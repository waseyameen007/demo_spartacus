/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { createBuilder, targetFromTargetString, } from '@angular-devkit/architect';
import { tags } from '@angular-devkit/core';
import * as browserSync from 'browser-sync';
import { createProxyMiddleware } from 'http-proxy-middleware';
import { join, resolve as pathResolve } from 'path';
import { EMPTY, combineLatest, from, of, zip } from 'rxjs';
import { catchError, concatMap, debounce, debounceTime, delay, finalize, ignoreElements, map, mapTo, startWith, switchMap, tap, } from 'rxjs/operators';
import * as url from 'url';
import { getAvailablePort, spawnAsObservable, waitUntilServerIsListening } from './utils';
/** Log messages to ignore and not rely to the logger */
const IGNORED_STDOUT_MESSAGES = [
    'server listening on',
    'Angular is running in development mode. Call enableProdMode() to enable production mode.',
];
export function execute(options, context) {
    const browserTarget = targetFromTargetString(options.browserTarget);
    const serverTarget = targetFromTargetString(options.serverTarget);
    const getBaseUrl = (bs) => `${bs.getOption('scheme')}://${bs.getOption('host')}:${bs.getOption('port')}`;
    const browserTargetRun = context.scheduleTarget(browserTarget, {
        serviceWorker: false,
        watch: true,
        progress: options.progress,
    });
    const serverTargetRun = context.scheduleTarget(serverTarget, {
        watch: true,
        progress: options.progress,
    });
    const bsInstance = browserSync.create();
    context.logger.error(tags.stripIndents `
  ****************************************************************************************
  This is a simple server for use in testing or debugging Angular applications locally.
  It hasn't been reviewed for security issues.

  DON'T USE IT FOR PRODUCTION!
  ****************************************************************************************
 `);
    return zip(browserTargetRun, serverTargetRun, getAvailablePort()).pipe(switchMap(([br, sr, nodeServerPort]) => {
        return combineLatest([br.output, sr.output]).pipe(
        // This is needed so that if both server and browser emit close to each other
        // we only emit once. This typically happens on the first build.
        debounceTime(120), switchMap(([b, s]) => {
            if (!s.success || !b.success) {
                return of([b, s]);
            }
            return startNodeServer(s, nodeServerPort, context.logger, !!options.inspect).pipe(mapTo([b, s]), catchError((err) => {
                context.logger.error(`A server error has occurred.\n${mapErrorToMessage(err)}`);
                return EMPTY;
            }));
        }), map(([b, s]) => [
            {
                success: b.success && s.success,
                error: b.error || s.error,
            },
            nodeServerPort,
        ]), tap(([builderOutput]) => {
            if (builderOutput.success) {
                context.logger.info('\nCompiled successfully.');
            }
        }), debounce(([builderOutput]) => builderOutput.success && !options.inspect
            ? waitUntilServerIsListening(nodeServerPort)
            : EMPTY));
    }), concatMap(([builderOutput, nodeServerPort]) => {
        if (!builderOutput.success) {
            return of(builderOutput);
        }
        if (bsInstance.active) {
            bsInstance.reload();
            return of(builderOutput);
        }
        else {
            return from(initBrowserSync(bsInstance, nodeServerPort, options, context)).pipe(tap((bs) => {
                const baseUrl = getBaseUrl(bs);
                context.logger.info(tags.oneLine `
                **
                Angular Universal Live Development Server is listening on ${baseUrl},
                open your browser on ${baseUrl}
                **
              `);
            }), mapTo(builderOutput));
        }
    }), map((builderOutput) => ({
        success: builderOutput.success,
        error: builderOutput.error,
        baseUrl: bsInstance && getBaseUrl(bsInstance),
    })), finalize(() => {
        if (bsInstance) {
            bsInstance.exit();
            bsInstance.cleanup();
        }
    }), catchError((error) => of({
        success: false,
        error: mapErrorToMessage(error),
    })));
}
function startNodeServer(serverOutput, port, logger, inspectMode = false) {
    const outputPath = serverOutput.outputPath;
    const path = join(outputPath, 'main.js');
    const env = Object.assign(Object.assign({}, process.env), { PORT: '' + port });
    const args = [`"${path}"`];
    if (inspectMode) {
        args.unshift('--inspect-brk');
    }
    return of(null).pipe(delay(0), // Avoid EADDRINUSE error since it will cause the kill event to be finish.
    switchMap(() => spawnAsObservable('node', args, { env, shell: true })), tap(({ stderr, stdout }) => {
        if (stderr) {
            logger.error(stderr);
        }
        if (stdout && !IGNORED_STDOUT_MESSAGES.some((x) => stdout.includes(x))) {
            logger.info(stdout);
        }
    }), ignoreElements(), 
    // Emit a signal after the process has been started
    startWith(undefined));
}
function initBrowserSync(browserSyncInstance, nodeServerPort, options, context) {
    return __awaiter(this, void 0, void 0, function* () {
        if (browserSyncInstance.active) {
            return browserSyncInstance;
        }
        const { port: browserSyncPort, open, host, publicHost, proxyConfig } = options;
        const bsPort = browserSyncPort || (yield getAvailablePort());
        const bsOptions = {
            proxy: {
                target: `localhost:${nodeServerPort}`,
                proxyOptions: {
                    xfwd: true,
                },
                proxyRes: [
                    (proxyRes) => {
                        if ('headers' in proxyRes) {
                            proxyRes.headers['cache-control'] = undefined;
                        }
                    },
                ],
                // proxyOptions is not in the typings
            },
            host,
            port: bsPort,
            ui: false,
            server: false,
            notify: false,
            ghostMode: false,
            logLevel: 'silent',
            open,
            https: getSslConfig(context.workspaceRoot, options),
        };
        const publicHostNormalized = publicHost && publicHost.endsWith('/')
            ? publicHost.substring(0, publicHost.length - 1)
            : publicHost;
        if (publicHostNormalized) {
            const { protocol, hostname, port, pathname } = url.parse(publicHostNormalized);
            const defaultSocketIoPath = '/browser-sync/socket.io';
            const defaultNamespace = '/browser-sync';
            const hasPathname = !!(pathname && pathname !== '/');
            const namespace = hasPathname ? pathname + defaultNamespace : defaultNamespace;
            const path = hasPathname ? pathname + defaultSocketIoPath : defaultSocketIoPath;
            bsOptions.socket = {
                namespace,
                path,
                domain: url.format({
                    protocol,
                    hostname,
                    port,
                }),
            };
            // When having a pathname we also need to create a reverse proxy because socket.io
            // will be listening on: 'http://localhost:4200/ssr/browser-sync/socket.io'
            // However users will typically have a reverse proxy that will redirect all matching requests
            // ex: http://testinghost.com/ssr -> http://localhost:4200 which will result in a 404.
            if (hasPathname) {
                // Remove leading slash
                (bsOptions.scriptPath = (p) => p.substring(1)),
                    (bsOptions.middleware = [
                        createProxyMiddleware(defaultSocketIoPath, {
                            target: url.format({
                                protocol: 'http',
                                hostname: host,
                                port: bsPort,
                                pathname: path,
                            }),
                            ws: true,
                            logLevel: 'silent',
                        }),
                    ]);
            }
        }
        if (proxyConfig) {
            if (!bsOptions.middleware) {
                bsOptions.middleware = [];
            }
            else if (!Array.isArray(bsOptions.middleware)) {
                bsOptions.middleware = [bsOptions.middleware];
            }
            bsOptions.middleware = [
                ...bsOptions.middleware,
                ...getProxyConfig(context.workspaceRoot, proxyConfig),
            ];
        }
        return new Promise((resolve, reject) => {
            browserSyncInstance.init(bsOptions, (error, bs) => {
                if (error) {
                    reject(error);
                }
                else {
                    resolve(bs);
                }
            });
        });
    });
}
function mapErrorToMessage(error) {
    if (error instanceof Error) {
        return error.message;
    }
    if (typeof error === 'string') {
        return error;
    }
    return '';
}
function getSslConfig(root, options) {
    const { ssl, sslCert, sslKey } = options;
    if (ssl && sslCert && sslKey) {
        return {
            key: pathResolve(root, sslKey),
            cert: pathResolve(root, sslCert),
        };
    }
    return ssl;
}
function getProxyConfig(root, proxyConfig) {
    const proxyPath = pathResolve(root, proxyConfig);
    let proxySettings;
    try {
        proxySettings = require(proxyPath);
    }
    catch (error) {
        if (error.code === 'MODULE_NOT_FOUND') {
            throw new Error(`Proxy config file ${proxyPath} does not exist.`);
        }
        throw error;
    }
    const proxies = Array.isArray(proxySettings) ? proxySettings : [proxySettings];
    const createdProxies = [];
    for (const proxy of proxies) {
        for (const [key, context] of Object.entries(proxy)) {
            if (typeof key === 'string') {
                createdProxies.push(createProxyMiddleware(key.replace(/^\*$/, '**').replace(/\/\*$/, ''), context));
            }
            else {
                createdProxies.push(createProxyMiddleware(key, context));
            }
        }
    }
    return createdProxies;
}
export default createBuilder(execute);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9tb2R1bGVzL2J1aWxkZXJzL3NyYy9zc3ItZGV2LXNlcnZlci9pbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0dBTUc7Ozs7Ozs7Ozs7QUFFSCxPQUFPLEVBR0wsYUFBYSxFQUNiLHNCQUFzQixHQUN2QixNQUFNLDJCQUEyQixDQUFDO0FBQ25DLE9BQU8sRUFBaUIsSUFBSSxFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFDM0QsT0FBTyxLQUFLLFdBQVcsTUFBTSxjQUFjLENBQUM7QUFFNUMsT0FBTyxFQUFFLHFCQUFxQixFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDOUQsT0FBTyxFQUFFLElBQUksRUFBRSxPQUFPLElBQUksV0FBVyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQ3BELE9BQU8sRUFBRSxLQUFLLEVBQWMsYUFBYSxFQUFFLElBQUksRUFBRSxFQUFFLEVBQUUsR0FBRyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQ3ZFLE9BQU8sRUFDTCxVQUFVLEVBQ1YsU0FBUyxFQUNULFFBQVEsRUFDUixZQUFZLEVBQ1osS0FBSyxFQUNMLFFBQVEsRUFDUixjQUFjLEVBQ2QsR0FBRyxFQUNILEtBQUssRUFDTCxTQUFTLEVBQ1QsU0FBUyxFQUNULEdBQUcsR0FDSixNQUFNLGdCQUFnQixDQUFDO0FBQ3hCLE9BQU8sS0FBSyxHQUFHLE1BQU0sS0FBSyxDQUFDO0FBRzNCLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxpQkFBaUIsRUFBRSwwQkFBMEIsRUFBRSxNQUFNLFNBQVMsQ0FBQztBQUUxRix3REFBd0Q7QUFDeEQsTUFBTSx1QkFBdUIsR0FBRztJQUM5QixxQkFBcUI7SUFDckIsMEZBQTBGO0NBQzNGLENBQUM7QUFPRixNQUFNLFVBQVUsT0FBTyxDQUNyQixPQUFtQyxFQUNuQyxPQUF1QjtJQUV2QixNQUFNLGFBQWEsR0FBRyxzQkFBc0IsQ0FB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Q0FBQyxDQUFDO1NBQ25FO1FBRUQsTUFBTSxLQUFLLENBQUM7S0FDYjtJQUVELE1BQU0sT0FBTyxHQUFHLEtBQUssQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxhQUFhLENBQUMsQ0FBQztJQUMvRSxNQUFNLGNBQWMsR0FBRyxFQUFFLENBQUM7SUFFMUIsS0FBSyxNQUFNLEtBQUssSUFBSSxPQUFPLEVBQUU7UUFDM0IsS0FBSyxNQUFNLENBQUMsR0FBRyxFQUFFLE9BQU8sQ0FBQyxJQUFJLE1BQU0sQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLEVBQUU7WUFDbEQsSUFBSSxPQUFPLEdBQUcsS0FBSyxRQUFRLEVBQUU7Z0JBQzNCLGNBQWMsQ0FBQyxJQUFJLENBQ2pCLHFCQUFxQixDQUNuQixHQUFHLENBQUMsT0FBTyxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsQ0FBQyxPQUFPLENBQUMsT0FBTyxFQUFFLEVBQUUsQ0FBQyxFQUM5QyxPQUFjLENBQ2tCLENBQ25DLENBQUM7YUFDSDtpQkFBTTtnQkFDTCxjQUFjLENBQUMsSUFBSSxDQUNqQixxQkFBcUIsQ0FBQyxHQUFHLEVBQUUsT0FBYyxDQUFrQyxDQUM1RSxDQUFDO2FBQ0g7U0FDRjtLQUNGO0lBRUQsT0FBTyxjQUFjLENBQUM7QUFDeEIsQ0FBQztBQUVELGVBQWUsYUFBYSxDQUE0QyxPQUFPLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG5pbXBvcnQge1xuICBCdWlsZGVyQ29udGV4dCxcbiAgQnVpbGRlck91dHB1dCxcbiAgY3JlYXRlQnVpbGRlcixcbiAgdGFyZ2V0RnJvbVRhcmdldFN0cmluZyxcbn0gZnJvbSAnQGFuZ3VsYXItZGV2a2l0L2FyY2hpdGVjdCc7XG5pbXBvcnQgeyBqc29uLCBsb2dnaW5nLCB0YWdzIH0gZnJvbSAnQGFuZ3VsYXItZGV2a2l0L2NvcmUnO1xuaW1wb3J0ICogYXMgYnJvd3NlclN5bmMgZnJvbSAnYnJvd3Nlci1zeW5jJztcbmltcG9ydCB7IGV4aXN0c1N5bmMgfSBmcm9tICdmcyc7XG5pbXBvcnQgeyBjcmVhdGVQcm94eU1pZGRsZXdhcmUgfSBmcm9tICdodHRwLXByb3h5LW1pZGRsZXdhcmUnO1xuaW1wb3J0IHsgam9pbiwgcmVzb2x2ZSBhcyBwYXRoUmVzb2x2ZSB9IGZyb20gJ3BhdGgnO1xuaW1wb3J0IHsgRU1QVFksIE9ic2VydmFibGUsIGNvbWJpbmVMYXRlc3QsIGZyb20sIG9mLCB6aXAgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7XG4gIGNhdGNoRXJyb3IsXG4gIGNvbmNhdE1hcCxcbiAgZGVib3VuY2UsXG4gIGRlYm91bmNlVGltZSxcbiAgZGVsYXksXG4gIGZpbmFsaXplLFxuICBpZ25vcmVFbGVtZW50cyxcbiAgbWFwLFxuICBtYXBUbyxcbiAgc3RhcnRXaXRoLFxuICBzd2l0Y2hNYXAsXG4gIHRhcCxcbn0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0ICogYXMgdXJsIGZyb20gJ3VybCc7XG5pbXBvcnQgeyBTY2hlbWEgfSBmcm9tICcuL3NjaGVtYSc7XG5cbmltcG9ydCB7IGdldEF2YWlsYWJsZVBvcnQsIHNwYXduQXNPYnNlcnZhYmxlLCB3YWl0VW50aWxTZXJ2ZXJJc0xpc3RlbmluZyB9IGZyb20gJy4vdXRpbHMnO1xuXG4vKiogTG9nIG1lc3NhZ2VzIHRvIGlnbm9yZSBhbmQgbm90IHJlbHkgdG8gdGhlIGxvZ2dlciAqL1xuY29uc3QgSUdOT1JFRF9TVERPVVRfTUVTU0FHRVMgPSBbXG4gICdzZXJ2ZXIgbGlzdGVuaW5nIG9uJyxcbiAgJ0FuZ3VsYXIgaXMgcnVubmluZyBpbiBkZXZlbG9wbWVudCBtb2RlLiBDYWxsIGVuYWJsZVByb2RNb2RlKCkgdG8gZW5hYmxlIHByb2R1Y3Rpb24gbW9kZS4nLFxuXTtcblxuZXhwb3J0IHR5cGUgU1NSRGV2U2VydmVyQnVpbGRlck9wdGlvbnMgPSBTY2hlbWEgJiBqc29uLkpzb25PYmplY3Q7XG5leHBvcnQgdHlwZSBTU1JEZXZTZXJ2ZXJCdWlsZGVyT3V0cHV0ID0gQnVpbGRlck91dHB1dCAmIHtcbiAgYmFzZVVybD86IHN0cmluZztcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBleGVjdXRlKFxuICBvcHRpb25zOiBTU1JEZXZTZXJ2ZXJCdWlsZGVyT3B0aW9ucyxcbiAgY29udGV4dDogQnVpbGRlckNvbnRleHQsXG4pOiBPYnNlcnZhYmxlPFNTUkRldlNlcnZlckJ1aWxkZXJPdXRwdXQ+IHtcbiAgY29uc3QgYnJvd3NlclRhcmdldCA9IHRhcmdldEZyb21UYXJnZXRTdHJpbmcob3B0aW9ucy5icm93c2VyVGFyZ2V0KTtcbiAgY29uc3Qgc2VydmVyVGFyZ2V0ID0gdGFyZ2V0RnJvbVRhcmdldFN0cmluZyhvcHRpb25zLnNlcnZlclRhcmdldCk7XG4gIGNvbnN0IGdldEJhc2VVcmwgPSAoYnM6IGJyb3dzZXJTeW5jLkJyb3dzZXJTeW5jSW5zdGFuY2UpID0+XG4gICAgYCR7YnMuZ2V0T3B0aW9uKCdzY2hlbWUnKX06Ly8ke2JzLmdldE9wdGlvbignaG9zdCcpfToke2JzLmdldE9wdGlvbigncG9ydCcpfWA7XG4gIGNvbnN0IGJyb3dzZXJUYXJnZXRSdW4gPSBjb250ZXh0LnNjaGVkdWxlVGFyZ2V0KGJyb3dzZXJUYXJnZXQsIHtcbiAgICBzZXJ2aWNlV29ya2VyOiBmYWxzZSxcbiAgICB3YXRjaDogdHJ1ZSxcbiAgICBwcm9ncmVzczogb3B0aW9ucy5wcm9ncmVzcyxcbiAgfSk7XG5cbiAgY29uc3Qgc2VydmVyVGFyZ2V0UnVuID0gY29udGV4dC5zY2hlZHVsZVRhcmdldChzZXJ2ZXJUYXJnZXQsIHtcbiAgICB3YXRjaDogdHJ1ZSxcbiAgICBwcm9ncmVzczogb3B0aW9ucy5wcm9ncmVzcyxcbiAgfSk7XG5cbiAgY29uc3QgYnNJbnN0YW5jZSA9IGJyb3dzZXJTeW5jLmNyZWF0ZSgpO1xuXG4gIGNvbnRleHQubG9nZ2VyLmVycm9yKHRhZ3Muc3RyaXBJbmRlbnRzYFxuICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gIFRoaXMgaXMgYSBzaW1wbGUgc2VydmVyIGZvciB1c2UgaW4gdGVzdGluZyBvciBkZWJ1Z2dpbmcgQW5ndWxhciBhcHBsaWNhdGlvbnMgbG9jYWxseS5cbiAgSXQgaGFzbid0IGJlZW4gcmV2aWV3ZWQgZm9yIHNlY3VyaXR5IGlzc3Vlcy5cblxuICBET04nVCBVU0UgSVQgRk9SIFBST0RVQ1RJT04hXG4gICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiBgKTtcblxuICByZXR1cm4gemlwKGJyb3dzZXJUYXJnZXRSdW4sIHNlcnZlclRhcmdldFJ1biwgZ2V0QXZhaWxhYmxlUG9ydCgpKS5waXBlKFxuICAgIHN3aXRjaE1hcCgoW2JyLCBzciwgbm9kZVNlcnZlclBvcnRdKSA9PiB7XG4gICAgICByZXR1cm4gY29tYmluZUxhdGVzdChbYnIub3V0cHV0LCBzci5vdXRwdXRdKS5waXBlKFxuICAgICAgICAvLyBUaGlzIGlzIG5lZWRlZCBzbyB0aGF0IGlmIGJvdGggc2VydmVyIGFuZCBicm93c2VyIGVtaXQgY2xvc2UgdG8gZWFjaCBvdGhlclxuICAgICAgICAvLyB3ZSBvbmx5IGVtaXQgb25jZS4gVGhpcyB0eXBpY2FsbHkgaGFwcGVucyBvbiB0aGUgZmlyc3QgYnVpbGQuXG4gICAgICAgIGRlYm91bmNlVGltZSgxMjApLFxuICAgICAgICBzd2l0Y2hNYXAoKFtiLCBzXSkgPT4ge1xuICAgICAgICAgIGlmICghcy5zdWNjZXNzIHx8ICFiLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHJldHVybiBvZihbYiwgc10pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBzdGFydE5vZGVTZXJ2ZXIocywgbm9kZVNlcnZlclBvcnQsIGNvbnRleHQubG9nZ2VyLCAhIW9wdGlvbnMuaW5zcGVjdCkucGlwZShcbiAgICAgICAgICAgIG1hcFRvKFtiLCBzXSksXG4gICAgICAgICAgICBjYXRjaEVycm9yKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgY29udGV4dC5sb2dnZXIuZXJyb3IoYEEgc2VydmVyIGVycm9yIGhhcyBvY2N1cnJlZC5cXG4ke21hcEVycm9yVG9NZXNzYWdlKGVycil9YCk7XG5cbiAgICAgICAgICAgICAgcmV0dXJuIEVNUFRZO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgKTtcbiAgICAgICAgfSksXG4gICAgICAgIG1hcChcbiAgICAgICAgICAoW2IsIHNdKSA9PlxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogYi5zdWNjZXNzICYmIHMuc3VjY2VzcyxcbiAgICAgICAgICAgICAgICBlcnJvcjogYi5lcnJvciB8fCBzLmVycm9yLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBub2RlU2VydmVyUG9ydCxcbiAgICAgICAgICAgIF0gYXMgW1NTUkRldlNlcnZlckJ1aWxkZXJPdXRwdXQsIG51bWJlcl0sXG4gICAgICAgICksXG4gICAgICAgIHRhcCgoW2J1aWxkZXJPdXRwdXRdKSA9PiB7XG4gICAgICAgICAgaWYgKGJ1aWxkZXJPdXRwdXQuc3VjY2Vzcykge1xuICAgICAgICAgICAgY29udGV4dC5sb2dnZXIuaW5mbygnXFxuQ29tcGlsZWQgc3VjY2Vzc2Z1bGx5LicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgICAgIGRlYm91bmNlKChbYnVpbGRlck91dHB1dF0pID0+XG4gICAgICAgICAgYnVpbGRlck91dHB1dC5zdWNjZXNzICYmICFvcHRpb25zLmluc3BlY3RcbiAgICAgICAgICAgID8gd2FpdFVudGlsU2VydmVySXNMaXN0ZW5pbmcobm9kZVNlcnZlclBvcnQpXG4gICAgICAgICAgICA6IEVNUFRZLFxuICAgICAgICApLFxuICAgICAgKTtcbiAgICB9KSxcbiAgICBjb25jYXRNYXAoKFtidWlsZGVyT3V0cHV0LCBub2RlU2VydmVyUG9ydF0pID0+IHtcbiAgICAgIGlmICghYnVpbGRlck91dHB1dC5zdWNjZXNzKSB7XG4gICAgICAgIHJldHVybiBvZihidWlsZGVyT3V0cHV0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGJzSW5zdGFuY2UuYWN0aXZlKSB7XG4gICAgICAgIGJzSW5zdGFuY2UucmVsb2FkKCk7XG5cbiAgICAgICAgcmV0dXJuIG9mKGJ1aWxkZXJPdXRwdXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZyb20oaW5pdEJyb3dzZXJTeW5jKGJzSW5zdGFuY2UsIG5vZGVTZXJ2ZXJQb3J0LCBvcHRpb25zLCBjb250ZXh0KSkucGlwZShcbiAgICAgICAgICB0YXAoKGJzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBiYXNlVXJsID0gZ2V0QmFzZVVybChicyk7XG4gICAgICAgICAgICBjb250ZXh0LmxvZ2dlci5pbmZvKHRhZ3Mub25lTGluZWBcbiAgICAgICAgICAgICAgICAqKlxuICAgICAgICAgICAgICAgIEFuZ3VsYXIgVW5pdmVyc2FsIExpdmUgRGV2ZWxvcG1lbnQgU2VydmVyIGlzIGxpc3RlbmluZyBvbiAke2Jhc2VVcmx9LFxuICAgICAgICAgICAgICAgIG9wZW4geW91ciBicm93c2VyIG9uICR7YmFzZVVybH1cbiAgICAgICAgICAgICAgICAqKlxuICAgICAgICAgICAgICBgKTtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBtYXBUbyhidWlsZGVyT3V0cHV0KSxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9KSxcbiAgICBtYXAoXG4gICAgICAoYnVpbGRlck91dHB1dCkgPT5cbiAgICAgICAgKHtcbiAgICAgICAgICBzdWNjZXNzOiBidWlsZGVyT3V0cHV0LnN1Y2Nlc3MsXG4gICAgICAgICAgZXJyb3I6IGJ1aWxkZXJPdXRwdXQuZXJyb3IsXG4gICAgICAgICAgYmFzZVVybDogYnNJbnN0YW5jZSAmJiBnZXRCYXNlVXJsKGJzSW5zdGFuY2UpLFxuICAgICAgICB9IGFzIFNTUkRldlNlcnZlckJ1aWxkZXJPdXRwdXQpLFxuICAgICksXG4gICAgZmluYWxpemUoKCkgPT4ge1xuICAgICAgaWYgKGJzSW5zdGFuY2UpIHtcbiAgICAgICAgYnNJbnN0YW5jZS5leGl0KCk7XG4gICAgICAgIGJzSW5zdGFuY2UuY2xlYW51cCgpO1xuICAgICAgfVxuICAgIH0pLFxuICAgIGNhdGNoRXJyb3IoKGVycm9yKSA9PlxuICAgICAgb2Yoe1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IG1hcEVycm9yVG9NZXNzYWdlKGVycm9yKSxcbiAgICAgIH0pLFxuICAgICksXG4gICk7XG59XG5cbmZ1bmN0aW9uIHN0YXJ0Tm9kZVNlcnZlcihcbiAgc2VydmVyT3V0cHV0OiBCdWlsZGVyT3V0cHV0LFxuICBwb3J0OiBudW1iZXIsXG4gIGxvZ2dlcjogbG9nZ2luZy5Mb2dnZXJBcGksXG4gIGluc3BlY3RNb2RlID0gZmFsc2UsXG4pOiBPYnNlcnZhYmxlPHZvaWQ+IHtcbiAgY29uc3Qgb3V0cHV0UGF0aCA9IHNlcnZlck91dHB1dC5vdXRwdXRQYXRoIGFzIHN0cmluZztcbiAgY29uc3QgcGF0aCA9IGpvaW4ob3V0cHV0UGF0aCwgJ21haW4uanMnKTtcbiAgY29uc3QgZW52ID0geyAuLi5wcm9jZXNzLmVudiwgUE9SVDogJycgKyBwb3J0IH07XG5cbiAgY29uc3QgYXJncyA9IFtgXCIke3BhdGh9XCJgXTtcbiAgaWYgKGluc3BlY3RNb2RlKSB7XG4gICAgYXJncy51bnNoaWZ0KCctLWluc3BlY3QtYnJrJyk7XG4gIH1cblxuICByZXR1cm4gb2YobnVsbCkucGlwZShcbiAgICBkZWxheSgwKSwgLy8gQXZvaWQgRUFERFJJTlVTRSBlcnJvciBzaW5jZSBpdCB3aWxsIGNhdXNlIHRoZSBraWxsIGV2ZW50IHRvIGJlIGZpbmlzaC5cbiAgICBzd2l0Y2hNYXAoKCkgPT4gc3Bhd25Bc09ic2VydmFibGUoJ25vZGUnLCBhcmdzLCB7IGVudiwgc2hlbGw6IHRydWUgfSkpLFxuICAgIHRhcCgoeyBzdGRlcnIsIHN0ZG91dCB9KSA9PiB7XG4gICAgICBpZiAoc3RkZXJyKSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcihzdGRlcnIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3Rkb3V0ICYmICFJR05PUkVEX1NURE9VVF9NRVNTQUdFUy5zb21lKCh4KSA9PiBzdGRvdXQuaW5jbHVkZXMoeCkpKSB7XG4gICAgICAgIGxvZ2dlci5pbmZvKHN0ZG91dCk7XG4gICAgICB9XG4gICAgfSksXG4gICAgaWdub3JlRWxlbWVudHMoKSxcbiAgICAvLyBFbWl0IGEgc2lnbmFsIGFmdGVyIHRoZSBwcm9jZXNzIGhhcyBiZWVuIHN0YXJ0ZWRcbiAgICBzdGFydFdpdGgodW5kZWZpbmVkKSxcbiAgKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gaW5pdEJyb3dzZXJTeW5jKFxuICBicm93c2VyU3luY0luc3RhbmNlOiBicm93c2VyU3luYy5Ccm93c2VyU3luY0luc3RhbmNlLFxuICBub2RlU2VydmVyUG9ydDogbnVtYmVyLFxuICBvcHRpb25zOiBTU1JEZXZTZXJ2ZXJCdWlsZGVyT3B0aW9ucyxcbiAgY29udGV4dDogQnVpbGRlckNvbnRleHQsXG4pOiBQcm9taXNlPGJyb3dzZXJTeW5jLkJyb3dzZXJTeW5jSW5zdGFuY2U+IHtcbiAgaWYgKGJyb3dzZXJTeW5jSW5zdGFuY2UuYWN0aXZlKSB7XG4gICAgcmV0dXJuIGJyb3dzZXJTeW5jSW5zdGFuY2U7XG4gIH1cblxuICBjb25zdCB7IHBvcnQ6IGJyb3dzZXJTeW5jUG9ydCwgb3BlbiwgaG9zdCwgcHVibGljSG9zdCwgcHJveHlDb25maWcgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGJzUG9ydCA9IGJyb3dzZXJTeW5jUG9ydCB8fCAoYXdhaXQgZ2V0QXZhaWxhYmxlUG9ydCgpKTtcbiAgY29uc3QgYnNPcHRpb25zOiBicm93c2VyU3luYy5PcHRpb25zID0ge1xuICAgIHByb3h5OiB7XG4gICAgICB0YXJnZXQ6IGBsb2NhbGhvc3Q6JHtub2RlU2VydmVyUG9ydH1gLFxuICAgICAgcHJveHlPcHRpb25zOiB7XG4gICAgICAgIHhmd2Q6IHRydWUsXG4gICAgICB9LFxuICAgICAgcHJveHlSZXM6IFtcbiAgICAgICAgKHByb3h5UmVzKSA9PiB7XG4gICAgICAgICAgaWYgKCdoZWFkZXJzJyBpbiBwcm94eVJlcykge1xuICAgICAgICAgICAgcHJveHlSZXMuaGVhZGVyc1snY2FjaGUtY29udHJvbCddID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgICAvLyBwcm94eU9wdGlvbnMgaXMgbm90IGluIHRoZSB0eXBpbmdzXG4gICAgfSBhcyBicm93c2VyU3luYy5Qcm94eU9wdGlvbnMgJiB7IHByb3h5T3B0aW9uczogeyB4ZndkOiBib29sZWFuIH0gfSxcbiAgICBob3N0LFxuICAgIHBvcnQ6IGJzUG9ydCxcbiAgICB1aTogZmFsc2UsXG4gICAgc2VydmVyOiBmYWxzZSxcbiAgICBub3RpZnk6IGZhbHNlLFxuICAgIGdob3N0TW9kZTogZmFsc2UsXG4gICAgbG9nTGV2ZWw6ICdzaWxlbnQnLFxuICAgIG9wZW4sXG4gICAgaHR0cHM6IGdldFNzbENvbmZpZyhjb250ZXh0LndvcmtzcGFjZVJvb3QsIG9wdGlvbnMpLFxuICB9O1xuXG4gIGNvbnN0IHB1YmxpY0hvc3ROb3JtYWxpemVkID1cbiAgICBwdWJsaWNIb3N0ICYmIHB1YmxpY0hvc3QuZW5kc1dpdGgoJy8nKVxuICAgICAgPyBwdWJsaWNIb3N0LnN1YnN0cmluZygwLCBwdWJsaWNIb3N0Lmxlbmd0aCAtIDEpXG4gICAgICA6IHB1YmxpY0hvc3Q7XG5cbiAgaWYgKHB1YmxpY0hvc3ROb3JtYWxpemVkKSB7XG4gICAgY29uc3QgeyBwcm90b2NvbCwgaG9zdG5hbWUsIHBvcnQsIHBhdGhuYW1lIH0gPSB1cmwucGFyc2UocHVibGljSG9zdE5vcm1hbGl6ZWQpO1xuICAgIGNvbnN0IGRlZmF1bHRTb2NrZXRJb1BhdGggPSAnL2Jyb3dzZXItc3luYy9zb2NrZXQuaW8nO1xuICAgIGNvbnN0IGRlZmF1bHROYW1lc3BhY2UgPSAnL2Jyb3dzZXItc3luYyc7XG4gICAgY29uc3QgaGFzUGF0aG5hbWUgPSAhIShwYXRobmFtZSAmJiBwYXRobmFtZSAhPT0gJy8nKTtcbiAgICBjb25zdCBuYW1lc3BhY2UgPSBoYXNQYXRobmFtZSA/IHBhdGhuYW1lICsgZGVmYXVsdE5hbWVzcGFjZSA6IGRlZmF1bHROYW1lc3BhY2U7XG4gICAgY29uc3QgcGF0aCA9IGhhc1BhdGhuYW1lID8gcGF0aG5hbWUgKyBkZWZhdWx0U29ja2V0SW9QYXRoIDogZGVmYXVsdFNvY2tldElvUGF0aDtcblxuICAgIGJzT3B0aW9ucy5zb2NrZXQgPSB7XG4gICAgICBuYW1lc3BhY2UsXG4gICAgICBwYXRoLFxuICAgICAgZG9tYWluOiB1cmwuZm9ybWF0KHtcbiAgICAgICAgcHJvdG9jb2wsXG4gICAgICAgIGhvc3RuYW1lLFxuICAgICAgICBwb3J0LFxuICAgICAgfSksXG4gICAgfTtcblxuICAgIC8vIFdoZW4gaGF2aW5nIGEgcGF0aG5hbWUgd2UgYWxzbyBuZWVkIHRvIGNyZWF0ZSBhIHJldmVyc2UgcHJveHkgYmVjYXVzZSBzb2NrZXQuaW9cbiAgICAvLyB3aWxsIGJlIGxpc3RlbmluZyBvbjogJ2h0dHA6Ly9sb2NhbGhvc3Q6NDIwMC9zc3IvYnJvd3Nlci1zeW5jL3NvY2tldC5pbydcbiAgICAvLyBIb3dldmVyIHVzZXJzIHdpbGwgdHlwaWNhbGx5IGhhdmUgYSByZXZlcnNlIHByb3h5IHRoYXQgd2lsbCByZWRpcmVjdCBhbGwgbWF0Y2hpbmcgcmVxdWVzdHNcbiAgICAvLyBleDogaHR0cDovL3Rlc3Rpbmdob3N0LmNvbS9zc3IgLT4gaHR0cDovL2xvY2FsaG9zdDo0MjAwIHdoaWNoIHdpbGwgcmVzdWx0IGluIGEgNDA0LlxuICAgIGlmIChoYXNQYXRobmFtZSkge1xuICAgICAgLy8gUmVtb3ZlIGxlYWRpbmcgc2xhc2hcbiAgICAgIChic09wdGlvbnMuc2NyaXB0UGF0aCA9IChwKSA9PiBwLnN1YnN0cmluZygxKSksXG4gICAgICAgIChic09wdGlvbnMubWlkZGxld2FyZSA9IFtcbiAgICAgICAgICBjcmVhdGVQcm94eU1pZGRsZXdhcmUoZGVmYXVsdFNvY2tldElvUGF0aCwge1xuICAgICAgICAgICAgdGFyZ2V0OiB1cmwuZm9ybWF0KHtcbiAgICAgICAgICAgICAgcHJvdG9jb2w6ICdodHRwJyxcbiAgICAgICAgICAgICAgaG9zdG5hbWU6IGhvc3QsXG4gICAgICAgICAgICAgIHBvcnQ6IGJzUG9ydCxcbiAgICAgICAgICAgICAgcGF0aG5hbWU6IHBhdGgsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHdzOiB0cnVlLFxuICAgICAgICAgICAgbG9nTGV2ZWw6ICdzaWxlbnQnLFxuICAgICAgICAgIH0pIGFzIGFueSxcbiAgICAgICAgXSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHByb3h5Q29uZmlnKSB7XG4gICAgaWYgKCFic09wdGlvbnMubWlkZGxld2FyZSkge1xuICAgICAgYnNPcHRpb25zLm1pZGRsZXdhcmUgPSBbXTtcbiAgICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KGJzT3B0aW9ucy5taWRkbGV3YXJlKSkge1xuICAgICAgYnNPcHRpb25zLm1pZGRsZXdhcmUgPSBbYnNPcHRpb25zLm1pZGRsZXdhcmVdO1xuICAgIH1cblxuICAgIGJzT3B0aW9ucy5taWRkbGV3YXJlID0gW1xuICAgICAgLi4uYnNPcHRpb25zLm1pZGRsZXdhcmUsXG4gICAgICAuLi5nZXRQcm94eUNvbmZpZyhjb250ZXh0LndvcmtzcGFjZVJvb3QsIHByb3h5Q29uZmlnKSxcbiAgICBdO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBicm93c2VyU3luY0luc3RhbmNlLmluaXQoYnNPcHRpb25zLCAoZXJyb3IsIGJzKSA9PiB7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc29sdmUoYnMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gbWFwRXJyb3JUb01lc3NhZ2UoZXJyb3I6IHVua25vd24pOiBzdHJpbmcge1xuICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgIHJldHVybiBlcnJvci5tZXNzYWdlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBlcnJvciA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZXJyb3I7XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbmZ1bmN0aW9uIGdldFNzbENvbmZpZyhcbiAgcm9vdDogc3RyaW5nLFxuICBvcHRpb25zOiBTU1JEZXZTZXJ2ZXJCdWlsZGVyT3B0aW9ucyxcbik6IGJyb3dzZXJTeW5jLkh0dHBzT3B0aW9ucyB8IHVuZGVmaW5lZCB8IGJvb2xlYW4ge1xuICBjb25zdCB7IHNzbCwgc3NsQ2VydCwgc3NsS2V5IH0gPSBvcHRpb25zO1xuICBpZiAoc3NsICYmIHNzbENlcnQgJiYgc3NsS2V5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtleTogcGF0aFJlc29sdmUocm9vdCwgc3NsS2V5KSxcbiAgICAgIGNlcnQ6IHBhdGhSZXNvbHZlKHJvb3QsIHNzbENlcnQpLFxuICAgIH07XG4gIH1cblxuICByZXR1cm4gc3NsO1xufVxuXG5mdW5jdGlvbiBnZXRQcm94eUNvbmZpZyhyb290OiBzdHJpbmcsIHByb3h5Q29uZmlnOiBzdHJpbmcpOiBicm93c2VyU3luYy5NaWRkbGV3YXJlSGFuZGxlcltdIHtcbiAgY29uc3QgcHJveHlQYXRoID0gcGF0aFJlc29sdmUocm9vdCwgcHJveHlDb25maWcpO1xuICBsZXQgcHJveHlTZXR0aW5nczogYW55O1xuICB0cnkge1xuICAgIHByb3h5U2V0dGluZ3MgPSByZXF1aXJlKHByb3h5UGF0aCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKGVycm9yLmNvZGUgPT09ICdNT0RVTEVfTk9UX0ZPVU5EJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBQcm94eSBjb25maWcgZmlsZSAke3Byb3h5UGF0aH0gZG9lcyBub3QgZXhpc3QuYCk7XG4gICAgfVxuXG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICBjb25zdCBwcm94aWVzID0gQXJyYXkuaXNBcnJheShwcm94eVNldHRpbmdzKSA/IHByb3h5U2V0dGluZ3MgOiBbcHJveHlTZXR0aW5nc107XG4gIGNvbnN0IGNyZWF0ZWRQcm94aWVzID0gW107XG5cbiAgZm9yIChjb25zdCBwcm94eSBvZiBwcm94aWVzKSB7XG4gICAgZm9yIChjb25zdCBba2V5LCBjb250ZXh0XSBvZiBPYmplY3QuZW50cmllcyhwcm94eSkpIHtcbiAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgICBjcmVhdGVkUHJveGllcy5wdXNoKFxuICAgICAgICAgIGNyZWF0ZVByb3h5TWlkZGxld2FyZShcbiAgICAgICAgICAgIGtleS5yZXBsYWNlKC9eXFwqJC8sICcqKicpLnJlcGxhY2UoL1xcL1xcKiQvLCAnJyksXG4gICAgICAgICAgICBjb250ZXh0IGFzIGFueSxcbiAgICAgICAgICApIGFzIGJyb3dzZXJTeW5jLk1pZGRsZXdhcmVIYW5kbGVyLFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3JlYXRlZFByb3hpZXMucHVzaChcbiAgICAgICAgICBjcmVhdGVQcm94eU1pZGRsZXdhcmUoa2V5LCBjb250ZXh0IGFzIGFueSkgYXMgYnJvd3NlclN5bmMuTWlkZGxld2FyZUhhbmRsZXIsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNyZWF0ZWRQcm94aWVzO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVCdWlsZGVyPFNTUkRldlNlcnZlckJ1aWxkZXJPcHRpb25zLCBCdWlsZGVyT3V0cHV0PihleGVjdXRlKTtcbiJdfQ==