/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define("@nguniversal/builders/src/prerender/worker", ["require", "exports", "@nguniversal/common/engine", "fs", "path"], factory);
    }
})(function (require, exports) {
    "use strict";
    var __syncRequire = typeof module === "object" && typeof module.exports === "object";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.render = exports.setup = void 0;
    const engine_1 = require("@nguniversal/common/engine");
    const fs = require("fs");
    const path = require("path");
    let workerArgs;
    let inlineCriticalCssProcessor;
    function setup(options) {
        workerArgs = options;
        if (workerArgs.inlineCriticalCss) {
            inlineCriticalCssProcessor = new engine_1.ÉµInlineCriticalCssProcessor({
                deployUrl: workerArgs.deployUrl,
                minify: workerArgs.minifyCss,
            });
        }
    }
    exports.setup = setup;
    /**
     * Renders each route in routes and writes them to <outputPath>/<route>/index.html.
     */
    function render(outputPath, serverBundlePath, route) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = {};
            const browserIndexOutputPath = path.join(outputPath, workerArgs.indexFile);
            const outputFolderPath = path.join(outputPath, route);
            const outputIndexPath = path.join(outputFolderPath, 'index.html');
            const { renderModule, AppServerModule } = yield __syncRequire ? Promise.resolve().then(() => require(serverBundlePath)) : new Promise((resolve_1, reject_1) => { require([serverBundlePath], resolve_1, reject_1); });
            const indexBaseName = fs.existsSync(path.join(outputPath, 'index.original.html'))
                ? 'index.original.html'
                : workerArgs.indexFile;
            const browserIndexInputPath = path.join(outputPath, indexBaseName);
            let indexHtml = yield fs.promises.readFile(browserIndexInputPath, 'utf8');
            indexHtml = indexHtml.replace('</html>', '<!-- This page was prerendered with Angular Universal -->\n</html>');
            if (workerArgs.inlineCriticalCss) {
                // Workaround for https://github.com/GoogleChromeLabs/critters/issues/64
                indexHtml = indexHtml.replace(/ media=\"print\" onload=\"this\.media='all'"><noscript><link .+?><\/noscript>/g, '>');
            }
            let html = yield renderModule(AppServerModule, {
                document: indexHtml,
                url: route,
            });
            if (inlineCriticalCssProcessor) {
                const { content, warnings, errors } = yield inlineCriticalCssProcessor.process(html, {
                    outputPath,
                });
                result.errors = errors;
                result.warnings = warnings;
                html = content;
            }
            // This case happens when we are prerendering "/".
            if (browserIndexOutputPath === outputIndexPath) {
                const browserIndexOutputPathOriginal = path.join(outputPath, 'index.original.html');
                fs.renameSync(browserIndexOutputPath, browserIndexOutputPathOriginal);
            }
            fs.mkdirSync(outputFolderPath, { recursive: true });
            fs.writeFileSync(outputIndexPath, html);
            return result;
        });
    }
    exports.render = render;
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid29ya2VyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vbW9kdWxlcy9idWlsZGVycy9zcmMvcHJlcmVuZGVyL3dvcmtlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0dBTUc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBRUgsdURBQXVHO0lBQ3ZHLHlCQUF5QjtJQUN6Qiw2QkFBNkI7SUFjN0IsSUFBSSxVQUEyQixDQUFDO0lBQ2hDLElBQUksMEJBQWtFLENBQUM7SUFFdkUsU0FBZ0IsS0FBSyxDQUFDLE9BQXdCO1FBQzVDLFVBQVUsR0FBRyxPQUFPLENBQUM7UUFDckIsSUFBSSxVQUFVLENBQUMsaUJBQWlCLEVBQUU7WUFDaEMsMEJBQTBCLEdBQUcsSUFBSSxvQ0FBMEIsQ0FBQztnQkFDMUQsU0FBUyxFQUFFLFVBQVUsQ0FBQyxTQUFTO2dCQUMvQixNQUFNLEVBQUUsVUFBVSxDQUFDLFNBQVM7YUFDN0IsQ0FBQyxDQUFDO1NBQ0o7SUFDSCxDQUFDO0lBUkQsc0JBUUM7SUFFRDs7T0FFRztJQUNILFNBQXNCLE1BQU0sQ0FDMUIsVUFBa0IsRUFDbEIsZ0JBQXdCLEVBQ3hCLEtBQWE7O1lBRWIsTUFBTSxNQUFNLEdBQUcsRUFBa0IsQ0FBQztZQUNsQyxNQUFNLHNCQUFzQixHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLFVBQVUsQ0FBQyxTQUFTLENBQUMsQ0FBQztZQUMzRSxNQUFNLGdCQUFnQixHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLEtBQUssQ0FBQyxDQUFDO1lBQ3RELE1BQU0sZUFBZSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLEVBQUUsWUFBWSxDQUFDLENBQUM7WUFFbEUsTUFBTSxFQUFFLFlBQVksRUFBRSxlQUFlLEVBQUUsR0FBRywyREFBYSxnQkFBZ0IscURBQWhCLGdCQUFnQiwyQkFBQyxDQUFDO1lBRXpFLE1BQU0sYUFBYSxHQUFHLEVBQUUsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUUscUJBQXFCLENBQUMsQ0FBQztnQkFDL0UsQ0FBQyxDQUFDLHFCQUFxQjtnQkFDdkIsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxTQUFTLENBQUM7WUFDekIsTUFBTSxxQkFBcUIsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRSxhQUFhLENBQUMsQ0FBQztZQUNuRSxJQUFJLFNBQVMsR0FBRyxNQUFNLEVBQUUsQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLHFCQUFxQixFQUFFLE1BQU0sQ0FBQyxDQUFDO1lBQzFFLFNBQVMsR0FBRyxTQUFTLENBQUMsT0FBTyxDQUMzQixTQUFTLEVBQ1Qsb0VBQW9FLENBQ3JFLENBQUM7WUFDRixJQUFJLFVBQVUsQ0FBQyxpQkFBaUIsRUFBRTtnQkFDaEMsd0VBQXdFO2dCQUN4RSxTQUFTLEdBQUcsU0FBUyxDQUFDLE9BQU8sQ0FDM0IsZ0ZBQWdGLEVBQ2hGLEdBQUcsQ0FDSixDQUFDO2FBQ0g7WUFFRCxJQUFJLElBQUksR0FBRyxNQUFNLFlBQVksQ0FBQyxlQUFlLEVBQUU7Z0JBQzdDLFFBQVEsRUFBRSxTQUFTO2dCQUNuQixHQUFHLEVBQUUsS0FBSzthQUNYLENBQUMsQ0FBQztZQUVILElBQUksMEJBQTBCLEVBQUU7Z0JBQzlCLE1BQU0sRUFBRSxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0sRUFBRSxHQUFHLE1BQU0sMEJBQTBCLENBQUMsT0FBTyxDQUFDLElBQUksRUFBRTtvQkFDbkYsVUFBVTtpQkFDWCxDQUFDLENBQUM7Z0JBQ0gsTUFBTSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7Z0JBQ3ZCLE1BQU0sQ0FBQyxRQUFRLEdBQUcsUUFBUSxDQUFDO2dCQUMzQixJQUFJLEdBQUcsT0FBTyxDQUFDO2FBQ2hCO1lBRUQsa0RBQWtEO1lBQ2xELElBQUksc0JBQXNCLEtBQUssZUFBZSxFQUFFO2dCQUM5QyxNQUFNLDhCQUE4QixHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLHFCQUFxQixDQUFDLENBQUM7Z0JBQ3BGLEVBQUUsQ0FBQyxVQUFVLENBQUMsc0JBQXNCLEVBQUUsOEJBQThCLENBQUMsQ0FBQzthQUN2RTtZQUVELEVBQUUsQ0FBQyxTQUFTLENBQUMsZ0JBQWdCLEVBQUUsRUFBRSxTQUFTLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQztZQUNwRCxFQUFFLENBQUMsYUFBYSxDQUFDLGVBQWUsRUFBRSxJQUFJLENBQUMsQ0FBQztZQUV4QyxPQUFPLE1BQU0sQ0FBQztRQUNoQixDQUFDO0tBQUE7SUFyREQsd0JBcURDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5cbmltcG9ydCB7IMm1SW5saW5lQ3JpdGljYWxDc3NQcm9jZXNzb3IgYXMgSW5saW5lQ3JpdGljYWxDc3NQcm9jZXNzb3IgfSBmcm9tICdAbmd1bml2ZXJzYWwvY29tbW9uL2VuZ2luZSc7XG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcyc7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFdvcmtlclNldHVwQXJncyB7XG4gIGluZGV4RmlsZTogc3RyaW5nO1xuICBkZXBsb3lVcmw6IHN0cmluZztcbiAgaW5saW5lQ3JpdGljYWxDc3M6IGJvb2xlYW47XG4gIG1pbmlmeUNzczogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZW5kZXJSZXN1bHQge1xuICBlcnJvcnM/OiBzdHJpbmdbXTtcbiAgd2FybmluZ3M/OiBzdHJpbmdbXTtcbn1cblxubGV0IHdvcmtlckFyZ3M6IFdvcmtlclNldHVwQXJncztcbmxldCBpbmxpbmVDcml0aWNhbENzc1Byb2Nlc3NvcjogSW5saW5lQ3JpdGljYWxDc3NQcm9jZXNzb3IgfCB1bmRlZmluZWQ7XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXR1cChvcHRpb25zOiBXb3JrZXJTZXR1cEFyZ3MpOiB2b2lkIHtcbiAgd29ya2VyQXJncyA9IG9wdGlvbnM7XG4gIGlmICh3b3JrZXJBcmdzLmlubGluZUNyaXRpY2FsQ3NzKSB7XG4gICAgaW5saW5lQ3JpdGljYWxDc3NQcm9jZXNzb3IgPSBuZXcgSW5saW5lQ3JpdGljYWxDc3NQcm9jZXNzb3Ioe1xuICAgICAgZGVwbG95VXJsOiB3b3JrZXJBcmdzLmRlcGxveVVybCxcbiAgICAgIG1pbmlmeTogd29ya2VyQXJncy5taW5pZnlDc3MsXG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW5kZXJzIGVhY2ggcm91dGUgaW4gcm91dGVzIGFuZCB3cml0ZXMgdGhlbSB0byA8b3V0cHV0UGF0aD4vPHJvdXRlPi9pbmRleC5odG1sLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVuZGVyKFxuICBvdXRwdXRQYXRoOiBzdHJpbmcsXG4gIHNlcnZlckJ1bmRsZVBhdGg6IHN0cmluZyxcbiAgcm91dGU6IHN0cmluZyxcbik6IFByb21pc2U8UmVuZGVyUmVzdWx0PiB7XG4gIGNvbnN0IHJlc3VsdCA9IHt9IGFzIFJlbmRlclJlc3VsdDtcbiAgY29uc3QgYnJvd3NlckluZGV4T3V0cHV0UGF0aCA9IHBhdGguam9pbihvdXRwdXRQYXRoLCB3b3JrZXJBcmdzLmluZGV4RmlsZSk7XG4gIGNvbnN0IG91dHB1dEZvbGRlclBhdGggPSBwYXRoLmpvaW4ob3V0cHV0UGF0aCwgcm91dGUpO1xuICBjb25zdCBvdXRwdXRJbmRleFBhdGggPSBwYXRoLmpvaW4ob3V0cHV0Rm9sZGVyUGF0aCwgJ2luZGV4Lmh0bWwnKTtcblxuICBjb25zdCB7IHJlbmRlck1vZHVsZSwgQXBwU2VydmVyTW9kdWxlIH0gPSBhd2FpdCBpbXBvcnQoc2VydmVyQnVuZGxlUGF0aCk7XG5cbiAgY29uc3QgaW5kZXhCYXNlTmFtZSA9IGZzLmV4aXN0c1N5bmMocGF0aC5qb2luKG91dHB1dFBhdGgsICdpbmRleC5vcmlnaW5hbC5odG1sJykpXG4gICAgPyAnaW5kZXgub3JpZ2luYWwuaHRtbCdcbiAgICA6IHdvcmtlckFyZ3MuaW5kZXhGaWxlO1xuICBjb25zdCBicm93c2VySW5kZXhJbnB1dFBhdGggPSBwYXRoLmpvaW4ob3V0cHV0UGF0aCwgaW5kZXhCYXNlTmFtZSk7XG4gIGxldCBpbmRleEh0bWwgPSBhd2FpdCBmcy5wcm9taXNlcy5yZWFkRmlsZShicm93c2VySW5kZXhJbnB1dFBhdGgsICd1dGY4Jyk7XG4gIGluZGV4SHRtbCA9IGluZGV4SHRtbC5yZXBsYWNlKFxuICAgICc8L2h0bWw+JyxcbiAgICAnPCEtLSBUaGlzIHBhZ2Ugd2FzIHByZXJlbmRlcmVkIHdpdGggQW5ndWxhciBVbml2ZXJzYWwgLS0+XFxuPC9odG1sPicsXG4gICk7XG4gIGlmICh3b3JrZXJBcmdzLmlubGluZUNyaXRpY2FsQ3NzKSB7XG4gICAgLy8gV29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL0dvb2dsZUNocm9tZUxhYnMvY3JpdHRlcnMvaXNzdWVzLzY0XG4gICAgaW5kZXhIdG1sID0gaW5kZXhIdG1sLnJlcGxhY2UoXG4gICAgICAvIG1lZGlhPVxcXCJwcmludFxcXCIgb25sb2FkPVxcXCJ0aGlzXFwubWVkaWE9J2FsbCdcIj48bm9zY3JpcHQ+PGxpbmsgLis/PjxcXC9ub3NjcmlwdD4vZyxcbiAgICAgICc+JyxcbiAgICApO1xuICB9XG5cbiAgbGV0IGh0bWwgPSBhd2FpdCByZW5kZXJNb2R1bGUoQXBwU2VydmVyTW9kdWxlLCB7XG4gICAgZG9jdW1lbnQ6IGluZGV4SHRtbCxcbiAgICB1cmw6IHJvdXRlLFxuICB9KTtcblxuICBpZiAoaW5saW5lQ3JpdGljYWxDc3NQcm9jZXNzb3IpIHtcbiAgICBjb25zdCB7IGNvbnRlbnQsIHdhcm5pbmdzLCBlcnJvcnMgfSA9IGF3YWl0IGlubGluZUNyaXRpY2FsQ3NzUHJvY2Vzc29yLnByb2Nlc3MoaHRtbCwge1xuICAgICAgb3V0cHV0UGF0aCxcbiAgICB9KTtcbiAgICByZXN1bHQuZXJyb3JzID0gZXJyb3JzO1xuICAgIHJlc3VsdC53YXJuaW5ncyA9IHdhcm5pbmdzO1xuICAgIGh0bWwgPSBjb250ZW50O1xuICB9XG5cbiAgLy8gVGhpcyBjYXNlIGhhcHBlbnMgd2hlbiB3ZSBhcmUgcHJlcmVuZGVyaW5nIFwiL1wiLlxuICBpZiAoYnJvd3NlckluZGV4T3V0cHV0UGF0aCA9PT0gb3V0cHV0SW5kZXhQYXRoKSB7XG4gICAgY29uc3QgYnJvd3NlckluZGV4T3V0cHV0UGF0aE9yaWdpbmFsID0gcGF0aC5qb2luKG91dHB1dFBhdGgsICdpbmRleC5vcmlnaW5hbC5odG1sJyk7XG4gICAgZnMucmVuYW1lU3luYyhicm93c2VySW5kZXhPdXRwdXRQYXRoLCBicm93c2VySW5kZXhPdXRwdXRQYXRoT3JpZ2luYWwpO1xuICB9XG5cbiAgZnMubWtkaXJTeW5jKG91dHB1dEZvbGRlclBhdGgsIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xuICBmcy53cml0ZUZpbGVTeW5jKG91dHB1dEluZGV4UGF0aCwgaHRtbCk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbiJdfQ==