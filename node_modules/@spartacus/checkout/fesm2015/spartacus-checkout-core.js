import * as i0 from '@angular/core';
import { Injectable, NgModule, InjectionToken } from '@angular/core';
import * as i2 from '@spartacus/core';
import { StateUtils, PROCESS_FEATURE, MULTI_CART_DATA, UserAddressEvent, UpdateUserAddressEvent, DeleteUserAddressEvent, ProcessSelectors, getLastValueSync, OCC_USER_ID_ANONYMOUS, B2BPaymentTypeEnum, PageMetaResolver, PageType, normalizeHttpError, SiteContextActions, UserActions, withdrawOn, AuthActions, CartActions, ORDER_TYPE } from '@spartacus/core';
import * as i1 from '@spartacus/checkout/root';
import { OrderPlacedEvent, CheckoutDeliveryFacade, CheckoutPaymentFacade, CheckoutFacade, PaymentTypeFacade, CheckoutCostCenterFacade, ClearCheckoutFacade } from '@spartacus/checkout/root';
import { SavedCartEvent, SaveCartSuccessEvent, RestoreSavedCartSuccessEvent } from '@spartacus/cart/saved-cart/root';
import { Subscription, combineLatest, of, from } from 'rxjs';
import { filter, take, map, withLatestFrom, tap, pluck, shareReplay, switchMap, catchError, mergeMap, concatMap } from 'rxjs/operators';
import * as i1$1 from '@ngrx/store';
import { createFeatureSelector, createSelector, select, StoreModule } from '@ngrx/store';
import { CommonModule } from '@angular/common';
import * as i1$2 from '@ngrx/effects';
import { ofType, Effect, EffectsModule } from '@ngrx/effects';
import { __decorate } from 'tslib';

class CheckoutAdapter {
}

class CheckoutConnector {
    constructor(adapter) {
        this.adapter = adapter;
    }
    placeOrder(userId, cartId, termsChecked) {
        return this.adapter.placeOrder(userId, cartId, termsChecked);
    }
    loadCheckoutDetails(userId, cartId) {
        return this.adapter.loadCheckoutDetails(userId, cartId);
    }
    clearCheckoutDeliveryAddress(userId, cartId) {
        return this.adapter.clearCheckoutDeliveryAddress(userId, cartId);
    }
    clearCheckoutDeliveryMode(userId, cartId) {
        return this.adapter.clearCheckoutDeliveryMode(userId, cartId);
    }
}
CheckoutConnector.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutConnector, deps: [{ token: CheckoutAdapter }], target: i0.ɵɵFactoryTarget.Injectable });
CheckoutConnector.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutConnector });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutConnector, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: CheckoutAdapter }]; } });

class CheckoutCostCenterAdapter {
}

class CheckoutCostCenterConnector {
    constructor(adapter) {
        this.adapter = adapter;
    }
    setCostCenter(userId, cartId, costCenterId) {
        return this.adapter.setCostCenter(userId, cartId, costCenterId);
    }
}
CheckoutCostCenterConnector.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutCostCenterConnector, deps: [{ token: CheckoutCostCenterAdapter }], target: i0.ɵɵFactoryTarget.Injectable });
CheckoutCostCenterConnector.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutCostCenterConnector });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutCostCenterConnector, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: CheckoutCostCenterAdapter }]; } });

class CheckoutDeliveryAdapter {
}

class CheckoutDeliveryConnector {
    constructor(adapter) {
        this.adapter = adapter;
    }
    createAddress(userId, cartId, address) {
        return this.adapter.createAddress(userId, cartId, address);
    }
    setAddress(userId, cartId, addressId) {
        return this.adapter.setAddress(userId, cartId, addressId);
    }
    setMode(userId, cartId, deliveryModeId) {
        return this.adapter.setMode(userId, cartId, deliveryModeId);
    }
    getMode(userId, cartId) {
        return this.adapter.getMode(userId, cartId);
    }
    getSupportedModes(userId, cartId) {
        return this.adapter.getSupportedModes(userId, cartId);
    }
}
CheckoutDeliveryConnector.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutDeliveryConnector, deps: [{ token: CheckoutDeliveryAdapter }], target: i0.ɵɵFactoryTarget.Injectable });
CheckoutDeliveryConnector.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutDeliveryConnector });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutDeliveryConnector, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: CheckoutDeliveryAdapter }]; } });

class PaymentTypeAdapter {
}

class PaymentTypeConnector {
    constructor(adapter) {
        this.adapter = adapter;
    }
    getPaymentTypes() {
        return this.adapter.loadPaymentTypes();
    }
    setPaymentType(userId, cartId, typeCode, poNumber) {
        return this.adapter.setPaymentType(userId, cartId, typeCode, poNumber);
    }
}
PaymentTypeConnector.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PaymentTypeConnector, deps: [{ token: PaymentTypeAdapter }], target: i0.ɵɵFactoryTarget.Injectable });
PaymentTypeConnector.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PaymentTypeConnector });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PaymentTypeConnector, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: PaymentTypeAdapter }]; } });

class CheckoutPaymentAdapter {
}

class CheckoutPaymentConnector {
    constructor(adapter) {
        this.adapter = adapter;
    }
    create(userId, cartId, paymentDetails) {
        return this.adapter.create(userId, cartId, paymentDetails);
    }
    set(userId, cartId, paymentDetailsId) {
        return this.adapter.set(userId, cartId, paymentDetailsId);
    }
    getCardTypes() {
        return this.adapter.loadCardTypes();
    }
}
CheckoutPaymentConnector.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutPaymentConnector, deps: [{ token: CheckoutPaymentAdapter }], target: i0.ɵɵFactoryTarget.Injectable });
CheckoutPaymentConnector.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutPaymentConnector });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutPaymentConnector, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: CheckoutPaymentAdapter }]; } });

class CheckoutReplenishmentOrderAdapter {
}

class CheckoutReplenishmentOrderConnector {
    constructor(adapter) {
        this.adapter = adapter;
    }
    scheduleReplenishmentOrder(cartId, scheduleReplenishmentForm, termsChecked, userId) {
        return this.adapter.scheduleReplenishmentOrder(cartId, scheduleReplenishmentForm, termsChecked, userId);
    }
}
CheckoutReplenishmentOrderConnector.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutReplenishmentOrderConnector, deps: [{ token: CheckoutReplenishmentOrderAdapter }], target: i0.ɵɵFactoryTarget.Injectable });
CheckoutReplenishmentOrderConnector.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutReplenishmentOrderConnector });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutReplenishmentOrderConnector, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: CheckoutReplenishmentOrderAdapter }]; } });

const LOAD_CARD_TYPES = '[Checkout] Load Card Types';
const LOAD_CARD_TYPES_FAIL = '[Checkout] Load Card Fail';
const LOAD_CARD_TYPES_SUCCESS = '[Checkout] Load Card Success';
class LoadCardTypes {
    constructor() {
        this.type = LOAD_CARD_TYPES;
    }
}
class LoadCardTypesFail {
    constructor(payload) {
        this.payload = payload;
        this.type = LOAD_CARD_TYPES_FAIL;
    }
}
class LoadCardTypesSuccess {
    constructor(payload) {
        this.payload = payload;
        this.type = LOAD_CARD_TYPES_SUCCESS;
    }
}

const CHECKOUT_FEATURE = 'checkout';
const CHECKOUT_DETAILS = '[Checkout] Checkout Details';
const SET_DELIVERY_ADDRESS_PROCESS_ID = 'setDeliveryAddress';
const SET_DELIVERY_MODE_PROCESS_ID = 'setDeliveryMode';
const SET_SUPPORTED_DELIVERY_MODE_PROCESS_ID = 'setSupportedDeliveryMode';
const SET_PAYMENT_DETAILS_PROCESS_ID = 'setPaymentDetails';
const GET_PAYMENT_TYPES_PROCESS_ID = 'getPaymentTypes';
const SET_COST_CENTER_PROCESS_ID = 'setCostCenter';
const PLACED_ORDER_PROCESS_ID = 'placeOrder';

const CLEAR_CHECKOUT_DELIVERY_ADDRESS = '[Checkout] Clear Checkout Delivery Address';
const CLEAR_CHECKOUT_DELIVERY_ADDRESS_SUCCESS = '[Checkout] Clear Checkout Delivery Address Success';
const CLEAR_CHECKOUT_DELIVERY_ADDRESS_FAIL = '[Checkout] Clear Checkout Delivery Address Fail';
const CLEAR_CHECKOUT_DELIVERY_MODE = '[Checkout] Clear Checkout Delivery Mode';
const CLEAR_CHECKOUT_DELIVERY_MODE_SUCCESS = '[Checkout] Clear Checkout Delivery Mode Success';
const CLEAR_CHECKOUT_DELIVERY_MODE_FAIL = '[Checkout] Clear Checkout Delivery Mode Fail';
const ADD_DELIVERY_ADDRESS = '[Checkout] Add Delivery Address';
const ADD_DELIVERY_ADDRESS_FAIL = '[Checkout] Add Delivery Address Fail';
const ADD_DELIVERY_ADDRESS_SUCCESS = '[Checkout] Add Delivery Address Success';
const SET_DELIVERY_ADDRESS = '[Checkout] Set Delivery Address';
const SET_DELIVERY_ADDRESS_FAIL = '[Checkout] Set Delivery Address Fail';
const SET_DELIVERY_ADDRESS_SUCCESS = '[Checkout] Set Delivery Address Success';
const RESET_SET_DELIVERY_ADDRESS_PROCESS = '[Checkout] Reset Set Delivery Address Process';
const LOAD_SUPPORTED_DELIVERY_MODES = '[Checkout] Load Supported Delivery Modes';
const LOAD_SUPPORTED_DELIVERY_MODES_FAIL = '[Checkout] Load Supported Delivery Modes Fail';
const LOAD_SUPPORTED_DELIVERY_MODES_SUCCESS = '[Checkout] Load Supported Delivery Modes Success';
const CLEAR_SUPPORTED_DELIVERY_MODES = '[Checkout] Clear Supported Delivery Modes';
const SET_DELIVERY_MODE = '[Checkout] Set Delivery Mode';
const SET_DELIVERY_MODE_FAIL = '[Checkout] Set Delivery Mode Fail';
const SET_DELIVERY_MODE_SUCCESS = '[Checkout] Set Delivery Mode Success';
const RESET_SET_DELIVERY_MODE_PROCESS = '[Checkout] Reset Set Delivery Mode Process';
const SET_SUPPORTED_DELIVERY_MODES = '[Checkout] Set Supported Delivery Modes';
const SET_SUPPORTED_DELIVERY_MODES_FAIL = '[Checkout] Set Supported Delivery Modes Fail';
const SET_SUPPORTED_DELIVERY_MODES_SUCCESS = '[Checkout] Set Supported Delivery Modes Success';
const RESET_SUPPORTED_SET_DELIVERY_MODES_PROCESS = '[Checkout] Reset Set Supported Delivery Modes Process';
const CREATE_PAYMENT_DETAILS = '[Checkout] Create Payment Details';
const CREATE_PAYMENT_DETAILS_FAIL = '[Checkout] Create Payment Details Fail';
const CREATE_PAYMENT_DETAILS_SUCCESS = '[Checkout] Create Payment Details Success';
const SET_PAYMENT_DETAILS = '[Checkout] Set Payment Details';
const SET_PAYMENT_DETAILS_FAIL = '[Checkout] Set Payment Details Fail';
const SET_PAYMENT_DETAILS_SUCCESS = '[Checkout] Set Payment Details Success';
const RESET_SET_PAYMENT_DETAILS_PROCESS = '[Checkout] Reset Set Payment Details Process';
const PLACE_ORDER = '[Checkout] Place Order';
const PLACE_ORDER_FAIL = '[Checkout] Place Order Fail';
const PLACE_ORDER_SUCCESS = '[Checkout] Place Order Success';
const CLEAR_PLACE_ORDER = '[Checkout] Clear Place Order';
const CLEAR_CHECKOUT_STEP = '[Checkout] Clear One Checkout Step';
const CLEAR_CHECKOUT_DATA = '[Checkout] Clear Checkout Data';
const LOAD_CHECKOUT_DETAILS = '[Checkout] Load Checkout Details';
const LOAD_CHECKOUT_DETAILS_FAIL = '[Checkout] Load Checkout Details Fail';
const LOAD_CHECKOUT_DETAILS_SUCCESS = '[Checkout] Load Checkout Details Success';
const CHECKOUT_CLEAR_MISCS_DATA = '[Checkout] Clear Miscs Data';
const PAYMENT_PROCESS_SUCCESS = '[Checkout] Payment Process Success';
const SET_COST_CENTER = '[Checkout] Set Cost Center';
const SET_COST_CENTER_FAIL = '[Checkout] Set Cost Center Fail';
const SET_COST_CENTER_SUCCESS = '[Checkout] Set Cost Center Success';
const RESET_SET_COST_CENTER_PROCESS = '[Checkout] Reset Set Cost Center Process';
class AddDeliveryAddress {
    constructor(payload) {
        this.payload = payload;
        this.type = ADD_DELIVERY_ADDRESS;
    }
}
class AddDeliveryAddressFail {
    constructor(payload) {
        this.payload = payload;
        this.type = ADD_DELIVERY_ADDRESS_FAIL;
    }
}
class AddDeliveryAddressSuccess {
    constructor(payload) {
        this.payload = payload;
        this.type = ADD_DELIVERY_ADDRESS_SUCCESS;
    }
}
class SetDeliveryAddress extends StateUtils.EntityLoadAction {
    constructor(payload) {
        super(PROCESS_FEATURE, SET_DELIVERY_ADDRESS_PROCESS_ID);
        this.payload = payload;
        this.type = SET_DELIVERY_ADDRESS;
    }
}
class SetDeliveryAddressFail extends StateUtils.EntityFailAction {
    constructor(payload) {
        super(PROCESS_FEATURE, SET_DELIVERY_ADDRESS_PROCESS_ID, payload);
        this.payload = payload;
        this.type = SET_DELIVERY_ADDRESS_FAIL;
    }
}
class SetDeliveryAddressSuccess extends StateUtils.EntitySuccessAction {
    constructor(payload) {
        super(PROCESS_FEATURE, SET_DELIVERY_ADDRESS_PROCESS_ID);
        this.payload = payload;
        this.type = SET_DELIVERY_ADDRESS_SUCCESS;
    }
}
class ResetSetDeliveryAddressProcess extends StateUtils.EntityLoaderResetAction {
    constructor() {
        super(PROCESS_FEATURE, SET_DELIVERY_ADDRESS_PROCESS_ID);
        this.type = RESET_SET_DELIVERY_ADDRESS_PROCESS;
    }
}
class LoadSupportedDeliveryModes extends StateUtils.EntityLoadAction {
    constructor(payload) {
        super(PROCESS_FEATURE, SET_SUPPORTED_DELIVERY_MODE_PROCESS_ID);
        this.payload = payload;
        this.type = LOAD_SUPPORTED_DELIVERY_MODES;
    }
}
class LoadSupportedDeliveryModesFail extends StateUtils.EntityFailAction {
    constructor(payload) {
        super(PROCESS_FEATURE, SET_SUPPORTED_DELIVERY_MODE_PROCESS_ID);
        this.payload = payload;
        this.type = LOAD_SUPPORTED_DELIVERY_MODES_FAIL;
    }
}
class LoadSupportedDeliveryModesSuccess extends StateUtils.EntitySuccessAction {
    constructor(payload) {
        super(PROCESS_FEATURE, SET_SUPPORTED_DELIVERY_MODE_PROCESS_ID);
        this.payload = payload;
        this.type = LOAD_SUPPORTED_DELIVERY_MODES_SUCCESS;
    }
}
class ResetLoadSupportedDeliveryModesProcess extends StateUtils.EntityLoaderResetAction {
    constructor() {
        super(PROCESS_FEATURE, SET_SUPPORTED_DELIVERY_MODE_PROCESS_ID);
        this.type = RESET_SUPPORTED_SET_DELIVERY_MODES_PROCESS;
    }
}
class SetDeliveryMode extends StateUtils.EntityLoadAction {
    constructor(payload) {
        super(PROCESS_FEATURE, SET_DELIVERY_MODE_PROCESS_ID);
        this.payload = payload;
        this.type = SET_DELIVERY_MODE;
    }
}
class SetDeliveryModeFail extends StateUtils.EntityFailAction {
    constructor(payload) {
        super(PROCESS_FEATURE, SET_DELIVERY_MODE_PROCESS_ID, payload);
        this.payload = payload;
        this.type = SET_DELIVERY_MODE_FAIL;
    }
}
class SetDeliveryModeSuccess extends StateUtils.EntitySuccessAction {
    constructor(payload) {
        super(PROCESS_FEATURE, SET_DELIVERY_MODE_PROCESS_ID);
        this.payload = payload;
        this.type = SET_DELIVERY_MODE_SUCCESS;
    }
}
class ResetSetDeliveryModeProcess extends StateUtils.EntityLoaderResetAction {
    constructor() {
        super(PROCESS_FEATURE, SET_DELIVERY_MODE_PROCESS_ID);
        this.type = RESET_SET_DELIVERY_MODE_PROCESS;
    }
}
class CreatePaymentDetails extends StateUtils.EntityLoadAction {
    constructor(payload) {
        super(PROCESS_FEATURE, SET_PAYMENT_DETAILS_PROCESS_ID);
        this.payload = payload;
        this.type = CREATE_PAYMENT_DETAILS;
    }
}
class CreatePaymentDetailsFail extends StateUtils.EntityFailAction {
    constructor(payload) {
        super(PROCESS_FEATURE, SET_PAYMENT_DETAILS_PROCESS_ID);
        this.payload = payload;
        this.type = CREATE_PAYMENT_DETAILS_FAIL;
    }
}
class CreatePaymentDetailsSuccess {
    constructor(payload) {
        this.payload = payload;
        this.type = CREATE_PAYMENT_DETAILS_SUCCESS;
    }
}
class PaymentProcessSuccess extends StateUtils.EntitySuccessAction {
    constructor() {
        super(PROCESS_FEATURE, SET_PAYMENT_DETAILS_PROCESS_ID);
        this.type = PAYMENT_PROCESS_SUCCESS;
    }
}
class SetPaymentDetails extends StateUtils.EntityLoadAction {
    constructor(payload) {
        super(PROCESS_FEATURE, SET_PAYMENT_DETAILS_PROCESS_ID);
        this.payload = payload;
        this.type = SET_PAYMENT_DETAILS;
    }
}
class SetPaymentDetailsFail extends StateUtils.EntityFailAction {
    constructor(payload) {
        super(PROCESS_FEATURE, SET_PAYMENT_DETAILS_PROCESS_ID, payload);
        this.payload = payload;
        this.type = SET_PAYMENT_DETAILS_FAIL;
    }
}
class SetPaymentDetailsSuccess extends StateUtils.EntitySuccessAction {
    constructor(payload) {
        super(PROCESS_FEATURE, SET_PAYMENT_DETAILS_PROCESS_ID);
        this.payload = payload;
        this.type = SET_PAYMENT_DETAILS_SUCCESS;
    }
}
class ResetSetPaymentDetailsProcess extends StateUtils.EntityLoaderResetAction {
    constructor() {
        super(PROCESS_FEATURE, SET_PAYMENT_DETAILS_PROCESS_ID);
        this.type = RESET_SET_PAYMENT_DETAILS_PROCESS;
    }
}
class PlaceOrder extends StateUtils.EntityLoadAction {
    constructor(payload) {
        super(PROCESS_FEATURE, PLACED_ORDER_PROCESS_ID);
        this.payload = payload;
        this.type = PLACE_ORDER;
    }
}
class PlaceOrderFail extends StateUtils.EntityFailAction {
    constructor(payload) {
        super(PROCESS_FEATURE, PLACED_ORDER_PROCESS_ID, payload);
        this.payload = payload;
        this.type = PLACE_ORDER_FAIL;
    }
}
class PlaceOrderSuccess extends StateUtils.EntitySuccessAction {
    constructor(payload) {
        super(PROCESS_FEATURE, PLACED_ORDER_PROCESS_ID);
        this.payload = payload;
        this.type = PLACE_ORDER_SUCCESS;
    }
}
class ClearPlaceOrder extends StateUtils.EntityLoaderResetAction {
    constructor() {
        super(PROCESS_FEATURE, PLACED_ORDER_PROCESS_ID);
        this.type = CLEAR_PLACE_ORDER;
    }
}
class ClearSupportedDeliveryModes {
    constructor() {
        this.type = CLEAR_SUPPORTED_DELIVERY_MODES;
    }
}
class ClearCheckoutStep {
    constructor(payload) {
        this.payload = payload;
        this.type = CLEAR_CHECKOUT_STEP;
    }
}
class ClearCheckoutData {
    constructor() {
        this.type = CLEAR_CHECKOUT_DATA;
    }
}
class LoadCheckoutDetails extends StateUtils.LoaderLoadAction {
    constructor(payload) {
        super(CHECKOUT_DETAILS);
        this.payload = payload;
        this.type = LOAD_CHECKOUT_DETAILS;
    }
}
class LoadCheckoutDetailsFail extends StateUtils.LoaderFailAction {
    constructor(payload) {
        super(CHECKOUT_DETAILS, payload);
        this.payload = payload;
        this.type = LOAD_CHECKOUT_DETAILS_FAIL;
    }
}
class LoadCheckoutDetailsSuccess extends StateUtils.LoaderSuccessAction {
    constructor(payload) {
        super(CHECKOUT_DETAILS);
        this.payload = payload;
        this.type = LOAD_CHECKOUT_DETAILS_SUCCESS;
    }
}
class CheckoutClearMiscsData {
    constructor() {
        this.type = CHECKOUT_CLEAR_MISCS_DATA;
    }
}
class ClearCheckoutDeliveryAddress {
    constructor(payload) {
        this.payload = payload;
        this.type = CLEAR_CHECKOUT_DELIVERY_ADDRESS;
    }
}
class ClearCheckoutDeliveryAddressSuccess {
    constructor() {
        this.type = CLEAR_CHECKOUT_DELIVERY_ADDRESS_SUCCESS;
    }
}
class ClearCheckoutDeliveryAddressFail {
    constructor(payload) {
        this.payload = payload;
        this.type = CLEAR_CHECKOUT_DELIVERY_ADDRESS_FAIL;
    }
}
class ClearCheckoutDeliveryMode extends StateUtils.EntityProcessesIncrementAction {
    constructor(payload) {
        super(MULTI_CART_DATA, payload.cartId);
        this.payload = payload;
        this.type = CLEAR_CHECKOUT_DELIVERY_MODE;
    }
}
class ClearCheckoutDeliveryModeSuccess extends StateUtils.EntityProcessesDecrementAction {
    constructor(payload) {
        super(MULTI_CART_DATA, payload.cartId);
        this.payload = payload;
        this.type = CLEAR_CHECKOUT_DELIVERY_MODE_SUCCESS;
    }
}
class ClearCheckoutDeliveryModeFail extends StateUtils.EntityProcessesDecrementAction {
    constructor(payload) {
        super(MULTI_CART_DATA, payload.cartId);
        this.payload = payload;
        this.type = CLEAR_CHECKOUT_DELIVERY_MODE_FAIL;
    }
}
class SetCostCenter extends StateUtils.EntityLoadAction {
    constructor(payload) {
        super(PROCESS_FEATURE, SET_COST_CENTER_PROCESS_ID);
        this.payload = payload;
        this.type = SET_COST_CENTER;
    }
}
class SetCostCenterFail extends StateUtils.EntityFailAction {
    constructor(payload) {
        super(PROCESS_FEATURE, SET_COST_CENTER_PROCESS_ID, payload);
        this.payload = payload;
        this.type = SET_COST_CENTER_FAIL;
    }
}
class SetCostCenterSuccess extends StateUtils.EntitySuccessAction {
    constructor(payload) {
        super(PROCESS_FEATURE, SET_COST_CENTER_PROCESS_ID);
        this.payload = payload;
        this.type = SET_COST_CENTER_SUCCESS;
    }
}
class ResetSetCostCenterProcess extends StateUtils.EntityLoaderResetAction {
    constructor() {
        super(PROCESS_FEATURE, SET_COST_CENTER_PROCESS_ID);
        this.type = RESET_SET_COST_CENTER_PROCESS;
    }
}

const SET_ORDER_TYPE = '[Checkout] Set Order Type';
class SetOrderType {
    constructor(payload) {
        this.payload = payload;
        this.type = SET_ORDER_TYPE;
    }
}

const LOAD_PAYMENT_TYPES = '[Checkout] Load Payment Types';
const LOAD_PAYMENT_TYPES_FAIL = '[Checkout] Load Payment Types Fail';
const LOAD_PAYMENT_TYPES_SUCCESS = '[Checkout] Load Payment Types Success';
const RESET_LOAD_PAYMENT_TYPES_PROCESS_ID = '[Checkout] Reset Load Payment Type Process';
const SET_PAYMENT_TYPE = '[Checkout] Set Payment Type';
const SET_PAYMENT_TYPE_FAIL = '[Checkout] Set Payment Type Fail';
const SET_PAYMENT_TYPE_SUCCESS = '[Checkout] Set Payment Type Success';
class LoadPaymentTypes extends StateUtils.EntityLoadAction {
    constructor() {
        super(PROCESS_FEATURE, GET_PAYMENT_TYPES_PROCESS_ID);
        this.type = LOAD_PAYMENT_TYPES;
    }
}
class LoadPaymentTypesFail extends StateUtils.EntityFailAction {
    constructor(payload) {
        super(PROCESS_FEATURE, GET_PAYMENT_TYPES_PROCESS_ID);
        this.payload = payload;
        this.type = LOAD_PAYMENT_TYPES_FAIL;
    }
}
class LoadPaymentTypesSuccess extends StateUtils.EntitySuccessAction {
    constructor(payload) {
        super(PROCESS_FEATURE, GET_PAYMENT_TYPES_PROCESS_ID);
        this.payload = payload;
        this.type = LOAD_PAYMENT_TYPES_SUCCESS;
    }
}
class ResetLoadPaymentTypesProcess extends StateUtils.EntityLoaderResetAction {
    constructor() {
        super(PROCESS_FEATURE, GET_PAYMENT_TYPES_PROCESS_ID);
        this.type = RESET_LOAD_PAYMENT_TYPES_PROCESS_ID;
    }
}
class SetPaymentType {
    constructor(payload) {
        this.payload = payload;
        this.type = SET_PAYMENT_TYPE;
    }
}
class SetPaymentTypeFail {
    constructor(payload) {
        this.payload = payload;
        this.type = SET_PAYMENT_TYPE_FAIL;
    }
}
class SetPaymentTypeSuccess {
    constructor(payload) {
        this.payload = payload;
        this.type = SET_PAYMENT_TYPE_SUCCESS;
    }
}

const SCHEDULE_REPLENISHMENT_ORDER = '[Checkout] Schedule Replenishment Order';
const SCHEDULE_REPLENISHMENT_ORDER_SUCCESS = '[Checkout] Schedule Replenishment Order Success';
const SCHEDULE_REPLENISHMENT_ORDER_FAIL = '[Checkout] Schedule Replenishment Order Fail';
const CLEAR_SCHEDULE_REPLENISHMENT_ORDER = '[Checkout] Clear Schedule Replenishment Data';
class ScheduleReplenishmentOrder extends StateUtils.EntityLoadAction {
    constructor(payload) {
        super(PROCESS_FEATURE, PLACED_ORDER_PROCESS_ID);
        this.payload = payload;
        this.type = SCHEDULE_REPLENISHMENT_ORDER;
    }
}
class ScheduleReplenishmentOrderSuccess extends StateUtils.EntitySuccessAction {
    constructor(payload) {
        super(PROCESS_FEATURE, PLACED_ORDER_PROCESS_ID);
        this.payload = payload;
        this.type = SCHEDULE_REPLENISHMENT_ORDER_SUCCESS;
    }
}
class ScheduleReplenishmentOrderFail extends StateUtils.EntityFailAction {
    constructor(payload) {
        super(PROCESS_FEATURE, PLACED_ORDER_PROCESS_ID, payload);
        this.payload = payload;
        this.type = SCHEDULE_REPLENISHMENT_ORDER_FAIL;
    }
}
class ClearScheduleReplenishmentOrderAction extends StateUtils.EntityLoaderResetAction {
    constructor() {
        super(PROCESS_FEATURE, PLACED_ORDER_PROCESS_ID);
        this.type = CLEAR_SCHEDULE_REPLENISHMENT_ORDER;
    }
}

var checkoutGroup_actions = /*#__PURE__*/Object.freeze({
    __proto__: null,
    LOAD_CARD_TYPES: LOAD_CARD_TYPES,
    LOAD_CARD_TYPES_FAIL: LOAD_CARD_TYPES_FAIL,
    LOAD_CARD_TYPES_SUCCESS: LOAD_CARD_TYPES_SUCCESS,
    LoadCardTypes: LoadCardTypes,
    LoadCardTypesFail: LoadCardTypesFail,
    LoadCardTypesSuccess: LoadCardTypesSuccess,
    CLEAR_CHECKOUT_DELIVERY_ADDRESS: CLEAR_CHECKOUT_DELIVERY_ADDRESS,
    CLEAR_CHECKOUT_DELIVERY_ADDRESS_SUCCESS: CLEAR_CHECKOUT_DELIVERY_ADDRESS_SUCCESS,
    CLEAR_CHECKOUT_DELIVERY_ADDRESS_FAIL: CLEAR_CHECKOUT_DELIVERY_ADDRESS_FAIL,
    CLEAR_CHECKOUT_DELIVERY_MODE: CLEAR_CHECKOUT_DELIVERY_MODE,
    CLEAR_CHECKOUT_DELIVERY_MODE_SUCCESS: CLEAR_CHECKOUT_DELIVERY_MODE_SUCCESS,
    CLEAR_CHECKOUT_DELIVERY_MODE_FAIL: CLEAR_CHECKOUT_DELIVERY_MODE_FAIL,
    ADD_DELIVERY_ADDRESS: ADD_DELIVERY_ADDRESS,
    ADD_DELIVERY_ADDRESS_FAIL: ADD_DELIVERY_ADDRESS_FAIL,
    ADD_DELIVERY_ADDRESS_SUCCESS: ADD_DELIVERY_ADDRESS_SUCCESS,
    SET_DELIVERY_ADDRESS: SET_DELIVERY_ADDRESS,
    SET_DELIVERY_ADDRESS_FAIL: SET_DELIVERY_ADDRESS_FAIL,
    SET_DELIVERY_ADDRESS_SUCCESS: SET_DELIVERY_ADDRESS_SUCCESS,
    RESET_SET_DELIVERY_ADDRESS_PROCESS: RESET_SET_DELIVERY_ADDRESS_PROCESS,
    LOAD_SUPPORTED_DELIVERY_MODES: LOAD_SUPPORTED_DELIVERY_MODES,
    LOAD_SUPPORTED_DELIVERY_MODES_FAIL: LOAD_SUPPORTED_DELIVERY_MODES_FAIL,
    LOAD_SUPPORTED_DELIVERY_MODES_SUCCESS: LOAD_SUPPORTED_DELIVERY_MODES_SUCCESS,
    CLEAR_SUPPORTED_DELIVERY_MODES: CLEAR_SUPPORTED_DELIVERY_MODES,
    SET_DELIVERY_MODE: SET_DELIVERY_MODE,
    SET_DELIVERY_MODE_FAIL: SET_DELIVERY_MODE_FAIL,
    SET_DELIVERY_MODE_SUCCESS: SET_DELIVERY_MODE_SUCCESS,
    RESET_SET_DELIVERY_MODE_PROCESS: RESET_SET_DELIVERY_MODE_PROCESS,
    SET_SUPPORTED_DELIVERY_MODES: SET_SUPPORTED_DELIVERY_MODES,
    SET_SUPPORTED_DELIVERY_MODES_FAIL: SET_SUPPORTED_DELIVERY_MODES_FAIL,
    SET_SUPPORTED_DELIVERY_MODES_SUCCESS: SET_SUPPORTED_DELIVERY_MODES_SUCCESS,
    RESET_SUPPORTED_SET_DELIVERY_MODES_PROCESS: RESET_SUPPORTED_SET_DELIVERY_MODES_PROCESS,
    CREATE_PAYMENT_DETAILS: CREATE_PAYMENT_DETAILS,
    CREATE_PAYMENT_DETAILS_FAIL: CREATE_PAYMENT_DETAILS_FAIL,
    CREATE_PAYMENT_DETAILS_SUCCESS: CREATE_PAYMENT_DETAILS_SUCCESS,
    SET_PAYMENT_DETAILS: SET_PAYMENT_DETAILS,
    SET_PAYMENT_DETAILS_FAIL: SET_PAYMENT_DETAILS_FAIL,
    SET_PAYMENT_DETAILS_SUCCESS: SET_PAYMENT_DETAILS_SUCCESS,
    RESET_SET_PAYMENT_DETAILS_PROCESS: RESET_SET_PAYMENT_DETAILS_PROCESS,
    PLACE_ORDER: PLACE_ORDER,
    PLACE_ORDER_FAIL: PLACE_ORDER_FAIL,
    PLACE_ORDER_SUCCESS: PLACE_ORDER_SUCCESS,
    CLEAR_PLACE_ORDER: CLEAR_PLACE_ORDER,
    CLEAR_CHECKOUT_STEP: CLEAR_CHECKOUT_STEP,
    CLEAR_CHECKOUT_DATA: CLEAR_CHECKOUT_DATA,
    LOAD_CHECKOUT_DETAILS: LOAD_CHECKOUT_DETAILS,
    LOAD_CHECKOUT_DETAILS_FAIL: LOAD_CHECKOUT_DETAILS_FAIL,
    LOAD_CHECKOUT_DETAILS_SUCCESS: LOAD_CHECKOUT_DETAILS_SUCCESS,
    CHECKOUT_CLEAR_MISCS_DATA: CHECKOUT_CLEAR_MISCS_DATA,
    PAYMENT_PROCESS_SUCCESS: PAYMENT_PROCESS_SUCCESS,
    SET_COST_CENTER: SET_COST_CENTER,
    SET_COST_CENTER_FAIL: SET_COST_CENTER_FAIL,
    SET_COST_CENTER_SUCCESS: SET_COST_CENTER_SUCCESS,
    RESET_SET_COST_CENTER_PROCESS: RESET_SET_COST_CENTER_PROCESS,
    AddDeliveryAddress: AddDeliveryAddress,
    AddDeliveryAddressFail: AddDeliveryAddressFail,
    AddDeliveryAddressSuccess: AddDeliveryAddressSuccess,
    SetDeliveryAddress: SetDeliveryAddress,
    SetDeliveryAddressFail: SetDeliveryAddressFail,
    SetDeliveryAddressSuccess: SetDeliveryAddressSuccess,
    ResetSetDeliveryAddressProcess: ResetSetDeliveryAddressProcess,
    LoadSupportedDeliveryModes: LoadSupportedDeliveryModes,
    LoadSupportedDeliveryModesFail: LoadSupportedDeliveryModesFail,
    LoadSupportedDeliveryModesSuccess: LoadSupportedDeliveryModesSuccess,
    ResetLoadSupportedDeliveryModesProcess: ResetLoadSupportedDeliveryModesProcess,
    SetDeliveryMode: SetDeliveryMode,
    SetDeliveryModeFail: SetDeliveryModeFail,
    SetDeliveryModeSuccess: SetDeliveryModeSuccess,
    ResetSetDeliveryModeProcess: ResetSetDeliveryModeProcess,
    CreatePaymentDetails: CreatePaymentDetails,
    CreatePaymentDetailsFail: CreatePaymentDetailsFail,
    CreatePaymentDetailsSuccess: CreatePaymentDetailsSuccess,
    PaymentProcessSuccess: PaymentProcessSuccess,
    SetPaymentDetails: SetPaymentDetails,
    SetPaymentDetailsFail: SetPaymentDetailsFail,
    SetPaymentDetailsSuccess: SetPaymentDetailsSuccess,
    ResetSetPaymentDetailsProcess: ResetSetPaymentDetailsProcess,
    PlaceOrder: PlaceOrder,
    PlaceOrderFail: PlaceOrderFail,
    PlaceOrderSuccess: PlaceOrderSuccess,
    ClearPlaceOrder: ClearPlaceOrder,
    ClearSupportedDeliveryModes: ClearSupportedDeliveryModes,
    ClearCheckoutStep: ClearCheckoutStep,
    ClearCheckoutData: ClearCheckoutData,
    LoadCheckoutDetails: LoadCheckoutDetails,
    LoadCheckoutDetailsFail: LoadCheckoutDetailsFail,
    LoadCheckoutDetailsSuccess: LoadCheckoutDetailsSuccess,
    CheckoutClearMiscsData: CheckoutClearMiscsData,
    ClearCheckoutDeliveryAddress: ClearCheckoutDeliveryAddress,
    ClearCheckoutDeliveryAddressSuccess: ClearCheckoutDeliveryAddressSuccess,
    ClearCheckoutDeliveryAddressFail: ClearCheckoutDeliveryAddressFail,
    ClearCheckoutDeliveryMode: ClearCheckoutDeliveryMode,
    ClearCheckoutDeliveryModeSuccess: ClearCheckoutDeliveryModeSuccess,
    ClearCheckoutDeliveryModeFail: ClearCheckoutDeliveryModeFail,
    SetCostCenter: SetCostCenter,
    SetCostCenterFail: SetCostCenterFail,
    SetCostCenterSuccess: SetCostCenterSuccess,
    ResetSetCostCenterProcess: ResetSetCostCenterProcess,
    SET_ORDER_TYPE: SET_ORDER_TYPE,
    SetOrderType: SetOrderType,
    LOAD_PAYMENT_TYPES: LOAD_PAYMENT_TYPES,
    LOAD_PAYMENT_TYPES_FAIL: LOAD_PAYMENT_TYPES_FAIL,
    LOAD_PAYMENT_TYPES_SUCCESS: LOAD_PAYMENT_TYPES_SUCCESS,
    RESET_LOAD_PAYMENT_TYPES_PROCESS_ID: RESET_LOAD_PAYMENT_TYPES_PROCESS_ID,
    SET_PAYMENT_TYPE: SET_PAYMENT_TYPE,
    SET_PAYMENT_TYPE_FAIL: SET_PAYMENT_TYPE_FAIL,
    SET_PAYMENT_TYPE_SUCCESS: SET_PAYMENT_TYPE_SUCCESS,
    LoadPaymentTypes: LoadPaymentTypes,
    LoadPaymentTypesFail: LoadPaymentTypesFail,
    LoadPaymentTypesSuccess: LoadPaymentTypesSuccess,
    ResetLoadPaymentTypesProcess: ResetLoadPaymentTypesProcess,
    SetPaymentType: SetPaymentType,
    SetPaymentTypeFail: SetPaymentTypeFail,
    SetPaymentTypeSuccess: SetPaymentTypeSuccess,
    SCHEDULE_REPLENISHMENT_ORDER: SCHEDULE_REPLENISHMENT_ORDER,
    SCHEDULE_REPLENISHMENT_ORDER_SUCCESS: SCHEDULE_REPLENISHMENT_ORDER_SUCCESS,
    SCHEDULE_REPLENISHMENT_ORDER_FAIL: SCHEDULE_REPLENISHMENT_ORDER_FAIL,
    CLEAR_SCHEDULE_REPLENISHMENT_ORDER: CLEAR_SCHEDULE_REPLENISHMENT_ORDER,
    ScheduleReplenishmentOrder: ScheduleReplenishmentOrder,
    ScheduleReplenishmentOrderSuccess: ScheduleReplenishmentOrderSuccess,
    ScheduleReplenishmentOrderFail: ScheduleReplenishmentOrderFail,
    ClearScheduleReplenishmentOrderAction: ClearScheduleReplenishmentOrderAction
});

class CheckoutEventBuilder {
    constructor(stateEventService) {
        this.stateEventService = stateEventService;
        this.register();
    }
    /**
     * Registers checkout events
     */
    register() {
        this.orderPlacedEvent();
    }
    /**
     * Register an order successfully placed event
     */
    orderPlacedEvent() {
        this.stateEventService.register({
            action: PLACE_ORDER_SUCCESS,
            event: OrderPlacedEvent,
        });
    }
}
CheckoutEventBuilder.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutEventBuilder, deps: [{ token: i2.StateEventService }], target: i0.ɵɵFactoryTarget.Injectable });
CheckoutEventBuilder.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutEventBuilder });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutEventBuilder, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i2.StateEventService }]; } });

class CheckoutEventListener {
    constructor(checkoutDeliveryFacade, clearCheckoutFacade, eventService) {
        this.checkoutDeliveryFacade = checkoutDeliveryFacade;
        this.clearCheckoutFacade = clearCheckoutFacade;
        this.eventService = eventService;
        this.subscription = new Subscription();
        this.onUserAddressChange();
        this.onSavedCartChange();
    }
    /**
     * Clears the checkout delivery info when an address in the address book is
     * changed ( updated, set as default or deleted )
     *
     * Listens for UpdateUserAddressEvent or DeleteUserAddressEvent
     */
    onUserAddressChange() {
        this.subscription.add(this.eventService
            .get(UserAddressEvent)
            .pipe(filter((event) => {
            return (event instanceof UpdateUserAddressEvent ||
                event instanceof DeleteUserAddressEvent);
        }))
            .subscribe((_event) => {
            this.checkoutDeliveryFacade.clearCheckoutDeliveryDetails();
        }));
    }
    /**
     * What te active cart is saved for later or when a saved card is restored,
     * the whole checkout state is reset.
     *
     * Listens for SaveCartSuccessEvent or RestoreSavedCartSuccessEvent
     */
    onSavedCartChange() {
        this.subscription.add(this.eventService
            .get(SavedCartEvent)
            .pipe(filter((event) => {
            return (event instanceof SaveCartSuccessEvent ||
                event instanceof RestoreSavedCartSuccessEvent);
        }))
            .subscribe((_event) => {
            this.clearCheckoutFacade.resetCheckoutProcesses();
        }));
    }
    ngOnDestroy() {
        var _a;
        (_a = this.subscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();
    }
}
CheckoutEventListener.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutEventListener, deps: [{ token: i1.CheckoutDeliveryFacade }, { token: i1.ClearCheckoutFacade }, { token: i2.EventService }], target: i0.ɵɵFactoryTarget.Injectable });
CheckoutEventListener.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutEventListener, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutEventListener, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.CheckoutDeliveryFacade }, { type: i1.ClearCheckoutFacade }, { type: i2.EventService }]; } });

class CheckoutEventModule {
    constructor(_checkoutEventBuilder, _checkoutEventListener) { }
}
CheckoutEventModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutEventModule, deps: [{ token: CheckoutEventBuilder }, { token: CheckoutEventListener }], target: i0.ɵɵFactoryTarget.NgModule });
CheckoutEventModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutEventModule });
CheckoutEventModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutEventModule });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutEventModule, decorators: [{
            type: NgModule,
            args: [{}]
        }], ctorParameters: function () { return [{ type: CheckoutEventBuilder }, { type: CheckoutEventListener }]; } });

const initialState$3 = {
    entities: {},
};
function reducer$3(state = initialState$3, action) {
    switch (action.type) {
        case LOAD_CARD_TYPES_SUCCESS: {
            const cardTypes = action.payload;
            const entities = cardTypes.reduce((cardTypesEntities, name) => {
                return Object.assign(Object.assign({}, cardTypesEntities), { [name.code]: name });
            }, Object.assign({}, state.entities));
            return Object.assign(Object.assign({}, state), { entities });
        }
        case CHECKOUT_CLEAR_MISCS_DATA: {
            return initialState$3;
        }
    }
    return state;
}
const getCardTypesEntites$1 = (state) => state.entities;

const getDeliveryAddressSelector = (state) => state.address;
const getDeliveryModeSelector = (state) => state.deliveryMode;
const getPaymentDetailsSelector = (state) => state.paymentDetails;
const getOrderDetailsSelector = (state) => state.orderDetails;
const getCheckoutState = createFeatureSelector(CHECKOUT_FEATURE);
const getCheckoutStepsState = createSelector(getCheckoutState, (checkoutState) => checkoutState.steps);
const getCheckoutSteps = createSelector(getCheckoutStepsState, (state) => StateUtils.loaderValueSelector(state));
const getDeliveryAddress = createSelector(getCheckoutSteps, getDeliveryAddressSelector);
const getDeliveryMode = createSelector(getCheckoutSteps, getDeliveryModeSelector);
const getSupportedDeliveryModes = createSelector(getDeliveryMode, (deliveryMode) => {
    return (deliveryMode &&
        Object.keys(deliveryMode.supported).map((code) => deliveryMode.supported[code]));
});
const getSelectedDeliveryModeCode = createSelector(getDeliveryMode, (deliveryMode) => {
    return deliveryMode && deliveryMode.selected;
});
const getSelectedDeliveryMode = createSelector(getDeliveryMode, (deliveryMode) => {
    if (deliveryMode.selected !== '') {
        if (Object.keys(deliveryMode.supported).length === 0) {
            return null;
        }
        return deliveryMode.supported[deliveryMode.selected];
    }
});
const getPaymentDetails = createSelector(getCheckoutSteps, getPaymentDetailsSelector);
const getCheckoutOrderDetails = createSelector(getCheckoutSteps, getOrderDetailsSelector);
const getCheckoutDetailsLoaded = createSelector(getCheckoutStepsState, (state) => StateUtils.loaderSuccessSelector(state) &&
    !StateUtils.loaderLoadingSelector(state));
const getCheckoutLoading = createSelector(getCheckoutStepsState, (state) => StateUtils.loaderLoadingSelector(state));
const getPoNumer = createSelector(getCheckoutSteps, (state) => state.poNumber.po);
const getCostCenter = createSelector(getCheckoutSteps, (state) => state.poNumber.costCenter);

const getCardTypesState = createSelector(getCheckoutState, (state) => state.cardTypes);
const getCardTypesEntites = createSelector(getCardTypesState, getCardTypesEntites$1);
const getAllCardTypes = createSelector(getCardTypesEntites, (entites) => {
    return Object.keys(entites).map((code) => entites[code]);
});

const getSelectedOrderTypeSelector = (state) => state.selected;
const getOrderTypesState = createSelector(getCheckoutState, (state) => state.orderType);
const getSelectedOrderType = createSelector(getOrderTypesState, getSelectedOrderTypeSelector);

const initialState$2 = {
    entities: {},
    selected: undefined,
};
function reducer$2(state = initialState$2, action) {
    var _a;
    switch (action.type) {
        case LOAD_PAYMENT_TYPES_SUCCESS: {
            const paymentTypes = action.payload;
            const entities = paymentTypes.reduce((paymentTypesEntities, name) => {
                return Object.assign(Object.assign({}, paymentTypesEntities), { [name.code]: name });
            }, Object.assign({}, state.entities));
            return Object.assign(Object.assign({}, state), { entities });
        }
        case SET_PAYMENT_TYPE_SUCCESS: {
            return Object.assign(Object.assign({}, state), { selected: (_a = action.payload.paymentType) === null || _a === void 0 ? void 0 : _a.code });
        }
        case CLEAR_CHECKOUT_DATA: {
            return Object.assign(Object.assign({}, state), { selected: undefined });
        }
        case CHECKOUT_CLEAR_MISCS_DATA: {
            return initialState$2;
        }
    }
    return state;
}
const getPaymentTypesEntites$1 = (state) => state.entities;
const getSelectedPaymentType$1 = (state) => state.selected;

const getPaymentTypesState = createSelector(getCheckoutState, (state) => state.paymentTypes);
const getPaymentTypesEntites = createSelector(getPaymentTypesState, getPaymentTypesEntites$1);
const getAllPaymentTypes = createSelector(getPaymentTypesEntites, (entites) => {
    return Object.keys(entites).map((code) => entites[code]);
});
const getSelectedPaymentType = createSelector(getPaymentTypesState, getSelectedPaymentType$1);

var checkoutGroup_selectors = /*#__PURE__*/Object.freeze({
    __proto__: null,
    getCardTypesState: getCardTypesState,
    getCardTypesEntites: getCardTypesEntites,
    getAllCardTypes: getAllCardTypes,
    getCheckoutState: getCheckoutState,
    getCheckoutStepsState: getCheckoutStepsState,
    getCheckoutSteps: getCheckoutSteps,
    getDeliveryAddress: getDeliveryAddress,
    getDeliveryMode: getDeliveryMode,
    getSupportedDeliveryModes: getSupportedDeliveryModes,
    getSelectedDeliveryModeCode: getSelectedDeliveryModeCode,
    getSelectedDeliveryMode: getSelectedDeliveryMode,
    getPaymentDetails: getPaymentDetails,
    getCheckoutOrderDetails: getCheckoutOrderDetails,
    getCheckoutDetailsLoaded: getCheckoutDetailsLoaded,
    getCheckoutLoading: getCheckoutLoading,
    getPoNumer: getPoNumer,
    getCostCenter: getCostCenter,
    getSelectedOrderTypeSelector: getSelectedOrderTypeSelector,
    getOrderTypesState: getOrderTypesState,
    getSelectedOrderType: getSelectedOrderType,
    getPaymentTypesState: getPaymentTypesState,
    getPaymentTypesEntites: getPaymentTypesEntites,
    getAllPaymentTypes: getAllPaymentTypes,
    getSelectedPaymentType: getSelectedPaymentType
});

class CheckoutCostCenterService {
    constructor(checkoutStore, activeCartService, userIdService) {
        this.checkoutStore = checkoutStore;
        this.activeCartService = activeCartService;
        this.userIdService = userIdService;
    }
    /**
     * Set cost center to cart
     * @param costCenterId : cost center id
     */
    setCostCenter(costCenterId) {
        let cartId;
        this.activeCartService
            .getActiveCartId()
            .pipe(take(1))
            .subscribe((activeCartId) => (cartId = activeCartId));
        this.userIdService.takeUserId(true).subscribe((userId) => {
            if (cartId) {
                this.checkoutStore.dispatch(new SetCostCenter({
                    userId: userId,
                    cartId: cartId,
                    costCenterId: costCenterId,
                }));
            }
        }, () => {
            // TODO: for future releases, refactor this part to thrown errors
        });
    }
    /**
     * Get cost center id from cart
     */
    getCostCenter() {
        return combineLatest([
            this.activeCartService.getActive(),
            this.checkoutStore.pipe(select(getCostCenter)),
        ]).pipe(filter(([cart]) => Boolean(cart)), map(([cart, costCenterId]) => {
            if (costCenterId === undefined && cart.costCenter) {
                costCenterId = cart.costCenter.code;
                this.checkoutStore.dispatch(new SetCostCenterSuccess(cart.costCenter.code));
            }
            return costCenterId;
        }));
    }
}
CheckoutCostCenterService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutCostCenterService, deps: [{ token: i1$1.Store }, { token: i2.ActiveCartService }, { token: i2.UserIdService }], target: i0.ɵɵFactoryTarget.Injectable });
CheckoutCostCenterService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutCostCenterService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutCostCenterService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1$1.Store }, { type: i2.ActiveCartService }, { type: i2.UserIdService }]; } });

class CheckoutDeliveryService {
    constructor(checkoutStore, processStateStore, activeCartService, userIdService) {
        this.checkoutStore = checkoutStore;
        this.processStateStore = processStateStore;
        this.activeCartService = activeCartService;
        this.userIdService = userIdService;
    }
    /**
     * Get supported delivery modes
     */
    getSupportedDeliveryModes() {
        return this.checkoutStore.pipe(select(getSupportedDeliveryModes), withLatestFrom(this.processStateStore.pipe(select(ProcessSelectors.getProcessStateFactory(SET_SUPPORTED_DELIVERY_MODE_PROCESS_ID)))), tap(([, loadingState]) => {
            if (!(loadingState.loading || loadingState.success || loadingState.error)) {
                this.loadSupportedDeliveryModes();
            }
        }), pluck(0), shareReplay({ bufferSize: 1, refCount: true }));
    }
    /**
     * Get selected delivery mode
     */
    getSelectedDeliveryMode() {
        return this.checkoutStore.pipe(select(getSelectedDeliveryMode));
    }
    /**
     * Get selected delivery mode code
     */
    getSelectedDeliveryModeCode() {
        return this.checkoutStore.pipe(select(getSelectedDeliveryModeCode));
    }
    /**
     * Get delivery address
     */
    getDeliveryAddress() {
        return this.checkoutStore.pipe(select(getDeliveryAddress));
    }
    /**
     * Get status about successfully set Delivery Address
     */
    getSetDeliveryAddressProcess() {
        return this.processStateStore.pipe(select(ProcessSelectors.getProcessStateFactory(SET_DELIVERY_ADDRESS_PROCESS_ID)));
    }
    /**
     * Clear info about process of setting Delivery Address
     */
    resetSetDeliveryAddressProcess() {
        this.checkoutStore.dispatch(new ResetSetDeliveryAddressProcess());
    }
    /**
     * Get status about of set Delivery Mode process
     */
    getSetDeliveryModeProcess() {
        return this.processStateStore.pipe(select(ProcessSelectors.getProcessStateFactory(SET_DELIVERY_MODE_PROCESS_ID)));
    }
    /**
     * Clear info about process of setting Delivery Mode
     */
    resetSetDeliveryModeProcess() {
        this.checkoutStore.dispatch(new ResetSetDeliveryModeProcess());
    }
    /**
     * Clear info about process of setting Supported Delivery Modes
     */
    resetLoadSupportedDeliveryModesProcess() {
        this.checkoutStore.dispatch(new ResetLoadSupportedDeliveryModesProcess());
    }
    /**
     * Get status about of set supported Delivery Modes process
     */
    getLoadSupportedDeliveryModeProcess() {
        return this.processStateStore.pipe(select(ProcessSelectors.getProcessStateFactory(SET_SUPPORTED_DELIVERY_MODE_PROCESS_ID)));
    }
    /**
     * Clear supported delivery modes loaded in last checkout process
     */
    clearCheckoutDeliveryModes() {
        this.checkoutStore.dispatch(new ClearSupportedDeliveryModes());
    }
    /**
     * Create and set a delivery address using the address param
     * @param address : the Address to be created and set
     */
    createAndSetAddress(address) {
        if (this.actionAllowed()) {
            let userId;
            this.userIdService
                .getUserId()
                .subscribe((occUserId) => (userId = occUserId))
                .unsubscribe();
            let cartId;
            this.activeCartService
                .getActiveCartId()
                .subscribe((activeCartId) => (cartId = activeCartId))
                .unsubscribe();
            if (userId && cartId) {
                this.checkoutStore.dispatch(new AddDeliveryAddress({
                    userId,
                    cartId,
                    address: address,
                }));
            }
        }
    }
    /**
     * Load supported delivery modes
     */
    loadSupportedDeliveryModes() {
        if (this.actionAllowed()) {
            let userId;
            this.userIdService
                .getUserId()
                .subscribe((occUserId) => (userId = occUserId))
                .unsubscribe();
            let cartId;
            this.activeCartService
                .getActiveCartId()
                .subscribe((activeCartId) => (cartId = activeCartId))
                .unsubscribe();
            if (userId && cartId) {
                this.checkoutStore.dispatch(new LoadSupportedDeliveryModes({
                    userId,
                    cartId,
                }));
            }
        }
    }
    /**
     * Set delivery mode
     * @param mode : The delivery mode to be set
     */
    setDeliveryMode(mode) {
        if (this.actionAllowed()) {
            const userId = getLastValueSync(this.userIdService.getUserId());
            const cartId = getLastValueSync(this.activeCartService.getActiveCartId());
            if (userId && cartId) {
                combineLatest([
                    this.activeCartService.isStable(),
                    this.checkoutStore.pipe(select(getCheckoutLoading)),
                ])
                    .pipe(filter(([isStable, isLoading]) => isStable && !isLoading), take(1))
                    .subscribe(() => {
                    this.checkoutStore.dispatch(new SetDeliveryMode({
                        userId,
                        cartId,
                        selectedModeId: mode,
                    }));
                });
            }
        }
    }
    /**
     * Set delivery address
     * @param address : The address to be set
     */
    setDeliveryAddress(address) {
        if (this.actionAllowed()) {
            let userId;
            this.userIdService
                .getUserId()
                .subscribe((occUserId) => (userId = occUserId))
                .unsubscribe();
            let cartId;
            this.activeCartService
                .getActiveCartId()
                .subscribe((activeCartId) => (cartId = activeCartId))
                .unsubscribe();
            if (cartId && userId) {
                this.checkoutStore.dispatch(new SetDeliveryAddress({
                    userId,
                    cartId,
                    address: address,
                }));
            }
        }
    }
    /**
     * Clear address already setup in last checkout process
     */
    clearCheckoutDeliveryAddress() {
        let userId;
        this.userIdService
            .getUserId()
            .subscribe((occUserId) => (userId = occUserId))
            .unsubscribe();
        let cartId;
        this.activeCartService
            .getActiveCartId()
            .subscribe((activeCartId) => (cartId = activeCartId))
            .unsubscribe();
        if (userId && cartId) {
            this.checkoutStore.dispatch(new ClearCheckoutDeliveryAddress({
                userId,
                cartId,
            }));
        }
    }
    /**
     * Clear selected delivery mode setup in last checkout process
     */
    clearCheckoutDeliveryMode() {
        let userId;
        this.userIdService
            .getUserId()
            .subscribe((occUserId) => (userId = occUserId))
            .unsubscribe();
        let cartId;
        this.activeCartService
            .getActiveCartId()
            .subscribe((activeCartId) => (cartId = activeCartId))
            .unsubscribe();
        if (userId && cartId) {
            this.checkoutStore.dispatch(new ClearCheckoutDeliveryMode({
                userId,
                cartId,
            }));
        }
    }
    /**
     * Clear address and delivery mode already setup in last checkout process
     */
    clearCheckoutDeliveryDetails() {
        this.clearCheckoutDeliveryAddress();
        this.clearCheckoutDeliveryMode();
        this.clearCheckoutDeliveryModes();
    }
    actionAllowed() {
        let userId;
        this.userIdService
            .getUserId()
            .subscribe((occUserId) => (userId = occUserId))
            .unsubscribe();
        return ((userId && userId !== OCC_USER_ID_ANONYMOUS) ||
            this.activeCartService.isGuestCart());
    }
}
CheckoutDeliveryService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutDeliveryService, deps: [{ token: i1$1.Store }, { token: i1$1.Store }, { token: i2.ActiveCartService }, { token: i2.UserIdService }], target: i0.ɵɵFactoryTarget.Injectable });
CheckoutDeliveryService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutDeliveryService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutDeliveryService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1$1.Store }, { type: i1$1.Store }, { type: i2.ActiveCartService }, { type: i2.UserIdService }]; } });

class CheckoutPaymentService {
    constructor(checkoutStore, processStateStore, activeCartService, userIdService) {
        this.checkoutStore = checkoutStore;
        this.processStateStore = processStateStore;
        this.activeCartService = activeCartService;
        this.userIdService = userIdService;
    }
    /**
     * Get card types
     */
    getCardTypes() {
        return this.checkoutStore.pipe(select(getAllCardTypes));
    }
    /**
     * Get payment details
     */
    getPaymentDetails() {
        return this.checkoutStore.pipe(select(getPaymentDetails));
    }
    /**
     * Get status about set Payment Details process
     */
    getSetPaymentDetailsResultProcess() {
        return this.processStateStore.pipe(select(ProcessSelectors.getProcessStateFactory(SET_PAYMENT_DETAILS_PROCESS_ID)));
    }
    /**
     * Clear info about process of setting Payment Details
     */
    resetSetPaymentDetailsProcess() {
        this.checkoutStore.dispatch(new ResetSetPaymentDetailsProcess());
    }
    /**
     * Load the supported card types
     */
    loadSupportedCardTypes() {
        this.checkoutStore.dispatch(new LoadCardTypes());
    }
    /**
     * Create payment details using the given paymentDetails param
     * @param paymentDetails: the PaymentDetails to be created
     */
    createPaymentDetails(paymentDetails) {
        if (this.actionAllowed()) {
            let userId;
            this.userIdService
                .getUserId()
                .subscribe((occUserId) => (userId = occUserId))
                .unsubscribe();
            let cartId;
            this.activeCartService
                .getActiveCartId()
                .subscribe((activeCartId) => (cartId = activeCartId))
                .unsubscribe();
            if (userId && cartId) {
                this.checkoutStore.dispatch(new CreatePaymentDetails({
                    userId,
                    cartId,
                    paymentDetails,
                }));
            }
        }
    }
    /**
     * Set payment details
     * @param paymentDetails : the PaymentDetails to be set
     */
    setPaymentDetails(paymentDetails) {
        if (this.actionAllowed()) {
            const userId = getLastValueSync(this.userIdService.getUserId());
            const cartId = getLastValueSync(this.activeCartService.getActiveCartId());
            if (userId && cartId) {
                combineLatest([
                    this.activeCartService.isStable(),
                    this.checkoutStore.pipe(select(getCheckoutLoading)),
                ])
                    .pipe(filter(([isStable, isLoading]) => isStable && !isLoading), take(1))
                    .subscribe(() => {
                    this.checkoutStore.dispatch(new SetPaymentDetails({
                        userId,
                        cartId,
                        paymentDetails: paymentDetails,
                    }));
                });
            }
        }
    }
    /**
     * Sets payment loading to true without having the flicker issue (GH-3102)
     */
    paymentProcessSuccess() {
        this.checkoutStore.dispatch(new PaymentProcessSuccess());
    }
    actionAllowed() {
        let userId;
        this.userIdService
            .getUserId()
            .subscribe((occUserId) => (userId = occUserId))
            .unsubscribe();
        return ((userId && userId !== OCC_USER_ID_ANONYMOUS) ||
            this.activeCartService.isGuestCart());
    }
}
CheckoutPaymentService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutPaymentService, deps: [{ token: i1$1.Store }, { token: i1$1.Store }, { token: i2.ActiveCartService }, { token: i2.UserIdService }], target: i0.ɵɵFactoryTarget.Injectable });
CheckoutPaymentService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutPaymentService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutPaymentService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1$1.Store }, { type: i1$1.Store }, { type: i2.ActiveCartService }, { type: i2.UserIdService }]; } });

class CheckoutService {
    constructor(checkoutStore, processStateStore, activeCartService, userIdService) {
        this.checkoutStore = checkoutStore;
        this.processStateStore = processStateStore;
        this.activeCartService = activeCartService;
        this.userIdService = userIdService;
    }
    /**
     * Places an order
     */
    placeOrder(termsChecked) {
        if (this.actionAllowed()) {
            let userId;
            this.userIdService
                .getUserId()
                .subscribe((occUserId) => (userId = occUserId))
                .unsubscribe();
            let cartId;
            this.activeCartService
                .getActiveCartId()
                .subscribe((activeCartId) => (cartId = activeCartId))
                .unsubscribe();
            if (userId && cartId) {
                this.checkoutStore.dispatch(new PlaceOrder({
                    userId,
                    cartId,
                    termsChecked,
                }));
            }
        }
    }
    /**
     * Schedule a replenishment order
     */
    scheduleReplenishmentOrder(scheduleReplenishmentForm, termsChecked) {
        let cartId;
        this.activeCartService
            .getActiveCartId()
            .pipe(take(1))
            .subscribe((activeCartId) => (cartId = activeCartId));
        this.userIdService.takeUserId(true).subscribe((userId) => {
            if (Boolean(cartId) && Boolean(userId)) {
                this.checkoutStore.dispatch(new ScheduleReplenishmentOrder({
                    cartId,
                    scheduleReplenishmentForm,
                    termsChecked,
                    userId,
                }));
            }
        }, () => {
            // TODO: for future releases, refactor this part to thrown errors
        });
    }
    /**
     * Returns the place or schedule replenishment order's loading flag
     */
    getPlaceOrderLoading() {
        return this.processStateStore.pipe(select(ProcessSelectors.getProcessLoadingFactory(PLACED_ORDER_PROCESS_ID)));
    }
    /**
     * Returns the place or schedule replenishment order's success flag
     */
    getPlaceOrderSuccess() {
        return this.processStateStore.pipe(select(ProcessSelectors.getProcessSuccessFactory(PLACED_ORDER_PROCESS_ID)));
    }
    /**
     * Returns the place or schedule replenishment order's error flag
     */
    getPlaceOrderError() {
        return this.processStateStore.pipe(select(ProcessSelectors.getProcessErrorFactory(PLACED_ORDER_PROCESS_ID)));
    }
    /**
     * Resets the place or schedule replenishment order's processing state
     */
    clearPlaceOrderState() {
        this.checkoutStore.dispatch(new ClearPlaceOrder());
    }
    /**
     * Clear checkout data
     */
    clearCheckoutData() {
        this.checkoutStore.dispatch(new ClearCheckoutData());
    }
    /**
     * Clear checkout step
     * @param stepNumber : the step number to be cleared
     */
    clearCheckoutStep(stepNumber) {
        this.checkoutStore.dispatch(new ClearCheckoutStep(stepNumber));
    }
    /**
     * Load checkout details data
     * @param cartId : string Cart ID of loaded cart
     */
    loadCheckoutDetails(cartId) {
        let userId;
        this.userIdService
            .getUserId()
            .subscribe((occUserId) => (userId = occUserId))
            .unsubscribe();
        if (userId) {
            this.checkoutStore.dispatch(new LoadCheckoutDetails({
                userId,
                cartId,
            }));
        }
    }
    /**
     * Get status of checkout details loaded
     */
    getCheckoutDetailsLoaded() {
        return this.checkoutStore.pipe(select(getCheckoutDetailsLoaded));
    }
    /**
     * Check if checkout details are stable (no longer loading)
     */
    isLoading() {
        return this.checkoutStore.pipe(select(getCheckoutLoading));
    }
    /**
     * Get order details
     */
    getOrderDetails() {
        return this.checkoutStore.pipe(select(getCheckoutOrderDetails));
    }
    /**
     * Set checkout order type
     * @param orderType : an enum of types of order we are placing
     */
    setOrderType(orderType) {
        this.checkoutStore.dispatch(new SetOrderType(orderType));
    }
    /**
     * Get current checkout order type
     */
    getCurrentOrderType() {
        return this.checkoutStore.pipe(select(getSelectedOrderType));
    }
    actionAllowed() {
        let userId;
        this.userIdService
            .getUserId()
            .subscribe((occUserId) => (userId = occUserId))
            .unsubscribe();
        return ((userId && userId !== OCC_USER_ID_ANONYMOUS) ||
            this.activeCartService.isGuestCart());
    }
}
CheckoutService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutService, deps: [{ token: i1$1.Store }, { token: i1$1.Store }, { token: i2.ActiveCartService }, { token: i2.UserIdService }], target: i0.ɵɵFactoryTarget.Injectable });
CheckoutService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1$1.Store }, { type: i1$1.Store }, { type: i2.ActiveCartService }, { type: i2.UserIdService }]; } });

class ClearCheckoutService {
    constructor(checkoutDeliveryFacade, checkoutPaymentFacade) {
        this.checkoutDeliveryFacade = checkoutDeliveryFacade;
        this.checkoutPaymentFacade = checkoutPaymentFacade;
    }
    /**
     * Use it to clear checkout state
     */
    resetCheckoutProcesses() {
        this.checkoutDeliveryFacade.resetSetDeliveryAddressProcess();
        this.checkoutDeliveryFacade.resetSetDeliveryModeProcess();
        this.checkoutPaymentFacade.resetSetPaymentDetailsProcess();
    }
}
ClearCheckoutService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ClearCheckoutService, deps: [{ token: i1.CheckoutDeliveryFacade }, { token: i1.CheckoutPaymentFacade }], target: i0.ɵɵFactoryTarget.Injectable });
ClearCheckoutService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ClearCheckoutService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ClearCheckoutService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.CheckoutDeliveryFacade }, { type: i1.CheckoutPaymentFacade }]; } });

class PaymentTypeService {
    constructor(checkoutStore, processStateStore, activeCartService, userIdService) {
        this.checkoutStore = checkoutStore;
        this.processStateStore = processStateStore;
        this.activeCartService = activeCartService;
        this.userIdService = userIdService;
    }
    /**
     * Get payment types
     */
    getPaymentTypes() {
        return this.checkoutStore.pipe(select(getAllPaymentTypes), withLatestFrom(this.processStateStore.pipe(select(ProcessSelectors.getProcessStateFactory(GET_PAYMENT_TYPES_PROCESS_ID)))), tap(([_, loadingState]) => {
            if (!(loadingState.loading || loadingState.success || loadingState.error)) {
                this.loadPaymentTypes();
            }
        }), pluck(0), shareReplay({ bufferSize: 1, refCount: true }));
    }
    /**
     * Load the supported payment types
     */
    loadPaymentTypes() {
        this.checkoutStore.dispatch(new LoadPaymentTypes());
    }
    /**
     * Set payment type to cart
     * @param typeCode
     * @param poNumber : purchase order number
     */
    setPaymentType(typeCode, poNumber) {
        let cartId;
        this.activeCartService
            .getActiveCartId()
            .pipe(take(1))
            .subscribe((activeCartId) => (cartId = activeCartId));
        this.userIdService.takeUserId(true).subscribe((userId) => {
            if (cartId) {
                this.checkoutStore.dispatch(new SetPaymentType({
                    userId: userId,
                    cartId: cartId,
                    typeCode: typeCode,
                    poNumber: poNumber,
                }));
            }
        }, () => {
            // TODO: for future releases, refactor this part to thrown errors
        });
    }
    /**
     * Get the selected payment type
     */
    getSelectedPaymentType() {
        return combineLatest([
            this.activeCartService.getActive(),
            this.checkoutStore.pipe(select(getSelectedPaymentType)),
        ]).pipe(tap(([cart, selected]) => {
            if (selected === undefined) {
                // in b2b, cart always has paymentType (default value 'CARD')
                if (cart && cart.paymentType) {
                    this.checkoutStore.dispatch(new SetPaymentTypeSuccess(cart));
                }
            }
        }), map(([, selected]) => selected));
    }
    /**
     * Get whether the selected payment type is "ACCOUNT" payment
     */
    isAccountPayment() {
        return this.getSelectedPaymentType().pipe(map((selected) => selected === B2BPaymentTypeEnum.ACCOUNT_PAYMENT));
    }
    /**
     * Get PO Number
     */
    getPoNumber() {
        return combineLatest([
            this.activeCartService.getActive(),
            this.checkoutStore.pipe(select(getPoNumer)),
        ]).pipe(tap(([cart, po]) => {
            if (po === undefined && cart && cart.purchaseOrderNumber) {
                this.checkoutStore.dispatch(new SetPaymentTypeSuccess(cart));
            }
        }), map(([_, po]) => po));
    }
}
PaymentTypeService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PaymentTypeService, deps: [{ token: i1$1.Store }, { token: i1$1.Store }, { token: i2.ActiveCartService }, { token: i2.UserIdService }], target: i0.ɵɵFactoryTarget.Injectable });
PaymentTypeService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PaymentTypeService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PaymentTypeService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1$1.Store }, { type: i1$1.Store }, { type: i2.ActiveCartService }, { type: i2.UserIdService }]; } });

const facadeProviders = [
    CheckoutDeliveryService,
    {
        provide: CheckoutDeliveryFacade,
        useExisting: CheckoutDeliveryService,
    },
    CheckoutPaymentService,
    {
        provide: CheckoutPaymentFacade,
        useExisting: CheckoutPaymentService,
    },
    CheckoutService,
    {
        provide: CheckoutFacade,
        useExisting: CheckoutService,
    },
    PaymentTypeService,
    {
        provide: PaymentTypeFacade,
        useExisting: PaymentTypeService,
    },
    CheckoutCostCenterService,
    {
        provide: CheckoutCostCenterFacade,
        useExisting: CheckoutCostCenterService,
    },
    ClearCheckoutService,
    {
        provide: ClearCheckoutFacade,
        useExisting: ClearCheckoutService,
    },
];

/**
 * Resolves the page data for all Content Pages based on the `PageType.CONTENT_PAGE`
 * and the `MultiStepCheckoutSummaryPageTemplate`. If the checkout page matches this template,
 * the more generic `ContentPageMetaResolver` is overridden by this resolver.
 *
 * The page title and robots are resolved in this implementation only.
 */
class CheckoutPageMetaResolver extends PageMetaResolver {
    constructor(translation, activeCartService, basePageMetaResolver) {
        super();
        this.translation = translation;
        this.activeCartService = activeCartService;
        this.basePageMetaResolver = basePageMetaResolver;
        this.cart$ = this.activeCartService.getActive();
        this.pageType = PageType.CONTENT_PAGE;
        this.pageTemplate = 'MultiStepCheckoutSummaryPageTemplate';
    }
    /**
     * @override
     * Resolves the page title from the translation `pageMetaResolver.checkout.title`. The
     * cart total item `count` is passed to the translation, so it can be used in the title.
     *
     * The title from the page data is ignored for this page title.
     */
    resolveTitle() {
        return this.cart$.pipe(switchMap((c) => this.translation.translate('pageMetaResolver.checkout.title', {
            count: c.totalItems,
        })));
    }
    resolveDescription() {
        return this.basePageMetaResolver.resolveDescription();
    }
    resolveRobots() {
        return this.basePageMetaResolver.resolveRobots();
    }
}
CheckoutPageMetaResolver.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutPageMetaResolver, deps: [{ token: i2.TranslationService }, { token: i2.ActiveCartService }, { token: i2.BasePageMetaResolver }], target: i0.ɵɵFactoryTarget.Injectable });
CheckoutPageMetaResolver.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutPageMetaResolver, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutPageMetaResolver, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i2.TranslationService }, { type: i2.ActiveCartService }, { type: i2.BasePageMetaResolver }]; } });

class CardTypesEffects {
    constructor(actions$, checkoutPaymentConnector) {
        this.actions$ = actions$;
        this.checkoutPaymentConnector = checkoutPaymentConnector;
        this.loadCardTypes$ = this.actions$.pipe(ofType(LOAD_CARD_TYPES), switchMap(() => {
            return this.checkoutPaymentConnector.getCardTypes().pipe(map((cardTypes) => new LoadCardTypesSuccess(cardTypes)), catchError((error) => of(new LoadCardTypesFail(normalizeHttpError(error)))));
        }));
    }
}
CardTypesEffects.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CardTypesEffects, deps: [{ token: i1$2.Actions }, { token: CheckoutPaymentConnector }], target: i0.ɵɵFactoryTarget.Injectable });
CardTypesEffects.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CardTypesEffects });
__decorate([
    Effect()
], CardTypesEffects.prototype, "loadCardTypes$", void 0);
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CardTypesEffects, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1$2.Actions }, { type: CheckoutPaymentConnector }]; }, propDecorators: { loadCardTypes$: [] } });

class CheckoutEffects {
    constructor(actions$, checkoutDeliveryConnector, checkoutPaymentConnector, checkoutCostCenterConnector, checkoutConnector) {
        this.actions$ = actions$;
        this.checkoutDeliveryConnector = checkoutDeliveryConnector;
        this.checkoutPaymentConnector = checkoutPaymentConnector;
        this.checkoutCostCenterConnector = checkoutCostCenterConnector;
        this.checkoutConnector = checkoutConnector;
        this.contextChange$ = this.actions$.pipe(ofType(SiteContextActions.CURRENCY_CHANGE, SiteContextActions.LANGUAGE_CHANGE));
        this.addDeliveryAddress$ = this.actions$.pipe(ofType(ADD_DELIVERY_ADDRESS), map((action) => action.payload), mergeMap((payload) => this.checkoutDeliveryConnector
            .createAddress(payload.userId, payload.cartId, payload.address)
            .pipe(mergeMap((address) => {
            address['titleCode'] = payload.address.titleCode;
            if (payload.address.region && payload.address.region.isocodeShort) {
                Object.assign(address.region, {
                    isocodeShort: payload.address.region.isocodeShort,
                });
            }
            if (payload.userId === OCC_USER_ID_ANONYMOUS) {
                return [
                    new SetDeliveryAddress({
                        userId: payload.userId,
                        cartId: payload.cartId,
                        address: address,
                    }),
                ];
            }
            else {
                return [
                    new UserActions.LoadUserAddresses(payload.userId),
                    new SetDeliveryAddress({
                        userId: payload.userId,
                        cartId: payload.cartId,
                        address: address,
                    }),
                ];
            }
        }), catchError((error) => of(new AddDeliveryAddressFail(normalizeHttpError(error)))))), withdrawOn(this.contextChange$));
        this.setDeliveryAddress$ = this.actions$.pipe(ofType(SET_DELIVERY_ADDRESS), map((action) => action.payload), mergeMap((payload) => {
            return this.checkoutDeliveryConnector
                .setAddress(payload.userId, payload.cartId, payload.address.id)
                .pipe(mergeMap(() => [
                new SetDeliveryAddressSuccess(payload.address),
                new ClearCheckoutDeliveryMode({
                    userId: payload.userId,
                    cartId: payload.cartId,
                }),
                new ClearSupportedDeliveryModes(),
                new ResetLoadSupportedDeliveryModesProcess(),
                new LoadSupportedDeliveryModes({
                    userId: payload.userId,
                    cartId: payload.cartId,
                }),
            ]), catchError((error) => of(new SetDeliveryAddressFail(normalizeHttpError(error)))));
        }), withdrawOn(this.contextChange$));
        this.loadSupportedDeliveryModes$ = this.actions$.pipe(ofType(LOAD_SUPPORTED_DELIVERY_MODES), map((action) => action.payload), mergeMap((payload) => {
            return this.checkoutDeliveryConnector
                .getSupportedModes(payload.userId, payload.cartId)
                .pipe(map((data) => {
                return new LoadSupportedDeliveryModesSuccess(data);
            }), catchError((error) => of(new LoadSupportedDeliveryModesFail(normalizeHttpError(error)))));
        }), withdrawOn(this.contextChange$));
        this.clearCheckoutMiscsDataOnLanguageChange$ = this.actions$.pipe(ofType(SiteContextActions.LANGUAGE_CHANGE), mergeMap(() => [
            new ResetLoadSupportedDeliveryModesProcess(),
            new ResetLoadPaymentTypesProcess(),
            new CheckoutClearMiscsData(),
        ]));
        this.clearDeliveryModesOnCurrencyChange$ = this.actions$.pipe(ofType(SiteContextActions.CURRENCY_CHANGE), map(() => new ClearSupportedDeliveryModes()));
        this.clearCheckoutDataOnLogout$ = this.actions$.pipe(ofType(AuthActions.LOGOUT), mergeMap(() => [
            new ClearCheckoutData(),
            new ResetLoadSupportedDeliveryModesProcess(),
            new ResetLoadPaymentTypesProcess(),
        ]));
        this.clearCheckoutDataOnLogin$ = this.actions$.pipe(ofType(AuthActions.LOGIN), map(() => new ClearCheckoutData()));
        this.setDeliveryMode$ = this.actions$.pipe(ofType(SET_DELIVERY_MODE), map((action) => action.payload), mergeMap((payload) => {
            return this.checkoutDeliveryConnector
                .setMode(payload.userId, payload.cartId, payload.selectedModeId)
                .pipe(mergeMap(() => {
                return [
                    new SetDeliveryModeSuccess(payload.selectedModeId),
                    new CartActions.LoadCart({
                        userId: payload.userId,
                        cartId: payload.cartId,
                    }),
                ];
            }), catchError((error) => of(new SetDeliveryModeFail(normalizeHttpError(error)))));
        }), withdrawOn(this.contextChange$));
        this.createPaymentDetails$ = this.actions$.pipe(ofType(CREATE_PAYMENT_DETAILS), map((action) => action.payload), mergeMap((payload) => {
            // get information for creating a subscription directly with payment provider
            return this.checkoutPaymentConnector
                .create(payload.userId, payload.cartId, payload.paymentDetails)
                .pipe(mergeMap((details) => {
                if (payload.userId === OCC_USER_ID_ANONYMOUS) {
                    return [new CreatePaymentDetailsSuccess(details)];
                }
                else {
                    return [
                        new UserActions.LoadUserPaymentMethods(payload.userId),
                        new CreatePaymentDetailsSuccess(details),
                    ];
                }
            }), catchError((error) => of(new CreatePaymentDetailsFail(normalizeHttpError(error)))));
        }), withdrawOn(this.contextChange$));
        this.setPaymentDetails$ = this.actions$.pipe(ofType(SET_PAYMENT_DETAILS), map((action) => action.payload), mergeMap((payload) => {
            return this.checkoutPaymentConnector
                .set(payload.userId, payload.cartId, payload.paymentDetails.id)
                .pipe(map(() => new SetPaymentDetailsSuccess(payload.paymentDetails)), catchError((error) => of(new SetPaymentDetailsFail(normalizeHttpError(error)))));
        }), withdrawOn(this.contextChange$));
        this.placeOrder$ = this.actions$.pipe(ofType(PLACE_ORDER), map((action) => action.payload), mergeMap((payload) => {
            return this.checkoutConnector
                .placeOrder(payload.userId, payload.cartId, payload.termsChecked)
                .pipe(switchMap((data) => [
                new CartActions.RemoveCart({ cartId: payload.cartId }),
                new PlaceOrderSuccess(data),
            ]), catchError((error) => of(new PlaceOrderFail(normalizeHttpError(error)))));
        }), withdrawOn(this.contextChange$));
        this.loadCheckoutDetails$ = this.actions$.pipe(ofType(LOAD_CHECKOUT_DETAILS), map((action) => action.payload), mergeMap((payload) => {
            return this.checkoutConnector
                .loadCheckoutDetails(payload.userId, payload.cartId)
                .pipe(map((data) => new LoadCheckoutDetailsSuccess(data)), catchError((error) => of(new LoadCheckoutDetailsFail(normalizeHttpError(error)))));
        }), withdrawOn(this.contextChange$));
        this.reloadDetailsOnMergeCart$ = this.actions$.pipe(ofType(CartActions.MERGE_CART_SUCCESS), map((action) => action.payload), map((payload) => {
            return new LoadCheckoutDetails({
                userId: payload.userId,
                cartId: payload.cartId,
            });
        }));
        this.clearCheckoutDeliveryAddress$ = this.actions$.pipe(ofType(CLEAR_CHECKOUT_DELIVERY_ADDRESS), map((action) => action.payload), filter((payload) => Boolean(payload.cartId)), switchMap((payload) => {
            return this.checkoutConnector
                .clearCheckoutDeliveryAddress(payload.userId, payload.cartId)
                .pipe(map(() => new ClearCheckoutDeliveryAddressSuccess()), catchError((error) => of(new ClearCheckoutDeliveryAddressFail(normalizeHttpError(error)))));
        }), withdrawOn(this.contextChange$));
        this.clearCheckoutDeliveryMode$ = this.actions$.pipe(ofType(CLEAR_CHECKOUT_DELIVERY_MODE), map((action) => action.payload), filter((payload) => Boolean(payload.cartId)), concatMap((payload) => {
            return this.checkoutConnector
                .clearCheckoutDeliveryMode(payload.userId, payload.cartId)
                .pipe(mergeMap(() => [
                new ClearCheckoutDeliveryModeSuccess(Object.assign({}, payload)),
                new CartActions.LoadCart({
                    cartId: payload.cartId,
                    userId: payload.userId,
                }),
            ]), catchError((error) => from([
                new ClearCheckoutDeliveryModeFail(Object.assign(Object.assign({}, payload), { error: normalizeHttpError(error) })),
                new CartActions.LoadCart({
                    cartId: payload.cartId,
                    userId: payload.userId,
                }),
            ])));
        }), withdrawOn(this.contextChange$));
        this.setCostCenter$ = this.actions$.pipe(ofType(SET_COST_CENTER), map((action) => action.payload), switchMap((payload) => {
            return this.checkoutCostCenterConnector
                .setCostCenter(payload.userId, payload.cartId, payload.costCenterId)
                .pipe(mergeMap((_data) => [
                new CartActions.LoadCart({
                    cartId: payload.cartId,
                    userId: payload.userId,
                }),
                new SetCostCenterSuccess(payload.costCenterId),
                new ClearCheckoutDeliveryAddress({
                    userId: payload.userId,
                    cartId: payload.cartId,
                }),
            ]), catchError((error) => of(new SetCostCenterFail(normalizeHttpError(error)))));
        }), withdrawOn(this.contextChange$));
    }
}
CheckoutEffects.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutEffects, deps: [{ token: i1$2.Actions }, { token: CheckoutDeliveryConnector }, { token: CheckoutPaymentConnector }, { token: CheckoutCostCenterConnector }, { token: CheckoutConnector }], target: i0.ɵɵFactoryTarget.Injectable });
CheckoutEffects.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutEffects });
__decorate([
    Effect()
], CheckoutEffects.prototype, "addDeliveryAddress$", void 0);
__decorate([
    Effect()
], CheckoutEffects.prototype, "setDeliveryAddress$", void 0);
__decorate([
    Effect()
], CheckoutEffects.prototype, "loadSupportedDeliveryModes$", void 0);
__decorate([
    Effect()
], CheckoutEffects.prototype, "clearCheckoutMiscsDataOnLanguageChange$", void 0);
__decorate([
    Effect()
], CheckoutEffects.prototype, "clearDeliveryModesOnCurrencyChange$", void 0);
__decorate([
    Effect()
], CheckoutEffects.prototype, "clearCheckoutDataOnLogout$", void 0);
__decorate([
    Effect()
], CheckoutEffects.prototype, "clearCheckoutDataOnLogin$", void 0);
__decorate([
    Effect()
], CheckoutEffects.prototype, "setDeliveryMode$", void 0);
__decorate([
    Effect()
], CheckoutEffects.prototype, "createPaymentDetails$", void 0);
__decorate([
    Effect()
], CheckoutEffects.prototype, "setPaymentDetails$", void 0);
__decorate([
    Effect()
], CheckoutEffects.prototype, "placeOrder$", void 0);
__decorate([
    Effect()
], CheckoutEffects.prototype, "loadCheckoutDetails$", void 0);
__decorate([
    Effect()
], CheckoutEffects.prototype, "reloadDetailsOnMergeCart$", void 0);
__decorate([
    Effect()
], CheckoutEffects.prototype, "clearCheckoutDeliveryAddress$", void 0);
__decorate([
    Effect()
], CheckoutEffects.prototype, "clearCheckoutDeliveryMode$", void 0);
__decorate([
    Effect()
], CheckoutEffects.prototype, "setCostCenter$", void 0);
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutEffects, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1$2.Actions }, { type: CheckoutDeliveryConnector }, { type: CheckoutPaymentConnector }, { type: CheckoutCostCenterConnector }, { type: CheckoutConnector }]; }, propDecorators: { addDeliveryAddress$: [], setDeliveryAddress$: [], loadSupportedDeliveryModes$: [], clearCheckoutMiscsDataOnLanguageChange$: [], clearDeliveryModesOnCurrencyChange$: [], clearCheckoutDataOnLogout$: [], clearCheckoutDataOnLogin$: [], setDeliveryMode$: [], createPaymentDetails$: [], setPaymentDetails$: [], placeOrder$: [], loadCheckoutDetails$: [], reloadDetailsOnMergeCart$: [], clearCheckoutDeliveryAddress$: [], clearCheckoutDeliveryMode$: [], setCostCenter$: [] } });

class PaymentTypesEffects {
    constructor(actions$, paymentTypeConnector) {
        this.actions$ = actions$;
        this.paymentTypeConnector = paymentTypeConnector;
        this.loadPaymentTypes$ = this.actions$.pipe(ofType(LOAD_PAYMENT_TYPES), switchMap(() => {
            return this.paymentTypeConnector.getPaymentTypes().pipe(map((paymentTypes) => new LoadPaymentTypesSuccess(paymentTypes)), catchError((error) => of(new LoadPaymentTypesFail(normalizeHttpError(error)))));
        }));
        this.setPaymentType$ = this.actions$.pipe(ofType(SET_PAYMENT_TYPE), map((action) => action.payload), switchMap((payload) => {
            return this.paymentTypeConnector
                .setPaymentType(payload.userId, payload.cartId, payload.typeCode, payload.poNumber)
                .pipe(mergeMap((data) => {
                return [
                    new CartActions.LoadCartSuccess({
                        cart: data,
                        userId: payload.userId,
                        cartId: payload.cartId,
                    }),
                    new ClearCheckoutData(),
                    new SetPaymentTypeSuccess(data),
                ];
            }), catchError((error) => of(new SetPaymentTypeFail(normalizeHttpError(error)))));
        }));
    }
}
PaymentTypesEffects.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PaymentTypesEffects, deps: [{ token: i1$2.Actions }, { token: PaymentTypeConnector }], target: i0.ɵɵFactoryTarget.Injectable });
PaymentTypesEffects.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PaymentTypesEffects });
__decorate([
    Effect()
], PaymentTypesEffects.prototype, "loadPaymentTypes$", void 0);
__decorate([
    Effect()
], PaymentTypesEffects.prototype, "setPaymentType$", void 0);
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PaymentTypesEffects, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1$2.Actions }, { type: PaymentTypeConnector }]; }, propDecorators: { loadPaymentTypes$: [], setPaymentType$: [] } });

const DELIVERY_MODE_NORMALIZER = new InjectionToken('DeliveryModeNormalizer');

const PAYMENT_TYPE_NORMALIZER = new InjectionToken('PaymentTypeNormalizer');

const PAYMENT_DETAILS_SERIALIZER = new InjectionToken('PaymentDetailsSerializer');
const CARD_TYPE_NORMALIZER = new InjectionToken('CardTypeNormalizer');

const REPLENISHMENT_ORDER_FORM_SERIALIZER = new InjectionToken('ReplenishmentOrderFormSerializer');

class ReplenishmentOrderEffects {
    constructor(actions$, checkoutReplOrderConnector) {
        this.actions$ = actions$;
        this.checkoutReplOrderConnector = checkoutReplOrderConnector;
        this.scheduleReplenishmentOrder$ = this.actions$.pipe(ofType(SCHEDULE_REPLENISHMENT_ORDER), map((action) => action.payload), mergeMap((payload) => {
            return this.checkoutReplOrderConnector
                .scheduleReplenishmentOrder(payload.cartId, payload.scheduleReplenishmentForm, payload.termsChecked, payload.userId)
                .pipe(switchMap((data) => [
                new CartActions.RemoveCart({ cartId: payload.cartId }),
                new ScheduleReplenishmentOrderSuccess(data),
            ]), catchError((error) => of(new ScheduleReplenishmentOrderFail(normalizeHttpError(error)))));
        }));
    }
}
ReplenishmentOrderEffects.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ReplenishmentOrderEffects, deps: [{ token: i1$2.Actions }, { token: CheckoutReplenishmentOrderConnector }], target: i0.ɵɵFactoryTarget.Injectable });
ReplenishmentOrderEffects.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ReplenishmentOrderEffects });
__decorate([
    Effect()
], ReplenishmentOrderEffects.prototype, "scheduleReplenishmentOrder$", void 0);
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ReplenishmentOrderEffects, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1$2.Actions }, { type: CheckoutReplenishmentOrderConnector }]; }, propDecorators: { scheduleReplenishmentOrder$: [] } });

const effects = [
    CheckoutEffects,
    CardTypesEffects,
    PaymentTypesEffects,
    ReplenishmentOrderEffects,
];

const initialState$1 = {
    poNumber: { po: undefined, costCenter: undefined },
    address: {},
    deliveryMode: {
        supported: {},
        selected: '',
    },
    paymentDetails: {},
    orderDetails: {},
};
function reducer$1(state = initialState$1, action) {
    switch (action.type) {
        case SET_PAYMENT_TYPE_SUCCESS: {
            const cart = action.payload;
            return Object.assign(Object.assign({}, state), { poNumber: Object.assign(Object.assign({}, state.poNumber), { po: cart.purchaseOrderNumber }) });
        }
        case SET_COST_CENTER_SUCCESS: {
            return Object.assign(Object.assign({}, state), { poNumber: Object.assign(Object.assign({}, state.poNumber), { costCenter: action.payload }) });
        }
        case ADD_DELIVERY_ADDRESS_SUCCESS:
        case SET_DELIVERY_ADDRESS_SUCCESS: {
            const address = action.payload;
            return Object.assign(Object.assign({}, state), { address });
        }
        case LOAD_SUPPORTED_DELIVERY_MODES_SUCCESS: {
            const supportedModes = action.payload;
            if (!supportedModes) {
                return state;
            }
            const supported = supportedModes.reduce((modes, mode) => {
                return Object.assign(Object.assign({}, modes), { [mode.code]: mode });
            }, Object.assign({}, state.deliveryMode.supported));
            return Object.assign(Object.assign({}, state), { deliveryMode: Object.assign(Object.assign({}, state.deliveryMode), { supported }) });
        }
        case SET_DELIVERY_MODE_SUCCESS: {
            const selected = action.payload;
            return Object.assign(Object.assign({}, state), { deliveryMode: Object.assign(Object.assign({}, state.deliveryMode), { selected }) });
        }
        case CREATE_PAYMENT_DETAILS_SUCCESS:
        case SET_PAYMENT_DETAILS_SUCCESS: {
            return Object.assign(Object.assign({}, state), { paymentDetails: action.payload });
        }
        case CREATE_PAYMENT_DETAILS_FAIL: {
            const paymentDetails = action.payload;
            if (paymentDetails['hasError']) {
                return Object.assign(Object.assign({}, state), { paymentDetails });
            }
            return state;
        }
        case PLACE_ORDER_SUCCESS:
        case SCHEDULE_REPLENISHMENT_ORDER_SUCCESS: {
            const orderDetails = action.payload;
            return Object.assign(Object.assign({}, state), { orderDetails });
        }
        case CLEAR_CHECKOUT_DATA: {
            return initialState$1;
        }
        case CLEAR_CHECKOUT_STEP: {
            const stepNumber = action.payload;
            switch (stepNumber) {
                case 1: {
                    return Object.assign(Object.assign({}, state), { address: {} });
                }
                case 2: {
                    return Object.assign(Object.assign({}, state), { deliveryMode: Object.assign(Object.assign({}, state.deliveryMode), { supported: {}, selected: '' }) });
                }
                case 3: {
                    return Object.assign(Object.assign({}, state), { paymentDetails: {} });
                }
            }
            return state;
        }
        case CLEAR_SUPPORTED_DELIVERY_MODES:
        case CHECKOUT_CLEAR_MISCS_DATA: {
            return Object.assign(Object.assign({}, state), { deliveryMode: Object.assign(Object.assign({}, state.deliveryMode), { supported: {} }) });
        }
        case LOAD_CHECKOUT_DETAILS_SUCCESS: {
            return Object.assign(Object.assign({}, state), { address: action.payload.deliveryAddress, deliveryMode: Object.assign(Object.assign({}, state.deliveryMode), { selected: action.payload.deliveryMode &&
                        action.payload.deliveryMode.code }), paymentDetails: action.payload.paymentInfo });
        }
        case CLEAR_CHECKOUT_DELIVERY_ADDRESS: {
            return Object.assign(Object.assign({}, state), { address: {} });
        }
        case CLEAR_CHECKOUT_DELIVERY_MODE: {
            return Object.assign(Object.assign({}, state), { deliveryMode: Object.assign(Object.assign({}, state.deliveryMode), { selected: '' }) });
        }
    }
    return state;
}

const initialState = {
    selected: ORDER_TYPE.PLACE_ORDER,
};
function reducer(state = initialState, action) {
    switch (action.type) {
        case SET_ORDER_TYPE: {
            return Object.assign(Object.assign({}, state), { selected: action.payload });
        }
        case CLEAR_CHECKOUT_DATA: {
            return initialState;
        }
        default: {
            return state;
        }
    }
}

function getReducers() {
    return {
        steps: StateUtils.loaderReducer(CHECKOUT_DETAILS, reducer$1),
        cardTypes: reducer$3,
        paymentTypes: reducer$2,
        orderType: reducer,
    };
}
const reducerToken = new InjectionToken('CheckoutReducers');
const reducerProvider = {
    provide: reducerToken,
    useFactory: getReducers,
};

class CheckoutStoreModule {
}
CheckoutStoreModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutStoreModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
CheckoutStoreModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutStoreModule, imports: [CommonModule, i1$1.StoreFeatureModule, i1$2.EffectsFeatureModule] });
CheckoutStoreModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutStoreModule, providers: [reducerProvider], imports: [[
            CommonModule,
            StoreModule.forFeature(CHECKOUT_FEATURE, reducerToken),
            EffectsModule.forFeature(effects),
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutStoreModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        StoreModule.forFeature(CHECKOUT_FEATURE, reducerToken),
                        EffectsModule.forFeature(effects),
                    ],
                    providers: [reducerProvider],
                }]
        }] });

class CheckoutCoreModule {
}
CheckoutCoreModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutCoreModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
CheckoutCoreModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutCoreModule, imports: [CheckoutStoreModule, CheckoutEventModule] });
CheckoutCoreModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutCoreModule, providers: [
        ...facadeProviders,
        CheckoutDeliveryConnector,
        CheckoutCostCenterConnector,
        CheckoutConnector,
        CheckoutPaymentConnector,
        PaymentTypeConnector,
        CheckoutReplenishmentOrderConnector,
        CheckoutEventBuilder,
        CheckoutPageMetaResolver,
        {
            provide: PageMetaResolver,
            useExisting: CheckoutPageMetaResolver,
            multi: true,
        },
    ], imports: [[CheckoutStoreModule, CheckoutEventModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutCoreModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CheckoutStoreModule, CheckoutEventModule],
                    providers: [
                        ...facadeProviders,
                        CheckoutDeliveryConnector,
                        CheckoutCostCenterConnector,
                        CheckoutConnector,
                        CheckoutPaymentConnector,
                        PaymentTypeConnector,
                        CheckoutReplenishmentOrderConnector,
                        CheckoutEventBuilder,
                        CheckoutPageMetaResolver,
                        {
                            provide: PageMetaResolver,
                            useExisting: CheckoutPageMetaResolver,
                            multi: true,
                        },
                    ],
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { CARD_TYPE_NORMALIZER, CHECKOUT_DETAILS, CHECKOUT_FEATURE, checkoutGroup_actions as CheckoutActions, CheckoutAdapter, CheckoutConnector, CheckoutCoreModule, CheckoutCostCenterAdapter, CheckoutCostCenterConnector, CheckoutCostCenterService, CheckoutDeliveryAdapter, CheckoutDeliveryConnector, CheckoutDeliveryService, CheckoutEventBuilder, CheckoutEventListener, CheckoutEventModule, CheckoutPageMetaResolver, CheckoutPaymentAdapter, CheckoutPaymentConnector, CheckoutPaymentService, CheckoutReplenishmentOrderAdapter, CheckoutReplenishmentOrderConnector, checkoutGroup_selectors as CheckoutSelectors, CheckoutService, ClearCheckoutService, DELIVERY_MODE_NORMALIZER, GET_PAYMENT_TYPES_PROCESS_ID, PAYMENT_DETAILS_SERIALIZER, PAYMENT_TYPE_NORMALIZER, PLACED_ORDER_PROCESS_ID, PaymentTypeAdapter, PaymentTypeConnector, PaymentTypeService, REPLENISHMENT_ORDER_FORM_SERIALIZER, SET_COST_CENTER_PROCESS_ID, SET_DELIVERY_ADDRESS_PROCESS_ID, SET_DELIVERY_MODE_PROCESS_ID, SET_PAYMENT_DETAILS_PROCESS_ID, SET_SUPPORTED_DELIVERY_MODE_PROCESS_ID };
//# sourceMappingURL=spartacus-checkout-core.js.map
