import * as i0 from '@angular/core';
import { Injectable, NgModule } from '@angular/core';
import * as i2 from '@spartacus/core';
import { TimeUtils, CART_NORMALIZER, ADDRESS_SERIALIZER, ADDRESS_NORMALIZER, PAYMENT_DETAILS_NORMALIZER, HttpParamsURIEncoder, REPLENISHMENT_ORDER_NORMALIZER, OCC_USER_ID_ANONYMOUS, InterceptorUtil, USE_CLIENT_TOKEN, ORDER_NORMALIZER, provideDefaultConfig } from '@spartacus/core';
import * as i1 from '@angular/common/http';
import { HttpHeaders, HttpParams } from '@angular/common/http';
import { DELIVERY_MODE_NORMALIZER, PAYMENT_TYPE_NORMALIZER, PAYMENT_DETAILS_SERIALIZER, CARD_TYPE_NORMALIZER, REPLENISHMENT_ORDER_FORM_SERIALIZER, CheckoutAdapter, CheckoutDeliveryAdapter, CheckoutPaymentAdapter, PaymentTypeAdapter, CheckoutCostCenterAdapter, CheckoutReplenishmentOrderAdapter } from '@spartacus/checkout/core';
import { pluck, map, mergeMap } from 'rxjs/operators';
import { CommonModule } from '@angular/common';

class OccReplenishmentOrderFormSerializer {
    convert(source, target) {
        if (target === undefined) {
            target = Object.assign({}, source);
        }
        if (source.replenishmentStartDate) {
            target.replenishmentStartDate = this.convertDate(source.replenishmentStartDate);
        }
        return target;
    }
    /**
     * Adds the current timestamp (including timezone offset) to a date string in the format YYYY-mm-dd
     * @Example
     * Converts 2021-10-15 to 2021-10-15T15:38:05-05:00
     */
    convertDate(date) {
        const localTime = new Date().toLocaleTimeString([], {
            hour: '2-digit',
            minute: '2-digit',
            hourCycle: 'h23',
        });
        return `${date}T${localTime}:00${TimeUtils.getLocalTimezoneOffset()}`;
    }
}
OccReplenishmentOrderFormSerializer.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OccReplenishmentOrderFormSerializer, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
OccReplenishmentOrderFormSerializer.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OccReplenishmentOrderFormSerializer });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OccReplenishmentOrderFormSerializer, decorators: [{
            type: Injectable
        }] });

class OccCheckoutCostCenterAdapter {
    constructor(http, occEndpoints, converter) {
        this.http = http;
        this.occEndpoints = occEndpoints;
        this.converter = converter;
    }
    setCostCenter(userId, cartId, costCenterId) {
        return this.http
            .put(this.getSetCartCostCenterEndpoint(userId, cartId, costCenterId), {})
            .pipe(this.converter.pipeable(CART_NORMALIZER));
    }
    getSetCartCostCenterEndpoint(userId, cartId, costCenterId) {
        return this.occEndpoints.buildUrl('setCartCostCenter', {
            urlParams: { userId, cartId },
            queryParams: { costCenterId },
        });
    }
}
OccCheckoutCostCenterAdapter.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OccCheckoutCostCenterAdapter, deps: [{ token: i1.HttpClient }, { token: i2.OccEndpointsService }, { token: i2.ConverterService }], target: i0.ɵɵFactoryTarget.Injectable });
OccCheckoutCostCenterAdapter.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OccCheckoutCostCenterAdapter });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OccCheckoutCostCenterAdapter, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.HttpClient }, { type: i2.OccEndpointsService }, { type: i2.ConverterService }]; } });

class OccCheckoutDeliveryAdapter {
    constructor(http, occEndpoints, converter) {
        this.http = http;
        this.occEndpoints = occEndpoints;
        this.converter = converter;
    }
    getCreateDeliveryAddressEndpoint(userId, cartId) {
        return this.occEndpoints.buildUrl('createDeliveryAddress', {
            urlParams: {
                userId,
                cartId,
            },
        });
    }
    getSetDeliveryAddressEndpoint(userId, cartId, addressId) {
        return this.occEndpoints.buildUrl('setDeliveryAddress', {
            urlParams: { userId, cartId },
            queryParams: { addressId },
        });
    }
    getDeliveryModeEndpoint(userId, cartId) {
        return this.occEndpoints.buildUrl('deliveryMode', {
            urlParams: {
                userId,
                cartId,
            },
        });
    }
    getSetDeliveryModeEndpoint(userId, cartId, deliveryModeId) {
        return this.occEndpoints.buildUrl('setDeliveryMode', {
            urlParams: {
                userId,
                cartId,
            },
            queryParams: { deliveryModeId },
        });
    }
    getDeliveryModesEndpoint(userId, cartId) {
        return this.occEndpoints.buildUrl('deliveryModes', {
            urlParams: { userId, cartId },
        });
    }
    createAddress(userId, cartId, address) {
        address = this.converter.convert(address, ADDRESS_SERIALIZER);
        return this.http
            .post(this.getCreateDeliveryAddressEndpoint(userId, cartId), address, {
            headers: new HttpHeaders().set('Content-Type', 'application/json'),
        })
            .pipe(this.converter.pipeable(ADDRESS_NORMALIZER));
    }
    setAddress(userId, cartId, addressId) {
        return this.http.put(this.getSetDeliveryAddressEndpoint(userId, cartId, addressId), {});
    }
    setMode(userId, cartId, deliveryModeId) {
        return this.http.put(this.getSetDeliveryModeEndpoint(userId, cartId, deliveryModeId), {});
    }
    getMode(userId, cartId) {
        return this.http
            .get(this.getDeliveryModeEndpoint(userId, cartId))
            .pipe(this.converter.pipeable(DELIVERY_MODE_NORMALIZER));
    }
    getSupportedModes(userId, cartId) {
        return this.http
            .get(this.getDeliveryModesEndpoint(userId, cartId))
            .pipe(pluck('deliveryModes'), map((modes) => modes !== null && modes !== void 0 ? modes : []), this.converter.pipeableMany(DELIVERY_MODE_NORMALIZER));
    }
}
OccCheckoutDeliveryAdapter.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OccCheckoutDeliveryAdapter, deps: [{ token: i1.HttpClient }, { token: i2.OccEndpointsService }, { token: i2.ConverterService }], target: i0.ɵɵFactoryTarget.Injectable });
OccCheckoutDeliveryAdapter.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OccCheckoutDeliveryAdapter });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OccCheckoutDeliveryAdapter, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.HttpClient }, { type: i2.OccEndpointsService }, { type: i2.ConverterService }]; } });

class OccCheckoutPaymentTypeAdapter {
    constructor(http, occEndpoints, converter) {
        this.http = http;
        this.occEndpoints = occEndpoints;
        this.converter = converter;
    }
    loadPaymentTypes() {
        return this.http
            .get(this.getPaymentTypesEndpoint())
            .pipe(map((paymentTypeList) => { var _a; return (_a = paymentTypeList.paymentTypes) !== null && _a !== void 0 ? _a : []; }), this.converter.pipeableMany(PAYMENT_TYPE_NORMALIZER));
    }
    setPaymentType(userId, cartId, paymentType, purchaseOrderNumber) {
        return this.http
            .put(this.getSetCartPaymentTypeEndpoint(userId, cartId, paymentType, purchaseOrderNumber), {})
            .pipe(this.converter.pipeable(CART_NORMALIZER));
    }
    getPaymentTypesEndpoint() {
        return this.occEndpoints.buildUrl('paymentTypes');
    }
    getSetCartPaymentTypeEndpoint(userId, cartId, paymentType, purchaseOrderNumber) {
        const queryParams = purchaseOrderNumber
            ? { paymentType, purchaseOrderNumber }
            : { paymentType };
        return this.occEndpoints.buildUrl('setCartPaymentType', {
            urlParams: { userId, cartId },
            queryParams,
        });
    }
}
OccCheckoutPaymentTypeAdapter.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OccCheckoutPaymentTypeAdapter, deps: [{ token: i1.HttpClient }, { token: i2.OccEndpointsService }, { token: i2.ConverterService }], target: i0.ɵɵFactoryTarget.Injectable });
OccCheckoutPaymentTypeAdapter.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OccCheckoutPaymentTypeAdapter });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OccCheckoutPaymentTypeAdapter, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.HttpClient }, { type: i2.OccEndpointsService }, { type: i2.ConverterService }]; } });

class OccCheckoutPaymentAdapter {
    constructor(http, occEndpoints, converter) {
        this.http = http;
        this.occEndpoints = occEndpoints;
        this.converter = converter;
        if (typeof DOMParser !== 'undefined') {
            this.domparser = new DOMParser();
        }
    }
    getSetPaymentDetailsEndpoint(userId, cartId, paymentDetailsId) {
        return this.occEndpoints.buildUrl('setCartPaymentDetails', {
            urlParams: { userId, cartId },
            queryParams: { paymentDetailsId },
        });
    }
    getPaymentProviderSubInfoEndpoint(userId, cartId) {
        return this.occEndpoints.buildUrl('paymentProviderSubInfo', {
            urlParams: {
                userId,
                cartId,
            },
        });
    }
    getCreatePaymentDetailsEndpoint(userId, cartId) {
        return this.occEndpoints.buildUrl('createPaymentDetails', {
            urlParams: {
                userId,
                cartId,
            },
        });
    }
    getCardTypesEndpoint() {
        return this.occEndpoints.buildUrl('cardTypes');
    }
    create(userId, cartId, paymentDetails) {
        paymentDetails = this.converter.convert(paymentDetails, PAYMENT_DETAILS_SERIALIZER);
        return this.getProviderSubInfo(userId, cartId).pipe(map((data) => {
            const labelsMap = this.convertToMap(data.mappingLabels.entry);
            return {
                url: data.postUrl,
                parameters: this.getParamsForPaymentProvider(paymentDetails, data.parameters.entry, labelsMap),
                mappingLabels: labelsMap,
            };
        }), mergeMap((sub) => {
            // create a subscription directly with payment provider
            return this.createSubWithProvider(sub.url, sub.parameters).pipe(map((response) => this.extractPaymentDetailsFromHtml(response)), mergeMap((fromPaymentProvider) => {
                var _a;
                fromPaymentProvider['defaultPayment'] =
                    (_a = paymentDetails.defaultPayment) !== null && _a !== void 0 ? _a : false;
                fromPaymentProvider['savePaymentInfo'] = true;
                return this.createDetailsWithParameters(userId, cartId, fromPaymentProvider).pipe(this.converter.pipeable(PAYMENT_DETAILS_NORMALIZER));
            }));
        }));
    }
    set(userId, cartId, paymentDetailsId) {
        return this.http.put(this.getSetPaymentDetailsEndpoint(userId, cartId, paymentDetailsId), {});
    }
    loadCardTypes() {
        return this.http.get(this.getCardTypesEndpoint()).pipe(map((cardTypeList) => { var _a; return (_a = cardTypeList.cardTypes) !== null && _a !== void 0 ? _a : []; }), this.converter.pipeableMany(CARD_TYPE_NORMALIZER));
    }
    getProviderSubInfo(userId, cartId) {
        return this.http.get(this.getPaymentProviderSubInfoEndpoint(userId, cartId));
    }
    createSubWithProvider(postUrl, parameters) {
        const headers = new HttpHeaders({
            'Content-Type': 'application/x-www-form-urlencoded',
            Accept: 'text/html',
        });
        let httpParams = new HttpParams({ encoder: new HttpParamsURIEncoder() });
        Object.keys(parameters).forEach((key) => {
            httpParams = httpParams.append(key, parameters[key]);
        });
        return this.http.post(postUrl, httpParams, {
            headers,
            responseType: 'text',
        });
    }
    createDetailsWithParameters(userId, cartId, parameters) {
        let httpParams = new HttpParams({ encoder: new HttpParamsURIEncoder() });
        Object.keys(parameters).forEach((key) => {
            httpParams = httpParams.append(key, parameters[key]);
        });
        const headers = new HttpHeaders({
            'Content-Type': 'application/x-www-form-urlencoded',
        });
        return this.http.post(this.getCreatePaymentDetailsEndpoint(userId, cartId), httpParams, { headers });
    }
    getParamsForPaymentProvider(paymentDetails, parameters, mappingLabels) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        const params = this.convertToMap(parameters);
        params[mappingLabels['hybris_account_holder_name']] =
            paymentDetails.accountHolderName;
        params[mappingLabels['hybris_card_type']] = (_a = paymentDetails.cardType) === null || _a === void 0 ? void 0 : _a.code;
        params[mappingLabels['hybris_card_number']] = paymentDetails.cardNumber;
        if (mappingLabels['hybris_combined_expiry_date'] === 'true') {
            params[mappingLabels['hybris_card_expiry_date']] =
                paymentDetails.expiryMonth +
                    mappingLabels['hybris_separator_expiry_date'] +
                    paymentDetails.expiryYear;
        }
        else {
            params[mappingLabels['hybris_card_expiration_month']] =
                paymentDetails.expiryMonth;
            params[mappingLabels['hybris_card_expiration_year']] =
                paymentDetails.expiryYear;
        }
        params[mappingLabels['hybris_card_cvn']] = paymentDetails.cvn;
        // billing address
        params[mappingLabels['hybris_billTo_country']] =
            (_c = (_b = paymentDetails.billingAddress) === null || _b === void 0 ? void 0 : _b.country) === null || _c === void 0 ? void 0 : _c.isocode;
        params[mappingLabels['hybris_billTo_firstname']] =
            (_d = paymentDetails.billingAddress) === null || _d === void 0 ? void 0 : _d.firstName;
        params[mappingLabels['hybris_billTo_lastname']] =
            (_e = paymentDetails.billingAddress) === null || _e === void 0 ? void 0 : _e.lastName;
        params[mappingLabels['hybris_billTo_street1']] =
            ((_f = paymentDetails.billingAddress) === null || _f === void 0 ? void 0 : _f.line1) +
                ' ' +
                ((_g = paymentDetails.billingAddress) === null || _g === void 0 ? void 0 : _g.line2);
        params[mappingLabels['hybris_billTo_city']] =
            (_h = paymentDetails.billingAddress) === null || _h === void 0 ? void 0 : _h.town;
        if ((_j = paymentDetails.billingAddress) === null || _j === void 0 ? void 0 : _j.region) {
            params[mappingLabels['hybris_billTo_region']] =
                paymentDetails.billingAddress.region.isocodeShort;
        }
        else {
            params[mappingLabels['hybris_billTo_region']] = '';
        }
        params[mappingLabels['hybris_billTo_postalcode']] =
            (_k = paymentDetails.billingAddress) === null || _k === void 0 ? void 0 : _k.postalCode;
        return params;
    }
    extractPaymentDetailsFromHtml(html) {
        const domdoc = this.domparser.parseFromString(html, 'text/xml');
        const responseForm = domdoc.getElementsByTagName('form')[0];
        const inputs = responseForm.getElementsByTagName('input');
        const values = {};
        for (let i = 0; inputs[i]; i++) {
            const input = inputs[i];
            const name = input.getAttribute('name');
            const value = input.getAttribute('value');
            if (name && name !== '{}' && value && value !== '') {
                values[name] = value;
            }
        }
        return values;
    }
    convertToMap(paramList) {
        return paramList.reduce(function (result, item) {
            const key = item.key;
            result[key] = item.value;
            return result;
        }, {});
    }
}
OccCheckoutPaymentAdapter.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OccCheckoutPaymentAdapter, deps: [{ token: i1.HttpClient }, { token: i2.OccEndpointsService }, { token: i2.ConverterService }], target: i0.ɵɵFactoryTarget.Injectable });
OccCheckoutPaymentAdapter.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OccCheckoutPaymentAdapter });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OccCheckoutPaymentAdapter, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.HttpClient }, { type: i2.OccEndpointsService }, { type: i2.ConverterService }]; } });

class OccCheckoutReplenishmentOrderAdapter {
    constructor(http, occEndpoints, converter) {
        this.http = http;
        this.occEndpoints = occEndpoints;
        this.converter = converter;
    }
    getScheduleReplenishmentOrderEndpoint(userId, cartId, termsChecked) {
        return this.occEndpoints.buildUrl('scheduleReplenishmentOrder', {
            urlParams: {
                userId,
            },
            queryParams: { cartId, termsChecked },
        });
    }
    scheduleReplenishmentOrder(cartId, scheduleReplenishmentForm, termsChecked, userId) {
        scheduleReplenishmentForm = this.converter.convert(scheduleReplenishmentForm, REPLENISHMENT_ORDER_FORM_SERIALIZER);
        const headers = new HttpHeaders().set('Content-Type', 'application/json');
        return this.http
            .post(this.getScheduleReplenishmentOrderEndpoint(userId, cartId, termsChecked.toString()), scheduleReplenishmentForm, { headers })
            .pipe(this.converter.pipeable(REPLENISHMENT_ORDER_NORMALIZER));
    }
}
OccCheckoutReplenishmentOrderAdapter.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OccCheckoutReplenishmentOrderAdapter, deps: [{ token: i1.HttpClient }, { token: i2.OccEndpointsService }, { token: i2.ConverterService }], target: i0.ɵɵFactoryTarget.Injectable });
OccCheckoutReplenishmentOrderAdapter.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OccCheckoutReplenishmentOrderAdapter });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OccCheckoutReplenishmentOrderAdapter, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.HttpClient }, { type: i2.OccEndpointsService }, { type: i2.ConverterService }]; } });

class OccCheckoutAdapter {
    constructor(http, occEndpoints, converter) {
        this.http = http;
        this.occEndpoints = occEndpoints;
        this.converter = converter;
    }
    getPlaceOrderEndpoint(userId, cartId, termsChecked) {
        return this.occEndpoints.buildUrl('placeOrder', {
            urlParams: { userId },
            queryParams: { cartId, termsChecked },
        });
    }
    getRemoveDeliveryAddressEndpoint(userId, cartId) {
        return this.occEndpoints.buildUrl('removeDeliveryAddress', {
            urlParams: {
                userId,
                cartId,
            },
        });
    }
    getClearDeliveryModeEndpoint(userId, cartId) {
        return this.occEndpoints.buildUrl('clearDeliveryMode', {
            urlParams: { userId, cartId },
        });
    }
    getLoadCheckoutDetailsEndpoint(userId, cartId) {
        return this.occEndpoints.buildUrl('loadCheckoutDetails', {
            urlParams: {
                userId,
                cartId,
            },
        });
    }
    placeOrder(userId, cartId, termsChecked) {
        let headers = new HttpHeaders({
            'Content-Type': 'application/x-www-form-urlencoded',
        });
        if (userId === OCC_USER_ID_ANONYMOUS) {
            headers = InterceptorUtil.createHeader(USE_CLIENT_TOKEN, true, headers);
        }
        return this.http
            .post(this.getPlaceOrderEndpoint(userId, cartId, termsChecked.toString()), {}, { headers })
            .pipe(this.converter.pipeable(ORDER_NORMALIZER));
    }
    loadCheckoutDetails(userId, cartId) {
        return this.http.get(this.getLoadCheckoutDetailsEndpoint(userId, cartId));
    }
    clearCheckoutDeliveryAddress(userId, cartId) {
        return this.http.delete(this.getRemoveDeliveryAddressEndpoint(userId, cartId));
    }
    clearCheckoutDeliveryMode(userId, cartId) {
        return this.http.delete(this.getClearDeliveryModeEndpoint(userId, cartId));
    }
}
OccCheckoutAdapter.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OccCheckoutAdapter, deps: [{ token: i1.HttpClient }, { token: i2.OccEndpointsService }, { token: i2.ConverterService }], target: i0.ɵɵFactoryTarget.Injectable });
OccCheckoutAdapter.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OccCheckoutAdapter });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OccCheckoutAdapter, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.HttpClient }, { type: i2.OccEndpointsService }, { type: i2.ConverterService }]; } });

const defaultOccCheckoutConfig = {
    backend: {
        occ: {
            endpoints: {
                /* eslint-disable max-len */
                setDeliveryAddress: 'users/${userId}/carts/${cartId}/addresses/delivery',
                placeOrder: 'users/${userId}/orders?fields=FULL',
                cardTypes: 'cardtypes',
                paymentTypes: 'paymenttypes',
                createDeliveryAddress: 'users/${userId}/carts/${cartId}/addresses/delivery',
                removeDeliveryAddress: 'users/${userId}/carts/${cartId}/addresses/delivery',
                deliveryMode: 'users/${userId}/carts/${cartId}/deliverymode',
                setDeliveryMode: 'users/${userId}/carts/${cartId}/deliverymode',
                clearDeliveryMode: 'users/${userId}/carts/${cartId}/deliverymode',
                deliveryModes: 'users/${userId}/carts/${cartId}/deliverymodes',
                setCartCostCenter: 'users/${userId}/carts/${cartId}/costcenter?fields=DEFAULT,potentialProductPromotions,appliedProductPromotions,potentialOrderPromotions,appliedOrderPromotions,entries(totalPrice(formattedValue),product(images(FULL),stock(FULL)),basePrice(formattedValue,value),updateable),totalPrice(formattedValue),totalItems,totalPriceWithTax(formattedValue),totalDiscounts(value,formattedValue),subTotal(formattedValue),deliveryItemsQuantity,deliveryCost(formattedValue),totalTax(formattedValue, value),pickupItemsQuantity,net,appliedVouchers,productDiscounts(formattedValue),user',
                setCartPaymentType: 'users/${userId}/carts/${cartId}/paymenttype?fields=DEFAULT,potentialProductPromotions,appliedProductPromotions,potentialOrderPromotions,appliedOrderPromotions,entries(totalPrice(formattedValue),product(images(FULL),stock(FULL)),basePrice(formattedValue,value),updateable),totalPrice(formattedValue),totalItems,totalPriceWithTax(formattedValue),totalDiscounts(value,formattedValue),subTotal(formattedValue),deliveryItemsQuantity,deliveryCost(formattedValue),totalTax(formattedValue, value),pickupItemsQuantity,net,appliedVouchers,productDiscounts(formattedValue),user',
                setCartPaymentDetails: 'users/${userId}/carts/${cartId}/paymentdetails',
                paymentProviderSubInfo: 'users/${userId}/carts/${cartId}/payment/sop/request?responseUrl=sampleUrl',
                createPaymentDetails: 'users/${userId}/carts/${cartId}/payment/sop/response',
                loadCheckoutDetails: 'users/${userId}/carts/${cartId}?fields=deliveryAddress(FULL),deliveryMode,paymentInfo(FULL)',
                /* eslint-enable */
            },
        },
    },
};

class CheckoutOccModule {
}
CheckoutOccModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutOccModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
CheckoutOccModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutOccModule, imports: [CommonModule] });
CheckoutOccModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutOccModule, providers: [
        provideDefaultConfig(defaultOccCheckoutConfig),
        OccReplenishmentOrderFormSerializer,
        {
            provide: CheckoutAdapter,
            useClass: OccCheckoutAdapter,
        },
        {
            provide: CheckoutDeliveryAdapter,
            useClass: OccCheckoutDeliveryAdapter,
        },
        {
            provide: CheckoutPaymentAdapter,
            useClass: OccCheckoutPaymentAdapter,
        },
        {
            provide: PaymentTypeAdapter,
            useClass: OccCheckoutPaymentTypeAdapter,
        },
        {
            provide: CheckoutCostCenterAdapter,
            useClass: OccCheckoutCostCenterAdapter,
        },
        {
            provide: CheckoutReplenishmentOrderAdapter,
            useClass: OccCheckoutReplenishmentOrderAdapter,
        },
        {
            provide: REPLENISHMENT_ORDER_FORM_SERIALIZER,
            useExisting: OccReplenishmentOrderFormSerializer,
            multi: true,
        },
    ], imports: [[CommonModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutOccModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    providers: [
                        provideDefaultConfig(defaultOccCheckoutConfig),
                        OccReplenishmentOrderFormSerializer,
                        {
                            provide: CheckoutAdapter,
                            useClass: OccCheckoutAdapter,
                        },
                        {
                            provide: CheckoutDeliveryAdapter,
                            useClass: OccCheckoutDeliveryAdapter,
                        },
                        {
                            provide: CheckoutPaymentAdapter,
                            useClass: OccCheckoutPaymentAdapter,
                        },
                        {
                            provide: PaymentTypeAdapter,
                            useClass: OccCheckoutPaymentTypeAdapter,
                        },
                        {
                            provide: CheckoutCostCenterAdapter,
                            useClass: OccCheckoutCostCenterAdapter,
                        },
                        {
                            provide: CheckoutReplenishmentOrderAdapter,
                            useClass: OccCheckoutReplenishmentOrderAdapter,
                        },
                        {
                            provide: REPLENISHMENT_ORDER_FORM_SERIALIZER,
                            useExisting: OccReplenishmentOrderFormSerializer,
                            multi: true,
                        },
                    ],
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { CheckoutOccModule, OccCheckoutAdapter, OccCheckoutCostCenterAdapter, OccCheckoutDeliveryAdapter, OccCheckoutPaymentAdapter, OccCheckoutPaymentTypeAdapter, OccCheckoutReplenishmentOrderAdapter, OccReplenishmentOrderFormSerializer };
//# sourceMappingURL=spartacus-checkout-occ.js.map
