import * as i3$2 from '@angular/common';
import { CommonModule } from '@angular/common';
import * as i0 from '@angular/core';
import { Injectable, Component, NgModule, ChangeDetectionStrategy, isDevMode, Pipe, EventEmitter, Input, Output, ViewChild } from '@angular/core';
import * as i3$1 from '@angular/forms';
import { Validators, FormsModule, ReactiveFormsModule } from '@angular/forms';
import * as i1 from '@spartacus/core';
import { I18nModule, provideDefaultConfig, B2BUserRole, GlobalMessageType, OCC_USER_ID_ANONYMOUS, OCC_USER_ID_GUEST, EMAIL_PATTERN, UrlModule, ConfigModule, isNotUndefined, B2BPaymentTypeEnum, DaysOfWeek, recurrencePeriod, ORDER_TYPE, provideConfig, PromotionLocation, FeaturesConfigModule } from '@spartacus/core';
import * as i4 from '@spartacus/storefront';
import { CustomFormValidators, FormErrorsModule, CartSharedModule, CartValidationGuard, SpinnerModule, ICON_TYPE, SuggestedAddressDialogComponent, CardModule, IconModule, SpinnerComponent, DIALOG_TYPE, PromotionsModule, AddressFormModule, PwaModule, OrderOverviewModule } from '@spartacus/storefront';
import { map, filter, tap, shareReplay, switchMap, skipWhile, debounceTime, distinctUntilChanged, take, withLatestFrom, takeWhile } from 'rxjs/operators';
import * as i3 from '@angular/router';
import { RouterModule } from '@angular/router';
import { combineLatest, of, BehaviorSubject, Subscription } from 'rxjs';
import * as i1$1 from '@spartacus/checkout/root';
import { DeliveryModePreferences, CheckoutStepType, checkoutShippingSteps, checkoutPaymentSteps } from '@spartacus/checkout/root';
import * as i4$1 from '@spartacus/user/account/root';
import * as i5 from '@ng-select/ng-select';
import { NgSelectModule } from '@ng-select/ng-select';
import * as i1$2 from '@spartacus/user/profile/root';

class NotCheckoutAuthGuard {
    constructor(authService, activeCartService, semanticPathService, router) {
        this.authService = authService;
        this.activeCartService = activeCartService;
        this.semanticPathService = semanticPathService;
        this.router = router;
    }
    canActivate() {
        return this.authService.isUserLoggedIn().pipe(map((isLoggedIn) => {
            if (isLoggedIn) {
                return this.router.parseUrl(this.semanticPathService.get('home'));
            }
            else if (this.activeCartService.isGuestCart()) {
                return this.router.parseUrl(this.semanticPathService.get('cart'));
            }
            return !isLoggedIn;
        }));
    }
}
NotCheckoutAuthGuard.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: NotCheckoutAuthGuard, deps: [{ token: i1.AuthService }, { token: i1.ActiveCartService }, { token: i1.SemanticPathService }, { token: i3.Router }], target: i0.ɵɵFactoryTarget.Injectable });
NotCheckoutAuthGuard.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: NotCheckoutAuthGuard, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: NotCheckoutAuthGuard, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.AuthService }, { type: i1.ActiveCartService }, { type: i1.SemanticPathService }, { type: i3.Router }]; } });

class CheckoutLoginComponent {
    constructor(formBuilder, authRedirectService, activeCartService) {
        this.formBuilder = formBuilder;
        this.authRedirectService = authRedirectService;
        this.activeCartService = activeCartService;
        this.checkoutLoginForm = this.formBuilder.group({
            email: ['', [Validators.required, CustomFormValidators.emailValidator]],
            emailConfirmation: ['', [Validators.required]],
        }, {
            validators: CustomFormValidators.emailsMustMatch('email', 'emailConfirmation'),
        });
    }
    onSubmit() {
        var _a;
        if (this.checkoutLoginForm.valid) {
            const email = (_a = this.checkoutLoginForm.get('email')) === null || _a === void 0 ? void 0 : _a.value;
            this.activeCartService.addEmail(email);
            if (!this.sub) {
                this.sub = this.activeCartService.getAssignedUser().subscribe(() => {
                    if (this.activeCartService.isGuestCart()) {
                        this.authRedirectService.redirect();
                    }
                });
            }
        }
        else {
            this.checkoutLoginForm.markAllAsTouched();
        }
    }
    ngOnDestroy() {
        if (this.sub) {
            this.sub.unsubscribe();
        }
    }
}
CheckoutLoginComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutLoginComponent, deps: [{ token: i3$1.FormBuilder }, { token: i1.AuthRedirectService }, { token: i1.ActiveCartService }], target: i0.ɵɵFactoryTarget.Component });
CheckoutLoginComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: CheckoutLoginComponent, selector: "cx-checkout-login", ngImport: i0, template: "<form (ngSubmit)=\"onSubmit()\" [formGroup]=\"checkoutLoginForm\">\n  <div class=\"form-group\">\n    <label>\n      <span class=\"label-content\">{{\n        'checkoutLogin.emailAddress.label' | cxTranslate\n      }}</span>\n      <input\n        aria-required=\"true\"\n        type=\"email\"\n        name=\"email\"\n        class=\"form-control\"\n        formControlName=\"email\"\n        placeholder=\"{{\n          'checkoutLogin.emailAddress.placeholder' | cxTranslate\n        }}\"\n      />\n      <cx-form-errors\n        aria-live=\"assertive\"\n        aria-atomic=\"true\"\n        [control]=\"checkoutLoginForm.get('email')\"\n      ></cx-form-errors>\n    </label>\n  </div>\n\n  <div class=\"form-group\">\n    <label>\n      <span class=\"label-content\">{{\n        'checkoutLogin.confirmEmail.label' | cxTranslate\n      }}</span>\n      <input\n        aria-required=\"true\"\n        type=\"email\"\n        name=\"emailConfirmation\"\n        class=\"form-control\"\n        formControlName=\"emailConfirmation\"\n        placeholder=\"{{\n          'checkoutLogin.confirmEmail.placeholder' | cxTranslate\n        }}\"\n      />\n      <cx-form-errors\n        aria-live=\"assertive\"\n        aria-atomic=\"true\"\n        [control]=\"checkoutLoginForm.get('emailConfirmation')\"\n      ></cx-form-errors>\n    </label>\n  </div>\n\n  <button type=\"submit\" class=\"btn btn-block btn-primary\">\n    {{ 'checkoutLogin.continue' | cxTranslate }}\n  </button>\n</form>\n", components: [{ type: i4.FormErrorsComponent, selector: "cx-form-errors", inputs: ["prefix", "translationParams", "control"] }], directives: [{ type: i3$1.ɵNgNoValidate, selector: "form:not([ngNoForm]):not([ngNativeValidate])" }, { type: i3$1.NgControlStatusGroup, selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { type: i3$1.FormGroupDirective, selector: "[formGroup]", inputs: ["formGroup"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }, { type: i3$1.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { type: i3$1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i3$1.FormControlName, selector: "[formControlName]", inputs: ["disabled", "formControlName", "ngModel"], outputs: ["ngModelChange"] }], pipes: { "cxTranslate": i1.TranslatePipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutLoginComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-checkout-login',
                    templateUrl: './checkout-login.component.html',
                }]
        }], ctorParameters: function () { return [{ type: i3$1.FormBuilder }, { type: i1.AuthRedirectService }, { type: i1.ActiveCartService }]; } });

class CheckoutLoginModule {
}
CheckoutLoginModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutLoginModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
CheckoutLoginModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutLoginModule, declarations: [CheckoutLoginComponent], imports: [CommonModule,
        I18nModule,
        FormsModule,
        ReactiveFormsModule,
        FormsModule,
        ReactiveFormsModule,
        FormErrorsModule], exports: [CheckoutLoginComponent] });
CheckoutLoginModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutLoginModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                GuestCheckoutLoginComponent: {
                    component: CheckoutLoginComponent,
                    guards: [NotCheckoutAuthGuard],
                },
            },
        }),
    ], imports: [[
            CommonModule,
            I18nModule,
            FormsModule,
            ReactiveFormsModule,
            FormsModule,
            ReactiveFormsModule,
            FormErrorsModule,
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutLoginModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        I18nModule,
                        FormsModule,
                        ReactiveFormsModule,
                        FormsModule,
                        ReactiveFormsModule,
                        FormErrorsModule,
                    ],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                GuestCheckoutLoginComponent: {
                                    component: CheckoutLoginComponent,
                                    guards: [NotCheckoutAuthGuard],
                                },
                            },
                        }),
                    ],
                    declarations: [CheckoutLoginComponent],
                    exports: [CheckoutLoginComponent],
                }]
        }] });

class CartNotEmptyGuard {
    constructor(activeCartService, semanticPathService, router) {
        this.activeCartService = activeCartService;
        this.semanticPathService = semanticPathService;
        this.router = router;
    }
    canActivate() {
        return combineLatest([
            this.activeCartService.getActive(),
            this.activeCartService.isStable(),
        ]).pipe(filter(([_, loaded]) => loaded), map(([cart]) => {
            if (this.isEmpty(cart)) {
                return this.router.parseUrl(this.semanticPathService.get('home'));
            }
            return true;
        }));
    }
    isEmpty(cart) {
        return cart && !cart.totalItems;
    }
}
CartNotEmptyGuard.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CartNotEmptyGuard, deps: [{ token: i1.ActiveCartService }, { token: i1.SemanticPathService }, { token: i3.Router }], target: i0.ɵɵFactoryTarget.Injectable });
CartNotEmptyGuard.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CartNotEmptyGuard, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CartNotEmptyGuard, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.ActiveCartService }, { type: i1.SemanticPathService }, { type: i3.Router }]; } });

class CheckoutConfigService {
    constructor(checkoutConfig) {
        var _a, _b, _c, _d, _e;
        this.checkoutConfig = checkoutConfig;
        this.express = (_b = (_a = this.checkoutConfig.checkout) === null || _a === void 0 ? void 0 : _a.express) !== null && _b !== void 0 ? _b : false;
        this.guest = (_d = (_c = this.checkoutConfig.checkout) === null || _c === void 0 ? void 0 : _c.guest) !== null && _d !== void 0 ? _d : false;
        this.defaultDeliveryMode = ((_e = this.checkoutConfig.checkout) === null || _e === void 0 ? void 0 : _e.defaultDeliveryMode) || [];
    }
    compareDeliveryCost(deliveryMode1, deliveryMode2) {
        var _a, _b;
        if (((_a = deliveryMode1.deliveryCost) === null || _a === void 0 ? void 0 : _a.value) &&
            ((_b = deliveryMode2.deliveryCost) === null || _b === void 0 ? void 0 : _b.value)) {
            if (deliveryMode1.deliveryCost.value > deliveryMode2.deliveryCost.value) {
                return 1;
            }
            else if (deliveryMode1.deliveryCost.value < deliveryMode2.deliveryCost.value) {
                return -1;
            }
        }
        return 0;
    }
    findMatchingDeliveryMode(deliveryModes, index = 0) {
        var _a;
        switch (this.defaultDeliveryMode[index]) {
            case DeliveryModePreferences.FREE:
                if (((_a = deliveryModes[0].deliveryCost) === null || _a === void 0 ? void 0 : _a.value) === 0) {
                    return deliveryModes[0].code;
                }
                break;
            case DeliveryModePreferences.LEAST_EXPENSIVE:
                const leastExpensiveFound = deliveryModes.find((deliveryMode) => { var _a; return ((_a = deliveryMode.deliveryCost) === null || _a === void 0 ? void 0 : _a.value) !== 0; });
                if (leastExpensiveFound) {
                    return leastExpensiveFound.code;
                }
                break;
            case DeliveryModePreferences.MOST_EXPENSIVE:
                return deliveryModes[deliveryModes.length - 1].code;
            default:
                const codeFound = deliveryModes.find((deliveryMode) => deliveryMode.code === this.defaultDeliveryMode[index]);
                if (codeFound) {
                    return codeFound.code;
                }
        }
        const lastMode = this.defaultDeliveryMode.length - 1 <= index;
        return lastMode
            ? deliveryModes[0].code
            : this.findMatchingDeliveryMode(deliveryModes, index + 1);
    }
    getPreferredDeliveryMode(deliveryModes) {
        deliveryModes.sort(this.compareDeliveryCost);
        return this.findMatchingDeliveryMode(deliveryModes);
    }
    isExpressCheckout() {
        return this.express;
    }
    isGuestCheckout() {
        return this.guest;
    }
}
CheckoutConfigService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutConfigService, deps: [{ token: i1$1.CheckoutConfig }], target: i0.ɵɵFactoryTarget.Injectable });
CheckoutConfigService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutConfigService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutConfigService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1$1.CheckoutConfig }]; } });

class CheckoutAuthGuard {
    constructor(authService, authRedirectService, checkoutConfigService, activeCartService, semanticPathService, router, userService, globalMessageService) {
        this.authService = authService;
        this.authRedirectService = authRedirectService;
        this.checkoutConfigService = checkoutConfigService;
        this.activeCartService = activeCartService;
        this.semanticPathService = semanticPathService;
        this.router = router;
        this.userService = userService;
        this.globalMessageService = globalMessageService;
    }
    canActivate() {
        return combineLatest([
            this.authService.isUserLoggedIn(),
            this.activeCartService.getAssignedUser(),
            this.userService.get(),
            this.activeCartService.isStable(),
        ]).pipe(filter(([, , _user, isStable]) => isStable), 
        // if the user is authenticated and we have their data, OR if the user is anonymous
        filter(([isLoggedIn, , user]) => (!!user && isLoggedIn) || !isLoggedIn), map(([isLoggedIn, cartUser, user]) => {
            if (!isLoggedIn) {
                return this.handleAnonymousUser(cartUser);
            }
            else if (user && 'roles' in user) {
                return this.handleUserRole(user);
            }
            return isLoggedIn;
        }));
    }
    handleAnonymousUser(cartUser) {
        if (this.activeCartService.isGuestCart()) {
            return !!cartUser;
        }
        this.authRedirectService.saveCurrentNavigationUrl();
        if (this.checkoutConfigService.isGuestCheckout()) {
            return this.router.createUrlTree([this.semanticPathService.get('login')], { queryParams: { forced: true } });
        }
        else {
            return this.router.parseUrl(this.semanticPathService.get('login'));
        }
    }
    handleUserRole(user) {
        const roles = user.roles;
        if (roles === null || roles === void 0 ? void 0 : roles.includes(B2BUserRole.CUSTOMER)) {
            return true;
        }
        this.globalMessageService.add({ key: 'checkout.invalid.accountType' }, GlobalMessageType.MSG_TYPE_WARNING);
        return this.router.parseUrl(this.semanticPathService.get('home'));
    }
}
CheckoutAuthGuard.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutAuthGuard, deps: [{ token: i1.AuthService }, { token: i1.AuthRedirectService }, { token: CheckoutConfigService }, { token: i1.ActiveCartService }, { token: i1.SemanticPathService }, { token: i3.Router }, { token: i4$1.UserAccountFacade }, { token: i1.GlobalMessageService }], target: i0.ɵɵFactoryTarget.Injectable });
CheckoutAuthGuard.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutAuthGuard, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutAuthGuard, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.AuthService }, { type: i1.AuthRedirectService }, { type: CheckoutConfigService }, { type: i1.ActiveCartService }, { type: i1.SemanticPathService }, { type: i3.Router }, { type: i4$1.UserAccountFacade }, { type: i1.GlobalMessageService }]; } });

class CheckoutDetailsService {
    constructor(checkoutService, checkoutDeliveryService, checkoutPaymentService, activeCartService) {
        this.checkoutService = checkoutService;
        this.checkoutDeliveryService = checkoutDeliveryService;
        this.checkoutPaymentService = checkoutPaymentService;
        this.activeCartService = activeCartService;
        this.cartId$ = combineLatest([
            this.activeCartService.getActive(),
            this.activeCartService.isStable(),
        ]).pipe(filter(([, isStable]) => isStable), map(([cartData]) => {
            var _a;
            const cartUser = cartData.user;
            if (cartUser &&
                (cartUser.uid === OCC_USER_ID_ANONYMOUS ||
                    cartUser.uid === OCC_USER_ID_GUEST ||
                    !!((_a = cartUser.uid) === null || _a === void 0 ? void 0 : _a.split('|').slice(1).join('|').match(EMAIL_PATTERN)))) {
                return cartData.guid;
            }
            return cartData.code;
        }), filter((cartId) => !!cartId));
        this.getCheckoutDetailsLoaded$ = this.cartId$.pipe(tap((cartId) => this.checkoutService.loadCheckoutDetails(cartId)), shareReplay(1), switchMap(() => this.checkoutService.getCheckoutDetailsLoaded()), skipWhile((loaded) => !loaded));
    }
    getDeliveryAddress() {
        return this.getCheckoutDetailsLoaded$.pipe(switchMap(() => this.checkoutDeliveryService.getDeliveryAddress()));
    }
    getSelectedDeliveryModeCode() {
        return this.getCheckoutDetailsLoaded$.pipe(switchMap(() => this.checkoutDeliveryService.getSelectedDeliveryModeCode()));
    }
    getPaymentDetails() {
        return this.getCheckoutDetailsLoaded$.pipe(switchMap(() => this.checkoutPaymentService.getPaymentDetails()));
    }
}
CheckoutDetailsService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutDetailsService, deps: [{ token: i1$1.CheckoutFacade }, { token: i1$1.CheckoutDeliveryFacade }, { token: i1$1.CheckoutPaymentFacade }, { token: i1.ActiveCartService }], target: i0.ɵɵFactoryTarget.Injectable });
CheckoutDetailsService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutDetailsService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutDetailsService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1$1.CheckoutFacade }, { type: i1$1.CheckoutDeliveryFacade }, { type: i1$1.CheckoutPaymentFacade }, { type: i1.ActiveCartService }]; } });

class ExpressCheckoutService {
    constructor(userAddressService, userPaymentService, checkoutDeliveryService, checkoutPaymentService, checkoutDetailsService, checkoutConfigService, clearCheckoutService) {
        this.userAddressService = userAddressService;
        this.userPaymentService = userPaymentService;
        this.checkoutDeliveryService = checkoutDeliveryService;
        this.checkoutPaymentService = checkoutPaymentService;
        this.checkoutDetailsService = checkoutDetailsService;
        this.checkoutConfigService = checkoutConfigService;
        this.clearCheckoutService = clearCheckoutService;
        this.setShippingAddress();
        this.setDeliveryMode();
        this.setPaymentMethod();
    }
    setShippingAddress() {
        this.shippingAddressSet$ = combineLatest([
            this.userAddressService.getAddresses(),
            this.userAddressService.getAddressesLoadedSuccess(),
            this.checkoutDeliveryService.getSetDeliveryAddressProcess(),
        ]).pipe(debounceTime(0), tap(([, addressesLoadedSuccess]) => {
            if (!addressesLoadedSuccess) {
                this.userAddressService.loadAddresses();
            }
        }), filter(([, addressesLoadedSuccess]) => addressesLoadedSuccess), switchMap(([addresses, , setDeliveryAddressProcess]) => {
            const defaultAddress = addresses.find((address) => address.defaultAddress) || addresses[0];
            if (defaultAddress && Object.keys(defaultAddress).length) {
                if (!(setDeliveryAddressProcess.success ||
                    setDeliveryAddressProcess.error ||
                    setDeliveryAddressProcess.loading)) {
                    this.checkoutDeliveryService.setDeliveryAddress(defaultAddress);
                }
                return of(setDeliveryAddressProcess).pipe(filter((setDeliveryAddressProcessState) => {
                    var _a;
                    return ((_a = ((setDeliveryAddressProcessState.success ||
                        setDeliveryAddressProcessState.error) &&
                        !setDeliveryAddressProcessState.loading)) !== null && _a !== void 0 ? _a : false);
                }), switchMap((setDeliveryAddressProcessState) => {
                    if (setDeliveryAddressProcessState.success) {
                        return this.checkoutDetailsService.getDeliveryAddress();
                    }
                    return of(false);
                }), map((data) => Boolean(data && Object.keys(data).length)));
            }
            return of(false);
        }), distinctUntilChanged());
    }
    setPaymentMethod() {
        this.paymentMethodSet$ = combineLatest([
            this.deliveryModeSet$,
            this.userPaymentService.getPaymentMethods(),
            this.userPaymentService.getPaymentMethodsLoadedSuccess(),
            this.checkoutPaymentService.getSetPaymentDetailsResultProcess(),
        ]).pipe(debounceTime(0), tap(([, , paymentMethodsLoadedSuccess]) => {
            if (!paymentMethodsLoadedSuccess) {
                this.userPaymentService.loadPaymentMethods();
            }
        }), filter(([, , success]) => success), switchMap(([deliveryModeSet, payments, , setPaymentDetailsProcess]) => {
            if (!deliveryModeSet) {
                return of(false);
            }
            const defaultPayment = payments.find((address) => address.defaultPayment) || payments[0];
            if (defaultPayment && Object.keys(defaultPayment).length) {
                if (!(setPaymentDetailsProcess.success ||
                    setPaymentDetailsProcess.error ||
                    setPaymentDetailsProcess.loading)) {
                    this.checkoutPaymentService.setPaymentDetails(defaultPayment);
                }
                return of(setPaymentDetailsProcess).pipe(filter((setPaymentDetailsProcessState) => {
                    var _a;
                    return ((_a = ((setPaymentDetailsProcessState.success ||
                        setPaymentDetailsProcessState.error) &&
                        !setPaymentDetailsProcessState.loading)) !== null && _a !== void 0 ? _a : false);
                }), switchMap((setPaymentDetailsProcessState) => {
                    if (setPaymentDetailsProcessState.success) {
                        return this.checkoutDetailsService.getPaymentDetails();
                    }
                    return of(false);
                }), map((data) => Boolean(data && Object.keys(data).length)));
            }
            return of(false);
        }));
    }
    setDeliveryMode() {
        this.deliveryModeSet$ = combineLatest([
            this.shippingAddressSet$,
            this.checkoutDeliveryService.getSupportedDeliveryModes(),
            this.checkoutDeliveryService.getSetDeliveryModeProcess(),
            this.checkoutDeliveryService.getLoadSupportedDeliveryModeProcess(),
        ]).pipe(debounceTime(0), switchMap(([addressSet, supportedDeliveryModes, setDeliveryModeStatusFlag, loadSupportedDeliveryModeStatus,]) => {
            if (addressSet) {
                return of([
                    supportedDeliveryModes,
                    setDeliveryModeStatusFlag,
                    loadSupportedDeliveryModeStatus,
                ]).pipe(filter(([, , supportedDeliveryModeStatus]) => { var _a; return (_a = supportedDeliveryModeStatus.success) !== null && _a !== void 0 ? _a : false; }), switchMap(([deliveryModes, setDeliveryModeStatus, ,]) => {
                    if (Boolean(deliveryModes.length)) {
                        const preferredDeliveryMode = this.checkoutConfigService.getPreferredDeliveryMode(deliveryModes);
                        return of([
                            preferredDeliveryMode,
                            setDeliveryModeStatus,
                        ]).pipe(tap(([deliveryMode, deliveryModeLoadingStatus]) => {
                            if (deliveryMode &&
                                !(deliveryModeLoadingStatus.success ||
                                    deliveryModeLoadingStatus.error ||
                                    deliveryModeLoadingStatus.loading)) {
                                this.checkoutDeliveryService.setDeliveryMode(deliveryMode);
                            }
                        }), filter(([, deliveryModeLoadingStatus]) => {
                            var _a;
                            return ((_a = ((deliveryModeLoadingStatus.success ||
                                deliveryModeLoadingStatus.error) &&
                                !deliveryModeLoadingStatus.loading)) !== null && _a !== void 0 ? _a : false);
                        }), switchMap(([, deliveryModeLoadingStatus]) => {
                            if (deliveryModeLoadingStatus.success) {
                                return this.checkoutDetailsService.getSelectedDeliveryModeCode();
                            }
                            return of(false);
                        }), map((data) => Boolean(data)));
                    }
                    return of(false);
                }));
            }
            else {
                return of(false);
            }
        }), distinctUntilChanged());
    }
    trySetDefaultCheckoutDetails() {
        this.clearCheckoutService.resetCheckoutProcesses();
        return this.paymentMethodSet$.pipe(map((paymentMethodSet) => Boolean(paymentMethodSet)));
    }
}
ExpressCheckoutService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ExpressCheckoutService, deps: [{ token: i1.UserAddressService }, { token: i1.UserPaymentService }, { token: i1$1.CheckoutDeliveryFacade }, { token: i1$1.CheckoutPaymentFacade }, { token: CheckoutDetailsService }, { token: CheckoutConfigService }, { token: i1$1.ClearCheckoutFacade }], target: i0.ɵɵFactoryTarget.Injectable });
ExpressCheckoutService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ExpressCheckoutService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ExpressCheckoutService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.UserAddressService }, { type: i1.UserPaymentService }, { type: i1$1.CheckoutDeliveryFacade }, { type: i1$1.CheckoutPaymentFacade }, { type: CheckoutDetailsService }, { type: CheckoutConfigService }, { type: i1$1.ClearCheckoutFacade }]; } });

class CheckoutStepService {
    constructor(routingService, checkoutConfig, routingConfigService) {
        this.routingService = routingService;
        this.checkoutConfig = checkoutConfig;
        this.routingConfigService = routingConfigService;
        this.steps$ = new BehaviorSubject([]);
        this.activeStepIndex$ = this.routingService
            .getRouterState()
            .pipe(switchMap((router) => {
            const activeStepUrl = router.state.context.id;
            return this.steps$.pipe(map((steps) => {
                let activeIndex = 0;
                steps.forEach((step, index) => {
                    var _a;
                    const routeUrl = `/${(_a = this.routingConfigService.getRouteConfig(step.routeName)
                        .paths) === null || _a === void 0 ? void 0 : _a[0]}`;
                    if (routeUrl === activeStepUrl) {
                        activeIndex = index;
                    }
                });
                return activeIndex;
            }));
        }));
        this.resetSteps();
    }
    back(activatedRoute) {
        const previousUrl = this.getPreviousCheckoutStepUrl(activatedRoute);
        this.routingService.go(previousUrl === null ? 'cart' : previousUrl);
    }
    next(activatedRoute) {
        const nextUrl = this.getNextCheckoutStepUrl(activatedRoute);
        this.routingService.go(nextUrl);
    }
    goToStepWithIndex(stepIndex) {
        this.routingService.go(this.getStepUrlFromStepRoute(this.allSteps[stepIndex].routeName));
    }
    getBackBntText(activatedRoute) {
        if (this.getPreviousCheckoutStepUrl(activatedRoute) === null) {
            return 'checkout.backToCart';
        }
        return 'common.back';
    }
    resetSteps() {
        var _a, _b;
        this.allSteps = ((_b = (_a = this.checkoutConfig.checkout) === null || _a === void 0 ? void 0 : _a.steps) !== null && _b !== void 0 ? _b : [])
            .filter((step) => !step.disabled)
            .map((x) => Object.assign({}, x));
        this.steps$.next(this.allSteps);
    }
    disableEnableStep(currentStepType, disabled) {
        const currentStep = this.allSteps.find((step) => step.type.includes(currentStepType));
        if (currentStep && currentStep.disabled !== disabled) {
            currentStep.disabled = disabled;
            this.steps$.next(this.allSteps.filter((step) => !step.disabled));
        }
    }
    getCheckoutStep(currentStepType) {
        const index = this.getCheckoutStepIndex('type', currentStepType);
        if (index !== null) {
            return this.allSteps[index];
        }
    }
    getCheckoutStepRoute(currentStepType) {
        var _a;
        return (_a = this.getCheckoutStep(currentStepType)) === null || _a === void 0 ? void 0 : _a.routeName;
    }
    getFirstCheckoutStepRoute() {
        return this.allSteps[0].routeName;
    }
    getNextCheckoutStepUrl(activatedRoute) {
        const stepIndex = this.getCurrentStepIndex(activatedRoute);
        if (stepIndex !== null && stepIndex >= 0) {
            let i = 1;
            while (this.allSteps[stepIndex + i] &&
                this.allSteps[stepIndex + i].disabled) {
                i++;
            }
            const nextStep = this.allSteps[stepIndex + i];
            if (nextStep) {
                return this.getStepUrlFromStepRoute(nextStep.routeName);
            }
        }
        return null;
    }
    getPreviousCheckoutStepUrl(activatedRoute) {
        const stepIndex = this.getCurrentStepIndex(activatedRoute);
        if (stepIndex !== null && stepIndex >= 0) {
            let i = 1;
            while (this.allSteps[stepIndex - i] &&
                this.allSteps[stepIndex - i].disabled) {
                i++;
            }
            const previousStep = this.allSteps[stepIndex - i];
            if (previousStep) {
                return this.getStepUrlFromStepRoute(previousStep.routeName);
            }
        }
        return null;
    }
    getCurrentStepIndex(activatedRoute) {
        const currentStepUrl = this.getStepUrlFromActivatedRoute(activatedRoute);
        const stepIndex = this.allSteps.findIndex((step) => currentStepUrl === `/${this.getStepUrlFromStepRoute(step.routeName)}`);
        return stepIndex === -1 ? null : stepIndex;
    }
    getStepUrlFromActivatedRoute(activatedRoute) {
        return activatedRoute &&
            activatedRoute.snapshot &&
            activatedRoute.snapshot.url
            ? `/${activatedRoute.snapshot.url.join('/')}`
            : null;
    }
    getStepUrlFromStepRoute(stepRoute) {
        var _a, _b;
        return ((_b = (_a = this.routingConfigService.getRouteConfig(stepRoute).paths) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : null);
    }
    getCheckoutStepIndex(key, value) {
        return key && value
            ? this.allSteps.findIndex((step) => {
                const propertyVal = step[key];
                return propertyVal instanceof Array
                    ? propertyVal.includes(value)
                    : propertyVal === value;
            })
            : null;
    }
}
CheckoutStepService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutStepService, deps: [{ token: i1.RoutingService }, { token: i1$1.CheckoutConfig }, { token: i1.RoutingConfigService }], target: i0.ɵɵFactoryTarget.Injectable });
CheckoutStepService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutStepService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutStepService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.RoutingService }, { type: i1$1.CheckoutConfig }, { type: i1.RoutingConfigService }]; } });

class CheckoutGuard {
    constructor(router, routingConfigService, checkoutConfigService, expressCheckoutService, activeCartService, checkoutStepService) {
        var _a;
        this.router = router;
        this.routingConfigService = routingConfigService;
        this.checkoutConfigService = checkoutConfigService;
        this.expressCheckoutService = expressCheckoutService;
        this.activeCartService = activeCartService;
        this.checkoutStepService = checkoutStepService;
        this.firstStep$ = of(this.router.parseUrl((_a = this.routingConfigService.getRouteConfig(this.checkoutStepService.getFirstCheckoutStepRoute()).paths) === null || _a === void 0 ? void 0 : _a[0]));
    }
    canActivate() {
        if (this.checkoutConfigService.isExpressCheckout() &&
            !this.activeCartService.isGuestCart()) {
            return this.expressCheckoutService.trySetDefaultCheckoutDetails().pipe(switchMap((expressCheckoutPossible) => {
                var _a;
                const reviewOrderRoute = this.checkoutStepService.getCheckoutStepRoute(CheckoutStepType.REVIEW_ORDER);
                return expressCheckoutPossible && reviewOrderRoute
                    ? of(this.router.parseUrl((_a = this.routingConfigService.getRouteConfig(reviewOrderRoute)
                        .paths) === null || _a === void 0 ? void 0 : _a[0]))
                    : this.firstStep$;
            }));
        }
        return this.firstStep$;
    }
}
CheckoutGuard.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutGuard, deps: [{ token: i3.Router }, { token: i1.RoutingConfigService }, { token: CheckoutConfigService }, { token: ExpressCheckoutService }, { token: i1.ActiveCartService }, { token: CheckoutStepService }], target: i0.ɵɵFactoryTarget.Injectable });
CheckoutGuard.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutGuard, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutGuard, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i3.Router }, { type: i1.RoutingConfigService }, { type: CheckoutConfigService }, { type: ExpressCheckoutService }, { type: i1.ActiveCartService }, { type: CheckoutStepService }]; } });

class CheckoutOrchestratorComponent {
    constructor() { }
}
CheckoutOrchestratorComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutOrchestratorComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
CheckoutOrchestratorComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: CheckoutOrchestratorComponent, selector: "cx-checkout-orchestrator", ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutOrchestratorComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-checkout-orchestrator',
                    template: '',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return []; } });

class CheckoutOrchestratorModule {
}
CheckoutOrchestratorModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutOrchestratorModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
CheckoutOrchestratorModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutOrchestratorModule, declarations: [CheckoutOrchestratorComponent], imports: [CommonModule], exports: [CheckoutOrchestratorComponent] });
CheckoutOrchestratorModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutOrchestratorModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                CheckoutOrchestrator: {
                    component: CheckoutOrchestratorComponent,
                    guards: [CheckoutAuthGuard, CartNotEmptyGuard, CheckoutGuard],
                },
            },
        }),
    ], imports: [[CommonModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutOrchestratorModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                CheckoutOrchestrator: {
                                    component: CheckoutOrchestratorComponent,
                                    guards: [CheckoutAuthGuard, CartNotEmptyGuard, CheckoutGuard],
                                },
                            },
                        }),
                    ],
                    declarations: [CheckoutOrchestratorComponent],
                    exports: [CheckoutOrchestratorComponent],
                }]
        }] });

class CheckoutOrderSummaryComponent {
    constructor(activeCartService) {
        this.activeCartService = activeCartService;
        this.cart$ = this.activeCartService.getActive();
    }
}
CheckoutOrderSummaryComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutOrderSummaryComponent, deps: [{ token: i1.ActiveCartService }], target: i0.ɵɵFactoryTarget.Component });
CheckoutOrderSummaryComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: CheckoutOrderSummaryComponent, selector: "cx-checkout-order-summary", ngImport: i0, template: "<cx-order-summary [cart]=\"cart$ | async\"></cx-order-summary>\n", components: [{ type: i4.OrderSummaryComponent, selector: "cx-order-summary", inputs: ["cart"] }], pipes: { "async": i3$2.AsyncPipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutOrderSummaryComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-checkout-order-summary',
                    templateUrl: './checkout-order-summary.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: i1.ActiveCartService }]; } });

class CheckoutOrderSummaryModule {
}
CheckoutOrderSummaryModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutOrderSummaryModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
CheckoutOrderSummaryModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutOrderSummaryModule, declarations: [CheckoutOrderSummaryComponent], imports: [CommonModule, CartSharedModule], exports: [CheckoutOrderSummaryComponent] });
CheckoutOrderSummaryModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutOrderSummaryModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                CheckoutOrderSummary: {
                    component: CheckoutOrderSummaryComponent,
                },
            },
        }),
    ], imports: [[CommonModule, CartSharedModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutOrderSummaryModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, CartSharedModule],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                CheckoutOrderSummary: {
                                    component: CheckoutOrderSummaryComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [CheckoutOrderSummaryComponent],
                    exports: [CheckoutOrderSummaryComponent],
                }]
        }] });

class CheckoutStepsSetGuard {
    constructor(paymentTypeService, checkoutStepService, checkoutDetailsService, routingConfigService, checkoutCostCenterService, router) {
        this.paymentTypeService = paymentTypeService;
        this.checkoutStepService = checkoutStepService;
        this.checkoutDetailsService = checkoutDetailsService;
        this.routingConfigService = routingConfigService;
        this.checkoutCostCenterService = checkoutCostCenterService;
        this.router = router;
    }
    canActivate(route, _) {
        let currentIndex = -1;
        const currentRouteUrl = '/' + route.url.join('/');
        // check whether the previous step is set
        return combineLatest([
            this.checkoutStepService.steps$,
            this.paymentTypeService.isAccountPayment(),
        ]).pipe(tap(([, isAccount]) => {
            this.checkoutStepService.disableEnableStep(CheckoutStepType.PAYMENT_DETAILS, isAccount);
        }), take(1), switchMap(([steps, isAccount]) => {
            currentIndex = steps.findIndex((step) => {
                var _a;
                const stepRouteUrl = `/${(_a = this.routingConfigService.getRouteConfig(step.routeName).paths) === null || _a === void 0 ? void 0 : _a[0]}`;
                return stepRouteUrl === currentRouteUrl;
            });
            // get current step
            let currentStep;
            if (currentIndex >= 0) {
                currentStep = steps[currentIndex];
            }
            if (Boolean(currentStep)) {
                return this.isStepSet(steps[currentIndex - 1], isAccount);
            }
            else {
                if (isDevMode()) {
                    console.warn(`Missing step with route '${currentRouteUrl}' in checkout configuration or this step is disabled.`);
                }
                return of(this.getUrl('checkout'));
            }
        }));
    }
    isStepSet(step, isAccountPayment) {
        if (step && !step.disabled) {
            switch (step.type[0]) {
                case CheckoutStepType.PAYMENT_TYPE: {
                    return this.isPaymentTypeSet(step);
                }
                case CheckoutStepType.SHIPPING_ADDRESS: {
                    return this.isShippingAddressAndCostCenterSet(step, isAccountPayment);
                }
                case CheckoutStepType.DELIVERY_MODE: {
                    return this.isDeliveryModeSet(step);
                }
                case CheckoutStepType.PAYMENT_DETAILS: {
                    return this.isPaymentDetailsSet(step);
                }
                case CheckoutStepType.REVIEW_ORDER: {
                    break;
                }
            }
        }
        return of(true);
    }
    isPaymentTypeSet(step) {
        return this.paymentTypeService.getSelectedPaymentType().pipe(map((paymentType) => {
            if (Boolean(paymentType)) {
                return true;
            }
            else {
                return this.getUrl(step.routeName);
            }
        }));
    }
    isShippingAddressAndCostCenterSet(step, isAccountPayment) {
        return combineLatest([
            this.checkoutDetailsService.getDeliveryAddress(),
            this.checkoutCostCenterService.getCostCenter(),
        ]).pipe(map(([deliveryAddress, costCenter]) => {
            if (isAccountPayment) {
                if (deliveryAddress &&
                    Object.keys(deliveryAddress).length &&
                    Boolean(costCenter)) {
                    return true;
                }
                else {
                    return this.getUrl(step.routeName);
                }
            }
            else {
                if (deliveryAddress &&
                    Object.keys(deliveryAddress).length &&
                    costCenter === undefined) {
                    return true;
                }
                else {
                    return this.getUrl(step.routeName);
                }
            }
        }));
    }
    isDeliveryModeSet(step) {
        return this.checkoutDetailsService
            .getSelectedDeliveryModeCode()
            .pipe(map((mode) => mode && mode.length ? true : this.getUrl(step.routeName)));
    }
    isPaymentDetailsSet(step) {
        return this.checkoutDetailsService
            .getPaymentDetails()
            .pipe(map((paymentDetails) => paymentDetails && Object.keys(paymentDetails).length !== 0
            ? true
            : this.getUrl(step.routeName)));
    }
    getUrl(routeName) {
        var _a;
        return this.router.parseUrl((_a = this.routingConfigService.getRouteConfig(routeName).paths) === null || _a === void 0 ? void 0 : _a[0]);
    }
}
CheckoutStepsSetGuard.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutStepsSetGuard, deps: [{ token: i1$1.PaymentTypeFacade }, { token: CheckoutStepService }, { token: CheckoutDetailsService }, { token: i1.RoutingConfigService }, { token: i1$1.CheckoutCostCenterFacade }, { token: i3.Router }], target: i0.ɵɵFactoryTarget.Injectable });
CheckoutStepsSetGuard.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutStepsSetGuard, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutStepsSetGuard, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1$1.PaymentTypeFacade }, { type: CheckoutStepService }, { type: CheckoutDetailsService }, { type: i1.RoutingConfigService }, { type: i1$1.CheckoutCostCenterFacade }, { type: i3.Router }]; } });

class CheckoutProgressMobileBottomComponent {
    constructor(checkoutStepService) {
        this.checkoutStepService = checkoutStepService;
        this._steps$ = this.checkoutStepService.steps$;
        this.activeStepIndex$ = this.checkoutStepService.activeStepIndex$.pipe(tap((index) => (this.activeStepIndex = index)));
    }
    get steps$() {
        return this._steps$.asObservable();
    }
}
CheckoutProgressMobileBottomComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutProgressMobileBottomComponent, deps: [{ token: CheckoutStepService }], target: i0.ɵɵFactoryTarget.Component });
CheckoutProgressMobileBottomComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: CheckoutProgressMobileBottomComponent, selector: "cx-checkout-progress-mobile-bottom", ngImport: i0, template: "<div *ngIf=\"(activeStepIndex$ | async) !== undefined\">\n  <div class=\"cx-media\">\n    <div *ngFor=\"let step of steps$ | async; let i = index\">\n      <div class=\"cx-list-media\" *ngIf=\"i > activeStepIndex\">\n        <div>{{ i + 1 }}. {{ step.name | cxTranslate }}</div>\n      </div>\n    </div>\n  </div>\n</div>\n", directives: [{ type: i3$2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3$2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], pipes: { "async": i3$2.AsyncPipe, "cxTranslate": i1.TranslatePipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutProgressMobileBottomComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-checkout-progress-mobile-bottom',
                    templateUrl: './checkout-progress-mobile-bottom.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: CheckoutStepService }]; } });

class CheckoutProgressMobileBottomModule {
}
CheckoutProgressMobileBottomModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutProgressMobileBottomModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
CheckoutProgressMobileBottomModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutProgressMobileBottomModule, declarations: [CheckoutProgressMobileBottomComponent], imports: [CommonModule, UrlModule, I18nModule, RouterModule], exports: [CheckoutProgressMobileBottomComponent] });
CheckoutProgressMobileBottomModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutProgressMobileBottomModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                CheckoutProgressMobileBottom: {
                    component: CheckoutProgressMobileBottomComponent,
                    guards: [CheckoutAuthGuard, CartNotEmptyGuard, CheckoutStepsSetGuard],
                },
            },
        }),
    ], imports: [[CommonModule, UrlModule, I18nModule, RouterModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutProgressMobileBottomModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, UrlModule, I18nModule, RouterModule],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                CheckoutProgressMobileBottom: {
                                    component: CheckoutProgressMobileBottomComponent,
                                    guards: [CheckoutAuthGuard, CartNotEmptyGuard, CheckoutStepsSetGuard],
                                },
                            },
                        }),
                    ],
                    declarations: [CheckoutProgressMobileBottomComponent],
                    exports: [CheckoutProgressMobileBottomComponent],
                }]
        }] });

class CheckoutProgressMobileTopComponent {
    constructor(activeCartService, checkoutStepService) {
        this.activeCartService = activeCartService;
        this.checkoutStepService = checkoutStepService;
        this._steps$ = this.checkoutStepService.steps$;
        this.activeStepIndex$ = this.checkoutStepService.activeStepIndex$.pipe(tap((index) => (this.activeStepIndex = index)));
    }
    get steps$() {
        return this._steps$.asObservable();
    }
    ngOnInit() {
        this.cart$ = this.activeCartService.getActive();
    }
}
CheckoutProgressMobileTopComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutProgressMobileTopComponent, deps: [{ token: i1.ActiveCartService }, { token: CheckoutStepService }], target: i0.ɵɵFactoryTarget.Component });
CheckoutProgressMobileTopComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: CheckoutProgressMobileTopComponent, selector: "cx-checkout-progress-mobile-top", ngImport: i0, template: "<div *ngIf=\"(activeStepIndex$ | async) !== undefined\">\n  <div *ngIf=\"cart$ | async as cart\">\n    <div class=\"cx-media\">\n      <div class=\"cx-list-media\" *ngIf=\"cart?.totalItems && cart?.subTotal\">\n        {{ 'cartItems.cartTotal' | cxTranslate: { count: cart.totalItems } }}:\n        {{ cart.subTotal.formattedValue }}\n      </div>\n      <div *ngFor=\"let step of steps$ | async; let i = index\">\n        <div class=\"cx-list-media\" *ngIf=\"i < activeStepIndex\">\n          <div>{{ i + 1 }}. {{ step.name | cxTranslate }}</div>\n          <button\n            class=\"btn btn-link\"\n            [routerLink]=\"{ cxRoute: step.routeName } | cxUrl\"\n          >\n            {{ 'common.edit' | cxTranslate }}\n          </button>\n        </div>\n        <div class=\"cx-list-media is-active\" *ngIf=\"i === activeStepIndex\">\n          <div>{{ i + 1 }}. {{ step.name | cxTranslate }}</div>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n", directives: [{ type: i3$2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3$2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i3.RouterLink, selector: ":not(a):not(area)[routerLink]", inputs: ["routerLink", "queryParams", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange", "replaceUrl", "state", "relativeTo"] }], pipes: { "async": i3$2.AsyncPipe, "cxTranslate": i1.TranslatePipe, "cxUrl": i1.UrlPipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutProgressMobileTopComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-checkout-progress-mobile-top',
                    templateUrl: './checkout-progress-mobile-top.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: i1.ActiveCartService }, { type: CheckoutStepService }]; } });

class CheckoutProgressMobileTopModule {
}
CheckoutProgressMobileTopModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutProgressMobileTopModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
CheckoutProgressMobileTopModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutProgressMobileTopModule, declarations: [CheckoutProgressMobileTopComponent], imports: [CommonModule, UrlModule, I18nModule, RouterModule], exports: [CheckoutProgressMobileTopComponent] });
CheckoutProgressMobileTopModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutProgressMobileTopModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                CheckoutProgressMobileTop: {
                    component: CheckoutProgressMobileTopComponent,
                    guards: [CheckoutAuthGuard, CartNotEmptyGuard, CheckoutStepsSetGuard],
                },
            },
        }),
    ], imports: [[CommonModule, UrlModule, I18nModule, RouterModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutProgressMobileTopModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, UrlModule, I18nModule, RouterModule],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                CheckoutProgressMobileTop: {
                                    component: CheckoutProgressMobileTopComponent,
                                    guards: [CheckoutAuthGuard, CartNotEmptyGuard, CheckoutStepsSetGuard],
                                },
                            },
                        }),
                    ],
                    declarations: [CheckoutProgressMobileTopComponent],
                    exports: [CheckoutProgressMobileTopComponent],
                }]
        }] });

class MultiLinePipe {
    transform(value) {
        const lastIndex = value.lastIndexOf(' ');
        if (lastIndex === -1)
            return value;
        return (value.substring(0, lastIndex) +
            '<br />' +
            value.substring(lastIndex, value.length).trim());
    }
}
MultiLinePipe.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: MultiLinePipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe });
MultiLinePipe.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: MultiLinePipe, name: "cxMultiLine" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: MultiLinePipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'cxMultiLine',
                }]
        }] });

class CheckoutProgressComponent {
    constructor(checkoutStepService) {
        this.checkoutStepService = checkoutStepService;
        this._steps$ = this.checkoutStepService.steps$;
        this.activeStepIndex$ = this.checkoutStepService.activeStepIndex$.pipe(tap((index) => (this.activeStepIndex = index)));
    }
    get steps$() {
        return this._steps$.asObservable();
    }
    getTabIndex(stepIndex) {
        return !this.isActive(stepIndex) && !this.isDisabled(stepIndex) ? 0 : -1;
    }
    isActive(index) {
        return index === this.activeStepIndex;
    }
    isDisabled(index) {
        return index > this.activeStepIndex;
    }
}
CheckoutProgressComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutProgressComponent, deps: [{ token: CheckoutStepService }], target: i0.ɵɵFactoryTarget.Component });
CheckoutProgressComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: CheckoutProgressComponent, selector: "cx-checkout-progress", ngImport: i0, template: "<section *ngIf=\"(activeStepIndex$ | async) !== undefined\">\n  <div class=\"cx-nav d-none d-lg-block d-xl-block\">\n    <ul class=\"cx-list\">\n      <ng-container *ngFor=\"let step of steps$ | async; let i = index\">\n        <li\n          class=\"cx-item\"\n          [class.active]=\"isActive(i)\"\n          [class.disabled]=\"isDisabled(i)\"\n        >\n          <a\n            [routerLink]=\"{ cxRoute: step.routeName } | cxUrl\"\n            class=\"cx-link\"\n            [class.active]=\"isActive(i)\"\n            [class.disabled]=\"isDisabled(i)\"\n            [tabindex]=\"getTabIndex(i)\"\n            [innerHTML]=\"step.name | cxTranslate | cxMultiLine\"\n          >\n          </a>\n        </li>\n      </ng-container>\n    </ul>\n  </div>\n</section>\n", directives: [{ type: i3$2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3$2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i3.RouterLinkWithHref, selector: "a[routerLink],area[routerLink]", inputs: ["routerLink", "target", "queryParams", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange", "replaceUrl", "state", "relativeTo"] }], pipes: { "async": i3$2.AsyncPipe, "cxUrl": i1.UrlPipe, "cxMultiLine": MultiLinePipe, "cxTranslate": i1.TranslatePipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutProgressComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-checkout-progress',
                    templateUrl: './checkout-progress.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: CheckoutStepService }]; } });

class CheckoutProgressModule {
}
CheckoutProgressModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutProgressModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
CheckoutProgressModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutProgressModule, declarations: [CheckoutProgressComponent, MultiLinePipe], imports: [CommonModule, UrlModule, I18nModule, RouterModule], exports: [CheckoutProgressComponent] });
CheckoutProgressModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutProgressModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                CheckoutProgress: {
                    component: CheckoutProgressComponent,
                    guards: [CheckoutAuthGuard, CartNotEmptyGuard, CheckoutStepsSetGuard],
                },
            },
        }),
    ], imports: [[CommonModule, UrlModule, I18nModule, RouterModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutProgressModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, UrlModule, I18nModule, RouterModule],
                    declarations: [CheckoutProgressComponent, MultiLinePipe],
                    exports: [CheckoutProgressComponent],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                CheckoutProgress: {
                                    component: CheckoutProgressComponent,
                                    guards: [CheckoutAuthGuard, CartNotEmptyGuard, CheckoutStepsSetGuard],
                                },
                            },
                        }),
                    ],
                }]
        }] });

class CostCenterComponent {
    constructor(userCostCenterService, checkoutCostCenterService, paymentTypeService) {
        this.userCostCenterService = userCostCenterService;
        this.checkoutCostCenterService = checkoutCostCenterService;
        this.paymentTypeService = paymentTypeService;
    }
    get isAccountPayment$() {
        return this.paymentTypeService.isAccountPayment();
    }
    get costCenters$() {
        return this.userCostCenterService.getActiveCostCenters().pipe(withLatestFrom(this.checkoutCostCenterService.getCostCenter()), filter(([costCenters]) => Boolean(costCenters)), tap(([costCenters, cartCostCenter]) => {
            if (!Boolean(cartCostCenter)) {
                this.setCostCenter(costCenters[0].code);
            }
            else {
                this.costCenterId = cartCostCenter;
            }
        }), map(([costCenters]) => costCenters));
    }
    setCostCenter(selectCostCenter) {
        this.costCenterId = selectCostCenter;
        this.checkoutCostCenterService.setCostCenter(this.costCenterId);
    }
}
CostCenterComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CostCenterComponent, deps: [{ token: i1.UserCostCenterService }, { token: i1$1.CheckoutCostCenterFacade }, { token: i1$1.PaymentTypeFacade }], target: i0.ɵɵFactoryTarget.Component });
CostCenterComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: CostCenterComponent, selector: "cx-cost-center", ngImport: i0, template: "<ng-container *ngIf=\"isAccountPayment$ | async\">\n  <div class=\"row\">\n    <div class=\"col-md-12 col-xl-10\">\n      <ng-container *ngIf=\"costCenters$ | async as costCenters\">\n        <div *ngIf=\"costCenters.length !== 0\">\n          <label>\n            <span class=\"label-content required\">{{\n              'checkoutPO.costCenter' | cxTranslate\n            }}</span>\n            <select (change)=\"setCostCenter($event.target.value)\">\n              <option\n                *ngFor=\"let costCenter of costCenters\"\n                value=\"{{ costCenter.code }}\"\n                [selected]=\"costCenterId === costCenter.code\"\n              >\n                {{ costCenter.name }}\n              </option>\n            </select>\n            <span class=\"label-content\">{{\n              'checkoutPO.availableLabel' | cxTranslate\n            }}</span>\n          </label>\n        </div>\n      </ng-container>\n    </div>\n  </div>\n</ng-container>\n", directives: [{ type: i3$2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3$2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], pipes: { "async": i3$2.AsyncPipe, "cxTranslate": i1.TranslatePipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CostCenterComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-cost-center',
                    templateUrl: 'cost-center.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: i1.UserCostCenterService }, { type: i1$1.CheckoutCostCenterFacade }, { type: i1$1.PaymentTypeFacade }]; } });

class CostCenterModule {
}
CostCenterModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CostCenterModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
CostCenterModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CostCenterModule, declarations: [CostCenterComponent], imports: [CommonModule,
        I18nModule, i1.ConfigModule] });
CostCenterModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CostCenterModule, imports: [[
            CommonModule,
            I18nModule,
            ConfigModule.withConfig({
                cmsComponents: {
                    CheckoutCostCenterComponent: {
                        component: CostCenterComponent,
                        guards: [CheckoutAuthGuard, CartNotEmptyGuard, CartValidationGuard],
                    },
                },
            }),
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CostCenterModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        I18nModule,
                        ConfigModule.withConfig({
                            cmsComponents: {
                                CheckoutCostCenterComponent: {
                                    component: CostCenterComponent,
                                    guards: [CheckoutAuthGuard, CartNotEmptyGuard, CartValidationGuard],
                                },
                            },
                        }),
                    ],
                    declarations: [CostCenterComponent],
                }]
        }] });

class DeliveryModeComponent {
    constructor(fb, checkoutDeliveryService, checkoutConfigService, activatedRoute, checkoutStepService) {
        this.fb = fb;
        this.checkoutDeliveryService = checkoutDeliveryService;
        this.checkoutConfigService = checkoutConfigService;
        this.activatedRoute = activatedRoute;
        this.checkoutStepService = checkoutStepService;
        this.continueButtonPressed = false;
        this.backBtnText = this.checkoutStepService.getBackBntText(this.activatedRoute);
        this.mode = this.fb.group({
            deliveryModeId: ['', Validators.required],
        });
    }
    ngOnInit() {
        this.supportedDeliveryModes$ = this.checkoutDeliveryService
            .getSupportedDeliveryModes()
            .pipe(filter((deliveryModes) => !!(deliveryModes === null || deliveryModes === void 0 ? void 0 : deliveryModes.length)), distinctUntilChanged((current, previous) => {
            return JSON.stringify(current) === JSON.stringify(previous);
        }));
        // Reload delivery modes on error
        this.checkoutDeliveryService
            .getLoadSupportedDeliveryModeProcess()
            .pipe(takeWhile((state) => (state === null || state === void 0 ? void 0 : state.success) === false))
            .subscribe((state) => {
            if (state.error && !state.loading) {
                this.checkoutDeliveryService.loadSupportedDeliveryModes();
            }
        });
        this.deliveryModeSub = this.supportedDeliveryModes$
            .pipe(withLatestFrom(this.checkoutDeliveryService
            .getSelectedDeliveryMode()
            .pipe(map((deliveryMode) => deliveryMode === null || deliveryMode === void 0 ? void 0 : deliveryMode.code))))
            .subscribe(([deliveryModes, code]) => {
            if (!(code &&
                !!deliveryModes.find((deliveryMode) => deliveryMode.code === code))) {
                code =
                    this.checkoutConfigService.getPreferredDeliveryMode(deliveryModes);
            }
            if (code) {
                this.mode.controls['deliveryModeId'].setValue(code);
                this.checkoutDeliveryService.setDeliveryMode(code);
            }
        });
    }
    changeMode(code) {
        this.checkoutDeliveryService.setDeliveryMode(code);
    }
    next() {
        if (this.mode.valid && this.mode.value) {
            this.continueButtonPressed = true;
            this.checkoutStepService.next(this.activatedRoute);
        }
    }
    back() {
        this.checkoutStepService.back(this.activatedRoute);
    }
    get deliveryModeInvalid() {
        return this.mode.controls['deliveryModeId'].invalid;
    }
    ngOnDestroy() {
        if (this.deliveryModeSub) {
            this.deliveryModeSub.unsubscribe();
        }
    }
}
DeliveryModeComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: DeliveryModeComponent, deps: [{ token: i3$1.FormBuilder }, { token: i1$1.CheckoutDeliveryFacade }, { token: CheckoutConfigService }, { token: i3.ActivatedRoute }, { token: CheckoutStepService }], target: i0.ɵɵFactoryTarget.Component });
DeliveryModeComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: DeliveryModeComponent, selector: "cx-delivery-mode", ngImport: i0, template: "<div [formGroup]=\"mode\">\n  <div class=\"row\">\n    <div class=\"col-md-12 col-lg-9\">\n      <h2 class=\"cx-checkout-title d-none d-lg-block d-xl-block\">\n        {{ 'checkoutShipping.shippingMethod' | cxTranslate }}\n      </h2>\n\n      <ng-container\n        *ngIf=\"(supportedDeliveryModes$ | async)?.length; else loading\"\n      >\n        <div\n          class=\"form-check\"\n          *ngFor=\"let mode of supportedDeliveryModes$ | async\"\n        >\n          <input\n            class=\"form-check-input\"\n            role=\"radio\"\n            type=\"radio\"\n            id=\"deliveryMode-{{ mode.code }}\"\n            aria-checked=\"true\"\n            (change)=\"changeMode(mode.code)\"\n            [value]=\"mode.code\"\n            formControlName=\"deliveryModeId\"\n          />\n          <label\n            class=\"cx-delivery-label form-check-label form-radio-label\"\n            for=\"deliveryMode-{{ mode.code }}\"\n          >\n            <div class=\"cx-delivery-mode\">{{ mode.name }}</div>\n            <div class=\"cx-delivery-price\">\n              {{ mode.deliveryCost.formattedValue }}\n            </div>\n            <div class=\"cx-delivery-details\">{{ mode.description }}</div>\n          </label>\n        </div>\n      </ng-container>\n    </div>\n  </div>\n\n  <ng-container *ngIf=\"!continueButtonPressed; else loading\">\n    <div class=\"row cx-checkout-btns\">\n      <div class=\"col-md-12 col-lg-6\">\n        <button class=\"btn btn-block btn-action\" (click)=\"back()\">\n          {{ backBtnText | cxTranslate }}\n        </button>\n      </div>\n      <div class=\"col-md-12 col-lg-6\">\n        <button\n          class=\"btn btn-block btn-primary\"\n          [disabled]=\"deliveryModeInvalid\"\n          (click)=\"next()\"\n        >\n          {{ 'common.continue' | cxTranslate }}\n        </button>\n      </div>\n    </div>\n  </ng-container>\n</div>\n\n<ng-template #loading>\n  <div class=\"cx-spinner\">\n    <cx-spinner></cx-spinner>\n  </div>\n</ng-template>\n", components: [{ type: i4.SpinnerComponent, selector: "cx-spinner" }], directives: [{ type: i3$1.NgControlStatusGroup, selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { type: i3$1.FormGroupDirective, selector: "[formGroup]", inputs: ["formGroup"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }, { type: i3$2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3$2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i3$1.RadioControlValueAccessor, selector: "input[type=radio][formControlName],input[type=radio][formControl],input[type=radio][ngModel]", inputs: ["name", "formControlName", "value"] }, { type: i3$1.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { type: i3$1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i3$1.FormControlName, selector: "[formControlName]", inputs: ["disabled", "formControlName", "ngModel"], outputs: ["ngModelChange"] }], pipes: { "cxTranslate": i1.TranslatePipe, "async": i3$2.AsyncPipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: DeliveryModeComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-delivery-mode',
                    templateUrl: './delivery-mode.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: i3$1.FormBuilder }, { type: i1$1.CheckoutDeliveryFacade }, { type: CheckoutConfigService }, { type: i3.ActivatedRoute }, { type: CheckoutStepService }]; } });

class DeliveryModeModule {
}
DeliveryModeModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: DeliveryModeModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
DeliveryModeModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: DeliveryModeModule, declarations: [DeliveryModeComponent], imports: [CommonModule, ReactiveFormsModule, I18nModule, SpinnerModule], exports: [DeliveryModeComponent] });
DeliveryModeModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: DeliveryModeModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                CheckoutDeliveryMode: {
                    component: DeliveryModeComponent,
                    // TODO(#8880): Shouldn't we keep ShippingAddressSetGuard here?
                    guards: [CheckoutAuthGuard, CartNotEmptyGuard],
                },
            },
        }),
    ], imports: [[CommonModule, ReactiveFormsModule, I18nModule, SpinnerModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: DeliveryModeModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, ReactiveFormsModule, I18nModule, SpinnerModule],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                CheckoutDeliveryMode: {
                                    component: DeliveryModeComponent,
                                    // TODO(#8880): Shouldn't we keep ShippingAddressSetGuard here?
                                    guards: [CheckoutAuthGuard, CartNotEmptyGuard],
                                },
                            },
                        }),
                    ],
                    declarations: [DeliveryModeComponent],
                    exports: [DeliveryModeComponent],
                }]
        }] });

class PaymentFormComponent {
    constructor(checkoutPaymentService, checkoutDeliveryService, userPaymentService, globalMessageService, fb, modalService, userAddressService) {
        this.checkoutPaymentService = checkoutPaymentService;
        this.checkoutDeliveryService = checkoutDeliveryService;
        this.userPaymentService = userPaymentService;
        this.globalMessageService = globalMessageService;
        this.fb = fb;
        this.modalService = modalService;
        this.userAddressService = userAddressService;
        this.iconTypes = ICON_TYPE;
        this.months = [];
        this.years = [];
        this.sameAsShippingAddress = true;
        this.selectedCountry$ = new BehaviorSubject('');
        this.goBack = new EventEmitter();
        this.closeForm = new EventEmitter();
        this.setPaymentDetails = new EventEmitter();
        this.paymentForm = this.fb.group({
            cardType: this.fb.group({
                code: [null, Validators.required],
            }),
            accountHolderName: ['', Validators.required],
            cardNumber: ['', Validators.required],
            expiryMonth: [null, Validators.required],
            expiryYear: [null, Validators.required],
            cvn: ['', Validators.required],
            defaultPayment: [false],
        });
        this.billingAddressForm = this.fb.group({
            firstName: ['', Validators.required],
            lastName: ['', Validators.required],
            line1: ['', Validators.required],
            line2: [''],
            town: ['', Validators.required],
            region: this.fb.group({
                isocodeShort: [null, Validators.required],
            }),
            country: this.fb.group({
                isocode: [null, Validators.required],
            }),
            postalCode: ['', Validators.required],
        });
    }
    ngOnInit() {
        this.expMonthAndYear();
        this.countries$ = this.userPaymentService.getAllBillingCountries().pipe(tap((countries) => {
            // If the store is empty fetch countries. This is also used when changing language.
            if (Object.keys(countries).length === 0) {
                this.userPaymentService.loadBillingCountries();
            }
        }));
        this.cardTypes$ = this.checkoutPaymentService.getCardTypes().pipe(tap((cardTypes) => {
            if (Object.keys(cardTypes).length === 0) {
                this.checkoutPaymentService.loadSupportedCardTypes();
            }
        }));
        this.shippingAddress$ = this.checkoutDeliveryService.getDeliveryAddress();
        this.loading$ =
            this.checkoutPaymentService.getSetPaymentDetailsResultProcess();
        this.showSameAsShippingAddressCheckbox$ = combineLatest([
            this.countries$,
            this.shippingAddress$,
        ]).pipe(map(([countries, address]) => {
            var _a;
            return ((_a = ((address === null || address === void 0 ? void 0 : address.country) &&
                !!countries.filter((country) => { var _a; return country.isocode === ((_a = address.country) === null || _a === void 0 ? void 0 : _a.isocode); }).length)) !== null && _a !== void 0 ? _a : false);
        }), tap((shouldShowCheckbox) => {
            this.sameAsShippingAddress = shouldShowCheckbox;
        }));
        this.regions$ = this.selectedCountry$.pipe(switchMap((country) => this.userAddressService.getRegions(country)), tap((regions) => {
            const regionControl = this.billingAddressForm.get('region.isocodeShort');
            if (regions.length > 0) {
                regionControl === null || regionControl === void 0 ? void 0 : regionControl.enable();
            }
            else {
                regionControl === null || regionControl === void 0 ? void 0 : regionControl.disable();
            }
        }));
    }
    expMonthAndYear() {
        const year = new Date().getFullYear();
        for (let i = 0; i < 10; i++) {
            this.years.push(year + i);
        }
        for (let j = 1; j <= 12; j++) {
            if (j < 10) {
                this.months.push(`0${j}`);
            }
            else {
                this.months.push(j.toString());
            }
        }
    }
    toggleDefaultPaymentMethod() {
        this.paymentForm.value.defaultPayment =
            !this.paymentForm.value.defaultPayment;
    }
    toggleSameAsShippingAddress() {
        this.sameAsShippingAddress = !this.sameAsShippingAddress;
    }
    getAddressCardContent(address) {
        var _a;
        let region = '';
        if (address.region && address.region.isocode) {
            region = address.region.isocode + ', ';
        }
        return {
            textBold: address.firstName + ' ' + address.lastName,
            text: [
                address.line1,
                address.line2,
                address.town + ', ' + region + ((_a = address.country) === null || _a === void 0 ? void 0 : _a.isocode),
                address.postalCode,
                address.phone,
            ],
        };
    }
    openSuggestedAddress(results) {
        if (!this.suggestedAddressModalRef) {
            this.suggestedAddressModalRef = this.modalService.open(SuggestedAddressDialogComponent, { centered: true, size: 'lg' });
            this.suggestedAddressModalRef.componentInstance.enteredAddress =
                this.billingAddressForm.value;
            this.suggestedAddressModalRef.componentInstance.suggestedAddresses =
                results.suggestedAddresses;
            this.suggestedAddressModalRef.result
                .then(() => {
                this.suggestedAddressModalRef = null;
            })
                .catch(() => {
                // this  callback is called when modal is closed with Esc key or clicking backdrop
                this.suggestedAddressModalRef = null;
            });
        }
    }
    close() {
        this.closeForm.emit();
    }
    back() {
        this.goBack.emit();
    }
    verifyAddress() {
        if (this.sameAsShippingAddress) {
            this.next();
        }
        else {
            this.userAddressService
                .verifyAddress(this.billingAddressForm.value)
                .subscribe((result) => {
                this.handleAddressVerificationResults(result);
            });
        }
    }
    handleAddressVerificationResults(results) {
        if (results.decision === 'ACCEPT') {
            this.next();
        }
        else if (results.decision === 'REJECT') {
            this.globalMessageService.add({ key: 'addressForm.invalidAddress' }, GlobalMessageType.MSG_TYPE_ERROR);
        }
        else if (results.decision === 'REVIEW') {
            this.openSuggestedAddress(results);
        }
    }
    countrySelected(country) {
        var _a;
        (_a = this.billingAddressForm.get('country.isocode')) === null || _a === void 0 ? void 0 : _a.setValue(country.isocode);
        this.selectedCountry$.next(country.isocode);
    }
    next() {
        if (this.paymentForm.valid) {
            if (this.sameAsShippingAddress) {
                this.setPaymentDetails.emit({
                    paymentDetails: this.paymentForm.value,
                    billingAddress: null,
                });
            }
            else {
                if (this.billingAddressForm.valid) {
                    this.setPaymentDetails.emit({
                        paymentDetails: this.paymentForm.value,
                        billingAddress: this.billingAddressForm.value,
                    });
                }
                else {
                    this.billingAddressForm.markAllAsTouched();
                }
            }
        }
        else {
            this.paymentForm.markAllAsTouched();
            if (!this.sameAsShippingAddress) {
                this.billingAddressForm.markAllAsTouched();
            }
        }
    }
}
PaymentFormComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PaymentFormComponent, deps: [{ token: i1$1.CheckoutPaymentFacade }, { token: i1$1.CheckoutDeliveryFacade }, { token: i1.UserPaymentService }, { token: i1.GlobalMessageService }, { token: i3$1.FormBuilder }, { token: i4.ModalService }, { token: i1.UserAddressService }], target: i0.ɵɵFactoryTarget.Component });
PaymentFormComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: PaymentFormComponent, selector: "cx-payment-form", inputs: { setAsDefaultField: "setAsDefaultField", paymentMethodsCount: "paymentMethodsCount" }, outputs: { goBack: "goBack", closeForm: "closeForm", setPaymentDetails: "setPaymentDetails" }, ngImport: i0, template: "<!-- FORM -->\n<ng-container *ngIf=\"!(loading$ | async)?.loading; else spinner\">\n  <form (ngSubmit)=\"next()\" [formGroup]=\"paymentForm\">\n    <div class=\"row\">\n      <div class=\"col-md-12 col-xl-10\">\n        <div class=\"form-group\" formGroupName=\"cardType\">\n          <ng-container *ngIf=\"cardTypes$ | async as cardTypes\">\n            <div *ngIf=\"cardTypes.length !== 0\">\n              <label>\n                <span class=\"label-content required\">{{\n                  'paymentForm.paymentType' | cxTranslate\n                }}</span>\n                <ng-select\n                  aria-required=\"true\"\n                  [searchable]=\"true\"\n                  [clearable]=\"false\"\n                  [items]=\"cardTypes\"\n                  bindLabel=\"name\"\n                  bindValue=\"code\"\n                  placeholder=\"{{ 'paymentForm.selectOne' | cxTranslate }}\"\n                  formControlName=\"code\"\n                >\n                </ng-select>\n                <cx-form-errors\n                  aria-live=\"assertive\"\n                  aria-atomic=\"true\"\n                  [control]=\"paymentForm.get('cardType.code')\"\n                ></cx-form-errors>\n              </label>\n            </div>\n          </ng-container>\n        </div>\n\n        <div class=\"form-group\">\n          <label>\n            <span class=\"label-content\">{{\n              'paymentForm.accountHolderName.label' | cxTranslate\n            }}</span>\n            <input\n              aria-required=\"true\"\n              class=\"form-control\"\n              type=\"text\"\n              placeholder=\"{{\n                'paymentForm.accountHolderName.placeholder' | cxTranslate\n              }}\"\n              formControlName=\"accountHolderName\"\n            />\n            <cx-form-errors\n              aria-live=\"assertive\"\n              aria-atomic=\"true\"\n              [control]=\"paymentForm.get('accountHolderName')\"\n            ></cx-form-errors>\n          </label>\n        </div>\n\n        <div class=\"form-group\">\n          <label>\n            <span class=\"label-content\">{{\n              'paymentForm.cardNumber' | cxTranslate\n            }}</span>\n            <input\n              aria-required=\"true\"\n              type=\"text\"\n              class=\"form-control\"\n              formControlName=\"cardNumber\"\n            />\n            <cx-form-errors\n              aria-live=\"assertive\"\n              aria-atomic=\"true\"\n              [control]=\"paymentForm.get('cardNumber')\"\n            ></cx-form-errors>\n          </label>\n        </div>\n\n        <div class=\"row\">\n          <div class=\"form-group col-md-8\">\n            <fieldset class=\"cx-payment-form-exp-date\">\n              <legend class=\"label-content\">\n                {{ 'paymentForm.expirationDate' | cxTranslate }}\n              </legend>\n              <label class=\"cx-payment-form-exp-date-wrapper\">\n                <ng-select\n                  aria-required=\"true\"\n                  [searchable]=\"true\"\n                  [clearable]=\"false\"\n                  [items]=\"months\"\n                  placeholder=\"{{ 'paymentForm.monthMask' | cxTranslate }}\"\n                  formControlName=\"expiryMonth\"\n                  [attr.aria-label]=\"\n                    'paymentForm.expirationMonth'\n                      | cxTranslate\n                        : { selected: paymentForm.get('expiryMonth')?.value }\n                  \"\n                >\n                </ng-select>\n                <cx-form-errors\n                  aria-live=\"assertive\"\n                  aria-atomic=\"true\"\n                  [control]=\"paymentForm.get('expiryMonth')\"\n                ></cx-form-errors>\n              </label>\n              <label class=\"cx-payment-form-exp-date-wrapper\">\n                <ng-select\n                  aria-required=\"true\"\n                  [searchable]=\"true\"\n                  [clearable]=\"false\"\n                  [items]=\"years\"\n                  placeholder=\"{{ 'paymentForm.yearMask' | cxTranslate }}\"\n                  [attr.aria-label]=\"\n                    'paymentForm.expirationYear'\n                      | cxTranslate\n                        : { selected: paymentForm.get('expiryYear')?.value }\n                  \"\n                  formControlName=\"expiryYear\"\n                >\n                </ng-select>\n                <cx-form-errors\n                  aria-live=\"assertive\"\n                  aria-atomic=\"true\"\n                  [control]=\"paymentForm.get('expiryYear')\"\n                ></cx-form-errors>\n              </label>\n            </fieldset>\n          </div>\n\n          <div class=\"form-group col-md-4\">\n            <label>\n              <span class=\"label-content\">\n                {{ 'paymentForm.securityCode' | cxTranslate }}\n                <cx-icon\n                  [type]=\"iconTypes.INFO\"\n                  class=\"cx-payment-form-tooltip\"\n                  placement=\"right\"\n                  title=\"{{ 'paymentForm.securityCodeTitle' | cxTranslate }}\"\n                  alt=\"\"\n                ></cx-icon>\n              </span>\n              <input\n                aria-required=\"true\"\n                type=\"text\"\n                class=\"form-control\"\n                id=\"cVVNumber\"\n                formControlName=\"cvn\"\n              />\n              <cx-form-errors\n                aria-live=\"assertive\"\n                aria-atomic=\"true\"\n                [control]=\"paymentForm.get('cvn')\"\n              ></cx-form-errors>\n            </label>\n          </div>\n        </div>\n\n        <div class=\"form-group\" *ngIf=\"setAsDefaultField\">\n          <div class=\"form-check\">\n            <label>\n              <input\n                type=\"checkbox\"\n                class=\"form-check-input\"\n                (change)=\"toggleDefaultPaymentMethod()\"\n              />\n              <span class=\"form-check-label\">{{\n                'paymentForm.setAsDefault' | cxTranslate\n              }}</span>\n            </label>\n          </div>\n        </div>\n\n        <!-- BILLING -->\n        <div class=\"cx-payment-form-billing\">\n          <div class=\"cx-payment-form-billing-address\">\n            {{ 'paymentForm.billingAddress' | cxTranslate }}\n          </div>\n\n          <!-- SAME AS SHIPPING CHECKBOX -->\n          <ng-container *ngIf=\"showSameAsShippingAddressCheckbox$ | async\">\n            <div class=\"form-group\">\n              <div class=\"form-check\">\n                <label>\n                  <input\n                    type=\"checkbox\"\n                    class=\"form-check-input\"\n                    [checked]=\"sameAsShippingAddress\"\n                    (change)=\"toggleSameAsShippingAddress()\"\n                  />\n                  <span class=\"form-check-label\">{{\n                    'paymentForm.sameAsShippingAddress' | cxTranslate\n                  }}</span>\n                </label>\n              </div>\n            </div>\n          </ng-container>\n\n          <!-- BILLING INFO COMPONENT -->\n          <ng-container\n            *ngIf=\"\n              sameAsShippingAddress &&\n                (shippingAddress$ | async) as shippingAddress;\n              else billingAddress\n            \"\n          >\n            <cx-card\n              [content]=\"getAddressCardContent(shippingAddress)\"\n            ></cx-card>\n          </ng-container>\n\n          <ng-template #billingAddress>\n            <div [formGroup]=\"billingAddressForm\">\n              <div class=\"form-group\" formGroupName=\"country\">\n                <ng-container *ngIf=\"countries$ | async as countries\">\n                  <div *ngIf=\"countries.length !== 0\">\n                    <label aria-required=\"true\">\n                      <span class=\"label-content required\">{{\n                        'addressForm.country' | cxTranslate\n                      }}</span>\n                      <ng-select\n                        aria-required=\"true\"\n                        [searchable]=\"true\"\n                        [clearable]=\"false\"\n                        [items]=\"countries\"\n                        bindLabel=\"name\"\n                        bindValue=\"isocode\"\n                        placeholder=\"{{\n                          'addressForm.selectOne' | cxTranslate\n                        }}\"\n                        (change)=\"countrySelected($event)\"\n                        formControlName=\"isocode\"\n                      >\n                      </ng-select>\n                      <cx-form-errors\n                        aria-live=\"assertive\"\n                        aria-atomic=\"true\"\n                        [control]=\"billingAddressForm.get('country.isocode')\"\n                      ></cx-form-errors>\n                    </label>\n                  </div>\n                </ng-container>\n              </div>\n              <div class=\"form-group\">\n                <label>\n                  <span class=\"label-content required\">{{\n                    'addressForm.firstName.label' | cxTranslate\n                  }}</span>\n                  <input\n                    aria-required=\"true\"\n                    class=\"form-control\"\n                    type=\"text\"\n                    placeholder=\"{{\n                      'addressForm.firstName.placeholder' | cxTranslate\n                    }}\"\n                    formControlName=\"firstName\"\n                  />\n                  <cx-form-errors\n                    aria-live=\"assertive\"\n                    aria-atomic=\"true\"\n                    [control]=\"billingAddressForm.get('firstName')\"\n                  ></cx-form-errors>\n                </label>\n              </div>\n              <div class=\"form-group\">\n                <label>\n                  <span class=\"label-content required\">{{\n                    'addressForm.lastName.label' | cxTranslate\n                  }}</span>\n                  <input\n                    aria-required=\"true\"\n                    type=\"text\"\n                    class=\"form-control\"\n                    placeholder=\"{{\n                      'addressForm.lastName.placeholder' | cxTranslate\n                    }}\"\n                    formControlName=\"lastName\"\n                  />\n                  <cx-form-errors\n                    aria-live=\"assertive\"\n                    aria-atomic=\"true\"\n                    [control]=\"billingAddressForm.get('lastName')\"\n                  ></cx-form-errors>\n                </label>\n              </div>\n              <div class=\"form-group\">\n                <label>\n                  <span class=\"label-content required\">{{\n                    'addressForm.address1' | cxTranslate\n                  }}</span>\n                  <input\n                    aria-required=\"true\"\n                    type=\"text\"\n                    class=\"form-control\"\n                    placeholder=\"{{\n                      'addressForm.streetAddress' | cxTranslate\n                    }}\"\n                    formControlName=\"line1\"\n                  />\n                  <cx-form-errors\n                    aria-live=\"assertive\"\n                    aria-atomic=\"true\"\n                    [control]=\"billingAddressForm.get('line1')\"\n                  ></cx-form-errors>\n                </label>\n              </div>\n              <div class=\"form-group\">\n                <label>\n                  <span class=\"label-content\">{{\n                    'addressForm.address2' | cxTranslate\n                  }}</span>\n                  <input\n                    type=\"text\"\n                    class=\"form-control\"\n                    placeholder=\"{{ 'addressForm.aptSuite' | cxTranslate }}\"\n                    formControlName=\"line2\"\n                  />\n                </label>\n              </div>\n              <div class=\"row\">\n                <div class=\"form-group col-md-6\">\n                  <label>\n                    <span class=\"label-content required\">{{\n                      'addressForm.city.label' | cxTranslate\n                    }}</span>\n                    <input\n                      aria-required=\"true\"\n                      type=\"text\"\n                      class=\"form-control\"\n                      placeholder=\"{{\n                        'addressForm.city.placeholder' | cxTranslate\n                      }}\"\n                      formControlName=\"town\"\n                    />\n                    <cx-form-errors\n                      aria-live=\"assertive\"\n                      aria-atomic=\"true\"\n                      [control]=\"billingAddressForm.get('town')\"\n                    ></cx-form-errors>\n                  </label>\n                </div>\n                <div class=\"form-group col-md-6\">\n                  <label>\n                    <span class=\"label-content required\">{{\n                      'addressForm.zipCode.label' | cxTranslate\n                    }}</span>\n                    <input\n                      aria-required=\"true\"\n                      type=\"text\"\n                      class=\"form-control\"\n                      placeholder=\"{{\n                        'addressForm.zipCode.placeholder' | cxTranslate\n                      }}\"\n                      formControlName=\"postalCode\"\n                    />\n                    <cx-form-errors\n                      aria-live=\"assertive\"\n                      aria-atomic=\"true\"\n                      [control]=\"billingAddressForm.get('postalCode')\"\n                    ></cx-form-errors>\n                  </label>\n                </div>\n                <ng-container\n                  *ngIf=\"regions$ | async as regions\"\n                  formGroupName=\"region\"\n                >\n                  <ng-container *ngIf=\"regions.length !== 0\">\n                    <div class=\"form-group col-md-6\">\n                      <label aria-required=\"true\">\n                        <span class=\"label-content required\">{{\n                          'addressForm.state' | cxTranslate\n                        }}</span>\n                        <ng-select\n                          aria-required=\"true\"\n                          class=\"region-select\"\n                          formControlName=\"isocodeShort\"\n                          [searchable]=\"true\"\n                          [clearable]=\"false\"\n                          [items]=\"regions\"\n                          bindLabel=\"{{\n                            regions[0].name ? 'name' : 'isocodeShort'\n                          }}\"\n                          bindValue=\"{{\n                            regions[0].name ? 'isocodeShort' : 'region'\n                          }}\"\n                          placeholder=\"{{\n                            'addressForm.selectOne' | cxTranslate\n                          }}\"\n                        >\n                        </ng-select>\n                        <cx-form-errors\n                          aria-live=\"assertive\"\n                          aria-atomic=\"true\"\n                          [control]=\"\n                            billingAddressForm.get('region.isocodeShort')\n                          \"\n                        ></cx-form-errors>\n                      </label>\n                    </div>\n                  </ng-container>\n                </ng-container>\n              </div>\n            </div>\n          </ng-template>\n        </div>\n      </div>\n    </div>\n\n    <!-- BUTTON SECTION -->\n    <div class=\"cx-checkout-btns row\">\n      <div class=\"col-md-12 col-lg-6\">\n        <button\n          *ngIf=\"paymentMethodsCount === 0\"\n          class=\"btn btn-block btn-action\"\n          (click)=\"back()\"\n        >\n          {{ 'common.back' | cxTranslate }}\n        </button>\n        <button\n          *ngIf=\"paymentMethodsCount > 0\"\n          class=\"btn btn-block btn-action\"\n          (click)=\"close()\"\n        >\n          {{ 'paymentForm.changePayment' | cxTranslate }}\n        </button>\n      </div>\n      <div class=\"col-md-12 col-lg-6\">\n        <button class=\"btn btn-block btn-primary\" type=\"submit\">\n          {{ 'common.continue' | cxTranslate }}\n        </button>\n      </div>\n    </div>\n  </form>\n</ng-container>\n\n<ng-template #spinner>\n  <cx-spinner></cx-spinner>\n</ng-template>\n", components: [{ type: i5.NgSelectComponent, selector: "ng-select", inputs: ["markFirst", "dropdownPosition", "loading", "closeOnSelect", "hideSelected", "selectOnTab", "bufferAmount", "selectableGroup", "selectableGroupAsModel", "searchFn", "trackByFn", "clearOnBackspace", "labelForId", "inputAttrs", "readonly", "searchWhileComposing", "minTermLength", "editableSearchTerm", "keyDownFn", "multiple", "addTag", "searchable", "clearable", "isOpen", "items", "compareWith", "clearSearchOnAdd", "bindLabel", "placeholder", "notFoundText", "typeToSearchText", "addTagText", "loadingText", "clearAllText", "virtualScroll", "openOnEnter", "appendTo", "bindValue", "appearance", "maxSelectedItems", "groupBy", "groupValue", "tabIndex", "typeahead"], outputs: ["blur", "focus", "change", "open", "close", "search", "clear", "add", "remove", "scroll", "scrollToEnd"] }, { type: i4.FormErrorsComponent, selector: "cx-form-errors", inputs: ["prefix", "translationParams", "control"] }, { type: i4.IconComponent, selector: "cx-icon,[cxIcon]", inputs: ["cxIcon", "type"] }, { type: i4.CardComponent, selector: "cx-card", inputs: ["border", "editMode", "isDefault", "content", "fitToContainer", "truncateText", "charactersLimit"], outputs: ["deleteCard", "setDefaultCard", "sendCard", "editCard", "cancelCard"] }, { type: i4.SpinnerComponent, selector: "cx-spinner" }], directives: [{ type: i3$2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3$1.ɵNgNoValidate, selector: "form:not([ngNoForm]):not([ngNativeValidate])" }, { type: i3$1.NgControlStatusGroup, selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { type: i3$1.FormGroupDirective, selector: "[formGroup]", inputs: ["formGroup"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }, { type: i3$1.FormGroupName, selector: "[formGroupName]", inputs: ["formGroupName"] }, { type: i3$1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i3$1.FormControlName, selector: "[formControlName]", inputs: ["disabled", "formControlName", "ngModel"], outputs: ["ngModelChange"] }, { type: i3$1.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }], pipes: { "async": i3$2.AsyncPipe, "cxTranslate": i1.TranslatePipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PaymentFormComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-payment-form',
                    templateUrl: './payment-form.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: i1$1.CheckoutPaymentFacade }, { type: i1$1.CheckoutDeliveryFacade }, { type: i1.UserPaymentService }, { type: i1.GlobalMessageService }, { type: i3$1.FormBuilder }, { type: i4.ModalService }, { type: i1.UserAddressService }]; }, propDecorators: { setAsDefaultField: [{
                type: Input
            }], paymentMethodsCount: [{
                type: Input
            }], goBack: [{
                type: Output
            }], closeForm: [{
                type: Output
            }], setPaymentDetails: [{
                type: Output
            }] } });

class PaymentFormModule {
}
PaymentFormModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PaymentFormModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
PaymentFormModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PaymentFormModule, declarations: [PaymentFormComponent], imports: [CommonModule,
        ReactiveFormsModule,
        NgSelectModule,
        CardModule,
        I18nModule,
        IconModule,
        SpinnerModule,
        FormErrorsModule], exports: [PaymentFormComponent] });
PaymentFormModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PaymentFormModule, imports: [[
            CommonModule,
            ReactiveFormsModule,
            NgSelectModule,
            CardModule,
            I18nModule,
            IconModule,
            SpinnerModule,
            FormErrorsModule,
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PaymentFormModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        ReactiveFormsModule,
                        NgSelectModule,
                        CardModule,
                        I18nModule,
                        IconModule,
                        SpinnerModule,
                        FormErrorsModule,
                    ],
                    declarations: [PaymentFormComponent],
                    exports: [PaymentFormComponent],
                }]
        }] });

class PaymentMethodComponent {
    constructor(userPaymentService, checkoutService, checkoutDeliveryService, checkoutPaymentService, globalMessageService, activatedRoute, translation, activeCartService, checkoutStepService) {
        this.userPaymentService = userPaymentService;
        this.checkoutService = checkoutService;
        this.checkoutDeliveryService = checkoutDeliveryService;
        this.checkoutPaymentService = checkoutPaymentService;
        this.globalMessageService = globalMessageService;
        this.activatedRoute = activatedRoute;
        this.translation = translation;
        this.activeCartService = activeCartService;
        this.checkoutStepService = checkoutStepService;
        this.iconTypes = ICON_TYPE;
        this.isGuestCheckout = false;
        this.newPaymentFormManuallyOpened = false;
        this.backBtnText = this.checkoutStepService.getBackBntText(this.activatedRoute);
    }
    ngOnInit() {
        this.shouldRedirect = false;
        this.isLoading$ = this.userPaymentService.getPaymentMethodsLoading();
        if (!this.activeCartService.isGuestCart()) {
            this.userPaymentService.loadPaymentMethods();
        }
        else {
            this.isGuestCheckout = true;
        }
        this.checkoutDeliveryService
            .getDeliveryAddress()
            .pipe(take(1))
            .subscribe((address) => {
            this.deliveryAddress = address;
        });
        this.existingPaymentMethods$ = this.userPaymentService.getPaymentMethods();
        this.selectedMethod$ = this.checkoutPaymentService.getPaymentDetails().pipe(tap((paymentInfo) => {
            if (paymentInfo && !!Object.keys(paymentInfo).length) {
                if (paymentInfo['hasError']) {
                    Object.keys(paymentInfo).forEach((key) => {
                        if (key.startsWith('InvalidField')) {
                            this.sendPaymentMethodFailGlobalMessage(paymentInfo[key]);
                        }
                    });
                    this.checkoutService.clearCheckoutStep(3);
                }
                else if (this.shouldRedirect) {
                    this.next();
                }
            }
        }));
        this.cards$ = combineLatest([
            this.existingPaymentMethods$.pipe(switchMap((methods) => {
                return !(methods === null || methods === void 0 ? void 0 : methods.length)
                    ? of([])
                    : combineLatest(methods.map((method) => combineLatest([
                        of(method),
                        this.translation.translate('paymentCard.expires', {
                            month: method.expiryMonth,
                            year: method.expiryYear,
                        }),
                    ]).pipe(map(([payment, translation]) => ({
                        payment,
                        expiryTranslation: translation,
                    })))));
            })),
            this.selectedMethod$,
            this.translation.translate('paymentForm.useThisPayment'),
            this.translation.translate('paymentCard.defaultPaymentMethod'),
            this.translation.translate('paymentCard.selected'),
        ]).pipe(map(([paymentMethods, selectedMethod, textUseThisPayment, textDefaultPaymentMethod, textSelected,]) => {
            if (paymentMethods.length &&
                (!selectedMethod || Object.keys(selectedMethod).length === 0)) {
                const defaultPaymentMethod = paymentMethods.find((paymentMethod) => paymentMethod.payment.defaultPayment);
                if (defaultPaymentMethod) {
                    selectedMethod = defaultPaymentMethod.payment;
                    this.checkoutPaymentService.setPaymentDetails(selectedMethod);
                }
            }
            return paymentMethods.map((payment) => ({
                content: this.createCard(payment.payment, {
                    textExpires: payment.expiryTranslation,
                    textUseThisPayment,
                    textDefaultPaymentMethod,
                    textSelected,
                }, selectedMethod),
                paymentMethod: payment.payment,
            }));
        }));
    }
    selectPaymentMethod(paymentDetails) {
        this.checkoutPaymentService.setPaymentDetails(paymentDetails);
    }
    showNewPaymentForm() {
        this.newPaymentFormManuallyOpened = true;
    }
    hideNewPaymentForm() {
        this.newPaymentFormManuallyOpened = false;
    }
    setPaymentDetails({ paymentDetails, billingAddress, }) {
        const details = Object.assign({}, paymentDetails);
        details.billingAddress = billingAddress || this.deliveryAddress;
        this.checkoutPaymentService.createPaymentDetails(details);
        this.shouldRedirect = true;
    }
    ngOnDestroy() {
        this.checkoutPaymentService.paymentProcessSuccess();
    }
    getCardIcon(code) {
        let ccIcon;
        if (code === 'visa') {
            ccIcon = this.iconTypes.VISA;
        }
        else if (code === 'master' || code === 'mastercard_eurocard') {
            ccIcon = this.iconTypes.MASTER_CARD;
        }
        else if (code === 'diners') {
            ccIcon = this.iconTypes.DINERS_CLUB;
        }
        else if (code === 'amex') {
            ccIcon = this.iconTypes.AMEX;
        }
        else {
            ccIcon = this.iconTypes.CREDIT_CARD;
        }
        return ccIcon;
    }
    sendPaymentMethodFailGlobalMessage(field) {
        this.globalMessageService.add({
            key: 'paymentMethods.invalidField',
            params: { field },
        }, GlobalMessageType.MSG_TYPE_ERROR);
    }
    createCard(paymentDetails, cardLabels, selected) {
        var _a, _b;
        return {
            title: paymentDetails.defaultPayment
                ? cardLabels.textDefaultPaymentMethod
                : '',
            textBold: paymentDetails.accountHolderName,
            text: [(_a = paymentDetails.cardNumber) !== null && _a !== void 0 ? _a : '', cardLabels.textExpires],
            img: this.getCardIcon((_b = paymentDetails.cardType) === null || _b === void 0 ? void 0 : _b.code),
            actions: [{ name: cardLabels.textUseThisPayment, event: 'send' }],
            header: (selected === null || selected === void 0 ? void 0 : selected.id) === paymentDetails.id
                ? cardLabels.textSelected
                : undefined,
        };
    }
    next() {
        this.checkoutStepService.next(this.activatedRoute);
    }
    back() {
        this.checkoutStepService.back(this.activatedRoute);
    }
}
PaymentMethodComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PaymentMethodComponent, deps: [{ token: i1.UserPaymentService }, { token: i1$1.CheckoutFacade }, { token: i1$1.CheckoutDeliveryFacade }, { token: i1$1.CheckoutPaymentFacade }, { token: i1.GlobalMessageService }, { token: i3.ActivatedRoute }, { token: i1.TranslationService }, { token: i1.ActiveCartService }, { token: CheckoutStepService }], target: i0.ɵɵFactoryTarget.Component });
PaymentMethodComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: PaymentMethodComponent, selector: "cx-payment-method", ngImport: i0, template: "<ng-container *ngIf=\"cards$ | async as cards\">\n  <h2 class=\"cx-checkout-title d-none d-lg-block d-xl-block\">\n    {{ 'paymentForm.payment' | cxTranslate }}\n  </h2>\n  <ng-container *ngIf=\"!(isLoading$ | async); else loading\">\n    <ng-container\n      *ngIf=\"\n        cards?.length && !newPaymentFormManuallyOpened;\n        else newPaymentForm\n      \"\n    >\n      <p class=\"cx-checkout-text\">\n        {{ 'paymentForm.choosePaymentMethod' | cxTranslate }}\n      </p>\n      <div class=\"cx-checkout-btns row\">\n        <div class=\"col-md-12 col-lg-6\">\n          <button\n            class=\"btn btn-block btn-action\"\n            (click)=\"showNewPaymentForm()\"\n          >\n            {{ 'paymentForm.addNewPayment' | cxTranslate }}\n          </button>\n        </div>\n      </div>\n\n      <div class=\"cx-checkout-body row\">\n        <div\n          class=\"cx-payment-card col-md-12 col-lg-6\"\n          *ngFor=\"let card of cards; let i = index\"\n        >\n          <div class=\"cx-payment-card-inner\">\n            <cx-card\n              [border]=\"true\"\n              [fitToContainer]=\"true\"\n              [content]=\"card.content\"\n              (sendCard)=\"selectPaymentMethod(card.paymentMethod)\"\n            ></cx-card>\n          </div>\n        </div>\n      </div>\n\n      <div class=\"row cx-checkout-btns\">\n        <div class=\"col-md-12 col-lg-6\">\n          <button class=\"btn btn-block btn-action\" (click)=\"back()\">\n            {{ backBtnText | cxTranslate }}\n          </button>\n        </div>\n        <div class=\"col-md-12 col-lg-6\">\n          <button\n            class=\"btn btn-block btn-primary\"\n            [disabled]=\"!(selectedMethod$ | async)?.id\"\n            (click)=\"next()\"\n          >\n            {{ 'common.continue' | cxTranslate }}\n          </button>\n        </div>\n      </div>\n    </ng-container>\n\n    <ng-template #newPaymentForm>\n      <cx-payment-form\n        (setPaymentDetails)=\"setPaymentDetails($event)\"\n        (closeForm)=\"hideNewPaymentForm()\"\n        (goBack)=\"back()\"\n        [paymentMethodsCount]=\"cards?.length || 0\"\n        [setAsDefaultField]=\"!isGuestCheckout\"\n      ></cx-payment-form>\n    </ng-template>\n  </ng-container>\n\n  <ng-template #loading>\n    <div class=\"cx-spinner\"><cx-spinner></cx-spinner></div>\n  </ng-template>\n</ng-container>\n", components: [{ type: i4.CardComponent, selector: "cx-card", inputs: ["border", "editMode", "isDefault", "content", "fitToContainer", "truncateText", "charactersLimit"], outputs: ["deleteCard", "setDefaultCard", "sendCard", "editCard", "cancelCard"] }, { type: PaymentFormComponent, selector: "cx-payment-form", inputs: ["setAsDefaultField", "paymentMethodsCount"], outputs: ["goBack", "closeForm", "setPaymentDetails"] }, { type: i4.SpinnerComponent, selector: "cx-spinner" }], directives: [{ type: i3$2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3$2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], pipes: { "async": i3$2.AsyncPipe, "cxTranslate": i1.TranslatePipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PaymentMethodComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-payment-method',
                    templateUrl: './payment-method.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: i1.UserPaymentService }, { type: i1$1.CheckoutFacade }, { type: i1$1.CheckoutDeliveryFacade }, { type: i1$1.CheckoutPaymentFacade }, { type: i1.GlobalMessageService }, { type: i3.ActivatedRoute }, { type: i1.TranslationService }, { type: i1.ActiveCartService }, { type: CheckoutStepService }]; } });

class PaymentMethodModule {
}
PaymentMethodModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PaymentMethodModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
PaymentMethodModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PaymentMethodModule, declarations: [PaymentMethodComponent], imports: [CommonModule,
        RouterModule,
        PaymentFormModule,
        CardModule,
        SpinnerModule,
        I18nModule], exports: [PaymentMethodComponent] });
PaymentMethodModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PaymentMethodModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                CheckoutPaymentDetails: {
                    component: PaymentMethodComponent,
                    // TODO(#8880): Shouldn't we keep ShippingAddressSetGuard and others here?
                    guards: [CheckoutAuthGuard, CartNotEmptyGuard],
                },
            },
        }),
    ], imports: [[
            CommonModule,
            RouterModule,
            PaymentFormModule,
            CardModule,
            SpinnerModule,
            I18nModule,
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PaymentMethodModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        RouterModule,
                        PaymentFormModule,
                        CardModule,
                        SpinnerModule,
                        I18nModule,
                    ],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                CheckoutPaymentDetails: {
                                    component: PaymentMethodComponent,
                                    // TODO(#8880): Shouldn't we keep ShippingAddressSetGuard and others here?
                                    guards: [CheckoutAuthGuard, CartNotEmptyGuard],
                                },
                            },
                        }),
                    ],
                    declarations: [PaymentMethodComponent],
                    exports: [PaymentMethodComponent],
                }]
        }] });

class PaymentTypeComponent {
    constructor(paymentTypeService, checkoutStepService, activatedRoute) {
        this.paymentTypeService = paymentTypeService;
        this.checkoutStepService = checkoutStepService;
        this.activatedRoute = activatedRoute;
        this.paymentTypes$ = this.paymentTypeService.getPaymentTypes();
        this.typeSelected$ = this.paymentTypeService
            .getSelectedPaymentType()
            .pipe(filter(isNotUndefined), distinctUntilChanged(), tap((selected) => {
            this.typeSelected = selected;
            this.checkoutStepService.resetSteps();
            this.checkoutStepService.disableEnableStep(CheckoutStepType.PAYMENT_DETAILS, selected === B2BPaymentTypeEnum.ACCOUNT_PAYMENT);
        }));
        this.cartPoNumber$ = this.paymentTypeService
            .getPoNumber()
            .pipe(filter(isNotUndefined), tap((po) => {
            return (this.cartPoNumber = po);
        }));
    }
    changeType(code) {
        this.paymentTypeService.setPaymentType(code);
        this.typeSelected = code;
    }
    next() {
        // set po number to cart
        const poNumInput = this._poNumberInput.nativeElement.value;
        if (this.typeSelected && poNumInput !== this.cartPoNumber) {
            this.paymentTypeService.setPaymentType(this.typeSelected, poNumInput);
        }
        this.checkoutStepService.next(this.activatedRoute);
    }
    back() {
        this.checkoutStepService.back(this.activatedRoute);
    }
}
PaymentTypeComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PaymentTypeComponent, deps: [{ token: i1$1.PaymentTypeFacade }, { token: CheckoutStepService }, { token: i3.ActivatedRoute }], target: i0.ɵɵFactoryTarget.Component });
PaymentTypeComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: PaymentTypeComponent, selector: "cx-payment-type", viewQueries: [{ propertyName: "_poNumberInput", first: true, predicate: ["poNumber"], descendants: true }], ngImport: i0, template: "<div class=\"row\">\n  <div class=\"col-md-12 col-lg-6\">\n    <label>\n      <span class=\"label-content\">{{\n        'checkoutPO.poNumber' | cxTranslate\n      }}</span>\n      <input\n        #poNumber\n        class=\"form-control\"\n        formControlName=\"poNumber\"\n        type=\"text\"\n        placeholder=\"{{ 'checkoutPO.placeholder' | cxTranslate }}\"\n        value=\"{{ cartPoNumber$ | async }}\"\n      />\n    </label>\n  </div>\n</div>\n<div class=\"row\">\n  <div class=\"col-md-12 col-lg-6\">\n    <ng-container\n      *ngIf=\"\n        (paymentTypes$ | async)?.length && typeSelected$ | async;\n        else loading\n      \"\n    >\n      <label class=\"cx-payment-type-container\">\n        <span class=\"label-content\">{{\n          'paymentTypes.title' | cxTranslate\n        }}</span>\n        <div class=\"form-check\" *ngFor=\"let type of paymentTypes$ | async\">\n          <input\n            id=\"paymentType-{{ type.code }}\"\n            class=\"form-check-input\"\n            role=\"radio\"\n            type=\"radio\"\n            aria-checked=\"true\"\n            (change)=\"changeType(type.code)\"\n            [value]=\"type.code\"\n            [checked]=\"type.code == typeSelected\"\n            formControlName=\"paymentType\"\n          />\n          <label\n            class=\"cx-payment-type-label form-check-label form-radio-label\"\n            for=\"paymentType-{{ type.code }}\"\n          >\n            <div class=\"cx-payment-type\">\n              {{ 'paymentTypes.paymentType_' + type?.code | cxTranslate }}\n            </div>\n          </label>\n        </div>\n      </label>\n    </ng-container>\n  </div>\n</div>\n\n<div class=\"cx-checkout-btns row\">\n  <div class=\"col-md-12 col-lg-6\">\n    <button class=\"btn btn-block btn-action\" (click)=\"back()\">\n      {{ 'checkout.backToCart' | cxTranslate }}\n    </button>\n  </div>\n  <div class=\"col-md-12 col-lg-6\">\n    <button class=\"btn btn-block btn-primary\" (click)=\"next()\">\n      {{ 'common.continue' | cxTranslate }}\n    </button>\n  </div>\n</div>\n\n<ng-template #loading>\n  <div class=\"cx-spinner\">\n    <cx-spinner></cx-spinner>\n  </div>\n</ng-template>\n", components: [{ type: i4.SpinnerComponent, selector: "cx-spinner" }], directives: [{ type: i3$2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3$2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], pipes: { "cxTranslate": i1.TranslatePipe, "async": i3$2.AsyncPipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PaymentTypeComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-payment-type',
                    templateUrl: './payment-type.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: i1$1.PaymentTypeFacade }, { type: CheckoutStepService }, { type: i3.ActivatedRoute }]; }, propDecorators: { _poNumberInput: [{
                type: ViewChild,
                args: ['poNumber', { static: false }]
            }] } });

class PaymentTypeModule {
}
PaymentTypeModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PaymentTypeModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
PaymentTypeModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PaymentTypeModule, declarations: [PaymentTypeComponent], imports: [CommonModule,
        I18nModule,
        SpinnerModule, i1.ConfigModule], exports: [PaymentTypeComponent] });
PaymentTypeModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PaymentTypeModule, imports: [[
            CommonModule,
            I18nModule,
            SpinnerModule,
            ConfigModule.withConfig({
                cmsComponents: {
                    CheckoutPaymentType: {
                        component: PaymentTypeComponent,
                        guards: [CheckoutAuthGuard, CartNotEmptyGuard, CartValidationGuard],
                    },
                },
            }),
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PaymentTypeModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        I18nModule,
                        SpinnerModule,
                        ConfigModule.withConfig({
                            cmsComponents: {
                                CheckoutPaymentType: {
                                    component: PaymentTypeComponent,
                                    guards: [CheckoutAuthGuard, CartNotEmptyGuard, CartValidationGuard],
                                },
                            },
                        }),
                    ],
                    declarations: [PaymentTypeComponent],
                    exports: [PaymentTypeComponent],
                }]
        }] });

const defaultPlaceOrderSpinnerLayoutConfig = {
    launch: {
        PLACE_ORDER_SPINNER: {
            inline: true,
            component: SpinnerComponent,
            dialogType: DIALOG_TYPE.POPOVER_CENTER_BACKDROP,
        },
    },
};

class CheckoutReplenishmentFormService {
    constructor() {
        /**
         * Default form data
         */
        this.defaultFormData = {
            daysOfWeek: [DaysOfWeek.MONDAY],
            nthDayOfMonth: '1',
            numberOfDays: '14',
            numberOfWeeks: '1',
            recurrencePeriod: recurrencePeriod.DAILY,
            replenishmentStartDate: new Date().toISOString().split('T')[0],
        };
        this.scheduleReplenishmentFormData$ = new BehaviorSubject(this.defaultFormData);
    }
    getScheduleReplenishmentFormData() {
        return this.scheduleReplenishmentFormData$.asObservable();
    }
    setScheduleReplenishmentFormData(formData) {
        this.scheduleReplenishmentFormData$.next(formData);
    }
    resetScheduleReplenishmentFormData() {
        this.scheduleReplenishmentFormData$.next(this.defaultFormData);
    }
}
CheckoutReplenishmentFormService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutReplenishmentFormService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
CheckoutReplenishmentFormService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutReplenishmentFormService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutReplenishmentFormService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return []; } });

class PlaceOrderComponent {
    constructor(checkoutService, routingService, fb, checkoutReplenishmentFormService, launchDialogService, vcr) {
        this.checkoutService = checkoutService;
        this.routingService = routingService;
        this.fb = fb;
        this.checkoutReplenishmentFormService = checkoutReplenishmentFormService;
        this.launchDialogService = launchDialogService;
        this.vcr = vcr;
        this.subscription = new Subscription();
        this.daysOfWeekNotChecked$ = new BehaviorSubject(false);
        this.checkoutSubmitForm = this.fb.group({
            termsAndConditions: [false, Validators.requiredTrue],
        });
    }
    get termsAndConditionInvalid() {
        return this.checkoutSubmitForm.invalid;
    }
    submitForm() {
        if (this.checkoutSubmitForm.valid && Boolean(this.currentOrderType)) {
            switch (this.currentOrderType) {
                case ORDER_TYPE.PLACE_ORDER: {
                    this.checkoutService.placeOrder(this.checkoutSubmitForm.valid);
                    break;
                }
                case ORDER_TYPE.SCHEDULE_REPLENISHMENT_ORDER: {
                    this.checkoutService.scheduleReplenishmentOrder(this.scheduleReplenishmentFormData, this.checkoutSubmitForm.valid);
                    break;
                }
            }
        }
        else {
            this.checkoutSubmitForm.markAllAsTouched();
        }
    }
    ngOnInit() {
        this.subscription.add(combineLatest([
            this.checkoutService.getPlaceOrderLoading(),
            this.checkoutService.getPlaceOrderSuccess(),
            this.checkoutService.getPlaceOrderError(),
        ]).subscribe(([orderLoading, orderSuccess, orderError]) => {
            if (orderLoading) {
                this.placedOrder = this.launchDialogService.launch("PLACE_ORDER_SPINNER" /* PLACE_ORDER_SPINNER */, this.vcr);
            }
            if (orderError) {
                if (this.placedOrder) {
                    this.placedOrder
                        .subscribe((component) => {
                        this.launchDialogService.clear("PLACE_ORDER_SPINNER" /* PLACE_ORDER_SPINNER */);
                        if (component) {
                            component.destroy();
                        }
                    })
                        .unsubscribe();
                    this.checkoutService.clearPlaceOrderState();
                }
            }
            if (orderSuccess) {
                this.onSuccess(orderSuccess);
            }
        }));
        this.subscription.add(this.checkoutService
            .getCurrentOrderType()
            .subscribe((orderType) => (this.currentOrderType = orderType)));
        this.subscription.add(this.checkoutReplenishmentFormService
            .getScheduleReplenishmentFormData()
            .subscribe((data) => {
            var _a;
            this.scheduleReplenishmentFormData = data;
            this.daysOfWeekNotChecked$.next(((_a = data.daysOfWeek) === null || _a === void 0 ? void 0 : _a.length) === 0 &&
                data.recurrencePeriod === recurrencePeriod.WEEKLY);
        }));
    }
    onSuccess(data) {
        if (data) {
            switch (this.currentOrderType) {
                case ORDER_TYPE.PLACE_ORDER: {
                    this.routingService.go({ cxRoute: 'orderConfirmation' });
                    break;
                }
                case ORDER_TYPE.SCHEDULE_REPLENISHMENT_ORDER: {
                    this.routingService.go({ cxRoute: 'replenishmentConfirmation' });
                    break;
                }
            }
            this.checkoutReplenishmentFormService.resetScheduleReplenishmentFormData();
        }
    }
    ngOnDestroy() {
        this.subscription.unsubscribe();
        this.launchDialogService.clear("PLACE_ORDER_SPINNER" /* PLACE_ORDER_SPINNER */);
        this.checkoutService.clearPlaceOrderState();
    }
}
PlaceOrderComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PlaceOrderComponent, deps: [{ token: i1$1.CheckoutFacade }, { token: i1.RoutingService }, { token: i3$1.FormBuilder }, { token: CheckoutReplenishmentFormService }, { token: i4.LaunchDialogService }, { token: i0.ViewContainerRef }], target: i0.ɵɵFactoryTarget.Component });
PlaceOrderComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: PlaceOrderComponent, selector: "cx-place-order", ngImport: i0, template: "<form\n  (ngSubmit)=\"submitForm()\"\n  class=\"cx-place-order-form form-check\"\n  [formGroup]=\"checkoutSubmitForm\"\n>\n  <div class=\"form-group\">\n    <label>\n      <input\n        formControlName=\"termsAndConditions\"\n        class=\"scaled-input form-check-input\"\n        type=\"checkbox\"\n      />\n      <span class=\"form-check-label\">\n        {{ 'checkoutReview.confirmThatRead' | cxTranslate }}\n        <a\n          [routerLink]=\"{ cxRoute: 'termsAndConditions' } | cxUrl\"\n          class=\"cx-tc-link\"\n          target=\"_blank\"\n        >\n          {{ 'checkoutReview.termsAndConditions' | cxTranslate }}\n        </a>\n      </span>\n    </label>\n  </div>\n\n  <button\n    type=\"submit\"\n    class=\"btn btn-primary btn-block\"\n    [disabled]=\"termsAndConditionInvalid || (daysOfWeekNotChecked$ | async)\"\n  >\n    {{ 'checkoutReview.placeOrder' | cxTranslate }}\n  </button>\n</form>\n", directives: [{ type: i3$1.ɵNgNoValidate, selector: "form:not([ngNoForm]):not([ngNativeValidate])" }, { type: i3$1.NgControlStatusGroup, selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { type: i3$1.FormGroupDirective, selector: "[formGroup]", inputs: ["formGroup"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }, { type: i3$1.CheckboxControlValueAccessor, selector: "input[type=checkbox][formControlName],input[type=checkbox][formControl],input[type=checkbox][ngModel]" }, { type: i3$1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i3$1.FormControlName, selector: "[formControlName]", inputs: ["disabled", "formControlName", "ngModel"], outputs: ["ngModelChange"] }, { type: i3.RouterLinkWithHref, selector: "a[routerLink],area[routerLink]", inputs: ["routerLink", "target", "queryParams", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange", "replaceUrl", "state", "relativeTo"] }], pipes: { "cxTranslate": i1.TranslatePipe, "cxUrl": i1.UrlPipe, "async": i3$2.AsyncPipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PlaceOrderComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-place-order',
                    templateUrl: './place-order.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: i1$1.CheckoutFacade }, { type: i1.RoutingService }, { type: i3$1.FormBuilder }, { type: CheckoutReplenishmentFormService }, { type: i4.LaunchDialogService }, { type: i0.ViewContainerRef }]; } });

class PlaceOrderModule {
}
PlaceOrderModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PlaceOrderModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
PlaceOrderModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PlaceOrderModule, declarations: [PlaceOrderComponent], imports: [CommonModule,
        RouterModule,
        UrlModule,
        I18nModule,
        ReactiveFormsModule], exports: [PlaceOrderComponent] });
PlaceOrderModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PlaceOrderModule, providers: [
        provideConfig(defaultPlaceOrderSpinnerLayoutConfig),
        provideDefaultConfig({
            cmsComponents: {
                CheckoutPlaceOrder: {
                    component: PlaceOrderComponent,
                    guards: [CheckoutAuthGuard, CartNotEmptyGuard],
                },
            },
        }),
    ], imports: [[
            CommonModule,
            RouterModule,
            UrlModule,
            I18nModule,
            ReactiveFormsModule,
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PlaceOrderModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        RouterModule,
                        UrlModule,
                        I18nModule,
                        ReactiveFormsModule,
                    ],
                    providers: [
                        provideConfig(defaultPlaceOrderSpinnerLayoutConfig),
                        provideDefaultConfig({
                            cmsComponents: {
                                CheckoutPlaceOrder: {
                                    component: PlaceOrderComponent,
                                    guards: [CheckoutAuthGuard, CartNotEmptyGuard],
                                },
                            },
                        }),
                    ],
                    declarations: [PlaceOrderComponent],
                    exports: [PlaceOrderComponent],
                }]
        }] });

class ReviewSubmitComponent {
    constructor(checkoutDeliveryService, checkoutPaymentService, userAddressService, activeCartService, translation, checkoutStepService, paymentTypeService, checkoutCostCenterService, userCostCenterService) {
        this.checkoutDeliveryService = checkoutDeliveryService;
        this.checkoutPaymentService = checkoutPaymentService;
        this.userAddressService = userAddressService;
        this.activeCartService = activeCartService;
        this.translation = translation;
        this.checkoutStepService = checkoutStepService;
        this.paymentTypeService = paymentTypeService;
        this.checkoutCostCenterService = checkoutCostCenterService;
        this.userCostCenterService = userCostCenterService;
        this.iconTypes = ICON_TYPE;
        this.checkoutStepType = CheckoutStepType;
        this.promotionLocation = PromotionLocation.ActiveCart;
    }
    get cart$() {
        return this.activeCartService.getActive();
    }
    get entries$() {
        return this.activeCartService.getEntries();
    }
    get steps$() {
        return this.checkoutStepService.steps$;
    }
    get deliveryAddress$() {
        return this.checkoutDeliveryService.getDeliveryAddress();
    }
    get deliveryMode$() {
        return this.checkoutDeliveryService.getSelectedDeliveryMode().pipe(tap((selected) => {
            if (selected === null) {
                this.checkoutDeliveryService.loadSupportedDeliveryModes();
            }
        }));
    }
    get paymentDetails$() {
        return this.checkoutPaymentService.getPaymentDetails();
    }
    get countryName$() {
        return this.deliveryAddress$.pipe(switchMap((address) => { var _a; return this.userAddressService.getCountry((_a = address === null || address === void 0 ? void 0 : address.country) === null || _a === void 0 ? void 0 : _a.isocode); }), tap((country) => {
            if (country === null) {
                this.userAddressService.loadDeliveryCountries();
            }
        }), map((country) => country && country.name));
    }
    get poNumber$() {
        return this.paymentTypeService.getPoNumber();
    }
    get paymentType$() {
        return this.paymentTypeService.getSelectedPaymentType();
    }
    get isAccountPayment$() {
        return this.paymentTypeService.isAccountPayment();
    }
    get costCenter$() {
        return this.userCostCenterService.getActiveCostCenters().pipe(filter((costCenters) => Boolean(costCenters)), switchMap((costCenters) => {
            return this.checkoutCostCenterService.getCostCenter().pipe(map((code) => {
                return costCenters.find((cc) => cc.code === code);
            }));
        }));
    }
    getShippingAddressCard(deliveryAddress, countryName) {
        return combineLatest([
            this.translation.translate('addressCard.shipTo'),
        ]).pipe(map(([textTitle]) => {
            var _a;
            if (!countryName) {
                countryName = (_a = deliveryAddress === null || deliveryAddress === void 0 ? void 0 : deliveryAddress.country) === null || _a === void 0 ? void 0 : _a.isocode;
            }
            let region = '';
            if (deliveryAddress &&
                deliveryAddress.region &&
                deliveryAddress.region.isocode) {
                region = deliveryAddress.region.isocode + ', ';
            }
            return {
                title: textTitle,
                textBold: deliveryAddress.firstName + ' ' + deliveryAddress.lastName,
                text: [
                    deliveryAddress.line1,
                    deliveryAddress.line2,
                    deliveryAddress.town + ', ' + region + countryName,
                    deliveryAddress.postalCode,
                    deliveryAddress.phone,
                ],
            };
        }));
    }
    getCostCenterCard(costCenter) {
        return combineLatest([
            this.translation.translate('checkoutPO.costCenter'),
        ]).pipe(map(([textTitle]) => {
            var _a;
            return {
                title: textTitle,
                textBold: costCenter === null || costCenter === void 0 ? void 0 : costCenter.name,
                text: ['(' + ((_a = costCenter === null || costCenter === void 0 ? void 0 : costCenter.unit) === null || _a === void 0 ? void 0 : _a.name) + ')'],
            };
        }));
    }
    getDeliveryModeCard(deliveryMode) {
        return combineLatest([
            this.translation.translate('checkoutShipping.shippingMethod'),
        ]).pipe(map(([textTitle]) => {
            var _a, _b;
            return {
                title: textTitle,
                textBold: deliveryMode.name,
                text: [
                    deliveryMode.description,
                    ((_a = deliveryMode.deliveryCost) === null || _a === void 0 ? void 0 : _a.formattedValue)
                        ? (_b = deliveryMode.deliveryCost) === null || _b === void 0 ? void 0 : _b.formattedValue
                        : '',
                ],
            };
        }));
    }
    getPaymentMethodCard(paymentDetails) {
        return combineLatest([
            this.translation.translate('paymentForm.payment'),
            this.translation.translate('paymentCard.expires', {
                month: paymentDetails.expiryMonth,
                year: paymentDetails.expiryYear,
            }),
            this.translation.translate('paymentForm.billingAddress'),
        ]).pipe(map(([textTitle, textExpires, billingAddress]) => {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
            const region = ((_b = (_a = paymentDetails.billingAddress) === null || _a === void 0 ? void 0 : _a.region) === null || _b === void 0 ? void 0 : _b.isocode)
                ? ((_d = (_c = paymentDetails.billingAddress) === null || _c === void 0 ? void 0 : _c.region) === null || _d === void 0 ? void 0 : _d.isocode) + ', '
                : '';
            return {
                title: textTitle,
                textBold: paymentDetails.accountHolderName,
                text: [paymentDetails.cardNumber, textExpires],
                paragraphs: [
                    {
                        title: billingAddress + ':',
                        text: [
                            ((_e = paymentDetails.billingAddress) === null || _e === void 0 ? void 0 : _e.firstName) +
                                ' ' +
                                ((_f = paymentDetails.billingAddress) === null || _f === void 0 ? void 0 : _f.lastName),
                            (_g = paymentDetails.billingAddress) === null || _g === void 0 ? void 0 : _g.line1,
                            ((_h = paymentDetails.billingAddress) === null || _h === void 0 ? void 0 : _h.town) +
                                ', ' +
                                region +
                                ((_k = (_j = paymentDetails.billingAddress) === null || _j === void 0 ? void 0 : _j.country) === null || _k === void 0 ? void 0 : _k.isocode),
                            (_l = paymentDetails.billingAddress) === null || _l === void 0 ? void 0 : _l.postalCode,
                        ],
                    },
                ],
            };
        }));
    }
    getPoNumberCard(poNumber) {
        return combineLatest([
            this.translation.translate('checkoutReview.poNumber'),
            this.translation.translate('checkoutPO.noPoNumber'),
        ]).pipe(map(([textTitle, noneTextTitle]) => {
            return {
                title: textTitle,
                textBold: poNumber ? poNumber : noneTextTitle,
            };
        }));
    }
    getPaymentTypeCard(paymentType) {
        return combineLatest([
            this.translation.translate('checkoutProgress.methodOfPayment'),
            this.translation.translate('paymentTypes.paymentType_' + paymentType),
        ]).pipe(map(([textTitle, paymentTypeTranslation]) => {
            return {
                title: textTitle,
                textBold: paymentTypeTranslation,
            };
        }));
    }
    getCheckoutStepUrl(stepType) {
        const step = this.checkoutStepService.getCheckoutStep(stepType);
        return step && step.routeName;
    }
    shippingSteps(steps) {
        return steps.filter((step) => checkoutShippingSteps.includes(step.type[0]));
    }
    paymentSteps(steps) {
        return steps.filter((step) => checkoutPaymentSteps.includes(step.type[0]));
    }
}
ReviewSubmitComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ReviewSubmitComponent, deps: [{ token: i1$1.CheckoutDeliveryFacade }, { token: i1$1.CheckoutPaymentFacade }, { token: i1.UserAddressService }, { token: i1.ActiveCartService }, { token: i1.TranslationService }, { token: CheckoutStepService }, { token: i1$1.PaymentTypeFacade }, { token: i1$1.CheckoutCostCenterFacade }, { token: i1.UserCostCenterService }], target: i0.ɵɵFactoryTarget.Component });
ReviewSubmitComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: ReviewSubmitComponent, selector: "cx-review-submit", ngImport: i0, template: "<div class=\"cx-review\">\n  <!-- TITLE -->\n  <h2 class=\"cx-review-title d-none d-lg-block d-xl-block\">\n    {{ 'checkoutReview.review' | cxTranslate }}\n  </h2>\n\n  <div class=\"cx-review-summary row\">\n    <ng-container *ngIf=\"(steps$ | async)?.slice(0, -1) as steps\">\n      <div class=\"col-md-12 col-lg-6 col-xl-6 cx-review-payment-col\">\n        <ng-container *ngFor=\"let step of paymentSteps(steps)\">\n          <ng-container [ngSwitch]=\"step.type[0]\">\n            <ng-container *ngSwitchCase=\"checkoutStepType.PAYMENT_TYPE\">\n              <ng-container *ngTemplateOutlet=\"poNumber\"></ng-container>\n            </ng-container>\n            <ng-container *ngSwitchCase=\"checkoutStepType.PAYMENT_TYPE\">\n              <ng-container *ngTemplateOutlet=\"paymentType\"></ng-container>\n            </ng-container>\n            <ng-container *ngSwitchCase=\"checkoutStepType.PAYMENT_DETAILS\">\n              <ng-container *ngTemplateOutlet=\"paymentMethod\"></ng-container>\n            </ng-container>\n            <ng-container *ngSwitchCase=\"checkoutStepType.SHIPPING_ADDRESS\">\n              <ng-container *ngTemplateOutlet=\"costCenter\"></ng-container>\n            </ng-container>\n          </ng-container>\n        </ng-container>\n      </div>\n      <div class=\"col-md-12 col-lg-6 col-xl-6 cx-review-shipping-col\">\n        <ng-container *ngFor=\"let step of shippingSteps(steps)\">\n          <ng-container [ngSwitch]=\"step.type[0]\">\n            <ng-container *ngSwitchCase=\"checkoutStepType.SHIPPING_ADDRESS\">\n              <ng-container *ngTemplateOutlet=\"shippingAddress\"></ng-container>\n            </ng-container>\n            <ng-container *ngSwitchCase=\"checkoutStepType.DELIVERY_MODE\">\n              <ng-container *ngTemplateOutlet=\"deliveryMode\"></ng-container>\n            </ng-container>\n          </ng-container>\n        </ng-container>\n      </div>\n    </ng-container>\n  </div>\n\n  <!-- PO NUMBER SECTION -->\n  <ng-template #poNumber>\n    <div class=\"cx-review-summary-card\">\n      <cx-card [content]=\"getPoNumberCard(poNumber$ | async) | async\"></cx-card>\n      <div class=\"cx-review-summary-edit-step\">\n        <a\n          [attr.aria-label]=\"'checkoutReview.editPaymentType' | cxTranslate\"\n          [routerLink]=\"\n            {\n              cxRoute: getCheckoutStepUrl(checkoutStepType.PAYMENT_TYPE)\n            } | cxUrl\n          \"\n          ><cx-icon aria-hidden=\"true\" [type]=\"iconTypes.PENCIL\"></cx-icon\n        ></a>\n      </div>\n    </div>\n  </ng-template>\n\n  <!-- PAYMENT TYPE SECTION -->\n  <ng-template #paymentType>\n    <div class=\"cx-review-summary-card\">\n      <cx-card\n        *ngIf=\"paymentType$ | async as paymentType\"\n        [content]=\"getPaymentTypeCard(paymentType) | async\"\n      ></cx-card>\n      <div class=\"cx-review-summary-edit-step\">\n        <a\n          [attr.aria-label]=\"'checkoutReview.editPaymentType' | cxTranslate\"\n          [routerLink]=\"\n            {\n              cxRoute: getCheckoutStepUrl(checkoutStepType.PAYMENT_TYPE)\n            } | cxUrl\n          \"\n          ><cx-icon aria-hidden=\"true\" [type]=\"iconTypes.PENCIL\"></cx-icon\n        ></a>\n      </div>\n    </div>\n  </ng-template>\n\n  <!-- COST CENTER SECTION -->\n  <ng-template #costCenter>\n    <ng-container *ngIf=\"isAccountPayment$ | async\">\n      <div class=\"cx-review-summary-card\">\n        <cx-card\n          *ngIf=\"costCenter$ | async as costCenter\"\n          [content]=\"getCostCenterCard(costCenter) | async\"\n        ></cx-card>\n        <div class=\"cx-review-summary-edit-step\">\n          <a\n            [attr.aria-label]=\"\n              'checkoutReview.editShippingAddressDetails' | cxTranslate\n            \"\n            [routerLink]=\"\n              {\n                cxRoute: getCheckoutStepUrl(checkoutStepType.SHIPPING_ADDRESS)\n              } | cxUrl\n            \"\n            ><cx-icon aria-hidden=\"true\" [type]=\"iconTypes.PENCIL\"></cx-icon\n          ></a>\n        </div>\n      </div>\n    </ng-container>\n  </ng-template>\n\n  <!-- SHIPPING ADDRESS SECTION -->\n  <ng-template #shippingAddress>\n    <div\n      *ngIf=\"deliveryAddress$ | async as deliveryAddress\"\n      class=\"cx-review-summary-card cx-review-card-address\"\n    >\n      <cx-card\n        *ngIf=\"countryName$ | async as countryName\"\n        [content]=\"getShippingAddressCard(deliveryAddress, countryName) | async\"\n      ></cx-card>\n      <div class=\"cx-review-summary-edit-step\">\n        <a\n          [attr.aria-label]=\"\n            'checkoutReview.editShippingAddressDetails' | cxTranslate\n          \"\n          [routerLink]=\"\n            {\n              cxRoute: getCheckoutStepUrl(checkoutStepType.SHIPPING_ADDRESS)\n            } | cxUrl\n          \"\n          ><cx-icon aria-hidden=\"true\" [type]=\"iconTypes.PENCIL\"></cx-icon\n        ></a>\n      </div>\n    </div>\n  </ng-template>\n\n  <!-- DELIVERY MODE SECTION -->\n  <ng-template #deliveryMode>\n    <div class=\"cx-review-summary-card cx-review-card-shipping\">\n      <cx-card\n        *ngIf=\"deliveryMode$ | async as deliveryMode\"\n        [content]=\"getDeliveryModeCard(deliveryMode) | async\"\n      ></cx-card>\n      <div class=\"cx-review-summary-edit-step\">\n        <a\n          [attr.aria-label]=\"'checkoutReview.editDeliveryMode' | cxTranslate\"\n          [routerLink]=\"\n            { cxRoute: getCheckoutStepUrl(checkoutStepType.DELIVERY_MODE) }\n              | cxUrl\n          \"\n        >\n          <cx-icon aria-hidden=\"true\" [type]=\"iconTypes.PENCIL\"></cx-icon>\n        </a>\n      </div>\n    </div>\n  </ng-template>\n\n  <!-- PAYMENT METHOD SECTION -->\n  <ng-template #paymentMethod>\n    <div class=\"cx-review-summary-card cx-review-card-payment\">\n      <div>\n        <cx-card\n          *ngIf=\"paymentDetails$ | async as paymentDetails\"\n          [content]=\"getPaymentMethodCard(paymentDetails) | async\"\n        ></cx-card>\n      </div>\n      <div class=\"cx-review-summary-edit-step\">\n        <a\n          [attr.aria-label]=\"'checkoutReview.editPaymentDetails' | cxTranslate\"\n          [routerLink]=\"\n            { cxRoute: getCheckoutStepUrl(checkoutStepType.PAYMENT_DETAILS) }\n              | cxUrl\n          \"\n        >\n          <cx-icon aria-hidden=\"true\" [type]=\"iconTypes.PENCIL\"></cx-icon>\n        </a>\n      </div>\n    </div>\n  </ng-template>\n\n  <!-- CART ITEM SECTION -->\n  <ng-container *ngIf=\"cart$ | async as cart\">\n    <h4 class=\"cx-review-cart-total d-none d-lg-block d-xl-block\">\n      {{\n        'cartItems.cartTotal'\n          | cxTranslate: { count: cart.deliveryItemsQuantity }\n      }}:\n      {{ cart.totalPrice?.formattedValue }}\n    </h4>\n    <h4 class=\"cx-review-cart-heading d-block d-lg-none d-xl-none\">\n      {{ 'checkoutReview.placeOrder' | cxTranslate }}\n    </h4>\n    <div\n      class=\"cx-review-cart-item col-md-12\"\n      *ngIf=\"entries$ | async as entries\"\n    >\n      <cx-promotions\n        [promotions]=\"\n          (cart.appliedOrderPromotions || []).concat(\n            cart.potentialOrderPromotions || []\n          )\n        \"\n      ></cx-promotions>\n\n      <cx-cart-item-list\n        [items]=\"entries\"\n        [readonly]=\"true\"\n        [promotionLocation]=\"promotionLocation\"\n      ></cx-cart-item-list>\n    </div>\n  </ng-container>\n</div>\n", components: [{ type: i4.CardComponent, selector: "cx-card", inputs: ["border", "editMode", "isDefault", "content", "fitToContainer", "truncateText", "charactersLimit"], outputs: ["deleteCard", "setDefaultCard", "sendCard", "editCard", "cancelCard"] }, { type: i4.IconComponent, selector: "cx-icon,[cxIcon]", inputs: ["cxIcon", "type"] }, { type: i4.PromotionsComponent, selector: "cx-promotions", inputs: ["promotions"] }, { type: i4.CartItemListComponent, selector: "cx-cart-item-list", inputs: ["readonly", "hasHeader", "options", "cartId", "items", "promotionLocation", "cartIsLoading"] }], directives: [{ type: i3$2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3$2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i3$2.NgSwitch, selector: "[ngSwitch]", inputs: ["ngSwitch"] }, { type: i3$2.NgSwitchCase, selector: "[ngSwitchCase]", inputs: ["ngSwitchCase"] }, { type: i3$2.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }, { type: i3.RouterLinkWithHref, selector: "a[routerLink],area[routerLink]", inputs: ["routerLink", "target", "queryParams", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange", "replaceUrl", "state", "relativeTo"] }], pipes: { "cxTranslate": i1.TranslatePipe, "async": i3$2.AsyncPipe, "cxUrl": i1.UrlPipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ReviewSubmitComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-review-submit',
                    templateUrl: './review-submit.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: i1$1.CheckoutDeliveryFacade }, { type: i1$1.CheckoutPaymentFacade }, { type: i1.UserAddressService }, { type: i1.ActiveCartService }, { type: i1.TranslationService }, { type: CheckoutStepService }, { type: i1$1.PaymentTypeFacade }, { type: i1$1.CheckoutCostCenterFacade }, { type: i1.UserCostCenterService }]; } });

class ReviewSubmitModule {
}
ReviewSubmitModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ReviewSubmitModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ReviewSubmitModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ReviewSubmitModule, declarations: [ReviewSubmitComponent], imports: [CommonModule,
        CardModule,
        CartSharedModule,
        I18nModule,
        UrlModule,
        RouterModule,
        PromotionsModule,
        IconModule], exports: [ReviewSubmitComponent] });
ReviewSubmitModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ReviewSubmitModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                CheckoutReviewOrder: {
                    component: ReviewSubmitComponent,
                    // TODO(#8880): Shouldn't we keep ShippingAddressSetGuard and others here?
                    guards: [CheckoutAuthGuard, CartNotEmptyGuard],
                },
            },
        }),
    ], imports: [[
            CommonModule,
            CardModule,
            CartSharedModule,
            I18nModule,
            UrlModule,
            RouterModule,
            PromotionsModule,
            IconModule,
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ReviewSubmitModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        CardModule,
                        CartSharedModule,
                        I18nModule,
                        UrlModule,
                        RouterModule,
                        PromotionsModule,
                        IconModule,
                    ],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                CheckoutReviewOrder: {
                                    component: ReviewSubmitComponent,
                                    // TODO(#8880): Shouldn't we keep ShippingAddressSetGuard and others here?
                                    guards: [CheckoutAuthGuard, CartNotEmptyGuard],
                                },
                            },
                        }),
                    ],
                    declarations: [ReviewSubmitComponent],
                    exports: [ReviewSubmitComponent],
                }]
        }] });

class ScheduleReplenishmentOrderComponent {
    constructor(checkoutService, checkoutReplenishmentFormService) {
        this.checkoutService = checkoutService;
        this.checkoutReplenishmentFormService = checkoutReplenishmentFormService;
        this.subscription = new Subscription();
        this.iconTypes = ICON_TYPE;
        this.orderTypes = ORDER_TYPE;
        this.daysOfWeek = Object.values(DaysOfWeek);
        this.recurrencePeriodType = Object.values(recurrencePeriod);
        this.selectedOrderType$ = this.checkoutService.getCurrentOrderType();
        this.isMonthly = false;
        this.isWeekly = false;
        this.currentDaysOfWeek = [];
    }
    ngOnInit() {
        this.subscription.add(this.checkoutReplenishmentFormService
            .getScheduleReplenishmentFormData()
            .subscribe((data) => {
            this.scheduleReplenishmentFormData = data;
        }));
        this.initConfig();
    }
    changeOrderType(orderType) {
        this.checkoutService.setOrderType(orderType);
    }
    changeNumberOfDays(nDays) {
        this.checkoutReplenishmentFormService.setScheduleReplenishmentFormData(Object.assign(Object.assign({}, this.scheduleReplenishmentFormData), { numberOfDays: nDays }));
    }
    changeNumberOfWeeks(nWeeks) {
        this.checkoutReplenishmentFormService.setScheduleReplenishmentFormData(Object.assign(Object.assign({}, this.scheduleReplenishmentFormData), { numberOfWeeks: nWeeks }));
    }
    changeRecurrencePeriodType(type) {
        this.isWeekly = type === recurrencePeriod.WEEKLY;
        this.isMonthly = type === recurrencePeriod.MONTHLY;
        this.numberOfDays = this.isMonthly
            ? this.createNumberStringArray(31)
            : this.createNumberStringArray(30);
        this.checkoutReplenishmentFormService.setScheduleReplenishmentFormData(Object.assign(Object.assign({}, this.scheduleReplenishmentFormData), { recurrencePeriod: type }));
    }
    changeDayOfTheMonth(dayOfMonth) {
        this.checkoutReplenishmentFormService.setScheduleReplenishmentFormData(Object.assign(Object.assign({}, this.scheduleReplenishmentFormData), { nthDayOfMonth: dayOfMonth }));
    }
    changeReplenishmentStartDate(date) {
        if (Boolean(date)) {
            this.checkoutReplenishmentFormService.setScheduleReplenishmentFormData(Object.assign(Object.assign({}, this.scheduleReplenishmentFormData), { replenishmentStartDate: date }));
        }
    }
    changeRepeatDays(day, isChecked) {
        if (isChecked) {
            this.currentDaysOfWeek = [...this.currentDaysOfWeek];
            this.currentDaysOfWeek.push(day);
            this.checkoutReplenishmentFormService.setScheduleReplenishmentFormData(Object.assign(Object.assign({}, this.scheduleReplenishmentFormData), { daysOfWeek: this.currentDaysOfWeek }));
        }
        else {
            const foundDay = this.currentDaysOfWeek.find((data) => day === data);
            if (!foundDay)
                return;
            const index = this.currentDaysOfWeek.indexOf(foundDay);
            this.currentDaysOfWeek.splice(index, 1);
            this.checkoutReplenishmentFormService.setScheduleReplenishmentFormData(Object.assign(Object.assign({}, this.scheduleReplenishmentFormData), { daysOfWeek: this.currentDaysOfWeek }));
        }
    }
    hasDaysOfWeekChecked(day) {
        return this.currentDaysOfWeek.includes(day);
    }
    initConfig() {
        var _a;
        this.isMonthly =
            this.scheduleReplenishmentFormData.recurrencePeriod ===
                recurrencePeriod.MONTHLY;
        this.isWeekly =
            this.scheduleReplenishmentFormData.recurrencePeriod ===
                recurrencePeriod.WEEKLY;
        this.currentDaysOfWeek = [
            ...((_a = this.scheduleReplenishmentFormData.daysOfWeek) !== null && _a !== void 0 ? _a : []),
        ];
        this.numberOfDays = this.isMonthly
            ? this.createNumberStringArray(31)
            : this.createNumberStringArray(30);
        this.numberOfWeeks = this.createNumberStringArray(12);
        this.currentDate =
            this.scheduleReplenishmentFormData.replenishmentStartDate;
    }
    createNumberStringArray(n) {
        return Array(n)
            .fill(0)
            .map((_, y) => (y + 1).toString());
    }
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
}
ScheduleReplenishmentOrderComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ScheduleReplenishmentOrderComponent, deps: [{ token: i1$1.CheckoutFacade }, { token: CheckoutReplenishmentFormService }], target: i0.ɵɵFactoryTarget.Component });
ScheduleReplenishmentOrderComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: ScheduleReplenishmentOrderComponent, selector: "cx-schedule-replenishment-order", ngImport: i0, template: "<div class=\"cx-order-type-card\">\n  <div class=\"cx-label-container\">\n    <h5 class=\"cx-order-replenishment-header\">\n      {{ 'checkoutReview.autoReplenishOrder' | cxTranslate }}\n    </h5>\n    <cx-icon [type]=\"iconTypes.CLOCK\"></cx-icon>\n  </div>\n  <div\n    class=\"cx-order-type-container form-check\"\n    *ngFor=\"let type of orderTypes | keyvalue\"\n  >\n    <input\n      id=\"orderType-{{ type.value }}\"\n      class=\"scaled-input form-check-input\"\n      role=\"radio\"\n      type=\"radio\"\n      formControlName=\"orderType\"\n      aria-checked=\"true\"\n      (change)=\"changeOrderType(type.value)\"\n      [value]=\"type.value\"\n      [checked]=\"type.value == (selectedOrderType$ | async)\"\n    />\n    <label\n      class=\"order-type-label form-check-label form-radio-label\"\n      for=\"orderType-{{ type.value }}\"\n    >\n      <div class=\"order-type\">\n        {{ 'checkoutReview.orderType_' + type?.value | cxTranslate }}\n      </div>\n    </label>\n  </div>\n  <ng-container\n    *ngIf=\"\n      scheduleReplenishmentFormData &&\n      (selectedOrderType$ | async) === orderTypes.SCHEDULE_REPLENISHMENT_ORDER\n    \"\n  >\n    <div class=\"cx-replenishment-form-data-container\">\n      <div *ngIf=\"!isMonthly\" class=\"cx-days\">\n        <span class=\"form-data-label\">{{\n          'checkoutReview.every' | cxTranslate\n        }}</span>\n        <ng-container *ngIf=\"isWeekly; else isDaily\">\n          <select\n            class=\"form-control\"\n            (change)=\"changeNumberOfWeeks($event.target.value)\"\n          >\n            <option\n              *ngFor=\"let nWeeks of numberOfWeeks\"\n              [value]=\"nWeeks\"\n              [selected]=\"\n                nWeeks === scheduleReplenishmentFormData.numberOfWeeks\n              \"\n            >\n              {{ nWeeks }}\n            </option>\n          </select>\n        </ng-container>\n        <ng-template #isDaily>\n          <select\n            class=\"form-control\"\n            (change)=\"changeNumberOfDays($event.target.value)\"\n          >\n            <option\n              *ngFor=\"let nDays of numberOfDays\"\n              [value]=\"nDays\"\n              [selected]=\"nDays === scheduleReplenishmentFormData.numberOfDays\"\n            >\n              {{ nDays }}\n            </option>\n          </select>\n        </ng-template>\n      </div>\n      <div class=\"cx-month\">\n        <span *ngIf=\"isMonthly\" class=\"form-data-label\">{{\n          'checkoutReview.every' | cxTranslate\n        }}</span>\n        <select\n          class=\"form-control\"\n          (change)=\"changeRecurrencePeriodType($event.target.value)\"\n        >\n          <option\n            *ngFor=\"let type of recurrencePeriodType\"\n            [value]=\"type\"\n            [selected]=\"type === scheduleReplenishmentFormData.recurrencePeriod\"\n          >\n            {{ 'checkoutReview.recurrencePeriodType_' + type | cxTranslate }}\n          </option>\n        </select>\n      </div>\n      <div *ngIf=\"isMonthly\" class=\"cx-dayMonth\">\n        <span class=\"form-data-label\">{{\n          'checkoutReview.dayOfMonth' | cxTranslate\n        }}</span>\n        <div class=\"cx-day-of-month\">\n          <select\n            class=\"form-control\"\n            (change)=\"changeDayOfTheMonth($event.target.value)\"\n          >\n            <option\n              *ngFor=\"let nDays of numberOfDays\"\n              [value]=\"nDays\"\n              [selected]=\"nDays === scheduleReplenishmentFormData.nthDayOfMonth\"\n            >\n              {{ nDays }}\n            </option>\n          </select>\n        </div>\n      </div>\n    </div>\n\n    <div class=\"cx-replenishment-form-data-container\">\n      <span class=\"form-data-label\">{{\n        'checkoutReview.startOn' | cxTranslate\n      }}</span>\n      <div class=\"cx-replenishment-date\">\n        <input\n          type=\"date\"\n          placeholder=\"yyyy-mm-dd\"\n          [value]=\"currentDate\"\n          (change)=\"changeReplenishmentStartDate($event.target.value)\"\n        />\n      </div>\n    </div>\n\n    <div\n      *ngIf=\"isWeekly\"\n      class=\"cx-replenishment-form-data-container cx-repeat-days-container\"\n    >\n      <span class=\"cx-repeat-days form-data-label\">{{\n        'checkoutReview.repeatOnDays' | cxTranslate\n      }}</span>\n      <div *ngFor=\"let day of daysOfWeek\" class=\"form-check\">\n        <label for=\"day-{{ day }}\" class=\"cx-week-day\">{{\n          day | titlecase\n        }}</label\n        ><input\n          id=\"day-{{ day }}\"\n          type=\"checkbox\"\n          class=\"form-check-input\"\n          [checked]=\"hasDaysOfWeekChecked(day)\"\n          (change)=\"changeRepeatDays(day, $event.target.checked)\"\n        />\n      </div>\n    </div>\n  </ng-container>\n</div>\n", components: [{ type: i4.IconComponent, selector: "cx-icon,[cxIcon]", inputs: ["cxIcon", "type"] }], directives: [{ type: i3$2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i3$2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "cxTranslate": i1.TranslatePipe, "keyvalue": i3$2.KeyValuePipe, "async": i3$2.AsyncPipe, "titlecase": i3$2.TitleCasePipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ScheduleReplenishmentOrderComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-schedule-replenishment-order',
                    templateUrl: './schedule-replenishment-order.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: i1$1.CheckoutFacade }, { type: CheckoutReplenishmentFormService }]; } });

class ScheduleReplenishmentOrderModule {
}
ScheduleReplenishmentOrderModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ScheduleReplenishmentOrderModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ScheduleReplenishmentOrderModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ScheduleReplenishmentOrderModule, declarations: [ScheduleReplenishmentOrderComponent], imports: [CommonModule, RouterModule, I18nModule, IconModule], exports: [ScheduleReplenishmentOrderComponent] });
ScheduleReplenishmentOrderModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ScheduleReplenishmentOrderModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                CheckoutScheduleReplenishmentOrder: {
                    component: ScheduleReplenishmentOrderComponent,
                    guards: [CheckoutAuthGuard, CartNotEmptyGuard],
                },
            },
        }),
    ], imports: [[CommonModule, RouterModule, I18nModule, IconModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ScheduleReplenishmentOrderModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, RouterModule, I18nModule, IconModule],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                CheckoutScheduleReplenishmentOrder: {
                                    component: ScheduleReplenishmentOrderComponent,
                                    guards: [CheckoutAuthGuard, CartNotEmptyGuard],
                                },
                            },
                        }),
                    ],
                    declarations: [ScheduleReplenishmentOrderComponent],
                    exports: [ScheduleReplenishmentOrderComponent],
                }]
        }] });

class ShippingAddressComponent {
    constructor(userAddressService, checkoutDeliveryService, activatedRoute, translation, activeCartService, checkoutStepService, paymentTypeService, userCostCenterService, checkoutCostCenterService) {
        this.userAddressService = userAddressService;
        this.checkoutDeliveryService = checkoutDeliveryService;
        this.activatedRoute = activatedRoute;
        this.translation = translation;
        this.activeCartService = activeCartService;
        this.checkoutStepService = checkoutStepService;
        this.paymentTypeService = paymentTypeService;
        this.userCostCenterService = userCostCenterService;
        this.checkoutCostCenterService = checkoutCostCenterService;
        this.addressFormOpened = false;
        this.forceLoader = false; // this helps with smoother steps transition
        this.doneAutoSelect = false;
        this.isAccountPayment = false;
        this.subscriptions = new Subscription();
    }
    get isGuestCheckout() {
        return this.activeCartService.isGuestCart();
    }
    get backBtnText() {
        return this.checkoutStepService.getBackBntText(this.activatedRoute);
    }
    get isLoading$() {
        return this.userAddressService.getAddressesLoading();
    }
    get selectedAddress$() {
        return this.checkoutDeliveryService.getDeliveryAddress().pipe(tap((address) => {
            if (address &&
                (this.selectedAddress === undefined ||
                    this.selectedAddress.id !== address.id)) {
                this.selectedAddress = address;
                if (this.forceLoader) {
                    this.next();
                }
            }
        }));
    }
    get cards$() {
        return combineLatest([
            this.getSupportedAddresses(),
            this.selectedAddress$,
            this.translation.translate('checkoutAddress.defaultShippingAddress'),
            this.translation.translate('checkoutAddress.shipToThisAddress'),
            this.translation.translate('addressCard.selected'),
        ]).pipe(tap(([addresses, selected]) => this.selectDefaultAddress(addresses, selected)), map(([addresses, selected, textDefault, textShipTo, textSelected]) => addresses.map((address) => ({
            address,
            card: this.getCardContent(address, selected, textDefault, textShipTo, textSelected),
        }))));
    }
    getSupportedAddresses() {
        if (this.isAccountPayment &&
            this.checkoutCostCenterService &&
            this.userCostCenterService) {
            return this.checkoutCostCenterService.getCostCenter().pipe(distinctUntilChanged(), switchMap((selected) => {
                var _a, _b;
                this.doneAutoSelect = false;
                return ((_b = (_a = this.userCostCenterService) === null || _a === void 0 ? void 0 : _a.getCostCenterAddresses(selected)) !== null && _b !== void 0 ? _b : []);
            }));
        }
        return this.userAddressService.getAddresses();
    }
    selectDefaultAddress(addresses, selected) {
        if (!this.doneAutoSelect &&
            addresses &&
            addresses.length &&
            (!selected || Object.keys(selected).length === 0)) {
            if (this.isAccountPayment) {
                if (addresses.length === 1) {
                    this.selectAddress(addresses[0]);
                }
            }
            else {
                selected = addresses.find((address) => address.defaultAddress);
                if (selected) {
                    this.selectAddress(selected);
                }
            }
            this.doneAutoSelect = true;
        }
    }
    ngOnInit() {
        if (this.paymentTypeService &&
            this.userCostCenterService &&
            this.checkoutCostCenterService) {
            this.subscriptions.add(this.paymentTypeService
                .isAccountPayment()
                .pipe(distinctUntilChanged())
                .subscribe((isAccount) => (this.isAccountPayment = isAccount)));
        }
        if (!this.isGuestCheckout && !this.isAccountPayment) {
            this.userAddressService.loadAddresses();
        }
    }
    getCardContent(address, selected, textDefaultShippingAddress, textShipToThisAddress, textSelected) {
        var _a;
        let region = '';
        if (address.region && address.region.isocode) {
            region = address.region.isocode + ', ';
        }
        return {
            title: address.defaultAddress ? textDefaultShippingAddress : '',
            textBold: address.firstName + ' ' + address.lastName,
            text: [
                address.line1,
                address.line2,
                address.town + ', ' + region + ((_a = address.country) === null || _a === void 0 ? void 0 : _a.isocode),
                address.postalCode,
                address.phone,
            ],
            actions: [{ name: textShipToThisAddress, event: 'send' }],
            header: selected && selected.id === address.id ? textSelected : '',
        };
    }
    selectAddress(address) {
        this.checkoutDeliveryService.setDeliveryAddress(address);
    }
    addAddress(address) {
        this.forceLoader = true;
        if (Boolean(address)) {
            this.checkoutDeliveryService.createAndSetAddress(address);
        }
        else {
            this.forceLoader = false;
            this.next();
        }
    }
    showNewAddressForm() {
        this.addressFormOpened = true;
    }
    hideNewAddressForm(goPrevious = false) {
        this.addressFormOpened = false;
        if (goPrevious) {
            this.back();
        }
    }
    next() {
        this.checkoutStepService.next(this.activatedRoute);
    }
    back() {
        this.checkoutStepService.back(this.activatedRoute);
    }
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
    }
}
ShippingAddressComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ShippingAddressComponent, deps: [{ token: i1.UserAddressService }, { token: i1$1.CheckoutDeliveryFacade }, { token: i3.ActivatedRoute }, { token: i1.TranslationService }, { token: i1.ActiveCartService }, { token: CheckoutStepService }, { token: i1$1.PaymentTypeFacade }, { token: i1.UserCostCenterService }, { token: i1$1.CheckoutCostCenterFacade }], target: i0.ɵɵFactoryTarget.Component });
ShippingAddressComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: ShippingAddressComponent, selector: "cx-shipping-address", ngImport: i0, template: "<ng-container *ngIf=\"cards$ | async as cards\">\n  <h2 class=\"cx-checkout-title d-none d-lg-block d-xl-block\">\n    {{ 'checkoutAddress.shippingAddress' | cxTranslate }}\n  </h2>\n  <ng-container *ngIf=\"!forceLoader && !(isLoading$ | async); else loading\">\n    <ng-container\n      *ngIf=\"\n        isAccountPayment || (cards?.length && !addressFormOpened);\n        else newAddressForm\n      \"\n    >\n      <p class=\"cx-checkout-text\">\n        {{ 'checkoutAddress.selectYourShippingAddress' | cxTranslate }}\n      </p>\n      <div class=\"cx-checkout-btns row\" *ngIf=\"!isAccountPayment\">\n        <div class=\"col-sm-12 col-md-12 col-lg-6\">\n          <button\n            class=\"btn btn-block btn-action\"\n            (click)=\"showNewAddressForm()\"\n          >\n            {{ 'checkoutAddress.addNewAddress' | cxTranslate }}\n          </button>\n        </div>\n      </div>\n\n      <div class=\"cx-checkout-body row\">\n        <div\n          class=\"cx-shipping-address-card col-md-12 col-lg-6\"\n          *ngFor=\"let card of cards; let i = index\"\n        >\n          <div\n            class=\"cx-shipping-address-card-inner\"\n            (click)=\"selectAddress(card.address)\"\n          >\n            <cx-card\n              [border]=\"true\"\n              [fitToContainer]=\"true\"\n              [content]=\"card.card\"\n              (sendCard)=\"selectAddress(card.address)\"\n            ></cx-card>\n          </div>\n        </div>\n      </div>\n\n      <div class=\"cx-checkout-btns row\">\n        <div class=\"col-md-12 col-lg-6\">\n          <button class=\"cx-btn btn btn-block btn-action\" (click)=\"back()\">\n            {{ backBtnText | cxTranslate }}\n          </button>\n        </div>\n        <div class=\"col-md-12 col-lg-6\">\n          <button\n            class=\"cx-btn btn btn-block btn-primary\"\n            [disabled]=\"!selectedAddress?.id\"\n            (click)=\"next()\"\n          >\n            {{ 'common.continue' | cxTranslate }}\n          </button>\n        </div>\n      </div>\n    </ng-container>\n\n    <ng-template #newAddressForm>\n      <cx-address-form\n        *ngIf=\"cards.length; else initialAddressForm\"\n        [showTitleCode]=\"true\"\n        (backToAddress)=\"hideNewAddressForm(false)\"\n        (submitAddress)=\"addAddress($event)\"\n      ></cx-address-form>\n      <ng-template #initialAddressForm>\n        <cx-address-form\n          [showTitleCode]=\"true\"\n          [setAsDefaultField]=\"!isGuestCheckout\"\n          [addressData]=\"selectedAddress\"\n          cancelBtnLabel=\"{{ backBtnText | cxTranslate }}\"\n          (backToAddress)=\"hideNewAddressForm(true)\"\n          (submitAddress)=\"addAddress($event)\"\n        ></cx-address-form>\n      </ng-template>\n    </ng-template>\n  </ng-container>\n\n  <ng-template #loading>\n    <div class=\"cx-spinner\">\n      <cx-spinner></cx-spinner>\n    </div>\n  </ng-template>\n</ng-container>\n", components: [{ type: i4.CardComponent, selector: "cx-card", inputs: ["border", "editMode", "isDefault", "content", "fitToContainer", "truncateText", "charactersLimit"], outputs: ["deleteCard", "setDefaultCard", "sendCard", "editCard", "cancelCard"] }, { type: i4.AddressFormComponent, selector: "cx-address-form", inputs: ["addressData", "actionBtnLabel", "cancelBtnLabel", "setAsDefaultField", "showTitleCode", "showCancelBtn"], outputs: ["submitAddress", "backToAddress"] }, { type: i4.SpinnerComponent, selector: "cx-spinner" }], directives: [{ type: i3$2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3$2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], pipes: { "async": i3$2.AsyncPipe, "cxTranslate": i1.TranslatePipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ShippingAddressComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-shipping-address',
                    templateUrl: './shipping-address.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: i1.UserAddressService }, { type: i1$1.CheckoutDeliveryFacade }, { type: i3.ActivatedRoute }, { type: i1.TranslationService }, { type: i1.ActiveCartService }, { type: CheckoutStepService }, { type: i1$1.PaymentTypeFacade }, { type: i1.UserCostCenterService }, { type: i1$1.CheckoutCostCenterFacade }]; } });

class ShippingAddressModule {
}
ShippingAddressModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ShippingAddressModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ShippingAddressModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ShippingAddressModule, declarations: [ShippingAddressComponent], imports: [CommonModule,
        RouterModule,
        AddressFormModule,
        CardModule,
        SpinnerModule,
        I18nModule], exports: [ShippingAddressComponent] });
ShippingAddressModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ShippingAddressModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                CheckoutShippingAddress: {
                    component: ShippingAddressComponent,
                    guards: [CheckoutAuthGuard, CartNotEmptyGuard, CartValidationGuard],
                },
            },
        }),
    ], imports: [[
            CommonModule,
            RouterModule,
            AddressFormModule,
            CardModule,
            SpinnerModule,
            I18nModule,
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ShippingAddressModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        RouterModule,
                        AddressFormModule,
                        CardModule,
                        SpinnerModule,
                        I18nModule,
                    ],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                CheckoutShippingAddress: {
                                    component: ShippingAddressComponent,
                                    guards: [CheckoutAuthGuard, CartNotEmptyGuard, CartValidationGuard],
                                },
                            },
                        }),
                    ],
                    declarations: [ShippingAddressComponent],
                    exports: [ShippingAddressComponent],
                }]
        }] });

class GuestRegisterFormComponent {
    constructor(userRegisterFacade, routingService, authService, fb) {
        this.userRegisterFacade = userRegisterFacade;
        this.routingService = routingService;
        this.authService = authService;
        this.fb = fb;
        this.guestRegisterForm = this.fb.group({
            password: [
                '',
                [Validators.required, CustomFormValidators.passwordValidator],
            ],
            passwordconf: ['', Validators.required],
        }, {
            validators: CustomFormValidators.passwordsMustMatch('password', 'passwordconf'),
        });
    }
    submit() {
        if (this.guestRegisterForm.valid) {
            this.userRegisterFacade.registerGuest(this.guid, this.guestRegisterForm.value.password);
            if (!this.subscription) {
                this.subscription = this.authService
                    .isUserLoggedIn()
                    .subscribe((isLoggedIn) => {
                    if (isLoggedIn) {
                        this.routingService.go({ cxRoute: 'home' });
                    }
                });
            }
        }
        else {
            this.guestRegisterForm.markAllAsTouched();
        }
    }
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
    }
}
GuestRegisterFormComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: GuestRegisterFormComponent, deps: [{ token: i1$2.UserRegisterFacade }, { token: i1.RoutingService }, { token: i1.AuthService }, { token: i3$1.FormBuilder }], target: i0.ɵɵFactoryTarget.Component });
GuestRegisterFormComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: GuestRegisterFormComponent, selector: "cx-guest-register-form", inputs: { guid: "guid", email: "email" }, ngImport: i0, template: "<div class=\"register-guest\">\n  <div class=\"col-md-6 col-lg-4\">\n    <h3>{{ 'checkoutOrderConfirmation.createAccount' | cxTranslate }}</h3>\n    <p>\n      {{\n        'checkoutOrderConfirmation.createAccountForNext'\n          | cxTranslate: { email: email }\n      }}\n    </p>\n\n    <form (ngSubmit)=\"submit()\" [formGroup]=\"guestRegisterForm\">\n      <div class=\"form-group\">\n        <label>\n          <span class=\"label-content\">{{\n            'register.password.label' | cxTranslate\n          }}</span>\n          <input\n            aria-required=\"true\"\n            class=\"form-control\"\n            type=\"password\"\n            name=\"password\"\n            placeholder=\"{{ 'register.password.placeholder' | cxTranslate }}\"\n            formControlName=\"password\"\n          />\n          <cx-form-errors\n            aria-live=\"assertive\"\n            aria-atomic=\"true\"\n            [control]=\"guestRegisterForm.get('password')\"\n          ></cx-form-errors>\n        </label>\n      </div>\n\n      <div class=\"form-group\">\n        <label>\n          <span class=\"label-content\">{{\n            'register.confirmPassword.label' | cxTranslate\n          }}</span>\n          <input\n            aria-required=\"true\"\n            class=\"form-control\"\n            type=\"password\"\n            name=\"passwordconf\"\n            placeholder=\"{{\n              'register.confirmPassword.placeholder' | cxTranslate\n            }}\"\n            formControlName=\"passwordconf\"\n          />\n          <cx-form-errors\n            aria-live=\"assertive\"\n            aria-atomic=\"true\"\n            [control]=\"guestRegisterForm.get('passwordconf')\"\n          ></cx-form-errors>\n        </label>\n      </div>\n\n      <button type=\"submit\" class=\"btn btn-block btn-primary\">\n        {{ 'common.submit' | cxTranslate }}\n      </button>\n    </form>\n  </div>\n</div>\n", components: [{ type: i4.FormErrorsComponent, selector: "cx-form-errors", inputs: ["prefix", "translationParams", "control"] }], directives: [{ type: i3$1.ɵNgNoValidate, selector: "form:not([ngNoForm]):not([ngNativeValidate])" }, { type: i3$1.NgControlStatusGroup, selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { type: i3$1.FormGroupDirective, selector: "[formGroup]", inputs: ["formGroup"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }, { type: i3$1.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { type: i3$1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i3$1.FormControlName, selector: "[formControlName]", inputs: ["disabled", "formControlName", "ngModel"], outputs: ["ngModelChange"] }], pipes: { "cxTranslate": i1.TranslatePipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: GuestRegisterFormComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-guest-register-form',
                    templateUrl: './guest-register-form.component.html',
                }]
        }], ctorParameters: function () { return [{ type: i1$2.UserRegisterFacade }, { type: i1.RoutingService }, { type: i1.AuthService }, { type: i3$1.FormBuilder }]; }, propDecorators: { guid: [{
                type: Input
            }], email: [{
                type: Input
            }] } });

class OrderConfirmationItemsComponent {
    constructor(checkoutService) {
        this.checkoutService = checkoutService;
        this.promotionLocation = PromotionLocation.Checkout;
    }
    ngOnInit() {
        this.order$ = this.checkoutService.getOrderDetails();
    }
    ngOnDestroy() {
        this.checkoutService.clearCheckoutData();
    }
}
OrderConfirmationItemsComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OrderConfirmationItemsComponent, deps: [{ token: i1$1.CheckoutFacade }], target: i0.ɵɵFactoryTarget.Component });
OrderConfirmationItemsComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: OrderConfirmationItemsComponent, selector: "cx-order-confirmation-items", ngImport: i0, template: "<div class=\"cx-order-items container\" *ngIf=\"order$ | async as order\">\n  <h4 class=\"cx-order-items-header\">\n    {{ 'checkoutOrderConfirmation.orderItems' | cxTranslate }}\n  </h4>\n\n  <cx-promotions\n    [promotions]=\"order.appliedOrderPromotions || []\"\n  ></cx-promotions>\n\n  <cx-cart-item-list\n    [items]=\"order.entries\"\n    [readonly]=\"true\"\n    [promotionLocation]=\"promotionLocation\"\n  ></cx-cart-item-list>\n</div>\n", components: [{ type: i4.PromotionsComponent, selector: "cx-promotions", inputs: ["promotions"] }, { type: i4.CartItemListComponent, selector: "cx-cart-item-list", inputs: ["readonly", "hasHeader", "options", "cartId", "items", "promotionLocation", "cartIsLoading"] }], directives: [{ type: i3$2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "async": i3$2.AsyncPipe, "cxTranslate": i1.TranslatePipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OrderConfirmationItemsComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-order-confirmation-items',
                    templateUrl: './order-confirmation-items.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: i1$1.CheckoutFacade }]; } });

class OrderConfirmationOverviewComponent {
    constructor(checkoutService) {
        this.checkoutService = checkoutService;
    }
    ngOnInit() {
        this.order$ = this.checkoutService.getOrderDetails();
    }
    ngOnDestroy() {
        this.checkoutService.clearCheckoutData();
    }
}
OrderConfirmationOverviewComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OrderConfirmationOverviewComponent, deps: [{ token: i1$1.CheckoutFacade }], target: i0.ɵɵFactoryTarget.Component });
OrderConfirmationOverviewComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: OrderConfirmationOverviewComponent, selector: "cx-order-confirmation-overview", ngImport: i0, template: "<ng-container *ngIf=\"order$ | async as order\">\n  <cx-order-overview [order]=\"order\"></cx-order-overview>\n</ng-container>\n", components: [{ type: i4.OrderOverviewComponent, selector: "cx-order-overview", inputs: ["order"] }], directives: [{ type: i3$2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "async": i3$2.AsyncPipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OrderConfirmationOverviewComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-order-confirmation-overview',
                    templateUrl: './order-confirmation-overview.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: i1$1.CheckoutFacade }]; } });

class OrderConfirmationThankYouMessageComponent {
    constructor(checkoutService) {
        this.checkoutService = checkoutService;
        this.isGuestCustomer = false;
    }
    ngOnInit() {
        this.order$ = this.checkoutService.getOrderDetails().pipe(tap((order) => {
            var _a;
            this.isGuestCustomer =
                'guestCustomer' in order ? (_a = order.guestCustomer) !== null && _a !== void 0 ? _a : false : false;
            this.orderGuid = order.guid;
        }));
        this.isReplenishmentOrderType$ = this.checkoutService
            .getCurrentOrderType()
            .pipe(map((orderType) => ORDER_TYPE.SCHEDULE_REPLENISHMENT_ORDER === orderType));
    }
    ngOnDestroy() {
        this.checkoutService.clearCheckoutData();
    }
}
OrderConfirmationThankYouMessageComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OrderConfirmationThankYouMessageComponent, deps: [{ token: i1$1.CheckoutFacade }], target: i0.ɵɵFactoryTarget.Component });
OrderConfirmationThankYouMessageComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: OrderConfirmationThankYouMessageComponent, selector: "cx-order-confirmation-thank-you-message", ngImport: i0, template: "<ng-container *ngIf=\"order$ | async as order\">\n  <div class=\"cx-page-header\">\n    <h1 class=\"cx-page-title\">\n      {{ 'checkoutOrderConfirmation.confirmationOfOrder' | cxTranslate }}\n      {{\n        (isReplenishmentOrderType$ | async)\n          ? order.replenishmentOrderCode\n          : order.code\n      }}\n    </h1>\n  </div>\n\n  <div class=\"cx-order-confirmation-message\">\n    <h2>{{ 'checkoutOrderConfirmation.thankYou' | cxTranslate }}</h2>\n    <p>\n      {{ 'checkoutOrderConfirmation.invoiceHasBeenSentByEmail' | cxTranslate }}\n    </p>\n  </div>\n\n  <div *ngIf=\"isGuestCustomer\">\n    <cx-guest-register-form\n      [guid]=\"orderGuid\"\n      [email]=\"order.paymentInfo.billingAddress.email\"\n    ></cx-guest-register-form>\n  </div>\n\n  <cx-add-to-home-screen-banner></cx-add-to-home-screen-banner>\n</ng-container>\n", components: [{ type: GuestRegisterFormComponent, selector: "cx-guest-register-form", inputs: ["guid", "email"] }, { type: i4.AddToHomeScreenBannerComponent, selector: "cx-add-to-home-screen-banner" }], directives: [{ type: i3$2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "async": i3$2.AsyncPipe, "cxTranslate": i1.TranslatePipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OrderConfirmationThankYouMessageComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-order-confirmation-thank-you-message',
                    templateUrl: './order-confirmation-thank-you-message.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: i1$1.CheckoutFacade }]; } });

class OrderConfirmationTotalsComponent {
    constructor(checkoutService) {
        this.checkoutService = checkoutService;
    }
    ngOnInit() {
        this.order$ = this.checkoutService.getOrderDetails();
    }
    ngOnDestroy() {
        this.checkoutService.clearCheckoutData();
    }
}
OrderConfirmationTotalsComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OrderConfirmationTotalsComponent, deps: [{ token: i1$1.CheckoutFacade }], target: i0.ɵɵFactoryTarget.Component });
OrderConfirmationTotalsComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: OrderConfirmationTotalsComponent, selector: "cx-order-confirmation-totals", ngImport: i0, template: "<div class=\"cx-order-summary container\" *ngIf=\"order$ | async as order\">\n  <div class=\"row justify-content-end\">\n    <div class=\"col-sm-12 col-md-6 col-lg-5 col-xl-4\">\n      <cx-order-summary [cart]=\"order\"></cx-order-summary>\n    </div>\n  </div>\n</div>\n", components: [{ type: i4.OrderSummaryComponent, selector: "cx-order-summary", inputs: ["cart"] }], directives: [{ type: i3$2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "async": i3$2.AsyncPipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OrderConfirmationTotalsComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-order-confirmation-totals',
                    templateUrl: './order-confirmation-totals.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: i1$1.CheckoutFacade }]; } });

class OrderConfirmationGuard {
    constructor(checkoutService, router, semanticPathService) {
        this.checkoutService = checkoutService;
        this.router = router;
        this.semanticPathService = semanticPathService;
    }
    canActivate() {
        return this.checkoutService.getOrderDetails().pipe(map((orderDetails) => {
            if (orderDetails && Object.keys(orderDetails).length !== 0) {
                return true;
            }
            else {
                return this.router.parseUrl(this.semanticPathService.get('orders'));
            }
        }));
    }
}
OrderConfirmationGuard.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OrderConfirmationGuard, deps: [{ token: i1$1.CheckoutFacade }, { token: i3.Router }, { token: i1.SemanticPathService }], target: i0.ɵɵFactoryTarget.Injectable });
OrderConfirmationGuard.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OrderConfirmationGuard, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OrderConfirmationGuard, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1$1.CheckoutFacade }, { type: i3.Router }, { type: i1.SemanticPathService }]; } });

const orderConfirmationComponents = [
    OrderConfirmationItemsComponent,
    OrderConfirmationOverviewComponent,
    OrderConfirmationThankYouMessageComponent,
    OrderConfirmationTotalsComponent,
    GuestRegisterFormComponent,
];
class OrderConfirmationModule {
}
OrderConfirmationModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OrderConfirmationModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
OrderConfirmationModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OrderConfirmationModule, declarations: [OrderConfirmationItemsComponent,
        OrderConfirmationOverviewComponent,
        OrderConfirmationThankYouMessageComponent,
        OrderConfirmationTotalsComponent,
        GuestRegisterFormComponent], imports: [CommonModule,
        CartSharedModule,
        CardModule,
        PwaModule,
        PromotionsModule,
        I18nModule,
        ReactiveFormsModule,
        FeaturesConfigModule,
        FormErrorsModule,
        OrderOverviewModule], exports: [OrderConfirmationItemsComponent,
        OrderConfirmationOverviewComponent,
        OrderConfirmationThankYouMessageComponent,
        OrderConfirmationTotalsComponent,
        GuestRegisterFormComponent] });
OrderConfirmationModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OrderConfirmationModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                OrderConfirmationThankMessageComponent: {
                    component: OrderConfirmationThankYouMessageComponent,
                    guards: [OrderConfirmationGuard],
                },
                OrderConfirmationItemsComponent: {
                    component: OrderConfirmationItemsComponent,
                    guards: [OrderConfirmationGuard],
                },
                OrderConfirmationTotalsComponent: {
                    component: OrderConfirmationTotalsComponent,
                    guards: [OrderConfirmationGuard],
                },
                OrderConfirmationOverviewComponent: {
                    component: OrderConfirmationOverviewComponent,
                    guards: [OrderConfirmationGuard],
                },
            },
        }),
    ], imports: [[
            CommonModule,
            CartSharedModule,
            CardModule,
            PwaModule,
            PromotionsModule,
            I18nModule,
            ReactiveFormsModule,
            FeaturesConfigModule,
            FormErrorsModule,
            OrderOverviewModule,
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OrderConfirmationModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        CartSharedModule,
                        CardModule,
                        PwaModule,
                        PromotionsModule,
                        I18nModule,
                        ReactiveFormsModule,
                        FeaturesConfigModule,
                        FormErrorsModule,
                        OrderOverviewModule,
                    ],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                OrderConfirmationThankMessageComponent: {
                                    component: OrderConfirmationThankYouMessageComponent,
                                    guards: [OrderConfirmationGuard],
                                },
                                OrderConfirmationItemsComponent: {
                                    component: OrderConfirmationItemsComponent,
                                    guards: [OrderConfirmationGuard],
                                },
                                OrderConfirmationTotalsComponent: {
                                    component: OrderConfirmationTotalsComponent,
                                    guards: [OrderConfirmationGuard],
                                },
                                OrderConfirmationOverviewComponent: {
                                    component: OrderConfirmationOverviewComponent,
                                    guards: [OrderConfirmationGuard],
                                },
                            },
                        }),
                    ],
                    declarations: [...orderConfirmationComponents],
                    exports: [...orderConfirmationComponents],
                }]
        }] });

class ReplenishmentOrderConfirmationModule {
}
ReplenishmentOrderConfirmationModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ReplenishmentOrderConfirmationModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ReplenishmentOrderConfirmationModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ReplenishmentOrderConfirmationModule, imports: [CommonModule,
        CartSharedModule,
        CardModule,
        PwaModule,
        PromotionsModule,
        I18nModule,
        ReactiveFormsModule,
        FeaturesConfigModule,
        FormErrorsModule] });
ReplenishmentOrderConfirmationModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ReplenishmentOrderConfirmationModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                ReplenishmentConfirmationMessageComponent: {
                    component: OrderConfirmationThankYouMessageComponent,
                    guards: [OrderConfirmationGuard],
                },
                ReplenishmentConfirmationOverviewComponent: {
                    component: OrderConfirmationOverviewComponent,
                    guards: [OrderConfirmationGuard],
                },
                ReplenishmentConfirmationItemsComponent: {
                    component: OrderConfirmationItemsComponent,
                    guards: [OrderConfirmationGuard],
                },
                ReplenishmentConfirmationTotalsComponent: {
                    component: OrderConfirmationTotalsComponent,
                    guards: [OrderConfirmationGuard],
                },
            },
        }),
    ], imports: [[
            CommonModule,
            CartSharedModule,
            CardModule,
            PwaModule,
            PromotionsModule,
            I18nModule,
            ReactiveFormsModule,
            FeaturesConfigModule,
            FormErrorsModule,
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ReplenishmentOrderConfirmationModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        CartSharedModule,
                        CardModule,
                        PwaModule,
                        PromotionsModule,
                        I18nModule,
                        ReactiveFormsModule,
                        FeaturesConfigModule,
                        FormErrorsModule,
                    ],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                ReplenishmentConfirmationMessageComponent: {
                                    component: OrderConfirmationThankYouMessageComponent,
                                    guards: [OrderConfirmationGuard],
                                },
                                ReplenishmentConfirmationOverviewComponent: {
                                    component: OrderConfirmationOverviewComponent,
                                    guards: [OrderConfirmationGuard],
                                },
                                ReplenishmentConfirmationItemsComponent: {
                                    component: OrderConfirmationItemsComponent,
                                    guards: [OrderConfirmationGuard],
                                },
                                ReplenishmentConfirmationTotalsComponent: {
                                    component: OrderConfirmationTotalsComponent,
                                    guards: [OrderConfirmationGuard],
                                },
                            },
                        }),
                    ],
                }]
        }] });

class CheckoutComponentsModule {
}
CheckoutComponentsModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutComponentsModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
CheckoutComponentsModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutComponentsModule, imports: [CommonModule,
        CheckoutOrchestratorModule,
        CheckoutOrderSummaryModule,
        CheckoutProgressModule,
        CheckoutProgressMobileTopModule,
        CheckoutProgressMobileBottomModule,
        PaymentTypeModule,
        DeliveryModeModule,
        PaymentMethodModule,
        PlaceOrderModule,
        ScheduleReplenishmentOrderModule,
        ReviewSubmitModule,
        ShippingAddressModule,
        CostCenterModule,
        OrderConfirmationModule,
        ReplenishmentOrderConfirmationModule,
        CheckoutLoginModule] });
CheckoutComponentsModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutComponentsModule, imports: [[
            CommonModule,
            CheckoutOrchestratorModule,
            CheckoutOrderSummaryModule,
            CheckoutProgressModule,
            CheckoutProgressMobileTopModule,
            CheckoutProgressMobileBottomModule,
            PaymentTypeModule,
            DeliveryModeModule,
            PaymentMethodModule,
            PlaceOrderModule,
            ScheduleReplenishmentOrderModule,
            ReviewSubmitModule,
            ShippingAddressModule,
            CostCenterModule,
            OrderConfirmationModule,
            ReplenishmentOrderConfirmationModule,
            CheckoutLoginModule,
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CheckoutComponentsModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        CheckoutOrchestratorModule,
                        CheckoutOrderSummaryModule,
                        CheckoutProgressModule,
                        CheckoutProgressMobileTopModule,
                        CheckoutProgressMobileBottomModule,
                        PaymentTypeModule,
                        DeliveryModeModule,
                        PaymentMethodModule,
                        PlaceOrderModule,
                        ScheduleReplenishmentOrderModule,
                        ReviewSubmitModule,
                        ShippingAddressModule,
                        CostCenterModule,
                        OrderConfirmationModule,
                        ReplenishmentOrderConfirmationModule,
                        CheckoutLoginModule,
                    ],
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { CartNotEmptyGuard, CheckoutAuthGuard, CheckoutComponentsModule, CheckoutConfigService, CheckoutDetailsService, CheckoutGuard, CheckoutLoginComponent, CheckoutLoginModule, CheckoutOrchestratorComponent, CheckoutOrchestratorModule, CheckoutOrderSummaryComponent, CheckoutOrderSummaryModule, CheckoutProgressComponent, CheckoutProgressMobileBottomComponent, CheckoutProgressMobileBottomModule, CheckoutProgressMobileTopComponent, CheckoutProgressMobileTopModule, CheckoutProgressModule, CheckoutReplenishmentFormService, CheckoutStepService, CheckoutStepsSetGuard, DeliveryModeComponent, DeliveryModeModule, ExpressCheckoutService, GuestRegisterFormComponent, NotCheckoutAuthGuard, OrderConfirmationGuard, OrderConfirmationItemsComponent, OrderConfirmationModule, OrderConfirmationOverviewComponent, OrderConfirmationThankYouMessageComponent, OrderConfirmationTotalsComponent, PaymentFormComponent, PaymentFormModule, PaymentMethodComponent, PaymentMethodModule, PaymentTypeComponent, PaymentTypeModule, PlaceOrderComponent, PlaceOrderModule, ReplenishmentOrderConfirmationModule, ReviewSubmitComponent, ReviewSubmitModule, ScheduleReplenishmentOrderComponent, ScheduleReplenishmentOrderModule, ShippingAddressComponent, ShippingAddressModule };
//# sourceMappingURL=spartacus-checkout-components.js.map
