(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/common'), require('@angular/core'), require('@spartacus/core'), require('@angular/router'), require('rxjs/operators'), require('rxjs'), require('@angular/platform-browser'), require('@angular/forms'), require('@ng-bootstrap/ng-bootstrap'), require('@ng-select/ng-select'), require('@ngrx/effects'), require('@ngrx/store'), require('@angular/service-worker'), require('ngx-infinite-scroll'), require('@angular/common/http'), require('@ngrx/router-store')) :
    typeof define === 'function' && define.amd ? define('@spartacus/storefront', ['exports', '@angular/common', '@angular/core', '@spartacus/core', '@angular/router', 'rxjs/operators', 'rxjs', '@angular/platform-browser', '@angular/forms', '@ng-bootstrap/ng-bootstrap', '@ng-select/ng-select', '@ngrx/effects', '@ngrx/store', '@angular/service-worker', 'ngx-infinite-scroll', '@angular/common/http', '@ngrx/router-store'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.spartacus = global.spartacus || {}, global.spartacus.storefront = {}), global.ng.common, global.ng.core, global.core, global.ng.router, global.rxjs.operators, global.rxjs, global.ng.platformBrowser, global.ng.forms, global.ngBootstrap, global.ngSelect, global.effects, global.store, global.ng.serviceWorker, global.ngxInfiniteScroll, global.ng.common.http, global.fromNgrxRouter));
}(this, (function (exports, i3, i0, i1, i1$1, operators, rxjs, i1$2, i3$1, i1$3, i1$4, effects, i1$5, i1$6, i6, http, routerStore) { 'use strict';

    function _interopNamespace(e) {
        if (e && e.__esModule) return e;
        var n = Object.create(null);
        if (e) {
            Object.keys(e).forEach(function (k) {
                if (k !== 'default') {
                    var d = Object.getOwnPropertyDescriptor(e, k);
                    Object.defineProperty(n, k, d.get ? d : {
                        enumerable: true,
                        get: function () {
                            return e[k];
                        }
                    });
                }
            });
        }
        n['default'] = e;
        return Object.freeze(n);
    }

    var i3__namespace = /*#__PURE__*/_interopNamespace(i3);
    var i0__namespace = /*#__PURE__*/_interopNamespace(i0);
    var i1__namespace = /*#__PURE__*/_interopNamespace(i1);
    var i1__namespace$1 = /*#__PURE__*/_interopNamespace(i1$1);
    var i1__namespace$2 = /*#__PURE__*/_interopNamespace(i1$2);
    var i3__namespace$1 = /*#__PURE__*/_interopNamespace(i3$1);
    var i1__namespace$3 = /*#__PURE__*/_interopNamespace(i1$3);
    var i1__namespace$4 = /*#__PURE__*/_interopNamespace(i1$4);
    var i1__namespace$5 = /*#__PURE__*/_interopNamespace(i1$5);
    var i1__namespace$6 = /*#__PURE__*/_interopNamespace(i1$6);
    var i6__namespace = /*#__PURE__*/_interopNamespace(i6);

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (Object.prototype.hasOwnProperty.call(b, p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
        var t = {};
        for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); };
    }
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
    }
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    var __createBinding = Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    });
    function __exportStar(m, o) {
        for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
                __createBinding(o, m, p);
    }
    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
            return m.call(o);
        if (o && typeof o.length === "number")
            return {
                next: function () {
                    if (o && i >= o.length)
                        o = void 0;
                    return { value: o && o[i++], done: !o };
                }
            };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    /** @deprecated */
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }
    /** @deprecated */
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    function __spreadArray(to, from, pack) {
        if (pack || arguments.length === 2)
            for (var i = 0, l = from.length, ar; i < l; i++) {
                if (ar || !(i in from)) {
                    if (!ar)
                        ar = Array.prototype.slice.call(from, 0, i);
                    ar[i] = from[i];
                }
            }
        return to.concat(ar || from);
    }
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n])
            i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try {
            step(g[n](v));
        }
        catch (e) {
            settle(q[0][3], e);
        } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]); }
    }
    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }
    function __asyncValues(o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    }
    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
        }
        else {
            cooked.raw = raw;
        }
        return cooked;
    }
    ;
    var __setModuleDefault = Object.create ? (function (o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function (o, v) {
        o["default"] = v;
    };
    function __importStar(mod) {
        if (mod && mod.__esModule)
            return mod;
        var result = {};
        if (mod != null)
            for (var k in mod)
                if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                    __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    }
    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }
    function __classPrivateFieldGet(receiver, state, kind, f) {
        if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    }
    function __classPrivateFieldSet(receiver, state, value, kind, f) {
        if (kind === "m")
            throw new TypeError("Private method is not writable");
        if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    }

    /** The element attribute used to store the focus state */
    var FOCUS_ATTR = 'data-cx-focus';
    /** The element attribute used to store the focus group state */
    var FOCUS_GROUP_ATTR = 'data-cx-focus-group';
    exports.TrapFocus = void 0;
    (function (TrapFocus) {
        /**
         * Will trap the focus at the start of the focus group.
         */
        TrapFocus["start"] = "start";
        /**
         * Will trap the focus only at the end of the focus group.
         */
        TrapFocus["end"] = "end";
        /**
         * Will not trap the focus in both directions. This is actually not are
         * a great example of focus trap, but it will give the benefit of keyboard
         * tabbing by arrows.
         */
        TrapFocus["both"] = "both";
    })(exports.TrapFocus || (exports.TrapFocus = {}));

    var BaseFocusService = /** @class */ (function () {
        function BaseFocusService() {
        }
        return BaseFocusService;
    }());
    BaseFocusService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: BaseFocusService, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    BaseFocusService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: BaseFocusService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: BaseFocusService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }] });

    /**
     * Abstract directive that provides a common interface for all focus directives:
     * - Block Focus
     * - Persist Focus
     * - Escape Focus
     * - Auto Focus
     * - Tab Focus
     * - Trap Focus
     * - Lock Focus
     */
    var BaseFocusDirective = /** @class */ (function () {
        function BaseFocusDirective(elementRef, service) {
            this.elementRef = elementRef;
            this.service = service;
            /**
             * A default config can be provided for each directive if a specific focus directive
             * is used directly. i.e. `<div cxAutoFocus></div>`
             */
            this.defaultConfig = {};
        }
        BaseFocusDirective.prototype.ngOnInit = function () {
            this.setDefaultConfiguration();
            this.requiredTabindex = -1;
        };
        // empty, but sub classes might have an implementation
        BaseFocusDirective.prototype.ngOnChanges = function (_changes) { };
        /**
         * Override the (input) config if it undefined or an empty string, with the
         * `defaultConfig`. The `defaultConfig` might be specified for each directive
         * differently. If a specific directive is used (i.e. `cxAutoFocus`), the
         * specific (inherited) defaultConfig will be used.
         */
        BaseFocusDirective.prototype.setDefaultConfiguration = function () {
            if ((!this.config || this.config === '') && this.defaultConfig) {
                this.config = this.defaultConfig;
            }
        };
        Object.defineProperty(BaseFocusDirective.prototype, "host", {
            /**
             * Helper method to return the host element for the directive
             * given by the `elementRef`.
             */
            get: function () {
                return this.elementRef.nativeElement;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(BaseFocusDirective.prototype, "requiredTabindex", {
            /**
             * Force a tabindex on the host element if it is _required_ to make the element
             * focusable. If the element is focusable by nature or by a given tabindex, the
             * `tabindex` is not applied.
             *
             * Buttons, active links, etc. do no need an explicit tabindex to receive focus.
             */
            set: function (tabindex) {
                if (this.requiresExplicitTabIndex) {
                    this.tabindex = tabindex;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(BaseFocusDirective.prototype, "requiresExplicitTabIndex", {
            /**
             * Returns true if the host element does not have a tabindex defined
             * and it also doesn't get focus by browsers nature (i.e. button or
             * active link).
             */
            get: function () {
                return (this.tabindex === undefined &&
                    ['button', 'input', 'select', 'textarea'].indexOf(this.host.tagName.toLowerCase()) === -1 &&
                    !(this.host.tagName === 'A' &&
                        (this.host.hasAttribute('href') ||
                            this.host.hasAttribute('routerlink') ||
                            this.host.getAttribute('ng-reflect-router-link'))));
            },
            enumerable: false,
            configurable: true
        });
        return BaseFocusDirective;
    }());
    BaseFocusDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: BaseFocusDirective, deps: [{ token: i0__namespace.ElementRef }, { token: BaseFocusService }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    BaseFocusDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.5", type: BaseFocusDirective, inputs: { tabindex: "tabindex" }, host: { properties: { "attr.tabindex": "this.tabindex" } }, usesOnChanges: true, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: BaseFocusDirective, decorators: [{
                type: i0.Directive
            }], ctorParameters: function () { return [{ type: i0__namespace.ElementRef }, { type: BaseFocusService }]; }, propDecorators: { tabindex: [{
                    type: i0.Input
                }, {
                    type: i0.HostBinding,
                    args: ['attr.tabindex']
                }] } });

    /**
     * Directive implementation that adds a CSS class to the host element
     * when the moused is used to focus an element. As soon as the keyboard
     * is used, the class is removed.
     *
     * This feature must be explicitly enabled with the `disableMouseFocus` config.
     *
     * The appearance of the visual focus depends on the CSS implementation to
     * begin with. Spartacus styles add a blue border around each focusable element.
     * This can be considered annoying by keyboard users, as they won't need such a
     * strong indication of the selected element.
     */
    var VisibleFocusDirective = /** @class */ (function (_super) {
        __extends(VisibleFocusDirective, _super);
        function VisibleFocusDirective() {
            var _this = _super.apply(this, __spreadArray([], __read(arguments))) || this;
            _this.defaultConfig = {
                disableMouseFocus: true,
            };
            /** Controls a css class to hide focus visible CSS rules */
            _this.mouseFocus = false;
            return _this;
        }
        VisibleFocusDirective.prototype.handleMousedown = function () {
            if (this.shouldFocusVisible) {
                this.mouseFocus = true;
            }
        };
        VisibleFocusDirective.prototype.handleKeydown = function (event) {
            if (this.shouldFocusVisible) {
                this.mouseFocus = !this.isNavigating(event);
            }
        };
        Object.defineProperty(VisibleFocusDirective.prototype, "shouldFocusVisible", {
            /**
             * Indicates whether the configurations setup to disable visual focus.
             */
            get: function () {
                var _a;
                return (_a = this.config) === null || _a === void 0 ? void 0 : _a.disableMouseFocus;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Indicates whether the event is used to navigate the storefront. Some keyboard events
         * are used by mouse users to fill a form or interact with the OS or browser.
         */
        VisibleFocusDirective.prototype.isNavigating = function (event) {
            // when the cmd or ctrl keys are used, the user doesn't navigate the storefront
            if (event.metaKey) {
                return false;
            }
            // when the tab key is used, users are for navigating away from the current (form) element
            if (event.code === 'Tab') {
                return true;
            }
            // If the user fill in a form, we don't considering it part of storefront navigation.
            if (['INPUT', 'TEXTAREA'].includes(event.target.tagName)) {
                return false;
            }
            return true;
        };
        return VisibleFocusDirective;
    }(BaseFocusDirective));
    VisibleFocusDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: VisibleFocusDirective, deps: null, target: i0__namespace.ɵɵFactoryTarget.Directive });
    VisibleFocusDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.5", type: VisibleFocusDirective, host: { listeners: { "mousedown": "handleMousedown()", "keydown": "handleKeydown($event)" }, properties: { "class.mouse-focus": "this.mouseFocus" } }, usesInheritance: true, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: VisibleFocusDirective, decorators: [{
                type: i0.Directive
            }], propDecorators: { mouseFocus: [{
                    type: i0.HostBinding,
                    args: ['class.mouse-focus']
                }], handleMousedown: [{
                    type: i0.HostListener,
                    args: ['mousedown']
                }], handleKeydown: [{
                    type: i0.HostListener,
                    args: ['keydown', ['$event']]
                }] } });

    // { selector: '[cxBlockFocus]' }
    var BlockFocusDirective = /** @class */ (function (_super) {
        __extends(BlockFocusDirective, _super);
        function BlockFocusDirective(elementRef, service) {
            var _this = _super.call(this, elementRef, service) || this;
            _this.elementRef = elementRef;
            _this.service = service;
            _this.defaultConfig = { block: true };
            // @Input('cxBlockFocus')
            _this.config = {};
            return _this;
        }
        BlockFocusDirective.prototype.ngOnInit = function () {
            _super.prototype.ngOnInit.call(this);
            if (this.config.block) {
                this.tabindex = -1;
            }
        };
        return BlockFocusDirective;
    }(VisibleFocusDirective));
    BlockFocusDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: BlockFocusDirective, deps: [{ token: i0__namespace.ElementRef }, { token: BaseFocusService }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    BlockFocusDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.5", type: BlockFocusDirective, usesInheritance: true, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: BlockFocusDirective, decorators: [{
                type: i0.Directive
            }], ctorParameters: function () { return [{ type: i0__namespace.ElementRef }, { type: BaseFocusService }]; } });

    var GLOBAL_GROUP = '_g_';
    /**
     * Shared service to persist the focus for an element or a group
     * of elements. The persisted element focus can be used to persist
     * the focus for a DOM tree, so that the focus remains after a repaint
     * or reoccurs when a DOM tree is "unlocked".
     */
    var PersistFocusService = /** @class */ (function (_super) {
        __extends(PersistFocusService, _super);
        function PersistFocusService() {
            var _this = _super.apply(this, __spreadArray([], __read(arguments))) || this;
            // this is going to fail as we have sub services. They will al have their own map.
            // We must bring this to a singleton map.
            _this.focus = new Map();
            return _this;
        }
        PersistFocusService.prototype.get = function (group) {
            return this.focus.get(group || GLOBAL_GROUP);
        };
        /**
         * Persist the keyboard focus state for the given key. The focus is stored globally
         * or for the given group.
         */
        PersistFocusService.prototype.set = function (key, group) {
            if (key) {
                this.focus.set(group || GLOBAL_GROUP, key);
            }
        };
        /**
         * Clears the persisted keyboard focus state globally or for the given group.
         */
        PersistFocusService.prototype.clear = function (group) {
            this.focus.delete(group || GLOBAL_GROUP);
        };
        /**
         * Returns the group for the host element based on the configured group or
         * by the `data-cx-focus-group` attribute stored on the host.
         */
        PersistFocusService.prototype.getPersistenceGroup = function (host, config) {
            return (config === null || config === void 0 ? void 0 : config.group) ? config.group : host.getAttribute(FOCUS_GROUP_ATTR);
        };
        return PersistFocusService;
    }(BaseFocusService));
    PersistFocusService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PersistFocusService, deps: null, target: i0__namespace.ɵɵFactoryTarget.Injectable });
    PersistFocusService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PersistFocusService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PersistFocusService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }] });

    /**
     * Directive that provides persistence of the focused state. This is useful
     * when a group of focusable elements got refocused or even recreated. That
     * happens often when the DOM is constructed with an `*ngIf` or `*ngFor`.
     *
     * The focus state is based on a configured _key_, which can be passed in the
     * config input, either by using a string primitive or `PersistFocusConfig.key`:
     *
     * ```html
     * <button cxPersistFocus="myKey"></button>
     * <button cxFocus="myKey"></button>
     * <button [cxFocus]="{{key:'myKey'}"></button>
     * ```
     *
     * The focus state can be part of a focus _group_, so that the state is shared
     * and remember for the given group. In order to detect the persistence for a
     * given element, we store the persistence key as a data attribute (`data-cx-focus`):
     *
     * ```html
     * <button data-cx-focus="myKey"></button>
     * ```
     *
     * Other keyboard focus directives can read the key to understand whether the element
     * should retrieve focus.
     *
     */
    var PersistFocusDirective = /** @class */ (function (_super) {
        __extends(PersistFocusDirective, _super);
        function PersistFocusDirective(elementRef, service) {
            var _this = _super.call(this, elementRef, service) || this;
            _this.elementRef = elementRef;
            _this.service = service;
            _this.defaultConfig = {};
            /**
             * The persistence key can be passed directly or through the `FocusConfig.key`.
             * While this could be considered a global key, the likeliness of conflicts
             * is very small since the key is cleared when the focus is changed.
             */
            // @Input('cxPersistFocus')
            _this.config = {};
            return _this;
        }
        PersistFocusDirective.prototype.handleFocus = function (event) {
            this.service.set(this.key, this.group);
            event === null || event === void 0 ? void 0 : event.preventDefault();
            event === null || event === void 0 ? void 0 : event.stopPropagation();
        };
        PersistFocusDirective.prototype.ngOnInit = function () {
            _super.prototype.ngOnInit.call(this);
            this.attr = this.key ? this.key : undefined;
        };
        PersistFocusDirective.prototype.setDefaultConfiguration = function () {
            if (typeof this.config === 'string' && this.config !== '') {
                this.config = { key: this.config };
            }
            _super.prototype.setDefaultConfiguration.call(this);
        };
        /**
         * Focus the element explicitly if it was focused before.
         */
        PersistFocusDirective.prototype.ngAfterViewInit = function () {
            if (this.isPersisted) {
                this.host.focus({ preventScroll: true });
            }
        };
        Object.defineProperty(PersistFocusDirective.prototype, "isPersisted", {
            get: function () {
                return !!this.key && this.service.get(this.group) === this.key;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(PersistFocusDirective.prototype, "key", {
            /**
             * Returns the key for the host element, which is used to persist the
             * focus state. This is useful in cases where the DOM is rebuild.
             */
            get: function () {
                var _a;
                return (_a = this.config) === null || _a === void 0 ? void 0 : _a.key;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(PersistFocusDirective.prototype, "group", {
            /**
             * returns the persistence group (if any) for the focusable elements.
             */
            get: function () {
                return this.service.getPersistenceGroup(this.host, this.config);
            },
            enumerable: false,
            configurable: true
        });
        return PersistFocusDirective;
    }(BlockFocusDirective));
    PersistFocusDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PersistFocusDirective, deps: [{ token: i0__namespace.ElementRef }, { token: PersistFocusService }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    PersistFocusDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.5", type: PersistFocusDirective, host: { listeners: { "focus": "handleFocus($event)" }, properties: { "attr.data-cx-focus": "this.attr" } }, usesInheritance: true, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PersistFocusDirective, decorators: [{
                type: i0.Directive
            }], ctorParameters: function () { return [{ type: i0__namespace.ElementRef }, { type: PersistFocusService }]; }, propDecorators: { attr: [{
                    type: i0.HostBinding,
                    args: ["attr." + FOCUS_ATTR]
                }], handleFocus: [{
                    type: i0.HostListener,
                    args: ['focus', ['$event']]
                }] } });

    var SelectFocusUtility = /** @class */ (function () {
        function SelectFocusUtility() {
            /**
             * Query selectors used to query focusable child elements of the host element.
             * The selectors are supplemented with `:not([disabled])` and `:not([hidden])`.
             */
            this.focusableSelectors = [
                'a[href]',
                'button',
                '[tabindex]',
                'input',
                'select',
                'textarea',
            ];
            // like to leave out the following as we don't use it, and make this list exensible.
            //   `[contentEditable=true]`, // very unlikely to suport as we're not a business tool
            //   `iframe`, // we really don't like iframes...
            //   `area[href]`, // very debatable!
            this.focusableSelectorSuffix = ':not([disabled]):not([hidden])';
        }
        SelectFocusUtility.prototype.query = function (host, selector) {
            if (!selector || selector === '') {
                return [];
            }
            return Array.from(host.querySelectorAll(selector));
        };
        SelectFocusUtility.prototype.findFirstFocusable = function (host, config) {
            var _this = this;
            if (config === void 0) { config = { autofocus: true }; }
            var selector = typeof (config === null || config === void 0 ? void 0 : config.autofocus) === 'string' ? config.autofocus : '[autofocus]';
            // fallback to first focusable
            return (this.query(host, selector).find(function (el) { return !_this.isHidden(el); }) ||
                this.findFocusable(host).find(function (el) { return Boolean(el); }));
        };
        /**
         * returns all focusable child elements of the host element. The element selectors
         * are build from the `focusableSelectors`.
         *
         * @param host the `HTMLElement` used to query focusable elements
         * @param locked indicates whether inactive (`tabindex="-1"`) focusable elements should be returned
         * @param invisible indicates whether hidden focusable elements should be returned
         */
        SelectFocusUtility.prototype.findFocusable = function (host, locked, invisible) {
            var _this = this;
            if (locked === void 0) { locked = false; }
            if (invisible === void 0) { invisible = false; }
            var suffix = this.focusableSelectorSuffix;
            if (!locked) {
                suffix += ":not([tabindex='-1'])";
            }
            var selector = this.focusableSelectors
                .map(function (s) { return (s += suffix); })
                .join(',');
            return this.query(host, selector).filter(function (el) { return !invisible ? !_this.isHidden(el) : Boolean(el); });
        };
        /**
         * Indicates whether the element is hidden by CSS. There are various CSS rules and
         * HTML structures which can lead to an hidden or invisible element. An `offsetParent`
         * of null indicates that the element or any of it's decendants is hidden (`display:none`).
         *
         * Oother techniques use the visibility (`visibility: hidden`), opacity (`opacity`) or
         * phyisical location on the element itself or any of it's anchestor elements. Those
         * technique require to work with the _computed styles_, which will cause a performance
         * downgrade. We don't do this in the standard implementaton.
         */
        SelectFocusUtility.prototype.isHidden = function (el) {
            return el.offsetParent === null;
        };
        return SelectFocusUtility;
    }());
    SelectFocusUtility.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SelectFocusUtility, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    SelectFocusUtility.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SelectFocusUtility, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SelectFocusUtility, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }] });

    var EscapeFocusService = /** @class */ (function (_super) {
        __extends(EscapeFocusService, _super);
        function EscapeFocusService(selectFocusUtil) {
            var _this = _super.call(this) || this;
            _this.selectFocusUtil = selectFocusUtil;
            return _this;
        }
        EscapeFocusService.prototype.shouldFocus = function (config) {
            return !!(config === null || config === void 0 ? void 0 : config.focusOnEscape);
        };
        EscapeFocusService.prototype.handleEscape = function (host, config, event) {
            var _a;
            if (this.shouldFocus(config)) {
                if (host !== event.target) {
                    host.focus({ preventScroll: true });
                    event.preventDefault();
                    event.stopPropagation();
                }
                else {
                    if (config === null || config === void 0 ? void 0 : config.focusOnDoubleEscape) {
                        (_a = this.selectFocusUtil
                            .findFirstFocusable(host, { autofocus: true })) === null || _a === void 0 ? void 0 : _a.focus();
                    }
                }
            }
        };
        return EscapeFocusService;
    }(PersistFocusService));
    EscapeFocusService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: EscapeFocusService, deps: [{ token: SelectFocusUtility }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    EscapeFocusService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: EscapeFocusService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: EscapeFocusService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: SelectFocusUtility }]; } });

    /**
     * Directive to focus the host element whenever the `escape` key is captured.
     * UiEvents bubble up by nature, which is why the `cxEscGroup` can be used
     * on a tree of elements. Each time the escape key is used, the focus will
     * move up in the DOM tree.
     *
     */
    var EscapeFocusDirective = /** @class */ (function (_super) {
        __extends(EscapeFocusDirective, _super);
        function EscapeFocusDirective(elementRef, service) {
            var _this = _super.call(this, elementRef, service) || this;
            _this.elementRef = elementRef;
            _this.service = service;
            _this.defaultConfig = { focusOnEscape: true };
            _this.esc = new i0.EventEmitter();
            return _this;
        }
        /**
         * Handles the escape key event.
         * @param event the native keyboard event which contains the escape keydown event
         */
        EscapeFocusDirective.prototype.handleEscape = function (event) {
            if (this.service.shouldFocus(this.config)) {
                this.service.handleEscape(this.host, this.config, event);
            }
            this.esc.emit(this.service.shouldFocus(this.config));
        };
        EscapeFocusDirective.prototype.ngOnInit = function () {
            if (this.service.shouldFocus(this.config)) {
                this.requiredTabindex = -1;
            }
            _super.prototype.ngOnInit.call(this);
        };
        return EscapeFocusDirective;
    }(PersistFocusDirective));
    EscapeFocusDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: EscapeFocusDirective, deps: [{ token: i0__namespace.ElementRef }, { token: EscapeFocusService }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    EscapeFocusDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.5", type: EscapeFocusDirective, outputs: { esc: "esc" }, host: { listeners: { "keydown.escape": "handleEscape($event)" } }, usesInheritance: true, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: EscapeFocusDirective, decorators: [{
                type: i0.Directive
            }], ctorParameters: function () { return [{ type: i0__namespace.ElementRef }, { type: EscapeFocusService }]; }, propDecorators: { esc: [{
                    type: i0.Output
                }], handleEscape: [{
                    type: i0.HostListener,
                    args: ['keydown.escape', ['$event']]
                }] } });

    var AutoFocusService = /** @class */ (function (_super) {
        __extends(AutoFocusService, _super);
        function AutoFocusService() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * Returns the first focusable child element of the host element.
         */
        AutoFocusService.prototype.findFirstFocusable = function (host, config) {
            if (config === void 0) { config = { autofocus: true }; }
            if ((config === null || config === void 0 ? void 0 : config.autofocus) === ':host') {
                return host;
            }
            else if (this.hasPersistedFocus(host, config)) {
                return this.getPersisted(host, this.getPersistenceGroup(host, config));
            }
            else {
                return this.selectFocusUtil.findFirstFocusable(host, config) || host;
            }
        };
        /**
         * Indicates whether any of the focusable child elements is focused.
         */
        AutoFocusService.prototype.hasPersistedFocus = function (host, config) {
            return !!this.getPersisted(host, this.getPersistenceGroup(host, config));
        };
        /**
         * Returns the element that has a persisted focus state.
         *
         * @param host the `HTMLElement` used to query for focusable children
         * @param group the optional group for the persistent state, to separate different focus
         *   groups and remain the persistence
         */
        AutoFocusService.prototype.getPersisted = function (host, group) {
            if (!this.get(group)) {
                return;
            }
            var focussed = Array.from(host.querySelectorAll("[" + FOCUS_ATTR + "='" + this.get(group) + "']"));
            return focussed.length > 0 ? focussed[0] : null;
        };
        return AutoFocusService;
    }(EscapeFocusService));
    AutoFocusService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AutoFocusService, deps: null, target: i0__namespace.ɵɵFactoryTarget.Injectable });
    AutoFocusService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AutoFocusService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AutoFocusService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }] });

    /**
     * Directive that focus the first nested _focusable_ element based on state and configuration:
     *
     * 1. focusable element that was left in a focused state (aka _persisted_ focus)
     * 2. focusable element selected by configured CSS selector (i.e. 'button[type=submit]')
     * 3. focusable element marked with the native HTML5 `autofocus` attribute
     * 4. first focusable element
     * 5. the host element, in case the configured CSS selector is `:host`.
     *
     * Example configurations:
     *
     * `<div cxAutoFocus>[...]</div>`
     *
     * `<div [cxAutoFocus]="{autofocus: false}">[...]</div>`
     *
     * `<div [cxAutoFocus]="{autofocus: 'button.active'}">[...]</div>`
     *
     * `<div [cxAutoFocus]="{autofocus: ':host'}">[...]</div>`
     *
     * When your element is added dynamically (ie. by using an *ngIf or after a DOM change), the
     * focus can be refreshed by using the refreshFocus configuration.
     */
    var AutoFocusDirective = /** @class */ (function (_super) {
        __extends(AutoFocusDirective, _super);
        function AutoFocusDirective(elementRef, service) {
            var _this = _super.call(this, elementRef, service) || this;
            _this.elementRef = elementRef;
            _this.service = service;
            /** The AutoFocusDirective will be using autofocus by default  */
            _this.defaultConfig = { autofocus: true };
            return _this;
        }
        /**
         * Focus the element explicitly if it was focussed before.
         */
        AutoFocusDirective.prototype.ngAfterViewInit = function () {
            if (this.shouldAutofocus) {
                this.handleFocus();
            }
            if (!this.shouldAutofocus || this.hasPersistedFocus) {
                _super.prototype.ngAfterViewInit.call(this);
            }
        };
        AutoFocusDirective.prototype.ngOnChanges = function (changes) {
            var _a;
            // responsible for refresh focus based on the configured refresh property name
            if (!!((_a = changes.config.currentValue) === null || _a === void 0 ? void 0 : _a.refreshFocus)) {
                // ensure the autofocus when it's to provided initially
                if (!this.config.autofocus) {
                    this.config.autofocus = true;
                }
                this.handleFocus();
            }
            _super.prototype.ngOnChanges.call(this, changes);
        };
        /**
         * Mimic the focus without setting the actual focus on the host. The first
         * focusable child element will be focussed.
         */
        AutoFocusDirective.prototype.handleFocus = function (event) {
            var _a;
            if (this.shouldAutofocus) {
                if (!(event === null || event === void 0 ? void 0 : event.target) || event.target === this.host) {
                    (_a = this.firstFocusable) === null || _a === void 0 ? void 0 : _a.focus();
                }
                else {
                    event.target.focus();
                }
            }
            _super.prototype.handleFocus.call(this, event);
        };
        Object.defineProperty(AutoFocusDirective.prototype, "hasPersistedFocus", {
            /**
             * Helper function to get the first focusable child element
             */
            get: function () {
                return this.service.hasPersistedFocus(this.host, this.config);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AutoFocusDirective.prototype, "shouldAutofocus", {
            /**
             * Helper function to indicate whether we should use autofocus for the
             * child elements.
             */
            get: function () {
                var _a;
                return !!((_a = this.config) === null || _a === void 0 ? void 0 : _a.autofocus);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AutoFocusDirective.prototype, "firstFocusable", {
            /**
             * Helper function to get the first focusable child element.
             *
             * We keep this private to not pollute the API.
             */
            get: function () {
                return this.service.findFirstFocusable(this.host, this.config);
            },
            enumerable: false,
            configurable: true
        });
        return AutoFocusDirective;
    }(EscapeFocusDirective));
    AutoFocusDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AutoFocusDirective, deps: [{ token: i0__namespace.ElementRef }, { token: AutoFocusService }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    AutoFocusDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.5", type: AutoFocusDirective, usesInheritance: true, usesOnChanges: true, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AutoFocusDirective, decorators: [{
                type: i0.Directive
            }], ctorParameters: function () { return [{ type: i0__namespace.ElementRef }, { type: AutoFocusService }]; } });

    var TabFocusService = /** @class */ (function (_super) {
        __extends(TabFocusService, _super);
        function TabFocusService() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * Moves to the next (or previous) tab.
         */
        TabFocusService.prototype.moveTab = function (host, config, increment, event) {
            if (config === null || config === void 0 ? void 0 : config.tab) {
                var next = config.tab === 'scroll'
                    ? this.findNextScrollable(host, config, increment)
                    : this.findNext(host, config, increment);
                next === null || next === void 0 ? void 0 : next.focus();
                event.preventDefault();
                event.stopPropagation();
            }
        };
        /**
         * builds out virtual slides out of the full scrollable area, to allow
         * for maximum flexibility for the underlying layout without using hardcoded
         * slide sizes.
         */
        TabFocusService.prototype.findNextScrollable = function (host, config, increment) {
            var _a;
            var active = this.getActiveChild(host, config);
            if (!active) {
                return;
            }
            // slide count
            var virtualSlideCount = Math.round(host.scrollWidth / host.clientWidth);
            // find current virtual slide
            var currentVirtualSlide = Math.round(active.offsetLeft / (host.scrollWidth / virtualSlideCount));
            var nextVirtualSlide = currentVirtualSlide + increment;
            if (increment === 1 /* NEXT */ &&
                nextVirtualSlide >= virtualSlideCount) {
                nextVirtualSlide = 0;
            }
            if (increment === -1 /* PREV */ && nextVirtualSlide < 0) {
                nextVirtualSlide = virtualSlideCount - 1;
            }
            var firstItemOnNextSlide = (_a = this.getChildren(host, config)) === null || _a === void 0 ? void 0 : _a.find(function (tab) { return tab.offsetLeft >=
                (host.scrollWidth / virtualSlideCount) * nextVirtualSlide; });
            return firstItemOnNextSlide;
        };
        TabFocusService.prototype.findNext = function (host, config, increment) {
            var _this = this;
            var childs = this.getChildren(host, config);
            var activeIndex = childs === null || childs === void 0 ? void 0 : childs.findIndex(function (c) { return c === _this.getActiveChild(host, config); });
            if (!activeIndex || activeIndex === -1) {
                activeIndex = 0;
            }
            activeIndex += increment;
            if (increment === 1 /* NEXT */ && activeIndex >= (childs === null || childs === void 0 ? void 0 : childs.length)) {
                activeIndex = childs.length - 1;
            }
            if (increment === -1 /* PREV */ && activeIndex < 0) {
                activeIndex = 0;
            }
            return childs ? childs[activeIndex] : undefined;
        };
        /**
         * Returns the active focusable child element. If there's no active
         * focusable child element, the first focusable child is returned.
         */
        TabFocusService.prototype.getActiveChild = function (host, config) {
            var _this = this;
            var persisted = this.getPersisted(host, config === null || config === void 0 ? void 0 : config.group);
            if (persisted) {
                return persisted;
            }
            var children = this.getChildren(host, config);
            var index = children.findIndex(function (tab) { return _this.isActive(tab); });
            if (!index || index === -1) {
                index = 0;
            }
            return children[index];
        };
        TabFocusService.prototype.getChildren = function (host, config) {
            if (typeof config.tab === 'string' && config.tab !== 'scroll') {
                return this.selectFocusUtil.query(host, config.tab);
            }
            else {
                return this.findFocusable(host, true);
            }
        };
        /**
         * Returns all focusable child elements of the host element.
         *
         * @param host The host element is used to query child focusable elements.
         * @param locked Indicates if locked elements (tabindex=-1) should be returned, defaults to false.
         * @param invisible Indicates if invisible child elements should be returned, defaults to false.
         */
        TabFocusService.prototype.findFocusable = function (host, locked, invisible) {
            if (locked === void 0) { locked = false; }
            if (invisible === void 0) { invisible = false; }
            return this.selectFocusUtil.findFocusable(host, locked, invisible);
        };
        TabFocusService.prototype.isActive = function (el) {
            var child = document.activeElement;
            var selector = child.tagName;
            return (el === child ||
                !!Array.from(el.querySelectorAll(selector)).find(function (e) { return e === child; }));
        };
        return TabFocusService;
    }(AutoFocusService));
    TabFocusService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: TabFocusService, deps: null, target: i0__namespace.ɵɵFactoryTarget.Injectable });
    TabFocusService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: TabFocusService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: TabFocusService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }] });

    /**
     * Directive to move the focus of ("locked") child elements. This is useful
     * for a nested list of tabs, carousel slides or any group of elements that
     * requires horizontal navigation.
     */
    var TabFocusDirective = /** @class */ (function (_super) {
        __extends(TabFocusDirective, _super);
        function TabFocusDirective(elementRef, service) {
            var _this = _super.call(this, elementRef, service) || this;
            _this.elementRef = elementRef;
            _this.service = service;
            /** `tab` defaults to true if the directive `cxTabFocus` is used. */
            _this.defaultConfig = { tab: true };
            // @Input('cxTabFocus')
            _this.config = {};
            return _this;
        }
        TabFocusDirective.prototype.handleNextTab = function (event) {
            var _a;
            if ((_a = this.config) === null || _a === void 0 ? void 0 : _a.tab) {
                this.service.moveTab(this.host, this.config, 1 /* NEXT */, event);
            }
        };
        TabFocusDirective.prototype.handlePreviousTab = function (event) {
            var _a;
            if ((_a = this.config) === null || _a === void 0 ? void 0 : _a.tab) {
                this.service.moveTab(this.host, this.config, -1 /* PREV */, event);
            }
        };
        return TabFocusDirective;
    }(AutoFocusDirective));
    TabFocusDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: TabFocusDirective, deps: [{ token: i0__namespace.ElementRef }, { token: TabFocusService }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    TabFocusDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.5", type: TabFocusDirective, host: { listeners: { "keydown.arrowRight": "handleNextTab($event)", "keydown.arrowLeft": "handlePreviousTab($event)" } }, usesInheritance: true, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: TabFocusDirective, decorators: [{
                type: i0.Directive
            }], ctorParameters: function () { return [{ type: i0__namespace.ElementRef }, { type: TabFocusService }]; }, propDecorators: { handleNextTab: [{
                    type: i0.HostListener,
                    args: ['keydown.arrowRight', ['$event']]
                }], handlePreviousTab: [{
                    type: i0.HostListener,
                    args: ['keydown.arrowLeft', ['$event']]
                }] } });

    var TrapFocusService = /** @class */ (function (_super) {
        __extends(TrapFocusService, _super);
        function TrapFocusService() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * Indicates whether any of the child elements of the host are focusable.
         *
         * @param host `HTMLElement` that is used to query the focusable elements.
         */
        TrapFocusService.prototype.hasFocusableChildren = function (host) {
            return this.findFocusable(host).length > 0;
        };
        /**
         * Focus the next or previous element of all available focusable elements.
         * The focus is _trapped_ in case there's no next or previous available element.
         * The focus will automatically move the start or end of the list.
         */
        TrapFocusService.prototype.moveFocus = function (host, config, increment, event) {
            var focusable = this.findFocusable(host);
            var index = focusable.findIndex(function (v) { return v === event.target; }) + increment;
            var shouldMoveFocus = (index >= 0 && index < focusable.length) ||
                (index < 0 && this.getTrapStart(config.trap)) ||
                (index >= focusable.length && this.getTrapEnd(config.trap));
            if (shouldMoveFocus) {
                if (index >= focusable.length) {
                    index = 0;
                }
                if (index < 0) {
                    index = focusable.length - 1;
                }
                event.preventDefault();
                event.stopPropagation();
                var el = focusable[index];
                el.focus();
            }
        };
        TrapFocusService.prototype.getTrapStart = function (trap) {
            return trap === true || trap === exports.TrapFocus.start;
        };
        TrapFocusService.prototype.getTrapEnd = function (trap) {
            return trap === true || trap === exports.TrapFocus.end;
        };
        return TrapFocusService;
    }(TabFocusService));
    TrapFocusService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: TrapFocusService, deps: null, target: i0__namespace.ɵɵFactoryTarget.Injectable });
    TrapFocusService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: TrapFocusService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: TrapFocusService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }] });

    /**
     * Directive that keeps the focus inside the focusable child elements,
     * also known as a _focus trap_.
     */
    var TrapFocusDirective = /** @class */ (function (_super) {
        __extends(TrapFocusDirective, _super);
        function TrapFocusDirective(elementRef, service) {
            var _this = _super.call(this, elementRef, service) || this;
            _this.elementRef = elementRef;
            _this.service = service;
            _this.defaultConfig = { trap: true };
            // @Input('cxTrapFocus')
            _this.config = {};
            _this.handleTrapDown = function (event) {
                if (!!_this.config.trap) {
                    _this.moveFocus(event, 1 /* NEXT */);
                }
            };
            _this.handleTrapUp = function (event) {
                if (!!_this.config.trap) {
                    _this.moveFocus(event, -1 /* PREV */);
                }
            };
            return _this;
        }
        /**
         * Moves the focus of the element reference up or down, depending on the increment.
         * The focus of the element is trapped to avoid it from going out of the group.
         *
         * @param event UIEvent that is used to get the target element. The event is blocked
         *   from standard execution and further bubbling.
         * @param increment indicates whether the next or previous is focussed.
         */
        TrapFocusDirective.prototype.moveFocus = function (event, increment) {
            if (this.service.hasFocusableChildren(this.host)) {
                this.service.moveFocus(this.host, this.config, increment, event);
            }
        };
        return TrapFocusDirective;
    }(TabFocusDirective));
    TrapFocusDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: TrapFocusDirective, deps: [{ token: i0__namespace.ElementRef }, { token: TrapFocusService }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    TrapFocusDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.5", type: TrapFocusDirective, host: { listeners: { "keydown.arrowdown": "handleTrapDown($event)", "keydown.tab": "handleTrapDown($event)", "keydown.arrowup": "handleTrapUp($event)", "keydown.shift.tab": "handleTrapUp($event)" } }, usesInheritance: true, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: TrapFocusDirective, decorators: [{
                type: i0.Directive
            }], ctorParameters: function () { return [{ type: i0__namespace.ElementRef }, { type: TrapFocusService }]; }, propDecorators: { handleTrapDown: [{
                    type: i0.HostListener,
                    args: ['keydown.arrowdown', ['$event']]
                }, {
                    type: i0.HostListener,
                    args: ['keydown.tab', ['$event']]
                }], handleTrapUp: [{
                    type: i0.HostListener,
                    args: ['keydown.arrowup', ['$event']]
                }, {
                    type: i0.HostListener,
                    args: ['keydown.shift.tab', ['$event']]
                }] } });

    var LockFocusService = /** @class */ (function (_super) {
        __extends(LockFocusService, _super);
        function LockFocusService() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return LockFocusService;
    }(TrapFocusService));
    LockFocusService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: LockFocusService, deps: null, target: i0__namespace.ɵɵFactoryTarget.Injectable });
    LockFocusService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: LockFocusService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: LockFocusService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }] });

    /**
     * Focusable elements exclude hidden elements by default, but this contradicts with
     * unlocking (hidden) elements.
     */
    var UNLOCK_HIDDEN_ELEMENTS = true;
    /**
     * Directive that adds persistence for focussed element in case
     * the elements are being rebuild. This happens often when change
     * detection kicks in because of new data set from the backend.
     */
    var LockFocusDirective = /** @class */ (function (_super) {
        __extends(LockFocusDirective, _super);
        function LockFocusDirective(elementRef, service, renderer) {
            var _this = _super.call(this, elementRef, service) || this;
            _this.elementRef = elementRef;
            _this.service = service;
            _this.renderer = renderer;
            _this.defaultConfig = { lock: true };
            // @Input('cxLockFocus')
            _this.config = {};
            /**
             * Emits an event when the host is unlocked.
             */
            _this.unlock = new i0.EventEmitter();
            return _this;
        }
        /**
         * When the user selects enter or space, the focusable childs are
         * unlocked, which means that the tabindex is set to 0.
         */
        LockFocusDirective.prototype.handleEnter = function (event) {
            if (this.shouldLock && this.host === event.target) {
                this.unlockFocus(event);
                event.preventDefault();
                event.stopPropagation();
            }
        };
        /**
         * In case any of the children elements is touched by the mouse,
         * we unlock the group to not break the mouse-experience.
         */
        LockFocusDirective.prototype.handleClick = function (event) {
            if (this.shouldLock && this.isLocked) {
                this.unlockFocus(event);
                event.stopPropagation();
            }
        };
        LockFocusDirective.prototype.lockFocus = function () {
            this.addTabindexToChildren(-1);
        };
        LockFocusDirective.prototype.unlockFocus = function (event) {
            var _this = this;
            this.unlock.emit(true);
            this.addTabindexToChildren(0);
            // we focus the host if the event was triggered from a child
            if ((event === null || event === void 0 ? void 0 : event.target) === this.host) {
                // we wait a few milliseconds, mainly because firefox will otherwise apply
                // the mouse event on the new focused child element
                setTimeout(function () {
                    _super.prototype.handleFocus.call(_this, event);
                }, 100);
            }
        };
        LockFocusDirective.prototype.ngOnInit = function () {
            var _a, _b;
            _super.prototype.ngOnInit.call(this);
            this.shouldLock = (_a = this.config) === null || _a === void 0 ? void 0 : _a.lock;
            if (this.shouldLock) {
                this.tabindex = 0;
                // Locked elements will be set to `autofocus` by default if it's not
                // been configured. This will ensure that autofocus kicks in upon unlock.
                if (!this.config.hasOwnProperty('autofocus')) {
                    this.config.autofocus = true;
                }
                // Locked elements will be set to `focusOnEscape` by default if it's not
                // been configured. This will ensure that  the host gets locked again when
                // `escape` is pressed.
                if (!this.config.hasOwnProperty('focusOnEscape')) {
                    this.config.focusOnEscape = !(((_b = this.config) === null || _b === void 0 ? void 0 : _b.focusOnEscape) === false);
                }
            }
        };
        LockFocusDirective.prototype.ngAfterViewInit = function () {
            var _this = this;
            if (this.shouldLock) {
                /**
                 * If the component hosts a group of focusable children elements,
                 * we persist the group key to the children, so that they can taken this
                 * into account when they persist their focus state.
                 */
                if (!!this.group) {
                    this.service.findFocusable(this.host).forEach(function (el) {
                        // we must do this in after view init as
                        return _this.renderer.setAttribute(el, FOCUS_GROUP_ATTR, _this.group);
                    });
                }
                if (this.shouldAutofocus) {
                    this.handleFocus();
                }
            }
            _super.prototype.ngAfterViewInit.call(this);
        };
        LockFocusDirective.prototype.handleFocus = function (event) {
            var _this = this;
            if (this.shouldLock) {
                if (this.shouldUnlockAfterAutofocus(event)) {
                    // Delay unlocking in case the host is using `ChangeDetectionStrategy.Default`
                    setTimeout(function () { return _this.unlockFocus(event); });
                }
                else {
                    setTimeout(function () { return _this.lockFocus(); });
                    event === null || event === void 0 ? void 0 : event.stopPropagation();
                    return;
                }
            }
            _super.prototype.handleFocus.call(this, event);
        };
        LockFocusDirective.prototype.handleEscape = function (event) {
            if (this.shouldLock) {
                this.service.clear(this.config.group);
            }
            _super.prototype.handleEscape.call(this, event);
        };
        /**
         * When the handleFocus is called without an actual event, it's coming from Autofocus.
         * In this case we unlock the focusable children in case there's a focusable child that
         * was unlocked before.
         *
         * We keep this private to not polute the API.
         */
        LockFocusDirective.prototype.shouldUnlockAfterAutofocus = function (event) {
            return !event && this.service.hasPersistedFocus(this.host, this.config);
        };
        /**
         * Add the tabindex attribute to the focusable children elements
         */
        LockFocusDirective.prototype.addTabindexToChildren = function (i) {
            var _this = this;
            if (i === void 0) { i = 0; }
            if (this.shouldLock) {
                this.isLocked = i === -1;
                if (!(this.hasFocusableChildren && i === 0) || i === 0) {
                    this.focusable.forEach(function (el) { return _this.renderer.setAttribute(el, 'tabindex', i.toString()); });
                }
            }
        };
        Object.defineProperty(LockFocusDirective.prototype, "hasFocusableChildren", {
            /**
             * Utility method, returns all focusable children for the host element.
             *
             * We keep this private to not polute the API.
             */
            get: function () {
                return this.service.hasFocusableChildren(this.host);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(LockFocusDirective.prototype, "focusable", {
            /**
             * Returns the focusable children of the host element. If the host element
             * is configured to be locked, the query is restricted to child elements
             * with a tabindex !== `-1`.
             *
             * We keep this private to not polute the API.
             */
            get: function () {
                return this.service.findFocusable(this.host, this.shouldLock, UNLOCK_HIDDEN_ELEMENTS);
            },
            enumerable: false,
            configurable: true
        });
        return LockFocusDirective;
    }(TrapFocusDirective));
    LockFocusDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: LockFocusDirective, deps: [{ token: i0__namespace.ElementRef }, { token: LockFocusService }, { token: i0__namespace.Renderer2 }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    LockFocusDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.5", type: LockFocusDirective, outputs: { unlock: "unlock" }, host: { listeners: { "keydown.enter": "handleEnter($event)", "keydown.space": "handleEnter($event)", "click": "handleClick($event)" }, properties: { "class.focus-lock": "this.shouldLock", "class.is-locked": "this.isLocked" } }, usesInheritance: true, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: LockFocusDirective, decorators: [{
                type: i0.Directive
            }], ctorParameters: function () { return [{ type: i0__namespace.ElementRef }, { type: LockFocusService }, { type: i0__namespace.Renderer2 }]; }, propDecorators: { shouldLock: [{
                    type: i0.HostBinding,
                    args: ['class.focus-lock']
                }], isLocked: [{
                    type: i0.HostBinding,
                    args: ['class.is-locked']
                }], unlock: [{
                    type: i0.Output
                }], handleEnter: [{
                    type: i0.HostListener,
                    args: ['keydown.enter', ['$event']]
                }, {
                    type: i0.HostListener,
                    args: ['keydown.space', ['$event']]
                }], handleClick: [{
                    type: i0.HostListener,
                    args: ['click', ['$event']]
                }] } });

    var KeyboardFocusService = /** @class */ (function (_super) {
        __extends(KeyboardFocusService, _super);
        function KeyboardFocusService() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return KeyboardFocusService;
    }(LockFocusService));
    KeyboardFocusService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: KeyboardFocusService, deps: null, target: i0__namespace.ɵɵFactoryTarget.Injectable });
    KeyboardFocusService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: KeyboardFocusService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: KeyboardFocusService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }] });

    var FocusDirective = /** @class */ (function (_super) {
        __extends(FocusDirective, _super);
        function FocusDirective(elementRef, service, renderer) {
            var _this = _super.call(this, elementRef, service, renderer) || this;
            _this.elementRef = elementRef;
            _this.service = service;
            _this.renderer = renderer;
            _this.defaultConfig = {};
            _this.config = {};
            return _this;
        }
        return FocusDirective;
    }(LockFocusDirective));
    FocusDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: FocusDirective, deps: [{ token: i0__namespace.ElementRef }, { token: KeyboardFocusService }, { token: i0__namespace.Renderer2 }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    FocusDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.5", type: FocusDirective, selector: "[cxFocus]", inputs: { config: ["cxFocus", "config"] }, usesInheritance: true, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: FocusDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        selector: '[cxFocus]',
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ElementRef }, { type: KeyboardFocusService }, { type: i0__namespace.Renderer2 }]; }, propDecorators: { config: [{
                    type: i0.Input,
                    args: ['cxFocus']
                }] } });

    /**
     * @deprecated since 4.2, refer to spartacus issues (#13762)
     */
    var defaultKeyboardFocusConfig = {
        keyboardFocus: {
            enableResetFocusOnNavigate: false,
            enableResetViewOnNavigate: false,
        },
    };

    /**
     * @deprecated since 4.2, refer to spartacus issues (#13762)
     */
    var KeyboardFocusConfig = /** @class */ (function () {
        function KeyboardFocusConfig() {
        }
        return KeyboardFocusConfig;
    }());
    KeyboardFocusConfig.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: KeyboardFocusConfig, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    KeyboardFocusConfig.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: KeyboardFocusConfig, providedIn: 'root', useExisting: i1.Config });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: KeyboardFocusConfig, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                        useExisting: i1.Config,
                    }]
            }] });

    /**
     * The `BREAKPOINT` typing defaults to five default screen names:
     * xs, sm, md, lg, xl.
     *
     * The type can be extended to allow for custom screens, such as XLL or `tablet`.
     *
     * While the screen names are fully configurable, other features might have
     * pre-configured layout settings per screen. Page layouts or table configurations,
     * for example, are driven by screen size. In case you change the screen size or
     * introduce new screen names, you might loose out on these configurations.
     */
    exports.BREAKPOINT = void 0;
    (function (BREAKPOINT) {
        BREAKPOINT["xs"] = "xs";
        BREAKPOINT["sm"] = "sm";
        BREAKPOINT["md"] = "md";
        BREAKPOINT["lg"] = "lg";
        BREAKPOINT["xl"] = "xl";
    })(exports.BREAKPOINT || (exports.BREAKPOINT = {}));
    /**
     * The LayoutConfig supports the configuration of page slots by page templates
     * or page sections, such as headers and footers. The configuration also supports
     * adaptive design per breakpoint (not per device type), so that the DOM is (re)rendered
     * por a given breakpoint.
     */
    var LayoutConfig = /** @class */ (function () {
        function LayoutConfig() {
        }
        return LayoutConfig;
    }());
    LayoutConfig.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: LayoutConfig, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    LayoutConfig.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: LayoutConfig, providedIn: 'root', useExisting: i1.Config });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: LayoutConfig, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                        useExisting: i1.Config,
                    }]
            }] });

    /**
     * The `BreakpointService` resolves the various screen sizes that are used in
     * the storefront. The screen sizes are globally configurable based on your
     * layout requirements. You can adjust the screen sizes by setting the minimum
     * and/or maximum size for a breakpoint, as well as extending the configuration
     * with new screens.
     *
     * By default, the `BreakpointService` is based on the breakpoints from the
     * Bootstrap ui library:
     * - `xs`: < 576px
     * - `sm`: 576px - 767px
     * - `md`: 768px - 991px
     * - `lg`: 992px - 1199px
     * - `xl`: >= 1200px
     */
    var BreakpointService = /** @class */ (function () {
        function BreakpointService(winRef, layoutConfig, platform) {
            var _this = this;
            this.winRef = winRef;
            this.layoutConfig = layoutConfig;
            this.platform = platform;
            this.breakpoint$ = i3.isPlatformBrowser(this.platform)
                ? this.winRef.resize$.pipe(operators.map(function (event) { return _this.getBreakpoint(event.target.innerWidth); }), operators.distinctUntilChanged())
                : rxjs.of(this.fallbackBreakpoint);
        }
        Object.defineProperty(BreakpointService.prototype, "breakpoints", {
            /**
             * Returns the breakpoints for the storefront layout.
             *
             * The breakpoints are driven by the `LayoutConfig.breakpoints` and sorted based on
             * the given screen size.
             */
            get: function () {
                if (!this._breakpoints) {
                    this._breakpoints = this.resolveBreakpointsFromConfig();
                }
                return this._breakpoints;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Returns the _maximum_ size for the breakpoint, given by the `LayoutConfig.breakpoints`
         * configuration.
         */
        BreakpointService.prototype.getSize = function (breakpoint) {
            var _a, _b;
            return ((_a = this.getMaxSize(breakpoint)) !== null && _a !== void 0 ? _a :
                // if there's no direct max value or explicit max value
                // we must derive the max value from the previous min
                this.getMinSize((_b = this.breakpoints) === null || _b === void 0 ? void 0 : _b[this.breakpoints.indexOf(breakpoint) + 1]));
        };
        /**
         * Indicates whether the current screen size is smaller than the maximum size of the
         * given breakpoint.
         *
         * If the given breakpoint is `BREAKPOINT.md`, the method returns `true` when the
         * window innerWidth is smaller than the configured size of `BREAKPOINT.md`.
         */
        BreakpointService.prototype.isDown = function (breakpoint) {
            var _this = this;
            return this.breakpoint$.pipe(operators.map(function (br) { return _this.breakpoints
                .slice(0, _this.breakpoints.indexOf(breakpoint) + 1)
                .includes(br); }));
        };
        /**
         * Indicates whether the current screen size is larger than the minimum size of the
         * given breakpoint.
         *
         * If the given breakpoint is `BREAKPOINT.md`, the method returns `true` when the
         * window innerWidth is larger than the configured size of `BREAKPOINT.sm`.
         */
        BreakpointService.prototype.isUp = function (breakpoint) {
            var _this = this;
            return this.breakpoint$.pipe(operators.map(function (br) { return _this.breakpoints
                .slice(_this.breakpoints.indexOf(breakpoint))
                .includes(br); }));
        };
        /**
         * Indicates whether the given breakpoint fits in the current screen size.
         */
        BreakpointService.prototype.isEqual = function (breakpoint) {
            return this.breakpoint$.pipe(operators.map(function (br) { return br === breakpoint; }));
        };
        Object.defineProperty(BreakpointService.prototype, "fallbackBreakpoint", {
            /**
             * Returns the fallback breakpoint in case no breakpoint can be resolved. This is
             * typically the case when we're on SSR without an actual window.
             *
             * Returns the smallest screen size (mobile first).
             */
            get: function () {
                var _a;
                return (_a = this.breakpoints) === null || _a === void 0 ? void 0 : _a[0];
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Resolves the breakpoints and sorts them according to the configured size.
         *
         * The sort order is by small to large screens.
         */
        BreakpointService.prototype.resolveBreakpointsFromConfig = function () {
            var _this = this;
            var sortByScreenSize = function (next, prev) {
                var maxNext = Math.max(_this.getMinSize(next) + 1 || 0, _this.getMaxSize(next) || 0);
                var maxPrev = Math.max(_this.getMinSize(prev) + 1 || 0, _this.getMaxSize(prev) || 0);
                return maxNext < maxPrev ? -1 : 0;
            };
            return Object.keys(this.config).sort(sortByScreenSize);
        };
        /**
         * Returns the _maximum_ size for the breakpoint, given by the
         * `LayoutConfig.breakpoints` configuration. We will try to resolve the
         * max size form the current breakpoint, but if this is not available, we
         * resolve it form the next breakpoint
         */
        BreakpointService.prototype.getMaxSize = function (breakpoint) {
            var breakpointConfig = this.config[breakpoint];
            if (!breakpointConfig) {
                return null;
            }
            // we treat numbers as the max number by default
            if (typeof breakpointConfig === 'number') {
                return breakpointConfig;
            }
            else if (breakpointConfig.max) {
                return breakpointConfig.max;
            }
            else {
                return null;
            }
        };
        BreakpointService.prototype.getMinSize = function (breakpoint) {
            var _a;
            return (_a = this.config[breakpoint]) === null || _a === void 0 ? void 0 : _a.min;
        };
        /**
         * Returns a `BREAKPOINT` for the given window size.
         *
         * This method tries to match the closest breakpoint for the given
         * window size. We'll fallback to the `largest` size in case the window
         * is greater than the largest configurable breakpoint.
         *
         * The windowWidth should be smaller than the maximum size of any of the
         * screen sizes defined in the `LayoutConfig.breakpoints`.
         */
        BreakpointService.prototype.getBreakpoint = function (windowWidth) {
            var _this = this;
            var _a, _b;
            return ((_a = this.breakpoints.find(function (br) { return windowWidth < _this.getSize(br); })) !== null && _a !== void 0 ? _a : (_b = this.breakpoints) === null || _b === void 0 ? void 0 : _b[this.breakpoints.length - 1]);
        };
        Object.defineProperty(BreakpointService.prototype, "config", {
            /**
             * Helper method to return the breakpoint configuration.
             */
            get: function () {
                var _a;
                return ((_a = this.layoutConfig) === null || _a === void 0 ? void 0 : _a.breakpoints) || {};
            },
            enumerable: false,
            configurable: true
        });
        return BreakpointService;
    }());
    BreakpointService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: BreakpointService, deps: [{ token: i1__namespace.WindowRef }, { token: LayoutConfig }, { token: i0.PLATFORM_ID }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    BreakpointService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: BreakpointService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: BreakpointService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () {
            return [{ type: i1__namespace.WindowRef }, { type: LayoutConfig }, { type: undefined, decorators: [{
                            type: i0.Inject,
                            args: [i0.PLATFORM_ID]
                        }] }];
        } });

    /**
     * @deprecated since 4.2, refer to spartacus issues (#13762)
     * Shared service for keyboard focus features called when the browser navigates.
     */
    var OnNavigateFocusService = /** @class */ (function () {
        function OnNavigateFocusService(config, router, breakpointService, winRef) {
            this.config = config;
            this.router = router;
            this.breakpointService = breakpointService;
            this.winRef = winRef;
        }
        OnNavigateFocusService.prototype.ngOnDestroy = function () {
            var _a, _b;
            (_a = this.resetFocusOnNavigate) === null || _a === void 0 ? void 0 : _a.unsubscribe();
            (_b = this.resetViewOnNavigate) === null || _b === void 0 ? void 0 : _b.unsubscribe();
        };
        /**
         * Reads configuration and enables features based on flags set.
         */
        OnNavigateFocusService.prototype.initializeWithConfig = function () {
            var _a, _b, _c, _d;
            if (!this.winRef.isBrowser()) {
                return;
            }
            if ((_b = (_a = this.config) === null || _a === void 0 ? void 0 : _a.keyboardFocus) === null || _b === void 0 ? void 0 : _b.enableResetFocusOnNavigate) {
                this.setResetFocusOnNavigate(this.config.keyboardFocus.enableResetFocusOnNavigate);
            }
            if ((_d = (_c = this.config) === null || _c === void 0 ? void 0 : _c.keyboardFocus) === null || _d === void 0 ? void 0 : _d.enableResetViewOnNavigate) {
                this.setResetViewOnNavigate(this.config.keyboardFocus.enableResetViewOnNavigate);
            }
        };
        /**
         * Resets focus back to body element in the DOM tree when a navigation is started.
         * @param enable Enable or disable this feature. Set this to an array of BREAKPOINTS to enable for specified screen widths.
         */
        OnNavigateFocusService.prototype.setResetFocusOnNavigate = function (enable) {
            var _this = this;
            var _a;
            (_a = this.resetFocusOnNavigate) === null || _a === void 0 ? void 0 : _a.unsubscribe();
            if (enable) {
                this.resetFocusOnNavigate = this.router.events
                    .pipe(operators.filter(function (event) { return event instanceof i1$1.NavigationStart; }))
                    .subscribe(function () {
                    if (Array.isArray(enable)) {
                        _this.breakpointService.breakpoint$
                            .pipe(operators.take(1))
                            .subscribe(function (breakpoint) {
                            if (enable.includes(breakpoint)) {
                                _this.winRef.document.body.focus();
                            }
                        });
                    }
                    else if (typeof enable === 'boolean') {
                        _this.winRef.document.body.focus();
                    }
                });
            }
        };
        /**
         * Resets view back to body element in the DOM tree when a navigation is started.
         * @param enable Enable or disable this feature. Set this to an array of BREAKPOINTS to enable for specified screen widths.
         */
        OnNavigateFocusService.prototype.setResetViewOnNavigate = function (enable) {
            var _this = this;
            var _a;
            (_a = this.resetViewOnNavigate) === null || _a === void 0 ? void 0 : _a.unsubscribe();
            if (enable) {
                this.resetViewOnNavigate = this.router.events
                    .pipe(operators.filter(function (event) { return event instanceof i1$1.NavigationStart; }))
                    .subscribe(function () {
                    if (Array.isArray(enable)) {
                        _this.breakpointService.breakpoint$
                            .pipe(operators.take(1))
                            .subscribe(function (breakpoint) {
                            if (enable.includes(breakpoint)) {
                                _this.winRef.document.body.scrollIntoView();
                            }
                        });
                    }
                    else if (typeof enable === 'boolean') {
                        _this.winRef.document.body.scrollIntoView();
                    }
                });
            }
        };
        return OnNavigateFocusService;
    }());
    OnNavigateFocusService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OnNavigateFocusService, deps: [{ token: KeyboardFocusConfig }, { token: i1__namespace$1.Router }, { token: BreakpointService }, { token: i1__namespace.WindowRef }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    OnNavigateFocusService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OnNavigateFocusService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OnNavigateFocusService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: KeyboardFocusConfig }, { type: i1__namespace$1.Router }, { type: BreakpointService }, { type: i1__namespace.WindowRef }]; } });

    var directives = [
        // PersistFocusDirective,
        // VisibleFocusDirective,
        // BlockFocusDirective,
        // AutoFocusDirective,
        // EscapeFocusDirective,
        // LockFocusDirective,
        // TrapFocusDirective,
        // TabFocusDirective,
        FocusDirective,
    ];
    /**
     * @deprecated since 4.2, refer to spartacus issues (#13762)
     * Remove the router module as well as it was part of the old initiative for scroll positiioning
     */
    var KeyboardFocusModule = /** @class */ (function () {
        function KeyboardFocusModule() {
        }
        return KeyboardFocusModule;
    }());
    KeyboardFocusModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: KeyboardFocusModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    KeyboardFocusModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: KeyboardFocusModule, declarations: [
            // PersistFocusDirective,
            // VisibleFocusDirective,
            // BlockFocusDirective,
            // AutoFocusDirective,
            // EscapeFocusDirective,
            // LockFocusDirective,
            // TrapFocusDirective,
            // TabFocusDirective,
            FocusDirective
        ], imports: [i3.CommonModule, i1__namespace.ConfigModule, i1$1.RouterModule], exports: [
            // PersistFocusDirective,
            // VisibleFocusDirective,
            // BlockFocusDirective,
            // AutoFocusDirective,
            // EscapeFocusDirective,
            // LockFocusDirective,
            // TrapFocusDirective,
            // TabFocusDirective,
            FocusDirective
        ] });
    KeyboardFocusModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: KeyboardFocusModule, providers: [
            i1.provideDefaultConfig(defaultKeyboardFocusConfig),
            {
                provide: i0.APP_INITIALIZER,
                useFactory: keyboardFocusFactory,
                deps: [OnNavigateFocusService],
                multi: true,
            },
        ], imports: [[
                i3.CommonModule,
                i1.ConfigModule.withConfig(defaultKeyboardFocusConfig),
                i1$1.RouterModule,
            ]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: KeyboardFocusModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [
                            i3.CommonModule,
                            i1.ConfigModule.withConfig(defaultKeyboardFocusConfig),
                            i1$1.RouterModule,
                        ],
                        declarations: __spreadArray([], __read(directives)),
                        providers: [
                            i1.provideDefaultConfig(defaultKeyboardFocusConfig),
                            {
                                provide: i0.APP_INITIALIZER,
                                useFactory: keyboardFocusFactory,
                                deps: [OnNavigateFocusService],
                                multi: true,
                            },
                        ],
                        exports: __spreadArray([], __read(directives)),
                    }]
            }] });
    /**
     *  @deprecated since 4.2, refer to spartacus issues (#13762)
     *  Start keyboard focus services on app initialization.
     */
    function keyboardFocusFactory(onNavigateFocusService) {
        var isReady = function () { return onNavigateFocusService.initializeWithConfig(); };
        return isReady;
    }

    var MockKeyboardFocusDirective = /** @class */ (function () {
        function MockKeyboardFocusDirective() {
            this.config = {};
        }
        return MockKeyboardFocusDirective;
    }());
    MockKeyboardFocusDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: MockKeyboardFocusDirective, deps: [], target: i0__namespace.ɵɵFactoryTarget.Directive });
    MockKeyboardFocusDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.5", type: MockKeyboardFocusDirective, selector: "[cxFocus]", inputs: { config: ["cxFocus", "config"] }, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: MockKeyboardFocusDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        selector: '[cxFocus]',
                    }]
            }], propDecorators: { config: [{
                    type: i0.Input,
                    args: ['cxFocus']
                }] } });
    var KeyboardFocusTestingModule = /** @class */ (function () {
        function KeyboardFocusTestingModule() {
        }
        return KeyboardFocusTestingModule;
    }());
    KeyboardFocusTestingModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: KeyboardFocusTestingModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    KeyboardFocusTestingModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: KeyboardFocusTestingModule, declarations: [MockKeyboardFocusDirective], exports: [MockKeyboardFocusDirective] });
    KeyboardFocusTestingModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: KeyboardFocusTestingModule });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: KeyboardFocusTestingModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        declarations: [MockKeyboardFocusDirective],
                        exports: [MockKeyboardFocusDirective],
                    }]
            }] });

    // given that we're likely going to refactor the directives, we're
    // export * from './autofocus/index';
    // export * from './base/index';
    // export * from './block/index';
    // export * from './escape/index';
    // export * from './lock/index';
    // export * from './on-navigate/index';
    // export * from './persist/index';
    // export * from './tab/index';
    // export * from './trap/index';
    // export * from './visible/index';
    // export * from './keyboard-focus.model';

    /**
     * Types of dialog openings supported
     */
    exports.DIALOG_TYPE = void 0;
    (function (DIALOG_TYPE) {
        DIALOG_TYPE["POPOVER"] = "POPOVER";
        DIALOG_TYPE["POPOVER_CENTER"] = "POPOVER_CENTER";
        DIALOG_TYPE["POPOVER_CENTER_BACKDROP"] = "POPOVER_CENTER_BACKDROP";
        DIALOG_TYPE["DIALOG"] = "DIALOG";
        DIALOG_TYPE["SIDEBAR_START"] = "SIDEBAR_START";
        DIALOG_TYPE["SIDEBAR_END"] = "SIDEBAR_END";
    })(exports.DIALOG_TYPE || (exports.DIALOG_TYPE = {}));

    exports.LaunchRenderStrategy = /** @class */ (function () {
        function LaunchRenderStrategy(document, rendererFactory) {
            this.document = document;
            this.rendererFactory = rendererFactory;
            // List of called references; only used for rendered elements
            this.renderedCallers = [];
            /**
             * Classes to apply to the component when the dialog is a DIALOG
             */
            this.dialogClasses = ['d-block', 'fade', 'modal', 'show'];
            /**
             * Classes to apply to the component when the dialog is a POPOVER
             */
            this.popoverClasses = ['cx-dialog-popover'];
            /**
             * Classes to apply to the component when the dialog is a POPOVER_CENTER
             */
            this.popoverCenterClasses = ['cx-dialog-popover-center'];
            /**
             * Classes to apply to the component when the dialog is a POPOVER_CENTER with a backdrop
             */
            this.popoverCenterBackdropClasses = [
                'cx-dialog-popover-center-backdrop',
            ];
            /**
             * Classes to apply to the component when the dialog is a SIDEBAR_END
             */
            this.sidebarEndClasses = ['cx-sidebar-end'];
            /**
             * Classes to apply to the component when the dialog is a SIDEBAR_START
             */
            this.sidebarStartClasses = ['cx-sidebar-start'];
            this.renderer = rendererFactory.createRenderer(null, null);
        }
        /**
         * Determines if element should render
         *
         * @param caller
         * @param config
         */
        LaunchRenderStrategy.prototype.shouldRender = function (caller, config) {
            return (Boolean(config.component) &&
                (this.renderedCallers.some(function (el) { return el.caller === caller; })
                    ? !!config.multi
                    : true));
        };
        LaunchRenderStrategy.prototype.applyClasses = function (component, dialogType) {
            var e_1, _b;
            var classes = [];
            // TODO: make classes configurable
            switch (dialogType) {
                case exports.DIALOG_TYPE.DIALOG:
                    classes = this.dialogClasses;
                    this.renderer.addClass(this.document.body, 'modal-open');
                    break;
                case exports.DIALOG_TYPE.POPOVER:
                    classes = this.popoverClasses;
                    break;
                case exports.DIALOG_TYPE.POPOVER_CENTER:
                    classes = this.popoverCenterClasses;
                    break;
                case exports.DIALOG_TYPE.POPOVER_CENTER_BACKDROP:
                    classes = this.popoverCenterBackdropClasses;
                    break;
                case exports.DIALOG_TYPE.SIDEBAR_END:
                    classes = this.sidebarEndClasses;
                    break;
                case exports.DIALOG_TYPE.SIDEBAR_START:
                    classes = this.sidebarStartClasses;
                    break;
            }
            try {
                for (var classes_1 = __values(classes), classes_1_1 = classes_1.next(); !classes_1_1.done; classes_1_1 = classes_1.next()) {
                    var newClass = classes_1_1.value;
                    this.renderer.addClass(component.location.nativeElement, newClass);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (classes_1_1 && !classes_1_1.done && (_b = classes_1.return)) _b.call(classes_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        };
        /**
         * Method to call when rendered element is destroyed
         * The element will be removed from the list of rendered elements
         *
         * @param caller
         * @param _config optional parameters used in children strategies
         */
        LaunchRenderStrategy.prototype.remove = function (caller, config) {
            var _a;
            this.renderedCallers = this.renderedCallers.filter(function (el) { return el.caller !== caller; });
            if (((_a = config) === null || _a === void 0 ? void 0 : _a.dialogType) === exports.DIALOG_TYPE.DIALOG) {
                this.renderer.removeClass(this.document.body, 'modal-open');
            }
        };
        LaunchRenderStrategy.prototype.getPriority = function () {
            return -10 /* LOW */; // low, as it's a default matcher
        };
        return LaunchRenderStrategy;
    }());
    exports.LaunchRenderStrategy = __decorate([
        __param(0, i0.Inject(i3.DOCUMENT))
    ], exports.LaunchRenderStrategy);

    var LaunchDialogService = /** @class */ (function () {
        function LaunchDialogService(renderStrategies, layoutConfig) {
            this.renderStrategies = renderStrategies;
            this.layoutConfig = layoutConfig;
            this._dialogClose = new rxjs.BehaviorSubject(undefined);
            this._dataSubject = new rxjs.BehaviorSubject(undefined);
            this.renderStrategies = this.renderStrategies || [];
        }
        Object.defineProperty(LaunchDialogService.prototype, "data$", {
            get: function () {
                return this._dataSubject.asObservable();
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Open the dialog
         *
         * @param caller LAUNCH_CALLER
         * @param openElement button's Element ref
         * @param vcr View Container Ref of the container for inline rendering
         * @param data optional data which could be passed to dialog
         */
        LaunchDialogService.prototype.openDialog = function (caller, openElement, vcr, data) {
            var _this = this;
            var component = this.launch(caller, vcr, data);
            if (component) {
                return rxjs.combineLatest([component, this.dialogClose]).pipe(operators.filter(function (_b) {
                    var _c = __read(_b, 2), close = _c[1];
                    return close !== undefined;
                }), operators.tap(function (_b) {
                    var _c = __read(_b, 1), comp = _c[0];
                    openElement === null || openElement === void 0 ? void 0 : openElement.nativeElement.focus();
                    _this.clear(caller);
                    comp.destroy();
                }), operators.map(function (_b) {
                    var _c = __read(_b, 1), comp = _c[0];
                    return comp;
                }));
            }
        };
        /**
         * Render the element based on the strategy from the launch configuration
         *
         * @param caller LAUNCH_CALLER
         * @param vcr View Container Ref of the container for inline rendering
         */
        LaunchDialogService.prototype.launch = function (caller, vcr, data) {
            var config = this.findConfiguration(caller);
            if (config) {
                var renderer = this.getStrategy(config);
                // Render if the strategy exists
                if (renderer) {
                    this._dialogClose.next(undefined);
                    this._dataSubject.next(data);
                    return renderer.render(config, caller, vcr);
                }
            }
            else if (i0.isDevMode()) {
                console.warn('No configuration provided for caller ' + caller);
            }
        };
        /**
         * Opens dialog and subscribe in the service. Should be used if the trigger component might get destroyed while the component is open.
         *
         * @param caller Launch Caller
         * @param openElement Element to open
         * @param data Data to provide to the rendered element
         */
        LaunchDialogService.prototype.openDialogAndSubscribe = function (caller, openElement, data) {
            var _a;
            (_a = this.openDialog(caller, openElement, undefined, data)) === null || _a === void 0 ? void 0 : _a.pipe(operators.take(1)).subscribe();
        };
        /**
         * Util method to remove element from rendered elements list
         *
         * @param caller LAUNCH_CALLER
         */
        LaunchDialogService.prototype.clear = function (caller) {
            var config = this.findConfiguration(caller);
            if (config) {
                var renderer = this.getStrategy(config);
                // Render if the strategy exists
                if (renderer) {
                    renderer.remove(caller, config);
                }
            }
        };
        Object.defineProperty(LaunchDialogService.prototype, "dialogClose", {
            get: function () {
                return this._dialogClose.asObservable();
            },
            enumerable: false,
            configurable: true
        });
        LaunchDialogService.prototype.closeDialog = function (reason) {
            this._dialogClose.next(reason);
        };
        /**
         * Returns the configuration for the caller
         *
         * @param caller LAUNCH_CALLER
         */
        LaunchDialogService.prototype.findConfiguration = function (caller) {
            var _a;
            if ((_a = this.layoutConfig) === null || _a === void 0 ? void 0 : _a.launch) {
                return this.layoutConfig.launch[caller];
            }
            return undefined;
        };
        /**
         * Returns the render strategy based on the configuration
         *
         * @param config Configuration for launch
         */
        LaunchDialogService.prototype.getStrategy = function (config) {
            return i1.resolveApplicable(this.renderStrategies, [config]);
        };
        return LaunchDialogService;
    }());
    LaunchDialogService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: LaunchDialogService, deps: [{ token: exports.LaunchRenderStrategy }, { token: LayoutConfig }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    LaunchDialogService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: LaunchDialogService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: LaunchDialogService, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }], ctorParameters: function () {
            return [{ type: undefined, decorators: [{
                            type: i0.Inject,
                            args: [exports.LaunchRenderStrategy]
                        }] }, { type: LayoutConfig }];
        } });

    var AnonymousConsentManagementBannerComponent = /** @class */ (function () {
        function AnonymousConsentManagementBannerComponent(anonymousConsentsService, vcr, launchDialogService) {
            this.anonymousConsentsService = anonymousConsentsService;
            this.vcr = vcr;
            this.launchDialogService = launchDialogService;
            this.subscriptions = new rxjs.Subscription();
            this.bannerVisible$ = this.anonymousConsentsService.isBannerVisible();
        }
        AnonymousConsentManagementBannerComponent.prototype.viewDetails = function () {
            this.hideBanner();
            var dialog = this.launchDialogService.openDialog("ANONYMOUS_CONSENT" /* ANONYMOUS_CONSENT */, null, this.vcr);
            if (dialog) {
                this.subscriptions.add(dialog.subscribe());
            }
        };
        AnonymousConsentManagementBannerComponent.prototype.allowAll = function () {
            var _this = this;
            this.subscriptions.add(this.anonymousConsentsService
                .giveAllConsents()
                .pipe(operators.tap(function () { return _this.hideBanner(); }))
                .subscribe());
        };
        AnonymousConsentManagementBannerComponent.prototype.hideBanner = function () {
            this.anonymousConsentsService.toggleBannerDismissed(true);
        };
        AnonymousConsentManagementBannerComponent.prototype.ngOnDestroy = function () {
            this.subscriptions.unsubscribe();
        };
        return AnonymousConsentManagementBannerComponent;
    }());
    AnonymousConsentManagementBannerComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AnonymousConsentManagementBannerComponent, deps: [{ token: i1__namespace.AnonymousConsentsService }, { token: i0__namespace.ViewContainerRef }, { token: LaunchDialogService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    AnonymousConsentManagementBannerComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: AnonymousConsentManagementBannerComponent, selector: "cx-anonymous-consent-management-banner", ngImport: i0__namespace, template: "<ng-container *ngIf=\"bannerVisible$ | async as bannerVisible\">\n  <div\n    [ngClass]=\"{ 'anonymous-consent-banner-hidden': !bannerVisible }\"\n    class=\"anonymous-consent-banner\"\n  >\n    <div class=\"container\">\n      <div class=\"row\">\n        <div class=\"col-lg-8 col-xs-12\">\n          <div class=\"cx-banner-title\">\n            {{ 'anonymousConsents.banner.title' | cxTranslate }}\n          </div>\n          <div class=\"cx-banner-description\">\n            {{ 'anonymousConsents.banner.description' | cxTranslate }}\n          </div>\n        </div>\n\n        <div class=\"col-lg-4 col-xs-12 cx-banner-buttons\">\n          <button class=\"btn btn-action\" (click)=\"viewDetails()\">\n            {{ 'anonymousConsents.banner.viewDetails' | cxTranslate }}\n          </button>\n          <button class=\"btn btn-primary\" (click)=\"allowAll()\">\n            {{ 'anonymousConsents.banner.allowAll' | cxTranslate }}\n          </button>\n        </div>\n      </div>\n    </div>\n  </div>\n</ng-container>\n", directives: [{ type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3__namespace.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }], pipes: { "async": i3__namespace.AsyncPipe, "cxTranslate": i1__namespace.TranslatePipe } });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AnonymousConsentManagementBannerComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-anonymous-consent-management-banner',
                        templateUrl: './anonymous-consent-management-banner.component.html',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace.AnonymousConsentsService }, { type: i0__namespace.ViewContainerRef }, { type: LaunchDialogService }]; } });

    var InlineRenderStrategy = /** @class */ (function (_super) {
        __extends(InlineRenderStrategy, _super);
        function InlineRenderStrategy(document, rendererFactory, componentFactoryResolver) {
            var _this = _super.call(this, document, rendererFactory) || this;
            _this.document = document;
            _this.rendererFactory = rendererFactory;
            _this.componentFactoryResolver = componentFactoryResolver;
            return _this;
        }
        /**
         * Renders the component from the configuration in the view container ref
         *
         * @param config
         * @param caller
         * @param vcr
         */
        InlineRenderStrategy.prototype.render = function (config, caller, vcr) {
            // Only render if a ViewContainerRef is provided
            if (vcr && this.shouldRender(caller, config)) {
                var template = this.componentFactoryResolver.resolveComponentFactory(config.component);
                var component = vcr.createComponent(template);
                if (config === null || config === void 0 ? void 0 : config.dialogType) {
                    this.applyClasses(component, config === null || config === void 0 ? void 0 : config.dialogType);
                }
                this.renderedCallers.push({ caller: caller, element: vcr.element, component: component });
                return rxjs.of(component);
            }
            else if (i0.isDevMode()) {
                if (!vcr) {
                    console.warn("No view container ref provided for " + caller);
                }
                else {
                    console.warn("Element for " + caller + " already rendered. To allow multi rendering add property multi: true.");
                }
            }
        };
        InlineRenderStrategy.prototype.hasMatch = function (config) {
            return Boolean(config.inline);
        };
        return InlineRenderStrategy;
    }(exports.LaunchRenderStrategy));
    InlineRenderStrategy.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: InlineRenderStrategy, deps: [{ token: i3.DOCUMENT }, { token: i0__namespace.RendererFactory2 }, { token: i0__namespace.ComponentFactoryResolver }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    InlineRenderStrategy.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: InlineRenderStrategy, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: InlineRenderStrategy, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }], ctorParameters: function () {
            return [{ type: undefined, decorators: [{
                            type: i0.Inject,
                            args: [i3.DOCUMENT]
                        }] }, { type: i0__namespace.RendererFactory2 }, { type: i0__namespace.ComponentFactoryResolver }];
        } });

    var InlineRootRenderStrategy = /** @class */ (function (_super) {
        __extends(InlineRootRenderStrategy, _super);
        function InlineRootRenderStrategy(document, rendererFactory, componentFactoryResolver, injector) {
            var _this = _super.call(this, document, rendererFactory) || this;
            _this.document = document;
            _this.rendererFactory = rendererFactory;
            _this.componentFactoryResolver = componentFactoryResolver;
            _this.injector = injector;
            return _this;
        }
        Object.defineProperty(InlineRootRenderStrategy.prototype, "hostComponent", {
            get: function () {
                var _a, _b;
                return (_b = (_a = this.injector.get(i0.ApplicationRef)) === null || _a === void 0 ? void 0 : _a.components) === null || _b === void 0 ? void 0 : _b[0];
            },
            enumerable: false,
            configurable: true
        });
        InlineRootRenderStrategy.prototype.render = function (config, caller) {
            var _a, _b;
            if (this.shouldRender(caller, config)) {
                var componentFactory = this.componentFactoryResolver.resolveComponentFactory(config.component);
                var contentInjector = i0.Injector.create({
                    providers: [],
                });
                var componentRef = componentFactory.create(contentInjector);
                (_a = this.injector.get(i0.ApplicationRef)) === null || _a === void 0 ? void 0 : _a.attachView(componentRef.hostView);
                this.renderer.appendChild((_b = this.hostComponent) === null || _b === void 0 ? void 0 : _b.location.nativeElement, componentRef.location.nativeElement);
                if (config === null || config === void 0 ? void 0 : config.dialogType) {
                    this.applyClasses(componentRef, config === null || config === void 0 ? void 0 : config.dialogType);
                }
                this.renderedCallers.push({ caller: caller, component: componentRef });
                return rxjs.of(componentRef);
            }
        };
        InlineRootRenderStrategy.prototype.hasMatch = function (config) {
            return Boolean(config.inlineRoot);
        };
        return InlineRootRenderStrategy;
    }(exports.LaunchRenderStrategy));
    InlineRootRenderStrategy.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: InlineRootRenderStrategy, deps: [{ token: i3.DOCUMENT }, { token: i0__namespace.RendererFactory2 }, { token: i0__namespace.ComponentFactoryResolver }, { token: i0__namespace.Injector }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    InlineRootRenderStrategy.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: InlineRootRenderStrategy, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: InlineRootRenderStrategy, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }], ctorParameters: function () {
            return [{ type: undefined, decorators: [{
                            type: i0.Inject,
                            args: [i3.DOCUMENT]
                        }] }, { type: i0__namespace.RendererFactory2 }, { type: i0__namespace.ComponentFactoryResolver }, { type: i0__namespace.Injector }];
        } });

    exports.OutletPosition = void 0;
    (function (OutletPosition) {
        OutletPosition["REPLACE"] = "replace";
        OutletPosition["BEFORE"] = "before";
        OutletPosition["AFTER"] = "after";
    })(exports.OutletPosition || (exports.OutletPosition = {}));
    var AVOID_STACKED_OUTLETS = false;
    var USE_STACKED_OUTLETS = true;
    /**
     * Token for injecting outlet related context to the component rendered in the outlet
     */
    var OutletContextData = /** @class */ (function () {
        function OutletContextData() {
        }
        return OutletContextData;
    }());

    var OutletService = /** @class */ (function () {
        function OutletService() {
            var _a;
            this.templatesRefs = (_a = {},
                _a[exports.OutletPosition.BEFORE] = new Map(),
                _a[exports.OutletPosition.REPLACE] = new Map(),
                _a[exports.OutletPosition.AFTER] = new Map(),
                _a);
        }
        /**
         * @param templateOrFactory A `ComponentFactory` that inserts a component dynamically.
         */
        OutletService.prototype.add = function (outlet, templateOrFactory, position) {
            if (position === void 0) { position = exports.OutletPosition.REPLACE; }
            var store = this.templatesRefs[position];
            if (store) {
                var existing = store.get(outlet) || [];
                var newValue = existing.concat([templateOrFactory]);
                store.set(outlet, newValue);
            }
        };
        /**
         *
         * Returns a single object or multiple objects for the given outlet reference,
         * depending on the `stacked` argument.
         *
         * @param outlet The outlet reference
         * @param position the outlet position, `OutletPosition.before`, `OutletPosition.AFTER` or `OutletPosition.REPLACE`
         * @param stacked Indicates whether an array of outlet components is returned
         */
        OutletService.prototype.get = function (outlet, position, stacked) {
            if (position === void 0) { position = exports.OutletPosition.REPLACE; }
            if (stacked === void 0) { stacked = AVOID_STACKED_OUTLETS; }
            var store = this.templatesRefs[position] ||
                this.templatesRefs[exports.OutletPosition.REPLACE];
            var templateRef = store.get(outlet);
            if (templateRef && !stacked) {
                return templateRef[0];
            }
            return templateRef;
        };
        OutletService.prototype.remove = function (outlet, position, value) {
            if (position === void 0) { position = exports.OutletPosition.REPLACE; }
            var store = this.templatesRefs[position] ||
                this.templatesRefs[exports.OutletPosition.REPLACE];
            this.removeValueOrAll(store, outlet, value);
        };
        OutletService.prototype.removeValueOrAll = function (store, outlet, value) {
            if (!value && store.has(outlet)) {
                store.delete(outlet);
            }
            else if (value && store.has(outlet)) {
                var existing = store.get(outlet);
                existing = existing.filter(function (val) { return val !== value; });
                store.set(outlet, existing);
            }
        };
        return OutletService;
    }());
    OutletService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OutletService, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    OutletService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OutletService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OutletService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }] });

    var OutletRefDirective = /** @class */ (function () {
        function OutletRefDirective(tpl, outletService) {
            this.tpl = tpl;
            this.outletService = outletService;
        }
        OutletRefDirective.prototype.ngOnInit = function () {
            this.outletService.add(this.cxOutletRef, this.tpl, this.cxOutletPos);
        };
        OutletRefDirective.prototype.ngOnDestroy = function () {
            this.outletService.remove(this.cxOutletRef, this.cxOutletPos, this.tpl);
        };
        return OutletRefDirective;
    }());
    OutletRefDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OutletRefDirective, deps: [{ token: i0__namespace.TemplateRef }, { token: OutletService }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    OutletRefDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.5", type: OutletRefDirective, selector: "[cxOutletRef]", inputs: { cxOutletRef: "cxOutletRef", cxOutletPos: "cxOutletPos" }, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OutletRefDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        selector: '[cxOutletRef]',
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.TemplateRef }, { type: OutletService }]; }, propDecorators: { cxOutletRef: [{
                    type: i0.Input
                }], cxOutletPos: [{
                    type: i0.Input
                }] } });

    var OutletRefModule = /** @class */ (function () {
        function OutletRefModule() {
        }
        return OutletRefModule;
    }());
    OutletRefModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OutletRefModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    OutletRefModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OutletRefModule, declarations: [OutletRefDirective], imports: [i3.CommonModule], exports: [OutletRefDirective] });
    OutletRefModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OutletRefModule, imports: [[i3.CommonModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OutletRefModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [i3.CommonModule],
                        declarations: [OutletRefDirective],
                        exports: [OutletRefDirective],
                    }]
            }] });

    var OutletRendererService = /** @class */ (function () {
        function OutletRendererService() {
            this.outletRefs = new rxjs.BehaviorSubject(new Map());
        }
        /**
         * Dynamically render the templates in the specified array
         *
         * @param outlet
         */
        OutletRendererService.prototype.render = function (outlet) {
            if (this.outletRefs.value.size !== 0) {
                this.outletRefs.value.get(outlet).render();
            }
        };
        /**
         * Register outlet to be available to render dynamically
         *
         * @param cxOutlet
         * @param context
         */
        OutletRendererService.prototype.register = function (cxOutlet, context) {
            this.outletRefs.next(this.outletRefs.value.set(cxOutlet, context));
        };
        /**
         * Returns map of outlets
         *
         */
        OutletRendererService.prototype.getOutletRef = function (outlet) {
            return this.outletRefs.asObservable().pipe(operators.map(function (val) { return val.get(outlet); }), operators.filter(i1.isNotNullable));
        };
        return OutletRendererService;
    }());
    OutletRendererService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OutletRendererService, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    OutletRendererService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OutletRendererService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OutletRendererService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }] });

    /**
     * The IntersectionService uses the native IntersectionObserver (v2), which
     * can be used to implement pre-loading and deferred loading of DOM content.
     *
     */
    var IntersectionService = /** @class */ (function () {
        function IntersectionService(config) {
            this.config = config;
        }
        /**
         * Returns an Observable that emits only once a boolean value whenever
         * the given element has shown in the view port.
         *
         * The returned observable will only emit the first value. The
         * observable must be cleaned up either way, since the value might never emit; it
         *  depends on whether the element appears in the view port.
         */
        IntersectionService.prototype.isIntersected = function (element, options) {
            return this.intersects(element, options).pipe(operators.first(function (v) { return v === true; }));
        };
        /**
         * Indicates whenever the element intersects the view port. An optional margin
         * is used to intersects before the element shows up in the viewport.
         * A value is emitted each time the element intersects.
         *
         * This is private for now, but could be exposed as a public API
         * to introduce additional (css) render effects to the UI.
         */
        IntersectionService.prototype.intersects = function (element, options) {
            var _this = this;
            if (options === void 0) { options = {}; }
            var elementVisible$ = new rxjs.Observable(function (observer) {
                var rootMargin = _this.getRootMargin(options);
                var intersectOptions = { rootMargin: rootMargin, threshold: options.threshold };
                var intersectionObserver = new IntersectionObserver(function (entries) {
                    observer.next(entries);
                }, intersectOptions);
                intersectionObserver.observe(element);
                return function () {
                    intersectionObserver.disconnect();
                };
            }).pipe(operators.flatMap(function (entries) { return entries; }), operators.map(function (entry) { return entry.isIntersecting; }), operators.distinctUntilChanged());
            return elementVisible$;
        };
        IntersectionService.prototype.getRootMargin = function (options) {
            if (options === void 0) { options = {}; }
            if (options.rootMargin) {
                return options.rootMargin;
            }
            var layoutConfig = this.config;
            if (layoutConfig.deferredLoading &&
                layoutConfig.deferredLoading.intersectionMargin) {
                return layoutConfig.deferredLoading.intersectionMargin;
            }
        };
        return IntersectionService;
    }());
    IntersectionService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: IntersectionService, deps: [{ token: LayoutConfig }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    IntersectionService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: IntersectionService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: IntersectionService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: LayoutConfig }]; } });

    /**
     * The defer loading serivce is used to defer loading of DOM elements
     * until the elements are required for the user experience.
     */
    var DeferLoaderService = /** @class */ (function () {
        function DeferLoaderService(platformId, config, intersectionService) {
            this.platformId = platformId;
            this.config = config;
            this.intersectionService = intersectionService;
            this.globalLoadStrategy = config.deferredLoading
                ? config.deferredLoading.strategy
                : i1.DeferLoadingStrategy.INSTANT;
        }
        /**
         * Defer loading till the element intersects the viewport.
         *
         * We evaluate whether we instantly load the element for different reasons:
         * - we run in SSR mode
         * - there's no global strategy given
         * - the global loading strategy is set to INSTANT loading,
         *   and the loading strategy in the given is not set to DEFER
         * - the loading strategy in the given options is set to INSTANT
         */
        DeferLoaderService.prototype.load = function (element, options) {
            if (this.shouldLoadInstantly((options || {}).deferLoading)) {
                return rxjs.of(true);
            }
            else {
                return this.intersectionService.isIntersected(element, options);
            }
        };
        DeferLoaderService.prototype.shouldLoadInstantly = function (elementLoadingStrategy) {
            return (i3.isPlatformServer(this.platformId) ||
                elementLoadingStrategy === i1.DeferLoadingStrategy.INSTANT ||
                (elementLoadingStrategy !== i1.DeferLoadingStrategy.DEFER &&
                    this.globalLoadStrategy === i1.DeferLoadingStrategy.INSTANT));
        };
        return DeferLoaderService;
    }());
    DeferLoaderService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: DeferLoaderService, deps: [{ token: i0.PLATFORM_ID }, { token: LayoutConfig }, { token: IntersectionService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    DeferLoaderService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: DeferLoaderService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: DeferLoaderService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () {
            return [{ type: Object, decorators: [{
                            type: i0.Inject,
                            args: [i0.PLATFORM_ID]
                        }] }, { type: LayoutConfig }, { type: IntersectionService }];
        } });

    var OutletDirective = /** @class */ (function () {
        function OutletDirective(vcr, templateRef, outletService, deferLoaderService, outletRendererService) {
            this.vcr = vcr;
            this.templateRef = templateRef;
            this.outletService = outletService;
            this.deferLoaderService = deferLoaderService;
            this.outletRendererService = outletRendererService;
            this.renderedTemplate = [];
            this.renderedComponents = new Map();
            /**
             * Observable with current outlet context
             */
            this.outletContext$ = new rxjs.ReplaySubject(1);
            this.loaded = new i0.EventEmitter(true);
            this.subscription = new rxjs.Subscription();
        }
        /**
         * Renders view for outlet or defers it, depending on the input `cxOutletDefer`
         */
        OutletDirective.prototype.render = function () {
            this.vcr.clear();
            this.renderedTemplate = [];
            this.renderedComponents.clear();
            this.subscription.unsubscribe();
            this.subscription = new rxjs.Subscription();
            if (this.cxOutletDefer) {
                this.deferLoading();
            }
            else {
                this.build();
            }
        };
        OutletDirective.prototype.ngOnChanges = function (changes) {
            if (changes.cxOutlet) {
                this.render();
                this.outletRendererService.register(this.cxOutlet, this);
            }
            if (changes.cxOutletContext) {
                this.outletContext$.next(this.cxOutletContext);
            }
        };
        OutletDirective.prototype.deferLoading = function () {
            var _this = this;
            this.loaded.emit(false);
            var hostElement = this.getHostElement(this.vcr.element.nativeElement);
            // Although the deferLoaderService might emit only once, as long as the hostElement
            // isn't being loaded, there's no value being emitted. Therefore we need to clean up
            // the subscription on destroy.
            this.subscription.add(this.deferLoaderService
                .load(hostElement, this.cxOutletDefer)
                .subscribe(function () {
                _this.build();
                _this.loaded.emit(true);
            }));
        };
        /**
         * Renders view for outlet
         */
        OutletDirective.prototype.build = function () {
            this.buildOutlet(exports.OutletPosition.BEFORE);
            this.buildOutlet(exports.OutletPosition.REPLACE);
            this.buildOutlet(exports.OutletPosition.AFTER);
        };
        /**
         * Renders view in a given position for outlet
         */
        OutletDirective.prototype.buildOutlet = function (position) {
            var _this = this;
            var templates = (this.outletService.get(this.cxOutlet, position, USE_STACKED_OUTLETS));
            templates = templates === null || templates === void 0 ? void 0 : templates.filter(function (el) { return !_this.renderedTemplate.includes(el); });
            if (!templates && position === exports.OutletPosition.REPLACE) {
                templates = [this.templateRef];
            }
            // Just in case someone extended the `OutletService` and
            // returns a singular object.
            if (!Array.isArray(templates)) {
                templates = [templates];
            }
            var components = [];
            templates.forEach(function (obj) {
                var component = _this.create(obj, position);
                components.push(component);
            });
            this.renderedComponents.set(position, components);
        };
        /**
         * Renders view based on the given template or component factory
         */
        OutletDirective.prototype.create = function (tmplOrFactory, position) {
            this.renderedTemplate.push(tmplOrFactory);
            if (tmplOrFactory instanceof i0.ComponentFactory) {
                var component = this.vcr.createComponent(tmplOrFactory, undefined, this.getComponentInjector(position));
                return component;
            }
            else if (tmplOrFactory instanceof i0.TemplateRef) {
                var view = this.vcr.createEmbeddedView(tmplOrFactory, {
                    $implicit: this.cxOutletContext,
                });
                // we do not know if content is created dynamically or not
                // so we apply change detection anyway
                view.markForCheck();
                return view;
            }
        };
        /**
         * Returns injector with OutletContextData that can be injected to the component
         * rendered in the outlet
         */
        OutletDirective.prototype.getComponentInjector = function (position) {
            var contextData = {
                reference: this.cxOutlet,
                position: position,
                context: this.cxOutletContext,
                context$: this.outletContext$.asObservable(),
            };
            return i0.Injector.create({
                providers: [
                    {
                        provide: OutletContextData,
                        useValue: contextData,
                    },
                ],
                parent: this.vcr.injector,
            });
        };
        /**
         * Returns the closest `HtmlElement`, by iterating over the
         * parent nodes of the given element.
         *
         * We avoid traversing the parent _elements_, as this is blocking
         * ie11 implementations. One of the spare exclusions we make to not
         * supporting ie11.
         *
         * @param element
         */
        OutletDirective.prototype.getHostElement = function (element) {
            if (element instanceof HTMLElement) {
                return element;
            }
            return this.getHostElement(element.parentNode);
        };
        OutletDirective.prototype.ngOnDestroy = function () {
            this.subscription.unsubscribe();
            this.outletContext$.complete();
        };
        return OutletDirective;
    }());
    OutletDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OutletDirective, deps: [{ token: i0__namespace.ViewContainerRef }, { token: i0__namespace.TemplateRef }, { token: OutletService }, { token: DeferLoaderService }, { token: OutletRendererService }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    OutletDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.5", type: OutletDirective, selector: "[cxOutlet]", inputs: { cxOutlet: "cxOutlet", cxOutletContext: "cxOutletContext", cxOutletDefer: "cxOutletDefer" }, outputs: { loaded: "loaded" }, usesOnChanges: true, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OutletDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        selector: '[cxOutlet]',
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ViewContainerRef }, { type: i0__namespace.TemplateRef }, { type: OutletService }, { type: DeferLoaderService }, { type: OutletRendererService }]; }, propDecorators: { cxOutlet: [{
                    type: i0.Input
                }], cxOutletContext: [{
                    type: i0.Input
                }], cxOutletDefer: [{
                    type: i0.Input
                }], loaded: [{
                    type: i0.Output
                }] } });

    /**
     * @private We plan to drive the outlets by standard configuration
     */
    var PROVIDE_OUTLET_OPTIONS = new i0.InjectionToken('PROVIDE_OUTLET_OPTIONS');
    /**
     * Helper function to register a component for an outlet.
     *
     * @param options.id unique id of the outlet
     * @param options.component Component to be registered for the outlet
     * @param options.position Component's position in the outlet (default: `OutletPosition.AFTER`)
     */
    function provideOutlet(options) {
        return {
            provide: PROVIDE_OUTLET_OPTIONS,
            useValue: options,
            multi: true,
        };
    }

    /**
     * @private
     */
    function registerOutletsFactory(providedOutletOptions, componentFactoryResolver, outletService) {
        var result = function () {
            (providedOutletOptions !== null && providedOutletOptions !== void 0 ? providedOutletOptions : []).forEach(function (options) {
                var _a;
                var factory = componentFactoryResolver.resolveComponentFactory(options.component);
                outletService.add(options.id, factory, (_a = options.position) !== null && _a !== void 0 ? _a : exports.OutletPosition.AFTER);
            });
        };
        return result;
    }
    var OutletModule = /** @class */ (function () {
        function OutletModule() {
        }
        OutletModule.forRoot = function () {
            return {
                ngModule: OutletModule,
                providers: [
                    {
                        provide: i0.APP_INITIALIZER,
                        useFactory: registerOutletsFactory,
                        deps: [
                            [new i0.Optional(), PROVIDE_OUTLET_OPTIONS],
                            i0.ComponentFactoryResolver,
                            OutletService,
                        ],
                        multi: true,
                    },
                ],
            };
        };
        return OutletModule;
    }());
    OutletModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OutletModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    OutletModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OutletModule, declarations: [OutletDirective], imports: [i3.CommonModule], exports: [OutletDirective] });
    OutletModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OutletModule, imports: [[i3.CommonModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OutletModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [i3.CommonModule],
                        declarations: [OutletDirective],
                        exports: [OutletDirective],
                    }]
            }] });

    var OutletRenderStrategy = /** @class */ (function (_super) {
        __extends(OutletRenderStrategy, _super);
        function OutletRenderStrategy(document, rendererFactory, outletService, componentFactoryResolver, outletRendererService) {
            var _this = _super.call(this, document, rendererFactory) || this;
            _this.document = document;
            _this.rendererFactory = rendererFactory;
            _this.outletService = outletService;
            _this.componentFactoryResolver = componentFactoryResolver;
            _this.outletRendererService = outletRendererService;
            return _this;
        }
        /**
         * Renders the element in the configured outlet
         *
         * @param config
         * @param caller
         * @param vcr
         */
        OutletRenderStrategy.prototype.render = function (config, caller) {
            var _this = this;
            if (this.shouldRender(caller, config)) {
                var template_1 = this.componentFactoryResolver.resolveComponentFactory(config.component);
                this.outletService.add(config.outlet, template_1, config.position ? config.position : exports.OutletPosition.BEFORE);
                this.outletRendererService.render(config.outlet);
                this.renderedCallers.push({ caller: caller });
                return this.outletRendererService.getOutletRef(config.outlet).pipe(operators.map(function (outletDirective) {
                    var components = outletDirective.renderedComponents.get(config.position ? config.position : exports.OutletPosition.BEFORE);
                    return components
                        .reverse()
                        .find(function (component) { return component.componentType === template_1.componentType; });
                }), operators.tap(function (component) {
                    if ((config === null || config === void 0 ? void 0 : config.dialogType) && component) {
                        _this.applyClasses(component, config === null || config === void 0 ? void 0 : config.dialogType);
                    }
                }));
            }
        };
        OutletRenderStrategy.prototype.hasMatch = function (config) {
            return Boolean(config.outlet);
        };
        OutletRenderStrategy.prototype.remove = function (caller, config) {
            var template = this.componentFactoryResolver.resolveComponentFactory(config.component);
            this.outletService.remove(config.outlet, config.position ? config.position : exports.OutletPosition.BEFORE, template);
            _super.prototype.remove.call(this, caller, config);
        };
        return OutletRenderStrategy;
    }(exports.LaunchRenderStrategy));
    OutletRenderStrategy.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OutletRenderStrategy, deps: [{ token: i3.DOCUMENT }, { token: i0__namespace.RendererFactory2 }, { token: OutletService }, { token: i0__namespace.ComponentFactoryResolver }, { token: OutletRendererService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    OutletRenderStrategy.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OutletRenderStrategy, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OutletRenderStrategy, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }], ctorParameters: function () {
            return [{ type: undefined, decorators: [{
                            type: i0.Inject,
                            args: [i3.DOCUMENT]
                        }] }, { type: i0__namespace.RendererFactory2 }, { type: OutletService }, { type: i0__namespace.ComponentFactoryResolver }, { type: OutletRendererService }];
        } });

    var RoutingRenderStrategy = /** @class */ (function (_super) {
        __extends(RoutingRenderStrategy, _super);
        function RoutingRenderStrategy(document, rendererFactory, routingService) {
            var _this = _super.call(this, document, rendererFactory) || this;
            _this.document = document;
            _this.rendererFactory = rendererFactory;
            _this.routingService = routingService;
            return _this;
        }
        /**
         * Navigates to the route configured for the caller
         */
        RoutingRenderStrategy.prototype.render = function (config, _caller) {
            this.routingService.go(config);
        };
        RoutingRenderStrategy.prototype.hasMatch = function (config) {
            return Boolean(config.cxRoute);
        };
        return RoutingRenderStrategy;
    }(exports.LaunchRenderStrategy));
    RoutingRenderStrategy.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: RoutingRenderStrategy, deps: [{ token: i3.DOCUMENT }, { token: i0__namespace.RendererFactory2 }, { token: i1__namespace.RoutingService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    RoutingRenderStrategy.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: RoutingRenderStrategy, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: RoutingRenderStrategy, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }], ctorParameters: function () {
            return [{ type: undefined, decorators: [{
                            type: i0.Inject,
                            args: [i3.DOCUMENT]
                        }] }, { type: i0__namespace.RendererFactory2 }, { type: i1__namespace.RoutingService }];
        } });

    var LaunchDialogModule = /** @class */ (function () {
        function LaunchDialogModule() {
        }
        LaunchDialogModule.forRoot = function () {
            return {
                ngModule: LaunchDialogModule,
                providers: [{ provide: LayoutConfig, useExisting: i1.Config }],
            };
        };
        return LaunchDialogModule;
    }());
    LaunchDialogModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: LaunchDialogModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    LaunchDialogModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: LaunchDialogModule });
    LaunchDialogModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: LaunchDialogModule, providers: [
            {
                provide: exports.LaunchRenderStrategy,
                useExisting: OutletRenderStrategy,
                multi: true,
            },
            {
                provide: exports.LaunchRenderStrategy,
                useExisting: InlineRenderStrategy,
                multi: true,
            },
            {
                provide: exports.LaunchRenderStrategy,
                useExisting: RoutingRenderStrategy,
                multi: true,
            },
            {
                provide: exports.LaunchRenderStrategy,
                useExisting: InlineRootRenderStrategy,
                multi: true,
            },
        ] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: LaunchDialogModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        providers: [
                            {
                                provide: exports.LaunchRenderStrategy,
                                useExisting: OutletRenderStrategy,
                                multi: true,
                            },
                            {
                                provide: exports.LaunchRenderStrategy,
                                useExisting: InlineRenderStrategy,
                                multi: true,
                            },
                            {
                                provide: exports.LaunchRenderStrategy,
                                useExisting: RoutingRenderStrategy,
                                multi: true,
                            },
                            {
                                provide: exports.LaunchRenderStrategy,
                                useExisting: InlineRootRenderStrategy,
                                multi: true,
                            },
                        ],
                    }]
            }] });

    exports.ICON_TYPE = void 0;
    (function (ICON_TYPE) {
        ICON_TYPE["STAR"] = "STAR";
        ICON_TYPE["SEARCH"] = "SEARCH";
        ICON_TYPE["CART"] = "CART";
        ICON_TYPE["INFO"] = "INFO";
        ICON_TYPE["GRID"] = "GRID";
        ICON_TYPE["LIST"] = "LIST";
        ICON_TYPE["CARET_DOWN"] = "CARET_DOWN";
        ICON_TYPE["CARET_UP"] = "CARET_UP";
        ICON_TYPE["CARET_LEFT"] = "CARET_LEFT";
        ICON_TYPE["CARET_RIGHT"] = "CARET_RIGHT";
        ICON_TYPE["CLOSE"] = "CLOSE";
        ICON_TYPE["ERROR"] = "ERROR";
        ICON_TYPE["WARNING"] = "WARNING";
        ICON_TYPE["SUCCESS"] = "SUCCESS";
        ICON_TYPE["VISA"] = "VISA";
        ICON_TYPE["MASTER_CARD"] = "MASTER_CARD";
        ICON_TYPE["AMEX"] = "AMEX";
        ICON_TYPE["DINERS_CLUB"] = "DINERS_CLUB";
        ICON_TYPE["CREDIT_CARD"] = "CREDIT_CARD";
        ICON_TYPE["EXPAND"] = "EXPAND";
        ICON_TYPE["COLLAPSE"] = "COLLAPSE";
        ICON_TYPE["RESET"] = "RESET";
        ICON_TYPE["CIRCLE"] = "CIRCLE";
        ICON_TYPE["HEART"] = "HEART";
        ICON_TYPE["EMPTY_HEART"] = "EMPTY_HEART";
        ICON_TYPE["FILTER"] = "FILTER";
        ICON_TYPE["PENCIL"] = "PENCIL";
        ICON_TYPE["CLOCK"] = "CLOCK";
        ICON_TYPE["TRASH"] = "TRASH";
        ICON_TYPE["ACTIVE"] = "ACTIVE";
        ICON_TYPE["SORT_DOWN"] = "SORT_DOWN";
        ICON_TYPE["SORT"] = "SORT";
        ICON_TYPE["ON"] = "ON";
        ICON_TYPE["OFF"] = "OFF";
        ICON_TYPE["LINK_OUT"] = "LINK_OUT";
        ICON_TYPE["EXPAND_ARROWS"] = "EXPAND_ARROWS";
    })(exports.ICON_TYPE || (exports.ICON_TYPE = {}));
    var IconConfig = /** @class */ (function () {
        function IconConfig() {
        }
        return IconConfig;
    }());
    IconConfig.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: IconConfig, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    IconConfig.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: IconConfig, providedIn: 'root', useExisting: i1.Config });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: IconConfig, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                        useExisting: i1.Config,
                    }]
            }] });
    /**
     * Each ICON type can have an companied resource type, such as SVG, LINK (font) or just TEXT.
     * The resources will be automatically loaded in case they're required for the `ICON_TYPE`.
     */
    exports.IconResourceType = void 0;
    (function (IconResourceType) {
        /**
         * An svg based icon requires an SVG resource that must be loaded,
         * this is typically a sprite svg file.
         */
        IconResourceType["SVG"] = "svg";
        /**
         * A font based ICON might require an additional CSS file to be loaded.
         */
        IconResourceType["LINK"] = "link";
        /**
         * Text based icons will simply add the ICON string to the DOM. Text icons do not need an image
         * or CSS pseudo class (i.e. :before), as the text itself is the icon (i.e. +)
         */
        IconResourceType["TEXT"] = "text";
    })(exports.IconResourceType || (exports.IconResourceType = {}));

    var fontawesomeIconConfig = {
        icon: {
            symbols: {
                SEARCH: 'fas fa-search',
                CART: 'fas fa-shopping-cart',
                INFO: 'fas fa-info-circle',
                STAR: 'fas fa-star',
                GRID: 'fas fa-th-large',
                LIST: 'fas fa-bars',
                CARET_UP: 'fas fa-angle-up',
                CARET_DOWN: 'fas fa-angle-down',
                CARET_RIGHT: 'fas fa-angle-right',
                CARET_LEFT: 'fas fa-angle-left',
                ERROR: 'fas fa-exclamation-circle',
                WARNING: 'fas fa-exclamation-triangle',
                SUCCESS: 'fas fa-check-circle',
                CLOSE: 'fas fa-times',
                VISA: 'fab fa-cc-visa',
                MASTER_CARD: 'fab fa-cc-mastercard',
                AMEX: 'fab fa-cc-amex',
                DINERS_CLUB: 'fab fa-cc-diners-club',
                CREDIT_CARD: 'fas fa-credit-card',
                COLLAPSE: 'fas fa-minus',
                EXPAND: 'fas fa-plus',
                RESET: 'fas fa-times-circle',
                CIRCLE: 'fas fa-circle',
                HEART: 'fas fa-heart',
                EMPTY_HEART: 'far fa-heart',
                FILTER: 'fas fa-filter',
                PENCIL: 'fas fa-pencil-alt',
                CLOCK: 'far fa-clock',
                TRASH: 'fas fa-trash',
                ACTIVE: 'fas fa-check',
                ON: 'fas fa-toggle-on',
                OFF: 'fas fa-toggle-off',
                LINK_OUT: 'fas fa-external-link-alt',
                SORT_DOWN: 'fas fa-sort-down',
                SORT: 'fas fa-sort',
                EXPAND_ARROWS: 'fas fa-expand',
            },
            resources: [
                {
                    type: exports.IconResourceType.LINK,
                    url: 'https://use.fontawesome.com/releases/v5.8.1/css/all.css',
                },
            ],
        },
    };

    var IconLoaderService = /** @class */ (function () {
        function IconLoaderService(winRef, iconConfig, sanitizer) {
            this.winRef = winRef;
            this.iconConfig = iconConfig;
            this.sanitizer = sanitizer;
            this.loadedResources = [];
        }
        /**
         * Returns an html fragment which can be added to the DOM in a safe way.
         */
        IconLoaderService.prototype.getHtml = function (type) {
            if (this.isResourceType(type, exports.IconResourceType.SVG)) {
                return this.sanitizer.bypassSecurityTrustHtml("<svg><use xlink:href=\"" + this.getSvgPath(type) + "\"></use></svg>");
            }
            if (this.isResourceType(type, exports.IconResourceType.TEXT)) {
                return this.sanitizer.bypassSecurityTrustHtml(this.getSymbol(type));
            }
        };
        /**
         * Return the direction for which the icon should mirror (ltr vs rtl). The icon direction
         * is configurable, but optional, as only a few icons should be flipped for rtl direction.
         */
        IconLoaderService.prototype.getFlipDirection = function (type) {
            var _a, _b;
            return (_b = (_a = this.config) === null || _a === void 0 ? void 0 : _a.flipDirection) === null || _b === void 0 ? void 0 : _b[type];
        };
        /**
         *
         * Returns the symbol class(es) for the icon type.
         */
        IconLoaderService.prototype.getStyleClasses = function (iconType) {
            return this.getSymbol(iconType) || '';
        };
        /**
         * Indicates whether the given `ICON_TYPE` is configured for
         * the given `IconResourceType`.
         */
        IconLoaderService.prototype.isResourceType = function (iconType, resourceType) {
            return (this.config.resources &&
                !!this.config.resources.find(function (res) { return res.types && res.type === resourceType && res.types.includes(iconType); }));
        };
        /**
         * Returns the path to the svg link. The link supports path names
         * as well, if the config a[[s been setup to support a svg file path.
         * Additionally, the icon prefix will be taken into account to prefix the
         * icon IDs in the SVG.
         */
        IconLoaderService.prototype.getSvgPath = function (iconType) {
            var svgResource = this.config.resources.find(function (res) { return res.type === exports.IconResourceType.SVG &&
                res.types &&
                res.types.includes(iconType); });
            if (svgResource) {
                return svgResource.url
                    ? svgResource.url + "#" + this.getSymbol(iconType)
                    : "#" + this.getSymbol(iconType);
            }
        };
        /**
         * Loads the resource url (if any) for the given icon.
         * The icon will only be loaded once.
         *
         * NOTE: this is not working when the shadow is used as there's
         * no head element available and the link must be loaded for every
         * web component.
         */
        IconLoaderService.prototype.addLinkResource = function (iconType) {
            var resource = this.findResource(iconType, exports.IconResourceType.LINK);
            if (resource &&
                resource.url &&
                !this.loadedResources.includes(resource.url)) {
                this.loadedResources.push(resource.url);
                var head = this.winRef.document.getElementsByTagName('head')[0];
                var link = this.winRef.document.createElement('link');
                link.rel = 'stylesheet';
                link.type = 'text/css';
                link.href = resource.url;
                head.appendChild(link);
            }
        };
        IconLoaderService.prototype.findResource = function (iconType, resourceType) {
            if (!this.config.resources) {
                return;
            }
            var resource = this.config.resources.find(function (res) { return res.type === resourceType && res.types && res.types.includes(iconType); });
            // no specific resource found, let's try to find a one-size-fits-all resource
            if (!resource) {
                resource = this.config.resources.find(function (res) { return (res.type === resourceType && !res.types) || res.types === []; });
            }
            return resource;
        };
        IconLoaderService.prototype.getSymbol = function (iconType) {
            if (this.config && this.config.symbols && this.config.symbols[iconType]) {
                return this.config.symbols[iconType];
            }
        };
        Object.defineProperty(IconLoaderService.prototype, "config", {
            get: function () {
                return this.iconConfig.icon;
            },
            enumerable: false,
            configurable: true
        });
        return IconLoaderService;
    }());
    IconLoaderService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: IconLoaderService, deps: [{ token: i1__namespace.WindowRef }, { token: IconConfig }, { token: i1__namespace$2.DomSanitizer }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    IconLoaderService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: IconLoaderService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: IconLoaderService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace.WindowRef }, { type: IconConfig }, { type: i1__namespace$2.DomSanitizer }]; } });

    /**
     * The ltr and rtl directions can be used to configure the storefront for a certain direction, both statically
     * or dynamically.
     *
     * The HTML5 "auto" value is not supported in Spartacus, as it's considered to be too fragile for the global
     * direction.
     */
    exports.DirectionMode = void 0;
    (function (DirectionMode) {
        /**
         * Indicates Left to Right direction.
         */
        DirectionMode["LTR"] = "ltr";
        /**
         * Indicates Right to Left direction.
         */
        DirectionMode["RTL"] = "rtl";
    })(exports.DirectionMode || (exports.DirectionMode = {}));

    /**
     *
     * The icon component can be added in different ways:
     *
     * With the component selector:
     * `<cx-icon type="SEARCH"></cx-icon>`
     *
     * With the attribute selector:
     * `<span cxIcon="STAR"></span>`
     *
     * Additionally, content can be projected to the icon:
     *
     * `<button cxIcon="HAPPY">happy label</button>`
     *
     * The above button would become (based on a TEXT resource type):
     * `<button>😊happy label</button>`
     *
     * While the content is projected, the icon itself doesn't require an
     * additional DOM node which is an advantage over the component selector.
     */
    var IconComponent = /** @class */ (function () {
        function IconComponent(iconLoader, elementRef, renderer) {
            this.iconLoader = iconLoader;
            this.elementRef = elementRef;
            this.renderer = renderer;
        }
        Object.defineProperty(IconComponent.prototype, "cxIcon", {
            /**
             * The cxIcon directive is bound to the icon type. You can feed the `ICON_TYPE` to
             * accomplish a configurable button in the UI.
             */
            set: function (type) {
                this.setIcon(type);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IconComponent.prototype, "type", {
            /**
             * The type input parameter is bound to the icon type. You can feed the `ICON_TYPE` to
             * accomplish a configurable button in the UI.
             */
            set: function (type) {
                this.setIcon(type);
            },
            enumerable: false,
            configurable: true
        });
        IconComponent.prototype.setIcon = function (type) {
            if (!type || type === '') {
                return;
            }
            this.icon = this.iconLoader.getHtml(type);
            this.addStyleClasses(type);
            this.iconLoader.addLinkResource(type);
            this.flipIcon(type);
        };
        /**
         * The icons supports flipping for some icons to support rtl and ltr directions.
         */
        IconComponent.prototype.flipIcon = function (type) {
            // TODO: this can be dropped with the next major release.
            if (!this.iconLoader.getFlipDirection) {
                return;
            }
            var iconDirection = this.iconLoader.getFlipDirection(type);
            this.flipAtLtr = iconDirection === exports.DirectionMode.LTR;
            this.flipAtRtl = iconDirection === exports.DirectionMode.RTL;
        };
        /**
         * Adds the style classes and the link resource (if available).
         */
        IconComponent.prototype.addStyleClasses = function (type) {
            var _this = this;
            var _a, _b, _c;
            this.renderer.addClass(this.host, 'cx-icon');
            (_a = this.styleClasses) === null || _a === void 0 ? void 0 : _a.forEach(function (cls) { return _this.renderer.removeClass(_this.host, cls); });
            this.styleClasses = (_b = this.iconLoader.getStyleClasses(type)) === null || _b === void 0 ? void 0 : _b.split(' ');
            (_c = this.styleClasses) === null || _c === void 0 ? void 0 : _c.forEach(function (cls) {
                if (cls !== '') {
                    _this.renderer.addClass(_this.host, cls);
                }
            });
        };
        Object.defineProperty(IconComponent.prototype, "host", {
            get: function () {
                return this.elementRef.nativeElement;
            },
            enumerable: false,
            configurable: true
        });
        return IconComponent;
    }());
    IconComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: IconComponent, deps: [{ token: IconLoaderService }, { token: i0__namespace.ElementRef }, { token: i0__namespace.Renderer2 }], target: i0__namespace.ɵɵFactoryTarget.Component });
    IconComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: IconComponent, selector: "cx-icon,[cxIcon]", inputs: { cxIcon: "cxIcon", type: "type" }, host: { properties: { "class.flip-at-rtl": "this.flipAtRtl", "class.flip-at-ltr": "this.flipAtLtr" } }, ngImport: i0__namespace, template: "<i [outerHTML]=\"icon\"></i><ng-content></ng-content>\n" });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: IconComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-icon,[cxIcon]',
                        templateUrl: './icon.component.html',
                    }]
            }], ctorParameters: function () { return [{ type: IconLoaderService }, { type: i0__namespace.ElementRef }, { type: i0__namespace.Renderer2 }]; }, propDecorators: { cxIcon: [{
                    type: i0.Input
                }], type: [{
                    type: i0.Input
                }], flipAtRtl: [{
                    type: i0.HostBinding,
                    args: ['class.flip-at-rtl']
                }], flipAtLtr: [{
                    type: i0.HostBinding,
                    args: ['class.flip-at-ltr']
                }] } });

    var defaultIconConfig = {
        icon: {
            flipDirection: {
                CARET_RIGHT: exports.DirectionMode.RTL,
                CARET_LEFT: exports.DirectionMode.RTL,
            },
        },
    };

    var IconModule = /** @class */ (function () {
        function IconModule() {
        }
        return IconModule;
    }());
    IconModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: IconModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    IconModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: IconModule, declarations: [IconComponent], imports: [i3.CommonModule], exports: [IconComponent] });
    IconModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: IconModule, providers: [
            i1.provideDefaultConfig(defaultIconConfig),
            // TODO: move the opinionated fontawesome config to a recipe
            i1.provideDefaultConfig(fontawesomeIconConfig),
        ], imports: [[i3.CommonModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: IconModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        declarations: [IconComponent],
                        imports: [i3.CommonModule],
                        providers: [
                            i1.provideDefaultConfig(defaultIconConfig),
                            // TODO: move the opinionated fontawesome config to a recipe
                            i1.provideDefaultConfig(fontawesomeIconConfig),
                        ],
                        exports: [IconComponent],
                    }]
            }] });

    // PRIVATE TESTING UTIL
    var MockIconComponent = /** @class */ (function () {
        function MockIconComponent() {
        }
        return MockIconComponent;
    }());
    MockIconComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: MockIconComponent, deps: [], target: i0__namespace.ɵɵFactoryTarget.Component });
    MockIconComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: MockIconComponent, selector: "cx-icon,[cxIcon]", inputs: { cxIcon: "cxIcon", type: "type" }, ngImport: i0__namespace, template: "{{ type || cxIcon }}", isInline: true });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: MockIconComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-icon,[cxIcon]',
                        template: "{{ type || cxIcon }}",
                    }]
            }], propDecorators: { cxIcon: [{
                    type: i0.Input
                }], type: [{
                    type: i0.Input
                }] } });
    var mockComponents = [MockIconComponent];
    var MockIconLoaderService = /** @class */ (function () {
        function MockIconLoaderService() {
        }
        MockIconLoaderService.prototype.getHtml = function () { };
        MockIconLoaderService.prototype.getStyleClasses = function () { };
        MockIconLoaderService.prototype.addStyleClasses = function () { };
        MockIconLoaderService.prototype.addLinkResource = function () { };
        return MockIconLoaderService;
    }());
    var IconTestingModule = /** @class */ (function () {
        function IconTestingModule() {
        }
        return IconTestingModule;
    }());
    IconTestingModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: IconTestingModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    IconTestingModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: IconTestingModule, declarations: [MockIconComponent], exports: [MockIconComponent] });
    IconTestingModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: IconTestingModule, providers: [
            {
                provide: IconLoaderService,
                useClass: MockIconLoaderService,
            },
        ] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: IconTestingModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        declarations: mockComponents,
                        exports: mockComponents,
                        providers: [
                            {
                                provide: IconLoaderService,
                                useClass: MockIconLoaderService,
                            },
                        ],
                    }]
            }] });

    // TODO: Improve a11y with better text appropriate to usage (example: loading cart spinner)
    var SpinnerComponent = /** @class */ (function () {
        function SpinnerComponent() {
        }
        return SpinnerComponent;
    }());
    SpinnerComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SpinnerComponent, deps: [], target: i0__namespace.ɵɵFactoryTarget.Component });
    SpinnerComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: SpinnerComponent, selector: "cx-spinner", ngImport: i0__namespace, template: "<div class=\"loader-container\">\n  <div class=\"loader\">{{ 'spinner.loading' | cxTranslate }}</div>\n</div>\n", pipes: { "cxTranslate": i1__namespace.TranslatePipe } });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SpinnerComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-spinner',
                        templateUrl: './spinner.component.html',
                    }]
            }], ctorParameters: function () { return []; } });

    var ConsentManagementFormComponent = /** @class */ (function () {
        function ConsentManagementFormComponent() {
            this.consentGiven = false;
            this.requiredConsents = [];
            this.consentChanged = new i0.EventEmitter();
        }
        ConsentManagementFormComponent.prototype.ngOnInit = function () {
            if (this.consent) {
                this.consentGiven = Boolean(this.consent.consentState === i1.ANONYMOUS_CONSENT_STATUS.GIVEN);
            }
            else {
                if (this.consentTemplate && this.consentTemplate.currentConsent) {
                    if (this.consentTemplate.currentConsent.consentWithdrawnDate) {
                        this.consentGiven = false;
                    }
                    else if (this.consentTemplate.currentConsent.consentGivenDate) {
                        this.consentGiven = true;
                    }
                }
            }
        };
        ConsentManagementFormComponent.prototype.onConsentChange = function () {
            this.consentGiven = !this.consentGiven;
            this.consentChanged.emit({
                given: this.consentGiven,
                template: this.consentTemplate,
            });
        };
        ConsentManagementFormComponent.prototype.isRequired = function (templateId) {
            return this.requiredConsents.includes(templateId);
        };
        return ConsentManagementFormComponent;
    }());
    ConsentManagementFormComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ConsentManagementFormComponent, deps: [], target: i0__namespace.ɵɵFactoryTarget.Component });
    ConsentManagementFormComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: ConsentManagementFormComponent, selector: "cx-consent-management-form", inputs: { consentTemplate: "consentTemplate", requiredConsents: "requiredConsents", consent: "consent" }, outputs: { consentChanged: "consentChanged" }, ngImport: i0__namespace, template: "<div class=\"form-check\">\n  <label>\n    <input\n      type=\"checkbox\"\n      class=\"form-check-input\"\n      (change)=\"onConsentChange()\"\n      [checked]=\"consentGiven\"\n      [disabled]=\"isRequired(consentTemplate?.id)\"\n    />\n    <span class=\"form-check-label cx-be-bold\">\n      {{ consentTemplate?.name }}\n    </span>\n    <br />\n    <span class=\"form-check-label\">\n      {{ consentTemplate?.description }}\n    </span>\n  </label>\n</div>\n" });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ConsentManagementFormComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-consent-management-form',
                        templateUrl: './consent-management-form.component.html',
                    }]
            }], ctorParameters: function () { return []; }, propDecorators: { consentTemplate: [{
                    type: i0.Input
                }], requiredConsents: [{
                    type: i0.Input
                }], consent: [{
                    type: i0.Input
                }], consentChanged: [{
                    type: i0.Output
                }] } });

    var AnonymousConsentDialogComponent = /** @class */ (function () {
        function AnonymousConsentDialogComponent(config, anonymousConsentsService, el, launchDialogService) {
            this.config = config;
            this.anonymousConsentsService = anonymousConsentsService;
            this.el = el;
            this.launchDialogService = launchDialogService;
            this.role = 'dialog';
            this.modal = true;
            this.subscriptions = new rxjs.Subscription();
            this.showLegalDescription = true;
            this.iconTypes = exports.ICON_TYPE;
            this.requiredConsents = [];
            this.focusConfig = {
                trap: true,
                block: true,
                autofocus: 'input[type="checkbox"]',
                focusOnEscape: true,
            };
            if (Boolean(this.config.anonymousConsents)) {
                this.showLegalDescription =
                    this.config.anonymousConsents.showLegalDescriptionInDialog;
                if (Boolean(this.config.anonymousConsents.requiredConsents)) {
                    this.requiredConsents = this.config.anonymousConsents.requiredConsents;
                }
            }
        }
        AnonymousConsentDialogComponent.prototype.handleClick = function (event) {
            // Close on click outside the dialog window
            if (event.target.tagName === this.el.nativeElement.tagName) {
                this.close('Cross click');
            }
        };
        AnonymousConsentDialogComponent.prototype.ngOnInit = function () {
            this.templates$ = this.anonymousConsentsService.getTemplates();
            this.consents$ = this.anonymousConsentsService.getConsents();
            this.loading$ = this.anonymousConsentsService.getLoadTemplatesLoading();
        };
        AnonymousConsentDialogComponent.prototype.close = function (reason) {
            this.launchDialogService.closeDialog(reason);
        };
        AnonymousConsentDialogComponent.prototype.rejectAll = function () {
            var _this = this;
            this.subscriptions.add(rxjs.combineLatest([this.templates$, this.consents$])
                .pipe(operators.take(1), operators.distinctUntilChanged(), operators.tap(function (_a) {
                var _b = __read(_a, 2), templates = _b[0], consents = _b[1];
                return templates.forEach(function (template) {
                    var consent = _this.getCorrespondingConsent(template, consents);
                    if (_this.anonymousConsentsService.isConsentGiven(consent)) {
                        if (_this.isRequiredConsent(template)) {
                            return;
                        }
                        _this.anonymousConsentsService.withdrawConsent(template.id);
                    }
                });
            }))
                .subscribe());
            this.close('rejectAll');
        };
        AnonymousConsentDialogComponent.prototype.allowAll = function () {
            var _this = this;
            this.subscriptions.add(rxjs.combineLatest([this.templates$, this.consents$])
                .pipe(operators.take(1), operators.distinctUntilChanged(), operators.tap(function (_a) {
                var _b = __read(_a, 2), templates = _b[0], consents = _b[1];
                return templates.forEach(function (template) {
                    var consent = _this.getCorrespondingConsent(template, consents);
                    if ((consent && consent.consentState == null) ||
                        _this.anonymousConsentsService.isConsentWithdrawn(consent)) {
                        if (_this.isRequiredConsent(template)) {
                            return;
                        }
                        _this.anonymousConsentsService.giveConsent(template.id);
                    }
                });
            }))
                .subscribe());
            this.close('allowAll');
        };
        AnonymousConsentDialogComponent.prototype.isRequiredConsent = function (template) {
            return (Boolean(this.config.anonymousConsents) &&
                Boolean(this.config.anonymousConsents.requiredConsents) &&
                this.config.anonymousConsents.requiredConsents.includes(template.id));
        };
        AnonymousConsentDialogComponent.prototype.onConsentChange = function (_a) {
            var given = _a.given, template = _a.template;
            if (given) {
                this.anonymousConsentsService.giveConsent(template.id);
            }
            else {
                this.anonymousConsentsService.withdrawConsent(template.id);
            }
        };
        AnonymousConsentDialogComponent.prototype.getCorrespondingConsent = function (template, consents) {
            var e_1, _a;
            if (consents === void 0) { consents = []; }
            try {
                for (var consents_1 = __values(consents), consents_1_1 = consents_1.next(); !consents_1_1.done; consents_1_1 = consents_1.next()) {
                    var consent = consents_1_1.value;
                    if (template.id === consent.templateCode) {
                        return consent;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (consents_1_1 && !consents_1_1.done && (_a = consents_1.return)) _a.call(consents_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return null;
        };
        AnonymousConsentDialogComponent.prototype.ngOnDestroy = function () {
            this.subscriptions.unsubscribe();
        };
        return AnonymousConsentDialogComponent;
    }());
    AnonymousConsentDialogComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AnonymousConsentDialogComponent, deps: [{ token: i1__namespace.AnonymousConsentsConfig }, { token: i1__namespace.AnonymousConsentsService }, { token: i0__namespace.ElementRef }, { token: LaunchDialogService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    AnonymousConsentDialogComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: AnonymousConsentDialogComponent, selector: "cx-anonymous-consent-dialog", host: { listeners: { "click": "handleClick($event)" }, properties: { "attr.role": "this.role", "attr.aria-modal": "this.modal" } }, ngImport: i0__namespace, template: "<div\n  class=\"cx-anonymous-consent-dialog\"\n  [cxFocus]=\"focusConfig\"\n  (esc)=\"close('Escape clicked')\"\n>\n  <div class=\"cx-dialog-content\">\n    <div *ngIf=\"loading$ | async; else dialogBody\">\n      <cx-spinner></cx-spinner>\n    </div>\n    <ng-template #dialogBody>\n      <div class=\"cx-dialog-header\">\n        <h3>\n          {{ 'anonymousConsents.dialog.title' | cxTranslate }}\n        </h3>\n        <button\n          type=\"button\"\n          class=\"close\"\n          [attr.aria-label]=\"'common.close' | cxTranslate\"\n          (click)=\"close('Cross click')\"\n        >\n          <span aria-hidden=\"true\">\n            <cx-icon [type]=\"iconTypes.CLOSE\"></cx-icon>\n          </span>\n        </button>\n      </div>\n      <!-- Separator -->\n      <div class=\"cx-dialog-description\" *ngIf=\"showLegalDescription\">\n        {{ 'anonymousConsents.dialog.legalDescription' | cxTranslate }}\n        <div\n          class=\"cx-dialog-separator col-sm-12 d-xs-block d-sm-block d-md-none\"\n        ></div>\n      </div>\n      <!-- Actions -->\n      <div class=\"cx-dialog-buttons\">\n        <a tabindex=\"0\" class=\"btn-link cx-action-link\" (click)=\"rejectAll()\">{{\n          'anonymousConsents.dialog.clearAll' | cxTranslate\n        }}</a>\n        <a tabindex=\"0\" class=\"btn-link cx-action-link\" (click)=\"allowAll()\">{{\n          'anonymousConsents.dialog.selectAll' | cxTranslate\n        }}</a>\n      </div>\n      <!-- Modal Body -->\n      <div class=\"cx-dialog-body\" *ngIf=\"templates$ | async as templates\">\n        <ng-container *ngIf=\"consents$ | async as consents\">\n          <div\n            class=\"cx-dialog-row col-sm-12 col-md-6\"\n            *ngFor=\"let template of templates\"\n          >\n            <cx-consent-management-form\n              [consentTemplate]=\"template\"\n              [requiredConsents]=\"requiredConsents\"\n              [consent]=\"getCorrespondingConsent(template, consents)\"\n              (consentChanged)=\"onConsentChange($event)\"\n            ></cx-consent-management-form>\n          </div>\n        </ng-container>\n      </div>\n    </ng-template>\n  </div>\n</div>\n", components: [{ type: SpinnerComponent, selector: "cx-spinner" }, { type: IconComponent, selector: "cx-icon,[cxIcon]", inputs: ["cxIcon", "type"] }, { type: ConsentManagementFormComponent, selector: "cx-consent-management-form", inputs: ["consentTemplate", "requiredConsents", "consent"], outputs: ["consentChanged"] }], directives: [{ type: FocusDirective, selector: "[cxFocus]", inputs: ["cxFocus"] }, { type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3__namespace.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], pipes: { "async": i3__namespace.AsyncPipe, "cxTranslate": i1__namespace.TranslatePipe } });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AnonymousConsentDialogComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-anonymous-consent-dialog',
                        templateUrl: './anonymous-consent-dialog.component.html',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace.AnonymousConsentsConfig }, { type: i1__namespace.AnonymousConsentsService }, { type: i0__namespace.ElementRef }, { type: LaunchDialogService }]; }, propDecorators: { role: [{
                    type: i0.HostBinding,
                    args: ['attr.role']
                }], modal: [{
                    type: i0.HostBinding,
                    args: ['attr.aria-modal']
                }], handleClick: [{
                    type: i0.HostListener,
                    args: ['click', ['$event']]
                }] } });

    var defaultAnonymousConsentLayoutConfig = {
        launch: {
            ANONYMOUS_CONSENT: {
                inline: true,
                component: AnonymousConsentDialogComponent,
                dialogType: exports.DIALOG_TYPE.DIALOG,
            },
        },
    };

    var AnonymousConsentOpenDialogComponent = /** @class */ (function () {
        function AnonymousConsentOpenDialogComponent(vcr, launchDialogService) {
            this.vcr = vcr;
            this.launchDialogService = launchDialogService;
        }
        AnonymousConsentOpenDialogComponent.prototype.openDialog = function () {
            var dialog = this.launchDialogService.openDialog("ANONYMOUS_CONSENT" /* ANONYMOUS_CONSENT */, this.openElement, this.vcr);
            if (dialog) {
                dialog.pipe(operators.take(1)).subscribe();
            }
        };
        return AnonymousConsentOpenDialogComponent;
    }());
    AnonymousConsentOpenDialogComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AnonymousConsentOpenDialogComponent, deps: [{ token: i0__namespace.ViewContainerRef }, { token: LaunchDialogService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    AnonymousConsentOpenDialogComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: AnonymousConsentOpenDialogComponent, selector: "cx-anonymous-consent-open-dialog", viewQueries: [{ propertyName: "openElement", first: true, predicate: ["open"], descendants: true }], ngImport: i0__namespace, template: "<button #open class=\"btn btn-link\" (click)=\"openDialog()\">\n  {{ 'anonymousConsents.preferences' | cxTranslate }}\n</button>\n", pipes: { "cxTranslate": i1__namespace.TranslatePipe } });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AnonymousConsentOpenDialogComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-anonymous-consent-open-dialog',
                        templateUrl: './anonymous-consent-open-dialog.component.html',
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ViewContainerRef }, { type: LaunchDialogService }]; }, propDecorators: { openElement: [{
                    type: i0.ViewChild,
                    args: ['open']
                }] } });

    var AnonymousConsentManagementBannerModule = /** @class */ (function () {
        function AnonymousConsentManagementBannerModule() {
        }
        return AnonymousConsentManagementBannerModule;
    }());
    AnonymousConsentManagementBannerModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AnonymousConsentManagementBannerModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    AnonymousConsentManagementBannerModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AnonymousConsentManagementBannerModule, declarations: [AnonymousConsentManagementBannerComponent,
            AnonymousConsentOpenDialogComponent], imports: [i3.CommonModule,
            i1.I18nModule,
            i1.FeaturesConfigModule,
            KeyboardFocusModule], exports: [AnonymousConsentManagementBannerComponent,
            AnonymousConsentOpenDialogComponent] });
    AnonymousConsentManagementBannerModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AnonymousConsentManagementBannerModule, providers: [
            i1.provideConfig(defaultAnonymousConsentLayoutConfig),
            i1.provideDefaultConfig({
                cmsComponents: {
                    AnonymousConsentManagementBannerComponent: {
                        component: AnonymousConsentManagementBannerComponent,
                        deferLoading: i1.DeferLoadingStrategy.INSTANT,
                    },
                    AnonymousConsentOpenDialogComponent: {
                        component: AnonymousConsentOpenDialogComponent,
                    },
                },
            }),
        ], imports: [[
                i3.CommonModule,
                i1.I18nModule,
                i1.FeaturesConfigModule,
                KeyboardFocusModule,
            ]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AnonymousConsentManagementBannerModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [
                            i3.CommonModule,
                            i1.I18nModule,
                            i1.FeaturesConfigModule,
                            KeyboardFocusModule,
                        ],
                        providers: [
                            i1.provideConfig(defaultAnonymousConsentLayoutConfig),
                            i1.provideDefaultConfig({
                                cmsComponents: {
                                    AnonymousConsentManagementBannerComponent: {
                                        component: AnonymousConsentManagementBannerComponent,
                                        deferLoading: i1.DeferLoadingStrategy.INSTANT,
                                    },
                                    AnonymousConsentOpenDialogComponent: {
                                        component: AnonymousConsentOpenDialogComponent,
                                    },
                                },
                            }),
                        ],
                        declarations: [
                            AnonymousConsentManagementBannerComponent,
                            AnonymousConsentOpenDialogComponent,
                        ],
                        exports: [
                            AnonymousConsentManagementBannerComponent,
                            AnonymousConsentOpenDialogComponent,
                        ],
                    }]
            }] });

    /**
     * A service to handle modal
     */
    var ModalService = /** @class */ (function () {
        function ModalService(ngbModalService, applicationRef) {
            this.ngbModalService = ngbModalService;
            this.applicationRef = applicationRef;
            this.modals = [];
        }
        Object.defineProperty(ModalService.prototype, "rootComponent", {
            get: function () {
                var _a, _b, _c, _d;
                return (_d = (_c = (_b = (_a = this.applicationRef) === null || _a === void 0 ? void 0 : _a.components) === null || _b === void 0 ? void 0 : _b[0]) === null || _c === void 0 ? void 0 : _c.location) === null || _d === void 0 ? void 0 : _d.nativeElement;
            },
            enumerable: false,
            configurable: true
        });
        ModalService.prototype.open = function (content, options) {
            var activeModal;
            options = Object.assign({ container: this.rootComponent }, options);
            activeModal = this.ngbModalService.open(content, options);
            this.modals.push(activeModal);
            this.handleModalRemoveEvents(activeModal);
            return activeModal;
        };
        ModalService.prototype.handleModalRemoveEvents = function (modal) {
            var _this = this;
            modal.result.finally(function () {
                _this.modals = _this.modals.filter(function (m) { return m !== modal; });
            });
        };
        ModalService.prototype.getActiveModal = function () {
            var modal = this.modals[this.modals.length - 1];
            return modal ? modal : null;
        };
        ModalService.prototype.dismissActiveModal = function (reason) {
            var modal = this.getActiveModal();
            if (modal) {
                modal.dismiss(reason);
            }
        };
        ModalService.prototype.closeActiveModal = function (reason) {
            var modal = this.getActiveModal();
            if (modal) {
                modal.close(reason);
            }
        };
        return ModalService;
    }());
    ModalService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ModalService, deps: [{ token: i1__namespace$3.NgbModal }, { token: i0__namespace.ApplicationRef }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ModalService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ModalService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ModalService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace$3.NgbModal }, { type: i0__namespace.ApplicationRef }]; } });

    /**
     * Identifiers of outlets inside the cart details view.
     */
    exports.CartOutlets = void 0;
    (function (CartOutlets) {
        CartOutlets["ITEM"] = "cx-cart-item";
        CartOutlets["ITEM_DETAILS"] = "cx-cart-item.details";
        CartOutlets["ITEM_BUNDLE_DETAILS"] = "cx-cart-item.bundle-details";
    })(exports.CartOutlets || (exports.CartOutlets = {}));

    /**
     * Context source for `CartItemComponent`.
     *
     * `CartItemContext` should be injected instead in child components.
     */
    var CartItemContextSource = /** @class */ (function () {
        function CartItemContextSource() {
            this.compact$ = new rxjs.ReplaySubject(1);
            this.readonly$ = new rxjs.ReplaySubject(1);
            this.item$ = new rxjs.ReplaySubject(1);
            this.quantityControl$ = new rxjs.ReplaySubject(1);
            this.location$ = new rxjs.ReplaySubject(1);
            this.options$ = new rxjs.ReplaySubject(1);
        }
        return CartItemContextSource;
    }());
    CartItemContextSource.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartItemContextSource, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    CartItemContextSource.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartItemContextSource });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartItemContextSource, decorators: [{
                type: i0.Injectable
            }] });

    /**
     * Context for `CartItemComponent`.
     */
    var CartItemContext = /** @class */ (function () {
        function CartItemContext() {
        }
        return CartItemContext;
    }());
    CartItemContext.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartItemContext, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    CartItemContext.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartItemContext });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartItemContext, decorators: [{
                type: i0.Injectable
            }] });

    var CartValidationStateService = /** @class */ (function () {
        function CartValidationStateService(routingService) {
            var _this = this;
            this.routingService = routingService;
            this.NAVIGATION_SKIPS = 2;
            this.navigationIdCount = 0;
            this.subscription = new rxjs.Subscription();
            this.cartValidationResult$ = new rxjs.ReplaySubject(1);
            this.checkForValidationResultClear$ = this.routingService
                .getRouterState()
                .pipe(operators.withLatestFrom(this.cartValidationResult$), operators.tap(function (_a) {
                var _b = __read(_a, 2), routerState = _b[0], cartModifications = _b[1];
                if (_this.navigationIdCount + _this.NAVIGATION_SKIPS <=
                    routerState.navigationId &&
                    cartModifications.length) {
                    _this.cartValidationResult$.next([]);
                    _this.navigationIdCount = routerState.navigationId;
                }
            }));
            this.setInitialState();
        }
        CartValidationStateService.prototype.ngOnDestroy = function () {
            this.subscription.unsubscribe();
        };
        CartValidationStateService.prototype.setInitialState = function () {
            this.setNavigationIdStep();
            this.subscription.add(this.checkForValidationResultClear$.subscribe());
        };
        CartValidationStateService.prototype.updateValidationResultAndRoutingId = function (cartModification) {
            this.cartValidationResult$.next(cartModification);
            this.setNavigationIdStep();
        };
        CartValidationStateService.prototype.setNavigationIdStep = function () {
            var _this = this;
            this.routingService
                .getRouterState()
                .pipe(operators.take(1))
                .subscribe(function (routerState) { return (_this.navigationIdCount = routerState.navigationId); });
        };
        return CartValidationStateService;
    }());
    CartValidationStateService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartValidationStateService, deps: [{ token: i1__namespace.RoutingService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    CartValidationStateService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartValidationStateService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartValidationStateService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace.RoutingService }]; } });

    var CartItemValidationWarningComponent = /** @class */ (function () {
        function CartItemValidationWarningComponent(cartValidationStateService) {
            var _this = this;
            this.cartValidationStateService = cartValidationStateService;
            this.iconTypes = exports.ICON_TYPE;
            this.isVisible = true;
            this.cartModification$ = this.cartValidationStateService.cartValidationResult$.pipe(operators.map(function (modificationList) { return modificationList.find(function (modification) { return modification.entry.product.code === _this.code; }); }));
        }
        return CartItemValidationWarningComponent;
    }());
    CartItemValidationWarningComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartItemValidationWarningComponent, deps: [{ token: CartValidationStateService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    CartItemValidationWarningComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: CartItemValidationWarningComponent, selector: "cx-cart-item-validation-warning", inputs: { code: "code" }, ngImport: i0__namespace, template: "<ng-container *ngIf=\"cartModification$ | async as cartModification\">\n  <div class=\"alert alert-info\" *ngIf=\"isVisible\">\n    <span class=\"alert-icon\">\n      <cx-icon [type]=\"iconTypes.INFO\"></cx-icon>\n    </span>\n    <span>\n      {{\n        'validation.' + cartModification.statusCode\n          | cxTranslate\n            : {\n                quantity: cartModification.quantityAdded\n              }\n      }}\n    </span>\n\n    <button class=\"close\" type=\"button\" (click)=\"isVisible = !isVisible\">\n      <cx-icon [type]=\"iconTypes.CLOSE\"></cx-icon>\n    </button>\n  </div>\n</ng-container>\n", components: [{ type: IconComponent, selector: "cx-icon,[cxIcon]", inputs: ["cxIcon", "type"] }], directives: [{ type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "async": i3__namespace.AsyncPipe, "cxTranslate": i1__namespace.TranslatePipe }, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartItemValidationWarningComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-cart-item-validation-warning',
                        templateUrl: './cart-item-validation-warning.component.html',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], ctorParameters: function () { return [{ type: CartValidationStateService }]; }, propDecorators: { code: [{
                    type: i0.Input
                }] } });

    /**
     * Indicates how the browser should load the image.
     *
     * While this might not add too much value in some scenarios, as we have other
     * optimizations to defer loading of larger pieces of the DOM, there might be
     * components who haven't implemented other lazy loading techniques. Moreover,
     * a server sides rendered page that lands directly in the browser could benefit
     * enormously from the lazy loading of images.
     */
    exports.ImageLoadingStrategy = void 0;
    (function (ImageLoadingStrategy) {
        /**
         * Loads the image immediately, regardless of whether or not the image
         * is currently within the visible viewport (this is the default value).
         */
        ImageLoadingStrategy["EAGER"] = "eager";
        /**
         * Defers loading the image until it reaches a calculated distance from the viewport,
         * as defined by the browser. The intent is to avoid the network and storage bandwidth
         * needed to handle the image until it's reasonably certain that it will be needed.
         * This generally improves the performance of the content in most typical use cases.
         */
        ImageLoadingStrategy["LAZY"] = "lazy";
    })(exports.ImageLoadingStrategy || (exports.ImageLoadingStrategy = {}));

    /**
     * Service which generates media URLs. It leverage the MediaContainer and MediaFormats so
     * that URLs and sizes are generated for the same media. This helps to improve performance
     * across difference devices and layouts.
     *
     * Media formats are optional, but highly recommended. The format will help the browser to
     * identify the right media for the right experience.
     *
     * The MediaService will generate absolute URLs in case relative URLs are provided for the Media.
     * The baseUrl is read from the `occConfig.backend.media.baseUrl` or
     * `occConfig.backend.occ.baseUrl`.
     */
    var MediaService = /** @class */ (function () {
        function MediaService(config) {
            this.config = config;
        }
        /**
         * Returns a `Media` object with the main media (`src`) and various media (`src`)
         * for specific formats.
         */
        MediaService.prototype.getMedia = function (mediaContainer, format, alt, role) {
            if (!mediaContainer) {
                return;
            }
            var mainMedia = mediaContainer.url
                ? mediaContainer
                : this.resolveMedia(mediaContainer, format);
            return {
                src: this.resolveAbsoluteUrl(mainMedia === null || mainMedia === void 0 ? void 0 : mainMedia.url),
                alt: alt !== null && alt !== void 0 ? alt : mainMedia === null || mainMedia === void 0 ? void 0 : mainMedia.altText,
                role: role !== null && role !== void 0 ? role : mainMedia === null || mainMedia === void 0 ? void 0 : mainMedia.role,
                srcset: this.resolveSrcSet(mediaContainer, format),
            };
        };
        Object.defineProperty(MediaService.prototype, "loadingStrategy", {
            /**
             * Reads the loading strategy from the `MediaConfig`.
             *
             * Defaults to `ImageLoadingStrategy.EAGER`.
             */
            get: function () {
                var _a, _b;
                return ((_b = (_a = this.config) === null || _a === void 0 ? void 0 : _a.imageLoadingStrategy) !== null && _b !== void 0 ? _b : exports.ImageLoadingStrategy.EAGER);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MediaService.prototype, "sortedFormats", {
            /**
             * Creates the media formats in a logical sorted order. The map contains the
             * format key and the format size information. We do this only once for performance
             * benefits.
             */
            get: function () {
                var _this = this;
                var _a, _b;
                if (!this._sortedFormats && ((_a = this.config) === null || _a === void 0 ? void 0 : _a.mediaFormats)) {
                    this._sortedFormats = Object.keys(this.config.mediaFormats)
                        .map(function (key) { return ({
                        code: key,
                        size: _this.config.mediaFormats[key],
                    }); })
                        .sort(function (a, b) { return (a.size.width > b.size.width ? 1 : -1); });
                }
                return (_b = this._sortedFormats) !== null && _b !== void 0 ? _b : [];
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MediaService.prototype, "reversedFormats", {
            /**
             * Creates the media formats in a reversed sorted order.
             */
            get: function () {
                if (!this._reversedFormats) {
                    this._reversedFormats = this.sortedFormats.slice().reverse();
                }
                return this._reversedFormats;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Resolves the right media for the given format. The fo
         */
        MediaService.prototype.resolveMedia = function (media, format) {
            return media[this.resolveFormat(media, format)];
        };
        /**
         * Validates the format against the given mediaContainer. If there is no format available,
         * or if the mediaContainer doesn't contain a media for the given media, the most optimal
         * format is resolved. If even that is not possible, the first format is returned.
         */
        MediaService.prototype.resolveFormat = function (mediaContainer, format) {
            if (format && mediaContainer[format]) {
                return format;
            }
            return (this.resolveBestFormat(mediaContainer) || Object.keys(mediaContainer)[0]);
        };
        /**
         * Returns the media format code with the best size.
         */
        MediaService.prototype.resolveBestFormat = function (media) {
            var _a;
            return (_a = this.reversedFormats.find(function (format) { return media.hasOwnProperty(format.code); })) === null || _a === void 0 ? void 0 : _a.code;
        };
        /**
         * Returns a set of media for the available media formats. Additionally, the configured media
         * format width is added to the srcset, so that browsers can select the appropriate media.
         *
         * The optional maxFormat indicates that only sources till a certain format should be added
         * to the srcset.
         */
        MediaService.prototype.resolveSrcSet = function (media, maxFormat) {
            var _this = this;
            if (!media) {
                return undefined;
            }
            // Only create srcset images that are smaller than the given `maxFormat` (if any)
            var formats = this.sortedFormats;
            var max = formats.findIndex(function (f) { return f.code === maxFormat; });
            if (max > -1) {
                formats = formats.slice(0, max + 1);
            }
            var srcset = formats.reduce(function (set, format) {
                if (!!media[format.code]) {
                    if (set) {
                        set += ', ';
                    }
                    set += _this.resolveAbsoluteUrl(media[format.code].url) + " " + format.size.width + "w";
                }
                return set;
            }, '');
            return srcset === '' ? undefined : srcset;
        };
        /**
         * Resolves the absolute URL for the given url. In most cases, this URL represents
         * the relative URL on the backend. In that case, we prefix the url with the baseUrl.
         *
         * When we have receive an absolute URL, we return the URL as-is. An absolute URL might also
         * start with double slash, which is used to resolve media cross from http and https.
         */
        MediaService.prototype.resolveAbsoluteUrl = function (url) {
            return !url || url.startsWith('http') || url.startsWith('//')
                ? url
                : this.getBaseUrl() + url;
        };
        /**
         * The base URL is either driven by a specific `backend.media.baseUrl`, or by the
         * `backend.occ.baseUrl`.
         *
         * The `backend.media.baseUrl` can be used to load media from a different location.
         *
         * In Commerce Cloud, a different location could mean a different "aspect".
         *
         * Defaults to empty string in case no config is provided.
         */
        MediaService.prototype.getBaseUrl = function () {
            var _a, _b, _c, _d, _e, _f;
            return ((_f = (_c = (_b = (_a = this.config.backend) === null || _a === void 0 ? void 0 : _a.media) === null || _b === void 0 ? void 0 : _b.baseUrl) !== null && _c !== void 0 ? _c : (_e = (_d = this.config.backend) === null || _d === void 0 ? void 0 : _d.occ) === null || _e === void 0 ? void 0 : _e.baseUrl) !== null && _f !== void 0 ? _f : '');
        };
        return MediaService;
    }());
    MediaService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: MediaService, deps: [{ token: i1__namespace.Config }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    MediaService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: MediaService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: MediaService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace.Config }]; } });

    var MediaComponent = /** @class */ (function () {
        function MediaComponent(mediaService) {
            this.mediaService = mediaService;
            // TODO: Remove type forcing of `this.loadingStrategy` (ie. <ImageLoadingStrategy | null>) in 5.0 (#14236)
            /**
             * Set the loading strategy of the media. Defaults to global loading strategy.
             * Use 'lazy' or 'eager' strategies.
             */
            this.loading = (this.loadingStrategy);
            /**
             * Once the media is loaded, we emit an event.
             */
            this.loaded = new i0.EventEmitter();
            /**
             * The `cx-media` component has an `is-initialized` class as long as the
             * media is being initialized.
             */
            this.isInitialized = false;
            /**
             * The `cx-media` component has a `is-loading` class as long as the
             * media is loaded. Wehn the media is loaded, the `is-initialized` class
             * is added.
             */
            this.isLoading = true;
            /**
             * When there's no media provided for the content, or in case an error
             * happened during loading, we add the `is-missing` class. Visual effects
             * can be controlled by CSS.
             */
            this.isMissing = false;
        }
        MediaComponent.prototype.ngOnChanges = function () {
            this.create();
        };
        /**
         * Creates the `Media` object
         */
        MediaComponent.prototype.create = function () {
            var _a;
            this.media = this.mediaService.getMedia(this.container instanceof Array ? this.container[0] : this.container, this.format, this.alt, this.role);
            if (!((_a = this.media) === null || _a === void 0 ? void 0 : _a.src)) {
                this.handleMissing();
            }
        };
        /**
         * This handler is called from the UI when the image is loaded.
         */
        MediaComponent.prototype.loadHandler = function () {
            this.isLoading = false;
            this.isInitialized = true;
            this.isMissing = false;
            this.loaded.emit(true);
        };
        Object.defineProperty(MediaComponent.prototype, "loadingStrategy", {
            // TODO: Remove string return type (#14236)
            /**
             * Indicates whether the browser should lazy load the image.
             * @deprecated since 4.2. use ImageLoadingStrategy or null return types only
             */
            get: function () {
                return this.mediaService.loadingStrategy === exports.ImageLoadingStrategy.LAZY
                    ? exports.ImageLoadingStrategy.LAZY
                    : null;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Whenever an error happens during load, we mark the component
         * with css classes to have a missing media.
         */
        MediaComponent.prototype.errorHandler = function () {
            this.handleMissing();
        };
        MediaComponent.prototype.handleMissing = function () {
            this.isLoading = false;
            this.isInitialized = true;
            this.isMissing = true;
            this.loaded.emit(false);
        };
        return MediaComponent;
    }());
    MediaComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: MediaComponent, deps: [{ token: MediaService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    MediaComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: MediaComponent, selector: "cx-media", inputs: { container: "container", format: "format", alt: "alt", role: "role", loading: "loading" }, outputs: { loaded: "loaded" }, host: { properties: { "class.is-initialized": "this.isInitialized", "class.is-loading": "this.isLoading", "class.is-missing": "this.isMissing" } }, usesOnChanges: true, ngImport: i0__namespace, template: "<img\n  *ngIf=\"media?.src\"\n  [attr.src]=\"media.src\"\n  [attr.srcset]=\"media.srcset\"\n  [attr.alt]=\"media.alt\"\n  [attr.role]=\"media.role\"\n  [attr.loading]=\"loading\"\n  (load)=\"loadHandler()\"\n  (error)=\"errorHandler()\"\n/>\n", directives: [{ type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: MediaComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-media',
                        templateUrl: './media.component.html',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], ctorParameters: function () { return [{ type: MediaService }]; }, propDecorators: { container: [{
                    type: i0.Input
                }], format: [{
                    type: i0.Input
                }], alt: [{
                    type: i0.Input
                }], role: [{
                    type: i0.Input
                }], loading: [{
                    type: i0.Input
                }], loaded: [{
                    type: i0.Output
                }], isInitialized: [{
                    type: i0.HostBinding,
                    args: ['class.is-initialized']
                }], isLoading: [{
                    type: i0.HostBinding,
                    args: ['class.is-loading']
                }], isMissing: [{
                    type: i0.HostBinding,
                    args: ['class.is-missing']
                }] } });

    /**
     * Provides a UI to manage the count of the quantity, typically by using
     * increase and decrease functionality. The item counter expects an input `FormControl`
     * so that the state of the control can be managed outside of this component.
     */
    var ItemCounterComponent = /** @class */ (function () {
        function ItemCounterComponent() {
            /**
             * This can be used in case an item has a minmum order quantity.
             * @default 1
             */
            this.min = 1;
            /**
             * The step is used to increment the count. It is supposed to be a
             * positive integer or float.
             * @default 1
             */
            this.step = 1;
            /**
             * Indicates that the input can be manually set to zero,
             * despite the fact that the input controls will be limited to
             * the minimum. The zero value can be used to remove an item.
             */
            this.allowZero = false;
            /**
             * In readonly mode the item counter will only be shown as a label,
             * the form controls are not rendered.
             * Please not that readonly is different from the `disabled` form state.
             * @default false
             */
            this.readonly = false;
        }
        ItemCounterComponent.prototype.handleClick = function () {
            this.input.nativeElement.focus();
        };
        ItemCounterComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.sub = this.control.valueChanges
                .pipe(operators.startWith(this.control.value))
                .subscribe(function (value) { return _this.control.setValue(_this.getValidCount(value), { emitEvent: false }); });
        };
        ItemCounterComponent.prototype.ngOnDestroy = function () {
            if (this.sub) {
                this.sub.unsubscribe();
            }
        };
        ItemCounterComponent.prototype.increment = function () {
            // it's too early to use the `stepUp` and `stepDown` API...
            // let's wait for FF: https://caniuse.com/#search=stepUp
            this.control.setValue(this.control.value + this.step);
            this.control.markAsDirty();
        };
        ItemCounterComponent.prototype.decrement = function () {
            this.control.setValue(this.control.value - this.step);
            this.control.markAsDirty();
        };
        /**
         * Validate that the given value is in between
         * the `min` and `max` value. If the value is out
         * of  the min/max range, it will be altered.
         * If `allowZero` is set to true, the 0 value is ignored.
         *
         */
        ItemCounterComponent.prototype.getValidCount = function (value) {
            if (value < this.min && !(value === 0 && this.allowZero)) {
                value = this.min;
            }
            if (this.max && value > this.max) {
                value = this.max;
            }
            return value;
        };
        return ItemCounterComponent;
    }());
    ItemCounterComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ItemCounterComponent, deps: [], target: i0__namespace.ɵɵFactoryTarget.Component });
    ItemCounterComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: ItemCounterComponent, selector: "cx-item-counter", inputs: { control: "control", min: "min", max: "max", step: "step", allowZero: "allowZero", readonly: "readonly" }, host: { listeners: { "click": "handleClick()" }, properties: { "class.readonly": "this.readonly" } }, viewQueries: [{ propertyName: "input", first: true, predicate: ["qty"], descendants: true }], ngImport: i0__namespace, template: "<button\n  type=\"button\"\n  (click)=\"decrement()\"\n  [disabled]=\"control.disabled || control.value <= min\"\n  [tabindex]=\"control.disabled || control.value <= min ? -1 : 0\"\n  attr.aria-label=\"{{ 'itemCounter.removeOne' | cxTranslate }}\"\n>\n  -\n</button>\n<input\n  #qty\n  type=\"number\"\n  [min]=\"min\"\n  [max]=\"max\"\n  [step]=\"step\"\n  [readonly]=\"readonly\"\n  [tabindex]=\"readonly ? -1 : 0\"\n  [formControl]=\"control\"\n  attr.aria-label=\"{{ 'itemCounter.quantity' | cxTranslate }}\"\n/>\n<button\n  type=\"button\"\n  (click)=\"increment()\"\n  [disabled]=\"control.disabled || control.value >= max\"\n  tabindex=\"0\"\n  attr.aria-label=\"{{ 'itemCounter.addOneMore' | cxTranslate }}\"\n>\n  +\n</button>\n", directives: [{ type: i3__namespace$1.MinValidator, selector: "input[type=number][min][formControlName],input[type=number][min][formControl],input[type=number][min][ngModel]", inputs: ["min"] }, { type: i3__namespace$1.MaxValidator, selector: "input[type=number][max][formControlName],input[type=number][max][formControl],input[type=number][max][ngModel]", inputs: ["max"] }, { type: i3__namespace$1.NumberValueAccessor, selector: "input[type=number][formControlName],input[type=number][formControl],input[type=number][ngModel]" }, { type: i3__namespace$1.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { type: i3__namespace$1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i3__namespace$1.FormControlDirective, selector: "[formControl]", inputs: ["disabled", "formControl", "ngModel"], outputs: ["ngModelChange"], exportAs: ["ngForm"] }], pipes: { "cxTranslate": i1__namespace.TranslatePipe } });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ItemCounterComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-item-counter',
                        templateUrl: './item-counter.component.html',
                        // do not use OnPush change detection strategy as we would not
                        // get updates of other form control state (disabled). We want to have a
                        // disabled state in order to ensure that the control cannot be used while
                        // the cart is updated.
                    }]
            }], propDecorators: { control: [{
                    type: i0.Input
                }], min: [{
                    type: i0.Input
                }], max: [{
                    type: i0.Input
                }], step: [{
                    type: i0.Input
                }], allowZero: [{
                    type: i0.Input
                }], readonly: [{
                    type: i0.HostBinding,
                    args: ['class.readonly']
                }, {
                    type: i0.Input
                }], input: [{
                    type: i0.ViewChild,
                    args: ['qty']
                }], handleClick: [{
                    type: i0.HostListener,
                    args: ['click']
                }] } });

    var PromotionsComponent = /** @class */ (function () {
        function PromotionsComponent() {
        }
        return PromotionsComponent;
    }());
    PromotionsComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PromotionsComponent, deps: [], target: i0__namespace.ɵɵFactoryTarget.Component });
    PromotionsComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: PromotionsComponent, selector: "cx-promotions", inputs: { promotions: "promotions" }, ngImport: i0__namespace, template: "<div class=\"cx-promotions\" *ngIf=\"promotions\">\n  <ul *ngFor=\"let promotion of promotions\">\n    <li>{{ promotion.description }}</li>\n  </ul>\n</div>\n", directives: [{ type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3__namespace.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PromotionsComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-promotions',
                        templateUrl: './promotions.component.html',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], ctorParameters: function () { return []; }, propDecorators: { promotions: [{
                    type: i0.Input
                }] } });

    /**
     * Service to control the behavior of the DismissModalDirective
     */
    var ModalDirectiveService = /** @class */ (function () {
        function ModalDirectiveService() {
        }
        /**
         * Handler for the click event on the directive
         *
         * @param options.type    Action to perform after click - close or dismiss
         * @param options.reason  Reason for dismissing or closing the modal
         * @param url             url (optional) - exists only when the directive is also a `routerLink`.
         */
        ModalDirectiveService.prototype.onClick = function (options, activeModal, url) {
            var reason = options.reason;
            if (!reason && url) {
                reason = "Link click: " + url;
            }
            if (options.type === 'dismiss') {
                activeModal.dismiss(reason);
            }
            else if (options.type === 'close') {
                activeModal.close(reason);
            }
        };
        return ModalDirectiveService;
    }());
    ModalDirectiveService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ModalDirectiveService, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ModalDirectiveService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ModalDirectiveService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ModalDirectiveService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }] });
    /**
     * Directive to dismiss the modal on click
     */
    var ModalDirective = /** @class */ (function () {
        function ModalDirective(service, router, 
        // active modal can be injected only when the directive is projected inside modal
        activeModal, routerLink, routerLinkWithHref) {
            this.service = service;
            this.router = router;
            this.activeModal = activeModal;
            this.routerLink = routerLink;
            this.routerLinkWithHref = routerLinkWithHref;
        }
        /**
         * Returns URL in case when the directive is in the scope of a `routerLink` directive at the same time.
         */
        ModalDirective.prototype.getUrl = function () {
            var _a;
            var routerLink = (_a = this.routerLink) !== null && _a !== void 0 ? _a : this.routerLinkWithHref;
            return routerLink
                ? this.router.serializeUrl(routerLink.urlTree)
                : undefined;
        };
        ModalDirective.prototype.onClick = function () {
            if (this.activeModal) {
                this.service.onClick(this.options, this.activeModal, this.getUrl());
            }
        };
        Object.defineProperty(ModalDirective.prototype, "options", {
            /**
             * Converts the directive's inputs to the shape of modal directive options
             */
            get: function () {
                return { type: this.cxModal, reason: this.cxModalReason };
            },
            enumerable: false,
            configurable: true
        });
        return ModalDirective;
    }());
    ModalDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ModalDirective, deps: [{ token: ModalDirectiveService }, { token: i1__namespace$1.Router }, { token: i1__namespace$3.NgbActiveModal, optional: true }, { token: i1__namespace$1.RouterLink, optional: true }, { token: i1__namespace$1.RouterLinkWithHref, optional: true }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    ModalDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.5", type: ModalDirective, selector: "[cxModal]", inputs: { cxModal: "cxModal", cxModalReason: "cxModalReason" }, host: { listeners: { "click": "onClick()" } }, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ModalDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        selector: '[cxModal]',
                    }]
            }], ctorParameters: function () {
            return [{ type: ModalDirectiveService }, { type: i1__namespace$1.Router }, { type: i1__namespace$3.NgbActiveModal, decorators: [{
                            type: i0.Optional
                        }] }, { type: i1__namespace$1.RouterLink, decorators: [{
                            type: i0.Optional
                        }] }, { type: i1__namespace$1.RouterLinkWithHref, decorators: [{
                            type: i0.Optional
                        }] }];
        }, propDecorators: { cxModal: [{
                    type: i0.Input
                }], cxModalReason: [{
                    type: i0.Input
                }], onClick: [{
                    type: i0.HostListener,
                    args: ['click']
                }] } });

    var CartItemComponent = /** @class */ (function () {
        function CartItemComponent(cartItemContextSource) {
            this.cartItemContextSource = cartItemContextSource;
            this.compact = false;
            this.readonly = false;
            this.promotionLocation = i1.PromotionLocation.ActiveCart;
            // TODO: evaluate whether this is generic enough
            this.options = {
                isSaveForLater: false,
                optionalBtn: null,
            };
            this.iconTypes = exports.ICON_TYPE;
            this.CartOutlets = exports.CartOutlets;
        }
        CartItemComponent.prototype.ngOnChanges = function (changes) {
            if (changes === null || changes === void 0 ? void 0 : changes.compact) {
                this.cartItemContextSource.compact$.next(this.compact);
            }
            if (changes === null || changes === void 0 ? void 0 : changes.readonly) {
                this.cartItemContextSource.readonly$.next(this.readonly);
            }
            if (changes === null || changes === void 0 ? void 0 : changes.item) {
                this.cartItemContextSource.item$.next(this.item);
            }
            if (changes === null || changes === void 0 ? void 0 : changes.quantityControl) {
                this.cartItemContextSource.quantityControl$.next(this.quantityControl);
            }
            if (changes === null || changes === void 0 ? void 0 : changes.promotionLocation) {
                this.cartItemContextSource.location$.next(this.promotionLocation);
            }
            if (changes === null || changes === void 0 ? void 0 : changes.options) {
                this.cartItemContextSource.options$.next(this.options);
            }
        };
        CartItemComponent.prototype.isProductOutOfStock = function (product) {
            // TODO Move stocklevelstatuses across the app to an enum
            return (product &&
                product.stock &&
                product.stock.stockLevelStatus === 'outOfStock');
        };
        CartItemComponent.prototype.removeItem = function () {
            this.quantityControl.setValue(0);
            this.quantityControl.markAsDirty();
        };
        return CartItemComponent;
    }());
    CartItemComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartItemComponent, deps: [{ token: CartItemContextSource }], target: i0__namespace.ɵɵFactoryTarget.Component });
    CartItemComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: CartItemComponent, selector: "cx-cart-item", inputs: { compact: "compact", item: "item", readonly: "readonly", quantityControl: "quantityControl", promotionLocation: "promotionLocation", options: "options" }, providers: [
            CartItemContextSource,
            { provide: CartItemContext, useExisting: CartItemContextSource },
        ], usesOnChanges: true, ngImport: i0__namespace, template: "<!-- Item Start Outlet -->\n<ng-template [cxOutlet]=\"CartOutlets.ITEM\">\n  <ng-container *cxFeatureLevel=\"'4.2'\">\n    <cx-cart-item-validation-warning\n      [code]=\"item.product.code\"\n    ></cx-cart-item-validation-warning>\n  </ng-container>\n  <div [ngClass]=\"compact ? 'cx-compact row' : 'row'\">\n    <!-- Item Image -->\n    <div class=\"col-2 cx-image-container\">\n      <a\n        [routerLink]=\"{ cxRoute: 'product', params: item.product } | cxUrl\"\n        cxModal=\"dismiss\"\n        tabindex=\"-1\"\n      >\n        <cx-media\n          [container]=\"item.product.images?.PRIMARY\"\n          format=\"cartIcon\"\n        ></cx-media>\n      </a>\n    </div>\n    <!-- Item Information -->\n    <div class=\"cx-info col-10\">\n      <div class=\"cx-info-container row\">\n        <!-- Item Description -->\n        <div [ngClass]=\"compact ? '' : ' col-md-3 col-lg-3 col-xl-5'\">\n          <div *ngIf=\"item.product.name\" class=\"cx-name\">\n            <a\n              class=\"cx-link\"\n              [routerLink]=\"\n                { cxRoute: 'product', params: item.product } | cxUrl\n              \"\n              cxModal=\"dismiss\"\n              ><h2>{{ item.product.name }}</h2></a\n            >\n          </div>\n          <div *ngIf=\"item.product.code\" class=\"cx-code\">\n            {{ 'cartItems.id' | cxTranslate }} {{ item.product.code }}\n          </div>\n\n          <!-- Item Details Outlet -->\n          <ng-template [cxOutlet]=\"CartOutlets.ITEM_DETAILS\"> </ng-template>\n\n          <!-- Variants -->\n          <ng-container *ngIf=\"item.product.baseOptions?.length\">\n            <div\n              *ngFor=\"\n                let variant of item.product.baseOptions[0]?.selected\n                  ?.variantOptionQualifiers\n              \"\n              class=\"cx-property\"\n            >\n              <div class=\"cx-label\" *ngIf=\"variant.name && variant.value\">\n                {{ variant.name }}: {{ variant.value }}\n              </div>\n            </div>\n          </ng-container>\n        </div>\n        <!-- Item Price -->\n        <div\n          *ngIf=\"item.basePrice\"\n          class=\"cx-price\"\n          [ngClass]=\"compact ? '' : ' col-md-3 col-lg-3 col-xl-2'\"\n        >\n          <div\n            class=\"cx-label\"\n            [ngClass]=\"compact ? '' : ' d-block d-md-none d-lg-none d-xl-none'\"\n          >\n            {{ 'cartItems.itemPrice' | cxTranslate }}\n          </div>\n          <div *ngIf=\"item.basePrice\" class=\"cx-value\">\n            {{ item.basePrice?.formattedValue }}\n          </div>\n        </div>\n        <!-- Item Quantity -->\n        <div class=\"cx-quantity\" [ngClass]=\"compact ? '' : ' col-3'\">\n          <div\n            class=\"cx-label\"\n            [ngClass]=\"compact ? '' : ' d-block d-md-none d-lg-none d-xl-none'\"\n            placement=\"left\"\n            title=\"{{ 'cartItems.quantityTitle' | cxTranslate }}\"\n          >\n            {{ 'cartItems.quantity' | cxTranslate }}\n          </div>\n          <div class=\"cx-value\" [class.readonly-value]=\"readonly\">\n            <cx-item-counter\n              [control]=\"quantityControl\"\n              [readonly]=\"\n                !item.updateable || readonly || options.isSaveForLater\n              \"\n              [max]=\"item.product.stock?.stockLevel\"\n              [allowZero]=\"true\"\n            >\n            </cx-item-counter>\n          </div>\n        </div>\n        <!-- Total -->\n        <ng-container *ngIf=\"options.isSaveForLater; else total\">\n          <div\n            class=\"cx-total\"\n            [ngClass]=\"compact ? '' : ' col-md-3 col-lg-3 col-xl-2'\"\n          >\n            <div\n              class=\"cx-label\"\n              [ngClass]=\"\n                compact ? '' : ' d-block d-md-none d-lg-none d-xl-none'\n              \"\n            >\n              {{ 'saveForLaterItems.stock' | cxTranslate }}\n            </div>\n            <div\n              *ngIf=\"item.product?.stock?.stockLevel >= 0; else forceInstock\"\n              class=\"cx-value\"\n            >\n              {{ item.product.stock.stockLevel }}\n            </div>\n            <ng-template #forceInstock>\n              <div class=\"cx-value\">\n                {{ 'saveForLaterItems.forceInStock' | cxTranslate }}\n              </div>\n            </ng-template>\n          </div>\n        </ng-container>\n      </div>\n      <!-- Availability -->\n      <div\n        *ngIf=\"isProductOutOfStock(item.product)\"\n        class=\"cx-availability col-12\"\n      >\n        {{ 'addToCart.outOfStock' | cxTranslate }}\n      </div>\n\n      <!-- Item Bundle Details Outlet -->\n      <ng-template [cxOutlet]=\"CartOutlets.ITEM_BUNDLE_DETAILS\"> </ng-template>\n\n      <!-- Promotion -->\n\n      <cx-promotions [promotions]=\"item.promotions\"></cx-promotions>\n\n      <!-- Actions -->\n      <div\n        *ngIf=\"(!readonly || options.isSaveForLater) && item.updateable\"\n        class=\"cx-actions col-12\"\n      >\n        <ng-container *ngIf=\"!isProductOutOfStock(item.product)\">\n          <ng-container\n            *ngTemplateOutlet=\"\n              options.optionalBtn;\n              context: {\n                $implicit: { loading: quantityControl.disabled, item: item }\n              }\n            \"\n          ></ng-container>\n        </ng-container>\n\n        <div class=\"col-md-3 cx-remove-btn\">\n          <button\n            class=\"link cx-action-link\"\n            [disabled]=\"quantityControl.disabled\"\n            (click)=\"removeItem()\"\n            attr.aria-label=\"{{ 'addToCart.removeFromCart' | cxTranslate }}\"\n          >\n            {{ 'common.remove' | cxTranslate }}\n          </button>\n        </div>\n      </div>\n    </div>\n  </div>\n\n  <ng-template #total>\n    <div\n      *ngIf=\"item.totalPrice\"\n      class=\"cx-total\"\n      [ngClass]=\"compact ? '' : ' col-md-3 col-xl-2'\"\n    >\n      <div\n        class=\"cx-label\"\n        [ngClass]=\"compact ? '' : ' d-block d-md-none d-lg-none d-xl-none'\"\n      >\n        {{ 'cartItems.total' | cxTranslate }}\n      </div>\n      <div class=\"cx-value\">{{ item.totalPrice.formattedValue }}</div>\n    </div>\n  </ng-template>\n</ng-template>\n", components: [{ type: CartItemValidationWarningComponent, selector: "cx-cart-item-validation-warning", inputs: ["code"] }, { type: MediaComponent, selector: "cx-media", inputs: ["container", "format", "alt", "role", "loading"], outputs: ["loaded"] }, { type: ItemCounterComponent, selector: "cx-item-counter", inputs: ["control", "min", "max", "step", "allowZero", "readonly"] }, { type: PromotionsComponent, selector: "cx-promotions", inputs: ["promotions"] }], directives: [{ type: OutletDirective, selector: "[cxOutlet]", inputs: ["cxOutlet", "cxOutletContext", "cxOutletDefer"], outputs: ["loaded"] }, { type: i1__namespace.FeatureLevelDirective, selector: "[cxFeatureLevel]", inputs: ["cxFeatureLevel"] }, { type: i3__namespace.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { type: i1__namespace$1.RouterLinkWithHref, selector: "a[routerLink],area[routerLink]", inputs: ["routerLink", "target", "queryParams", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange", "replaceUrl", "state", "relativeTo"] }, { type: ModalDirective, selector: "[cxModal]", inputs: ["cxModal", "cxModalReason"] }, { type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3__namespace.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i3__namespace.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }], pipes: { "cxUrl": i1__namespace.UrlPipe, "cxTranslate": i1__namespace.TranslatePipe } });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartItemComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-cart-item',
                        templateUrl: './cart-item.component.html',
                        providers: [
                            CartItemContextSource,
                            { provide: CartItemContext, useExisting: CartItemContextSource },
                        ],
                    }]
            }], ctorParameters: function () { return [{ type: CartItemContextSource }]; }, propDecorators: { compact: [{
                    type: i0.Input
                }], item: [{
                    type: i0.Input
                }], readonly: [{
                    type: i0.Input
                }], quantityControl: [{
                    type: i0.Input
                }], promotionLocation: [{
                    type: i0.Input
                }], options: [{
                    type: i0.Input
                }] } });

    var AddedToCartDialogComponent = /** @class */ (function () {
        function AddedToCartDialogComponent(modalService, cartService) {
            this.modalService = modalService;
            this.cartService = cartService;
            this.iconTypes = exports.ICON_TYPE;
            this.promotionLocation = i1.PromotionLocation.ActiveCart;
            this.quantity = 0;
            this.modalIsOpen = false;
            this.form = new i3$1.FormGroup({});
        }
        /**
         * Returns an observable formControl with the quantity of the cartEntry,
         * but also updates the entry in case of a changed value.
         * The quantity can be set to zero in order to remove the entry.
         */
        AddedToCartDialogComponent.prototype.getQuantityControl = function () {
            var _this = this;
            if (!this.quantityControl$) {
                this.quantityControl$ = this.entry$.pipe(operators.filter(function (e) { return !!e; }), operators.map(function (entry) { return _this.getQuantityFormControl(entry); }), operators.switchMap(function () { return _this.form.valueChanges.pipe(
                // eslint-disable-next-line import/no-deprecated
                operators.startWith(null), operators.tap(function (valueChange) {
                    if (valueChange) {
                        _this.cartService.updateEntry(valueChange.entryNumber, valueChange.quantity);
                        if (valueChange.quantity === 0) {
                            _this.dismissModal('Removed');
                        }
                    }
                    else {
                        _this.form.markAsPristine();
                    }
                })); }), operators.map(function () { return _this.form.get('quantity'); }), operators.shareReplay({ bufferSize: 1, refCount: true }));
            }
            return this.quantityControl$;
        };
        AddedToCartDialogComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.addedEntryWasMerged$ = this.loaded$.pipe(operators.filter(function (loaded) { return loaded; }), operators.switchMapTo(this.cartService.getEntries()), operators.map(function (entries) { return entries.length === _this.numberOfEntriesBeforeAdd; }));
        };
        /**
         * Adds quantity and entryNumber form controls to the FormGroup.
         * Returns quantity form control.
         */
        AddedToCartDialogComponent.prototype.getQuantityFormControl = function (entry) {
            if (!this.form.get('quantity')) {
                var quantity = new i3$1.FormControl(entry.quantity, { updateOn: 'blur' });
                this.form.addControl('quantity', quantity);
                var entryNumber = new i3$1.FormControl(entry.entryNumber);
                this.form.addControl('entryNumber', entryNumber);
            }
            return this.form.get('quantity');
        };
        AddedToCartDialogComponent.prototype.dismissModal = function (reason) {
            this.modalService.dismissActiveModal(reason);
        };
        return AddedToCartDialogComponent;
    }());
    AddedToCartDialogComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AddedToCartDialogComponent, deps: [{ token: ModalService }, { token: i1__namespace.ActiveCartService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    AddedToCartDialogComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: AddedToCartDialogComponent, selector: "cx-added-to-cart-dialog", viewQueries: [{ propertyName: "dialog", first: true, predicate: ["dialog"], descendants: true, read: i0.ElementRef }], ngImport: i0__namespace, template: "<div #dialog>\n  <!-- Modal Header -->\n  <ng-container *ngIf=\"(loaded$ | async) || modalIsOpen; else loading\">\n    <div class=\"cx-dialog-header modal-header\">\n      <div\n        class=\"cx-dialog-title modal-title\"\n        aria-live=\"polite\"\n        aria-atomic=\"true\"\n      >\n        {{\n          (addedEntryWasMerged$ | async)\n            ? ('addToCart.itemsIncrementedInYourCart' | cxTranslate)\n            : ('addToCart.itemsAddedToYourCart' | cxTranslate)\n        }}\n      </div>\n      <button\n        type=\"button\"\n        class=\"close\"\n        attr.aria-label=\"{{ 'addToCart.closeModal' | cxTranslate }}\"\n        cxModal=\"dismiss\"\n        cxModalReason=\"Cross click\"\n      >\n        <span aria-hidden=\"true\">\n          <cx-icon [type]=\"iconTypes.CLOSE\"></cx-icon>\n        </span>\n      </button>\n    </div>\n    <!-- Modal Body -->\n    <div class=\"cx-dialog-body modal-body\" *ngIf=\"entry$ | async as entry\">\n      <div class=\"cx-dialog-row\">\n        <div class=\"cx-dialog-item col-sm-12 col-md-6\">\n          <cx-cart-item\n            [item]=\"entry\"\n            [compact]=\"true\"\n            [quantityControl]=\"getQuantityControl() | async\"\n            [promotionLocation]=\"promotionLocation\"\n          ></cx-cart-item>\n        </div>\n        <!-- Separator -->\n        <div\n          class=\"cx-dialog-separator col-sm-12 d-xs-block d-sm-block d-md-none\"\n        ></div>\n        <!-- Total container -->\n        <div\n          class=\"cx-dialog-actions col-sm-12 col-md-6\"\n          *ngIf=\"cart$ | async as cart\"\n        >\n          <div class=\"cx-dialog-total\">\n            <div>\n              {{\n                'cartItems.cartTotal'\n                  | cxTranslate: { count: cart.deliveryItemsQuantity }\n              }}\n            </div>\n\n            <div>{{ cart.subTotal?.formattedValue }}</div>\n          </div>\n\n          <!-- Promotions -->\n          <div class=\"cx-dialog-promotions\">\n            <cx-promotions\n              [promotions]=\"\n                (cart.appliedOrderPromotions || []).concat(\n                  cart.potentialOrderPromotions || []\n                )\n              \"\n            ></cx-promotions>\n          </div>\n\n          <!-- Actions -->\n          <div class=\"cx-dialog-buttons\">\n            <a\n              [class.disabled]=\"form.dirty\"\n              [routerLink]=\"{ cxRoute: 'cart' } | cxUrl\"\n              cxModal=\"dismiss\"\n              cxModalReason=\"View Cart click\"\n              class=\"btn btn-primary\"\n              autofocus\n              >{{ 'addToCart.viewCart' | cxTranslate }}</a\n            >\n            <a\n              [class.disabled]=\"form.dirty\"\n              [routerLink]=\"{ cxRoute: 'checkout' } | cxUrl\"\n              cxModal=\"dismiss\"\n              cxModalReason=\"Proceed To Checkout click\"\n              class=\"btn btn-secondary\"\n              >{{ 'addToCart.proceedToCheckout' | cxTranslate }}</a\n            >\n          </div>\n        </div>\n      </div>\n    </div>\n  </ng-container>\n\n  <ng-template #loading>\n    <div class=\"cx-dialog-header modal-header\">\n      <div class=\"cx-dialog-title modal-title\">\n        {{ 'addToCart.updatingCart' | cxTranslate }}\n      </div>\n      <button\n        type=\"button\"\n        class=\"close\"\n        [attr.aria-label]=\"'common.close' | cxTranslate\"\n        cxModal=\"dismiss\"\n        cxModalReason=\"Cross click\"\n      >\n        <span aria-hidden=\"true\">\n          <cx-icon [type]=\"iconTypes.CLOSE\"></cx-icon>\n        </span>\n      </button>\n    </div>\n    <!-- Modal Body -->\n    <div class=\"cx-dialog-body modal-body\">\n      <div class=\"cx-dialog-row\">\n        <div class=\"col-sm-12\"><cx-spinner></cx-spinner></div>\n      </div>\n    </div>\n  </ng-template>\n</div>\n", components: [{ type: IconComponent, selector: "cx-icon,[cxIcon]", inputs: ["cxIcon", "type"] }, { type: CartItemComponent, selector: "cx-cart-item", inputs: ["compact", "item", "readonly", "quantityControl", "promotionLocation", "options"] }, { type: PromotionsComponent, selector: "cx-promotions", inputs: ["promotions"] }, { type: SpinnerComponent, selector: "cx-spinner" }], directives: [{ type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: ModalDirective, selector: "[cxModal]", inputs: ["cxModal", "cxModalReason"] }, { type: i1__namespace$1.RouterLinkWithHref, selector: "a[routerLink],area[routerLink]", inputs: ["routerLink", "target", "queryParams", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange", "replaceUrl", "state", "relativeTo"] }], pipes: { "async": i3__namespace.AsyncPipe, "cxTranslate": i1__namespace.TranslatePipe, "cxUrl": i1__namespace.UrlPipe } });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AddedToCartDialogComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-added-to-cart-dialog',
                        templateUrl: './added-to-cart-dialog.component.html',
                    }]
            }], ctorParameters: function () { return [{ type: ModalService }, { type: i1__namespace.ActiveCartService }]; }, propDecorators: { dialog: [{
                    type: i0.ViewChild,
                    args: ['dialog', { read: i0.ElementRef }]
                }] } });

    var CurrentProductService = /** @class */ (function () {
        function CurrentProductService(routingService, productService) {
            this.routingService = routingService;
            this.productService = productService;
            this.DEFAULT_PRODUCT_SCOPE = "details" /* DETAILS */;
        }
        /**
         * Returns an observable for the current product
         * @returns Product
         * @returns null if product can't be found
         *
         * @param scopes
         */
        CurrentProductService.prototype.getProduct = function (scopes) {
            var _this = this;
            return this.getCode().pipe(operators.distinctUntilChanged(), operators.switchMap(function (productCode) {
                return productCode
                    ? _this.productService.get(productCode, scopes || _this.DEFAULT_PRODUCT_SCOPE)
                    : rxjs.of(null);
            }), operators.filter(i1.isNotUndefined));
        };
        CurrentProductService.prototype.getCode = function () {
            return this.routingService
                .getRouterState()
                .pipe(operators.map(function (state) { return state.state.params['productCode']; }));
        };
        return CurrentProductService;
    }());
    CurrentProductService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CurrentProductService, deps: [{ token: i1__namespace.RoutingService }, { token: i1__namespace.ProductService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    CurrentProductService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CurrentProductService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CurrentProductService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace.RoutingService }, { type: i1__namespace.ProductService }]; } });

    var CmsComponentData = /** @class */ (function () {
        function CmsComponentData() {
        }
        return CmsComponentData;
    }());

    var AddToCartComponent = /** @class */ (function () {
        function AddToCartComponent(modalService, currentProductService, cd, activeCartService, component) {
            var _a;
            this.modalService = modalService;
            this.currentProductService = currentProductService;
            this.cd = cd;
            this.activeCartService = activeCartService;
            this.component = component;
            this.showQuantity = true;
            this.hasStock = false;
            this.inventoryThreshold = false;
            this.showInventory$ = (_a = this.component) === null || _a === void 0 ? void 0 : _a.data$.pipe(operators.map(function (data) { return data.inventoryDisplay; }));
            this.quantity = 1;
            this.numberOfEntriesBeforeAdd = 0;
            this.addToCartForm = new i3$1.FormGroup({
                quantity: new i3$1.FormControl(1, { updateOn: 'blur' }),
            });
        }
        AddToCartComponent.prototype.ngOnInit = function () {
            var _this = this;
            var _a;
            if (this.product) {
                this.productCode = (_a = this.product.code) !== null && _a !== void 0 ? _a : '';
                this.setStockInfo(this.product);
                this.cd.markForCheck();
            }
            else if (this.productCode) {
                // force hasStock and quantity for the time being, as we do not have more info:
                this.quantity = 1;
                this.hasStock = true;
                this.cd.markForCheck();
            }
            else {
                this.subscription = this.currentProductService
                    .getProduct()
                    .pipe(operators.filter(i1.isNotNullable))
                    .subscribe(function (product) {
                    var _a;
                    _this.productCode = (_a = product.code) !== null && _a !== void 0 ? _a : '';
                    _this.setStockInfo(product);
                    _this.cd.markForCheck();
                });
            }
        };
        AddToCartComponent.prototype.setStockInfo = function (product) {
            var _a, _b, _c, _d;
            this.quantity = 1;
            this.hasStock = Boolean(((_a = product.stock) === null || _a === void 0 ? void 0 : _a.stockLevelStatus) !== 'outOfStock');
            this.inventoryThreshold = (_c = (_b = product.stock) === null || _b === void 0 ? void 0 : _b.isValueRounded) !== null && _c !== void 0 ? _c : false;
            if (this.hasStock && ((_d = product.stock) === null || _d === void 0 ? void 0 : _d.stockLevel)) {
                this.maxQuantity = product.stock.stockLevel;
            }
        };
        /**
         * In specific scenarios, we need to omit displaying the stock level or append a plus to the value.
         * When backoffice forces a product to be in stock, omit showing the stock level.
         * When product stock level is limited by a threshold value, append '+' at the end.
         * When out of stock, display no numerical value.
         */
        AddToCartComponent.prototype.getInventory = function () {
            if (this.hasStock) {
                var quantityDisplay = this.maxQuantity
                    ? this.maxQuantity.toString()
                    : '';
                return this.inventoryThreshold ? quantityDisplay + '+' : quantityDisplay;
            }
            else {
                return '';
            }
        };
        AddToCartComponent.prototype.updateCount = function (value) {
            this.quantity = value;
        };
        AddToCartComponent.prototype.addToCart = function () {
            var _this = this;
            var quantity = this.addToCartForm.get('quantity').value;
            if (!this.productCode || quantity <= 0) {
                return;
            }
            this.activeCartService
                .getEntries()
                .pipe(operators.take(1))
                .subscribe(function (entries) {
                _this.numberOfEntriesBeforeAdd = entries.length;
                _this.openModal();
                _this.activeCartService.addEntry(_this.productCode, quantity);
            });
        };
        /**
         * Provides required data and opens AddedToCartDialogComponent modal
         */
        AddToCartComponent.prototype.openModal = function () {
            var modalInstance;
            this.modalRef = this.modalService.open(AddedToCartDialogComponent, {
                centered: true,
                size: 'lg',
            });
            modalInstance = this.modalRef.componentInstance;
            // Display last entry for new product code. This always corresponds to
            // our new item, independently of whether merging occured or not
            modalInstance.entry$ = this.activeCartService.getLastEntry(this.productCode);
            modalInstance.cart$ = this.activeCartService.getActive();
            modalInstance.loaded$ = this.activeCartService.isStable();
            modalInstance.quantity = this.quantity;
            modalInstance.numberOfEntriesBeforeAdd = this.numberOfEntriesBeforeAdd;
        };
        AddToCartComponent.prototype.ngOnDestroy = function () {
            if (this.subscription) {
                this.subscription.unsubscribe();
            }
        };
        return AddToCartComponent;
    }());
    AddToCartComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AddToCartComponent, deps: [{ token: ModalService }, { token: CurrentProductService }, { token: i0__namespace.ChangeDetectorRef }, { token: i1__namespace.ActiveCartService }, { token: CmsComponentData, optional: true }], target: i0__namespace.ɵɵFactoryTarget.Component });
    AddToCartComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: AddToCartComponent, selector: "cx-add-to-cart", inputs: { productCode: "productCode", showQuantity: "showQuantity", product: "product" }, ngImport: i0__namespace, template: "<form *ngIf=\"productCode\" [formGroup]=\"addToCartForm\" (submit)=\"addToCart()\">\n  <div class=\"quantity\" *ngIf=\"showQuantity\">\n    <label>{{ 'addToCart.quantity' | cxTranslate }}</label>\n    <cx-item-counter\n      *ngIf=\"hasStock\"\n      [max]=\"maxQuantity\"\n      [control]=\"addToCartForm.get('quantity')\"\n    ></cx-item-counter>\n\n    <span class=\"info\">\n      <span *ngIf=\"showInventory$ | async\">{{ getInventory() }}</span>\n      {{\n        hasStock\n          ? ('addToCart.inStock' | cxTranslate)\n          : ('addToCart.outOfStock' | cxTranslate)\n      }}</span\n    >\n  </div>\n\n  <button\n    *ngIf=\"hasStock\"\n    class=\"btn btn-primary btn-block\"\n    type=\"submit\"\n    [disabled]=\"quantity <= 0 || quantity > maxQuantity\"\n  >\n    {{ 'addToCart.addToCart' | cxTranslate }}\n  </button>\n</form>\n", components: [{ type: ItemCounterComponent, selector: "cx-item-counter", inputs: ["control", "min", "max", "step", "allowZero", "readonly"] }], directives: [{ type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3__namespace$1.ɵNgNoValidate, selector: "form:not([ngNoForm]):not([ngNativeValidate])" }, { type: i3__namespace$1.NgControlStatusGroup, selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { type: i3__namespace$1.FormGroupDirective, selector: "[formGroup]", inputs: ["formGroup"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }], pipes: { "cxTranslate": i1__namespace.TranslatePipe, "async": i3__namespace.AsyncPipe }, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AddToCartComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-add-to-cart',
                        templateUrl: './add-to-cart.component.html',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], ctorParameters: function () {
            return [{ type: ModalService }, { type: CurrentProductService }, { type: i0__namespace.ChangeDetectorRef }, { type: i1__namespace.ActiveCartService }, { type: CmsComponentData, decorators: [{
                            type: i0.Optional
                        }] }];
        }, propDecorators: { productCode: [{
                    type: i0.Input
                }], showQuantity: [{
                    type: i0.Input
                }], product: [{
                    type: i0.Input
                }] } });

    var SpinnerModule = /** @class */ (function () {
        function SpinnerModule() {
        }
        return SpinnerModule;
    }());
    SpinnerModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SpinnerModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    SpinnerModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SpinnerModule, declarations: [SpinnerComponent], imports: [i3.CommonModule, i1.I18nModule], exports: [SpinnerComponent] });
    SpinnerModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SpinnerModule, imports: [[i3.CommonModule, i1.I18nModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SpinnerModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [i3.CommonModule, i1.I18nModule],
                        declarations: [SpinnerComponent],
                        exports: [SpinnerComponent],
                    }]
            }] });

    var ConsentManagementComponent = /** @class */ (function () {
        function ConsentManagementComponent(userConsentService, globalMessageService, anonymousConsentsConfig, anonymousConsentsService, authService) {
            this.userConsentService = userConsentService;
            this.globalMessageService = globalMessageService;
            this.anonymousConsentsConfig = anonymousConsentsConfig;
            this.anonymousConsentsService = anonymousConsentsService;
            this.authService = authService;
            this.subscriptions = new rxjs.Subscription();
            this.allConsentsLoading = new rxjs.BehaviorSubject(false);
            this.requiredConsents = [];
        }
        ConsentManagementComponent.prototype.ngOnInit = function () {
            this.loading$ = rxjs.combineLatest([
                this.userConsentService.getConsentsResultLoading(),
                this.userConsentService.getGiveConsentResultLoading(),
                this.userConsentService.getWithdrawConsentResultLoading(),
                this.authService.isUserLoggedIn(),
                this.allConsentsLoading,
            ]).pipe(operators.map(function (_a) {
                var _b = __read(_a, 5), consentLoading = _b[0], giveConsentLoading = _b[1], withdrawConsentLoading = _b[2], isUserLoggedIn = _b[3], allConsentsLoading = _b[4];
                return consentLoading ||
                    giveConsentLoading ||
                    withdrawConsentLoading ||
                    !isUserLoggedIn ||
                    allConsentsLoading;
            }));
            this.consentListInit();
            this.giveConsentInit();
            this.withdrawConsentInit();
        };
        ConsentManagementComponent.prototype.consentListInit = function () {
            var _this = this;
            this.templateList$ = this.userConsentService.getConsents().pipe(operators.withLatestFrom(this.anonymousConsentsService.getTemplates(), this.authService.isUserLoggedIn()), operators.filter(function (_a) {
                var _b = __read(_a, 3), _templateList = _b[0], _anonymousTemplates = _b[1], isUserLoggedIn = _b[2];
                return isUserLoggedIn;
            }), operators.tap(function (_a) {
                var _b = __read(_a, 2), templateList = _b[0], _anonymousTemplates = _b[1];
                if (!_this.consentsExists(templateList)) {
                    _this.userConsentService.loadConsents();
                }
            }), operators.map(function (_a) {
                var _b = __read(_a, 2), templateList = _b[0], anonymousTemplates = _b[1];
                if (Boolean(_this.anonymousConsentsConfig.anonymousConsents)) {
                    if (Boolean(_this.anonymousConsentsConfig.anonymousConsents.requiredConsents)) {
                        _this.requiredConsents =
                            _this.anonymousConsentsConfig.anonymousConsents.requiredConsents;
                    }
                    if (Boolean(_this.anonymousConsentsConfig.anonymousConsents
                        .consentManagementPage)) {
                        return _this.hideAnonymousConsents(templateList, anonymousTemplates);
                    }
                }
                return templateList;
            }));
        };
        ConsentManagementComponent.prototype.hideAnonymousConsents = function (templateList, anonymousTemplates) {
            if (anonymousTemplates === void 0) { anonymousTemplates = []; }
            var hideTemplateIds = [];
            if (!this.anonymousConsentsConfig.anonymousConsents.consentManagementPage
                .showAnonymousConsents) {
                hideTemplateIds = anonymousTemplates.map(function (template) { return template.id; });
                return this.userConsentService.filterConsentTemplates(templateList, hideTemplateIds);
            }
            if (Boolean(this.anonymousConsentsConfig.anonymousConsents.consentManagementPage
                .hideConsents) &&
                this.anonymousConsentsConfig.anonymousConsents.consentManagementPage
                    .hideConsents.length > 0) {
                hideTemplateIds =
                    this.anonymousConsentsConfig.anonymousConsents.consentManagementPage
                        .hideConsents;
            }
            return this.userConsentService.filterConsentTemplates(templateList, hideTemplateIds);
        };
        ConsentManagementComponent.prototype.giveConsentInit = function () {
            var _this = this;
            this.userConsentService.resetGiveConsentProcessState();
            this.subscriptions.add(this.userConsentService
                .getGiveConsentResultSuccess()
                .subscribe(function (success) { return _this.onConsentGivenSuccess(success); }));
        };
        ConsentManagementComponent.prototype.withdrawConsentInit = function () {
            var _this = this;
            this.userConsentService.resetWithdrawConsentProcessState();
            this.subscriptions.add(this.userConsentService
                .getWithdrawConsentResultLoading()
                .pipe(operators.skipWhile(Boolean), operators.withLatestFrom(this.userConsentService.getWithdrawConsentResultSuccess()), operators.map(function (_a) {
                var _b = __read(_a, 2), withdrawalSuccess = _b[1];
                return withdrawalSuccess;
            }), operators.tap(function (withdrawalSuccess) {
                if (withdrawalSuccess) {
                    _this.userConsentService.loadConsents();
                }
            }))
                .subscribe(function (withdrawalSuccess) { return _this.onConsentWithdrawnSuccess(withdrawalSuccess); }));
        };
        ConsentManagementComponent.prototype.consentsExists = function (templateList) {
            return Boolean(templateList) && templateList.length > 0;
        };
        ConsentManagementComponent.prototype.onConsentChange = function (_a) {
            var given = _a.given, template = _a.template;
            if (given) {
                this.userConsentService.giveConsent(template.id, template.version);
            }
            else {
                this.userConsentService.withdrawConsent(template.currentConsent.code);
            }
        };
        ConsentManagementComponent.prototype.onConsentGivenSuccess = function (success) {
            if (success) {
                this.userConsentService.resetGiveConsentProcessState();
                this.globalMessageService.add({ key: 'consentManagementForm.message.success.given' }, i1.GlobalMessageType.MSG_TYPE_CONFIRMATION);
            }
        };
        ConsentManagementComponent.prototype.onConsentWithdrawnSuccess = function (success) {
            if (success) {
                this.userConsentService.resetWithdrawConsentProcessState();
                this.globalMessageService.add({ key: 'consentManagementForm.message.success.withdrawn' }, i1.GlobalMessageType.MSG_TYPE_CONFIRMATION);
            }
        };
        ConsentManagementComponent.prototype.rejectAll = function (templates) {
            var _this = this;
            if (templates === void 0) { templates = []; }
            var consentsToWithdraw = [];
            templates.forEach(function (template) {
                if (_this.userConsentService.isConsentGiven(template.currentConsent)) {
                    if (_this.isRequiredConsent(template)) {
                        return;
                    }
                    consentsToWithdraw.push(template);
                }
            });
            this.allConsentsLoading.next(true);
            this.subscriptions.add(this.setupWithdrawalStream(consentsToWithdraw)
                .pipe(operators.tap(function (_timesLoaded) { return _this.allConsentsLoading.next(false); }))
                .subscribe());
        };
        ConsentManagementComponent.prototype.setupWithdrawalStream = function (consentsToWithdraw) {
            var _this = this;
            if (consentsToWithdraw === void 0) { consentsToWithdraw = []; }
            var loading$ = rxjs.concat(this.userConsentService.getWithdrawConsentResultLoading()).pipe(operators.distinctUntilChanged(), operators.filter(function (loading) { return !loading; }));
            var count$ = loading$.pipe(operators.scan(function (acc, _value) { return acc + 1; }, -1));
            var withdraw$ = count$.pipe(operators.tap(function (i) {
                if (i < consentsToWithdraw.length) {
                    _this.userConsentService.withdrawConsent(consentsToWithdraw[i].currentConsent.code);
                }
            }));
            var checkTimesLoaded$ = withdraw$.pipe(operators.filter(function (timesLoaded) { return timesLoaded === consentsToWithdraw.length; }));
            return checkTimesLoaded$;
        };
        ConsentManagementComponent.prototype.allowAll = function (templates) {
            var _this = this;
            if (templates === void 0) { templates = []; }
            var consentsToGive = [];
            templates.forEach(function (template) {
                if (_this.userConsentService.isConsentWithdrawn(template.currentConsent)) {
                    if (_this.isRequiredConsent(template)) {
                        return;
                    }
                }
                consentsToGive.push(template);
            });
            this.allConsentsLoading.next(true);
            this.subscriptions.add(this.setupGiveStream(consentsToGive)
                .pipe(operators.tap(function (_timesLoaded) { return _this.allConsentsLoading.next(false); }))
                .subscribe());
        };
        ConsentManagementComponent.prototype.setupGiveStream = function (consentsToGive) {
            var _this = this;
            if (consentsToGive === void 0) { consentsToGive = []; }
            var loading$ = rxjs.concat(this.userConsentService.getGiveConsentResultLoading()).pipe(operators.distinctUntilChanged(), operators.filter(function (loading) { return !loading; }));
            var count$ = loading$.pipe(operators.scan(function (acc, _value) { return acc + 1; }, -1));
            var giveConsent$ = count$.pipe(operators.tap(function (i) {
                if (i < consentsToGive.length) {
                    _this.userConsentService.giveConsent(consentsToGive[i].id, consentsToGive[i].version);
                }
            }));
            var checkTimesLoaded$ = giveConsent$.pipe(operators.filter(function (timesLoaded) { return timesLoaded === consentsToGive.length; }));
            return checkTimesLoaded$;
        };
        ConsentManagementComponent.prototype.isRequiredConsent = function (template) {
            return (Boolean(this.anonymousConsentsConfig.anonymousConsents) &&
                Boolean(this.anonymousConsentsConfig.anonymousConsents.requiredConsents) &&
                this.anonymousConsentsConfig.anonymousConsents.requiredConsents.includes(template.id));
        };
        ConsentManagementComponent.prototype.ngOnDestroy = function () {
            this.subscriptions.unsubscribe();
            this.allConsentsLoading.unsubscribe();
            this.userConsentService.resetGiveConsentProcessState();
            this.userConsentService.resetWithdrawConsentProcessState();
        };
        return ConsentManagementComponent;
    }());
    ConsentManagementComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ConsentManagementComponent, deps: [{ token: i1__namespace.UserConsentService }, { token: i1__namespace.GlobalMessageService }, { token: i1__namespace.AnonymousConsentsConfig }, { token: i1__namespace.AnonymousConsentsService }, { token: i1__namespace.AuthService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    ConsentManagementComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: ConsentManagementComponent, selector: "cx-consent-management", ngImport: i0__namespace, template: "<div *ngIf=\"loading$ | async; else consentManagementForm\">\n  <div class=\"cx-spinner\">\n    <cx-spinner></cx-spinner>\n  </div>\n</div>\n\n<ng-template #consentManagementForm>\n  <ng-container *ngIf=\"templateList$ | async as templateList\">\n    <div class=\"cx-consent-action-links\">\n      <div class=\"col-sm-12 col-md-8 col-lg-6\">\n        <button\n          tabindex=\"0\"\n          class=\"btn btn-link cx-action-link\"\n          (click)=\"rejectAll(templateList)\"\n        >\n          {{ 'consentManagementForm.clearAll' | cxTranslate }}\n        </button>\n        <button\n          tabindex=\"0\"\n          class=\"btn btn-link cx-action-link\"\n          (click)=\"allowAll(templateList)\"\n        >\n          {{ 'consentManagementForm.selectAll' | cxTranslate }}\n        </button>\n      </div>\n    </div>\n\n    <div class=\"cx-consent-toggles\">\n      <div class=\"col-sm-12 col-md-8 col-lg-6\">\n        <cx-consent-management-form\n          *ngFor=\"let consentTemplate of templateList\"\n          [consentTemplate]=\"consentTemplate\"\n          [requiredConsents]=\"requiredConsents\"\n          (consentChanged)=\"onConsentChange($event)\"\n        ></cx-consent-management-form>\n      </div>\n    </div>\n  </ng-container>\n</ng-template>\n", components: [{ type: SpinnerComponent, selector: "cx-spinner" }, { type: ConsentManagementFormComponent, selector: "cx-consent-management-form", inputs: ["consentTemplate", "requiredConsents", "consent"], outputs: ["consentChanged"] }], directives: [{ type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3__namespace.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], pipes: { "async": i3__namespace.AsyncPipe, "cxTranslate": i1__namespace.TranslatePipe } });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ConsentManagementComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-consent-management',
                        templateUrl: './consent-management.component.html',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace.UserConsentService }, { type: i1__namespace.GlobalMessageService }, { type: i1__namespace.AnonymousConsentsConfig }, { type: i1__namespace.AnonymousConsentsService }, { type: i1__namespace.AuthService }]; } });

    var ConsentManagementModule = /** @class */ (function () {
        function ConsentManagementModule() {
        }
        return ConsentManagementModule;
    }());
    ConsentManagementModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ConsentManagementModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    ConsentManagementModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ConsentManagementModule, declarations: [ConsentManagementComponent, ConsentManagementFormComponent], imports: [i3.CommonModule,
            i3$1.FormsModule,
            i3$1.ReactiveFormsModule,
            SpinnerModule,
            i1.I18nModule,
            IconModule], exports: [ConsentManagementComponent, ConsentManagementFormComponent] });
    ConsentManagementModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ConsentManagementModule, providers: [
            i1.provideDefaultConfig({
                cmsComponents: {
                    ConsentManagementComponent: {
                        component: ConsentManagementComponent,
                        guards: [i1.AuthGuard],
                    },
                },
            }),
        ], imports: [[
                i3.CommonModule,
                i3$1.FormsModule,
                i3$1.ReactiveFormsModule,
                SpinnerModule,
                i1.I18nModule,
                IconModule,
            ]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ConsentManagementModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [
                            i3.CommonModule,
                            i3$1.FormsModule,
                            i3$1.ReactiveFormsModule,
                            SpinnerModule,
                            i1.I18nModule,
                            IconModule,
                        ],
                        providers: [
                            i1.provideDefaultConfig({
                                cmsComponents: {
                                    ConsentManagementComponent: {
                                        component: ConsentManagementComponent,
                                        guards: [i1.AuthGuard],
                                    },
                                },
                            }),
                        ],
                        declarations: [ConsentManagementComponent, ConsentManagementFormComponent],
                        exports: [ConsentManagementComponent, ConsentManagementFormComponent],
                    }]
            }] });

    var AnonymousConsentsDialogModule = /** @class */ (function () {
        function AnonymousConsentsDialogModule() {
        }
        return AnonymousConsentsDialogModule;
    }());
    AnonymousConsentsDialogModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AnonymousConsentsDialogModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    AnonymousConsentsDialogModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AnonymousConsentsDialogModule, declarations: [AnonymousConsentDialogComponent], imports: [i3.CommonModule,
            i1.I18nModule,
            IconModule,
            SpinnerModule,
            ConsentManagementModule,
            KeyboardFocusModule], exports: [AnonymousConsentDialogComponent] });
    AnonymousConsentsDialogModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AnonymousConsentsDialogModule, imports: [[
                i3.CommonModule,
                i1.I18nModule,
                IconModule,
                SpinnerModule,
                ConsentManagementModule,
                KeyboardFocusModule,
            ]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AnonymousConsentsDialogModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [
                            i3.CommonModule,
                            i1.I18nModule,
                            IconModule,
                            SpinnerModule,
                            ConsentManagementModule,
                            KeyboardFocusModule,
                        ],
                        declarations: [AnonymousConsentDialogComponent],
                        exports: [AnonymousConsentDialogComponent],
                    }]
            }] });

    exports.PopoverEvent = void 0;
    (function (PopoverEvent) {
        PopoverEvent["INSIDE_CLICK"] = "insideClick";
        PopoverEvent["OUTSIDE_CLICK"] = "outsideClick";
        PopoverEvent["ESCAPE_KEYDOWN"] = "escapeKeydown";
        PopoverEvent["CLOSE_BUTTON_CLICK"] = "closeButtonClick";
        PopoverEvent["CLOSE_BUTTON_KEYDOWN"] = "closeButtonKeydown";
        PopoverEvent["ROUTE_CHANGE"] = "routeChange";
        PopoverEvent["OPEN"] = "open";
        PopoverEvent["OPEN_BY_KEYBOARD"] = "openByKeyboard";
    })(exports.PopoverEvent || (exports.PopoverEvent = {}));

    var PositioningService = /** @class */ (function () {
        function PositioningService(winRef) {
            this.winRef = winRef;
        }
        Object.defineProperty(PositioningService.prototype, "allowedPlacements", {
            get: function () {
                return [
                    'top',
                    'bottom',
                    'left',
                    'right',
                    'top-left',
                    'top-right',
                    'bottom-left',
                    'bottom-right',
                    'left-top',
                    'left-bottom',
                    'right-top',
                    'right-bottom',
                ];
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(PositioningService.prototype, "placementSeparator", {
            get: function () {
                return /\s+/;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(PositioningService.prototype, "window", {
            get: function () {
                return this.winRef.nativeWindow;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(PositioningService.prototype, "document", {
            get: function () {
                return this.winRef.document;
            },
            enumerable: false,
            configurable: true
        });
        PositioningService.prototype.getAllStyles = function (element) {
            var _a;
            return (_a = this.window) === null || _a === void 0 ? void 0 : _a.getComputedStyle(element);
        };
        PositioningService.prototype.getPositionStyleProperty = function (element) {
            var styles = this.getAllStyles(element);
            if (styles)
                return styles['position'] || undefined;
        };
        PositioningService.prototype.isStaticPositioned = function (element) {
            return (this.getPositionStyleProperty(element) || 'static') === 'static';
        };
        PositioningService.prototype.offsetParent = function (element) {
            var offsetParentEl = element.offsetParent || this.document.documentElement;
            while (offsetParentEl &&
                offsetParentEl !== this.document.documentElement &&
                this.isStaticPositioned(offsetParentEl)) {
                offsetParentEl = offsetParentEl.offsetParent;
            }
            return offsetParentEl || this.document.documentElement;
        };
        PositioningService.prototype.position = function (element, round) {
            if (round === void 0) { round = true; }
            var elPosition;
            var parentOffset = {
                width: 0,
                height: 0,
                top: 0,
                bottom: 0,
                left: 0,
                right: 0,
            };
            if (this.getPositionStyleProperty(element) === 'fixed') {
                elPosition = element.getBoundingClientRect();
                elPosition = {
                    top: elPosition.top,
                    bottom: elPosition.bottom,
                    left: elPosition.left,
                    right: elPosition.right,
                    height: elPosition.height,
                    width: elPosition.width,
                };
            }
            else {
                var offsetParentEl = this.offsetParent(element);
                elPosition = this.offset(element, false);
                if (offsetParentEl !== this.document.documentElement) {
                    parentOffset = this.offset(offsetParentEl, false);
                }
                parentOffset.top += offsetParentEl.clientTop;
                parentOffset.left += offsetParentEl.clientLeft;
            }
            elPosition.top -= parentOffset.top;
            elPosition.bottom -= parentOffset.top;
            elPosition.left -= parentOffset.left;
            elPosition.right -= parentOffset.left;
            if (round) {
                elPosition.top = Math.round(elPosition.top);
                elPosition.bottom = Math.round(elPosition.bottom);
                elPosition.left = Math.round(elPosition.left);
                elPosition.right = Math.round(elPosition.right);
            }
            return elPosition;
        };
        PositioningService.prototype.offset = function (element, round) {
            if (round === void 0) { round = true; }
            var elBcr = element.getBoundingClientRect();
            var viewportOffset = {
                top: (this.window &&
                    this.window.pageYOffset - this.document.documentElement.clientTop) ||
                    0,
                left: (this.window &&
                    this.window.pageXOffset - this.document.documentElement.clientLeft) ||
                    0,
            };
            var elOffset = {
                height: elBcr.height || element.offsetHeight,
                width: elBcr.width || element.offsetWidth,
                top: elBcr.top + viewportOffset.top,
                bottom: elBcr.bottom + viewportOffset.top,
                left: elBcr.left + viewportOffset.left,
                right: elBcr.right + viewportOffset.left,
            };
            if (round) {
                elOffset.height = Math.round(elOffset.height);
                elOffset.width = Math.round(elOffset.width);
                elOffset.top = Math.round(elOffset.top);
                elOffset.bottom = Math.round(elOffset.bottom);
                elOffset.left = Math.round(elOffset.left);
                elOffset.right = Math.round(elOffset.right);
            }
            return elOffset;
        };
        /*
          Return false if the element to position is outside the viewport.
        */
        PositioningService.prototype._positionElements = function (hostElement, targetElement, placement, appendToBody) {
            var _a, _b;
            var _c = __read(placement.split('-'), 2), _d = _c[0], placementPrimary = _d === void 0 ? 'top' : _d, _e = _c[1], placementSecondary = _e === void 0 ? 'center' : _e;
            var hostElPosition = appendToBody
                ? this.offset(hostElement, false)
                : this.position(hostElement, false);
            var targetElStyles = this.getAllStyles(targetElement);
            if (targetElStyles) {
                var marginTop = parseFloat(targetElStyles.marginTop);
                var marginBottom = parseFloat(targetElStyles.marginBottom);
                var marginLeft = parseFloat(targetElStyles.marginLeft);
                var marginRight = parseFloat(targetElStyles.marginRight);
                var topPosition = 0;
                var leftPosition = 0;
                switch (placementPrimary) {
                    case 'top':
                        topPosition =
                            hostElPosition.top -
                                (targetElement.offsetHeight + marginTop + marginBottom);
                        break;
                    case 'bottom':
                        topPosition = hostElPosition.top + hostElPosition.height;
                        break;
                    case 'left':
                        leftPosition =
                            hostElPosition.left -
                                (targetElement.offsetWidth + marginLeft + marginRight);
                        break;
                    case 'right':
                        leftPosition = hostElPosition.left + hostElPosition.width;
                        break;
                }
                switch (placementSecondary) {
                    case 'top':
                        topPosition = hostElPosition.top;
                        break;
                    case 'bottom':
                        topPosition =
                            hostElPosition.top +
                                hostElPosition.height -
                                targetElement.offsetHeight;
                        break;
                    case 'left':
                        leftPosition = hostElPosition.left;
                        break;
                    case 'right':
                        leftPosition =
                            hostElPosition.left +
                                hostElPosition.width -
                                targetElement.offsetWidth;
                        break;
                    case 'center':
                        if (placementPrimary === 'top' || placementPrimary === 'bottom') {
                            leftPosition =
                                hostElPosition.left +
                                    hostElPosition.width / 2 -
                                    targetElement.offsetWidth / 2;
                        }
                        else {
                            topPosition =
                                hostElPosition.top +
                                    hostElPosition.height / 2 -
                                    targetElement.offsetHeight / 2;
                        }
                        break;
                }
                targetElement.style.transform = "translate(" + Math.round(leftPosition) + "px, " + Math.round(topPosition) + "px)";
                // Check if the targetElement is inside the viewport
                var targetElBCR = targetElement.getBoundingClientRect();
                var html = this.document.documentElement;
                var windowHeight = ((_a = this.window) === null || _a === void 0 ? void 0 : _a.innerHeight) || html.clientHeight;
                var windowWidth = ((_b = this.window) === null || _b === void 0 ? void 0 : _b.innerWidth) || html.clientWidth;
                return (targetElBCR.left >= 0 &&
                    targetElBCR.top >= 0 &&
                    targetElBCR.right <= windowWidth &&
                    targetElBCR.bottom <= windowHeight);
            }
            return false;
        };
        /*
         * Accept the placement array and applies the appropriate placement dependent on the viewport.
         * Returns the applied placement.
         * In case of auto placement, placements are selected in order
         *   'top', 'bottom', 'left', 'right',
         *   'top-left', 'top-right',
         *   'bottom-left', 'bottom-right',
         *   'left-top', 'left-bottom',
         *   'right-top', 'right-bottom'.
         * */
        PositioningService.prototype.positionElements = function (hostElement, targetElement, placement, appendToBody) {
            var e_1, _c;
            var placementVals = Array.isArray(placement)
                ? placement
                : placement.split(this.placementSeparator);
            var hasAuto = placementVals.findIndex(function (val) { return val === 'auto'; });
            if (hasAuto >= 0) {
                this.allowedPlacements.forEach(function (obj) {
                    if (placementVals.find(function (val) { return val.search('^' + obj) !== -1; }) == null) {
                        placementVals.splice(hasAuto++, 1, obj);
                    }
                });
            }
            var style = targetElement.style;
            style.position = 'absolute';
            style.top = '0';
            style.left = '0';
            var testPlacement = 'auto';
            var isInViewport = false;
            try {
                for (var placementVals_1 = __values(placementVals), placementVals_1_1 = placementVals_1.next(); !placementVals_1_1.done; placementVals_1_1 = placementVals_1.next()) {
                    testPlacement = placementVals_1_1.value;
                    if (this._positionElements(hostElement, targetElement, testPlacement, appendToBody)) {
                        isInViewport = true;
                        break;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (placementVals_1_1 && !placementVals_1_1.done && (_c = placementVals_1.return)) _c.call(placementVals_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            if (!isInViewport) {
                this._positionElements(hostElement, targetElement, testPlacement, appendToBody);
            }
            return testPlacement;
        };
        PositioningService.prototype.getPositioningClass = function (position, autoPositioning) {
            var positionClass = "" + (position || 'top');
            if (autoPositioning && positionClass !== 'auto') {
                positionClass = positionClass + " auto";
            }
            return positionClass;
        };
        return PositioningService;
    }());
    PositioningService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PositioningService, deps: [{ token: i1__namespace.WindowRef }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    PositioningService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PositioningService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PositioningService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace.WindowRef }]; } });

    var PopoverComponent = /** @class */ (function () {
        function PopoverComponent(positioningService, winRef, changeDetectionRef, renderer, router) {
            this.positioningService = positioningService;
            this.winRef = winRef;
            this.changeDetectionRef = changeDetectionRef;
            this.renderer = renderer;
            this.router = router;
            /**
             * Icon types for close button icon.
             */
            this.iconTypes = exports.ICON_TYPE;
        }
        /**
         * Listens for click inside popover component wrapper.
         */
        PopoverComponent.prototype.insideClick = function () {
            this.eventSubject.next(exports.PopoverEvent.INSIDE_CLICK);
        };
        /**
         * Listens for every document click and ignores clicks
         * inside component.
         */
        PopoverComponent.prototype.outsideClick = function (event) {
            if (!this.isClickedOnPopover(event) && !this.isClickedOnDirective(event)) {
                this.eventSubject.next(exports.PopoverEvent.OUTSIDE_CLICK);
            }
        };
        /**
         * Listens for `escape` keydown event.
         */
        PopoverComponent.prototype.escapeKeydown = function () {
            this.eventSubject.next(exports.PopoverEvent.ESCAPE_KEYDOWN);
        };
        PopoverComponent.prototype.isClickedOnPopover = function (event) {
            return this.popoverInstance.location.nativeElement.contains(event.target);
        };
        PopoverComponent.prototype.isClickedOnDirective = function (event) {
            return this.triggerElement.nativeElement.contains(event.target);
        };
        /**
         * Emits close event trigger.
         */
        PopoverComponent.prototype.close = function (event) {
            event.preventDefault();
            if (event instanceof MouseEvent) {
                this.eventSubject.next(exports.PopoverEvent.CLOSE_BUTTON_CLICK);
            }
            else {
                this.eventSubject.next(exports.PopoverEvent.CLOSE_BUTTON_KEYDOWN);
            }
        };
        /**
         * Method uses `Renderer2` service to listen window scroll event.
         *
         * Registered only if property `positionOnScroll` is set to `true`.
         */
        PopoverComponent.prototype.triggerScrollEvent = function () {
            var _this = this;
            this.scrollEventUnlistener = this.renderer.listen(this.winRef.nativeWindow, 'scroll', function () { return _this.positionPopover(); });
        };
        /**
         * Method uses positioning service calculation and based on that
         * updates class name for popover component instance.
         */
        PopoverComponent.prototype.positionPopover = function () {
            this.popoverClass = this.positioningService.positionElements(this.triggerElement.nativeElement, this.popoverInstance.location.nativeElement, this.positioningService.getPositioningClass(this.position, this.autoPositioning), this.appendToBody);
            this.changeDetectionRef.markForCheck();
            this.baseClass = this.customClass + " " + this.popoverClass + " opened";
        };
        PopoverComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.isTemplate = this.content instanceof i0.TemplateRef;
            if (!this.customClass)
                this.customClass = 'cx-popover';
            if (!this.position)
                this.position = 'top';
            if (this.autoPositioning === undefined)
                this.autoPositioning = true;
            this.baseClass = "" + this.customClass;
            this.resizeSub = this.winRef.resize$.subscribe(function () {
                _this.positionPopover();
            });
            this.routeChangeSub = this.router.events
                .pipe(operators.filter(function (event) { return event instanceof i1$1.NavigationStart; }))
                .subscribe(function () {
                _this.eventSubject.next(exports.PopoverEvent.ROUTE_CHANGE);
            });
            if (this.positionOnScroll) {
                this.triggerScrollEvent();
            }
        };
        PopoverComponent.prototype.ngAfterViewChecked = function () {
            this.positionPopover();
        };
        PopoverComponent.prototype.ngOnDestroy = function () {
            if (this.resizeSub) {
                this.resizeSub.unsubscribe();
            }
            if (this.routeChangeSub) {
                this.routeChangeSub.unsubscribe();
            }
            if (this.scrollEventUnlistener) {
                this.scrollEventUnlistener();
            }
        };
        return PopoverComponent;
    }());
    PopoverComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PopoverComponent, deps: [{ token: PositioningService }, { token: i1__namespace.WindowRef }, { token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.Renderer2 }, { token: i1__namespace$1.Router }], target: i0__namespace.ɵɵFactoryTarget.Component });
    PopoverComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: PopoverComponent, selector: "cx-popover", host: { listeners: { "click": "insideClick()", "document:click": "outsideClick($event)", "keydown.escape": "escapeKeydown()" }, properties: { "className": "this.baseClass" } }, ngImport: i0__namespace, template: "<div class=\"arrow\"></div>\n<div class=\"popover-body\" [cxFocus]=\"focusConfig\">\n  <div class=\"cx-close-row\">\n    <button\n      *ngIf=\"displayCloseButton\"\n      type=\"button\"\n      class=\"close\"\n      (keydown.enter)=\"close($event)\"\n      (keydown.space)=\"close($event)\"\n      (click)=\"close($event)\"\n    >\n      <cx-icon [type]=\"iconTypes.CLOSE\"></cx-icon>\n    </button>\n  </div>\n  <ng-container *ngIf=\"isTemplate\">\n    <ng-container *ngTemplateOutlet=\"content\"></ng-container>\n  </ng-container>\n  <span *ngIf=\"!isTemplate\">{{ content }}</span>\n</div>\n", components: [{ type: IconComponent, selector: "cx-icon,[cxIcon]", inputs: ["cxIcon", "type"] }], directives: [{ type: FocusDirective, selector: "[cxFocus]", inputs: ["cxFocus"] }, { type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3__namespace.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }], changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PopoverComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-popover',
                        templateUrl: './popover.component.html',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], ctorParameters: function () { return [{ type: PositioningService }, { type: i1__namespace.WindowRef }, { type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.Renderer2 }, { type: i1__namespace$1.Router }]; }, propDecorators: { baseClass: [{
                    type: i0.HostBinding,
                    args: ['className']
                }], insideClick: [{
                    type: i0.HostListener,
                    args: ['click']
                }], outsideClick: [{
                    type: i0.HostListener,
                    args: ['document:click', ['$event']]
                }], escapeKeydown: [{
                    type: i0.HostListener,
                    args: ['keydown.escape']
                }] } });

    var PopoverService = /** @class */ (function () {
        function PopoverService() {
        }
        /**
         * For a11y improvements method returns different `FocusConfig`
         * based on which event popover was triggered.
         */
        PopoverService.prototype.getFocusConfig = function (event, appendToBody) {
            var config = {};
            if (event === exports.PopoverEvent.OPEN_BY_KEYBOARD && appendToBody) {
                config = {
                    trap: true,
                    block: true,
                    focusOnEscape: false,
                    autofocus: true,
                };
            }
            return config;
        };
        PopoverService.prototype.setFocusOnElement = function (element, focusConfig, appendToBody) {
            if (focusConfig && appendToBody) {
                element.nativeElement.focus();
            }
        };
        return PopoverService;
    }());
    PopoverService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PopoverService, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    PopoverService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PopoverService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PopoverService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }] });

    /**
     * Directive to bind popover with any DOM element.
     */
    var PopoverDirective = /** @class */ (function () {
        function PopoverDirective(element, viewContainer, componentFactoryResolver, renderer, changeDetectorRef, popoverService, winRef) {
            this.element = element;
            this.viewContainer = viewContainer;
            this.componentFactoryResolver = componentFactoryResolver;
            this.renderer = renderer;
            this.changeDetectorRef = changeDetectorRef;
            this.popoverService = popoverService;
            this.winRef = winRef;
            /**
             * An event emitted when the popover is opened.
             */
            this.openPopover = new i0.EventEmitter();
            /**
             * An event emitted when the popover is closed.
             */
            this.closePopover = new i0.EventEmitter();
            /**
             * Subject which emits specific type of `PopoverEvent`.
             */
            this.eventSubject = new rxjs.Subject();
            this.openTriggerEvents = [
                exports.PopoverEvent.OPEN,
                exports.PopoverEvent.OPEN_BY_KEYBOARD,
            ];
            this.focusPopoverTriggerEvents = [
                exports.PopoverEvent.OPEN_BY_KEYBOARD,
            ];
            this.closeTriggerEvents = [
                exports.PopoverEvent.ROUTE_CHANGE,
                exports.PopoverEvent.ESCAPE_KEYDOWN,
                exports.PopoverEvent.OUTSIDE_CLICK,
                exports.PopoverEvent.CLOSE_BUTTON_KEYDOWN,
                exports.PopoverEvent.CLOSE_BUTTON_CLICK,
            ];
            this.focusDirectiveTriggerEvents = [
                exports.PopoverEvent.ESCAPE_KEYDOWN,
                exports.PopoverEvent.CLOSE_BUTTON_KEYDOWN,
            ];
        }
        /**
         * Listen events fired on element binded to popover directive.
         *
         * Based on event type some a11y improvements can be made.
         * For example if popover was opened by `space` or `enter` key
         * dedicated `FocusConfig` can be set to autofocus first
         * focusable element in popover container.
         */
        PopoverDirective.prototype.handlePress = function (event) {
            event === null || event === void 0 ? void 0 : event.preventDefault();
            if ((event === null || event === void 0 ? void 0 : event.target) === this.element.nativeElement && !this.isOpen) {
                this.eventSubject.next(exports.PopoverEvent.OPEN_BY_KEYBOARD);
            }
            else if (this.isOpen) {
                this.eventSubject.next(exports.PopoverEvent.CLOSE_BUTTON_KEYDOWN);
            }
        };
        PopoverDirective.prototype.handleTab = function () {
            var _a;
            if (!((_a = this.focusConfig) === null || _a === void 0 ? void 0 : _a.trap) && this.isOpen) {
                this.eventSubject.next(exports.PopoverEvent.CLOSE_BUTTON_KEYDOWN);
            }
        };
        PopoverDirective.prototype.handleEscape = function () {
            this.eventSubject.next(exports.PopoverEvent.ESCAPE_KEYDOWN);
        };
        PopoverDirective.prototype.handleClick = function (event) {
            event === null || event === void 0 ? void 0 : event.preventDefault();
            if ((event === null || event === void 0 ? void 0 : event.target) === this.element.nativeElement && !this.isOpen) {
                this.eventSubject.next(exports.PopoverEvent.OPEN);
            }
            else if (this.isOpen) {
                this.eventSubject.next(exports.PopoverEvent.CLOSE_BUTTON_CLICK);
            }
        };
        /**
         * Method performs open action for popover component.
         */
        PopoverDirective.prototype.open = function (event) {
            var _a, _b;
            if (!((_a = this.cxPopoverOptions) === null || _a === void 0 ? void 0 : _a.disable)) {
                this.isOpen = true;
                this.focusConfig = this.popoverService.getFocusConfig(event, ((_b = this.cxPopoverOptions) === null || _b === void 0 ? void 0 : _b.appendToBody) || false);
                this.renderPopover();
                this.openPopover.emit();
            }
        };
        /**
         * Method performs close action for popover component.
         */
        PopoverDirective.prototype.close = function () {
            this.isOpen = false;
            this.viewContainer.clear();
            this.closePopover.emit();
        };
        /**
         * Method subscribes for events emitted by popover component
         * and based on event performs specific action.
         */
        PopoverDirective.prototype.handlePopoverEvents = function () {
            var _this = this;
            this.eventSubject.subscribe(function (event) {
                var _a;
                if (_this.openTriggerEvents.includes(event)) {
                    _this.open(event);
                }
                if (_this.focusPopoverTriggerEvents.includes(event)) {
                    _this.popoverContainer.location.nativeElement.focus();
                }
                if (_this.closeTriggerEvents.includes(event)) {
                    _this.close();
                }
                if (_this.focusDirectiveTriggerEvents.includes(event)) {
                    _this.popoverService.setFocusOnElement(_this.element, _this.focusConfig, (_a = _this.cxPopoverOptions) === null || _a === void 0 ? void 0 : _a.appendToBody);
                }
            });
        };
        /**
         * Method creates instance and pass parameters to popover component.
         */
        PopoverDirective.prototype.renderPopover = function () {
            var _a, _b, _c, _d, _e, _f, _g;
            var containerFactory = this.componentFactoryResolver.resolveComponentFactory(PopoverComponent);
            this.popoverContainer =
                this.viewContainer.createComponent(containerFactory);
            var componentInstance = this.popoverContainer.instance;
            if (componentInstance) {
                componentInstance.content = this.cxPopover;
                componentInstance.triggerElement = this.element;
                componentInstance.popoverInstance = this.popoverContainer;
                componentInstance.focusConfig = this.focusConfig;
                componentInstance.eventSubject = this.eventSubject;
                componentInstance.position = (_a = this.cxPopoverOptions) === null || _a === void 0 ? void 0 : _a.placement;
                componentInstance.customClass = (_b = this.cxPopoverOptions) === null || _b === void 0 ? void 0 : _b.class;
                componentInstance.appendToBody = (_c = this.cxPopoverOptions) === null || _c === void 0 ? void 0 : _c.appendToBody;
                componentInstance.positionOnScroll =
                    (_d = this.cxPopoverOptions) === null || _d === void 0 ? void 0 : _d.positionOnScroll;
                componentInstance.displayCloseButton =
                    (_e = this.cxPopoverOptions) === null || _e === void 0 ? void 0 : _e.displayCloseButton;
                componentInstance.autoPositioning =
                    (_f = this.cxPopoverOptions) === null || _f === void 0 ? void 0 : _f.autoPositioning;
                if ((_g = this.cxPopoverOptions) === null || _g === void 0 ? void 0 : _g.appendToBody) {
                    this.renderer.appendChild(this.winRef.document.body, this.popoverContainer.location.nativeElement);
                }
                this.popoverContainer.changeDetectorRef.detectChanges();
            }
        };
        PopoverDirective.prototype.ngOnInit = function () {
            this.handlePopoverEvents();
        };
        return PopoverDirective;
    }());
    PopoverDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PopoverDirective, deps: [{ token: i0__namespace.ElementRef }, { token: i0__namespace.ViewContainerRef }, { token: i0__namespace.ComponentFactoryResolver }, { token: i0__namespace.Renderer2 }, { token: i0__namespace.ChangeDetectorRef }, { token: PopoverService }, { token: i1__namespace.WindowRef }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    PopoverDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.5", type: PopoverDirective, selector: "[cxPopover]", inputs: { cxPopover: "cxPopover", cxPopoverOptions: "cxPopoverOptions" }, outputs: { openPopover: "openPopover", closePopover: "closePopover" }, host: { listeners: { "keydown.enter": "handlePress($event)", "keydown.space": "handlePress($event)", "keydown.tab": "handleTab()", "keydown.shift.tab": "handleTab()", "keydown.escape": "handleEscape()", "click": "handleClick($event)" } }, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PopoverDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        selector: '[cxPopover]',
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ElementRef }, { type: i0__namespace.ViewContainerRef }, { type: i0__namespace.ComponentFactoryResolver }, { type: i0__namespace.Renderer2 }, { type: i0__namespace.ChangeDetectorRef }, { type: PopoverService }, { type: i1__namespace.WindowRef }]; }, propDecorators: { cxPopover: [{
                    type: i0.Input
                }], cxPopoverOptions: [{
                    type: i0.Input
                }], openPopover: [{
                    type: i0.Output
                }], closePopover: [{
                    type: i0.Output
                }], handlePress: [{
                    type: i0.HostListener,
                    args: ['keydown.enter', ['$event']]
                }, {
                    type: i0.HostListener,
                    args: ['keydown.space', ['$event']]
                }], handleTab: [{
                    type: i0.HostListener,
                    args: ['keydown.tab']
                }, {
                    type: i0.HostListener,
                    args: ['keydown.shift.tab']
                }], handleEscape: [{
                    type: i0.HostListener,
                    args: ['keydown.escape']
                }], handleClick: [{
                    type: i0.HostListener,
                    args: ['click', ['$event']]
                }] } });

    var defaultLimit = 20;
    var TruncatePipe = /** @class */ (function () {
        function TruncatePipe() {
        }
        /**
         * example usage {{ exampleString | cxTruncate: [1, ''] }}
         */
        TruncatePipe.prototype.transform = function (value, args) {
            if (!args) {
                return value;
            }
            var trail = '...';
            var limit = args.length > 0 && args[0] && Number.isInteger(+args[0])
                ? args[0]
                : defaultLimit;
            if (args.length > 1 && args[1] !== undefined) {
                trail = args[1];
            }
            return value.length > limit ? value.substring(0, limit) + trail : value;
        };
        return TruncatePipe;
    }());
    TruncatePipe.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: TruncatePipe, deps: [], target: i0__namespace.ɵɵFactoryTarget.Pipe });
    TruncatePipe.ɵpipe = i0__namespace.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: TruncatePipe, name: "cxTruncate" });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: TruncatePipe, decorators: [{
                type: i0.Pipe,
                args: [{
                        name: 'cxTruncate',
                    }]
            }] });

    var TruncateTextPopoverComponent = /** @class */ (function () {
        function TruncateTextPopoverComponent() {
            /**
             * The maximum length of the characters after which the text will be truncated
             */
            this.charactersLimit = 100;
        }
        Object.defineProperty(TruncateTextPopoverComponent.prototype, "isTruncated", {
            get: function () {
                return this.content.length > +this.charactersLimit;
            },
            enumerable: false,
            configurable: true
        });
        return TruncateTextPopoverComponent;
    }());
    TruncateTextPopoverComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: TruncateTextPopoverComponent, deps: [], target: i0__namespace.ɵɵFactoryTarget.Component });
    TruncateTextPopoverComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: TruncateTextPopoverComponent, selector: "cx-truncate-text-popover", inputs: { content: "content", charactersLimit: "charactersLimit" }, ngImport: i0__namespace, template: "<ng-container>\n  <ng-container>\n    <span class=\"truncated-text\">\n      {{ content | cxTruncate: [charactersLimit] }}\n    </span>\n  </ng-container>\n\n  <ng-template #fullText>\n    {{ content }}\n  </ng-template>\n\n  <button\n    *ngIf=\"isTruncated\"\n    [cxPopover]=\"fullText\"\n    [cxPopoverOptions]=\"{\n      placement: 'auto',\n      appendToBody: true,\n      displayCloseButton: true\n    }\"\n    class=\"ml-1 link cx-action-link\"\n  >\n    {{ 'common.more' | cxTranslate }}\n  </button>\n</ng-container>\n", directives: [{ type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: PopoverDirective, selector: "[cxPopover]", inputs: ["cxPopover", "cxPopoverOptions"], outputs: ["openPopover", "closePopover"] }], pipes: { "cxTruncate": TruncatePipe, "cxTranslate": i1__namespace.TranslatePipe }, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: TruncateTextPopoverComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-truncate-text-popover',
                        templateUrl: './truncate-text-popover.component.html',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], propDecorators: { content: [{
                    type: i0.Input
                }], charactersLimit: [{
                    type: i0.Input
                }] } });

    var CardComponent = /** @class */ (function () {
        function CardComponent() {
            this.iconTypes = exports.ICON_TYPE;
            this.deleteCard = new i0.EventEmitter();
            this.setDefaultCard = new i0.EventEmitter();
            this.sendCard = new i0.EventEmitter();
            this.editCard = new i0.EventEmitter();
            this.cancelCard = new i0.EventEmitter();
            this.border = false;
            this.editMode = false;
            this.isDefault = false;
            this.fitToContainer = false;
            this.truncateText = false;
            this.charactersLimit = 100;
        }
        // ACTIONS
        CardComponent.prototype.setEditMode = function () {
            this.editMode = true;
        };
        CardComponent.prototype.cancelEdit = function () {
            this.editMode = false;
            this.cancelCard.emit(5);
        };
        CardComponent.prototype.delete = function () {
            this.deleteCard.emit(1);
        };
        CardComponent.prototype.setDefault = function () {
            this.isDefault = true;
            this.setDefaultCard.emit(2);
        };
        CardComponent.prototype.send = function () {
            this.sendCard.emit(3);
        };
        CardComponent.prototype.edit = function () {
            this.editCard.emit(4);
        };
        CardComponent.prototype.ngOnInit = function () { };
        return CardComponent;
    }());
    CardComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CardComponent, deps: [], target: i0__namespace.ɵɵFactoryTarget.Component });
    CardComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: CardComponent, selector: "cx-card", inputs: { border: "border", editMode: "editMode", isDefault: "isDefault", content: "content", fitToContainer: "fitToContainer", truncateText: "truncateText", charactersLimit: "charactersLimit" }, outputs: { deleteCard: "deleteCard", setDefaultCard: "setDefaultCard", sendCard: "sendCard", editCard: "editCard", cancelCard: "cancelCard" }, ngImport: i0__namespace, template: "<div\n  *ngIf=\"content\"\n  class=\"cx-card\"\n  [class.cx-card-border]=\"border\"\n  [class.cx-card-fit-to-container]=\"fitToContainer\"\n>\n  <!-- Card Header -->\n  <div *ngIf=\"content.header && !editMode\" class=\"card-header\">\n    {{ content.header }}\n  </div>\n  <!-- Card Body -->\n  <div class=\"card-body cx-card-body\" [class.cx-card-delete]=\"editMode\">\n    <!-- Edit message -->\n    <div *ngIf=\"editMode\" class=\"cx-card-delete-msg\">\n      {{ content.deleteMsg }}\n    </div>\n    <!-- Card title -->\n    <h3 *ngIf=\"content.title\" class=\"cx-card-title\">\n      {{ content.title }}\n    </h3>\n    <!-- Card Content -->\n    <div class=\"cx-card-container\">\n      <!-- Card Label -->\n      <div class=\"cx-card-label-container\">\n        <div *ngIf=\"content.textBold\" class=\"cx-card-label-bold\">\n          {{ content.textBold }}\n        </div>\n        <div *ngFor=\"let line of content.text\">\n          <div *ngIf=\"!truncateText; else truncate\" class=\"cx-card-label\">\n            {{ line }}\n          </div>\n\n          <ng-template #truncate>\n            <cx-truncate-text-popover\n              [charactersLimit]=\"charactersLimit\"\n              [content]=\"line\"\n            ></cx-truncate-text-popover>\n          </ng-template>\n        </div>\n        <div class=\"cx-card-paragraph\" *ngFor=\"let item of content.paragraphs\">\n          <div class=\"cx-card-paragraph-title\">{{ item.title }}</div>\n          <div *ngFor=\"let text of item.text\">\n            <div class=\"cx-card-paragraph-text\">\n              {{ text }}\n            </div>\n          </div>\n        </div>\n      </div>\n      <!-- Image -->\n      <div *ngIf=\"content.img\" class=\"cx-card-img-container\">\n        <cx-icon [type]=\"content.img\"></cx-icon>\n      </div>\n    </div>\n    <!-- Edit Mode Actions -->\n    <div *ngIf=\"editMode\" class=\"row cx-card-body-delete\">\n      <div class=\"col-md-6\">\n        <button class=\"btn btn-block btn-secondary\" (click)=\"cancelEdit()\">\n          {{ 'common.cancel' | cxTranslate }}\n        </button>\n      </div>\n      <div class=\"col-md-6\">\n        <button class=\"btn btn-block btn-primary\" (click)=\"delete()\">\n          {{ 'common.delete' | cxTranslate }}\n        </button>\n      </div>\n    </div>\n    <!-- Actions -->\n    <div *ngIf=\"content.actions && !editMode\" class=\"cx-card-actions\">\n      <div *ngFor=\"let action of content.actions\">\n        <div [ngSwitch]=\"action.event\">\n          <a\n            *ngSwitchCase=\"'delete'\"\n            class=\"cx-card-link card-link btn-link cx-action-link\"\n            (click)=\"delete()\"\n            (keydown.enter)=\"delete()\"\n            tabindex=\"0\"\n            >{{ action.name }}</a\n          >\n          <a\n            *ngSwitchCase=\"'default'\"\n            class=\"cx-card-link card-link btn-link cx-action-link\"\n            (click)=\"setDefault()\"\n            (keydown.enter)=\"setDefault()\"\n            tabindex=\"0\"\n            >{{ action.name }}</a\n          >\n          <a\n            *ngSwitchCase=\"'send'\"\n            class=\"cx-card-link card-link btn-link cx-action-link\"\n            (click)=\"send()\"\n            (keydown.enter)=\"send()\"\n            tabindex=\"0\"\n            >{{ action.name }}</a\n          >\n          <a\n            *ngSwitchCase=\"'edit'\"\n            class=\"cx-card-link card-link btn-link cx-action-link\"\n            (click)=\"edit()\"\n            (keydown.enter)=\"edit()\"\n            tabindex=\"0\"\n            >{{ action.name }}</a\n          >\n          <a\n            *ngSwitchDefault\n            href=\"{{ action.link }}\"\n            class=\"card-link btn-link cx-action-link\"\n            tabindex=\"0\"\n            >{{ action.name }}</a\n          >\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n", components: [{ type: TruncateTextPopoverComponent, selector: "cx-truncate-text-popover", inputs: ["content", "charactersLimit"] }, { type: IconComponent, selector: "cx-icon,[cxIcon]", inputs: ["cxIcon", "type"] }], directives: [{ type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3__namespace.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i3__namespace.NgSwitch, selector: "[ngSwitch]", inputs: ["ngSwitch"] }, { type: i3__namespace.NgSwitchCase, selector: "[ngSwitchCase]", inputs: ["ngSwitchCase"] }, { type: i3__namespace.NgSwitchDefault, selector: "[ngSwitchDefault]" }], pipes: { "cxTranslate": i1__namespace.TranslatePipe } });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CardComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-card',
                        templateUrl: './card.component.html',
                    }]
            }], ctorParameters: function () { return []; }, propDecorators: { deleteCard: [{
                    type: i0.Output
                }], setDefaultCard: [{
                    type: i0.Output
                }], sendCard: [{
                    type: i0.Output
                }], editCard: [{
                    type: i0.Output
                }], cancelCard: [{
                    type: i0.Output
                }], border: [{
                    type: i0.Input
                }], editMode: [{
                    type: i0.Input
                }], isDefault: [{
                    type: i0.Input
                }], content: [{
                    type: i0.Input
                }], fitToContainer: [{
                    type: i0.Input
                }], truncateText: [{
                    type: i0.Input
                }], charactersLimit: [{
                    type: i0.Input
                }] } });

    var PopoverModule = /** @class */ (function () {
        function PopoverModule() {
        }
        return PopoverModule;
    }());
    PopoverModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PopoverModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    PopoverModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PopoverModule, declarations: [PopoverDirective, PopoverComponent], imports: [i3.CommonModule, i1$1.RouterModule, KeyboardFocusModule, IconModule], exports: [PopoverDirective, PopoverComponent] });
    PopoverModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PopoverModule, imports: [[i3.CommonModule, i1$1.RouterModule, KeyboardFocusModule, IconModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PopoverModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [i3.CommonModule, i1$1.RouterModule, KeyboardFocusModule, IconModule],
                        declarations: [PopoverDirective, PopoverComponent],
                        exports: [PopoverDirective, PopoverComponent],
                    }]
            }] });

    var TruncateTextPopoverModule = /** @class */ (function () {
        function TruncateTextPopoverModule() {
        }
        return TruncateTextPopoverModule;
    }());
    TruncateTextPopoverModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: TruncateTextPopoverModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    TruncateTextPopoverModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: TruncateTextPopoverModule, declarations: [TruncateTextPopoverComponent, TruncatePipe], imports: [i3.CommonModule, i1.I18nModule, PopoverModule], exports: [TruncateTextPopoverComponent, TruncatePipe] });
    TruncateTextPopoverModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: TruncateTextPopoverModule, imports: [[i3.CommonModule, i1.I18nModule, PopoverModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: TruncateTextPopoverModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [i3.CommonModule, i1.I18nModule, PopoverModule],
                        declarations: [TruncateTextPopoverComponent, TruncatePipe],
                        exports: [TruncateTextPopoverComponent, TruncatePipe],
                    }]
            }] });

    var CardModule = /** @class */ (function () {
        function CardModule() {
        }
        return CardModule;
    }());
    CardModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CardModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    CardModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CardModule, declarations: [CardComponent], imports: [i3.CommonModule, i1.I18nModule, IconModule, TruncateTextPopoverModule], exports: [CardComponent] });
    CardModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CardModule, imports: [[i3.CommonModule, i1.I18nModule, IconModule, TruncateTextPopoverModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CardModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [i3.CommonModule, i1.I18nModule, IconModule, TruncateTextPopoverModule],
                        declarations: [CardComponent],
                        exports: [CardComponent],
                    }]
            }] });

    var CarouselService = /** @class */ (function () {
        function CarouselService(winRef) {
            this.winRef = winRef;
        }
        /**
         * The number of items per slide is calculated by the help of
         * the item width and the available width of the host element.
         * This appoach makes it possible to place the carousel in different
         * layouts. Instead of using the page breakpoints, the host size is
         * taken into account.
         *
         * Since there's no element resize API available, we use the
         * window `resize` event, so that we can adjust the number of items
         * whenever the window got resized.
         */
        CarouselService.prototype.getItemsPerSlide = function (nativeElement, itemWidth) {
            var _this = this;
            return this.winRef.resize$.pipe(operators.map(function () { return nativeElement.clientWidth; }), operators.map(function (totalWidth) { return _this.calculateItems(totalWidth, itemWidth); }));
        };
        /**
         * Calculates the number of items per given hostSize.  calculated based on the given
         * intended size in pixels or percentages. The
         *
         * @param availableWidth The available width in pixels for the carousel items.
         * @param itemWidth The width per carousel item, in px or percentage.
         */
        CarouselService.prototype.calculateItems = function (availableWidth, itemWidth) {
            var calculatedItems = 0;
            if (itemWidth.endsWith('px')) {
                var num = itemWidth.substring(0, itemWidth.length - 2);
                calculatedItems = availableWidth / num;
            }
            if (itemWidth.endsWith('%')) {
                var perc = itemWidth.substring(0, itemWidth.length - 1);
                calculatedItems =
                    availableWidth / (availableWidth * (perc / 100));
            }
            return Math.floor(calculatedItems) || 1;
        };
        return CarouselService;
    }());
    CarouselService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CarouselService, deps: [{ token: i1__namespace.WindowRef }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    CarouselService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CarouselService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CarouselService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace.WindowRef }]; } });

    /**
     * Generic carousel component that can be used to render any carousel items,
     * such as products, images, banners, or any component. Carousel items are
     * rendered in so-called carousel slides, and the previous/next buttons as well as
     * the indicator-buttons can used to navigate the slides.
     *
     * The component uses an array of Observables (`items$`) as an input, to allow
     * for lazy loading of items.
     *
     * The number of items per slide is calculated with the `itemWidth`, which can given
     * in pixels or percentage.
     *
     * To allow for flexible rendering of items, the rendering is delegated to the
     * given `template`. This allows for maximum flexibility.
     */
    var CarouselComponent = /** @class */ (function () {
        function CarouselComponent(el, service) {
            this.el = el;
            this.service = service;
            /**
             * Specifies the minimum size of the carousel item, either in px or %.
             * This value is used for the calculation of numbers per carousel, so that
             * the number of carousel items is dynamic. The calculation uses the `itemWidth`
             * and the host element `clientWidth`, so that the carousel is reusable in
             * different layouts (for example in a 50% grid).
             */
            this.itemWidth = '300px';
            /**
             * Indicates whether the visual indicators are used.
             */
            this.hideIndicators = false;
            this.indicatorIcon = exports.ICON_TYPE.CIRCLE;
            this.previousIcon = exports.ICON_TYPE.CARET_LEFT;
            this.nextIcon = exports.ICON_TYPE.CARET_RIGHT;
        }
        Object.defineProperty(CarouselComponent.prototype, "setItems", {
            set: function (inputItems) {
                this.items = inputItems;
                //Reset slider when changing products
                this.activeSlide = 0;
            },
            enumerable: false,
            configurable: true
        });
        CarouselComponent.prototype.ngOnInit = function () {
            var _this = this;
            if (!this.template && i0.isDevMode()) {
                console.error('No template reference provided to render the carousel items for the `cx-carousel`');
                return;
            }
            this.size$ = this.service
                .getItemsPerSlide(this.el.nativeElement, this.itemWidth)
                .pipe(operators.tap(function () { return (_this.activeSlide = 0); }));
        };
        CarouselComponent.prototype.getSlideNumber = function (size, currentIndex) {
            var normalizedCurrentIndex = currentIndex + 1;
            return Math.ceil(normalizedCurrentIndex / size);
        };
        return CarouselComponent;
    }());
    CarouselComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CarouselComponent, deps: [{ token: i0__namespace.ElementRef }, { token: CarouselService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    CarouselComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: CarouselComponent, selector: "cx-carousel", inputs: { title: "title", setItems: ["items", "setItems"], template: "template", itemWidth: "itemWidth", hideIndicators: "hideIndicators", indicatorIcon: "indicatorIcon", previousIcon: "previousIcon", nextIcon: "nextIcon" }, ngImport: i0__namespace, template: "<ng-container *ngIf=\"items?.length > 0 && (size$ | async) as size\">\n  <h2 *ngIf=\"title\">{{ title }}</h2>\n\n  <div class=\"carousel-panel\" [ngClass]=\"'size-' + size\">\n    <button\n      *ngIf=\"size < items.length\"\n      class=\"previous\"\n      (click)=\"activeSlide = activeSlide - size\"\n      [disabled]=\"activeSlide === 0\"\n      [attr.aria-label]=\"'carousel.previousSlide' | cxTranslate\"\n    >\n      <cx-icon [type]=\"previousIcon\"></cx-icon>\n    </button>\n\n    <div class=\"slides\">\n      <ng-container *ngFor=\"let _ of items; let i = index\">\n        <div\n          class=\"slide\"\n          *ngIf=\"i % size === 0\"\n          [class.active]=\"i === activeSlide\"\n        >\n          <ng-container\n            *ngFor=\"let item of items | slice: i:i + size; let j = index\"\n          >\n            <div\n              *ngIf=\"item | async as data\"\n              class=\"item\"\n              [class.active]=\"i === activeSlide\"\n            >\n              <ng-container\n                *ngTemplateOutlet=\"template; context: { item: data }\"\n              ></ng-container>\n            </div>\n          </ng-container>\n        </div>\n      </ng-container>\n    </div>\n\n    <button\n      *ngIf=\"size < items.length\"\n      class=\"next\"\n      (click)=\"activeSlide = activeSlide + size\"\n      tabindex=\"-1\"\n      [disabled]=\"activeSlide > items.length - size - 1\"\n      [attr.aria-label]=\"'carousel.nextSlide' | cxTranslate\"\n    >\n      <cx-icon [type]=\"nextIcon\"></cx-icon>\n    </button>\n  </div>\n\n  <div *ngIf=\"!hideIndicators && size < items.length\" class=\"indicators\">\n    <ng-container *ngFor=\"let _ of items; let i = index\">\n      <button\n        *ngIf=\"i % size === 0\"\n        (focus)=\"activeSlide = i\"\n        [disabled]=\"i === activeSlide\"\n        [attr.aria-label]=\"\n          'carousel.slideNumber'\n            | cxTranslate: { currentSlideNumber: getSlideNumber(size, i) }\n        \"\n        tabindex=\"-1\"\n      >\n        <cx-icon [type]=\"indicatorIcon\" aria-hidden=\"true\"></cx-icon>\n      </button>\n    </ng-container>\n  </div>\n</ng-container>\n", components: [{ type: IconComponent, selector: "cx-icon,[cxIcon]", inputs: ["cxIcon", "type"] }], directives: [{ type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3__namespace.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { type: i3__namespace.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i3__namespace.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }], pipes: { "async": i3__namespace.AsyncPipe, "cxTranslate": i1__namespace.TranslatePipe, "slice": i3__namespace.SlicePipe }, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CarouselComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-carousel',
                        templateUrl: './carousel.component.html',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ElementRef }, { type: CarouselService }]; }, propDecorators: { title: [{
                    type: i0.Input
                }], setItems: [{
                    type: i0.Input,
                    args: ['items']
                }], template: [{
                    type: i0.Input
                }], itemWidth: [{
                    type: i0.Input
                }], hideIndicators: [{
                    type: i0.Input
                }], indicatorIcon: [{
                    type: i0.Input
                }], previousIcon: [{
                    type: i0.Input
                }], nextIcon: [{
                    type: i0.Input
                }] } });

    var MediaModule = /** @class */ (function () {
        function MediaModule() {
        }
        MediaModule.forRoot = function () {
            return {
                ngModule: MediaModule,
            };
        };
        return MediaModule;
    }());
    MediaModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: MediaModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    MediaModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: MediaModule, declarations: [MediaComponent], imports: [i3.CommonModule], exports: [MediaComponent] });
    MediaModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: MediaModule, imports: [[i3.CommonModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: MediaModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [i3.CommonModule],
                        declarations: [MediaComponent],
                        exports: [MediaComponent],
                    }]
            }] });

    var CarouselModule = /** @class */ (function () {
        function CarouselModule() {
        }
        return CarouselModule;
    }());
    CarouselModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CarouselModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    CarouselModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CarouselModule, declarations: [CarouselComponent], imports: [i3.CommonModule,
            i1$1.RouterModule,
            IconModule,
            MediaModule,
            i1.UrlModule,
            i1.I18nModule], exports: [CarouselComponent] });
    CarouselModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CarouselModule, imports: [[
                i3.CommonModule,
                i1$1.RouterModule,
                IconModule,
                MediaModule,
                i1.UrlModule,
                i1.I18nModule,
            ]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CarouselModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [
                            i3.CommonModule,
                            i1$1.RouterModule,
                            IconModule,
                            MediaModule,
                            i1.UrlModule,
                            i1.I18nModule,
                        ],
                        declarations: [CarouselComponent],
                        exports: [CarouselComponent],
                    }]
            }] });

    /**
     * Service that provides the placeholder and input pattern for date pickers. This is
     * used in Spartacus to support browser that won't support the native html5 date picker
     * using `<input type="date">`.
     *
     * While the placeholder is configurable, you should be aware that the placeholder format
     * defaults to `yyyy-mm-dd` to align with Safaris limited support of ISO 8601.
     * Another consideration is the support of date formats in the backend. In case you change
     * this format, you might need to serialize the date to the supported date format in the
     * backend.
     *
     */
    var DatePickerService = /** @class */ (function () {
        function DatePickerService() {
        }
        Object.defineProperty(DatePickerService.prototype, "placeholder", {
            get: function () {
                return 'yyyy-mm-dd';
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DatePickerService.prototype, "pattern", {
            /**
             * The default date pattern is based on the placeholder string;
             */
            get: function () {
                return this.placeholder
                    .replace('yyyy', '\\d{4}')
                    .replace('mm', '\\d{1,2}')
                    .replace('dd', '\\d{1,2}');
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Validates if the string based date value is a valid date.
         */
        DatePickerService.prototype.isValidFormat = function (date, pattern) {
            var patternRegex = new RegExp("^" + (pattern !== null && pattern !== void 0 ? pattern : this.pattern) + "$");
            return patternRegex.test(date);
        };
        /**
         * Since Safari doesn't support proper date formats (ISO 8601), we need to do this
         * ourselves. We cannot rely on `new Date('2020-1-1')`. This will fail, only
         * `new Date('2020-01-01')` works.
         */
        DatePickerService.prototype.getDate = function (value) {
            if (!value) {
                return;
            }
            var delimiter = this.placeholder
                .replace('yyyy', '')
                .replace('mm', '')
                .replace('dd', '')
                .substr(0, 1);
            var dateParts = value.split(delimiter);
            var placeholderParts = this.placeholder.split(delimiter);
            var y = placeholderParts.indexOf('yyyy');
            var m = placeholderParts.indexOf('mm');
            var d = placeholderParts.indexOf('dd');
            return new Date(Number(dateParts[y]), Number(dateParts[m]) - 1, Number(dateParts[d]));
        };
        return DatePickerService;
    }());
    DatePickerService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: DatePickerService, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    DatePickerService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: DatePickerService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: DatePickerService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }] });

    /**
     * Renders translated form errors for a given form control, based on its `errors` property.
     *
     * The translation key consists of the optional input `prefix`
     * concatenated with the error key.
     *
     * And the translation params object consist of the error details
     * (if only it's an object) merged with the optional input object `translationParams`.
     */
    var FormErrorsComponent = /** @class */ (function () {
        function FormErrorsComponent() {
            /**
             * Prefix prepended to the translation key.
             */
            this.prefix = 'formErrors';
        }
        Object.defineProperty(FormErrorsComponent.prototype, "control", {
            get: function () {
                return this._control;
            },
            set: function (control) {
                this._control = control;
                this.errorsDetails$ = control === null || control === void 0 ? void 0 : control.statusChanges.pipe(operators.startWith({}), operators.map(function () { return control.errors || {}; }), operators.map(function (errors) { return Object.entries(errors).filter(function (_b) {
                    var _c = __read(_b, 2), _key = _c[0], details = _c[1];
                    return details;
                }); }));
                this.errors$ = this.errorsDetails$.pipe(operators.map(function (errors) { return errors.map(function (_b) {
                    var _c = __read(_b, 2), key = _c[0], _details = _c[1];
                    return key;
                }); }));
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Returns translation params composed of
         * the argument `errorDetails` (if only is an object) merged with
         * the component input object `translationParams`.
         *
         * In case of a conflicting object key, the value from
         * `translationParams` takes precedence.
         */
        FormErrorsComponent.prototype.getTranslationParams = function (errorDetails) {
            errorDetails = i1.isObject(errorDetails) ? errorDetails : {};
            return Object.assign(Object.assign({}, errorDetails), this.translationParams);
        };
        Object.defineProperty(FormErrorsComponent.prototype, "invalid", {
            get: function () {
                var _a;
                return (_a = this.control) === null || _a === void 0 ? void 0 : _a.invalid;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(FormErrorsComponent.prototype, "dirty", {
            get: function () {
                var _a;
                return (_a = this.control) === null || _a === void 0 ? void 0 : _a.dirty;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(FormErrorsComponent.prototype, "touched", {
            get: function () {
                var _a;
                return (_a = this.control) === null || _a === void 0 ? void 0 : _a.touched;
            },
            enumerable: false,
            configurable: true
        });
        return FormErrorsComponent;
    }());
    FormErrorsComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: FormErrorsComponent, deps: [], target: i0__namespace.ɵɵFactoryTarget.Component });
    FormErrorsComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: FormErrorsComponent, selector: "cx-form-errors", inputs: { prefix: "prefix", translationParams: "translationParams", control: "control" }, host: { properties: { "class.control-invalid": "this.invalid", "class.control-dirty": "this.dirty", "class.control-touched": "this.touched" } }, ngImport: i0__namespace, template: "<p *ngFor=\"let error of errorsDetails$ | async\">\n  {{ prefix + '.' + error[0] | cxTranslate: getTranslationParams(error[1]) }}\n</p>\n", directives: [{ type: i3__namespace.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], pipes: { "async": i3__namespace.AsyncPipe, "cxTranslate": i1__namespace.TranslatePipe }, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: FormErrorsComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-form-errors',
                        templateUrl: './form-errors.component.html',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], propDecorators: { prefix: [{
                    type: i0.Input
                }], translationParams: [{
                    type: i0.Input
                }], control: [{
                    type: i0.Input
                }], invalid: [{
                    type: i0.HostBinding,
                    args: ['class.control-invalid']
                }], dirty: [{
                    type: i0.HostBinding,
                    args: ['class.control-dirty']
                }], touched: [{
                    type: i0.HostBinding,
                    args: ['class.control-touched']
                }] } });

    /**
     * Component that adds a date control. While the native date picker works in most
     * modern browsers, some browsers need more guidance (placeholder), validation and
     * date conversion.
     *
     * The data picker supports (optional) min and max form controls, so that you can
     * limit the start and/or end date.
     *
     * Most of the implementation is done in the `DatePickerFallbackDirective`.
     */
    var DatePickerComponent = /** @class */ (function () {
        function DatePickerComponent(service) {
            this.service = service;
            this.update = new i0.EventEmitter();
        }
        DatePickerComponent.prototype.change = function () {
            this.update.emit();
        };
        Object.defineProperty(DatePickerComponent.prototype, "placeholder", {
            get: function () {
                return this.service.placeholder;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DatePickerComponent.prototype, "pattern", {
            get: function () {
                return this.service.pattern;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Only returns the date if we have a valid format. We do this to avoid
         * loads of console errors coming from the datePipe while the user is typing
         * (in those browsers where the date picker isn't supported).
         */
        DatePickerComponent.prototype.getDate = function (date) {
            return this.service.isValidFormat(date) ? date : null;
        };
        return DatePickerComponent;
    }());
    DatePickerComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: DatePickerComponent, deps: [{ token: DatePickerService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    DatePickerComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: DatePickerComponent, selector: "cx-date-picker", inputs: { control: "control", min: "min", max: "max" }, outputs: { update: "update" }, ngImport: i0__namespace, template: "<input\n  class=\"form-control\"\n  type=\"date\"\n  [formControl]=\"control\"\n  [attr.min]=\"min\"\n  [attr.max]=\"max\"\n  (change)=\"change()\"\n  [placeholder]=\"placeholder\"\n  [pattern]=\"pattern\"\n/>\n<cx-form-errors\n  aria-live=\"assertive\"\n  aria-atomic=\"true\"\n  [control]=\"control\"\n  prefix=\"formErrors.date\"\n  [translationParams]=\"{\n    max: getDate(max) | cxDate,\n    min: getDate(min) | cxDate\n  }\"\n></cx-form-errors>\n", components: [{ type: FormErrorsComponent, selector: "cx-form-errors", inputs: ["prefix", "translationParams", "control"] }], directives: [{ type: i3__namespace$1.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { type: i3__namespace$1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i3__namespace$1.FormControlDirective, selector: "[formControl]", inputs: ["disabled", "formControl", "ngModel"], outputs: ["ngModelChange"], exportAs: ["ngForm"] }, { type: i3__namespace$1.PatternValidator, selector: "[pattern][formControlName],[pattern][formControl],[pattern][ngModel]", inputs: ["pattern"] }], pipes: { "cxDate": i1__namespace.CxDatePipe } });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: DatePickerComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-date-picker',
                        templateUrl: './date-picker.component.html',
                        // we cannot use onPush change detection as the form state isn't updated without explicit
                        // change detection, see https://github.com/angular/angular/issues/10816
                    }]
            }], ctorParameters: function () { return [{ type: DatePickerService }]; }, propDecorators: { control: [{
                    type: i0.Input
                }], min: [{
                    type: i0.Input
                }], max: [{
                    type: i0.Input
                }], update: [{
                    type: i0.Output
                }] } });

    var FormErrorsModule = /** @class */ (function () {
        function FormErrorsModule() {
        }
        return FormErrorsModule;
    }());
    FormErrorsModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: FormErrorsModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    FormErrorsModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: FormErrorsModule, declarations: [FormErrorsComponent], imports: [i3.CommonModule, i1.I18nModule], exports: [FormErrorsComponent] });
    FormErrorsModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: FormErrorsModule, imports: [[i3.CommonModule, i1.I18nModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: FormErrorsModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [i3.CommonModule, i1.I18nModule],
                        declarations: [FormErrorsComponent],
                        exports: [FormErrorsComponent],
                    }]
            }] });

    var DatePickerModule = /** @class */ (function () {
        function DatePickerModule() {
        }
        return DatePickerModule;
    }());
    DatePickerModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: DatePickerModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    DatePickerModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: DatePickerModule, declarations: [DatePickerComponent], imports: [i3.CommonModule, i3$1.ReactiveFormsModule, FormErrorsModule, i1.I18nModule], exports: [DatePickerComponent] });
    DatePickerModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: DatePickerModule, imports: [[i3.CommonModule, i3$1.ReactiveFormsModule, FormErrorsModule, i1.I18nModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: DatePickerModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [i3.CommonModule, i3$1.ReactiveFormsModule, FormErrorsModule, i1.I18nModule],
                        declarations: [DatePickerComponent],
                        exports: [DatePickerComponent],
                    }]
            }] });

    /**
     * Component that adds a file upload control.
     */
    var FileUploadComponent = /** @class */ (function () {
        function FileUploadComponent() {
            /**
             * Allowed file types. It's setting attribute used for OS window for choosing files.
             */
            this.accept = '*';
            /**
             * Allows selecting multiple files.
             */
            this.multiple = false;
            // TODO: remove this event. Now it's used only to trigger some logic in the parent component.
            // Prerequisites (changes in the parent component):
            // - use an async validator that "opens file" using the value of the form control
            // - "open file" on form submit, but not on the form control change
            this.update = new i0.EventEmitter();
            // ControlValueAccessor START
            this.onChangeCallback = function () { };
            this.onTouchedCallback = function () { };
        }
        FileUploadComponent.prototype.selectFile = function ($event) {
            var _a;
            var files = (_a = $event.target) === null || _a === void 0 ? void 0 : _a.files;
            this.onChangeCallback(files);
            this.update.emit(files);
        };
        Object.defineProperty(FileUploadComponent.prototype, "selectedFiles", {
            get: function () {
                return Array.from(this.fileInput.nativeElement.files);
            },
            enumerable: false,
            configurable: true
        });
        FileUploadComponent.prototype.registerOnChange = function (callback) {
            this.onChangeCallback = callback;
        };
        FileUploadComponent.prototype.registerOnTouched = function (callback) {
            this.onTouchedCallback = callback;
        };
        FileUploadComponent.prototype.setDisabledState = function (disabled) {
            this.fileInput.nativeElement.disabled = disabled;
        };
        FileUploadComponent.prototype.writeValue = function (value) {
            if (value instanceof FileList) {
                this.fileInput.nativeElement.files = value;
            }
        };
        return FileUploadComponent;
    }());
    FileUploadComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: FileUploadComponent, deps: [], target: i0__namespace.ɵɵFactoryTarget.Component });
    FileUploadComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: FileUploadComponent, selector: "cx-file-upload", inputs: { accept: "accept", multiple: "multiple" }, outputs: { update: "update" }, providers: [
            {
                provide: i3$1.NG_VALUE_ACCESSOR,
                useExisting: i0.forwardRef(function () { return FileUploadComponent; }),
                multi: true,
            },
        ], viewQueries: [{ propertyName: "fileInput", first: true, predicate: ["fileInput"], descendants: true, static: true }], ngImport: i0__namespace, template: "<input\n  type=\"file\"\n  aria-hidden=\"true\"\n  [accept]=\"accept\"\n  [multiple]=\"multiple\"\n  (change)=\"selectFile($event)\"\n  #fileInput\n/>\n<button\n  [attr.aria-label]=\"'common.selectFile' | cxTranslate\"\n  class=\"btn btn-action\"\n  type=\"button\"\n  (click)=\"fileInput.click()\"\n>\n  <ng-content></ng-content>\n</button>\n<p *ngFor=\"let file of selectedFiles\">\n  {{ file?.name }}\n</p>\n", directives: [{ type: i3__namespace.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], pipes: { "cxTranslate": i1__namespace.TranslatePipe } });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: FileUploadComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-file-upload',
                        templateUrl: './file-upload.component.html',
                        providers: [
                            {
                                provide: i3$1.NG_VALUE_ACCESSOR,
                                useExisting: i0.forwardRef(function () { return FileUploadComponent; }),
                                multi: true,
                            },
                        ],
                        // we cannot use onPush change detection as the form state isn't updated without explicit
                        // change detection, see https://github.com/angular/angular/issues/10816
                    }]
            }], propDecorators: { accept: [{
                    type: i0.Input
                }], multiple: [{
                    type: i0.Input
                }], update: [{
                    type: i0.Output
                }], fileInput: [{
                    type: i0.ViewChild,
                    args: ['fileInput', { static: true }]
                }] } });

    var FileUploadModule = /** @class */ (function () {
        function FileUploadModule() {
        }
        return FileUploadModule;
    }());
    FileUploadModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: FileUploadModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    FileUploadModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: FileUploadModule, declarations: [FileUploadComponent], imports: [i3.CommonModule, i3$1.ReactiveFormsModule, FormErrorsModule, i1.I18nModule], exports: [FileUploadComponent] });
    FileUploadModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: FileUploadModule, imports: [[i3.CommonModule, i3$1.ReactiveFormsModule, FormErrorsModule, i1.I18nModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: FileUploadModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [i3.CommonModule, i3$1.ReactiveFormsModule, FormErrorsModule, i1.I18nModule],
                        declarations: [FileUploadComponent],
                        exports: [FileUploadComponent],
                    }]
            }] });

    var GenericLinkComponentService = /** @class */ (function () {
        function GenericLinkComponentService() {
            /**
             * Pattern matching string starting with `http://` or `https://`.
             */
            this.HTTP_PROTOCOL_REGEX = /^https?:\/\//i;
            /**
             * Pattern matching string starting with `mailto:`.
             */
            this.MAILTO_PROTOCOL_REGEX = /^mailto:/i;
            /**
             * Pattern matching string starting with `tel:`.
             */
            this.TEL_PROTOCOL_REGEX = /^tel:/i;
        }
        /**
         * Returns true when the @Input `url` is a string starting with `http://`, `https://`, `mailto:`, `tel:`.
         */
        GenericLinkComponentService.prototype.isExternalUrl = function (url) {
            return (typeof url === 'string' &&
                (this.HTTP_PROTOCOL_REGEX.test(url) ||
                    this.MAILTO_PROTOCOL_REGEX.test(url) ||
                    this.TEL_PROTOCOL_REGEX.test(url)));
        };
        return GenericLinkComponentService;
    }());
    GenericLinkComponentService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: GenericLinkComponentService, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    GenericLinkComponentService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: GenericLinkComponentService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: GenericLinkComponentService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }] });

    /**
     * This component navigates using [routerLink] attribute when input 'url' is a relative url. Otherwise (when it's absolute), [href] is used.
     */
    var GenericLinkComponent = /** @class */ (function () {
        function GenericLinkComponent(router, service) {
            this.router = router;
            this.service = service;
            /**
             * Pattern matching string starting with `http://` or `https://`.
             */
            this.PROTOCOL_REGEX = /^https?:\/\//i;
            /**
             * Pattern matching string starting with `mailto:`.
             */
            this.MAILTO_PROTOCOL_REGEX = /^mailto:/i;
            /**
             * Pattern matching string starting with `tel:`.
             */
            this.TEL_PROTOCOL_REGEX = /^tel:/i;
            /**
             * Used to split url into 2 parts:
             * 1. the path
             * 2. query params + hash fragment
             */
            this.URL_SPLIT = /(^[^#?]*)(.*)/;
            /**
             * Parsed parts of the @Input `url`, when it's a local URL.
             * It should not be used when the `url` is external.
             * @see `url`
             */
            this.routeParts = {};
        }
        GenericLinkComponent.prototype.isExternalUrl = function () {
            var _a;
            return (((_a = this.service) === null || _a === void 0 ? void 0 : _a.isExternalUrl(this.url)) ||
                (typeof this.url === 'string' &&
                    (this.PROTOCOL_REGEX.test(this.url) ||
                        this.MAILTO_PROTOCOL_REGEX.test(this.url) ||
                        this.TEL_PROTOCOL_REGEX.test(this.url))));
        };
        Object.defineProperty(GenericLinkComponent.prototype, "rel", {
            get: function () {
                return this.target === '_blank' ? 'noopener' : null;
            },
            enumerable: false,
            configurable: true
        });
        GenericLinkComponent.prototype.ngOnChanges = function (changes) {
            if (changes['url']) {
                this.setUrlParts(changes['url'].currentValue);
            }
        };
        Object.defineProperty(GenericLinkComponent.prototype, "routerUrl", {
            /**
             * The part with the path of the local url.
             */
            get: function () {
                return this.routeParts.path;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(GenericLinkComponent.prototype, "queryParams", {
            /**
             * The part with the query params of the local url.
             */
            get: function () {
                return this.routeParts.queryParams;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(GenericLinkComponent.prototype, "fragment", {
            /**
             * The part with the hash fragment of the local url.
             */
            get: function () {
                return this.routeParts.fragment;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Parses the given url and sets the property `urlParts` accordingly.
         */
        GenericLinkComponent.prototype.setUrlParts = function (url) {
            if (typeof url === 'string') {
                url = this.getAbsoluteUrl(url); // string links in CMS sometimes don't have the leading slash, so fix it here
                this.routeParts = this.splitUrl(url);
            }
            else {
                this.routeParts = { path: url };
            }
        };
        /**
         * Parses the given string into 3 parts:
         * - string path (wrapped in an array to be compatible with Angular syntax for the `routerLink`)
         * - query params (as an object)
         * - hash fragment (string)
         */
        GenericLinkComponent.prototype.splitUrl = function (url) {
            if (url === void 0) { url = ''; }
            var _b = this.router.parseUrl(url), queryParams = _b.queryParams, fragment = _b.fragment;
            var _c = __read(url.match(this.URL_SPLIT), 2), path = _c[1];
            // wrap path in an array, to have the Angular-like path format
            return { path: [path], queryParams: queryParams, fragment: fragment };
        };
        /**
         * Prepends a leading slash to the given URL string, in case it doesn't have it.
         */
        GenericLinkComponent.prototype.getAbsoluteUrl = function (url) {
            return url.startsWith('/') ? url : '/' + url;
        };
        return GenericLinkComponent;
    }());
    GenericLinkComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: GenericLinkComponent, deps: [{ token: i1__namespace$1.Router }, { token: GenericLinkComponentService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    GenericLinkComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: GenericLinkComponent, selector: "cx-generic-link", inputs: { url: "url", target: "target", id: "id", class: "class", style: "style", title: "title" }, usesOnChanges: true, ngImport: i0__namespace, template: "<!-- https://github.com/angular/angular/issues/24567 -->\n\n<ng-container *ngIf=\"isExternalUrl(); else isLocalUrl\">\n  <a\n    [href]=\"url\"\n    [attr.target]=\"target\"\n    [attr.rel]=\"rel\"\n    [attr.id]=\"id\"\n    [attr.class]=\"class\"\n    [attr.style]=\"style\"\n    [attr.title]=\"title\"\n  >\n    <ng-container *ngTemplateOutlet=\"content\"></ng-container>\n  </a>\n</ng-container>\n\n<ng-template #isLocalUrl>\n  <a\n    [routerLink]=\"routerUrl\"\n    [queryParams]=\"queryParams\"\n    [fragment]=\"fragment\"\n    [target]=\"target\"\n    [attr.id]=\"id\"\n    [attr.class]=\"class\"\n    [attr.style]=\"style\"\n    [attr.title]=\"title\"\n  >\n    <ng-container *ngTemplateOutlet=\"content\"></ng-container>\n  </a>\n</ng-template>\n\n<ng-template #content>\n  <ng-content></ng-content>\n</ng-template>\n", directives: [{ type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3__namespace.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }, { type: i1__namespace$1.RouterLinkWithHref, selector: "a[routerLink],area[routerLink]", inputs: ["routerLink", "target", "queryParams", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange", "replaceUrl", "state", "relativeTo"] }] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: GenericLinkComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-generic-link',
                        templateUrl: './generic-link.component.html',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace$1.Router }, { type: GenericLinkComponentService }]; }, propDecorators: { url: [{
                    type: i0.Input
                }], target: [{
                    type: i0.Input
                }], id: [{
                    type: i0.Input
                }], class: [{
                    type: i0.Input
                }], style: [{
                    type: i0.Input
                }], title: [{
                    type: i0.Input
                }] } });

    var GenericLinkModule = /** @class */ (function () {
        function GenericLinkModule() {
        }
        return GenericLinkModule;
    }());
    GenericLinkModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: GenericLinkModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    GenericLinkModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: GenericLinkModule, declarations: [GenericLinkComponent], imports: [i3.CommonModule, i1$1.RouterModule], exports: [GenericLinkComponent] });
    GenericLinkModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: GenericLinkModule, imports: [[i3.CommonModule, i1$1.RouterModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: GenericLinkModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [i3.CommonModule, i1$1.RouterModule],
                        declarations: [GenericLinkComponent],
                        exports: [GenericLinkComponent],
                    }]
            }] });

    var ItemCounterModule = /** @class */ (function () {
        function ItemCounterModule() {
        }
        return ItemCounterModule;
    }());
    ItemCounterModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ItemCounterModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    ItemCounterModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ItemCounterModule, declarations: [ItemCounterComponent], imports: [i3.CommonModule, i3$1.ReactiveFormsModule, i1.I18nModule], exports: [ItemCounterComponent] });
    ItemCounterModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ItemCounterModule, imports: [[i3.CommonModule, i3$1.ReactiveFormsModule, i1.I18nModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ItemCounterModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [i3.CommonModule, i3$1.ReactiveFormsModule, i1.I18nModule],
                        declarations: [ItemCounterComponent],
                        exports: [ItemCounterComponent],
                    }]
            }] });

    var defaultPaginationConfig = {
        pagination: {
            addStart: true,
            addEnd: true,
        },
    };

    var PaginationConfig = /** @class */ (function () {
        function PaginationConfig() {
        }
        return PaginationConfig;
    }());
    PaginationConfig.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PaginationConfig, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    PaginationConfig.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PaginationConfig, providedIn: 'root', useExisting: i1.Config });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PaginationConfig, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                        useExisting: i1.Config,
                    }]
            }] });

    /**
     * The item type is used to add semantic structure to the
     * PaginationItem, so that the UI understands the usage.
     */
    exports.PaginationItemType = void 0;
    (function (PaginationItemType) {
        PaginationItemType["GAP"] = "gap";
        PaginationItemType["FIRST"] = "first";
        PaginationItemType["LAST"] = "last";
        PaginationItemType["PREVIOUS"] = "previous";
        PaginationItemType["NEXT"] = "next";
        PaginationItemType["START"] = "start";
        PaginationItemType["END"] = "end";
        PaginationItemType["PAGE"] = "page";
    })(exports.PaginationItemType || (exports.PaginationItemType = {}));
    exports.PaginationNavigationPosition = void 0;
    (function (PaginationNavigationPosition) {
        PaginationNavigationPosition["ASIDE"] = "aside";
        PaginationNavigationPosition["BEFORE"] = "before";
        PaginationNavigationPosition["AFTER"] = "after";
    })(exports.PaginationNavigationPosition || (exports.PaginationNavigationPosition = {}));

    var FALLBACK_PAGINATION_OPTIONS = {
        rangeCount: 3,
        dotsLabel: '...',
        startLabel: '«',
        previousLabel: '‹',
        nextLabel: '›',
        endLabel: '»',
    };
    /**
     * Builds a pagination structures based on a pageCount and current page number.
     * There are various {@link PaginationConfig} options which can be used to configure
     * the behavior of the build. Alternatively, CSS can be used to further customize
     * the pagination.
     *
     * Examples:
     * The full blown pagination items contain the follow elements:
     *
     * `« ‹ 1 ... 4 (5) 6 ... 9 › »`
     *
     * This includes pagination items to the following pages:
     * - start page
     * - previous page
     * - first page
     * - page range
     * - last page
     * - next page
     * - end page
     *
     * All of those links are configurable, including the size of the page range.
     * The current page will always be centered in the page range to provide direct access
     * to the previous and next page.
     */
    var PaginationBuilder = /** @class */ (function () {
        function PaginationBuilder(paginationConfig) {
            this.paginationConfig = paginationConfig;
        }
        /**
         * Builds a list of `PaginationItem`. The give pageCount and current are used
         * to build out the full pagination. There are various {@link PaginationConfig} options
         * which can be used to configure the behavior of the build. Alternatively, CSS
         * can be used to further specialize visibility of the pagination.
         *
         * @param pageCount The total number of pages
         * @param current The current page number, 0-index based
         * @returns An array of `PaginationItem`
         */
        PaginationBuilder.prototype.paginate = function (pageCount, current) {
            var pages = [];
            if (!pageCount || pageCount < 2) {
                return pages;
            }
            this.addPages(pages, pageCount, current);
            this.addDots(pages, pageCount);
            this.addFirstLast(pages, pageCount);
            this.addNavigation(pages, pageCount, current);
            return pages;
        };
        /**
         * Returns the current page with surrounding pages (based on the `config.rangeCount`).
         * The current page is always centered to provide direct access to the previous and next page.
         *
         * @param pages The list of page items that is used to amend
         * @param pageCount The total number of pages
         * @param current The current page number, 0-index based
         */
        PaginationBuilder.prototype.addPages = function (pages, pageCount, current) {
            var start = this.getStartOfRange(pageCount, current);
            var max = Math.min(this.config.rangeCount, pageCount);
            Array.from(Array(max)).forEach(function (_, i) {
                pages.push({
                    number: i + start,
                    label: String(i + start + 1),
                    type: exports.PaginationItemType.PAGE,
                });
            });
        };
        /**
         * Adds dots before and after the given pages, if configured (defaults to true).
         * If the dots only represent a single page, the page number is added instead of
         * the dots, unless the configuration requires dots always.
         *
         * @param pages The list of page items that is used to amend
         * @param pageCount The total number of pages
         */
        PaginationBuilder.prototype.addDots = function (pages, pageCount) {
            var _this = this;
            if (!this.config.addDots) {
                return;
            }
            var addFirstGap = function () {
                var firstItemNumber = pages[0].number;
                var gapNumber = _this.config.addFirst ? 1 : 0;
                if (firstItemNumber > gapNumber) {
                    var isGap = !_this.config.substituteDotsForSingularPage ||
                        firstItemNumber !== gapNumber + 1;
                    var isSubstituted = _this.config.addFirst &&
                        _this.config.substituteDotsForSingularPage &&
                        gapNumber === 0;
                    var type = isGap
                        ? exports.PaginationItemType.GAP
                        : isSubstituted
                            ? exports.PaginationItemType.FIRST
                            : exports.PaginationItemType.PAGE;
                    return [
                        Object.assign({
                            label: isGap ? _this.config.dotsLabel : String(gapNumber + 1),
                            type: type,
                        }, isGap ? null : { number: gapNumber }),
                    ];
                }
                else
                    return [];
            };
            var addLastGap = function () {
                var nextPageNumber = pages[pages.length - 1].number + 1;
                var last = pageCount - (_this.config.addLast ? 2 : 1);
                if (nextPageNumber <= last) {
                    var isSubstituted = _this.config.addLast &&
                        _this.config.substituteDotsForSingularPage &&
                        nextPageNumber === last;
                    var isGap = nextPageNumber <
                        pageCount -
                            (_this.config.substituteDotsForSingularPage ? 1 : 0) -
                            (_this.config.addLast ? 1 : 0);
                    var type = isGap
                        ? exports.PaginationItemType.GAP
                        : isSubstituted
                            ? exports.PaginationItemType.LAST
                            : exports.PaginationItemType.PAGE;
                    return [
                        Object.assign({
                            label: isGap ? _this.config.dotsLabel : String(nextPageNumber + 1),
                            type: type,
                        }, isGap ? null : { number: nextPageNumber }),
                    ];
                }
                else
                    return [];
            };
            pages.unshift.apply(pages, __spreadArray([], __read(addFirstGap())));
            pages.push.apply(pages, __spreadArray([], __read(addLastGap())));
        };
        /**
         * Add links to the first and last page, if configured to do so.
         *
         * @param pages The list of page items that is used to amend
         * @param pageCount The total number of pages
         *
         */
        PaginationBuilder.prototype.addFirstLast = function (pages, pageCount) {
            if (this.config.addFirst && pages[0].number !== 0) {
                pages.unshift({
                    number: 0,
                    label: '1',
                    type: exports.PaginationItemType.FIRST,
                });
            }
            if (this.config.addLast &&
                pages[pages.length - 1].number !== pageCount - 1) {
                pages.push({
                    number: pageCount - 1,
                    label: String(pageCount),
                    type: exports.PaginationItemType.LAST,
                });
            }
        };
        /**
         * Add links to the start, previous, next and last page, if configured to do so.
         * The order of the links can be configured by using the {@link PaginationConfig},
         * using the `PaginationNavigationPosition` (`BEFORE` or `AFTER`).
         * The `PaginationNavigationPosition` allows for 3 flavours:
         *
         * - by default the pagination starts with start and previous and ends with the next and end links
         * - BEFORE – all navigation links are added in the front of the pagination list
         * - AFTER – all navigation links are pushed to the end of the pagination list
         *
         * @param pages The list of page items that is used to amend
         * @param pageCount The total number of pages
         * @param current The current page number, 0-index based
         *
         */
        PaginationBuilder.prototype.addNavigation = function (pages, pageCount, current) {
            var before = this.getBeforeLinks(current);
            var after = this.getAfterLinks(pageCount, current);
            var pos = this.config.navigationPosition;
            if (!pos || pos === exports.PaginationNavigationPosition.ASIDE) {
                pages.unshift.apply(pages, __spreadArray([], __read(before)));
                pages.push.apply(pages, __spreadArray([], __read(after)));
            }
            else {
                if (pos === exports.PaginationNavigationPosition.BEFORE) {
                    pages.unshift.apply(pages, __spreadArray(__spreadArray([], __read(before)), __read(after)));
                }
                if (pos === exports.PaginationNavigationPosition.AFTER) {
                    pages.push.apply(pages, __spreadArray(__spreadArray([], __read(before)), __read(after)));
                }
            }
        };
        /**
         * Returns the start and previous links, if applicable.
         */
        PaginationBuilder.prototype.getBeforeLinks = function (current) {
            var _this = this;
            var list = [];
            if (this.config.addStart) {
                var start = function () {
                    return Object.assign({
                        label: _this.config.startLabel,
                        type: exports.PaginationItemType.START,
                    }, current > 0 ? { number: 0 } : null);
                };
                list.push(start());
            }
            if (this.config.addPrevious) {
                var previous = function () {
                    return Object.assign({
                        label: _this.config.previousLabel,
                        type: exports.PaginationItemType.PREVIOUS,
                    }, current > 0 ? { number: current - 1 } : null);
                };
                list.push(previous());
            }
            return list;
        };
        /**
         * Returns the next and end links, if applicable.
         */
        PaginationBuilder.prototype.getAfterLinks = function (pageCount, current) {
            var _this = this;
            var list = [];
            if (this.config.addNext) {
                var next = function () {
                    return Object.assign({
                        label: _this.config.nextLabel,
                        type: exports.PaginationItemType.NEXT,
                    }, current < pageCount - 1 ? { number: current + 1 } : null);
                };
                list.push(next());
            }
            if (this.config.addEnd) {
                var end = function () {
                    return Object.assign({
                        label: _this.config.endLabel,
                        type: exports.PaginationItemType.END,
                    }, current < pageCount - 1 ? { number: pageCount - 1 } : null);
                };
                list.push(end());
            }
            return list;
        };
        /**
         * Resolves the first page of the range we need to build.
         * This is the page that is leading up to the range of the
         * current page.
         *
         * @param pageCount The total number of pages.
         * @param current The current page number, 0-index based.
         */
        PaginationBuilder.prototype.getStartOfRange = function (pageCount, current) {
            var count = this.config.rangeCount - 1;
            // the least number of pages before and after the current
            var delta = Math.round(count / 2);
            // ensure that we start with at least the first page
            var minStart = Math.max(0, current - delta);
            // ensures that we start with at least 1 and do not pass the last range
            var maxStart = Math.max(0, pageCount - count - 1);
            // ensure that we get at least a full range at the end
            return Math.min(maxStart, minStart);
        };
        Object.defineProperty(PaginationBuilder.prototype, "config", {
            /**
             * Returns the pagination configuration. The configuration is driven by the
             * (default) application configuration.
             *
             * The default application is limited to adding the start and end link:
             * ```ts
             *   addStart: true,
             *   addEnd: true
             * ```
             *
             * The application configuration is however merged into the following static configuration:
             * ```ts
             * {
             *   rangeCount: 3,
             *   dotsLabel: '...',
             *   startLabel: '«',
             *   previousLabel: '‹',
             *   nextLabel: '›',
             *   endLabel: '»'
             * }
             * ```
             */
            get: function () {
                return Object.assign(FALLBACK_PAGINATION_OPTIONS, this.paginationConfig.pagination);
            },
            enumerable: false,
            configurable: true
        });
        return PaginationBuilder;
    }());
    PaginationBuilder.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PaginationBuilder, deps: [{ token: PaginationConfig }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    PaginationBuilder.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PaginationBuilder, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PaginationBuilder, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: PaginationConfig }]; } });

    /**
     * The `PaginationComponent` is a generic component that is used for
     * all lists in Spartacus that require pagination. The component supports
     * all common features, which can be configured or hidden by CSS.
     */
    var PaginationComponent = /** @class */ (function () {
        function PaginationComponent(paginationBuilder, activatedRoute) {
            this.paginationBuilder = paginationBuilder;
            this.activatedRoute = activatedRoute;
            this.viewPageEvent = new i0.EventEmitter();
            this.pages = [];
        }
        Object.defineProperty(PaginationComponent.prototype, "pagination", {
            get: function () {
                return this._pagination;
            },
            set: function (value) {
                this._pagination = value;
                this.render(value);
            },
            enumerable: false,
            configurable: true
        });
        PaginationComponent.prototype.render = function (pagination) {
            if (!pagination) {
                return;
            }
            this.pages = this.paginationBuilder.paginate(pagination.totalPages, pagination.currentPage);
        };
        /**
         * Format aria-label based on pagination item type.
         *
         * @param label string
         * @param type PaginationItemType
         * @returns string
         */
        PaginationComponent.prototype.getAriaLabel = function (label, type) {
            // Convert 'Start' to First, and 'End' to Last for a more natural screen read.
            type = type === exports.PaginationItemType.START ? exports.PaginationItemType.FIRST : type;
            type = type === exports.PaginationItemType.END ? exports.PaginationItemType.LAST : type;
            return type === exports.PaginationItemType.PAGE
                ? type + " " + label
                : type + " " + exports.PaginationItemType.PAGE;
        };
        /**
         * Indicates whether the given item is the current item.
         *
         * @param item PaginationItem
         * @returns boolean
         */
        PaginationComponent.prototype.isCurrent = function (item) {
            return (item.type === exports.PaginationItemType.PAGE &&
                item.number === this.pagination.currentPage);
        };
        /**
         * Indicates whether the pagination item is inactive. This is used
         * to disabled a link or set the tabindex to `-1`.
         *
         * Defaults to true
         *
         * @param item PaginationItem
         * @returns returns -1 in case of a disabled
         */
        PaginationComponent.prototype.isInactive = function (item) {
            return (!item.hasOwnProperty('number') ||
                item.number === this.pagination.currentPage);
        };
        PaginationComponent.prototype.getQueryParams = function (item) {
            var queryParams = Object.assign({}, this.activatedRoute.snapshot.queryParams);
            if (this.queryParam &&
                item.number < this.pagination.totalPages &&
                !this.isCurrent(item)) {
                queryParams[this.queryParam] = item.number;
            }
            // omit the page number from the query parameters in case it's the default
            // to clean up the experience and avoid unnecessary polluting of the URL
            if (queryParams[this.queryParam] === this.defaultPage) {
                delete queryParams[this.queryParam];
            }
            return queryParams;
        };
        PaginationComponent.prototype.pageChange = function (page) {
            this.viewPageEvent.emit(page.number);
        };
        return PaginationComponent;
    }());
    PaginationComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PaginationComponent, deps: [{ token: PaginationBuilder }, { token: i1__namespace$1.ActivatedRoute }], target: i0__namespace.ɵɵFactoryTarget.Component });
    PaginationComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: PaginationComponent, selector: "cx-pagination", inputs: { pageRoute: "pageRoute", queryParam: "queryParam", defaultPage: "defaultPage", pagination: "pagination" }, outputs: { viewPageEvent: "viewPageEvent" }, ngImport: i0__namespace, template: "<a\n  *ngFor=\"let item of pages\"\n  [class]=\"item.type\"\n  [class.disabled]=\"isInactive(item)\"\n  [class.current]=\"isCurrent(item)\"\n  [routerLink]=\"pageRoute\"\n  [queryParams]=\"getQueryParams(item)\"\n  [tabIndex]=\"isInactive(item) ? -1 : 0\"\n  (click)=\"pageChange(item)\"\n  [attr.aria-label]=\"getAriaLabel(item.label, item.type)\"\n>\n  {{ item.label }}\n</a>\n", directives: [{ type: i3__namespace.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i1__namespace$1.RouterLinkWithHref, selector: "a[routerLink],area[routerLink]", inputs: ["routerLink", "target", "queryParams", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange", "replaceUrl", "state", "relativeTo"] }], changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PaginationComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-pagination',
                        templateUrl: './pagination.component.html',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], ctorParameters: function () { return [{ type: PaginationBuilder }, { type: i1__namespace$1.ActivatedRoute }]; }, propDecorators: { pageRoute: [{
                    type: i0.Input
                }], queryParam: [{
                    type: i0.Input
                }], defaultPage: [{
                    type: i0.Input
                }], pagination: [{
                    type: i0.Input
                }], viewPageEvent: [{
                    type: i0.Output
                }] } });

    var PaginationModule = /** @class */ (function () {
        function PaginationModule() {
        }
        return PaginationModule;
    }());
    PaginationModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PaginationModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    PaginationModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PaginationModule, declarations: [PaginationComponent], imports: [i3.CommonModule, i1$1.RouterModule], exports: [PaginationComponent] });
    PaginationModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PaginationModule, providers: [i1.provideDefaultConfig(defaultPaginationConfig)], imports: [[i3.CommonModule, i1$1.RouterModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PaginationModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [i3.CommonModule, i1$1.RouterModule],
                        providers: [i1.provideDefaultConfig(defaultPaginationConfig)],
                        declarations: [PaginationComponent],
                        exports: [PaginationComponent],
                    }]
            }] });

    var SortingComponent = /** @class */ (function () {
        function SortingComponent() {
            this.sortListEvent = new i0.EventEmitter();
        }
        SortingComponent.prototype.sortList = function (sortCode) {
            this.sortListEvent.emit(sortCode);
        };
        Object.defineProperty(SortingComponent.prototype, "selectedLabel", {
            get: function () {
                var _this = this;
                var _a, _b, _c, _d;
                return ((_c = (_b = (_a = this.sortOptions) === null || _a === void 0 ? void 0 : _a.find(function (sort) { return sort.code === _this.selectedOption; })) === null || _b === void 0 ? void 0 : _b.name) !== null && _c !== void 0 ? _c : (_d = this.sortLabels) === null || _d === void 0 ? void 0 : _d[this.selectedOption]);
            },
            enumerable: false,
            configurable: true
        });
        return SortingComponent;
    }());
    SortingComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SortingComponent, deps: [], target: i0__namespace.ɵɵFactoryTarget.Component });
    SortingComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: SortingComponent, selector: "cx-sorting", inputs: { sortOptions: "sortOptions", selectedOption: "selectedOption", placeholder: "placeholder", sortLabels: "sortLabels" }, outputs: { sortListEvent: "sortListEvent" }, ngImport: i0__namespace, template: "<ng-select\n  [searchable]=\"false\"\n  [clearable]=\"false\"\n  placeholder=\"{{ placeholder }}\"\n  (change)=\"sortList($event)\"\n  [ngModel]=\"selectedOption\"\n  [attr.aria-label]=\"selectedLabel || placeholder\"\n>\n  <ng-option *ngFor=\"let sort of sortOptions\" [value]=\"sort.code\">{{\n    sort.name ? sort.name : sortLabels ? sortLabels[sort.code] : ''\n  }}</ng-option>\n</ng-select>\n", components: [{ type: i1__namespace$4.NgSelectComponent, selector: "ng-select", inputs: ["markFirst", "dropdownPosition", "loading", "closeOnSelect", "hideSelected", "selectOnTab", "bufferAmount", "selectableGroup", "selectableGroupAsModel", "searchFn", "trackByFn", "clearOnBackspace", "labelForId", "inputAttrs", "readonly", "searchWhileComposing", "minTermLength", "editableSearchTerm", "keyDownFn", "multiple", "addTag", "searchable", "clearable", "isOpen", "items", "compareWith", "clearSearchOnAdd", "bindLabel", "placeholder", "notFoundText", "typeToSearchText", "addTagText", "loadingText", "clearAllText", "virtualScroll", "openOnEnter", "appendTo", "bindValue", "appearance", "maxSelectedItems", "groupBy", "groupValue", "tabIndex", "typeahead"], outputs: ["blur", "focus", "change", "open", "close", "search", "clear", "add", "remove", "scroll", "scrollToEnd"] }, { type: i1__namespace$4.ɵr, selector: "ng-option", inputs: ["disabled", "value"] }], directives: [{ type: i3__namespace$1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i3__namespace$1.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { type: i3__namespace.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SortingComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-sorting',
                        templateUrl: './sorting.component.html',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], ctorParameters: function () { return []; }, propDecorators: { sortOptions: [{
                    type: i0.Input
                }], selectedOption: [{
                    type: i0.Input
                }], placeholder: [{
                    type: i0.Input
                }], sortLabels: [{
                    type: i0.Input
                }], sortListEvent: [{
                    type: i0.Output
                }] } });

    var ListNavigationModule = /** @class */ (function () {
        function ListNavigationModule() {
        }
        return ListNavigationModule;
    }());
    ListNavigationModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ListNavigationModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    ListNavigationModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ListNavigationModule, declarations: [SortingComponent], imports: [i3.CommonModule,
            i1$4.NgSelectModule,
            i3$1.FormsModule,
            i3$1.ReactiveFormsModule,
            IconModule,
            PaginationModule], exports: [SortingComponent, PaginationComponent] });
    ListNavigationModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ListNavigationModule, imports: [[
                i3.CommonModule,
                i1$4.NgSelectModule,
                i3$1.FormsModule,
                i3$1.ReactiveFormsModule,
                IconModule,
                PaginationModule,
            ]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ListNavigationModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [
                            i3.CommonModule,
                            i1$4.NgSelectModule,
                            i3$1.FormsModule,
                            i3$1.ReactiveFormsModule,
                            IconModule,
                            PaginationModule,
                        ],
                        declarations: [SortingComponent],
                        exports: [SortingComponent, PaginationComponent],
                    }]
            }] });

    /**
     * Provides configuration specific to Media, such as images. This is used to optimize
     * rendering of the media, SEO and performance.
     */
    var MediaConfig = /** @class */ (function () {
        function MediaConfig() {
        }
        return MediaConfig;
    }());
    MediaConfig.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: MediaConfig, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    MediaConfig.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: MediaConfig, providedIn: 'root', useExisting: i1.Config });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: MediaConfig, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                        useExisting: i1.Config,
                    }]
            }] });

    /**
     * A reference to a newly opened modal
     *
     * @todo remove ngb dependency and create our own implementation of ModalRef
     */
    var ModalRef = /** @class */ (function (_super) {
        __extends(ModalRef, _super);
        function ModalRef() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return ModalRef;
    }(i1$3.NgbModalRef));

    var ModalModule = /** @class */ (function () {
        function ModalModule() {
        }
        return ModalModule;
    }());
    ModalModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ModalModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    ModalModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ModalModule, declarations: [ModalDirective], exports: [ModalDirective] });
    ModalModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ModalModule });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ModalModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        declarations: [ModalDirective],
                        exports: [ModalDirective],
                    }]
            }] });

    var OrderOverviewComponent = /** @class */ (function () {
        function OrderOverviewComponent(translation) {
            this.translation = translation;
        }
        Object.defineProperty(OrderOverviewComponent.prototype, "setOrder", {
            set: function (order) {
                this.order = order;
            },
            enumerable: false,
            configurable: true
        });
        OrderOverviewComponent.prototype.getReplenishmentCodeCardContent = function (orderCode) {
            return this.translation.translate('orderDetails.replenishmentId').pipe(operators.filter(function () { return Boolean(orderCode); }), operators.map(function (textTitle) { return ({
                title: textTitle,
                text: [orderCode],
            }); }));
        };
        OrderOverviewComponent.prototype.getReplenishmentActiveCardContent = function (active) {
            return rxjs.combineLatest([
                this.translation.translate('orderDetails.status'),
                this.translation.translate('orderDetails.active'),
                this.translation.translate('orderDetails.cancelled'),
            ]).pipe(operators.map(function (_c) {
                var _d = __read(_c, 3), textTitle = _d[0], textActive = _d[1], textCancelled = _d[2];
                return ({
                    title: textTitle,
                    text: [active ? textActive : textCancelled],
                });
            }));
        };
        OrderOverviewComponent.prototype.getReplenishmentStartOnCardContent = function (isoDate) {
            return this.translation.translate('orderDetails.startOn').pipe(operators.filter(function () { return Boolean(isoDate); }), operators.map(function (textTitle) {
                return {
                    title: textTitle,
                    text: [isoDate],
                };
            }));
        };
        OrderOverviewComponent.prototype.getReplenishmentFrequencyCardContent = function (frequency) {
            return this.translation.translate('orderDetails.frequency').pipe(operators.filter(function () { return Boolean(frequency); }), operators.map(function (textTitle) { return ({
                title: textTitle,
                text: [frequency],
            }); }));
        };
        OrderOverviewComponent.prototype.getReplenishmentNextDateCardContent = function (isoDate) {
            return this.translation.translate('orderDetails.nextOrderDate').pipe(operators.filter(function () { return Boolean(isoDate); }), operators.map(function (textTitle) {
                return {
                    title: textTitle,
                    text: [isoDate],
                };
            }));
        };
        OrderOverviewComponent.prototype.getOrderCodeCardContent = function (orderCode) {
            return this.translation.translate('orderDetails.orderNumber').pipe(operators.filter(function () { return Boolean(orderCode); }), operators.map(function (textTitle) { return ({
                title: textTitle,
                text: [orderCode],
            }); }));
        };
        OrderOverviewComponent.prototype.getOrderCurrentDateCardContent = function (isoDate) {
            return this.translation.translate('orderDetails.placedOn').pipe(operators.filter(function () { return Boolean(isoDate); }), operators.map(function (textTitle) {
                return {
                    title: textTitle,
                    text: [isoDate],
                };
            }));
        };
        OrderOverviewComponent.prototype.getOrderStatusCardContent = function (status) {
            return rxjs.combineLatest([
                this.translation.translate('orderDetails.status'),
                this.translation.translate('orderDetails.statusDisplay_' + status),
            ]).pipe(operators.map(function (_c) {
                var _d = __read(_c, 2), textTitle = _d[0], textStatus = _d[1];
                return ({
                    title: textTitle,
                    text: [textStatus],
                });
            }));
        };
        OrderOverviewComponent.prototype.getPurchaseOrderNumber = function (poNumber) {
            return rxjs.combineLatest([
                this.translation.translate('orderDetails.purchaseOrderNumber'),
                this.translation.translate('orderDetails.emptyPurchaseOrderId'),
            ]).pipe(operators.map(function (_c) {
                var _d = __read(_c, 2), textTitle = _d[0], noneTextTitle = _d[1];
                return ({
                    title: textTitle,
                    text: [poNumber ? poNumber : noneTextTitle],
                });
            }));
        };
        OrderOverviewComponent.prototype.getMethodOfPaymentCardContent = function (hasPaymentInfo) {
            return rxjs.combineLatest([
                this.translation.translate('orderDetails.methodOfPayment'),
                this.translation.translate('paymentTypes.paymentType_ACCOUNT'),
                this.translation.translate('paymentTypes.paymentType_CARD'),
            ]).pipe(operators.map(function (_c) {
                var _d = __read(_c, 3), textTitle = _d[0], textAccount = _d[1], textCard = _d[2];
                return ({
                    title: textTitle,
                    text: [Boolean(hasPaymentInfo) ? textCard : textAccount],
                });
            }));
        };
        OrderOverviewComponent.prototype.getCostCenterCardContent = function (costCenter) {
            return this.translation.translate('orderDetails.costCenter').pipe(operators.filter(function () { return Boolean(costCenter); }), operators.map(function (textTitle) {
                var _a;
                return ({
                    title: textTitle,
                    textBold: costCenter === null || costCenter === void 0 ? void 0 : costCenter.name,
                    text: ['(' + ((_a = costCenter === null || costCenter === void 0 ? void 0 : costCenter.unit) === null || _a === void 0 ? void 0 : _a.name) + ')'],
                });
            }));
        };
        OrderOverviewComponent.prototype.getAddressCardContent = function (deliveryAddress) {
            var _this = this;
            return this.translation.translate('addressCard.shipTo').pipe(operators.filter(function () { return Boolean(deliveryAddress); }), operators.map(function (textTitle) {
                var formattedAddress = _this.normalizeFormattedAddress(deliveryAddress.formattedAddress);
                return {
                    title: textTitle,
                    textBold: deliveryAddress.firstName + " " + deliveryAddress.lastName,
                    text: [formattedAddress, deliveryAddress.country.name],
                };
            }));
        };
        OrderOverviewComponent.prototype.getDeliveryModeCardContent = function (deliveryMode) {
            return this.translation.translate('orderDetails.shippingMethod').pipe(operators.filter(function () { return Boolean(deliveryMode); }), operators.map(function (textTitle) {
                var _a, _b;
                return ({
                    title: textTitle,
                    textBold: deliveryMode.name,
                    text: [
                        deliveryMode.description,
                        ((_a = deliveryMode.deliveryCost) === null || _a === void 0 ? void 0 : _a.formattedValue)
                            ? (_b = deliveryMode.deliveryCost) === null || _b === void 0 ? void 0 : _b.formattedValue
                            : '',
                    ],
                });
            }));
        };
        OrderOverviewComponent.prototype.getPaymentInfoCardContent = function (payment) {
            return rxjs.combineLatest([
                this.translation.translate('paymentForm.payment'),
                this.translation.translate('paymentCard.expires', {
                    month: Boolean(payment) ? payment.expiryMonth : '',
                    year: Boolean(payment) ? payment.expiryYear : '',
                }),
            ]).pipe(operators.filter(function () { return Boolean(payment); }), operators.map(function (_c) {
                var _d = __read(_c, 2), textTitle = _d[0], textExpires = _d[1];
                return ({
                    title: textTitle,
                    textBold: payment.accountHolderName,
                    text: [payment.cardNumber, textExpires],
                });
            }));
        };
        OrderOverviewComponent.prototype.getBillingAddressCardContent = function (billingAddress) {
            return this.translation.translate('paymentForm.billingAddress').pipe(operators.filter(function () { return Boolean(billingAddress); }), operators.map(function (textTitle) { return ({
                title: textTitle,
                textBold: billingAddress.firstName + " " + billingAddress.lastName,
                text: [billingAddress.formattedAddress, billingAddress.country.name],
            }); }));
        };
        OrderOverviewComponent.prototype.normalizeFormattedAddress = function (formattedAddress) {
            var addresses = formattedAddress
                .split(',')
                .map(function (address) { return address.trim(); });
            var newFormattedAddress = addresses.filter(Boolean).join(', ');
            return newFormattedAddress;
        };
        return OrderOverviewComponent;
    }());
    OrderOverviewComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OrderOverviewComponent, deps: [{ token: i1__namespace.TranslationService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    OrderOverviewComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: OrderOverviewComponent, selector: "cx-order-overview", inputs: { setOrder: ["order", "setOrder"] }, ngImport: i0__namespace, template: "<div class=\"cx-order-summary\">\n  <div class=\"container\">\n    <ng-container *ngIf=\"order.replenishmentOrderCode; else otherOrder\">\n      <div class=\"cx-summary-card\">\n        <cx-card\n          [content]=\"\n            getReplenishmentCodeCardContent(order?.replenishmentOrderCode)\n              | async\n          \"\n        ></cx-card>\n\n        <cx-card\n          [content]=\"getReplenishmentActiveCardContent(order?.active) | async\"\n        ></cx-card>\n      </div>\n\n      <div class=\"cx-summary-card\">\n        <cx-card\n          [content]=\"\n            getReplenishmentStartOnCardContent(order?.firstDate | cxDate)\n              | async\n          \"\n        ></cx-card>\n\n        <cx-card\n          [content]=\"\n            getReplenishmentFrequencyCardContent(\n              order?.trigger?.displayTimeTable\n            ) | async\n          \"\n        ></cx-card>\n\n        <cx-card\n          [content]=\"\n            getReplenishmentNextDateCardContent(\n              order?.trigger?.activationTime | cxDate\n            ) | async\n          \"\n        ></cx-card>\n      </div>\n    </ng-container>\n\n    <ng-template #otherOrder>\n      <div class=\"cx-summary-card\">\n        <cx-card\n          [content]=\"getOrderCodeCardContent(order?.code) | async\"\n        ></cx-card>\n\n        <cx-card\n          [content]=\"\n            getOrderCurrentDateCardContent(order?.created | cxDate) | async\n          \"\n        ></cx-card>\n\n        <cx-card\n          [content]=\"getOrderStatusCardContent(order.statusDisplay) | async\"\n        ></cx-card>\n      </div>\n    </ng-template>\n\n    <ng-container\n      *ngIf=\"order.purchaseOrderNumber || order.purchaseOrderNumber === ''\"\n    >\n      <div class=\"cx-summary-card\">\n        <cx-card\n          [content]=\"getPurchaseOrderNumber(order?.purchaseOrderNumber) | async\"\n        ></cx-card>\n\n        <cx-card\n          [content]=\"getMethodOfPaymentCardContent(order.paymentInfo) | async\"\n        ></cx-card>\n\n        <ng-container *ngIf=\"order.costCenter\">\n          <cx-card\n            [content]=\"getCostCenterCardContent(order?.costCenter) | async\"\n          ></cx-card>\n        </ng-container>\n      </div>\n    </ng-container>\n\n    <div class=\"cx-summary-card\">\n      <ng-container *ngIf=\"order.deliveryAddress\">\n        <cx-card\n          [content]=\"getAddressCardContent(order?.deliveryAddress) | async\"\n        ></cx-card>\n      </ng-container>\n\n      <ng-container *ngIf=\"order.deliveryMode\">\n        <cx-card\n          [content]=\"getDeliveryModeCardContent(order?.deliveryMode) | async\"\n        ></cx-card>\n      </ng-container>\n    </div>\n\n    <ng-container *ngIf=\"order.paymentInfo\">\n      <div class=\"cx-summary-card\">\n        <cx-card\n          [content]=\"getPaymentInfoCardContent(order?.paymentInfo) | async\"\n        ></cx-card>\n\n        <cx-card\n          [content]=\"\n            getBillingAddressCardContent(order?.paymentInfo?.billingAddress)\n              | async\n          \"\n        ></cx-card>\n      </div>\n    </ng-container>\n  </div>\n</div>\n", components: [{ type: CardComponent, selector: "cx-card", inputs: ["border", "editMode", "isDefault", "content", "fitToContainer", "truncateText", "charactersLimit"], outputs: ["deleteCard", "setDefaultCard", "sendCard", "editCard", "cancelCard"] }], directives: [{ type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "async": i3__namespace.AsyncPipe, "cxDate": i1__namespace.CxDatePipe }, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OrderOverviewComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-order-overview',
                        templateUrl: './order-overview.component.html',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace.TranslationService }]; }, propDecorators: { setOrder: [{
                    type: i0.Input,
                    args: ['order']
                }] } });

    var OrderOverviewModule = /** @class */ (function () {
        function OrderOverviewModule() {
        }
        return OrderOverviewModule;
    }());
    OrderOverviewModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OrderOverviewModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    OrderOverviewModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OrderOverviewModule, declarations: [OrderOverviewComponent], imports: [i3.CommonModule, i1.I18nModule, CardModule], exports: [OrderOverviewComponent] });
    OrderOverviewModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OrderOverviewModule, imports: [[i3.CommonModule, i1.I18nModule, CardModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OrderOverviewModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [i3.CommonModule, i1.I18nModule, CardModule],
                        declarations: [OrderOverviewComponent],
                        exports: [OrderOverviewComponent],
                    }]
            }] });

    var ProgressButtonComponent = /** @class */ (function () {
        function ProgressButtonComponent() {
            this.ariaLabel = '';
            this.class = '';
            this.disabled = false;
            this.loading = false;
            this.clikEvent = new i0.EventEmitter();
        }
        return ProgressButtonComponent;
    }());
    ProgressButtonComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProgressButtonComponent, deps: [], target: i0__namespace.ɵɵFactoryTarget.Component });
    ProgressButtonComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: ProgressButtonComponent, selector: "cx-progress-button", inputs: { ariaLabel: "ariaLabel", class: "class", disabled: "disabled", loading: "loading" }, outputs: { clikEvent: "clikEvent" }, ngImport: i0__namespace, template: "<button\n  (click)=\"clikEvent.emit()\"\n  [attr.aria-label]=\"ariaLabel\"\n  [disabled]=\"disabled || loading\"\n  [ngClass]=\"class\"\n  class=\"btn btn-primary\"\n>\n  <div class=\"cx-progress-button-container\">\n    <div *ngIf=\"loading\" class=\"loader-container\">\n      <div class=\"loader\">{{ 'spinner.loading' | cxTranslate }}</div>\n    </div>\n\n    <ng-content></ng-content>\n  </div>\n</button>\n", directives: [{ type: i3__namespace.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "cxTranslate": i1__namespace.TranslatePipe } });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProgressButtonComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-progress-button',
                        templateUrl: './progress-button.component.html',
                    }]
            }], ctorParameters: function () { return []; }, propDecorators: { ariaLabel: [{
                    type: i0.Input
                }], class: [{
                    type: i0.Input
                }], disabled: [{
                    type: i0.Input
                }], loading: [{
                    type: i0.Input
                }], clikEvent: [{
                    type: i0.Output
                }] } });

    var ProgressButtonModule = /** @class */ (function () {
        function ProgressButtonModule() {
        }
        return ProgressButtonModule;
    }());
    ProgressButtonModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProgressButtonModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    ProgressButtonModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProgressButtonModule, declarations: [ProgressButtonComponent], imports: [i3.CommonModule, i1.I18nModule], exports: [ProgressButtonComponent] });
    ProgressButtonModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProgressButtonModule, imports: [[i3.CommonModule, i1.I18nModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProgressButtonModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [i3.CommonModule, i1.I18nModule],
                        declarations: [ProgressButtonComponent],
                        exports: [ProgressButtonComponent],
                    }]
            }] });

    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var ReplenishmentOrderCancellationDialogComponent = /** @class */ (function () {
        function ReplenishmentOrderCancellationDialogComponent(userReplenishmentOrderService, globalMessageService, launchDialogService, el) {
            this.userReplenishmentOrderService = userReplenishmentOrderService;
            this.globalMessageService = globalMessageService;
            this.launchDialogService = launchDialogService;
            this.el = el;
            this.subscription = new rxjs.Subscription();
            this.focusConfig = {
                trap: true,
                block: true,
                autofocus: 'button',
                focusOnEscape: true,
            };
        }
        ReplenishmentOrderCancellationDialogComponent.prototype.handleClick = function (event) {
            // Close on click outside the dialog window
            if (event.target.tagName === this.el.nativeElement.tagName) {
                this.close('Cross click');
            }
        };
        ReplenishmentOrderCancellationDialogComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.subscription.add(rxjs.combineLatest([
                this.userReplenishmentOrderService
                    .getReplenishmentOrderDetails()
                    .pipe(operators.startWith(null)),
                this.launchDialogService.data$,
            ]).subscribe(function (_a) {
                var _b = __read(_a, 2), replenishmentOrder = _b[0], code = _b[1];
                _this.replenishmentOrderCode =
                    code || replenishmentOrder.replenishmentOrderCode;
            }));
            this.subscription.add(this.userReplenishmentOrderService
                .getCancelReplenishmentOrderSuccess()
                .subscribe(function (value) { return _this.onSuccess(value); }));
        };
        ReplenishmentOrderCancellationDialogComponent.prototype.onSuccess = function (value) {
            if (value) {
                this.launchDialogService.closeDialog('Successffully cancelled replenishment');
                this.globalMessageService.add({
                    key: 'orderDetails.cancelReplenishment.cancelSuccess',
                    params: {
                        replenishmentOrderCode: this.replenishmentOrderCode,
                    },
                }, i1.GlobalMessageType.MSG_TYPE_CONFIRMATION);
            }
            this.userReplenishmentOrderService.clearCancelReplenishmentOrderProcessState();
        };
        ReplenishmentOrderCancellationDialogComponent.prototype.close = function (reason) {
            this.launchDialogService.closeDialog(reason);
        };
        ReplenishmentOrderCancellationDialogComponent.prototype.cancelReplenishment = function () {
            this.userReplenishmentOrderService.cancelReplenishmentOrder(this.replenishmentOrderCode);
        };
        ReplenishmentOrderCancellationDialogComponent.prototype.ngOnDestroy = function () {
            this.subscription.unsubscribe();
        };
        return ReplenishmentOrderCancellationDialogComponent;
    }());
    ReplenishmentOrderCancellationDialogComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ReplenishmentOrderCancellationDialogComponent, deps: [{ token: i1__namespace.UserReplenishmentOrderService }, { token: i1__namespace.GlobalMessageService }, { token: LaunchDialogService }, { token: i0__namespace.ElementRef }], target: i0__namespace.ɵɵFactoryTarget.Component });
    ReplenishmentOrderCancellationDialogComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: ReplenishmentOrderCancellationDialogComponent, selector: "cx-replenishment-order-cancellation-dialog", host: { listeners: { "click": "handleClick($event)" } }, ngImport: i0__namespace, template: "<div\n  [cxFocus]=\"focusConfig\"\n  (esc)=\"close('Escape clicked')\"\n  class=\"cx-cancel-replenishment-dialog-foreground\"\n>\n  <div class=\"cx-cancel-replenishment-dialog-content\">\n    <div class=\"cx-cancel-replenishment-dialog-header\">\n      <h3>\n        {{ 'orderDetails.cancelReplenishment.title' | cxTranslate }}\n      </h3>\n    </div>\n    <div class=\"cx-cancel-replenishment-dialog-description\">\n      {{ 'orderDetails.cancelReplenishment.description' | cxTranslate }}\n    </div>\n\n    <div class=\"cx-cancel-replenishment-dialog-body\">\n      <div class=\"cx-cancel-replenishment-btns row\">\n        <div class=\"col-md-6\">\n          <button\n            class=\"btn btn-block btn-action\"\n            (click)=\"close('Close Replenishment Dialog')\"\n          >\n            {{ 'orderDetails.cancelReplenishment.reject' | cxTranslate }}\n          </button>\n        </div>\n        <div class=\"col-md-6\">\n          <button\n            class=\"btn btn-block btn-primary\"\n            (click)=\"cancelReplenishment()\"\n          >\n            {{ 'orderDetails.cancelReplenishment.accept' | cxTranslate }}\n          </button>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n", directives: [{ type: FocusDirective, selector: "[cxFocus]", inputs: ["cxFocus"] }], pipes: { "cxTranslate": i1__namespace.TranslatePipe } });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ReplenishmentOrderCancellationDialogComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-replenishment-order-cancellation-dialog',
                        templateUrl: './replenishment-order-cancellation-dialog.component.html',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace.UserReplenishmentOrderService }, { type: i1__namespace.GlobalMessageService }, { type: LaunchDialogService }, { type: i0__namespace.ElementRef }]; }, propDecorators: { handleClick: [{
                    type: i0.HostListener,
                    args: ['click', ['$event']]
                }] } });

    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var ReplenishmentOrderCancellationDialogModule = /** @class */ (function () {
        function ReplenishmentOrderCancellationDialogModule() {
        }
        return ReplenishmentOrderCancellationDialogModule;
    }());
    ReplenishmentOrderCancellationDialogModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ReplenishmentOrderCancellationDialogModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    ReplenishmentOrderCancellationDialogModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ReplenishmentOrderCancellationDialogModule, declarations: [ReplenishmentOrderCancellationDialogComponent], imports: [i3.CommonModule, i1.I18nModule, KeyboardFocusModule], exports: [ReplenishmentOrderCancellationDialogComponent] });
    ReplenishmentOrderCancellationDialogModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ReplenishmentOrderCancellationDialogModule, imports: [[i3.CommonModule, i1.I18nModule, KeyboardFocusModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ReplenishmentOrderCancellationDialogModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [i3.CommonModule, i1.I18nModule, KeyboardFocusModule],
                        declarations: [ReplenishmentOrderCancellationDialogComponent],
                        exports: [ReplenishmentOrderCancellationDialogComponent],
                    }]
            }] });

    /**
     * Supposed to be injected in the split view component, so that the split view state
     * is maintained for a single split view.
     */
    var SplitViewService = /** @class */ (function () {
        function SplitViewService() {
            /**
             * Newly added views are hidden by default, unless it is the first view of the split view.
             * The default hide mode can be overridden.
             */
            this.defaultHideMode = true;
            this.splitViewCount = 1;
            this._views$ = new rxjs.BehaviorSubject([]);
        }
        /**
         * Adds a view to the list of views. The view is initialized with the `SplitViewState`
         * state. If no state is provided, the state is created with the hidden property. The hidden
         * property is provided by the `defaultHideMode`, unless it's the first view (position: 0).
         */
        SplitViewService.prototype.add = function (position, initialState) {
            var state = Object.assign({ hidden: position === 0 ? false : this.defaultHideMode }, initialState);
            if (!this.views[position]) {
                this.views[position] = state;
                this.updateState(position, state.hidden);
                this._views$.next(this.views);
            }
        };
        /**
         * The split view is based on a number of views that can be used next to each other.
         * When the number changes (i.e. if the screen goes from wide to small), the visibility state
         * of the views should be updated.
         */
        SplitViewService.prototype.updateSplitView = function (splitViewCount) {
            if (splitViewCount !== this.splitViewCount) {
                this.splitViewCount = splitViewCount;
                this.updateState();
            }
        };
        /**
         * Returns an observable with the active view number. The active view number
         * represents the last visible view.
         */
        SplitViewService.prototype.getActiveView = function () {
            var _this = this;
            return this._views$.pipe(operators.map(function (views) { return _this.getActive(views); }), operators.distinctUntilChanged());
        };
        /**
         * Returns an observable with the SplitViewState for the given view position.
         */
        SplitViewService.prototype.getViewState = function (position) {
            return this._views$.pipe(operators.map(function (views) { return views[position]; }), 
            // we must filter here, since outlet driven views will destroyed the view
            operators.filter(function (view) { return Boolean(view); }));
        };
        /**
         * Removes a view from the list of views.
         *
         * Removing a view is different from hiding a view. Removing a view is typically done
         * when a component is destroyed.
         *
         * When the view is removed, the SplitViewState is updated to reflect that new organization
         * of views.
         */
        SplitViewService.prototype.remove = function (position) {
            var activePosition = this.getActive(this.views);
            this._views$.next(this.views.splice(0, position));
            if (activePosition >= position) {
                this.updateState(position);
            }
        };
        Object.defineProperty(SplitViewService.prototype, "nextPosition", {
            /**
             * Returns the next view position. This is useful for views that do not want to be bothered
             * with controlling view numbers.
             */
            get: function () {
                return this.views.length || 0;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Toggles the visibility of the views based on the given view position. If the view
         * is already visible, we close the view and active the former view. Unless the hide flag
         * is used, to force the view.
         *
         * The view state of other views in the split view are updated as well.
         *
         * @param position The zero-based position number of the view.
         * @param forceHide The (optional) hide state for the view position.
         */
        SplitViewService.prototype.toggle = function (position, forceHide) {
            // add the view if it hasn't been added before.
            if (!this.views[position]) {
                this.add(position, { hidden: forceHide !== null && forceHide !== void 0 ? forceHide : false });
            }
            // If the position is already visible, we move to a previous position. Only if the hide
            // state is forced, we keep the current position.
            if (this.views[position] &&
                forceHide === undefined &&
                !this.views[position].hidden) {
                position--;
            }
            this.updateState(position, forceHide === true);
        };
        /**
         * Updates the hidden state of all the views.
         */
        SplitViewService.prototype.updateState = function (position, hide) {
            var _this = this;
            var views = __spreadArray([], __read(this.views));
            if (hide !== undefined && views[position]) {
                views[position].hidden = hide;
            }
            var lastVisible = views.length - __spreadArray([], __read(views)).reverse().findIndex(function (view) { return !view.hidden; }) - 1;
            if (lastVisible === views.length) {
                if (position) {
                    // When there's only 1 view (mobile), we might not find any active
                    // if the user navigates back.
                    lastVisible = position - 1;
                }
                else {
                    lastVisible = views.length - 1;
                }
            }
            views.forEach(function (view, pos) {
                if (view && pos !== position) {
                    // hide other views that are outside the split view
                    view.hidden =
                        pos > lastVisible || pos < lastVisible - (_this.splitViewCount - 1);
                }
            });
            this._views$.next(views);
        };
        /**
         * Returns the active view count for the list of views.
         */
        SplitViewService.prototype.getActive = function (views) {
            // we reverse the list to find the last visible view
            var l = __spreadArray([], __read(views)).reverse()
                .findIndex(function (view) { return !view.hidden; });
            var last = l === -1 ? 0 : views.length - l - 1;
            return last;
        };
        Object.defineProperty(SplitViewService.prototype, "views", {
            /**
             * Utility method that resolves all views from the subject.
             */
            get: function () {
                return this._views$.value;
            },
            enumerable: false,
            configurable: true
        });
        return SplitViewService;
    }());
    SplitViewService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SplitViewService, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    SplitViewService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SplitViewService });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SplitViewService, decorators: [{
                type: i0.Injectable
            }] });

    /**
     * The split-view component supports an unlimited number of nested views. The component
     * is a host to those view components and doesn't add any restrictions to it's content;
     * content is projected as-is.
     *
     * ```html
     * <cx-split-view>
     *   <cx-view></cx-view>
     *   <cx-view></cx-view>
     *   <any-wrapper>
     *     <cx-view></cx-view>
     *   </any-wrapper>
     * </cx-split-view>
     * ```
     *
     * The split view component is only concerned with tracking the underlying _visible_
     * view components, so that the `lastVisibleView` can be updated accordingly. The actual
     * visibility of views is controlled by CSS. To allow for maximum flexibility, the CSS
     * implementation is using CSS variables. The `lastVisibleView` is bind to the
     * `--cx-active-view` on the host, so that all descendants views will inherit the
     * property conveniently.
     */
    var SplitViewComponent = /** @class */ (function () {
        function SplitViewComponent(splitService, breakpointService, elementRef) {
            this.splitService = splitService;
            this.breakpointService = breakpointService;
            this.elementRef = elementRef;
            this.subscription = new rxjs.Subscription();
            /**
             * Indicates the last visible view in the range of views that is visible. This
             * is bind to a css variable `--cx-active-view` so that the experience
             * can be fully controlled by css.
             */
            this.lastVisibleView = 1;
        }
        Object.defineProperty(SplitViewComponent.prototype, "hideMode", {
            /**
             * Sets the default hide mode for views. This mode is useful in case views are dynamically being created,
             * for example when they are created by router components.
             *
             * The mode defaults to true, unless this is the first view; the first view is never hidden.
             */
            set: function (mode) {
                this.splitService.defaultHideMode = mode;
            },
            enumerable: false,
            configurable: true
        });
        SplitViewComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.subscription.add(this.splitService
                .getActiveView()
                .subscribe(function (lastVisible) { return (_this.lastVisibleView = lastVisible + 1); }));
            this.subscription.add(this.breakpointService.breakpoint$.subscribe(function () {
                _this.splitService.updateSplitView(_this.splitViewCount);
            }));
        };
        Object.defineProperty(SplitViewComponent.prototype, "splitViewCount", {
            /**
             * Returns the maximum number of views per split-view. The number is based on the
             * CSS custom property `--cx-max-views`.
             */
            get: function () {
                return Number(getComputedStyle(this.elementRef.nativeElement).getPropertyValue('--cx-max-views'));
            },
            enumerable: false,
            configurable: true
        });
        SplitViewComponent.prototype.ngOnDestroy = function () {
            this.subscription.unsubscribe();
        };
        return SplitViewComponent;
    }());
    SplitViewComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SplitViewComponent, deps: [{ token: SplitViewService }, { token: BreakpointService }, { token: i0__namespace.ElementRef }], target: i0__namespace.ɵɵFactoryTarget.Component });
    SplitViewComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: SplitViewComponent, selector: "cx-split-view", inputs: { hideMode: "hideMode" }, host: { properties: { "style.--cx-active-view": "this.lastVisibleView", "attr.active-view": "this.lastVisibleView" } }, providers: [SplitViewService], ngImport: i0__namespace, template: "<ng-content></ng-content>\n", changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SplitViewComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-split-view',
                        templateUrl: './split-view.component.html',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        providers: [SplitViewService],
                    }]
            }], ctorParameters: function () { return [{ type: SplitViewService }, { type: BreakpointService }, { type: i0__namespace.ElementRef }]; }, propDecorators: { hideMode: [{
                    type: i0.Input
                }], lastVisibleView: [{
                    type: i0.HostBinding,
                    args: ['style.--cx-active-view']
                }, {
                    type: i0.HostBinding,
                    args: ['attr.active-view']
                }] } });

    /**
     * The view component is part of the `SplitViewComponent`. The view
     * contains the navigable content that should be split up. It maintains
     * a view position and allows to show or hide the view.
     *
     * The ViewComponent interacts with the `SplitViewService` for handing over the
     * view state, so that the overarching `SplitViewComponent` can manage the
     * overall experience.
     */
    var ViewComponent = /** @class */ (function () {
        function ViewComponent(splitService, elementRef, cd) {
            this.splitService = splitService;
            this.elementRef = elementRef;
            this.cd = cd;
            /**
             * The disappeared flag is added to the
             */
            this.disappeared = true;
            /**
             * An update of the view visibility is emitted to the hiddenChange output.
             */
            this.hiddenChange = new i0.EventEmitter();
        }
        Object.defineProperty(ViewComponent.prototype, "hidden", {
            /**
             * The hidden input is used to set the initial visible state of the view.
             * The hidden state defaults to false.
             *
             * The hidden input supports 2-way binding, see `hiddenChange` property.
             */
            set: function (hidden) {
                this._hidden = hidden;
                this.splitService.toggle(this.viewPosition, hidden);
            },
            enumerable: false,
            configurable: true
        });
        ViewComponent.prototype.ngOnInit = function () {
            var _this = this;
            var hidden = this._hidden ? { hidden: this._hidden } : {};
            this.splitService.add(this.viewPosition, hidden);
            this.subscription = this.splitService
                .getViewState(this.viewPosition)
                // delay the disappeared state, so that the (CSS driven) animation has time to finish
                .pipe(operators.delayWhen(function (view) { return rxjs.timer(view.hidden ? _this.duration * 1.25 : 0); }))
                .subscribe(function (view) {
                _this.hiddenChange.emit(view.hidden);
                _this._hidden = view.hidden;
                _this.disappeared = view.hidden;
                _this.cd.markForCheck();
            });
        };
        /**
         * Toggles the visibility of the view.
         *
         * An optional force flag can be used to explicitly show or hide view component.
         */
        ViewComponent.prototype.toggle = function (force) {
            this.splitService.toggle(this.viewPosition, force);
        };
        Object.defineProperty(ViewComponent.prototype, "viewPosition", {
            /**
             * Returns the position for the view.
             *
             * The position is either taken from the input `position` or generated by the `SplitService`.
             */
            get: function () {
                if (!(Number(this.position) >= 0)) {
                    this.position = this.splitService.nextPosition.toString();
                }
                return Number(this.position);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ViewComponent.prototype, "duration", {
            /**
             * Returns the duration in milliseconds. The duration is based on the CSS custom property
             * `--cx-transition-duration`. Defaults to 300 milliseconds.
             */
            get: function () {
                var duration = getComputedStyle(this.elementRef.nativeElement)
                    .getPropertyValue('--cx-transition-duration')
                    .trim();
                if (duration.indexOf('ms') > -1) {
                    return Number(duration.split('ms')[0]);
                }
                else if (duration.indexOf('s') > -1) {
                    return Number(duration.split('s')[0]) * 1000;
                }
                else {
                    return 300;
                }
            },
            enumerable: false,
            configurable: true
        });
        /**
         * The view is removed from the `SplitService` so that the view no longer
         * plays a role in the overall split view.
         */
        ViewComponent.prototype.ngOnDestroy = function () {
            var _a;
            this.splitService.remove(this.viewPosition);
            (_a = this.subscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();
        };
        return ViewComponent;
    }());
    ViewComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ViewComponent, deps: [{ token: SplitViewService }, { token: i0__namespace.ElementRef }, { token: i0__namespace.ChangeDetectorRef }], target: i0__namespace.ɵɵFactoryTarget.Component });
    ViewComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: ViewComponent, selector: "cx-view", inputs: { position: "position", hidden: "hidden" }, outputs: { hiddenChange: "hiddenChange" }, host: { properties: { "attr.position": "this.position", "style.--cx-view-position": "this.position", "attr.disappeared": "this.disappeared" } }, ngImport: i0__namespace, template: "<ng-content></ng-content>\n", changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ViewComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-view',
                        templateUrl: './view.component.html',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], ctorParameters: function () { return [{ type: SplitViewService }, { type: i0__namespace.ElementRef }, { type: i0__namespace.ChangeDetectorRef }]; }, propDecorators: { position: [{
                    type: i0.Input
                }, {
                    type: i0.HostBinding,
                    args: ['attr.position']
                }, {
                    type: i0.HostBinding,
                    args: ['style.--cx-view-position']
                }], disappeared: [{
                    type: i0.HostBinding,
                    args: ['attr.disappeared']
                }], hidden: [{
                    type: i0.Input
                }], hiddenChange: [{
                    type: i0.Output
                }] } });

    /**
     * The split-view component supports an unlimited number of nested views. Nested views are rendered
     * next to each other. The views can be rendered next to each other, but the max number of visible
     * views can be limisted as well. This is configurable in the CSS layer, so that the max number of views
     * per split-view can be different for each component.
     *
     * The basic structure of the split-view component is shown below:
     *
     *
     * ```
     * <cx-split-view>
     * </cx-split-view>
     * ```
     *
     * The UX pattern used for the split-view is driven by an initial view, which gets splitted into
     * more views as soon as the user starts interacting with the initial and subsequantial views.
     * The views can be driven by routes, which means that you can navigate through the splitted views
     * by using the browser history as well as share or bookmark splitted views.
     *
     * The UI is implemented in the style layer, with only a few generic style rules. Most of the split
     * view style is driven by CSS properties, so that alternative split-view styles can be introduced
     * per page or component.
     *
     * The max number of views per split-view on mobile is limited to 1 by default, where as on tablet
     * (and higher) it is set to 2. Spartacus has a pretty narrow layout, which is why 2 is maximum,
     * but customers could alter the layout to bring in more views in the same split-view at the time.
     *
     */
    var SplitViewModule = /** @class */ (function () {
        function SplitViewModule() {
        }
        return SplitViewModule;
    }());
    SplitViewModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SplitViewModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    SplitViewModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SplitViewModule, declarations: [SplitViewComponent, ViewComponent], imports: [i3.CommonModule, i1$1.RouterModule], exports: [SplitViewComponent, ViewComponent] });
    SplitViewModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SplitViewModule, imports: [[i3.CommonModule, i1$1.RouterModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SplitViewModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        declarations: [SplitViewComponent, ViewComponent],
                        imports: [i3.CommonModule, i1$1.RouterModule],
                        exports: [SplitViewComponent, ViewComponent],
                    }]
            }] });

    var GlobalMessageComponent = /** @class */ (function () {
        function GlobalMessageComponent(globalMessageService) {
            this.globalMessageService = globalMessageService;
            this.iconTypes = exports.ICON_TYPE;
            this.messageType = i1.GlobalMessageType;
        }
        GlobalMessageComponent.prototype.ngOnInit = function () {
            this.messages$ = this.globalMessageService.get();
        };
        GlobalMessageComponent.prototype.clear = function (type, index) {
            this.globalMessageService.remove(type, index);
        };
        return GlobalMessageComponent;
    }());
    GlobalMessageComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: GlobalMessageComponent, deps: [{ token: i1__namespace.GlobalMessageService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    GlobalMessageComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: GlobalMessageComponent, selector: "cx-global-message", ngImport: i0__namespace, template: "<div *ngIf=\"messages$ | async as messages\">\n  <div\n    class=\"alert alert-success\"\n    *ngFor=\"\n      let confMsg of messages[messageType.MSG_TYPE_CONFIRMATION];\n      let i = index\n    \"\n  >\n    <span class=\"alert-icon\">\n      <cx-icon [type]=\"iconTypes.SUCCESS\"></cx-icon>\n    </span>\n    <span>{{ confMsg | cxTranslate }}</span>\n    <button\n      class=\"close\"\n      type=\"button\"\n      (click)=\"clear(messageType.MSG_TYPE_CONFIRMATION, i)\"\n    >\n      <cx-icon [type]=\"iconTypes.CLOSE\"></cx-icon>\n    </button>\n  </div>\n  <div\n    class=\"alert alert-info\"\n    *ngFor=\"let infoMsg of messages[messageType.MSG_TYPE_INFO]; let i = index\"\n  >\n    <span class=\"alert-icon\">\n      <cx-icon [type]=\"iconTypes.INFO\"></cx-icon>\n    </span>\n    <span>{{ infoMsg | cxTranslate }}</span>\n    <button\n      class=\"close\"\n      type=\"button\"\n      (click)=\"clear(messageType.MSG_TYPE_INFO, i)\"\n    >\n      <cx-icon [type]=\"iconTypes.CLOSE\"></cx-icon>\n    </button>\n  </div>\n  <div\n    class=\"alert alert-warning\"\n    *ngFor=\"\n      let infoMsg of messages[messageType.MSG_TYPE_WARNING];\n      let i = index\n    \"\n  >\n    <span class=\"alert-icon\">\n      <cx-icon [type]=\"iconTypes.WARNING\"></cx-icon>\n    </span>\n    <span>{{ infoMsg | cxTranslate }}</span>\n    <button\n      class=\"close\"\n      type=\"button\"\n      (click)=\"clear(messageType.MSG_TYPE_WARNING, i)\"\n    >\n      <cx-icon [type]=\"iconTypes.CLOSE\"></cx-icon>\n    </button>\n  </div>\n  <div\n    class=\"alert alert-danger\"\n    *ngFor=\"let errorMsg of messages[messageType.MSG_TYPE_ERROR]; let i = index\"\n  >\n    <span class=\"alert-icon\">\n      <cx-icon [type]=\"iconTypes.ERROR\"></cx-icon>\n    </span>\n    <span>{{ errorMsg | cxTranslate }}</span>\n    <button\n      class=\"close\"\n      type=\"button\"\n      (click)=\"clear(messageType.MSG_TYPE_ERROR, i)\"\n    >\n      <cx-icon [type]=\"iconTypes.CLOSE\"></cx-icon>\n    </button>\n  </div>\n</div>\n", components: [{ type: IconComponent, selector: "cx-icon,[cxIcon]", inputs: ["cxIcon", "type"] }], directives: [{ type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3__namespace.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], pipes: { "async": i3__namespace.AsyncPipe, "cxTranslate": i1__namespace.TranslatePipe } });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: GlobalMessageComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-global-message',
                        templateUrl: './global-message.component.html',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace.GlobalMessageService }]; } });

    var GlobalMessageComponentModule = /** @class */ (function () {
        function GlobalMessageComponentModule() {
        }
        return GlobalMessageComponentModule;
    }());
    GlobalMessageComponentModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: GlobalMessageComponentModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    GlobalMessageComponentModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: GlobalMessageComponentModule, declarations: [GlobalMessageComponent], imports: [i3.CommonModule, IconModule, i1.I18nModule], exports: [GlobalMessageComponent] });
    GlobalMessageComponentModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: GlobalMessageComponentModule, imports: [[i3.CommonModule, IconModule, i1.I18nModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: GlobalMessageComponentModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [i3.CommonModule, IconModule, i1.I18nModule],
                        declarations: [GlobalMessageComponent],
                        exports: [GlobalMessageComponent],
                    }]
            }] });

    var MessageComponent = /** @class */ (function () {
        function MessageComponent() {
            this.showBody = false;
            this.isVisibleCloseButton = true;
            this.closeMessage = new i0.EventEmitter();
            this.buttonAction = new i0.EventEmitter();
            this.iconTypes = exports.ICON_TYPE;
        }
        Object.defineProperty(MessageComponent.prototype, "getCssClassesForMessage", {
            get: function () {
                return {
                    'cx-message-success': this.type === i1.GlobalMessageType.MSG_TYPE_CONFIRMATION,
                    'cx-message-info': this.type === i1.GlobalMessageType.MSG_TYPE_INFO,
                    'cx-message-warning': this.type === i1.GlobalMessageType.MSG_TYPE_WARNING,
                    'cx-message-danger': this.type === i1.GlobalMessageType.MSG_TYPE_ERROR,
                };
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MessageComponent.prototype, "getIconType", {
            get: function () {
                switch (this.type) {
                    case i1.GlobalMessageType.MSG_TYPE_CONFIRMATION:
                        return exports.ICON_TYPE.SUCCESS;
                    case i1.GlobalMessageType.MSG_TYPE_WARNING:
                        return exports.ICON_TYPE.WARNING;
                    case i1.GlobalMessageType.MSG_TYPE_ERROR:
                        return exports.ICON_TYPE.ERROR;
                    case i1.GlobalMessageType.MSG_TYPE_INFO:
                        return exports.ICON_TYPE.INFO;
                }
            },
            enumerable: false,
            configurable: true
        });
        return MessageComponent;
    }());
    MessageComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: MessageComponent, deps: [], target: i0__namespace.ɵɵFactoryTarget.Component });
    MessageComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: MessageComponent, selector: "cx-message", inputs: { text: "text", actionButtonText: "actionButtonText", accordionText: "accordionText", showBody: "showBody", isVisibleCloseButton: "isVisibleCloseButton", type: "type" }, outputs: { closeMessage: "closeMessage", buttonAction: "buttonAction" }, ngImport: i0__namespace, template: "<div [ngClass]=\"getCssClassesForMessage\" class=\"cx-message\">\n  <div class=\"cx-message-content\">\n    <div class=\"cx-message-header\">\n      <span class=\"cx-message-icon\">\n        <cx-icon [type]=\"getIconType\"></cx-icon>\n      </span>\n\n      <span class=\"cx-message-text\">\n        {{ text }}\n        <button\n          *ngIf=\"accordionText\"\n          (click)=\"showBody = !showBody\"\n          class=\"cx-message-accordion-button link cx-action-link\"\n          type=\"button\"\n        >\n          {{ accordionText }}\n          <cx-icon\n            [type]=\"showBody ? 'CARET_UP' : 'CARET_DOWN'\"\n            class=\"cx-message-accordion-icon\"\n          ></cx-icon>\n        </button>\n        <button\n          *ngIf=\"actionButtonText\"\n          (click)=\"buttonAction.emit()\"\n          class=\"btn btn-link cx-action-link\"\n          type=\"button\"\n        >\n          {{ actionButtonText }}\n        </button>\n      </span>\n\n      <button\n        *ngIf=\"isVisibleCloseButton\"\n        (click)=\"closeMessage.emit()\"\n        class=\"close\"\n        type=\"button\"\n      >\n        <cx-icon [type]=\"iconTypes.CLOSE\"></cx-icon>\n      </button>\n    </div>\n\n    <div *ngIf=\"showBody || !accordionText\" class=\"cx-message-body\">\n      <ng-content></ng-content>\n    </div>\n  </div>\n</div>\n", components: [{ type: IconComponent, selector: "cx-icon,[cxIcon]", inputs: ["cxIcon", "type"] }], directives: [{ type: i3__namespace.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: MessageComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-message',
                        templateUrl: './message.component.html',
                    }]
            }], ctorParameters: function () { return []; }, propDecorators: { text: [{
                    type: i0.Input
                }], actionButtonText: [{
                    type: i0.Input
                }], accordionText: [{
                    type: i0.Input
                }], showBody: [{
                    type: i0.Input
                }], isVisibleCloseButton: [{
                    type: i0.Input
                }], type: [{
                    type: i0.Input
                }], closeMessage: [{
                    type: i0.Output
                }], buttonAction: [{
                    type: i0.Output
                }] } });

    var MessageComponentModule = /** @class */ (function () {
        function MessageComponentModule() {
        }
        return MessageComponentModule;
    }());
    MessageComponentModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: MessageComponentModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    MessageComponentModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: MessageComponentModule, declarations: [MessageComponent], imports: [i3.CommonModule, IconModule, i1.I18nModule], exports: [MessageComponent] });
    MessageComponentModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: MessageComponentModule, imports: [[i3.CommonModule, IconModule, i1.I18nModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: MessageComponentModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [i3.CommonModule, IconModule, i1.I18nModule],
                        declarations: [MessageComponent],
                        exports: [MessageComponent],
                    }]
            }] });

    var PromotionsModule = /** @class */ (function () {
        function PromotionsModule() {
        }
        return PromotionsModule;
    }());
    PromotionsModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PromotionsModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    PromotionsModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PromotionsModule, declarations: [PromotionsComponent], imports: [i3.CommonModule], exports: [PromotionsComponent] });
    PromotionsModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PromotionsModule, imports: [[i3.CommonModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PromotionsModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [i3.CommonModule],
                        declarations: [PromotionsComponent],
                        exports: [PromotionsComponent],
                    }]
            }] });

    var _a$1;
    var LABELS = (_a$1 = {},
        _a$1[i1.LANGUAGE_CONTEXT_ID] = 'Language',
        _a$1[i1.CURRENCY_CONTEXT_ID] = 'Currency',
        _a$1);
    var SiteContextComponentService = /** @class */ (function () {
        function SiteContextComponentService(componentData, contextServiceMap, injector) {
            this.componentData = componentData;
            this.contextServiceMap = contextServiceMap;
            this.injector = injector;
        }
        SiteContextComponentService.prototype.getItems = function (context) {
            var _this = this;
            return this.getService(context).pipe(operators.switchMap(function (service) { return service.getAll(); }), operators.switchMap(function (items) { return _this.getContext(context).pipe(operators.switchMap(function (ctx) {
                var e_1, _a;
                var itemsCopy = [];
                try {
                    for (var items_1 = __values(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {
                        var item = items_1_1.value;
                        itemsCopy.push(Object.assign(Object.assign({}, item), { label: _this.getOptionLabel(item, ctx) }));
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (items_1_1 && !items_1_1.done && (_a = items_1.return)) _a.call(items_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                return rxjs.of(itemsCopy);
            })); }));
        };
        SiteContextComponentService.prototype.getActiveItem = function (context) {
            return this.getService(context).pipe(operators.switchMap(function (service) { return service.getActive(); }));
        };
        SiteContextComponentService.prototype.getLabel = function (context) {
            return this.getContext(context).pipe(operators.map(function (ctx) {
                return LABELS[ctx];
            }));
        };
        SiteContextComponentService.prototype.setActive = function (value, context) {
            this.getService(context)
                .pipe(operators.take(1))
                .subscribe(function (service) {
                service.setActive(value);
            });
        };
        SiteContextComponentService.prototype.getService = function (context) {
            var _this = this;
            return this.getContext(context).pipe(operators.map(function (ctx) { return (ctx ? _this.getInjectedService(ctx) : undefined); }), operators.filter(function (s) { return !!s; }));
        };
        SiteContextComponentService.prototype.getContext = function (context) {
            if (context) {
                return rxjs.of(context);
            }
            else if (this.componentData) {
                return this.componentData.data$.pipe(operators.map(function (data) { return data === null || data === void 0 ? void 0 : data.context; }), operators.map(function (ctx) {
                    switch (ctx) {
                        case 'LANGUAGE':
                            return i1.LANGUAGE_CONTEXT_ID;
                        case 'CURRENCY':
                            return i1.CURRENCY_CONTEXT_ID;
                        default:
                            return ctx;
                    }
                }));
            }
        };
        SiteContextComponentService.prototype.getInjectedService = function (context) {
            return this.injector.get(this.contextServiceMap[context], null);
        };
        SiteContextComponentService.prototype.getOptionLabel = function (item, context) {
            switch (context) {
                case i1.LANGUAGE_CONTEXT_ID:
                    return item.nativeName;
                case i1.CURRENCY_CONTEXT_ID:
                    return item.symbol + ' ' + item.isocode;
                default:
                    return item.isocode;
            }
        };
        return SiteContextComponentService;
    }());
    SiteContextComponentService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SiteContextComponentService, deps: [{ token: CmsComponentData, optional: true }, { token: i1__namespace.ContextServiceMap }, { token: i0__namespace.Injector }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    SiteContextComponentService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SiteContextComponentService });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SiteContextComponentService, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () {
            return [{ type: CmsComponentData, decorators: [{
                            type: i0.Optional
                        }] }, { type: i1__namespace.ContextServiceMap }, { type: i0__namespace.Injector }];
        } });

    var SiteContextSelectorComponent = /** @class */ (function () {
        function SiteContextSelectorComponent(componentService) {
            this.componentService = componentService;
            this.iconTypes = exports.ICON_TYPE;
        }
        Object.defineProperty(SiteContextSelectorComponent.prototype, "items$", {
            get: function () {
                return this.componentService.getItems(this.context);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(SiteContextSelectorComponent.prototype, "activeItem$", {
            get: function () {
                return this.componentService.getActiveItem(this.context);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(SiteContextSelectorComponent.prototype, "active", {
            set: function (value) {
                this.componentService.setActive(value, this.context);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(SiteContextSelectorComponent.prototype, "label$", {
            get: function () {
                return this.componentService.getLabel(this.context);
            },
            enumerable: false,
            configurable: true
        });
        return SiteContextSelectorComponent;
    }());
    SiteContextSelectorComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SiteContextSelectorComponent, deps: [{ token: SiteContextComponentService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    SiteContextSelectorComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: SiteContextSelectorComponent, selector: "cx-site-context-selector", inputs: { context: "context" }, ngImport: i0__namespace, template: "<label *ngIf=\"(items$ | async)?.length > 1 && (items$ | async) as items\">\n  <span>{{ label$ | async }}</span>\n  <select (change)=\"active = $event.target.value\">\n    <option\n      *ngFor=\"let item of items\"\n      value=\"{{ item.isocode }}\"\n      [selected]=\"(activeItem$ | async) === item.isocode\"\n    >\n      {{ item.label }}\n    </option></select\n  ><cx-icon [type]=\"iconTypes.CARET_DOWN\" class=\"small\"></cx-icon>\n</label>\n", components: [{ type: IconComponent, selector: "cx-icon,[cxIcon]", inputs: ["cxIcon", "type"] }], directives: [{ type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3__namespace.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], pipes: { "async": i3__namespace.AsyncPipe }, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SiteContextSelectorComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-site-context-selector',
                        templateUrl: './site-context-selector.component.html',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], ctorParameters: function () { return [{ type: SiteContextComponentService }]; }, propDecorators: { context: [{
                    type: i0.Input
                }] } });

    var LanguageCurrencyComponent = /** @class */ (function () {
        function LanguageCurrencyComponent() {
        }
        return LanguageCurrencyComponent;
    }());
    LanguageCurrencyComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: LanguageCurrencyComponent, deps: [], target: i0__namespace.ɵɵFactoryTarget.Component });
    LanguageCurrencyComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: LanguageCurrencyComponent, selector: "cx-language-currency-selector", ngImport: i0__namespace, template: "\n    <cx-site-context-selector context=\"language\"></cx-site-context-selector>\n    <cx-site-context-selector context=\"currency\"></cx-site-context-selector>\n  ", isInline: true, components: [{ type: SiteContextSelectorComponent, selector: "cx-site-context-selector", inputs: ["context"] }], changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: LanguageCurrencyComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-language-currency-selector',
                        template: "\n    <cx-site-context-selector context=\"language\"></cx-site-context-selector>\n    <cx-site-context-selector context=\"currency\"></cx-site-context-selector>\n  ",
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }] });

    var SiteContextSelectorModule = /** @class */ (function () {
        function SiteContextSelectorModule() {
        }
        return SiteContextSelectorModule;
    }());
    SiteContextSelectorModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SiteContextSelectorModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    SiteContextSelectorModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SiteContextSelectorModule, declarations: [SiteContextSelectorComponent, LanguageCurrencyComponent], imports: [i3.CommonModule, i1$1.RouterModule, i1.SiteContextModule, IconModule], exports: [SiteContextSelectorComponent, LanguageCurrencyComponent] });
    SiteContextSelectorModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SiteContextSelectorModule, providers: [
            i1.provideDefaultConfig({
                cmsComponents: {
                    CMSSiteContextComponent: {
                        component: SiteContextSelectorComponent,
                        providers: [
                            {
                                provide: SiteContextComponentService,
                                useClass: SiteContextComponentService,
                                deps: [CmsComponentData, i1.ContextServiceMap, i0.Injector],
                            },
                        ],
                    },
                    LanguageCurrencyComponent: {
                        component: LanguageCurrencyComponent,
                    },
                },
            }),
            SiteContextComponentService,
        ], imports: [[i3.CommonModule, i1$1.RouterModule, i1.SiteContextModule, IconModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SiteContextSelectorModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [i3.CommonModule, i1$1.RouterModule, i1.SiteContextModule, IconModule],
                        providers: [
                            i1.provideDefaultConfig({
                                cmsComponents: {
                                    CMSSiteContextComponent: {
                                        component: SiteContextSelectorComponent,
                                        providers: [
                                            {
                                                provide: SiteContextComponentService,
                                                useClass: SiteContextComponentService,
                                                deps: [CmsComponentData, i1.ContextServiceMap, i0.Injector],
                                            },
                                        ],
                                    },
                                    LanguageCurrencyComponent: {
                                        component: LanguageCurrencyComponent,
                                    },
                                },
                            }),
                            SiteContextComponentService,
                        ],
                        declarations: [SiteContextSelectorComponent, LanguageCurrencyComponent],
                        exports: [SiteContextSelectorComponent, LanguageCurrencyComponent],
                    }]
            }] });

    exports.SiteContextType = void 0;
    (function (SiteContextType) {
        SiteContextType["LANGUAGE"] = "LANGUAGE";
        SiteContextType["CURRENCY"] = "CURRENCY";
    })(exports.SiteContextType || (exports.SiteContextType = {}));

    /**
     * Star rating component can be used to view existing ratings as well
     * as create new ratings. The component can be used for any ratings.
     */
    var StarRatingComponent = /** @class */ (function () {
        function StarRatingComponent() {
            this.initialRate = 0;
            this.icon = exports.ICON_TYPE.STAR;
            /**
             * The rating component can be used in disabled mode,
             * so that the interaction is not provided.
             *
             * Defaults to true.
             */
            this.disabled = true;
            /**
             * The rating is used to color the rating stars. It can have a
             * precise number. The rating number is used for a CSS custom property
             * (AKA css variable) value. The actually coloring is done in CSS.
             */
            this.rating = this.initialRate;
            /**
             * Emits the given rating when the user clicks on a star.
             */
            // eslint-disable-next-line @angular-eslint/no-output-native
            this.change = new i0.EventEmitter();
        }
        StarRatingComponent.prototype.setRate = function (value) {
            if (this.disabled) {
                return;
            }
            this.rating = value;
        };
        StarRatingComponent.prototype.reset = function () {
            var _a;
            if (this.disabled) {
                return;
            }
            this.rating = (_a = this.initialRate) !== null && _a !== void 0 ? _a : 0;
        };
        StarRatingComponent.prototype.saveRate = function (rating) {
            if (this.disabled) {
                return;
            }
            this.initialRate = rating;
            this.setRate(rating);
            this.change.emit(rating);
        };
        return StarRatingComponent;
    }());
    StarRatingComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: StarRatingComponent, deps: [], target: i0__namespace.ɵɵFactoryTarget.Component });
    StarRatingComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: StarRatingComponent, selector: "cx-star-rating", inputs: { disabled: "disabled", rating: "rating" }, outputs: { change: "change" }, host: { listeners: { "mouseout": "reset()" }, properties: { "attr.disabled": "this.disabled", "style.--star-fill": "this.rating" } }, ngImport: i0__namespace, template: "<cx-icon\n  *ngFor=\"let i of [1, 2, 3, 4, 5]\"\n  [type]=\"icon\"\n  class=\"star\"\n  (mouseover)=\"setRate(i)\"\n  (click)=\"saveRate(i)\"\n  (keydown.space)=\"saveRate(i)\"\n  [attr.tabindex]=\"disabled ? null : 0\"\n></cx-icon>\n", components: [{ type: IconComponent, selector: "cx-icon,[cxIcon]", inputs: ["cxIcon", "type"] }], directives: [{ type: i3__namespace.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: StarRatingComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-star-rating',
                        templateUrl: './star-rating.component.html',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], propDecorators: { disabled: [{
                    type: i0.Input
                }, {
                    type: i0.HostBinding,
                    args: ['attr.disabled']
                }], rating: [{
                    type: i0.Input
                }, {
                    type: i0.HostBinding,
                    args: ['style.--star-fill']
                }], change: [{
                    type: i0.Output
                }], reset: [{
                    type: i0.HostListener,
                    args: ['mouseout']
                }] } });

    var StarRatingModule = /** @class */ (function () {
        function StarRatingModule() {
        }
        return StarRatingModule;
    }());
    StarRatingModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: StarRatingModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    StarRatingModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: StarRatingModule, declarations: [StarRatingComponent], imports: [i3.CommonModule, IconModule], exports: [StarRatingComponent] });
    StarRatingModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: StarRatingModule, imports: [[i3.CommonModule, IconModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: StarRatingModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [i3.CommonModule, IconModule],
                        declarations: [StarRatingComponent],
                        exports: [StarRatingComponent],
                    }]
            }] });

    var TableDataCellComponent = /** @class */ (function () {
        function TableDataCellComponent(outlet) {
            this.outlet = outlet;
        }
        Object.defineProperty(TableDataCellComponent.prototype, "value", {
            get: function () {
                return this.model[this.field];
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TableDataCellComponent.prototype, "model", {
            get: function () {
                var _a;
                return (_a = this.outlet) === null || _a === void 0 ? void 0 : _a.context;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TableDataCellComponent.prototype, "field", {
            get: function () {
                var _a, _b;
                return (_b = (_a = this.outlet) === null || _a === void 0 ? void 0 : _a.context) === null || _b === void 0 ? void 0 : _b._field;
            },
            enumerable: false,
            configurable: true
        });
        return TableDataCellComponent;
    }());
    TableDataCellComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: TableDataCellComponent, deps: [{ token: OutletContextData }], target: i0__namespace.ɵɵFactoryTarget.Component });
    TableDataCellComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: TableDataCellComponent, selector: "cx-table-data-cell", host: { properties: { "attr.title": "this.value" } }, ngImport: i0__namespace, template: "{{ value }}", isInline: true, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: TableDataCellComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-table-data-cell',
                        template: "{{ value }}",
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], ctorParameters: function () { return [{ type: OutletContextData }]; }, propDecorators: { value: [{
                    type: i0.HostBinding,
                    args: ['attr.title']
                }] } });

    var TableHeaderCellComponent = /** @class */ (function () {
        function TableHeaderCellComponent(outlet) {
            this.outlet = outlet;
        }
        Object.defineProperty(TableHeaderCellComponent.prototype, "header", {
            /**
             * Returns the static label for the given field, if available.
             */
            get: function () {
                var _a;
                if (typeof ((_a = this.fieldOptions) === null || _a === void 0 ? void 0 : _a.label) === 'string') {
                    return this.fieldOptions.label;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TableHeaderCellComponent.prototype, "localizedHeader", {
            /**
             * Returns the localized label for the given field.
             *
             * The localized label is either driven by the configured `label.i18nKey`
             * or concatenated by the table `type` and field `key`:
             *
             * `[tableType].[fieldKey]`
             *
             * The localized header can be translated with the `cxTranslate` pipe or `TranslationService`.
             */
            get: function () {
                var _a, _b;
                return (((_b = (_a = this.fieldOptions) === null || _a === void 0 ? void 0 : _a.label) === null || _b === void 0 ? void 0 : _b.i18nKey) ||
                    this.i18nRoot + "." + this.field);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TableHeaderCellComponent.prototype, "fieldOptions", {
            get: function () {
                var _a, _b, _c;
                return (_c = (_b = (_a = this.outlet) === null || _a === void 0 ? void 0 : _a.context._options) === null || _b === void 0 ? void 0 : _b.cells) === null || _c === void 0 ? void 0 : _c[this.field];
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TableHeaderCellComponent.prototype, "field", {
            get: function () {
                var _a, _b;
                return (_b = (_a = this.outlet) === null || _a === void 0 ? void 0 : _a.context) === null || _b === void 0 ? void 0 : _b._field;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TableHeaderCellComponent.prototype, "type", {
            get: function () {
                var _a, _b;
                return (_b = (_a = this.outlet) === null || _a === void 0 ? void 0 : _a.context) === null || _b === void 0 ? void 0 : _b._type;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TableHeaderCellComponent.prototype, "i18nRoot", {
            get: function () {
                var _a, _b;
                return (_b = (_a = this.outlet) === null || _a === void 0 ? void 0 : _a.context) === null || _b === void 0 ? void 0 : _b._i18nRoot;
            },
            enumerable: false,
            configurable: true
        });
        return TableHeaderCellComponent;
    }());
    TableHeaderCellComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: TableHeaderCellComponent, deps: [{ token: OutletContextData }], target: i0__namespace.ɵɵFactoryTarget.Component });
    TableHeaderCellComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: TableHeaderCellComponent, selector: "cx-table-header-cell", ngImport: i0__namespace, template: "{{ header || (localizedHeader | cxTranslate) }}", isInline: true, pipes: { "cxTranslate": i1__namespace.TranslatePipe }, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: TableHeaderCellComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-table-header-cell',
                        template: "{{ header || (localizedHeader | cxTranslate) }}",
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], ctorParameters: function () { return [{ type: OutletContextData }]; } });

    var defaultTableConfig = {
        tableOptions: {
            headerComponent: TableHeaderCellComponent,
            dataComponent: TableDataCellComponent,
        },
    };

    /**
     * The `TableConfig` provides a table configurations for specific table types. You can define
     * an all-screen table structure as well as a breakpoint specific table structure. The various
     * table structures are merged from small to large screen configurations, depending on the users
     * screen size.
     *
     * The `table.type` is used as a key to distinguish the various table configurations in the application.
     */
    var TableConfig = /** @class */ (function () {
        function TableConfig() {
        }
        return TableConfig;
    }());
    TableConfig.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: TableConfig, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    TableConfig.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: TableConfig, providedIn: 'root', useExisting: i1.Config });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: TableConfig, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                        useExisting: i1.Config,
                    }]
            }] });

    var TableDataCellModule = /** @class */ (function () {
        function TableDataCellModule() {
        }
        return TableDataCellModule;
    }());
    TableDataCellModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: TableDataCellModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    TableDataCellModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: TableDataCellModule, declarations: [TableDataCellComponent], imports: [i3.CommonModule] });
    TableDataCellModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: TableDataCellModule, imports: [[i3.CommonModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: TableDataCellModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [i3.CommonModule],
                        declarations: [TableDataCellComponent],
                    }]
            }] });

    var TableHeaderCellModule = /** @class */ (function () {
        function TableHeaderCellModule() {
        }
        return TableHeaderCellModule;
    }());
    TableHeaderCellModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: TableHeaderCellModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    TableHeaderCellModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: TableHeaderCellModule, declarations: [TableHeaderCellComponent], imports: [i3.CommonModule, i1.I18nModule] });
    TableHeaderCellModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: TableHeaderCellModule, imports: [[i3.CommonModule, i1.I18nModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: TableHeaderCellModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [i3.CommonModule, i1.I18nModule],
                        declarations: [TableHeaderCellComponent],
                    }]
            }] });

    /**
     * The table renderer service adds a component for each table cells (th and td)
     * based on a fine grained configuration. Each table type can configure both global
     * components for headers and cells as well as individual components for field
     * specific cells.
     *
     * The components are added to the outlet slots for the corresponding cells. The table
     * structure and data is added to the outlet context.
     */
    var TableRendererService = /** @class */ (function () {
        function TableRendererService(outletService, componentFactoryResolver, config) {
            this.outletService = outletService;
            this.componentFactoryResolver = componentFactoryResolver;
            this.config = config;
            // keep a list of outletRefs to avoid recreation
            this.outletRefs = new Map();
        }
        /**
         * Adds the configured table component for the header and data.
         */
        TableRendererService.prototype.add = function (structure) {
            var _this = this;
            var _a;
            (_a = structure === null || structure === void 0 ? void 0 : structure.cells) === null || _a === void 0 ? void 0 : _a.forEach(function (field) {
                var thRenderer = _this.getHeaderRenderer(structure, field);
                if (thRenderer) {
                    var ref = _this.getHeaderOutletRef(structure.type, field);
                    _this.render(ref, thRenderer);
                }
                var tdRenderer = _this.getDataRenderer(structure, field);
                if (tdRenderer) {
                    var ref = _this.getDataOutletRef(structure.type, field);
                    _this.render(ref, tdRenderer);
                }
            });
        };
        TableRendererService.prototype.render = function (outletRef, renderer) {
            if (this.outletRefs.has(outletRef)) {
                return;
            }
            this.outletRefs.set(outletRef, true);
            var template = this.componentFactoryResolver.resolveComponentFactory(renderer);
            this.outletService.add(outletRef, template);
        };
        /**
         * Returns the header render component for the given field.
         */
        TableRendererService.prototype.getHeaderRenderer = function (structure, field) {
            var _a, _b, _c, _d, _e;
            return (((_c = (_b = (_a = structure.options) === null || _a === void 0 ? void 0 : _a.cells) === null || _b === void 0 ? void 0 : _b[field]) === null || _c === void 0 ? void 0 : _c.headerComponent) ||
                ((_d = structure.options) === null || _d === void 0 ? void 0 : _d.headerComponent) ||
                ((_e = this.config.tableOptions) === null || _e === void 0 ? void 0 : _e.headerComponent));
        };
        /**
         * Returns the data render component for the given field.
         */
        TableRendererService.prototype.getDataRenderer = function (structure, field) {
            var _a, _b, _c, _d, _e;
            return (((_c = (_b = (_a = structure.options) === null || _a === void 0 ? void 0 : _a.cells) === null || _b === void 0 ? void 0 : _b[field]) === null || _c === void 0 ? void 0 : _c.dataComponent) ||
                ((_d = structure.options) === null || _d === void 0 ? void 0 : _d.dataComponent) ||
                ((_e = this.config.tableOptions) === null || _e === void 0 ? void 0 : _e.dataComponent));
        };
        /**
         * Returns the header (th) outlet reference for the given field.
         *
         * The outlet reference is generated as:
         * `table.[tableType].header.[field]`
         */
        TableRendererService.prototype.getHeaderOutletRef = function (type, field) {
            return "table." + type + ".header." + field;
        };
        /**
         * Returns the header (th) outlet context for the given field.
         */
        TableRendererService.prototype.getHeaderOutletContext = function (type, options, i18nRoot, field) {
            return {
                _type: type,
                _options: options,
                _field: field,
                _i18nRoot: i18nRoot,
            };
        };
        /**
         * Returns the data (td) outlet reference for the given field.
         *
         * The field is generated as:
         * `table.[tableType].data.[tableField]`
         */
        TableRendererService.prototype.getDataOutletRef = function (type, field) {
            return "table." + type + ".data." + field;
        };
        /**
         * Returns the data (td) outlet context for the given field.
         */
        TableRendererService.prototype.getDataOutletContext = function (type, options, i18nRoot, field, data) {
            return Object.assign(Object.assign({}, data), { _type: type, _options: options, _field: field, _i18nRoot: i18nRoot });
        };
        return TableRendererService;
    }());
    TableRendererService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: TableRendererService, deps: [{ token: OutletService }, { token: i0__namespace.ComponentFactoryResolver }, { token: TableConfig }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    TableRendererService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: TableRendererService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: TableRendererService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: OutletService }, { type: i0__namespace.ComponentFactoryResolver }, { type: TableConfig }]; } });

    /**
     * Layout orientation for the table configuration.
     */
    exports.TableLayout = void 0;
    (function (TableLayout) {
        /**
         * Renders the table vertically, with a heading on top of the table.
         *
         * Vertical layout is most common and the default layout.
         */
        TableLayout[TableLayout["VERTICAL"] = 1] = "VERTICAL";
        /**
         * Stacks items in a tables by generating a `tbody` for each item.
         */
        TableLayout[TableLayout["VERTICAL_STACKED"] = 2] = "VERTICAL_STACKED";
        /**
         * Horizontal oriented table layout renders the table headers in the first column of the table.
         */
        TableLayout[TableLayout["HORIZONTAL"] = 3] = "HORIZONTAL";
    })(exports.TableLayout || (exports.TableLayout = {}));

    /**
     * The table component provides a generic table DOM structure, with 3 layout types:
     * horizontal, vertical and _stacked vertical_ layout. The layout is driven by the
     * table structure.
     *
     * The implementation is fairly "dumb" and only renders string based content for TH
     * and TD elements. The actual cell rendering is delegated to a (configurable) cell
     * component. Additionally, each cell is registered as an outlet, so that customizations
     * can be done by both outlet templates and components.
     *
     * The outlet references are concatenated from the table `type` and header `key`. The
     * following snippet shows an outlet generated for a table header, for the table type
     * "cost-center" with a header key "name":
     *
     * ```
     * <th>
     *   <template cxOutlet="table.cost-center.header.name">
     *   </template>
     * </th>
     * ```
     *
     * Similarly, the data cells (`<td>`) are generated with the outlet template reference
     * `table.cost-center.data.name`.
     */
    var TableComponent = /** @class */ (function () {
        function TableComponent(rendererService) {
            this.rendererService = rendererService;
            this.launch = new i0.EventEmitter();
        }
        Object.defineProperty(TableComponent.prototype, "structure", {
            get: function () {
                return this._structure;
            },
            set: function (structure) {
                this._structure = structure;
                this.init();
            },
            enumerable: false,
            configurable: true
        });
        TableComponent.prototype.init = function () {
            this.verticalLayout = !this.layout || this.layout === exports.TableLayout.VERTICAL;
            this.verticalStackedLayout = this.layout === exports.TableLayout.VERTICAL_STACKED;
            this.horizontalLayout = this.layout === exports.TableLayout.HORIZONTAL;
            this.rendererService.add(this.structure);
            this.addTableDebugInfo();
        };
        TableComponent.prototype.launchItem = function (item) {
            this.launch.emit(item);
        };
        /**
         * Indicates whether the given item is the current item.
         *
         * The current item is driven by the `currentItem`, that holds a
         * property and value to compare.
         */
        TableComponent.prototype.isCurrentItem = function (item) {
            var _a, _b;
            if (!this.currentItem || !this.currentItem.value) {
                return false;
            }
            return ((_a = this.currentItem) === null || _a === void 0 ? void 0 : _a.value) === (item === null || item === void 0 ? void 0 : item[(_b = this.currentItem) === null || _b === void 0 ? void 0 : _b.property]);
        };
        /**
         * Returns the header (th) outlet reference for the given field.
         */
        TableComponent.prototype.getHeaderOutletRef = function (field) {
            return this.rendererService.getHeaderOutletRef(this.type, field);
        };
        /**
         * Returns the header (th) outlet context for the given field.
         */
        TableComponent.prototype.getHeaderOutletContext = function (field) {
            return this.rendererService.getHeaderOutletContext(this.type, this.options, this.i18nRoot, field);
        };
        /**
         * Returns the data (td) outlet reference for the given field.
         */
        TableComponent.prototype.getDataOutletRef = function (field) {
            return this.rendererService.getDataOutletRef(this.type, field);
        };
        /**
         * Returns the data (td) outlet context for the given field.
         */
        TableComponent.prototype.getDataOutletContext = function (field, data) {
            return this.rendererService.getDataOutletContext(this.type, this.options, this.i18nRoot, field, data);
        };
        TableComponent.prototype.trackData = function (_i, item) {
            return JSON.stringify(item);
        };
        /**
         * Generates the table type into the UI in devMode, so that developers
         * can easily get the notion of the table type.
         */
        TableComponent.prototype.addTableDebugInfo = function () {
            if (i0.isDevMode() && this.type) {
                this.tableType = this.type;
            }
        };
        Object.defineProperty(TableComponent.prototype, "layout", {
            /**
             * Helper method to return the deeply nested orientation configuration.
             */
            get: function () {
                var _a, _b;
                return (_b = (_a = this.structure) === null || _a === void 0 ? void 0 : _a.options) === null || _b === void 0 ? void 0 : _b.layout;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TableComponent.prototype, "type", {
            /**
             * Helper method to return the deeply nested type.
             */
            get: function () {
                var _a;
                return (_a = this.structure) === null || _a === void 0 ? void 0 : _a.type;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TableComponent.prototype, "options", {
            get: function () {
                var _a;
                return (_a = this.structure) === null || _a === void 0 ? void 0 : _a.options;
            },
            enumerable: false,
            configurable: true
        });
        return TableComponent;
    }());
    TableComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: TableComponent, deps: [{ token: TableRendererService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    TableComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: TableComponent, selector: "cx-table", inputs: { structure: "structure", data: "data", i18nRoot: "i18nRoot", currentItem: "currentItem" }, outputs: { launch: "launch" }, host: { properties: { "attr.__cx-table-type": "this.tableType", "class.horizontal": "this.horizontalLayout", "class.vertical": "this.verticalLayout", "class.vertical-stacked": "this.verticalStackedLayout" } }, ngImport: i0__namespace, template: "<table *ngIf=\"structure\">\n  <ng-container *ngIf=\"verticalStackedLayout\">\n    <tbody\n      *ngFor=\"let item of data; trackBy: trackData\"\n      (click)=\"launchItem(item)\"\n      [class.is-current]=\"isCurrentItem(item)\"\n    >\n      <tr *ngFor=\"let cell of structure.cells\" [class]=\"cell\">\n        <th>\n          <ng-template\n            [cxOutlet]=\"getHeaderOutletRef(cell)\"\n            [cxOutletContext]=\"getHeaderOutletContext(cell)\"\n          >\n            {{ cell }}\n          </ng-template>\n        </th>\n        <td>\n          <ng-template\n            [cxOutlet]=\"getDataOutletRef(cell)\"\n            [cxOutletContext]=\"getDataOutletContext(cell, item)\"\n          >\n            {{ item[cell] }}\n          </ng-template>\n        </td>\n      </tr>\n    </tbody>\n  </ng-container>\n\n  <!-- vertical tables render the item  -->\n  <ng-container *ngIf=\"verticalLayout\">\n    <thead>\n      <tr>\n        <th scope=\"col\" *ngFor=\"let cell of structure.cells\" [class]=\"cell\">\n          <ng-template\n            [cxOutlet]=\"getHeaderOutletRef(cell)\"\n            [cxOutletContext]=\"getHeaderOutletContext(cell)\"\n          >\n            {{ cell }}\n          </ng-template>\n        </th>\n      </tr>\n    </thead>\n\n    <tr\n      *ngFor=\"let item of data; trackBy: trackData\"\n      [class.is-current]=\"isCurrentItem(item)\"\n      (click)=\"launchItem(item)\"\n    >\n      <td *ngFor=\"let cell of structure.cells; let i = index\" [class]=\"cell\">\n        <ng-template\n          [cxOutlet]=\"getDataOutletRef(cell)\"\n          [cxOutletContext]=\"getDataOutletContext(cell, item)\"\n        >\n          {{ item[cell] }}\n        </ng-template>\n      </td>\n    </tr>\n  </ng-container>\n\n  <ng-container *ngIf=\"horizontalLayout\">\n    <tr *ngFor=\"let cell of structure.cells\" [class]=\"cell\">\n      <th scope=\"col\">\n        <ng-template\n          [cxOutlet]=\"getHeaderOutletRef(cell)\"\n          [cxOutletContext]=\"getHeaderOutletContext(cell)\"\n        >\n          {{ cell }}\n        </ng-template>\n      </th>\n      <td\n        *ngFor=\"let item of data; trackBy: trackData\"\n        [class.is-current]=\"isCurrentItem(item)\"\n        (click)=\"launchItem(item)\"\n      >\n        <ng-template\n          [cxOutlet]=\"getDataOutletRef(cell)\"\n          [cxOutletContext]=\"getDataOutletContext(cell, item)\"\n        >\n          {{ item[cell] }}\n        </ng-template>\n      </td>\n    </tr>\n  </ng-container>\n</table>\n", directives: [{ type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3__namespace.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: OutletDirective, selector: "[cxOutlet]", inputs: ["cxOutlet", "cxOutletContext", "cxOutletDefer"], outputs: ["loaded"] }], changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: TableComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-table',
                        templateUrl: './table.component.html',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], ctorParameters: function () { return [{ type: TableRendererService }]; }, propDecorators: { tableType: [{
                    type: i0.HostBinding,
                    args: ['attr.__cx-table-type']
                }], horizontalLayout: [{
                    type: i0.HostBinding,
                    args: ['class.horizontal']
                }], verticalLayout: [{
                    type: i0.HostBinding,
                    args: ['class.vertical']
                }], verticalStackedLayout: [{
                    type: i0.HostBinding,
                    args: ['class.vertical-stacked']
                }], structure: [{
                    type: i0.Input
                }], data: [{
                    type: i0.Input
                }], i18nRoot: [{
                    type: i0.Input
                }], currentItem: [{
                    type: i0.Input
                }], launch: [{
                    type: i0.Output
                }] } });

    /**
     * The TableModule provides a table component that is driven by (responsible) configuration.
     */
    var TableModule = /** @class */ (function () {
        function TableModule() {
        }
        return TableModule;
    }());
    TableModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: TableModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    TableModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: TableModule, declarations: [TableComponent], imports: [i3.CommonModule,
            OutletModule,
            TableHeaderCellModule,
            TableDataCellModule], exports: [TableComponent] });
    TableModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: TableModule, providers: [i1.provideConfig(defaultTableConfig)], imports: [[
                i3.CommonModule,
                OutletModule,
                TableHeaderCellModule,
                TableDataCellModule,
            ]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: TableModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [
                            i3.CommonModule,
                            OutletModule,
                            TableHeaderCellModule,
                            TableDataCellModule,
                        ],
                        declarations: [TableComponent],
                        exports: [TableComponent],
                        providers: [i1.provideConfig(defaultTableConfig)],
                    }]
            }] });

    /**
     * Responsive table service.
     *
     * The `TableService` is used to build a `TableStructure` by configuration. The configuration
     * allows for breakpoint specific configuration, so that the table can differentiate for
     * various screen sizes.
     *
     * While there are some global options, the configuration is mainly driven by the table _type_.
     *
     * If there is no table configuration for the given type found, a table header structure
     * is generated based on the actual data (if available) or randomly by generating 5 random headers.
     */
    var TableService = /** @class */ (function () {
        function TableService(breakpointService, config) {
            this.breakpointService = breakpointService;
            this.config = config;
        }
        /**
         * Builds the table structure.
         *
         * @param tableType The table type is used  to find the specific table configuration.
         * @param defaultStructure (optional) Default table structure that contains fallback options. More specific options are merged with the default structure.
         * @param data$ (optional) The actual data can be passed in to generate the table structure based on actual data.
         */
        TableService.prototype.buildStructure = function (tableType, defaultStructure) {
            if (this.hasTableConfig(tableType)) {
                return this.buildStructureFromConfig(tableType, defaultStructure);
            }
            else {
                return this.buildRandomStructure(tableType);
            }
        };
        /**
         * Returns the table structure by configuration. The configuration can be
         * breakpoint-driven, which means that an alternative header structure can
         * be created per screen size.
         *
         * The breakpoint is resolved by teh `BreakpointService`.
         */
        TableService.prototype.buildStructureFromConfig = function (type, defaultStructure) {
            var _this = this;
            return this.breakpointService.breakpoint$.pipe(operators.map(function (breakpoint) { return (Object.assign(Object.assign({}, _this.getTableConfig(type, breakpoint, defaultStructure)), { type: type })); }));
        };
        /**
         * Finds all applicable table configuration for the given type and breakpoint.
         * The default table configuration is merged with all relevant breakpoint
         * configurations.
         *
         * This allows to have some default configurations that apply to all screens, and
         * add configuration options for some screens.
         */
        TableService.prototype.getTableConfig = function (type, breakpoint, defaultStructure) {
            var _this = this;
            var _a, _b;
            if (!((_a = this.config.table) === null || _a === void 0 ? void 0 : _a[type])) {
                return null;
            }
            var relevant = this.findRelevantBreakpoints(breakpoint);
            var closestBreakpoint = __spreadArray([], __read(relevant)).reverse()
                .find(function (br) { var _a; return !!((_a = _this.config.table[type][br]) === null || _a === void 0 ? void 0 : _a.cells); });
            var cells = ((_b = this.config.table[type][closestBreakpoint]) === null || _b === void 0 ? void 0 : _b.cells) ||
                this.config.table[type].cells ||
                (defaultStructure === null || defaultStructure === void 0 ? void 0 : defaultStructure.cells);
            // add all default table configurations
            var options = Object.assign(Object.assign({}, defaultStructure === null || defaultStructure === void 0 ? void 0 : defaultStructure.options), this.config.table[type].options);
            // We merge all table options for smaller breakpoints into the global
            // options, so we inherit options.
            relevant.forEach(function (br) {
                var _a, _b, _c;
                options = Object.assign(Object.assign(Object.assign({}, options), (_a = defaultStructure === null || defaultStructure === void 0 ? void 0 : defaultStructure[br]) === null || _a === void 0 ? void 0 : _a.options), (_c = (_b = _this.config.table[type]) === null || _b === void 0 ? void 0 : _b[br]) === null || _c === void 0 ? void 0 : _c.options);
            });
            return { cells: cells, options: options };
        };
        /**
         * Generates the table structure by the help of the first data row.
         */
        TableService.prototype.buildStructureFromData = function (type, data$) {
            this.logWarning("No table configuration found to render table with type \"" + type + "\". The table header for \"" + type + "\" is generated by the help of the first data item");
            return data$.pipe(operators.map(function (data) {
                var cells = Object.keys(data === null || data === void 0 ? void 0 : data[0]).map(function (key) { return key; });
                return { type: type, cells: cells };
            }));
        };
        /**
         * As a last resort, the table structure is randomly created. The random structure
         * contains 5 headers, so that some of the unknown data is visualized.
         */
        TableService.prototype.buildRandomStructure = function (type) {
            this.logWarning("No data available for \"" + type + "\", a random structure is generated (with hidden table headers).");
            return rxjs.of({
                type: type,
                cells: ['unknown', 'unknown', 'unknown', 'unknown', 'unknown'],
            });
        };
        /**
         * Finds all the breakpoints can contribute to the table configuration, from small
         * to current.
         *
         * For example, if the current breakpoint is `MD`, this returns `[XS, SM, MD]`.
         */
        TableService.prototype.findRelevantBreakpoints = function (breakpoint) {
            var current = this.breakpointService.breakpoints.indexOf(breakpoint);
            return this.breakpointService.breakpoints.slice(0, current + 1);
        };
        /**
         * Indicates if the there is a configuration for the table available.
         */
        TableService.prototype.hasTableConfig = function (tableType) {
            var _a;
            return !!((_a = this.config.table) === null || _a === void 0 ? void 0 : _a[tableType]);
        };
        /**
         * Logs a message in the console to increase developer experience.
         *
         * The message is only logged in dev mode.
         */
        TableService.prototype.logWarning = function (message) {
            if (i0.isDevMode()) {
                console.warn(message);
            }
        };
        return TableService;
    }());
    TableService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: TableService, deps: [{ token: BreakpointService }, { token: TableConfig }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    TableService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: TableService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: TableService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: BreakpointService }, { type: TableConfig }]; } });

    var ViewConfig = /** @class */ (function () {
        function ViewConfig() {
        }
        return ViewConfig;
    }());
    ViewConfig.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ViewConfig, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ViewConfig.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ViewConfig, providedIn: 'root', useExisting: i1.Config });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ViewConfig, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                        useExisting: i1.Config,
                    }]
            }] });

    /*
     * Supplements the anchor links that contain only the hash fragment in the `href` attribute,
     * (e.g. `<a href="#someId">`), by prepending the current location (path and query params),
     * so it becomes a link to a full url
     * e.g. `<a href="https://domain.com/current/path?and=query-params#someId">`.
     *
     * This helps to avoid the undesirable navigation to the homepage URL (`/#someId`)
     * when clicking the original link.
     *
     * It's useful for example for cms-provided content passed to the [innerHTML] directive.
     */
    var SupplementHashAnchorsPipe = /** @class */ (function () {
        function SupplementHashAnchorsPipe(renderer, winRef) {
            this.renderer = renderer;
            this.winRef = winRef;
        }
        SupplementHashAnchorsPipe.prototype.getPath = function (anchorId) {
            var currentUrlWithoutFragment = this.winRef.location.href.replace(/#.*$/, '');
            return "" + currentUrlWithoutFragment + anchorId;
        };
        SupplementHashAnchorsPipe.prototype.transform = function (html) {
            var _this = this;
            var template = this.renderer.createElement('template');
            template.innerHTML = html.trim();
            var linkNodes = template.content.querySelectorAll('a');
            Array.from(linkNodes).forEach(function (link) {
                var href = link.getAttribute('href');
                if ((href === null || href === void 0 ? void 0 : href.indexOf('#')) === 0) {
                    _this.renderer.setProperty(link, 'href', _this.getPath(href));
                }
            });
            return template.innerHTML;
        };
        return SupplementHashAnchorsPipe;
    }());
    SupplementHashAnchorsPipe.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SupplementHashAnchorsPipe, deps: [{ token: i0__namespace.Renderer2 }, { token: i1__namespace.WindowRef }], target: i0__namespace.ɵɵFactoryTarget.Pipe });
    SupplementHashAnchorsPipe.ɵpipe = i0__namespace.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SupplementHashAnchorsPipe, name: "cxSupplementHashAnchors" });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SupplementHashAnchorsPipe, decorators: [{
                type: i0.Pipe,
                args: [{ name: 'cxSupplementHashAnchors' }]
            }], ctorParameters: function () { return [{ type: i0__namespace.Renderer2 }, { type: i1__namespace.WindowRef }]; } });

    var SupplementHashAnchorsModule = /** @class */ (function () {
        function SupplementHashAnchorsModule() {
        }
        return SupplementHashAnchorsModule;
    }());
    SupplementHashAnchorsModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SupplementHashAnchorsModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    SupplementHashAnchorsModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SupplementHashAnchorsModule, declarations: [SupplementHashAnchorsPipe], exports: [SupplementHashAnchorsPipe] });
    SupplementHashAnchorsModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SupplementHashAnchorsModule });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SupplementHashAnchorsModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        declarations: [SupplementHashAnchorsPipe],
                        exports: [SupplementHashAnchorsPipe],
                    }]
            }] });

    var FileDownloadService = /** @class */ (function () {
        function FileDownloadService() {
        }
        /**
         * Triggers the browser downloading of the file from the given URL.
         *
         * @param {string} url URL to file.
         * @param {string} [fileName] The optional parameter for defining filename
         * (including the extension) when saving the file.
         */
        FileDownloadService.prototype.download = function (url, fileName) {
            var link = document.createElement('a');
            link.setAttribute('href', url);
            link.setAttribute('download', "" + fileName);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        };
        return FileDownloadService;
    }());
    FileDownloadService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: FileDownloadService, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    FileDownloadService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: FileDownloadService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: FileDownloadService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }] });

    var ExportCsvFileService = /** @class */ (function () {
        function ExportCsvFileService(fileDownloadService) {
            this.fileDownloadService = fileDownloadService;
        }
        /**
         * Converts array of objects into CSV data structure.
         *
         * @param objectsArray Array of objects which should be converted to CSV.
         * @param separator Separator for CSV data.
         * @returns Processed string ready to be saved into file.
         */
        ExportCsvFileService.prototype.convert = function (objectsArray, separator) {
            return objectsArray.reduce(function (csvString, row) {
                var line = row.reduce(function (currentLine, column) {
                    currentLine += currentLine !== '' ? separator : '';
                    var cell = column.includes(separator) ? "\"" + column + "\"" : column;
                    return "" + currentLine + cell;
                }, '');
                return "" + csvString + line + "\r\n";
            }, '');
        };
        /**
         * Creates and download CSV file.
         *
         * @param objectsArray Array of objects which should be converted to CSV.
         * @param separator Separator for CSV data.
         * @param fileOptions Exported file options.
         */
        ExportCsvFileService.prototype.download = function (objectsArray, separator, fileOptions) {
            var fileName = fileOptions.fileName, type = fileOptions.type, extension = fileOptions.extension;
            var fileContent = this.convert(objectsArray, separator);
            var blob = new Blob([fileContent], { type: type });
            var url = URL.createObjectURL(blob);
            this.fileDownloadService.download(url, fileName + "." + extension);
        };
        return ExportCsvFileService;
    }());
    ExportCsvFileService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ExportCsvFileService, deps: [{ token: FileDownloadService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ExportCsvFileService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ExportCsvFileService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ExportCsvFileService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: FileDownloadService }]; } });

    var FileReaderService = /** @class */ (function () {
        function FileReaderService() {
        }
        /**
         * Load text file
         *
         * @param file text file to extract the data
         * @returns Observable from file reader
         */
        FileReaderService.prototype.loadTextFile = function (file) {
            return new rxjs.Observable(function (observer) {
                var fileReader = new FileReader();
                fileReader.readAsText(file);
                fileReader.onload = function () {
                    observer.next(fileReader.result);
                    observer.complete();
                };
                fileReader.onerror = function (error) {
                    fileReader.abort();
                    observer.error(error);
                };
            });
        };
        return FileReaderService;
    }());
    FileReaderService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: FileReaderService, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    FileReaderService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: FileReaderService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: FileReaderService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }] });

    var ImportCsvFileService = /** @class */ (function () {
        function ImportCsvFileService(fileReaderService) {
            this.fileReaderService = fileReaderService;
        }
        /**
         * Load CSV file.
         *
         * @param file File we want to load as CSV.
         * @param separator Separator for CSV data.
         * @return {Observable<string[][]>} Imported file
         */
        ImportCsvFileService.prototype.loadFile = function (file, separator) {
            var _this = this;
            return this.fileReaderService
                .loadTextFile(file)
                .pipe(operators.map(function (res) { return _this.parse(res, separator); }));
        };
        /**
         * Combined csv validation
         *
         * @param file File we want to load as CSV.
         * @param separator Separator for CSV data.
         * @param isDataParsable (optional) Callback for verify that structure type is proper.
         * @param maxEntries (optional) Limitation for maximum entries count.
         * @return {Observable<CsvFileValidationErrors | null>} Result of validation
         */
        ImportCsvFileService.prototype.validateFile = function (file, _a) {
            var _this = this;
            var separator = _a.separator, isDataParsable = _a.isDataParsable, maxEntries = _a.maxEntries;
            var errors = {};
            return this.fileReaderService.loadTextFile(file).pipe(operators.tap(function (data) {
                _this.validateEmpty(data, errors);
            }), operators.map(function (res) { return _this.parse(res, separator); }), operators.tap(function (data) {
                _this.validateNotParsable(data, errors, isDataParsable);
                _this.validateTooManyEntries(data, errors, maxEntries);
            }), operators.catchError(function (errors) { return rxjs.of(errors); }), operators.map(function () { return (Object.keys(errors).length === 0 ? null : errors); }));
        };
        /**
         * Processes the CSV data
         *
         * @param csvString raw extracted data from CSV
         * @param separator for csv data
         * @param ignoreHeader (optional) flag allows for ignore headers row while reading
         * @returns {string[][]} Parsed file
         */
        ImportCsvFileService.prototype.parse = function (csvString, separator, ignoreHeader) {
            if (ignoreHeader === void 0) { ignoreHeader = true; }
            return csvString
                .split('\n')
                .map(function (row) { return row.split(separator).map(function (cell) { return cell.replace(/"/g, ''); }); })
                .filter(function (value, index) { return !(ignoreHeader && index === 0) && value[0] !== ''; });
        };
        ImportCsvFileService.prototype.validateEmpty = function (data, errors) {
            if (data.toString().length === 0) {
                errors.empty = true;
                throw errors;
            }
        };
        ImportCsvFileService.prototype.validateTooManyEntries = function (data, errors, maxEntries) {
            if (maxEntries && data.length > maxEntries) {
                errors.tooManyEntries = { maxEntries: maxEntries };
                throw errors;
            }
        };
        ImportCsvFileService.prototype.validateNotParsable = function (data, errors, isDataParsable) {
            if (isDataParsable && !isDataParsable(data)) {
                errors.notParsable = true;
                throw errors;
            }
        };
        return ImportCsvFileService;
    }());
    ImportCsvFileService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ImportCsvFileService, deps: [{ token: FileReaderService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ImportCsvFileService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ImportCsvFileService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ImportCsvFileService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: FileReaderService }]; } });

    var FilesFormValidators = /** @class */ (function () {
        function FilesFormValidators() {
        }
        /**
         * Checks max size of file
         *
         * @param {number} maxSize Max size [MB]
         * @returns Uses 'tooLarge' validator error with maxSize property
         * @memberOf FilesFormValidators
         */
        FilesFormValidators.prototype.maxSize = function (maxSize) {
            return function (control) {
                var errors = {};
                if (maxSize) {
                    var files = Array.from(control.value);
                    files.forEach(function (file) {
                        var _a, _b;
                        if (file.size > maxSize * 1000000) {
                            var invalidFiles = (_b = (_a = errors.tooLarge) === null || _a === void 0 ? void 0 : _a.invalidFiles) !== null && _b !== void 0 ? _b : [];
                            errors.tooLarge = {
                                maxSize: maxSize,
                                invalidFiles: __spreadArray(__spreadArray([], __read(invalidFiles)), [file.name]),
                            };
                        }
                    });
                }
                return Object.keys(errors).length === 0 ? null : errors;
            };
        };
        return FilesFormValidators;
    }());
    FilesFormValidators.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: FilesFormValidators, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    FilesFormValidators.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: FilesFormValidators, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: FilesFormValidators, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }] });

    var CustomFormValidators = /** @class */ (function () {
        function CustomFormValidators() {
        }
        /**
         * Checks control's value with predefined email regexp
         *
         * NOTE: Use it as a control validator
         *
         * @static
         * @param {AbstractControl} control
         * @returns {(ValidationErrors | null)} Uses 'cxInvalidEmail' validator error
         * @memberof CustomFormValidators
         */
        CustomFormValidators.emailValidator = function (control) {
            var email = control.value;
            return email && (!email.length || email.match(i1.EMAIL_PATTERN))
                ? null
                : { cxInvalidEmail: true };
        };
        /**
         * Checks control's value with predefined password regexp
         *
         * NOTE: Use it as a control validator
         *
         * @static
         * @param {AbstractControl} control
         * @returns {(ValidationErrors | null)} Uses 'cxInvalidPassword' validator error
         * @memberof CustomFormValidators
         */
        CustomFormValidators.passwordValidator = function (control) {
            var password = control.value;
            return password && (!password.length || password.match(i1.PASSWORD_PATTERN))
                ? null
                : { cxInvalidPassword: true };
        };
        /**
         * Checks if control's value is between 1 and 5
         *
         * NOTE: Use it as a control validator
         *
         * @static
         * @param {AbstractControl} control
         * @returns {(ValidationErrors | null)} Uses 'cxStarRatingEmpty' validator error
         * @memberof CustomFormValidators
         */
        CustomFormValidators.starRatingEmpty = function (control) {
            var rating = control.value;
            return rating >= 1 && rating <= 5 ? null : { cxStarRatingEmpty: true };
        };
        /**
         * Checks if two password controls match
         *
         * NOTE: Use it as a form validator and pass password control names as parameters
         *
         * @static
         * @param {string} password First password control name
         * @param {string} passwordConfirmation Second password control name
         * @returns Uses 'cxPasswordsMustMatch' validator error
         * @memberof CustomFormValidators
         */
        CustomFormValidators.passwordsMustMatch = function (password, passwordConfirmation) {
            var validator = function (formGroup) { return controlsMustMatch(formGroup, password, passwordConfirmation, 'cxPasswordsMustMatch'); };
            return validator;
        };
        /**
         * Checks if two email controls match
         *
         * NOTE: Use it as a form validator and pass email control names as parameters
         *
         * @static
         * @param {string} email First email control name
         * @param {string} emailConfirmation Second email control name
         * @returns Uses 'cxEmailsMustMatch' validator error
         * @memberof CustomFormValidators
         */
        CustomFormValidators.emailsMustMatch = function (email, emailConfirmation) {
            var validator = function (formGroup) { return controlsMustMatch(formGroup, email, emailConfirmation, 'cxEmailsMustMatch'); };
            return validator;
        };
        /**
         * Checks if control's value is euqal or greater than 0
         *
         * NOTE: Use it as a control validator
         *
         * @static
         * @param {AbstractControl} control
         * @returns {(ValidationErrors | null)} Uses 'cxNegativeAmount' validator error
         * @memberof CustomFormValidators
         */
        CustomFormValidators.mustBePositive = function (control) {
            var amount = control.value;
            return amount >= 0 ? null : { cxNegativeAmount: true };
        };
        /**
         * Checks if control's value does not contain any special characters
         *
         * NOTE: Use it as a control validator
         *
         * @static
         * @param {AbstractControl} control
         * @returns {(ValidationErrors | null)} Uses 'cxContainsSpecialCharacters' validator error
         * @memberof CustomFormValidators
         */
        CustomFormValidators.noSpecialCharacters = function (control) {
            var forbiddenChars = ['/'];
            var str = String(control.value);
            var containsSpecialChars = forbiddenChars.some(function (char) { return str.includes(char); });
            return !containsSpecialChars ? null : { cxContainsSpecialCharacters: true };
        };
        /**
         * Checks if control's value passes pattern
         *
         * NOTE: Use it as a control validator
         *
         * @static
         * @param {(date: string) => boolean} isValidFormat Pattern verification function
         * @returns {(control: AbstractControl): ValidationErrors | null} Uses 'pattern' validator error
         * @memberof CustomFormValidators
         */
        CustomFormValidators.patternValidation = function (isValidFormat) {
            var validator = function (control) {
                var errors = {};
                if (control.value &&
                    control.value !== '' &&
                    !isValidFormat(control.value)) {
                    errors.pattern = true;
                }
                return Object.keys(errors).length === 0 ? null : errors;
            };
            return validator;
        };
        /**
         * Checks if two email controls match
         *
         * NOTE: Use it as a form validator and pass dates for range
         *
         * @static
         * @param {string} startDateKey First date control name
         * @param {string} endDateKey Second date control name
         * @param {(value: string) => Date} getDate Converting function
         * @returns Uses 'min' and 'max validator error
         * @memberof CustomFormValidators
         */
        CustomFormValidators.dateRange = function (startDateKey, endDateKey, getDate) {
            var validator = function (formGroup) {
                var _a, _b;
                var startDateControl = formGroup.controls[startDateKey];
                var endDateControl = formGroup.controls[endDateKey];
                var startDate = getDate(startDateControl.value);
                var endDate = getDate(endDateControl.value);
                if (!((_a = startDateControl.errors) === null || _a === void 0 ? void 0 : _a.pattern)) {
                    if (startDate > endDate) {
                        startDateControl.setErrors({ max: true });
                    }
                }
                if (!((_b = endDateControl.errors) === null || _b === void 0 ? void 0 : _b.pattern)) {
                    if (endDate < startDate) {
                        endDateControl.setErrors({ min: true });
                    }
                }
                return null;
            };
            return validator;
        };
        return CustomFormValidators;
    }());
    /**
     * Generic function for validators, which checks if two passed controls match.
     *
     * @param formGroup
     * @param firstControlName First control to check
     * @param secondControlName Second control to check
     * @param errorName Error which will be returned by validator
     */
    function controlsMustMatch(formGroup, firstControlName, secondControlName, errorName) {
        var _c;
        var firstControl = formGroup.controls[firstControlName];
        var secondControl = formGroup.controls[secondControlName];
        if (secondControl.errors && !secondControl.errors[errorName]) {
            return;
        }
        secondControl.setErrors(firstControl.value !== secondControl.value ? (_c = {}, _c[errorName] = true, _c) : null);
    }

    var titleScores = {
        mr: 1,
        mrs: 2,
        miss: 3,
        ms: 4,
        dr: 5,
        rev: 6,
    };
    function sortTitles(title1, title2) {
        if (!titleScores[title1.code] || !titleScores[title2.code]) {
            return 1;
        }
        else {
            return titleScores[title1.code] - titleScores[title2.code];
        }
    }

    var AppliedCouponsComponent = /** @class */ (function () {
        function AppliedCouponsComponent(cartVoucherService) {
            this.cartVoucherService = cartVoucherService;
            this.cartIsLoading = false;
            this.isReadOnly = false;
            this.iconTypes = exports.ICON_TYPE;
        }
        Object.defineProperty(AppliedCouponsComponent.prototype, "sortedVouchers", {
            get: function () {
                this.vouchers = this.vouchers || [];
                return this.vouchers.slice().sort(function (a, b) {
                    return a.code.localeCompare(b.code);
                });
            },
            enumerable: false,
            configurable: true
        });
        AppliedCouponsComponent.prototype.removeVoucher = function (voucherId) {
            this.cartVoucherService.removeVoucher(voucherId);
        };
        return AppliedCouponsComponent;
    }());
    AppliedCouponsComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AppliedCouponsComponent, deps: [{ token: i1__namespace.CartVoucherService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    AppliedCouponsComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: AppliedCouponsComponent, selector: "cx-applied-coupons", inputs: { vouchers: "vouchers", cartIsLoading: "cartIsLoading", isReadOnly: "isReadOnly" }, ngImport: i0__namespace, template: "<div *ngIf=\"isReadOnly; else editableCoupons\">\n  <div *ngIf=\"sortedVouchers.length > 0\">\n    <div class=\"cx-applied-coupon-title\">\n      {{ 'voucher.vouchersApplied' | cxTranslate }}\n    </div>\n  </div>\n  <div\n    *ngFor=\"let voucher of sortedVouchers\"\n    class=\"coupon-summary cx-coupon-card textonly\"\n    role=\"filter\"\n  >\n    <span class=\"cx-applied-coupon-code\">{{ voucher.voucherCode }}</span>\n  </div>\n</div>\n\n<ng-template #editableCoupons>\n  <div class=\"row\">\n    <div\n      *ngFor=\"let voucher of sortedVouchers\"\n      class=\"col-sm-12 col-md-6 col-lg-12 cx-coupon-card-grid\"\n      role=\"filter\"\n    >\n      <div class=\"cx-coupon-apply cx-coupon-card cx-coupon-list-wrap\">\n        <span class=\"cx-cart-coupon-code\">{{ voucher.voucherCode }}</span>\n        <button\n          type=\"button\"\n          class=\"close\"\n          [attr.aria-label]=\"'common.close' | cxTranslate\"\n          (click)=\"removeVoucher(voucher.voucherCode)\"\n          [disabled]=\"cartIsLoading\"\n          [class.disabled]=\"cartIsLoading\"\n        >\n          <span aria-hidden=\"true\">\n            <cx-icon [type]=\"iconTypes.CLOSE\"></cx-icon>\n          </span>\n        </button>\n      </div>\n    </div>\n  </div>\n</ng-template>\n", components: [{ type: IconComponent, selector: "cx-icon,[cxIcon]", inputs: ["cxIcon", "type"] }], directives: [{ type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3__namespace.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], pipes: { "cxTranslate": i1__namespace.TranslatePipe }, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AppliedCouponsComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-applied-coupons',
                        templateUrl: './applied-coupons.component.html',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace.CartVoucherService }]; }, propDecorators: { vouchers: [{
                    type: i0.Input
                }], cartIsLoading: [{
                    type: i0.Input
                }], isReadOnly: [{
                    type: i0.Input
                }] } });

    var CartCouponComponent = /** @class */ (function () {
        function CartCouponComponent(cartVoucherService, formBuilder, customerCouponService, activeCartService) {
            this.cartVoucherService = cartVoucherService;
            this.formBuilder = formBuilder;
            this.customerCouponService = customerCouponService;
            this.activeCartService = activeCartService;
            this.MAX_CUSTOMER_COUPON_PAGE = 100;
            this.ignoreCloseEvent = false;
            this.subscription = new rxjs.Subscription();
            this.couponBoxIsActive = false;
        }
        CartCouponComponent.prototype.ngOnInit = function () {
            var _this = this;
            if (this.customerCouponService) {
                this.customerCouponService.loadCustomerCoupons(this.MAX_CUSTOMER_COUPON_PAGE);
            }
            this.cart$ = rxjs.combineLatest([
                this.activeCartService.getActive(),
                this.activeCartService.getActiveCartId(),
                this.customerCouponService.getCustomerCoupons(this.MAX_CUSTOMER_COUPON_PAGE),
            ]).pipe(operators.tap(function (_a) {
                var _b = __read(_a, 3), cart = _b[0], activeCardId = _b[1], customerCoupons = _b[2];
                _this.cartId = activeCardId;
                _this.getApplicableCustomerCoupons(cart, customerCoupons.coupons);
            }), operators.map(function (_a) {
                var _b = __read(_a, 1), cart = _b[0];
                return cart;
            }));
            this.cartIsLoading$ = this.activeCartService
                .isStable()
                .pipe(operators.map(function (loaded) { return !loaded; }));
            this.cartVoucherService.resetAddVoucherProcessingState();
            this.couponForm = this.formBuilder.group({
                couponCode: ['', [i3$1.Validators.required]],
            });
            // TODO(#7241): Replace process subscriptions with event listeners and drop process for ADD_VOUCHER
            this.subscription.add(this.cartVoucherService
                .getAddVoucherResultSuccess()
                .subscribe(function (success) {
                _this.onSuccess(success);
            }));
            // TODO(#7241): Replace process subscriptions with event listeners and drop process for ADD_VOUCHER
            this.subscription.add(this.cartVoucherService.getAddVoucherResultError().subscribe(function (error) {
                _this.onError(error);
            }));
        };
        CartCouponComponent.prototype.onError = function (error) {
            if (error) {
                this.customerCouponService.loadCustomerCoupons(this.MAX_CUSTOMER_COUPON_PAGE);
                this.cartVoucherService.resetAddVoucherProcessingState();
            }
        };
        CartCouponComponent.prototype.onSuccess = function (success) {
            if (success) {
                this.couponForm.reset();
                this.cartVoucherService.resetAddVoucherProcessingState();
            }
        };
        CartCouponComponent.prototype.getApplicableCustomerCoupons = function (cart, coupons) {
            var _this = this;
            this.applicableCoupons = coupons || [];
            if (cart.appliedVouchers) {
                cart.appliedVouchers.forEach(function (appliedVoucher) {
                    _this.applicableCoupons = _this.applicableCoupons.filter(function (coupon) { return coupon.couponId !== appliedVoucher.code; });
                });
            }
        };
        CartCouponComponent.prototype.applyVoucher = function () {
            if (this.couponForm.valid) {
                this.cartVoucherService.addVoucher(this.couponForm.value.couponCode, this.cartId);
            }
            else {
                this.couponForm.markAllAsTouched();
            }
        };
        CartCouponComponent.prototype.applyCustomerCoupon = function (couponId) {
            this.cartVoucherService.addVoucher(couponId, this.cartId);
            this.couponBoxIsActive = false;
        };
        CartCouponComponent.prototype.close = function (event) {
            if (!this.ignoreCloseEvent) {
                this.couponBoxIsActive = false;
                if (event && event.target) {
                    event.target.blur();
                }
            }
            this.ignoreCloseEvent = false;
        };
        CartCouponComponent.prototype.disableClose = function () {
            this.ignoreCloseEvent = true;
        };
        CartCouponComponent.prototype.ngOnDestroy = function () {
            if (this.subscription) {
                this.subscription.unsubscribe();
            }
            this.cartVoucherService.resetAddVoucherProcessingState();
        };
        return CartCouponComponent;
    }());
    CartCouponComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartCouponComponent, deps: [{ token: i1__namespace.CartVoucherService }, { token: i3__namespace$1.FormBuilder }, { token: i1__namespace.CustomerCouponService }, { token: i1__namespace.ActiveCartService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    CartCouponComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: CartCouponComponent, selector: "cx-cart-coupon", ngImport: i0__namespace, template: "<ng-container *ngIf=\"cart$ | async as cart\">\n  <div class=\"cx-cart-coupon-title\">\n    {{ 'voucher.coupon' | cxTranslate }}\n  </div>\n  <div class=\"form-group\">\n    <form (ngSubmit)=\"applyVoucher()\" [formGroup]=\"couponForm\">\n      <div class=\"cx-cart-coupon-container\">\n        <input\n          aria-required=\"true\"\n          type=\"text\"\n          class=\"form-control input-coupon-code\"\n          formControlName=\"couponCode\"\n          placeholder=\"{{ 'voucher.placeholder' | cxTranslate }} \"\n        />\n        <button\n          class=\"btn btn-block btn-action apply-coupon-button\"\n          type=\"submit\"\n          [disabled]=\"cartIsLoading$ | async\"\n          [class.disabled]=\"cartIsLoading$ | async\"\n        >\n          {{ 'voucher.apply' | cxTranslate }}\n        </button>\n        <cx-form-errors\n          aria-live=\"assertive\"\n          aria-atomic=\"true\"\n          [control]=\"couponForm.get('couponCode')\"\n        ></cx-form-errors>\n      </div>\n    </form>\n  </div>\n\n  <cx-applied-coupons\n    [vouchers]=\"cart.appliedVouchers\"\n    [cartIsLoading]=\"cartIsLoading$ | async\"\n    [isReadOnly]=\"false\"\n  >\n  </cx-applied-coupons>\n\n  <ng-container *ngIf=\"applicableCoupons && applicableCoupons.length > 0\">\n    <div class=\"cx-available-coupon\">\n      <div class=\"title cx-cart-coupon-title\">\n        {{ 'voucher.availableCoupons' | cxTranslate }}\n      </div>\n      <div class=\"message\">\n        {{ 'voucher.availableCouponsLabel' | cxTranslate }}\n      </div>\n      <div class=\"scroll\">\n        <div class=\"coupons card\" *ngFor=\"let coupon of applicableCoupons\">\n          <button\n            (click)=\"applyCustomerCoupon(coupon.couponId)\"\n            class=\"coupon-id link\"\n            [disabled]=\"cartIsLoading$ | async\"\n            [class.disabled]=\"cartIsLoading$ | async\"\n          >\n            {{ coupon.couponId }}\n          </button>\n        </div>\n      </div>\n    </div>\n  </ng-container>\n</ng-container>\n", components: [{ type: FormErrorsComponent, selector: "cx-form-errors", inputs: ["prefix", "translationParams", "control"] }, { type: AppliedCouponsComponent, selector: "cx-applied-coupons", inputs: ["vouchers", "cartIsLoading", "isReadOnly"] }], directives: [{ type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3__namespace$1.ɵNgNoValidate, selector: "form:not([ngNoForm]):not([ngNativeValidate])" }, { type: i3__namespace$1.NgControlStatusGroup, selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { type: i3__namespace$1.FormGroupDirective, selector: "[formGroup]", inputs: ["formGroup"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }, { type: i3__namespace$1.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { type: i3__namespace$1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i3__namespace$1.FormControlName, selector: "[formControlName]", inputs: ["disabled", "formControlName", "ngModel"], outputs: ["ngModelChange"] }, { type: i3__namespace.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], pipes: { "async": i3__namespace.AsyncPipe, "cxTranslate": i1__namespace.TranslatePipe } });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartCouponComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-cart-coupon',
                        templateUrl: './cart-coupon.component.html',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace.CartVoucherService }, { type: i3__namespace$1.FormBuilder }, { type: i1__namespace.CustomerCouponService }, { type: i1__namespace.ActiveCartService }]; } });

    var CartCouponModule = /** @class */ (function () {
        function CartCouponModule() {
        }
        return CartCouponModule;
    }());
    CartCouponModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartCouponModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    CartCouponModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartCouponModule, declarations: [CartCouponComponent, AppliedCouponsComponent], imports: [i3.CommonModule,
            i1$4.NgSelectModule,
            i3$1.FormsModule,
            i3$1.ReactiveFormsModule,
            i1.I18nModule,
            IconModule,
            FormErrorsModule], exports: [CartCouponComponent, AppliedCouponsComponent] });
    CartCouponModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartCouponModule, providers: [
            i1.provideDefaultConfig({
                cmsComponents: {
                    CartApplyCouponComponent: {
                        component: CartCouponComponent,
                    },
                },
            }),
        ], imports: [[
                i3.CommonModule,
                i1$4.NgSelectModule,
                i3$1.FormsModule,
                i3$1.ReactiveFormsModule,
                i1.I18nModule,
                IconModule,
                FormErrorsModule,
            ]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartCouponModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        declarations: [CartCouponComponent, AppliedCouponsComponent],
                        exports: [CartCouponComponent, AppliedCouponsComponent],
                        imports: [
                            i3.CommonModule,
                            i1$4.NgSelectModule,
                            i3$1.FormsModule,
                            i3$1.ReactiveFormsModule,
                            i1.I18nModule,
                            IconModule,
                            FormErrorsModule,
                        ],
                        providers: [
                            i1.provideDefaultConfig({
                                cmsComponents: {
                                    CartApplyCouponComponent: {
                                        component: CartCouponComponent,
                                    },
                                },
                            }),
                        ],
                    }]
            }] });

    var CartItemListComponent = /** @class */ (function () {
        function CartItemListComponent(activeCartService, selectiveCartService, userIdService, multiCartService) {
            this.activeCartService = activeCartService;
            this.selectiveCartService = selectiveCartService;
            this.userIdService = userIdService;
            this.multiCartService = multiCartService;
            this.subscription = new rxjs.Subscription();
            this.readonly = false;
            this.hasHeader = true;
            this.options = {
                isSaveForLater: false,
                optionalBtn: null,
            };
            this._items = [];
            this.form = new i3$1.FormGroup({});
            this.promotionLocation = i1.PromotionLocation.ActiveCart;
        }
        Object.defineProperty(CartItemListComponent.prototype, "items", {
            get: function () {
                return this._items;
            },
            set: function (items) {
                this.resolveItems(items);
                this.createForm();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(CartItemListComponent.prototype, "setLoading", {
            set: function (value) {
                if (!this.readonly) {
                    // Whenever the cart is loading, we disable the complete form
                    // to avoid any user interaction with the cart.
                    value
                        ? this.form.disable({ emitEvent: false })
                        : this.form.enable({ emitEvent: false });
                }
            },
            enumerable: false,
            configurable: true
        });
        CartItemListComponent.prototype.ngOnInit = function () {
            var _this = this;
            var _a;
            this.subscription.add((_a = this.userIdService) === null || _a === void 0 ? void 0 : _a.getUserId().subscribe(function (userId) { return (_this.userId = userId); }));
        };
        /**
         * Resolves items passed to component input and updates 'items' field
         */
        CartItemListComponent.prototype.resolveItems = function (items) {
            var _a;
            if (!items) {
                this._items = [];
                return;
            }
            // The items we're getting from the input do not have a consistent model.
            // In case of a `consignmentEntry`, we need to normalize the data from the orderEntry.
            if (items.every(function (item) { return item.hasOwnProperty('orderEntry'); })) {
                this._items = items.map(function (consignmentEntry) {
                    var entry = Object.assign({}, consignmentEntry.orderEntry);
                    entry.quantity = consignmentEntry.quantity;
                    return entry;
                });
            }
            else {
                // We'd like to avoid the unnecessary re-renders of unchanged cart items after the data reload.
                // OCC cart entries don't have any unique identifier that we could use in Angular `trackBy`.
                // So we update each array element to the new object only when it's any different to the previous one.
                for (var i = 0; i < Math.max(items.length, this._items.length); i++) {
                    if (JSON.stringify((_a = this._items) === null || _a === void 0 ? void 0 : _a[i]) !== JSON.stringify(items[i])) {
                        if (this._items[i] && this.form) {
                            this.form.removeControl(this.getControlName(this._items[i]));
                        }
                        if (!items[i]) {
                            this._items.splice(i, 1);
                        }
                        else {
                            this._items[i] = items[i];
                        }
                    }
                }
            }
        };
        /**
         * Creates form models for list items
         */
        CartItemListComponent.prototype.createForm = function () {
            var _this = this;
            this._items.forEach(function (item) {
                var controlName = _this.getControlName(item);
                var group = new i3$1.FormGroup({
                    entryNumber: new i3$1.FormControl(item.entryNumber),
                    quantity: new i3$1.FormControl(item.quantity, { updateOn: 'blur' }),
                });
                _this.form.addControl(controlName, group);
                // If we disable form group before adding, disabled status will reset
                // Which forces us to disable control after including to form object
                if (!item.updateable || _this.readonly) {
                    _this.form.controls[controlName].disable();
                }
            });
        };
        CartItemListComponent.prototype.getControlName = function (item) {
            return item.entryNumber.toString();
        };
        CartItemListComponent.prototype.removeEntry = function (item) {
            var _a;
            if (this.selectiveCartService && this.options.isSaveForLater) {
                this.selectiveCartService.removeEntry(item);
            }
            else if (this.cartId && this.userId) {
                (_a = this.multiCartService) === null || _a === void 0 ? void 0 : _a.removeEntry(this.userId, this.cartId, item.entryNumber);
            }
            else {
                this.activeCartService.removeEntry(item);
            }
            delete this.form.controls[this.getControlName(item)];
        };
        CartItemListComponent.prototype.getControl = function (item) {
            var _this = this;
            return this.form.get(this.getControlName(item)).valueChanges.pipe(
            // eslint-disable-next-line import/no-deprecated
            operators.startWith(null), operators.tap(function (value) {
                var _a;
                if (item.updateable && value && !_this.readonly) {
                    if (_this.selectiveCartService && _this.options.isSaveForLater) {
                        _this.selectiveCartService.updateEntry(value.entryNumber, value.quantity);
                    }
                    else if (_this.cartId && _this.userId) {
                        (_a = _this.multiCartService) === null || _a === void 0 ? void 0 : _a.updateEntry(_this.userId, _this.cartId, value.entryNumber, value.quantity);
                    }
                    else {
                        _this.activeCartService.updateEntry(value.entryNumber, value.quantity);
                    }
                }
            }), operators.map(function () { return _this.form.get(_this.getControlName(item)); }));
        };
        CartItemListComponent.prototype.ngOnDestroy = function () {
            var _a;
            (_a = this.subscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();
        };
        return CartItemListComponent;
    }());
    CartItemListComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartItemListComponent, deps: [{ token: i1__namespace.ActiveCartService }, { token: i1__namespace.SelectiveCartService }, { token: i1__namespace.UserIdService }, { token: i1__namespace.MultiCartService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    CartItemListComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: CartItemListComponent, selector: "cx-cart-item-list", inputs: { readonly: "readonly", hasHeader: "hasHeader", options: "options", cartId: "cartId", items: "items", promotionLocation: "promotionLocation", setLoading: ["cartIsLoading", "setLoading"] }, ngImport: i0__namespace, template: "<div *ngIf=\"hasHeader\" class=\"d-none d-md-block d-lg-block d-xl-block\">\n  <div class=\"cx-item-list-header row\">\n    <div class=\"cx-item-list-desc col-md-5 col-lg-5 col-xl-6\">\n      {{ 'cartItems.description' | cxTranslate }}\n    </div>\n    <div class=\"cx-item-list-price col-md-3 col-lg-2 col-xl-2\">\n      {{ 'cartItems.itemPrice' | cxTranslate }}\n    </div>\n    <div class=\"cx-item-list-qty col-md-2 col-lg-3 col-xl-2\">\n      {{ 'cartItems.quantity' | cxTranslate }}\n    </div>\n\n    <ng-container *ngIf=\"options.isSaveForLater; else totalHeader\">\n      <div class=\"cx-item-list-total col-md-2 col-lg-2 col-xl-2\">\n        {{ 'saveForLaterItems.stock' | cxTranslate }}\n      </div>\n    </ng-container>\n  </div>\n</div>\n\n<div class=\"cx-item-list-row\" *ngFor=\"let item of items; let i = index\">\n  <div\n    *ngIf=\"getControl(item) | async as control\"\n    class=\"cx-item-list-items\"\n    [class.is-changed]=\"control.get('quantity').disabled\"\n  >\n    <cx-cart-item\n      [item]=\"item\"\n      [quantityControl]=\"control.get('quantity')\"\n      [readonly]=\"readonly\"\n      [promotionLocation]=\"promotionLocation\"\n      [options]=\"options\"\n    >\n    </cx-cart-item>\n  </div>\n</div>\n\n<ng-template #totalHeader>\n  <div class=\"cx-item-list-total col-md-2 col-lg-2 col-xl-2\">\n    {{ 'cartItems.total' | cxTranslate }}\n  </div>\n</ng-template>\n", components: [{ type: CartItemComponent, selector: "cx-cart-item", inputs: ["compact", "item", "readonly", "quantityControl", "promotionLocation", "options"] }], directives: [{ type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3__namespace.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], pipes: { "cxTranslate": i1__namespace.TranslatePipe, "async": i3__namespace.AsyncPipe }, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartItemListComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-cart-item-list',
                        templateUrl: './cart-item-list.component.html',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace.ActiveCartService }, { type: i1__namespace.SelectiveCartService }, { type: i1__namespace.UserIdService }, { type: i1__namespace.MultiCartService }]; }, propDecorators: { readonly: [{
                    type: i0.Input
                }], hasHeader: [{
                    type: i0.Input
                }], options: [{
                    type: i0.Input
                }], cartId: [{
                    type: i0.Input
                }], items: [{
                    type: i0.Input,
                    args: ['items']
                }], promotionLocation: [{
                    type: i0.Input
                }], setLoading: [{
                    type: i0.Input,
                    args: ['cartIsLoading']
                }] } });

    var OrderSummaryComponent = /** @class */ (function () {
        function OrderSummaryComponent() {
        }
        return OrderSummaryComponent;
    }());
    OrderSummaryComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OrderSummaryComponent, deps: [], target: i0__namespace.ɵɵFactoryTarget.Component });
    OrderSummaryComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: OrderSummaryComponent, selector: "cx-order-summary", inputs: { cart: "cart" }, ngImport: i0__namespace, template: "<h3>{{ 'orderCost.orderSummary' | cxTranslate }}</h3>\n\n<div class=\"cx-summary-partials\" *ngIf=\"cart\">\n  <div class=\"cx-summary-row\">\n    <div class=\"col-6 cx-summary-label\">\n      {{ 'orderCost.subtotal' | cxTranslate }}\n    </div>\n    <div class=\"col-6 cx-summary-amount\">\n      {{ cart.subTotal?.formattedValue }}\n    </div>\n  </div>\n  <div class=\"cx-summary-row\">\n    <div class=\"col-6 cx-summary-label\">\n      {{\n        (cart.deliveryCost?.formattedValue\n          ? 'orderCost.shipping'\n          : 'orderCost.estimatedShipping'\n        ) | cxTranslate\n      }}\n    </div>\n    <div class=\"col-6 cx-summary-amount\">\n      {{\n        cart.deliveryCost?.formattedValue\n          ? cart.deliveryCost.formattedValue\n          : ('orderCost.toBeDetermined' | cxTranslate)\n      }}\n    </div>\n  </div>\n  <div class=\"cx-summary-row\" *ngIf=\"cart.net; else cartWithoutNet\">\n    <div class=\"col-6 cx-summary-label\">\n      {{ 'orderCost.salesTax' | cxTranslate }}\n    </div>\n    <div class=\"col-6 cx-summary-amount\">\n      {{ cart.totalTax?.formattedValue }}\n    </div>\n  </div>\n  <div class=\"cx-summary-row cx-summary-total\">\n    <div class=\"col-6 cx-summary-label\">\n      {{ 'orderCost.total' | cxTranslate }}\n    </div>\n    <div class=\"col-6 cx-summary-amount\">\n      {{ cart.totalPriceWithTax?.formattedValue }}\n    </div>\n  </div>\n  <div class=\"cx-summary-row\" *ngIf=\"cart.totalDiscounts?.value > 0\">\n    {{ 'orderCost.discount' | cxTranslate }}\n    {{ cart.totalDiscounts?.formattedValue }}\n  </div>\n  <ng-template #cartWithoutNet>\n    <div class=\"cx-summary-row\">\n      {{\n        cart.totalPriceWithTax?.value !== cart.totalPrice?.value\n          ? ('orderCost.grossTax' | cxTranslate)\n          : ('orderCost.grossIncludeTax' | cxTranslate)\n      }}\n      {{ cart.totalTax?.formattedValue }}.\n    </div>\n  </ng-template>\n</div>\n\n<!--\n<cx-promotions\n  *ngIf=\"cart\"\n  [promotions]=\"cart.appliedOrderPromotions\"\n></cx-promotions>\n-->\n\n<ng-container *cxFeatureLevel=\"'1.3'\">\n  <cx-applied-coupons\n    [vouchers]=\"cart.appliedVouchers\"\n    [isReadOnly]=\"true\"\n  ></cx-applied-coupons>\n</ng-container>\n", components: [{ type: AppliedCouponsComponent, selector: "cx-applied-coupons", inputs: ["vouchers", "cartIsLoading", "isReadOnly"] }], directives: [{ type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i1__namespace.FeatureLevelDirective, selector: "[cxFeatureLevel]", inputs: ["cxFeatureLevel"] }], pipes: { "cxTranslate": i1__namespace.TranslatePipe } });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OrderSummaryComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-order-summary',
                        templateUrl: './order-summary.component.html',
                    }]
            }], propDecorators: { cart: [{
                    type: i0.Input
                }] } });

    var CartItemValidationWarningModule = /** @class */ (function () {
        function CartItemValidationWarningModule() {
        }
        return CartItemValidationWarningModule;
    }());
    CartItemValidationWarningModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartItemValidationWarningModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    CartItemValidationWarningModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartItemValidationWarningModule, declarations: [CartItemValidationWarningComponent], imports: [i3.CommonModule, i1$1.RouterModule, i1.I18nModule, i1.UrlModule, IconModule], exports: [CartItemValidationWarningComponent] });
    CartItemValidationWarningModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartItemValidationWarningModule, imports: [[i3.CommonModule, i1$1.RouterModule, i1.I18nModule, i1.UrlModule, IconModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartItemValidationWarningModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [i3.CommonModule, i1$1.RouterModule, i1.I18nModule, i1.UrlModule, IconModule],
                        exports: [CartItemValidationWarningComponent],
                        declarations: [CartItemValidationWarningComponent],
                    }]
            }] });

    var CartSharedModule = /** @class */ (function () {
        function CartSharedModule() {
        }
        return CartSharedModule;
    }());
    CartSharedModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartSharedModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    CartSharedModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartSharedModule, declarations: [CartItemComponent,
            OrderSummaryComponent,
            CartItemListComponent], imports: [i3.CommonModule,
            i1$1.RouterModule,
            CartCouponModule,
            i3$1.ReactiveFormsModule,
            i1.UrlModule,
            i1$3.NgbModule,
            PromotionsModule,
            i1.I18nModule,
            IconModule,
            MediaModule,
            ItemCounterModule,
            i1.FeaturesConfigModule,
            ModalModule,
            OutletModule,
            CartItemValidationWarningModule], exports: [CartItemComponent, CartItemListComponent, OrderSummaryComponent] });
    CartSharedModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartSharedModule, imports: [[
                i3.CommonModule,
                i1$1.RouterModule,
                CartCouponModule,
                i3$1.ReactiveFormsModule,
                i1.UrlModule,
                i1$3.NgbModule,
                PromotionsModule,
                i1.I18nModule,
                IconModule,
                MediaModule,
                ItemCounterModule,
                i1.FeaturesConfigModule,
                ModalModule,
                OutletModule,
                CartItemValidationWarningModule,
            ]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartSharedModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [
                            i3.CommonModule,
                            i1$1.RouterModule,
                            CartCouponModule,
                            i3$1.ReactiveFormsModule,
                            i1.UrlModule,
                            i1$3.NgbModule,
                            PromotionsModule,
                            i1.I18nModule,
                            IconModule,
                            MediaModule,
                            ItemCounterModule,
                            i1.FeaturesConfigModule,
                            ModalModule,
                            OutletModule,
                            CartItemValidationWarningModule,
                        ],
                        declarations: [
                            CartItemComponent,
                            OrderSummaryComponent,
                            CartItemListComponent,
                        ],
                        exports: [CartItemComponent, CartItemListComponent, OrderSummaryComponent],
                    }]
            }] });

    var AddToCartModule = /** @class */ (function () {
        function AddToCartModule() {
        }
        return AddToCartModule;
    }());
    AddToCartModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AddToCartModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    AddToCartModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AddToCartModule, declarations: [AddToCartComponent, AddedToCartDialogComponent], imports: [i3.CommonModule,
            i3$1.ReactiveFormsModule,
            CartSharedModule,
            i1$1.RouterModule,
            SpinnerModule,
            PromotionsModule,
            i1.FeaturesConfigModule,
            i1.UrlModule,
            IconModule,
            i1.I18nModule,
            ItemCounterModule,
            KeyboardFocusModule,
            ModalModule], exports: [AddToCartComponent, AddedToCartDialogComponent] });
    AddToCartModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AddToCartModule, providers: [
            i1.provideDefaultConfig({
                cmsComponents: {
                    ProductAddToCartComponent: {
                        component: AddToCartComponent,
                        data: {
                            inventoryDisplay: false,
                        },
                    },
                },
            }),
        ], imports: [[
                i3.CommonModule,
                i3$1.ReactiveFormsModule,
                CartSharedModule,
                i1$1.RouterModule,
                SpinnerModule,
                PromotionsModule,
                i1.FeaturesConfigModule,
                i1.UrlModule,
                IconModule,
                i1.I18nModule,
                ItemCounterModule,
                KeyboardFocusModule,
                ModalModule,
            ]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AddToCartModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [
                            i3.CommonModule,
                            i3$1.ReactiveFormsModule,
                            CartSharedModule,
                            i1$1.RouterModule,
                            SpinnerModule,
                            PromotionsModule,
                            i1.FeaturesConfigModule,
                            i1.UrlModule,
                            IconModule,
                            i1.I18nModule,
                            ItemCounterModule,
                            KeyboardFocusModule,
                            ModalModule,
                        ],
                        providers: [
                            i1.provideDefaultConfig({
                                cmsComponents: {
                                    ProductAddToCartComponent: {
                                        component: AddToCartComponent,
                                        data: {
                                            inventoryDisplay: false,
                                        },
                                    },
                                },
                            }),
                        ],
                        declarations: [AddToCartComponent, AddedToCartDialogComponent],
                        exports: [AddToCartComponent, AddedToCartDialogComponent],
                    }]
            }] });

    var AddToWishListComponent = /** @class */ (function () {
        function AddToWishListComponent(wishListService, currentProductService, authService) {
            var _this = this;
            this.wishListService = wishListService;
            this.currentProductService = currentProductService;
            this.authService = authService;
            this.product$ = this.currentProductService.getProduct().pipe(operators.filter(i1.isNotNullable), operators.tap(function (product) { return _this.setStockInfo(product); }));
            this.wishListEntries$ = this.wishListService
                .getWishList()
                .pipe(operators.filter(function (wishlist) { return Boolean(wishlist); }), operators.map(function (wishList) { return wishList.entries; }));
            this.userLoggedIn$ = this.authService.isUserLoggedIn();
            this.loading$ = this.wishListService.getWishListLoading();
            this.hasStock = false;
            this.iconTypes = exports.ICON_TYPE;
        }
        AddToWishListComponent.prototype.add = function (product) {
            this.wishListService.addEntry(product.code);
        };
        AddToWishListComponent.prototype.remove = function (entry) {
            this.wishListService.removeEntry(entry);
        };
        AddToWishListComponent.prototype.getProductInWishList = function (product, entries) {
            var item = entries.find(function (entry) { return entry.product.code === product.code; });
            return item;
        };
        AddToWishListComponent.prototype.setStockInfo = function (product) {
            this.hasStock = Boolean(product.stock && product.stock.stockLevelStatus !== 'outOfStock');
        };
        return AddToWishListComponent;
    }());
    AddToWishListComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AddToWishListComponent, deps: [{ token: i1__namespace.WishListService }, { token: CurrentProductService }, { token: i1__namespace.AuthService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    AddToWishListComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: AddToWishListComponent, selector: "cx-add-to-wishlist", ngImport: i0__namespace, template: "<ng-container *ngIf=\"product$ | async as product\">\n  <ng-container *ngIf=\"userLoggedIn$ | async; else loginPrompt\">\n    <ng-container *ngIf=\"wishListEntries$ | async as entries\">\n      <ng-container *ngIf=\"hasStock\">\n        <div\n          *ngIf=\"getProductInWishList(product, entries) as entry; else addItem\"\n        >\n          <button\n            class=\"btn btn-link button-remove cx-action-link\"\n            (click)=\"remove(entry)\"\n            [disabled]=\"loading$ | async\"\n          >\n            <cx-icon [type]=\"iconTypes.HEART\"></cx-icon>\n            <span class=\"button-text\">{{\n              'addToWishList.remove' | cxTranslate\n            }}</span>\n          </button>\n        </div>\n        <ng-template #addItem>\n          <button\n            class=\"btn btn-link button-add cx-action-link\"\n            (click)=\"add(product)\"\n            [disabled]=\"loading$ | async\"\n          >\n            <cx-icon [type]=\"iconTypes.EMPTY_HEART\"></cx-icon>\n            <span class=\"button-text\">{{\n              'addToWishList.add' | cxTranslate\n            }}</span>\n          </button>\n        </ng-template>\n      </ng-container>\n    </ng-container>\n  </ng-container>\n</ng-container>\n\n<ng-template #loginPrompt>\n  <ng-container *ngIf=\"hasStock\">\n    <a\n      class=\"btn btn-link button-add-link cx-action-link\"\n      [routerLink]=\"{ cxRoute: 'login' } | cxUrl\"\n    >\n      <cx-icon [type]=\"iconTypes.EMPTY_HEART\"></cx-icon>\n      <span class=\"button-text\">{{\n        'addToWishList.anonymous' | cxTranslate\n      }}</span>\n    </a>\n  </ng-container>\n</ng-template>\n", components: [{ type: IconComponent, selector: "cx-icon,[cxIcon]", inputs: ["cxIcon", "type"] }], directives: [{ type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i1__namespace$1.RouterLinkWithHref, selector: "a[routerLink],area[routerLink]", inputs: ["routerLink", "target", "queryParams", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange", "replaceUrl", "state", "relativeTo"] }], pipes: { "async": i3__namespace.AsyncPipe, "cxTranslate": i1__namespace.TranslatePipe, "cxUrl": i1__namespace.UrlPipe }, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AddToWishListComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-add-to-wishlist',
                        templateUrl: './add-to-wish-list.component.html',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace.WishListService }, { type: CurrentProductService }, { type: i1__namespace.AuthService }]; } });

    var AddToWishListModule = /** @class */ (function () {
        function AddToWishListModule() {
        }
        return AddToWishListModule;
    }());
    AddToWishListModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AddToWishListModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    AddToWishListModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AddToWishListModule, declarations: [AddToWishListComponent], imports: [i3.CommonModule, i1.I18nModule, IconModule, i1$1.RouterModule, i1.UrlModule], exports: [AddToWishListComponent] });
    AddToWishListModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AddToWishListModule, providers: [
            i1.provideDefaultConfig({
                cmsComponents: {
                    AddToWishListComponent: {
                        component: AddToWishListComponent,
                    },
                },
            }),
        ], imports: [[i3.CommonModule, i1.I18nModule, IconModule, i1$1.RouterModule, i1.UrlModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AddToWishListModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [i3.CommonModule, i1.I18nModule, IconModule, i1$1.RouterModule, i1.UrlModule],
                        providers: [
                            i1.provideDefaultConfig({
                                cmsComponents: {
                                    AddToWishListComponent: {
                                        component: AddToWishListComponent,
                                    },
                                },
                            }),
                        ],
                        declarations: [AddToWishListComponent],
                        exports: [AddToWishListComponent],
                    }]
            }] });

    var CartValidationWarningsComponent = /** @class */ (function () {
        function CartValidationWarningsComponent(cartValidationStateService) {
            var _this = this;
            this.cartValidationStateService = cartValidationStateService;
            this.iconTypes = exports.ICON_TYPE;
            this.visibleWarnings = {};
            this.cartModifications$ = this.cartValidationStateService.cartValidationResult$.pipe(operators.map(function (modificationList) {
                var result = modificationList.filter(function (modification) { return modification.statusCode === i1.CartValidationStatusCode.NO_STOCK; });
                result.forEach(function (modification) {
                    var _a, _b;
                    if ((_b = (_a = modification.entry) === null || _a === void 0 ? void 0 : _a.product) === null || _b === void 0 ? void 0 : _b.code) {
                        _this.visibleWarnings[modification.entry.product.code] = true;
                    }
                });
                return result;
            }));
        }
        CartValidationWarningsComponent.prototype.removeMessage = function (cartModification) {
            var _a, _b;
            if ((_b = (_a = cartModification.entry) === null || _a === void 0 ? void 0 : _a.product) === null || _b === void 0 ? void 0 : _b.code) {
                this.visibleWarnings[cartModification.entry.product.code] = false;
            }
        };
        return CartValidationWarningsComponent;
    }());
    CartValidationWarningsComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartValidationWarningsComponent, deps: [{ token: CartValidationStateService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    CartValidationWarningsComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: CartValidationWarningsComponent, selector: "cx-cart-validation-warnings", ngImport: i0__namespace, template: "<ng-container *ngFor=\"let cartModification of cartModifications$ | async\">\n  <div\n    class=\"alert alert-danger\"\n    *ngIf=\"visibleWarnings[cartModification.entry.product.code]\"\n  >\n    <span class=\"alert-icon\">\n      <cx-icon [type]=\"iconTypes.ERROR\"></cx-icon>\n    </span>\n    <span>\n      <a\n        [routerLink]=\"\n          { cxRoute: 'product', params: cartModification.entry.product } | cxUrl\n        \"\n      >\n        {{ cartModification.entry.product.name }}\n      </a>\n      {{ 'validation.productOutOfStock' | cxTranslate }}\n    </span>\n\n    <button\n      class=\"close\"\n      type=\"button\"\n      (click)=\"removeMessage(cartModification)\"\n    >\n      <cx-icon [type]=\"iconTypes.CLOSE\"></cx-icon>\n    </button>\n  </div>\n</ng-container>\n", components: [{ type: IconComponent, selector: "cx-icon,[cxIcon]", inputs: ["cxIcon", "type"] }], directives: [{ type: i3__namespace.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i1__namespace$1.RouterLinkWithHref, selector: "a[routerLink],area[routerLink]", inputs: ["routerLink", "target", "queryParams", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange", "replaceUrl", "state", "relativeTo"] }], pipes: { "async": i3__namespace.AsyncPipe, "cxUrl": i1__namespace.UrlPipe, "cxTranslate": i1__namespace.TranslatePipe }, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartValidationWarningsComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-cart-validation-warnings',
                        templateUrl: './cart-validation-warnings.component.html',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], ctorParameters: function () { return [{ type: CartValidationStateService }]; } });

    var CartDetailsComponent = /** @class */ (function () {
        function CartDetailsComponent(activeCartService, selectiveCartService, authService, routingService) {
            this.activeCartService = activeCartService;
            this.selectiveCartService = selectiveCartService;
            this.authService = authService;
            this.routingService = routingService;
            this.loggedIn = false;
            this.promotionLocation = i1.PromotionLocation.ActiveCart;
        }
        CartDetailsComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.cart$ = this.activeCartService.getActive();
            this.entries$ = this.activeCartService
                .getEntries()
                .pipe(operators.filter(function (entries) { return entries.length > 0; }));
            this.selectiveCartEnabled = this.selectiveCartService.isEnabled();
            this.cartLoaded$ = rxjs.combineLatest([
                this.activeCartService.isStable(),
                this.selectiveCartEnabled
                    ? this.selectiveCartService.isStable()
                    : rxjs.of(false),
                this.authService.isUserLoggedIn(),
            ]).pipe(operators.tap(function (_a) {
                var _b = __read(_a, 3), loggedIn = _b[2];
                return (_this.loggedIn = loggedIn);
            }), operators.map(function (_a) {
                var _b = __read(_a, 3), cartLoaded = _b[0], sflLoaded = _b[1], loggedIn = _b[2];
                return loggedIn && _this.selectiveCartEnabled
                    ? cartLoaded && sflLoaded
                    : cartLoaded;
            }));
        };
        CartDetailsComponent.prototype.saveForLater = function (item) {
            if (this.loggedIn) {
                this.activeCartService.removeEntry(item);
                this.selectiveCartService.addEntry(item.product.code, item.quantity);
            }
            else {
                this.routingService.go({ cxRoute: 'login' });
            }
        };
        return CartDetailsComponent;
    }());
    CartDetailsComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartDetailsComponent, deps: [{ token: i1__namespace.ActiveCartService }, { token: i1__namespace.SelectiveCartService }, { token: i1__namespace.AuthService }, { token: i1__namespace.RoutingService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    CartDetailsComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: CartDetailsComponent, selector: "cx-cart-details", ngImport: i0__namespace, template: "<ng-container *ngIf=\"cart$ | async as cart\">\n  <ng-container *ngIf=\"entries$ | async as entries\">\n    <div *ngIf=\"cart.totalItems > 0\" class=\"cart-details-wrapper\">\n      <ng-container *cxFeatureLevel=\"'4.2'\">\n        <cx-cart-validation-warnings></cx-cart-validation-warnings>\n      </ng-container>\n\n      <h4 class=\"cx-total\">\n        {{ 'cartDetails.cartName' | cxTranslate: { code: cart.code } }}\n      </h4>\n\n      <cx-promotions\n        [promotions]=\"\n          (cart.appliedOrderPromotions || []).concat(\n            cart.potentialOrderPromotions || []\n          )\n        \"\n      ></cx-promotions>\n\n      <cx-cart-item-list\n        [items]=\"entries\"\n        [cartIsLoading]=\"!(cartLoaded$ | async)\"\n        [promotionLocation]=\"promotionLocation\"\n        [options]=\"{\n          isSaveForLater: false,\n          optionalBtn: saveForLaterBtn\n        }\"\n      ></cx-cart-item-list>\n    </div>\n  </ng-container>\n</ng-container>\n\n<ng-template let-ctx #saveForLaterBtn>\n  <div\n    *ngIf=\"selectiveCartEnabled\"\n    class=\"col-md-3 col-lg-3 col-xl-3 cx-sfl-btn\"\n  >\n    <button\n      class=\"link cx-action-link\"\n      [disabled]=\"ctx.loading\"\n      (click)=\"saveForLater(ctx.item)\"\n      type=\"button\"\n    >\n      {{ 'saveForLaterItems.saveForLater' | cxTranslate }}\n    </button>\n  </div>\n</ng-template>\n", components: [{ type: CartValidationWarningsComponent, selector: "cx-cart-validation-warnings" }, { type: PromotionsComponent, selector: "cx-promotions", inputs: ["promotions"] }, { type: CartItemListComponent, selector: "cx-cart-item-list", inputs: ["readonly", "hasHeader", "options", "cartId", "items", "promotionLocation", "cartIsLoading"] }], directives: [{ type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i1__namespace.FeatureLevelDirective, selector: "[cxFeatureLevel]", inputs: ["cxFeatureLevel"] }], pipes: { "async": i3__namespace.AsyncPipe, "cxTranslate": i1__namespace.TranslatePipe }, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartDetailsComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-cart-details',
                        templateUrl: './cart-details.component.html',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace.ActiveCartService }, { type: i1__namespace.SelectiveCartService }, { type: i1__namespace.AuthService }, { type: i1__namespace.RoutingService }]; } });

    var CartValidationWarningsModule = /** @class */ (function () {
        function CartValidationWarningsModule() {
        }
        return CartValidationWarningsModule;
    }());
    CartValidationWarningsModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartValidationWarningsModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    CartValidationWarningsModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartValidationWarningsModule, declarations: [CartValidationWarningsComponent], imports: [i3.CommonModule, i1$1.RouterModule, i1.I18nModule, i1.UrlModule, IconModule], exports: [CartValidationWarningsComponent] });
    CartValidationWarningsModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartValidationWarningsModule, imports: [[i3.CommonModule, i1$1.RouterModule, i1.I18nModule, i1.UrlModule, IconModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartValidationWarningsModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [i3.CommonModule, i1$1.RouterModule, i1.I18nModule, i1.UrlModule, IconModule],
                        exports: [CartValidationWarningsComponent],
                        declarations: [CartValidationWarningsComponent],
                    }]
            }] });

    var CartDetailsModule = /** @class */ (function () {
        function CartDetailsModule() {
        }
        return CartDetailsModule;
    }());
    CartDetailsModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartDetailsModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    CartDetailsModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartDetailsModule, declarations: [CartDetailsComponent], imports: [CartSharedModule,
            i3.CommonModule,
            CartCouponModule,
            i1$1.RouterModule,
            i1.UrlModule,
            PromotionsModule,
            i1.FeaturesConfigModule,
            i1.I18nModule,
            CartValidationWarningsModule], exports: [CartDetailsComponent] });
    CartDetailsModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartDetailsModule, providers: [
            i1.provideDefaultConfig({
                cmsComponents: {
                    CartComponent: {
                        component: CartDetailsComponent,
                    },
                },
            }),
        ], imports: [[
                CartSharedModule,
                i3.CommonModule,
                CartCouponModule,
                i1$1.RouterModule,
                i1.UrlModule,
                PromotionsModule,
                i1.FeaturesConfigModule,
                i1.I18nModule,
                CartValidationWarningsModule,
            ]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartDetailsModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [
                            CartSharedModule,
                            i3.CommonModule,
                            CartCouponModule,
                            i1$1.RouterModule,
                            i1.UrlModule,
                            PromotionsModule,
                            i1.FeaturesConfigModule,
                            i1.I18nModule,
                            CartValidationWarningsModule,
                        ],
                        providers: [
                            i1.provideDefaultConfig({
                                cmsComponents: {
                                    CartComponent: {
                                        component: CartDetailsComponent,
                                    },
                                },
                            }),
                        ],
                        declarations: [CartDetailsComponent],
                        exports: [CartDetailsComponent],
                    }]
            }] });

    var CartPageLayoutHandler = /** @class */ (function () {
        function CartPageLayoutHandler(activeCartService, selectiveCartService) {
            this.activeCartService = activeCartService;
            this.selectiveCartService = selectiveCartService;
        }
        CartPageLayoutHandler.prototype.handle = function (slots$, pageTemplate, section) {
            if (pageTemplate === 'CartPageTemplate' && !section) {
                return rxjs.combineLatest([
                    slots$,
                    this.activeCartService.getActive(),
                    this.selectiveCartService.isEnabled()
                        ? this.selectiveCartService.getCart()
                        : rxjs.of({}),
                    this.activeCartService.getLoading(),
                ]).pipe(operators.map(function (_a) {
                    var _b = __read(_a, 4), slots = _b[0], cart = _b[1], selectiveCart = _b[2], loadingCart = _b[3];
                    var exclude = function (arr, args) { return arr.filter(function (item) { return args.every(function (arg) { return arg !== item; }); }); };
                    return Object.keys(cart).length === 0 && loadingCart
                        ? exclude(slots, [
                            'TopContent',
                            'CenterRightContentSlot',
                            'EmptyCartMiddleContent',
                        ])
                        : cart.totalItems
                            ? exclude(slots, ['EmptyCartMiddleContent'])
                            : selectiveCart.totalItems
                                ? exclude(slots, [
                                    'EmptyCartMiddleContent',
                                    'CenterRightContentSlot',
                                ])
                                : exclude(slots, ['TopContent', 'CenterRightContentSlot']);
                }));
            }
            return slots$;
        };
        return CartPageLayoutHandler;
    }());
    CartPageLayoutHandler.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartPageLayoutHandler, deps: [{ token: i1__namespace.ActiveCartService }, { token: i1__namespace.SelectiveCartService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    CartPageLayoutHandler.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartPageLayoutHandler, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartPageLayoutHandler, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace.ActiveCartService }, { type: i1__namespace.SelectiveCartService }]; } });

    exports.ProductImportStatus = void 0;
    (function (ProductImportStatus) {
        ProductImportStatus["SUCCESS"] = "success";
        ProductImportStatus["LOW_STOCK"] = "lowStock";
        ProductImportStatus["NO_STOCK"] = "noStock";
        ProductImportStatus["UNKNOWN_IDENTIFIER"] = "unknownIdentifier";
        ProductImportStatus["UNKNOWN_ERROR"] = "unknownError";
        ProductImportStatus["LIMIT_EXCEEDED"] = "limitExceeded";
    })(exports.ProductImportStatus || (exports.ProductImportStatus = {}));

    /**
     * An abstract class for contexts based on cart (active cart, saved cart) which share part of logic - mainly handle cart actions and map results.
     */
    var CartOrderEntriesContext = /** @class */ (function () {
        function CartOrderEntriesContext(actionsSubject) {
            this.actionsSubject = actionsSubject;
        }
        CartOrderEntriesContext.prototype.addEntries = function (products) {
            var _this = this;
            return this.add(products).pipe(operators.switchMap(function (cartId) { return _this.getResults(cartId); }), operators.take(products.length));
        };
        /**
         * Get emission of add entry results from actions subject
         *
         * @param {string} cartId
         * @returns {Observable<ProductImportInfo>}
         */
        CartOrderEntriesContext.prototype.getResults = function (cartId) {
            var _this = this;
            return this.actionsSubject.pipe(effects.ofType(i1.CartActions.CART_ADD_ENTRY_SUCCESS, i1.CartActions.CART_ADD_ENTRY_FAIL), operators.filter(function (action) { return action.payload.cartId === cartId; }), operators.map(function (action) { return _this.mapMessages(action); }));
        };
        /**
         * Map actions to summary messages
         *
         * @param {CartActions.CartAddEntrySuccess | CartActions.CartAddEntryFail} action
         * @returns ProductImportInfo
         */
        CartOrderEntriesContext.prototype.mapMessages = function (action) {
            var _a, _b, _c;
            var productCode = action.payload.productCode;
            if (action instanceof i1.CartActions.CartAddEntrySuccess) {
                var _d = action.payload, quantity = _d.quantity, quantityAdded = _d.quantityAdded, entry = _d.entry, statusCode = _d.statusCode;
                if (statusCode === exports.ProductImportStatus.LOW_STOCK) {
                    return {
                        productCode: productCode,
                        statusCode: statusCode,
                        productName: (_a = entry === null || entry === void 0 ? void 0 : entry.product) === null || _a === void 0 ? void 0 : _a.name,
                        quantity: quantity,
                        quantityAdded: quantityAdded,
                    };
                }
                if (statusCode === exports.ProductImportStatus.SUCCESS ||
                    statusCode === exports.ProductImportStatus.NO_STOCK) {
                    return { productCode: productCode, statusCode: statusCode, productName: (_b = entry === null || entry === void 0 ? void 0 : entry.product) === null || _b === void 0 ? void 0 : _b.name };
                }
            }
            else if (action instanceof i1.CartActions.CartAddEntryFail) {
                var error = action.payload.error;
                if (((_c = error === null || error === void 0 ? void 0 : error.details[0]) === null || _c === void 0 ? void 0 : _c.type) === 'UnknownIdentifierError') {
                    return {
                        productCode: productCode,
                        statusCode: exports.ProductImportStatus.UNKNOWN_IDENTIFIER,
                    };
                }
            }
            if (i0.isDevMode()) {
                console.warn('Unrecognized cart add entry action type while mapping messages', action);
            }
            return { productCode: productCode, statusCode: exports.ProductImportStatus.UNKNOWN_ERROR };
        };
        return CartOrderEntriesContext;
    }());

    exports.OrderEntriesSource = void 0;
    (function (OrderEntriesSource) {
        OrderEntriesSource["ACTIVE_CART"] = "ACTIVE_CART";
        OrderEntriesSource["NEW_SAVED_CART"] = "NEW_SAVED_CART";
        OrderEntriesSource["QUICK_ORDER"] = "QUICK_ORDER";
        OrderEntriesSource["SAVED_CART"] = "SAVED_CART";
        OrderEntriesSource["ORDER_CONFIRMATION"] = "ORDER_CONFIRMATION";
        OrderEntriesSource["ORDER_DETAILS"] = "ORDER_DETAILS";
    })(exports.OrderEntriesSource || (exports.OrderEntriesSource = {}));

    var ActiveCartOrderEntriesContext = /** @class */ (function (_super) {
        __extends(ActiveCartOrderEntriesContext, _super);
        function ActiveCartOrderEntriesContext(actionsSubject, activeCartService) {
            var _this = _super.call(this, actionsSubject) || this;
            _this.actionsSubject = actionsSubject;
            _this.activeCartService = activeCartService;
            _this.type = exports.OrderEntriesSource.ACTIVE_CART;
            return _this;
        }
        ActiveCartOrderEntriesContext.prototype.getEntries = function () {
            return this.activeCartService.getEntries();
        };
        ActiveCartOrderEntriesContext.prototype.add = function (products) {
            this.activeCartService.addEntries(this.mapProductsToOrderEntries(products));
            return this.activeCartService.getActiveCartId();
        };
        ActiveCartOrderEntriesContext.prototype.mapProductsToOrderEntries = function (products) {
            return products.map(function (product) { return ({
                product: { code: product.productCode },
                quantity: product.quantity,
            }); });
        };
        return ActiveCartOrderEntriesContext;
    }(CartOrderEntriesContext));
    ActiveCartOrderEntriesContext.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ActiveCartOrderEntriesContext, deps: [{ token: i1__namespace$5.ActionsSubject }, { token: i1__namespace.ActiveCartService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ActiveCartOrderEntriesContext.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ActiveCartOrderEntriesContext, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ActiveCartOrderEntriesContext, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace$5.ActionsSubject }, { type: i1__namespace.ActiveCartService }]; } });

    var CartTotalsComponent = /** @class */ (function () {
        function CartTotalsComponent(activeCartService, router) {
            this.activeCartService = activeCartService;
            this.router = router;
            this.cartValidationInProgress = false;
            this.subscription = new rxjs.Subscription();
        }
        CartTotalsComponent.prototype.ngOnInit = function () {
            var _this = this;
            var _a;
            this.cart$ = this.activeCartService.getActive();
            this.entries$ = this.activeCartService
                .getEntries()
                .pipe(operators.filter(function (entries) { return entries.length > 0; }));
            this.subscription.add((_a = this.router) === null || _a === void 0 ? void 0 : _a.events.subscribe(function (event) {
                if (event instanceof i1$1.NavigationEnd ||
                    event instanceof i1$1.NavigationCancel) {
                    _this.cartValidationInProgress = false;
                }
            }));
        };
        CartTotalsComponent.prototype.ngOnDestroy = function () {
            this.subscription.unsubscribe();
        };
        CartTotalsComponent.prototype.disableButtonWhileNavigation = function () {
            this.cartValidationInProgress = true;
        };
        return CartTotalsComponent;
    }());
    CartTotalsComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartTotalsComponent, deps: [{ token: i1__namespace.ActiveCartService }, { token: i1__namespace$1.Router }], target: i0__namespace.ɵɵFactoryTarget.Component });
    CartTotalsComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: CartTotalsComponent, selector: "cx-cart-totals", ngImport: i0__namespace, template: "<ng-container *ngIf=\"cart$ | async as cart\">\n  <ng-container *ngIf=\"entries$ | async as entries\">\n    <cx-order-summary [cart]=\"cart\"></cx-order-summary>\n    <ng-container *cxFeatureLevel=\"'!4.2'\">\n      <button\n        [routerLink]=\"{ cxRoute: 'checkout' } | cxUrl\"\n        *ngIf=\"entries.length\"\n        class=\"btn btn-primary btn-block\"\n        type=\"button\"\n      >\n        {{ 'cartDetails.proceedToCheckout' | cxTranslate }}\n      </button>\n    </ng-container>\n\n    <ng-container *cxFeatureLevel=\"'4.2'\">\n      <cx-progress-button\n        *ngIf=\"entries.length\"\n        [routerLink]=\"{ cxRoute: 'checkout' } | cxUrl\"\n        [loading]=\"cartValidationInProgress\"\n        [disabled]=\"cartValidationInProgress\"\n        [class]=\"'btn btn-primary btn-block'\"\n        (clikEvent)=\"disableButtonWhileNavigation()\"\n      >\n        {{\n          (!cartValidationInProgress ? 'cartDetails.proceedToCheckout' : '')\n            | cxTranslate\n        }}\n      </cx-progress-button>\n    </ng-container>\n  </ng-container>\n</ng-container>\n", components: [{ type: OrderSummaryComponent, selector: "cx-order-summary", inputs: ["cart"] }, { type: ProgressButtonComponent, selector: "cx-progress-button", inputs: ["ariaLabel", "class", "disabled", "loading"], outputs: ["clikEvent"] }], directives: [{ type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i1__namespace.FeatureLevelDirective, selector: "[cxFeatureLevel]", inputs: ["cxFeatureLevel"] }, { type: i1__namespace$1.RouterLink, selector: ":not(a):not(area)[routerLink]", inputs: ["routerLink", "queryParams", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange", "replaceUrl", "state", "relativeTo"] }], pipes: { "async": i3__namespace.AsyncPipe, "cxUrl": i1__namespace.UrlPipe, "cxTranslate": i1__namespace.TranslatePipe }, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartTotalsComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-cart-totals',
                        templateUrl: './cart-totals.component.html',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace.ActiveCartService }, { type: i1__namespace$1.Router }]; } });

    var CartTotalsModule = /** @class */ (function () {
        function CartTotalsModule() {
        }
        return CartTotalsModule;
    }());
    CartTotalsModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartTotalsModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    CartTotalsModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartTotalsModule, declarations: [CartTotalsComponent], imports: [i3.CommonModule,
            i1$1.RouterModule,
            i1.UrlModule,
            CartSharedModule,
            i1.I18nModule,
            CartCouponModule,
            i1.FeaturesConfigModule,
            ProgressButtonModule], exports: [CartTotalsComponent] });
    CartTotalsModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartTotalsModule, providers: [
            i1.provideDefaultConfig({
                cmsComponents: {
                    CartTotalsComponent: {
                        component: CartTotalsComponent,
                    },
                },
            }),
        ], imports: [[
                i3.CommonModule,
                i1$1.RouterModule,
                i1.UrlModule,
                CartSharedModule,
                i1.I18nModule,
                CartCouponModule,
                i1.FeaturesConfigModule,
                ProgressButtonModule,
            ]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartTotalsModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [
                            i3.CommonModule,
                            i1$1.RouterModule,
                            i1.UrlModule,
                            CartSharedModule,
                            i1.I18nModule,
                            CartCouponModule,
                            i1.FeaturesConfigModule,
                            ProgressButtonModule,
                        ],
                        providers: [
                            i1.provideDefaultConfig({
                                cmsComponents: {
                                    CartTotalsComponent: {
                                        component: CartTotalsComponent,
                                    },
                                },
                            }),
                        ],
                        declarations: [CartTotalsComponent],
                        exports: [CartTotalsComponent],
                    }]
            }] });

    var PAGE_LAYOUT_HANDLER = new i0.InjectionToken('PageLayoutHandler');

    var PageLayoutService = /** @class */ (function () {
        function PageLayoutService(cms, config, breakpointService, handlers) {
            this.cms = cms;
            this.config = config;
            this.breakpointService = breakpointService;
            this.handlers = handlers;
            // Prints warn messages for missing layout configs.
            // The warnings are only printed once per config
            // to not pollute the console log.
            this.warnLogMessages = {};
            this.logSlots = {};
        }
        PageLayoutService.prototype.getSlots = function (section) {
            var _this = this;
            return rxjs.combineLatest([this.page$, this.breakpointService.breakpoint$]).pipe(operators.map(function (_a) {
                var _b = __read(_a, 2), page = _b[0], breakpoint = _b[1];
                var pageTemplate = page.template;
                var slots = _this.resolveSlots(page, section, breakpoint);
                return { slots: slots, pageTemplate: pageTemplate, breakpoint: breakpoint };
            }), operators.switchMap(function (_a) {
                var e_1, _b;
                var slots = _a.slots, pageTemplate = _a.pageTemplate, breakpoint = _a.breakpoint;
                var result = rxjs.of(slots);
                try {
                    for (var _c = __values(_this.handlers || []), _d = _c.next(); !_d.done; _d = _c.next()) {
                        var handler = _d.value;
                        result = handler.handle(result, pageTemplate, section, breakpoint);
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                return result;
            }), operators.distinctUntilChanged(function (a, b) {
                if (a.length !== b.length) {
                    return false;
                }
                for (var i = 0; i < a.length; i++) {
                    if (a[i] !== b[i]) {
                        return false;
                    }
                }
                return true;
            }));
        };
        /**
         * Returns an observable with the last page slot above-the-fold
         * for the given pageTemplate / breakpoint.
         *
         * The page fold is configurable in the `LayoutConfig` for each page layout.
         */
        PageLayoutService.prototype.getPageFoldSlot = function (pageTemplate) {
            var _this = this;
            return this.breakpointService.breakpoint$.pipe(operators.map(function (breakpoint) {
                if (!_this.config.layoutSlots) {
                    // no layout config available
                    return null;
                }
                var pageTemplateConfig = _this.config.layoutSlots[pageTemplate];
                var config = _this.getResponsiveSlotConfig(pageTemplateConfig, 'pageFold', breakpoint);
                return config ? config.pageFold : null;
            }));
        };
        PageLayoutService.prototype.resolveSlots = function (page, section, breakpoint) {
            var config = this.getSlotConfig(page.template, 'slots', section, breakpoint);
            if (config && config.slots) {
                var pageSlots_1 = Object.keys(page.slots);
                return config.slots.filter(function (slot) { return pageSlots_1.includes(slot); });
            }
            else if (!section) {
                this.logMissingLayoutConfig(page);
                return Object.keys(page.slots);
            }
            else {
                this.logMissingLayoutConfig(page, section);
                return [];
            }
        };
        Object.defineProperty(PageLayoutService.prototype, "page$", {
            get: function () {
                return this.cms.getCurrentPage().pipe(operators.filter(function (page) { return !!page; }));
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(PageLayoutService.prototype, "templateName$", {
            get: function () {
                return this.page$.pipe(operators.filter(function (page) { return !!page.template; }), operators.map(function (page) { return page.template; }));
            },
            enumerable: false,
            configurable: true
        });
        /**
         * load slots from the layout configuration. The breakpoint is used
         * to load a specific configuration for the given breakpoint. If there's
         * no configuration available for the given breakpoint the default slot
         * configuration is returned.
         */
        PageLayoutService.prototype.getSlotConfig = function (templateUid, configAttribute, section, breakpoint) {
            if (!this.config.layoutSlots) {
                return null;
            }
            var pageTemplateConfig = this.config.layoutSlots[templateUid];
            if (section) {
                return this.getSlotConfigForSection(templateUid, configAttribute, section, breakpoint);
            }
            if (pageTemplateConfig) {
                return this.getResponsiveSlotConfig(pageTemplateConfig, configAttribute, breakpoint);
            }
        };
        PageLayoutService.prototype.getSlotConfigForSection = function (templateUid, configAttribute, section, breakpoint) {
            var pageTemplateConfig = this.config.layoutSlots[templateUid];
            if (!pageTemplateConfig) {
                return null;
            }
            // if there's no section config on the page layout
            // we fall back to the global section config
            var sectionConfig = pageTemplateConfig[section]
                ? pageTemplateConfig[section]
                : this.config.layoutSlots[section];
            if (!sectionConfig) {
                return null;
            }
            var responsiveConfig = this.getResponsiveSlotConfig(sectionConfig, configAttribute, breakpoint);
            if (responsiveConfig.hasOwnProperty(configAttribute)) {
                return responsiveConfig;
            }
            else if (pageTemplateConfig[section].hasOwnProperty(configAttribute)) {
                return pageTemplateConfig[section];
            }
            else if (this.config.layoutSlots[section]) {
                return this.config.layoutSlots[section];
            }
        };
        /**
         * Returns a list of slots for a breakpoint specific configuration
         * If there's no specific configuration for the breakpoint,
         * the closest available configuration will be returned.
         */
        PageLayoutService.prototype.getResponsiveSlotConfig = function (layoutSlotConfig, configAttribute, breakpoint) {
            var e_2, _a;
            var slotConfig = layoutSlotConfig;
            // fallback to default slot config
            if (!layoutSlotConfig || !breakpoint) {
                return slotConfig;
            }
            // we have a config for the specific breakpoint
            if (layoutSlotConfig[breakpoint] &&
                layoutSlotConfig[breakpoint].hasOwnProperty(configAttribute)) {
                return layoutSlotConfig[breakpoint];
            }
            // find closest config
            var all = this.breakpointService.breakpoints;
            try {
                for (var _b = __values(all.slice(0, all.indexOf(breakpoint))), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var br = _c.value;
                    if (layoutSlotConfig[br] &&
                        layoutSlotConfig[br].hasOwnProperty(configAttribute)) {
                        slotConfig = layoutSlotConfig[br];
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_2) throw e_2.error; }
            }
            return slotConfig;
        };
        /**
         * In order to help developers, we print some detailed log information in
         * case there's no layout configuration available for the given page template
         * or section. Additionally, the slot positions are printed in the console
         * in a format that can be copied / paste to the configuration.
         */
        PageLayoutService.prototype.logMissingLayoutConfig = function (page, section) {
            if (!i0.isDevMode()) {
                return;
            }
            if (!this.logSlots[page.template]) {
                // the info log is not printed in production
                // eslint-disable-next-line no-console
                console.info("Available CMS page slots: '" + Object.keys(page.slots).join("','") + "'");
                this.logSlots[page.template] = true;
            }
            var cacheKey = section || page.template;
            if (!this.warnLogMessages[cacheKey]) {
                console.warn("No layout config found for " + cacheKey + ", you can configure a 'LayoutConfig' to control the rendering of page slots.");
                this.warnLogMessages[cacheKey] = true;
            }
        };
        return PageLayoutService;
    }());
    PageLayoutService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PageLayoutService, deps: [{ token: i1__namespace.CmsService }, { token: LayoutConfig }, { token: BreakpointService }, { token: PAGE_LAYOUT_HANDLER, optional: true }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    PageLayoutService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PageLayoutService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PageLayoutService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () {
            return [{ type: i1__namespace.CmsService }, { type: LayoutConfig }, { type: BreakpointService }, { type: undefined, decorators: [{
                            type: i0.Optional
                        }, {
                            type: i0.Inject,
                            args: [PAGE_LAYOUT_HANDLER]
                        }] }];
        } });

    /**
     * Service responsible for resolving cms config based feature modules.
     */
    var CmsFeaturesService = /** @class */ (function () {
        function CmsFeaturesService(configInitializer, featureModules) {
            this.configInitializer = configInitializer;
            this.featureModules = featureModules;
            // maps componentType to feature
            this.componentFeatureMap = new Map();
            /*
             * Contains either FeatureInstance or FeatureInstance resolver for not yet
             * resolved feature modules
             */
            this.featureInstances = new Map();
            this.initFeatureMap();
        }
        CmsFeaturesService.prototype.initFeatureMap = function () {
            var _this = this;
            this.configInitializer
                .getStable('featureModules')
                .subscribe(function (config) {
                var e_1, _d, e_2, _e;
                var _a, _b;
                _this.featureModulesConfig = (_a = config.featureModules) !== null && _a !== void 0 ? _a : {};
                try {
                    for (var _f = __values(Object.entries(_this.featureModulesConfig)), _g = _f.next(); !_g.done; _g = _f.next()) {
                        var _h = __read(_g.value, 2), featureName = _h[0], featureConfig = _h[1];
                        if (typeof featureConfig !== 'string' &&
                            (featureConfig === null || featureConfig === void 0 ? void 0 : featureConfig.module) &&
                            ((_b = featureConfig === null || featureConfig === void 0 ? void 0 : featureConfig.cmsComponents) === null || _b === void 0 ? void 0 : _b.length)) {
                            try {
                                for (var _j = (e_2 = void 0, __values(featureConfig.cmsComponents)), _k = _j.next(); !_k.done; _k = _j.next()) {
                                    var component = _k.value;
                                    _this.componentFeatureMap.set(component, featureName);
                                }
                            }
                            catch (e_2_1) { e_2 = { error: e_2_1 }; }
                            finally {
                                try {
                                    if (_k && !_k.done && (_e = _j.return)) _e.call(_j);
                                }
                                finally { if (e_2) throw e_2.error; }
                            }
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_g && !_g.done && (_d = _f.return)) _d.call(_f);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            });
        };
        /**
         * Check if there is feature module configuration that covers specified
         * component type
         */
        CmsFeaturesService.prototype.hasFeatureFor = function (componentType) {
            return this.componentFeatureMap.has(componentType);
        };
        /**
         * Return full CmsComponent mapping defined in feature module
         */
        CmsFeaturesService.prototype.getCmsMapping = function (componentType) {
            var feature = this.componentFeatureMap.get(componentType);
            if (!feature) {
                return rxjs.of(undefined);
            }
            return this.resolveFeatureInstance(feature).pipe(operators.map(function (featureInstance) { var _a; return (_a = featureInstance.componentsMappings) === null || _a === void 0 ? void 0 : _a[componentType]; }));
        };
        /**
         * Resolves feature module for provided component type
         *
         * @param componentType
         */
        CmsFeaturesService.prototype.getModule = function (componentType) {
            var _a;
            var feature = this.componentFeatureMap.get(componentType);
            if (!feature) {
                return undefined;
            }
            var module;
            // we are returning injectors only for already resolved features
            (_a = this.featureInstances
                .get(feature)) === null || _a === void 0 ? void 0 : _a.subscribe(function (featureInstance) {
                module = featureInstance.moduleRef;
            }).unsubscribe();
            return module;
        };
        /**
         * Resolve feature based on feature name, if feature was not yet resolved
         *
         * It will first resolve all module dependencies if defined
         */
        CmsFeaturesService.prototype.resolveFeatureInstance = function (featureName) {
            var _this = this;
            return rxjs.defer(function () {
                if (!_this.featureInstances.has(featureName)) {
                    _this.featureInstances.set(featureName, _this.featureModules.resolveFeature(featureName).pipe(operators.map(function (moduleRef) { return _this.createFeatureInstance(moduleRef, featureName); }), operators.shareReplay()));
                }
                return _this.featureInstances.get(featureName);
            });
        };
        /**
         * Create feature instance from feature's moduleRef
         */
        CmsFeaturesService.prototype.createFeatureInstance = function (moduleRef, feature) {
            var e_3, _d;
            var _a, _b, _c;
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            var featureConfig = this.featureModulesConfig[feature];
            var featureInstance = {
                moduleRef: moduleRef,
                componentsMappings: {},
            };
            // resolve configuration for feature module
            var resolvedConfiguration = this.resolveFeatureConfiguration(moduleRef.injector);
            try {
                // extract cms components configuration from feature config
                for (var _e = __values((_a = featureConfig.cmsComponents) !== null && _a !== void 0 ? _a : []), _f = _e.next(); !_f.done; _f = _e.next()) {
                    var componentType = _f.value;
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    featureInstance.componentsMappings[componentType] =
                        (_c = (_b = resolvedConfiguration.cmsComponents) === null || _b === void 0 ? void 0 : _b[componentType]) !== null && _c !== void 0 ? _c : {};
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_f && !_f.done && (_d = _e.return)) _d.call(_e);
                }
                finally { if (e_3) throw e_3.error; }
            }
            return featureInstance;
        };
        /**
         * Returns configuration provided in feature module
         */
        CmsFeaturesService.prototype.resolveFeatureConfiguration = function (featureInjector) {
            // get config chunks from feature lib
            var featureConfigChunks = featureInjector.get(i1.ConfigChunk, [], i0.InjectFlags.Self);
            // get default config chunks from feature lib
            var featureDefaultConfigChunks = featureInjector.get(i1.DefaultConfigChunk, [], i0.InjectFlags.Self);
            return i1.deepMerge.apply(void 0, __spreadArray(__spreadArray([{}], __read((featureDefaultConfigChunks !== null && featureDefaultConfigChunks !== void 0 ? featureDefaultConfigChunks : []))), __read((featureConfigChunks !== null && featureConfigChunks !== void 0 ? featureConfigChunks : []))));
        };
        return CmsFeaturesService;
    }());
    CmsFeaturesService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CmsFeaturesService, deps: [{ token: i1__namespace.ConfigInitializerService }, { token: i1__namespace.FeatureModulesService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    CmsFeaturesService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CmsFeaturesService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CmsFeaturesService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace.ConfigInitializerService }, { type: i1__namespace.FeatureModulesService }]; } });

    /**
     * Service with logic related to resolving component from cms mapping
     */
    var CmsComponentsService = /** @class */ (function () {
        function CmsComponentsService(config, platformId, featureModules, configInitializer) {
            var _this = this;
            this.config = config;
            this.platformId = platformId;
            this.featureModules = featureModules;
            this.configInitializer = configInitializer;
            // Component mappings that were identified as missing
            this.missingComponents = [];
            // Already resolved mappings
            this.mappings = {};
            // Contains already initialized resolvers for specified component typez
            this.mappingResolvers = new Map();
            this.configInitializer
                .getStable('cmsComponents')
                .subscribe(function (cmsConfig) {
                // we want to grab cms configuration available at config initialization phase
                // as lazy-loaded modules can affect global configuration resulting in
                // non-deterministic state
                _this.staticCmsConfig = Object.assign({}, cmsConfig.cmsComponents);
            });
        }
        /**
         * Should be called to make sure all component mappings are determined,
         * especially lazy loaded ones.
         *
         * It's recommended way to make sure all other methods of CmsComponentService
         * will be able to work synchronously for asked component types and avoid risk
         * of potential errors that could be thrown otherwise.
         */
        CmsComponentsService.prototype.determineMappings = function (componentTypes) {
            var _this = this;
            return rxjs.defer(function () {
                var e_1, _d;
                var _a, _b;
                // we use defer, to be sure the logic below used to compose final observable
                // will be executed at subscription time (with up to date state at the time,
                // when it will be needed)
                var featureResolvers = [];
                try {
                    for (var componentTypes_1 = __values(componentTypes), componentTypes_1_1 = componentTypes_1.next(); !componentTypes_1_1.done; componentTypes_1_1 = componentTypes_1.next()) {
                        var componentType = componentTypes_1_1.value;
                        if (!_this.mappings[componentType]) {
                            var staticConfig = (_b = ((_a = _this.staticCmsConfig) !== null && _a !== void 0 ? _a : _this.config.cmsComponents)) === null || _b === void 0 ? void 0 : _b[componentType];
                            // check if this component type is managed by feature module
                            if (_this.featureModules.hasFeatureFor(componentType)) {
                                featureResolvers.push(
                                // we delegate populating this.mappings to feature resolver
                                _this.getFeatureMappingResolver(componentType, staticConfig));
                            }
                            else {
                                // simply use only static config
                                _this.mappings[componentType] = staticConfig;
                            }
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (componentTypes_1_1 && !componentTypes_1_1.done && (_d = componentTypes_1.return)) _d.call(componentTypes_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                if (featureResolvers.length) {
                    return rxjs.forkJoin(featureResolvers).pipe(operators.mapTo(componentTypes));
                }
                else {
                    return rxjs.of(componentTypes);
                }
            });
        };
        CmsComponentsService.prototype.getFeatureMappingResolver = function (componentType, staticConfig) {
            var _this = this;
            if (!this.mappingResolvers.has(componentType)) {
                var mappingResolver$ = this.featureModules
                    .getCmsMapping(componentType)
                    .pipe(operators.tap(function (featureComponentMapping) {
                    // We treat cms mapping configuration from a feature as a default,
                    // that can be overridden by app/static configuration
                    _this.mappings[componentType] = i1.deepMerge({}, featureComponentMapping, staticConfig);
                    _this.mappingResolvers.delete(componentType);
                }), operators.share());
                this.mappingResolvers.set(componentType, mappingResolver$);
            }
            return this.mappingResolvers.get(componentType);
        };
        /**
         * Returns the feature module for a cms component.
         * It will only work for cms components provided by feature modules.
         *
         * @param componentType
         */
        CmsComponentsService.prototype.getModule = function (componentType) {
            return (this.featureModules.hasFeatureFor(componentType) &&
                this.featureModules.getModule(componentType));
        };
        /**
         * Return collection of component mapping configuration for specified list of
         * component types.
         *
         * If component mapping can't be determined synchronously, for example, lazy
         * loaded one, it will throw an error.
         *
         * To make sure component mapping is available, determineMappings()
         * should be called and completed first.
         */
        CmsComponentsService.prototype.getMapping = function (componentType) {
            var _a, _b, _c;
            var componentConfig = (_a = this.mappings[componentType]) !== null && _a !== void 0 ? _a : (_c = ((_b = this.staticCmsConfig) !== null && _b !== void 0 ? _b : this.config.cmsComponents)) === null || _c === void 0 ? void 0 : _c[componentType];
            if (i0.isDevMode() && !componentConfig) {
                if (!this.missingComponents.includes(componentType)) {
                    this.missingComponents.push(componentType);
                    console.warn("No component implementation found for the CMS component type '" + componentType + "'.\n", "Make sure you implement a component and register it in the mapper.");
                }
            }
            return componentConfig;
        };
        /**
         * Checks, if component should be rendered as some components
         * could be disabled for server side renderings
         */
        CmsComponentsService.prototype.shouldRender = function (componentType) {
            var _a;
            var isSSR = i3.isPlatformServer(this.platformId);
            return !(isSSR && ((_a = this.getMapping(componentType)) === null || _a === void 0 ? void 0 : _a.disableSSR));
        };
        /**
         * Return DeferLoadingStrategy for component type.
         */
        CmsComponentsService.prototype.getDeferLoadingStrategy = function (componentType) {
            var _a, _b, _c;
            return (_c = (_b = ((_a = this.staticCmsConfig) !== null && _a !== void 0 ? _a : this.config.cmsComponents)) === null || _b === void 0 ? void 0 : _b[componentType]) === null || _c === void 0 ? void 0 : _c.deferLoading;
        };
        /**
         * Get cms driven child routes for components
         */
        CmsComponentsService.prototype.getChildRoutes = function (componentTypes) {
            var e_2, _d;
            var _a, _b;
            var configs = [];
            try {
                for (var componentTypes_2 = __values(componentTypes), componentTypes_2_1 = componentTypes_2.next(); !componentTypes_2_1.done; componentTypes_2_1 = componentTypes_2.next()) {
                    var componentType = componentTypes_2_1.value;
                    if (this.shouldRender(componentType)) {
                        configs.push((_b = (_a = this.getMapping(componentType)) === null || _a === void 0 ? void 0 : _a.childRoutes) !== null && _b !== void 0 ? _b : []);
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (componentTypes_2_1 && !componentTypes_2_1.done && (_d = componentTypes_2.return)) _d.call(componentTypes_2);
                }
                finally { if (e_2) throw e_2.error; }
            }
            return this.standardizeChildRoutes(configs);
        };
        /**
         * Returns the static data for the component type.
         */
        CmsComponentsService.prototype.getStaticData = function (componentType) {
            var _a;
            return (_a = this.getMapping(componentType)) === null || _a === void 0 ? void 0 : _a.data;
        };
        /**
         * Standardizes the format of `childRoutes` config.
         *
         * Some `childRoutes` configs are simple arrays of Routes (without the notion of the parent route).
         * But some configs can be an object with children routes and their parent defined in separate property.
         */
        CmsComponentsService.prototype.standardizeChildRoutes = function (childRoutesConfigs) {
            var result = { children: [] };
            (childRoutesConfigs || []).forEach(function (config) {
                var _d, _e;
                if (Array.isArray(config)) {
                    (_d = result.children).push.apply(_d, __spreadArray([], __read(config)));
                }
                else {
                    (_e = result.children).push.apply(_e, __spreadArray([], __read((config.children || []))));
                    if (config.parent) {
                        result.parent = config.parent;
                    }
                }
            });
            return result;
        };
        /**
         * Get cms driven guards for components
         */
        CmsComponentsService.prototype.getGuards = function (componentTypes) {
            var e_3, _d;
            var _a, _b;
            var guards = new Set();
            try {
                for (var componentTypes_3 = __values(componentTypes), componentTypes_3_1 = componentTypes_3.next(); !componentTypes_3_1.done; componentTypes_3_1 = componentTypes_3.next()) {
                    var componentType = componentTypes_3_1.value;
                    (_b = (_a = this.getMapping(componentType)) === null || _a === void 0 ? void 0 : _a.guards) === null || _b === void 0 ? void 0 : _b.forEach(function (guard) { return guards.add(guard); });
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (componentTypes_3_1 && !componentTypes_3_1.done && (_d = componentTypes_3.return)) _d.call(componentTypes_3);
                }
                finally { if (e_3) throw e_3.error; }
            }
            return Array.from(guards);
        };
        /**
         * Get i18n keys associated with components
         */
        CmsComponentsService.prototype.getI18nKeys = function (componentTypes) {
            var e_4, _d;
            var _a, _b;
            var i18nKeys = new Set();
            try {
                for (var componentTypes_4 = __values(componentTypes), componentTypes_4_1 = componentTypes_4.next(); !componentTypes_4_1.done; componentTypes_4_1 = componentTypes_4.next()) {
                    var componentType = componentTypes_4_1.value;
                    if (this.shouldRender(componentType)) {
                        (_b = (_a = this.getMapping(componentType)) === null || _a === void 0 ? void 0 : _a.i18nKeys) === null || _b === void 0 ? void 0 : _b.forEach(function (key) { return i18nKeys.add(key); });
                    }
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (componentTypes_4_1 && !componentTypes_4_1.done && (_d = componentTypes_4.return)) _d.call(componentTypes_4);
                }
                finally { if (e_4) throw e_4.error; }
            }
            return Array.from(i18nKeys);
        };
        return CmsComponentsService;
    }());
    CmsComponentsService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CmsComponentsService, deps: [{ token: i1__namespace.CmsConfig }, { token: i0.PLATFORM_ID }, { token: CmsFeaturesService }, { token: i1__namespace.ConfigInitializerService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    CmsComponentsService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CmsComponentsService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CmsComponentsService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () {
            return [{ type: i1__namespace.CmsConfig }, { type: Object, decorators: [{
                            type: i0.Inject,
                            args: [i0.PLATFORM_ID]
                        }] }, { type: CmsFeaturesService }, { type: i1__namespace.ConfigInitializerService }];
        } });

    var PageSlotService = /** @class */ (function () {
        function PageSlotService(cmsComponentsService, platformId, document) {
            this.cmsComponentsService = cmsComponentsService;
            this.platformId = platformId;
            this.document = document;
            this.resolvePrerenderedSlots();
        }
        /**
         * Finds all slots visible in the SSR pre-rendered DOM
         */
        PageSlotService.prototype.resolvePrerenderedSlots = function () {
            var _this = this;
            if (i3.isPlatformBrowser(this.platformId)) {
                this.prerenderedSlots = Array.from(this.document.querySelectorAll('cx-page-slot'))
                    .filter(function (el) { return el.getBoundingClientRect().top <
                    _this.document.documentElement.clientHeight; })
                    .map(function (el) { return el.getAttribute('position'); });
            }
        };
        /**
         * Indicates if certain slot should be rendered instantly.
         *
         * It's especially useful when transitioning from SSR to CSR application,
         * where we don't want to apply deferring logic to slots that are visible
         * to avoid unnecessary flickering.
         */
        PageSlotService.prototype.shouldNotDefer = function (slot) {
            var _a;
            if ((_a = this.prerenderedSlots) === null || _a === void 0 ? void 0 : _a.includes(slot)) {
                this.prerenderedSlots.splice(this.prerenderedSlots.indexOf(slot), 1);
                return true;
            }
            return false;
        };
        /**
         * Returns the defer options for the given component. If the wrapping
         * page slot is prerendered, we would ignore the defer options altogether.
         */
        PageSlotService.prototype.getComponentDeferOptions = function (slot, componentType) {
            if (this.shouldNotDefer(slot)) {
                return { deferLoading: i1.DeferLoadingStrategy.INSTANT };
            }
            var deferLoading = this.cmsComponentsService.getDeferLoadingStrategy(componentType);
            return { deferLoading: deferLoading };
        };
        return PageSlotService;
    }());
    PageSlotService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PageSlotService, deps: [{ token: CmsComponentsService }, { token: i0.PLATFORM_ID }, { token: i3.DOCUMENT }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    PageSlotService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PageSlotService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PageSlotService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () {
            return [{ type: CmsComponentsService }, { type: undefined, decorators: [{
                            type: i0.Inject,
                            args: [i0.PLATFORM_ID]
                        }] }, { type: undefined, decorators: [{
                            type: i0.Inject,
                            args: [i3.DOCUMENT]
                        }] }];
        } });

    /**
     * Lifecycle events for the creation and removal of CMS components.
     *
     * Triggers when the component is added or removed from the DOM, using
     * sub event `ComponentCreateEvent` and `ComponentDestroyEvent`.
     */
    var ComponentEvent = /** @class */ (function (_super) {
        __extends(ComponentEvent, _super);
        function ComponentEvent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return ComponentEvent;
    }(i1.CxEvent));
    /**
     * Indicates that the component is added to the DOM.
     */
    var ComponentCreateEvent = /** @class */ (function (_super) {
        __extends(ComponentCreateEvent, _super);
        function ComponentCreateEvent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return ComponentCreateEvent;
    }(ComponentEvent));
    /**
     * Event's type
     */
    ComponentCreateEvent.type = 'ComponentCreate';
    /**
     * Indicates that the component is removed from the DOM.
     */
    var ComponentDestroyEvent = /** @class */ (function (_super) {
        __extends(ComponentDestroyEvent, _super);
        function ComponentDestroyEvent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return ComponentDestroyEvent;
    }(ComponentEvent));
    /**
     * Event's type
     */
    ComponentDestroyEvent.type = 'ComponentDestroy';

    /**
     * ComponentHandler implementations can be used for instantiating and launching
     * different types of CMS mapped components
     */
    var ComponentHandler = /** @class */ (function () {
        function ComponentHandler() {
        }
        return ComponentHandler;
    }());

    /**
     * Responsible for obtaining component handler for specified component mapping
     */
    var ComponentHandlerService = /** @class */ (function () {
        function ComponentHandlerService(handlers) {
            this.handlers = handlers;
            this.invalidMappings = new Set();
        }
        /**
         * Get best matching component handler
         *
         * @param componentMapping
         */
        ComponentHandlerService.prototype.resolve = function (componentMapping) {
            var handler = i1.resolveApplicable(this.handlers, [componentMapping]);
            if (i0.isDevMode() && !handler) {
                if (!this.invalidMappings.has(componentMapping)) {
                    this.invalidMappings.add(componentMapping);
                    console.warn("Can't resolve handler for component mapping: ", componentMapping);
                }
            }
            return handler;
        };
        /**
         * Get launcher for specified component mapping
         *
         * @param componentMapping
         * @param viewContainerRef
         * @param elementInjector
         */
        ComponentHandlerService.prototype.getLauncher = function (componentMapping, viewContainerRef, elementInjector, module) {
            var _a;
            return (_a = this.resolve(componentMapping)) === null || _a === void 0 ? void 0 : _a.launcher(componentMapping, viewContainerRef, elementInjector, module);
        };
        return ComponentHandlerService;
    }());
    ComponentHandlerService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ComponentHandlerService, deps: [{ token: ComponentHandler, optional: true }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ComponentHandlerService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ComponentHandlerService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ComponentHandlerService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () {
            return [{ type: undefined, decorators: [{
                            type: i0.Optional
                        }, {
                            type: i0.Inject,
                            args: [ComponentHandler]
                        }] }];
        } });

    /**
     * Provides data for `CmsComponentData`. This is used while component is injected
     * dynamically, so that the component implementation can access the data.
     *
     * The data is resolved from dynamic data (CMS api) as well as static configured data.
     */
    var ComponentDataProvider = /** @class */ (function () {
        function ComponentDataProvider(componentsService, cmsService) {
            this.componentsService = componentsService;
            this.cmsService = cmsService;
        }
        /**
         * Return the component data for a component given by the `uid`.
         *
         * If the `type` is provided, static component data (if available) is
         * merged into the component data. The static data is complemented and
         * overridden with data retrieved from the cms service.
         */
        ComponentDataProvider.prototype.get = function (uid, type) {
            var _this = this;
            return rxjs.defer(function () {
                var staticComponentData;
                if (type) {
                    staticComponentData = _this.componentsService.getStaticData(type);
                }
                if (uid) {
                    if (staticComponentData) {
                        return _this.cmsService.getComponentData(uid).pipe(operators.map(function (data) { return (Object.assign(Object.assign({}, staticComponentData), data)); }), operators.startWith(staticComponentData));
                    }
                    else {
                        return _this.cmsService.getComponentData(uid);
                    }
                }
                else {
                    return staticComponentData ? rxjs.of(staticComponentData) : rxjs.EMPTY;
                }
            });
        };
        return ComponentDataProvider;
    }());
    ComponentDataProvider.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ComponentDataProvider, deps: [{ token: CmsComponentsService }, { token: i1__namespace.CmsService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ComponentDataProvider.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ComponentDataProvider, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ComponentDataProvider, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: CmsComponentsService }, { type: i1__namespace.CmsService }]; } });

    /**
     * Used to prepare injector for CMS components.
     *
     * Injector will take into account configured providers and provides CmsComponentData
     * for specified component's uid
     */
    var CmsInjectorService = /** @class */ (function () {
        function CmsInjectorService(cmsComponentsService, injector) {
            this.cmsComponentsService = cmsComponentsService;
            this.injector = injector;
        }
        CmsInjectorService.prototype.getInjector = function (type, uid, parentInjector) {
            var _a, _b;
            var configProviders = (_b = (_a = this.cmsComponentsService.getMapping(type)) === null || _a === void 0 ? void 0 : _a.providers) !== null && _b !== void 0 ? _b : [];
            return i0.Injector.create({
                providers: __spreadArray([
                    {
                        provide: CmsComponentData,
                        useFactory: function (dataProvider) { return ({
                            uid: uid,
                            data$: dataProvider.get(uid, type),
                        }); },
                        deps: [ComponentDataProvider],
                    }
                ], __read(configProviders)),
                parent: parentInjector !== null && parentInjector !== void 0 ? parentInjector : this.injector,
            });
        };
        return CmsInjectorService;
    }());
    CmsInjectorService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CmsInjectorService, deps: [{ token: CmsComponentsService }, { token: i0__namespace.Injector }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    CmsInjectorService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CmsInjectorService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CmsInjectorService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: CmsComponentsService }, { type: i0__namespace.Injector }]; } });

    /**
     * Directive used to facilitate instantiation of CMS driven dynamic components
     */
    var ComponentWrapperDirective = /** @class */ (function () {
        function ComponentWrapperDirective(vcr, cmsComponentsService, injector, dynamicAttributeService, renderer, componentHandler, cmsInjector, eventService) {
            this.vcr = vcr;
            this.cmsComponentsService = cmsComponentsService;
            this.injector = injector;
            this.dynamicAttributeService = dynamicAttributeService;
            this.renderer = renderer;
            this.componentHandler = componentHandler;
            this.cmsInjector = cmsInjector;
            this.eventService = eventService;
            this.cxComponentRef = new i0.EventEmitter();
        }
        ComponentWrapperDirective.prototype.ngOnInit = function () {
            var _this = this;
            this.cmsComponentsService
                .determineMappings([this.cxComponentWrapper.flexType])
                .subscribe(function () {
                if (_this.cmsComponentsService.shouldRender(_this.cxComponentWrapper.flexType)) {
                    _this.launchComponent();
                }
            });
        };
        ComponentWrapperDirective.prototype.launchComponent = function () {
            var _this = this;
            var componentMapping = this.cmsComponentsService.getMapping(this.cxComponentWrapper.flexType);
            if (!componentMapping) {
                return;
            }
            this.launcherResource = this.componentHandler
                .getLauncher(componentMapping, this.vcr, this.cmsInjector.getInjector(this.cxComponentWrapper.flexType, this.cxComponentWrapper.uid, this.injector), this.cmsComponentsService.getModule(this.cxComponentWrapper.flexType))
                .pipe(operators.tap(function (_b) {
                var elementRef = _b.elementRef, componentRef = _b.componentRef;
                _this.cmpRef = componentRef;
                _this.cxComponentRef.emit(componentRef);
                _this.dispatchEvent(ComponentCreateEvent, elementRef);
                _this.decorate(elementRef);
                _this.injector.get(i0.ChangeDetectorRef).markForCheck();
            }), operators.finalize(function () { return _this.dispatchEvent(ComponentDestroyEvent); }))
                .subscribe();
        };
        /**
         * Dispatch the component event.
         *
         * The event is dispatched during creation and removal of the component.
         */
        ComponentWrapperDirective.prototype.dispatchEvent = function (event, elementRef) {
            var _a;
            var payload = {
                typeCode: this.cxComponentWrapper.typeCode,
                id: this.cxComponentWrapper.uid,
            };
            if (event === ComponentCreateEvent) {
                payload.host = elementRef === null || elementRef === void 0 ? void 0 : elementRef.nativeElement;
            }
            (_a = this.eventService) === null || _a === void 0 ? void 0 : _a.dispatch(payload, event);
        };
        ComponentWrapperDirective.prototype.decorate = function (elementRef) {
            this.dynamicAttributeService.addAttributesToComponent(elementRef.nativeElement, this.renderer, this.cxComponentWrapper);
        };
        ComponentWrapperDirective.prototype.ngOnDestroy = function () {
            if (this.launcherResource) {
                this.launcherResource.unsubscribe();
            }
        };
        return ComponentWrapperDirective;
    }());
    ComponentWrapperDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ComponentWrapperDirective, deps: [{ token: i0__namespace.ViewContainerRef }, { token: CmsComponentsService }, { token: i0__namespace.Injector }, { token: i1__namespace.DynamicAttributeService }, { token: i0__namespace.Renderer2 }, { token: ComponentHandlerService }, { token: CmsInjectorService }, { token: i1__namespace.EventService, optional: true }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    ComponentWrapperDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.5", type: ComponentWrapperDirective, selector: "[cxComponentWrapper]", inputs: { cxComponentWrapper: "cxComponentWrapper" }, outputs: { cxComponentRef: "cxComponentRef" }, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ComponentWrapperDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        selector: '[cxComponentWrapper]',
                    }]
            }], ctorParameters: function () {
            return [{ type: i0__namespace.ViewContainerRef }, { type: CmsComponentsService }, { type: i0__namespace.Injector }, { type: i1__namespace.DynamicAttributeService }, { type: i0__namespace.Renderer2 }, { type: ComponentHandlerService }, { type: CmsInjectorService }, { type: i1__namespace.EventService, decorators: [{
                            type: i0.Optional
                        }] }];
        }, propDecorators: { cxComponentWrapper: [{
                    type: i0.Input
                }], cxComponentRef: [{
                    type: i0.Output
                }] } });

    /**
     * The `PageSlotComponent` is used to render the CMS page slot and it's components.
     *
     * The Page slot host element will be supplemented with css classes so that the layout
     * can be fully controlled by customers:
     * - The page slot _position_ is added as a css class by default.
     * - The `cx-pending` is added for as long as the slot hasn't start loading.
     * - The `page-fold` style class is added for the page slot which is configured as the page fold.
     */
    var PageSlotComponent = /** @class */ (function () {
        function PageSlotComponent(cmsService, dynamicAttributeService, renderer, elementRef, cd, pageSlotService) {
            var _this = this;
            this.cmsService = cmsService;
            this.dynamicAttributeService = dynamicAttributeService;
            this.renderer = renderer;
            this.elementRef = elementRef;
            this.cd = cd;
            this.pageSlotService = pageSlotService;
            /**
             * Indicates that the page slot is the last page slot above the fold.
             */
            this.isPageFold = false;
            /**
             * Indicates that the components of the page slot haven't been loaded as long
             * as the isPending state is true.
             */
            this.isPending = true;
            /**
             * Indicates that the page slot doesn't contain any components. This is no
             * longer used in spartacus, but kept for backwards compatibility.
             */
            this.hasComponents = false;
            this.position$ = new rxjs.BehaviorSubject(undefined);
            this.slot$ = this.position$.pipe(operators.switchMap(function (position) { return _this.cmsService.getContentSlot(position); }), operators.distinctUntilChanged(this.isDistinct));
            /** Observes the components for the given page slot. */
            this.components$ = this.slot$.pipe(operators.map(function (slot) { var _a; return (_a = slot === null || slot === void 0 ? void 0 : slot.components) !== null && _a !== void 0 ? _a : []; }));
            this.subscription = new rxjs.Subscription();
            /** Keeps track of the pending components that must be loaded for the page slot */
            this.pendingComponentCount = 0;
        }
        Object.defineProperty(PageSlotComponent.prototype, "position", {
            get: function () {
                return this.position$.value;
            },
            /**
             * The position represents the unique key for a page slot on a single page, but can
             * be reused cross pages.
             *
             * The position is used to find the CMS components for the page slot. It is also
             * added as an additional CSS class so that layout can be applied.
             */
            set: function (value) {
                this.position$.next(value);
            },
            enumerable: false,
            configurable: true
        });
        PageSlotComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.subscription.add(this.slot$.pipe(operators.tap(function (slot) { return _this.decorate(slot); })).subscribe(function (value) {
                _this.components = (value === null || value === void 0 ? void 0 : value.components) || [];
                _this.cd.markForCheck();
            }));
        };
        PageSlotComponent.prototype.decorate = function (slot) {
            var _a, _b;
            var cls = this.class || '';
            if (this.lastPosition && cls.indexOf(this.lastPosition) > -1) {
                cls = cls.replace(this.lastPosition, '');
            }
            if (this.position$.value) {
                cls += " " + this.position$.value;
                this.lastPosition = this.position$.value;
            }
            // host bindings
            this.pending = ((_a = slot === null || slot === void 0 ? void 0 : slot.components) === null || _a === void 0 ? void 0 : _a.length) || 0;
            this.hasComponents = ((_b = slot === null || slot === void 0 ? void 0 : slot.components) === null || _b === void 0 ? void 0 : _b.length) > 0;
            if (cls && cls !== this.class) {
                this.class = cls;
            }
            if (slot) {
                this.dynamicAttributeService.addAttributesToSlot(this.elementRef.nativeElement, this.renderer, slot);
            }
        };
        Object.defineProperty(PageSlotComponent.prototype, "pending", {
            get: function () {
                return this.pendingComponentCount;
            },
            /**
             * Sets the pending count for the page slot components. Once all pending components are
             * loaded, the `isPending` flag is updated, so that the associated class can be updated
             */
            set: function (count) {
                this.pendingComponentCount = count;
                this.isPending = this.pendingComponentCount > 0;
            },
            enumerable: false,
            configurable: true
        });
        /*
         * Is triggered when a component is added to the view. This is used to
         * update the pending count
         */
        PageSlotComponent.prototype.isLoaded = function (loadState) {
            if (loadState) {
                this.pending--;
                this.cd.markForCheck();
            }
        };
        /**
         * The `DeferLoadingStrategy` indicates whether the component should be
         * rendered instantly or whether it should be deferred.
         */
        PageSlotComponent.prototype.getComponentDeferOptions = function (componentType) {
            return this.pageSlotService.getComponentDeferOptions(this.position, componentType);
        };
        PageSlotComponent.prototype.isDistinct = function (old, current) {
            var _a;
            return (current.components &&
                ((_a = old.components) === null || _a === void 0 ? void 0 : _a.length) === current.components.length &&
                !old.components.find(function (el, index) { return el.uid !== current.components[index].uid; }));
        };
        PageSlotComponent.prototype.ngOnDestroy = function () {
            var _a;
            (_a = this.subscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();
        };
        return PageSlotComponent;
    }());
    PageSlotComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PageSlotComponent, deps: [{ token: i1__namespace.CmsService }, { token: i1__namespace.DynamicAttributeService }, { token: i0__namespace.Renderer2 }, { token: i0__namespace.ElementRef }, { token: i0__namespace.ChangeDetectorRef }, { token: PageSlotService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    PageSlotComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: PageSlotComponent, selector: "cx-page-slot,[cx-page-slot]", inputs: { position: "position", class: "class", isPageFold: "isPageFold", hasComponents: "hasComponents" }, host: { properties: { "attr.position": "this.position", "class": "this.class", "class.page-fold": "this.isPageFold", "class.cx-pending": "this.isPending", "class.has-components": "this.hasComponents" } }, ngImport: i0__namespace, template: "<ng-template\n  [cxOutlet]=\"position\"\n  [cxOutletContext]=\"{ components$: components$ }\"\n>\n  <ng-template\n    *ngFor=\"let component of components\"\n    [cxOutlet]=\"component.flexType\"\n    [cxOutletContext]=\"{ component: component }\"\n    [cxOutletDefer]=\"getComponentDeferOptions(component.flexType)\"\n    (loaded)=\"isLoaded($event)\"\n  >\n    <ng-container [cxComponentWrapper]=\"component\"></ng-container>\n  </ng-template>\n</ng-template>\n", directives: [{ type: OutletDirective, selector: "[cxOutlet]", inputs: ["cxOutlet", "cxOutletContext", "cxOutletDefer"], outputs: ["loaded"] }, { type: i3__namespace.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: ComponentWrapperDirective, selector: "[cxComponentWrapper]", inputs: ["cxComponentWrapper"], outputs: ["cxComponentRef"] }], changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PageSlotComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-page-slot,[cx-page-slot]',
                        templateUrl: './page-slot.component.html',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace.CmsService }, { type: i1__namespace.DynamicAttributeService }, { type: i0__namespace.Renderer2 }, { type: i0__namespace.ElementRef }, { type: i0__namespace.ChangeDetectorRef }, { type: PageSlotService }]; }, propDecorators: { position: [{
                    type: i0.HostBinding,
                    args: ['attr.position']
                }, {
                    type: i0.Input
                }], class: [{
                    type: i0.Input
                }, {
                    type: i0.HostBinding
                }], isPageFold: [{
                    type: i0.HostBinding,
                    args: ['class.page-fold']
                }, {
                    type: i0.Input
                }], isPending: [{
                    type: i0.HostBinding,
                    args: ['class.cx-pending']
                }], hasComponents: [{
                    type: i0.HostBinding,
                    args: ['class.has-components']
                }, {
                    type: i0.Input
                }] } });

    /**
     * Directive that Adds a style class to the host element based on the cms page
     * template. The CMS page template is driven by the CMS structure, which is configurable
     * in the backend.
     *
     * The style class is added to the host element of the directive. The host element is resolved
     * from the `elementRef`, or, in case the directive is used in an `ng-template`, by the
     * `TemplateRef`.
     *
     * An example of the usage is given below:
     *
     * ```html
     * <cx-storefront class="LandingPageTemplate">
     *   <ng-template cxPageTemplateStyle>...</ng-template>
     * <cx-storefront>
     * ```
     *
     * The style class can also be provided by an input:
     *
     * ```html
     * <ng-template [cxPageTemplateStyle]="pageTemplateName">
     * ```
     *
     */
    var PageTemplateDirective = /** @class */ (function () {
        function PageTemplateDirective(pageLayoutService, elementRef, templateRef, cd) {
            this.pageLayoutService = pageLayoutService;
            this.elementRef = elementRef;
            this.templateRef = templateRef;
            this.cd = cd;
            // Maintains the page template subscription
            this.subscription = new rxjs.Subscription();
        }
        Object.defineProperty(PageTemplateDirective.prototype, "setTemplate", {
            /**
             * Adds a style class to the host element based on the cms page template, unless
             * the class is given as an input.
             *
             * The host element is either the actual host, or the parent element in case this
             * is used inside an `ng-template`.
             */
            set: function (template) {
                if (template && template !== '') {
                    this.useTemplateFromInput = true;
                    this.addStyleClass(template);
                }
                else if (this.useTemplateFromInput) {
                    // we only clear the template if it has been provided by the input before
                    this.clear();
                }
            },
            enumerable: false,
            configurable: true
        });
        PageTemplateDirective.prototype.ngOnInit = function () {
            var _this = this;
            if (!this.useTemplateFromInput) {
                this.subscription.add(this.pageLayoutService.templateName$.subscribe(function (template) { return _this.addStyleClass(template); }));
            }
        };
        /**
         * Adds the page template as a style class to the given element. If any
         * page template was added before, we clean it up.
         *
         * We'll not use hostBinding for the style class, as it will potential drop
         * an existing class name on the host. This is why we need to work with
         * the lower level change detection api.
         */
        PageTemplateDirective.prototype.addStyleClass = function (template, el) {
            this.clear(el);
            if (template) {
                this.currentTemplate = template;
                (el !== null && el !== void 0 ? el : this.host).classList.add(this.currentTemplate);
                this.cd.markForCheck();
            }
        };
        /**
         * Cleans up the class host binding, if a template class was assigned before.
         */
        PageTemplateDirective.prototype.clear = function (el) {
            var _a;
            if (this.currentTemplate) {
                (_a = (el !== null && el !== void 0 ? el : this.host).classList) === null || _a === void 0 ? void 0 : _a.remove(this.currentTemplate);
                this.cd.markForCheck();
            }
        };
        Object.defineProperty(PageTemplateDirective.prototype, "host", {
            /**
             * Returns the host element (`HTMLElement`).
             *
             * If the directive is used on an `ng-template`, we take the parent element,
             * to ensure that we're not ending up with a comment.
             */
            get: function () {
                return !!this.templateRef
                    ? this.templateRef.elementRef.nativeElement.parentElement
                    : this.elementRef.nativeElement;
            },
            enumerable: false,
            configurable: true
        });
        PageTemplateDirective.prototype.ngOnDestroy = function () {
            this.subscription.unsubscribe();
        };
        return PageTemplateDirective;
    }());
    PageTemplateDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PageTemplateDirective, deps: [{ token: PageLayoutService }, { token: i0__namespace.ElementRef }, { token: i0__namespace.TemplateRef, optional: true }, { token: i0__namespace.ChangeDetectorRef }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    PageTemplateDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.5", type: PageTemplateDirective, selector: "[cxPageTemplateStyle]", inputs: { setTemplate: ["cxPageTemplateStyle", "setTemplate"] }, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PageTemplateDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        selector: '[cxPageTemplateStyle]',
                    }]
            }], ctorParameters: function () {
            return [{ type: PageLayoutService }, { type: i0__namespace.ElementRef }, { type: i0__namespace.TemplateRef, decorators: [{
                            type: i0.Optional
                        }] }, { type: i0__namespace.ChangeDetectorRef }];
        }, propDecorators: { setTemplate: [{
                    type: i0.Input,
                    args: ['cxPageTemplateStyle']
                }] } });

    var PageLayoutComponent = /** @class */ (function () {
        function PageLayoutComponent(pageLayoutService) {
            var _this = this;
            this.pageLayoutService = pageLayoutService;
            this.section$ = new rxjs.BehaviorSubject(undefined);
            this.templateName$ = this.pageLayoutService.templateName$;
            this.layoutName$ = this.section$.pipe(operators.switchMap(function (section) { return (section ? rxjs.of(section) : _this.templateName$); }));
            this.slots$ = this.section$.pipe(operators.switchMap(function (section) { return _this.pageLayoutService.getSlots(section); }));
            this.pageFoldSlot$ = this.templateName$.pipe(operators.switchMap(function (templateName) { return _this.pageLayoutService.getPageFoldSlot(templateName); }), operators.distinctUntilChanged());
        }
        Object.defineProperty(PageLayoutComponent.prototype, "section", {
            set: function (value) {
                this.section$.next(value);
            },
            enumerable: false,
            configurable: true
        });
        return PageLayoutComponent;
    }());
    PageLayoutComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PageLayoutComponent, deps: [{ token: PageLayoutService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    PageLayoutComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: PageLayoutComponent, selector: "cx-page-layout", inputs: { section: "section" }, ngImport: i0__namespace, template: "<ng-template\n  [cxPageTemplateStyle]=\"layoutName$ | async\"\n  [cxOutlet]=\"layoutName$ | async\"\n  [cxOutletContext]=\"{\n    templateName$: templateName$,\n    slots$: slots$,\n    section$: section$\n  }\"\n>\n  <ng-content></ng-content>\n\n  <cx-page-slot\n    *ngFor=\"let slot of slots$ | async\"\n    [position]=\"slot\"\n    [isPageFold]=\"slot === (pageFoldSlot$ | async)\"\n  ></cx-page-slot>\n</ng-template>\n", components: [{ type: PageSlotComponent, selector: "cx-page-slot,[cx-page-slot]", inputs: ["position", "class", "isPageFold", "hasComponents"] }], directives: [{ type: PageTemplateDirective, selector: "[cxPageTemplateStyle]", inputs: ["cxPageTemplateStyle"] }, { type: OutletDirective, selector: "[cxOutlet]", inputs: ["cxOutlet", "cxOutletContext", "cxOutletDefer"], outputs: ["loaded"] }, { type: i3__namespace.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], pipes: { "async": i3__namespace.AsyncPipe }, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PageLayoutComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-page-layout',
                        templateUrl: './page-layout.component.html',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], ctorParameters: function () { return [{ type: PageLayoutService }]; }, propDecorators: { section: [{
                    type: i0.Input
                }] } });

    // This service should be exposed in public API only after the refactor planned in https://github.com/SAP/spartacus/issues/7070
    var CmsRoutesImplService = /** @class */ (function () {
        function CmsRoutesImplService(router, cmsComponentsService) {
            this.router = router;
            this.cmsComponentsService = cmsComponentsService;
        }
        CmsRoutesImplService.prototype.cmsRouteExists = function (url) {
            var isCmsDrivenRoute = url.startsWith('/');
            if (!isCmsDrivenRoute) {
                return false;
            }
            var routePath = url.substr(1);
            return (isCmsDrivenRoute &&
                !!this.router.config.find(function (route) { return route.data && route.data.cxCmsRouteContext && route.path === routePath; }));
        };
        /**
         * Contains Cms driven routing logic intended for use use in guards, especially in canActivate method.
         *
         * Will return true, when logic wont have to modify routing (so canActivate could be easily resolved to true)
         * or will return false, when routing configuration was updated and redirection to newly generated route was initiated.
         *
         * @param pageContext
         * @param currentUrl
         */
        CmsRoutesImplService.prototype.handleCmsRoutesInGuard = function (pageContext, componentTypes, currentUrl, currentPageLabel) {
            var _a;
            if (this.cmsRouteExists(currentPageLabel)) {
                return true;
            }
            var childRoutesConfig = this.cmsComponentsService.getChildRoutes(componentTypes);
            if ((_a = childRoutesConfig === null || childRoutesConfig === void 0 ? void 0 : childRoutesConfig.children) === null || _a === void 0 ? void 0 : _a.length) {
                if (this.updateRouting(pageContext, currentPageLabel, childRoutesConfig)) {
                    this.router.navigateByUrl(currentUrl);
                    return false;
                }
            }
            return true;
        };
        CmsRoutesImplService.prototype.updateRouting = function (pageContext, pageLabel, childRoutesConfig) {
            var _a, _b;
            if (pageContext.type === i1.PageType.CONTENT_PAGE &&
                pageLabel.startsWith('/') &&
                pageLabel.length > 1) {
                var newRoute = {
                    path: pageLabel.substr(1),
                    component: PageLayoutComponent,
                    children: childRoutesConfig.children,
                    data: i1.deepMerge({}, (_b = (_a = childRoutesConfig === null || childRoutesConfig === void 0 ? void 0 : childRoutesConfig.parent) === null || _a === void 0 ? void 0 : _a.data) !== null && _b !== void 0 ? _b : {}, {
                        cxCmsRouteContext: {
                            type: pageContext.type,
                            id: pageLabel,
                        },
                    }),
                };
                this.router.resetConfig(__spreadArray([newRoute], __read(this.router.config)));
                return true;
            }
            return false;
        };
        return CmsRoutesImplService;
    }());
    CmsRoutesImplService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CmsRoutesImplService, deps: [{ token: i1__namespace$1.Router }, { token: CmsComponentsService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    CmsRoutesImplService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CmsRoutesImplService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CmsRoutesImplService, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }], ctorParameters: function () { return [{ type: i1__namespace$1.Router }, { type: CmsComponentsService }]; } });

    // Public injection token for the private implementation of the service `CmsRoutesImplService`.
    // After #7070, this class should be replaced with a real implementation.
    var CmsRoutesService = /** @class */ (function () {
        function CmsRoutesService() {
        }
        return CmsRoutesService;
    }());
    CmsRoutesService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CmsRoutesService, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    CmsRoutesService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CmsRoutesService, providedIn: 'root', useExisting: CmsRoutesImplService });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CmsRoutesService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                        useExisting: CmsRoutesImplService,
                    }]
            }] });

    var CmsI18nService = /** @class */ (function () {
        function CmsI18nService(cmsComponentsService, translation, translationChunk) {
            this.cmsComponentsService = cmsComponentsService;
            this.translation = translation;
            this.translationChunk = translationChunk;
        }
        CmsI18nService.prototype.loadForComponents = function (componentTypes) {
            var e_1, _a;
            var i18nKeys = this.cmsComponentsService.getI18nKeys(componentTypes);
            var i18nChunks = new Set();
            try {
                for (var i18nKeys_1 = __values(i18nKeys), i18nKeys_1_1 = i18nKeys_1.next(); !i18nKeys_1_1.done; i18nKeys_1_1 = i18nKeys_1.next()) {
                    var key = i18nKeys_1_1.value;
                    i18nChunks.add(this.translationChunk.getChunkNameForKey(key));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (i18nKeys_1_1 && !i18nKeys_1_1.done && (_a = i18nKeys_1.return)) _a.call(i18nKeys_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            this.translation.loadChunks(Array.from(i18nChunks));
        };
        return CmsI18nService;
    }());
    CmsI18nService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CmsI18nService, deps: [{ token: CmsComponentsService }, { token: i1__namespace.TranslationService }, { token: i1__namespace.TranslationChunkService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    CmsI18nService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CmsI18nService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CmsI18nService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: CmsComponentsService }, { type: i1__namespace.TranslationService }, { type: i1__namespace.TranslationChunkService }]; } });

    var CmsGuardsService = /** @class */ (function () {
        function CmsGuardsService(cmsComponentsService, injector) {
            this.cmsComponentsService = cmsComponentsService;
            this.injector = injector;
        }
        CmsGuardsService.prototype.cmsPageCanActivate = function (componentTypes, route, state) {
            var _this = this;
            var guards = this.cmsComponentsService.getGuards(componentTypes);
            if (guards.length) {
                var canActivateObservables = guards.map(function (guardClass) {
                    var guard = _this.injector.get(guardClass, null);
                    if (isCanActivate(guard)) {
                        return wrapIntoObservable(guard.canActivate(route, state)).pipe(operators.first());
                    }
                    else {
                        throw new Error('Invalid CanActivate guard in cmsMapping');
                    }
                });
                return rxjs.concat.apply(void 0, __spreadArray([], __read(canActivateObservables))).pipe(operators.skipWhile(function (canActivate) { return canActivate === true; }), operators.endWith(true), operators.first());
            }
            else {
                return rxjs.of(true);
            }
        };
        return CmsGuardsService;
    }());
    CmsGuardsService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CmsGuardsService, deps: [{ token: CmsComponentsService }, { token: i0__namespace.Injector }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    CmsGuardsService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CmsGuardsService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CmsGuardsService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: CmsComponentsService }, { type: i0__namespace.Injector }]; } });
    function wrapIntoObservable(value) {
        if (rxjs.isObservable(value)) {
            return value;
        }
        if (isPromise(value)) {
            return rxjs.from(Promise.resolve(value));
        }
        return rxjs.of(value);
    }
    function isPromise(obj) {
        return !!obj && typeof obj.then === 'function';
    }
    function isCanActivate(guard) {
        return guard && isFunction(guard.canActivate);
    }
    function isFunction(v) {
        return typeof v === 'function';
    }

    /**
     * Helper service for `CmsPageGuard`
     */
    var CmsPageGuardService = /** @class */ (function () {
        function CmsPageGuardService(semanticPathService, cmsService, cmsRoutes, cmsI18n, cmsGuards, cmsComponentsService, routing) {
            this.semanticPathService = semanticPathService;
            this.cmsService = cmsService;
            this.cmsRoutes = cmsRoutes;
            this.cmsI18n = cmsI18n;
            this.cmsGuards = cmsGuards;
            this.cmsComponentsService = cmsComponentsService;
            this.routing = routing;
        }
        /**
         * Takes CMS components types in the current CMS page, triggers (configurable) side effects and returns a boolean - whether the route can be activated.
         *
         * Based on `cmsComponents` config for the components in the page:
         * - Evaluates components' guards; if one of them emits false or UrlTree - the route cannot be activated or redirects to the given UrlTree, respectively.
         * - If all components' guards emitted true, then the route can be activated
         * - Then we trigger loading of configured i18n chunks in parallel
         * - And we register the configured children routes of cms components
         *
         * @param pageContext current cms page context
         * @param pageData cms page data
         * @param route activated route snapshot
         * @param state router state snapshot
         *
         * @returns boolean observable - whether the route can be activated
         */
        CmsPageGuardService.prototype.canActivatePage = function (pageContext, pageData, route, state) {
            var _this = this;
            return this.cmsService.getPageComponentTypes(pageContext).pipe(operators.take(1), operators.switchMap(function (componentTypes) { return _this.cmsComponentsService.determineMappings(componentTypes); }), operators.switchMap(function (componentTypes) { return _this.cmsGuards
                .cmsPageCanActivate(componentTypes, route, state)
                .pipe(operators.withLatestFrom(rxjs.of(componentTypes))); }), operators.tap(function (_b) {
                var _c = __read(_b, 2), canActivate = _c[0], componentTypes = _c[1];
                if (canActivate === true) {
                    _this.cmsI18n.loadForComponents(componentTypes);
                }
            }), operators.map(function (_b) {
                var _c = __read(_b, 2), canActivate = _c[0], componentTypes = _c[1];
                var _a;
                var pageLabel = pageData.label || pageContext.id; // for content pages the page label returned from backend can be different than ID initially assumed from route
                if (canActivate === true && !((_a = route === null || route === void 0 ? void 0 : route.data) === null || _a === void 0 ? void 0 : _a.cxCmsRouteContext)) {
                    return _this.cmsRoutes.handleCmsRoutesInGuard(pageContext, componentTypes, state.url, pageLabel);
                }
                return canActivate;
            }));
        };
        /**
         * Activates the "NOT FOUND" cms page.
         *
         * It loads cms page data for the "NOT FOUND" page and puts it in the state of the the requested page label.
         * Then it processes its CMS components with the method `canActivatePage()` of this service. For more, see its docs.
         */
        CmsPageGuardService.prototype.canActivateNotFoundPage = function (pageContext, route, state) {
            var _this = this;
            var notFoundCmsPageContext = {
                type: i1.PageType.CONTENT_PAGE,
                id: this.semanticPathService.get('notFound'),
            };
            return this.cmsService.getPage(notFoundCmsPageContext).pipe(operators.switchMap(function (notFoundPage) {
                if (notFoundPage) {
                    return _this.cmsService.getPageIndex(notFoundCmsPageContext).pipe(operators.tap(function (notFoundIndex) {
                        _this.cmsService.setPageFailIndex(pageContext, notFoundIndex);
                        _this.routing.changeNextPageContext(notFoundCmsPageContext);
                    }), operators.switchMap(function (notFoundIndex) { return _this.cmsService.getPageIndex(pageContext).pipe(
                    // we have to wait for page index update
                    operators.filter(function (index) { return index === notFoundIndex; })); }), operators.switchMap(function () { return _this.canActivatePage(pageContext, notFoundPage, route, state); }));
                }
                return rxjs.of(false);
            }));
        };
        return CmsPageGuardService;
    }());
    CmsPageGuardService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CmsPageGuardService, deps: [{ token: i1__namespace.SemanticPathService }, { token: i1__namespace.CmsService }, { token: CmsRoutesService }, { token: CmsI18nService }, { token: CmsGuardsService }, { token: CmsComponentsService }, { token: i1__namespace.RoutingService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    CmsPageGuardService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CmsPageGuardService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CmsPageGuardService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace.SemanticPathService }, { type: i1__namespace.CmsService }, { type: CmsRoutesService }, { type: CmsI18nService }, { type: CmsGuardsService }, { type: CmsComponentsService }, { type: i1__namespace.RoutingService }]; } });

    var CmsPageGuard = /** @class */ (function () {
        function CmsPageGuard(routingService, cmsService, protectedRoutesGuard, service, routingConfig) {
            this.routingService = routingService;
            this.cmsService = cmsService;
            this.protectedRoutesGuard = protectedRoutesGuard;
            this.service = service;
            this.routingConfig = routingConfig;
        }
        /**
         * Tries to load the CMS page data for the anticipated route and returns:
         * - `true` - if it can be activated
         * - `false` - if it cannot be activated
         * - `UrlTree` - if user should be redirected to a given `UrlTree`
         *
         * If the route can be activated, it fires additional calculations on the CMS components present on this CMS page,
         * based on their configuration (`cmsComponents` config).
         *
         * For more, see docs of the `CmsPageGuardService.canActivatePage`.
         */
        CmsPageGuard.prototype.canActivate = function (route, state) {
            var _this = this;
            return this.protectedRoutesGuard.canActivate(route).pipe(operators.switchMap(function (canActivate) { return canActivate === true
                ? _this.routingService.getNextPageContext().pipe(operators.take(1), operators.switchMap(function (pageContext) { return _this.cmsService.getPage(pageContext, _this.shouldReload()).pipe(operators.first(), operators.switchMap(function (pageData) { return pageData
                    ? _this.service.canActivatePage(pageContext, pageData, route, state)
                    : _this.service.canActivateNotFoundPage(pageContext, route, state); })); }))
                : rxjs.of(canActivate); }));
        };
        /**
         * Returns whether we should reload the CMS page data, even when it was loaded before.
         */
        CmsPageGuard.prototype.shouldReload = function () {
            return this.routingConfig.getLoadStrategy() !== "once" /* ONCE */;
        };
        return CmsPageGuard;
    }());
    CmsPageGuard.guardName = 'CmsPageGuard';
    CmsPageGuard.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CmsPageGuard, deps: [{ token: i1__namespace.RoutingService }, { token: i1__namespace.CmsService }, { token: i1__namespace.ProtectedRoutesGuard }, { token: CmsPageGuardService }, { token: i1__namespace.RoutingConfigService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    CmsPageGuard.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CmsPageGuard, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CmsPageGuard, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace.RoutingService }, { type: i1__namespace.CmsService }, { type: i1__namespace.ProtectedRoutesGuard }, { type: CmsPageGuardService }, { type: i1__namespace.RoutingConfigService }]; } });

    var MiniCartComponent = /** @class */ (function () {
        function MiniCartComponent(activeCartService) {
            this.activeCartService = activeCartService;
            this.iconTypes = exports.ICON_TYPE;
            this.quantity$ = this.activeCartService.getActive().pipe(operators.startWith({ deliveryItemsQuantity: 0 }), operators.map(function (cart) { return cart.deliveryItemsQuantity || 0; }));
            this.total$ = this.activeCartService.getActive().pipe(operators.filter(function (cart) { return !!cart.totalPrice; }), operators.map(function (cart) { return cart.totalPrice.formattedValue; }));
        }
        return MiniCartComponent;
    }());
    MiniCartComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: MiniCartComponent, deps: [{ token: i1__namespace.ActiveCartService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    MiniCartComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: MiniCartComponent, selector: "cx-mini-cart", ngImport: i0__namespace, template: "<a\n  [attr.aria-label]=\"\n    'miniCart.item' | cxTranslate: { count: quantity$ | async }\n  \"\n  [routerLink]=\"{ cxRoute: 'cart' } | cxUrl\"\n>\n  <cx-icon [type]=\"iconTypes.CART\"></cx-icon>\n\n  <span class=\"total\">\n    {{ 'miniCart.total' | cxTranslate: { total: total$ | async } }}\n  </span>\n\n  <span class=\"count\">\n    {{ 'miniCart.count' | cxTranslate: { count: quantity$ | async } }}\n  </span>\n</a>\n", components: [{ type: IconComponent, selector: "cx-icon,[cxIcon]", inputs: ["cxIcon", "type"] }], directives: [{ type: i1__namespace$1.RouterLinkWithHref, selector: "a[routerLink],area[routerLink]", inputs: ["routerLink", "target", "queryParams", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange", "replaceUrl", "state", "relativeTo"] }], pipes: { "cxTranslate": i1__namespace.TranslatePipe, "async": i3__namespace.AsyncPipe, "cxUrl": i1__namespace.UrlPipe }, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: MiniCartComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-mini-cart',
                        templateUrl: './mini-cart.component.html',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace.ActiveCartService }]; } });

    var MiniCartModule = /** @class */ (function () {
        function MiniCartModule() {
        }
        return MiniCartModule;
    }());
    MiniCartModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: MiniCartModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    MiniCartModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: MiniCartModule, declarations: [MiniCartComponent], imports: [i3.CommonModule, i1$1.RouterModule, i1.UrlModule, IconModule, i1.I18nModule], exports: [MiniCartComponent] });
    MiniCartModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: MiniCartModule, providers: [
            i1.provideDefaultConfig({
                cmsComponents: {
                    MiniCartComponent: {
                        component: MiniCartComponent,
                    },
                },
            }),
        ], imports: [[i3.CommonModule, i1$1.RouterModule, i1.UrlModule, IconModule, i1.I18nModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: MiniCartModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [i3.CommonModule, i1$1.RouterModule, i1.UrlModule, IconModule, i1.I18nModule],
                        providers: [
                            i1.provideDefaultConfig({
                                cmsComponents: {
                                    MiniCartComponent: {
                                        component: MiniCartComponent,
                                    },
                                },
                            }),
                        ],
                        declarations: [MiniCartComponent],
                        exports: [MiniCartComponent],
                    }]
            }] });

    var ORDER_ENTRIES_CONTEXT = Symbol('ORDER_ENTRIES_CONTEXT');

    var SaveForLaterComponent = /** @class */ (function () {
        function SaveForLaterComponent(cmsService, cartService, selectiveCartService) {
            this.cmsService = cmsService;
            this.cartService = cartService;
            this.selectiveCartService = selectiveCartService;
            this.CartLocation = i1.PromotionLocation;
        }
        SaveForLaterComponent.prototype.ngOnInit = function () {
            this.isCartEmpty$ = this.cartService
                .getActive()
                .pipe(operators.map(function (cart) { return !(cart && cart.totalItems && cart.totalItems > 0); }));
            this.saveForLater$ = this.selectiveCartService.getCart();
            this.entries$ = this.selectiveCartService
                .getEntries()
                .pipe(operators.filter(function (entries) { return entries.length > 0; }));
            this.cartLoaded$ = rxjs.combineLatest([
                this.cartService.isStable(),
                this.selectiveCartService.isStable(),
            ]).pipe(operators.map(function (_a) {
                var _b = __read(_a, 2), cartLoaded = _b[0], sflLoaded = _b[1];
                return cartLoaded && sflLoaded;
            }));
            this.data$ = this.cmsService.getComponentData('EmptyCartParagraphComponent');
        };
        SaveForLaterComponent.prototype.moveToCart = function (item) {
            this.selectiveCartService.removeEntry(item);
            this.cartService.addEntry(item.product.code, item.quantity);
        };
        return SaveForLaterComponent;
    }());
    SaveForLaterComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SaveForLaterComponent, deps: [{ token: i1__namespace.CmsService }, { token: i1__namespace.ActiveCartService }, { token: i1__namespace.SelectiveCartService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    SaveForLaterComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: SaveForLaterComponent, selector: "cx-save-for-later", ngImport: i0__namespace, template: "<ng-container *ngIf=\"isCartEmpty$ | async\">\n  <p\n    *ngIf=\"data$ | async as data\"\n    [innerHTML]=\"data.content\"\n    class=\"cx-empty-cart-info\"\n  ></p>\n</ng-container>\n\n<ng-container *ngIf=\"saveForLater$ | async as saveForLater\">\n  <ng-container *ngIf=\"entries$ | async as entries\">\n    <div *ngIf=\"saveForLater.totalItems > 0\" class=\"cart-details-wrapper\">\n      <div class=\"cx-total\">\n        {{\n          'saveForLaterItems.itemTotal'\n            | cxTranslate: { count: saveForLater.totalItems }\n        }}\n      </div>\n      <cx-cart-item-list\n        [items]=\"entries\"\n        [readonly]=\"false\"\n        [cartIsLoading]=\"!(cartLoaded$ | async)\"\n        [promotionLocation]=\"CartLocation.SaveForLater\"\n        [options]=\"{\n          isSaveForLater: true,\n          optionalBtn: moveToCartBtn\n        }\"\n      ></cx-cart-item-list>\n    </div>\n  </ng-container>\n</ng-container>\n\n<ng-template let-ctx #moveToCartBtn>\n  <div class=\"col-md-3 col-lg-3 col-xl-3 cx-sfl-btn\">\n    <button\n      class=\"link cx-action-link\"\n      [disabled]=\"ctx.loading\"\n      (click)=\"moveToCart(ctx.item)\"\n      type=\"button\"\n    >\n      {{ 'saveForLaterItems.moveToCart' | cxTranslate }}\n    </button>\n  </div>\n</ng-template>\n", components: [{ type: CartItemListComponent, selector: "cx-cart-item-list", inputs: ["readonly", "hasHeader", "options", "cartId", "items", "promotionLocation", "cartIsLoading"] }], directives: [{ type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "async": i3__namespace.AsyncPipe, "cxTranslate": i1__namespace.TranslatePipe } });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SaveForLaterComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-save-for-later',
                        templateUrl: './save-for-later.component.html',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace.CmsService }, { type: i1__namespace.ActiveCartService }, { type: i1__namespace.SelectiveCartService }]; } });

    var SaveForLaterModule = /** @class */ (function () {
        function SaveForLaterModule() {
        }
        return SaveForLaterModule;
    }());
    SaveForLaterModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SaveForLaterModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    SaveForLaterModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SaveForLaterModule, declarations: [SaveForLaterComponent], imports: [i3.CommonModule, i1.I18nModule, CartSharedModule], exports: [SaveForLaterComponent] });
    SaveForLaterModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SaveForLaterModule, providers: [
            i1.provideDefaultConfig({
                cmsComponents: {
                    SaveForLaterComponent: {
                        component: SaveForLaterComponent,
                    },
                },
            }),
        ], imports: [[i3.CommonModule, i1.I18nModule, CartSharedModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SaveForLaterModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [i3.CommonModule, i1.I18nModule, CartSharedModule],
                        providers: [
                            i1.provideDefaultConfig({
                                cmsComponents: {
                                    SaveForLaterComponent: {
                                        component: SaveForLaterComponent,
                                    },
                                },
                            }),
                        ],
                        declarations: [SaveForLaterComponent],
                        exports: [SaveForLaterComponent],
                    }]
            }] });

    var _a, _b;
    var CartComponentModule = /** @class */ (function () {
        function CartComponentModule() {
        }
        return CartComponentModule;
    }());
    CartComponentModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartComponentModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    CartComponentModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartComponentModule, imports: [i1$3.NgbModule,
            CartDetailsModule,
            CartTotalsModule,
            CartSharedModule,
            SaveForLaterModule, i1__namespace$1.RouterModule], exports: [AddToWishListModule,
            CartDetailsModule,
            CartTotalsModule,
            CartSharedModule,
            AddToCartModule,
            MiniCartModule,
            i1.CartModule,
            SaveForLaterModule] });
    CartComponentModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartComponentModule, providers: [
            {
                provide: PAGE_LAYOUT_HANDLER,
                useExisting: CartPageLayoutHandler,
                multi: true,
            },
        ], imports: [[
                i1$3.NgbModule,
                CartDetailsModule,
                CartTotalsModule,
                CartSharedModule,
                SaveForLaterModule,
                i1$1.RouterModule.forChild([
                    {
                        // @ts-ignore
                        path: null,
                        canActivate: [CmsPageGuard],
                        component: PageLayoutComponent,
                        data: {
                            cxRoute: 'cart',
                            cxContext: (_a = {},
                                _a[ORDER_ENTRIES_CONTEXT] = ActiveCartOrderEntriesContext,
                                _a),
                        },
                    },
                ]),
            ], AddToWishListModule,
            CartDetailsModule,
            CartTotalsModule,
            CartSharedModule,
            AddToCartModule,
            MiniCartModule,
            i1.CartModule,
            SaveForLaterModule] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartComponentModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [
                            i1$3.NgbModule,
                            CartDetailsModule,
                            CartTotalsModule,
                            CartSharedModule,
                            SaveForLaterModule,
                            i1$1.RouterModule.forChild([
                                {
                                    // @ts-ignore
                                    path: null,
                                    canActivate: [CmsPageGuard],
                                    component: PageLayoutComponent,
                                    data: {
                                        cxRoute: 'cart',
                                        cxContext: (_b = {},
                                            _b[ORDER_ENTRIES_CONTEXT] = ActiveCartOrderEntriesContext,
                                            _b),
                                    },
                                },
                            ]),
                        ],
                        exports: [
                            AddToWishListModule,
                            CartDetailsModule,
                            CartTotalsModule,
                            CartSharedModule,
                            AddToCartModule,
                            MiniCartModule,
                            i1.CartModule,
                            SaveForLaterModule,
                        ],
                        declarations: [],
                        providers: [
                            {
                                provide: PAGE_LAYOUT_HANDLER,
                                useExisting: CartPageLayoutHandler,
                                multi: true,
                            },
                        ],
                    }]
            }] });

    var CartValidationComponentsModule = /** @class */ (function () {
        function CartValidationComponentsModule() {
        }
        return CartValidationComponentsModule;
    }());
    CartValidationComponentsModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartValidationComponentsModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    CartValidationComponentsModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartValidationComponentsModule, imports: [CartValidationWarningsModule, CartItemValidationWarningModule] });
    CartValidationComponentsModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartValidationComponentsModule, providers: [], imports: [[CartValidationWarningsModule, CartItemValidationWarningModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartValidationComponentsModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [CartValidationWarningsModule, CartItemValidationWarningModule],
                        providers: [],
                    }]
            }] });

    var CartValidationGuard = /** @class */ (function () {
        function CartValidationGuard(cartValidationService, semanticPathService, router, globalMessageService, activeCartService, cartValidationStateService, cartConfigService) {
            this.cartValidationService = cartValidationService;
            this.semanticPathService = semanticPathService;
            this.router = router;
            this.globalMessageService = globalMessageService;
            this.activeCartService = activeCartService;
            this.cartValidationStateService = cartValidationStateService;
            this.cartConfigService = cartConfigService;
            this.GLOBAL_MESSAGE_TIMEOUT = 10000;
        }
        CartValidationGuard.prototype.canActivate = function () {
            var _this = this;
            return !this.cartConfigService.isCartValidationEnabled()
                ? rxjs.of(true)
                : this.cartValidationService.validateCart().pipe(operators.withLatestFrom(this.activeCartService.getEntries()), operators.map(function (_b) {
                    var _c = __read(_b, 2), cartModificationList = _c[0], cartEntries = _c[1];
                    var _a;
                    _this.cartValidationStateService.updateValidationResultAndRoutingId(cartModificationList === null || cartModificationList === void 0 ? void 0 : cartModificationList.cartModifications);
                    if (((_a = cartModificationList === null || cartModificationList === void 0 ? void 0 : cartModificationList.cartModifications) === null || _a === void 0 ? void 0 : _a.length) !== 0) {
                        var validationResultMessage = void 0;
                        if (cartEntries.length === 1 &&
                            cartEntries[0].product.code ===
                                (cartModificationList === null || cartModificationList === void 0 ? void 0 : cartModificationList.cartModifications[0].entry.product.code) &&
                            (cartModificationList === null || cartModificationList === void 0 ? void 0 : cartModificationList.cartModifications[0].statusCode) ===
                                i1.CartValidationStatusCode.NO_STOCK) {
                            validationResultMessage = {
                                key: 'validation.cartEntryRemoved',
                                params: {
                                    name: cartModificationList === null || cartModificationList === void 0 ? void 0 : cartModificationList.cartModifications[0].entry.product.name,
                                },
                            };
                        }
                        else {
                            validationResultMessage = {
                                key: 'validation.cartEntriesChangeDuringCheckout',
                            };
                        }
                        _this.globalMessageService.add(validationResultMessage, i1.GlobalMessageType.MSG_TYPE_ERROR, _this.GLOBAL_MESSAGE_TIMEOUT);
                        _this.activeCartService.reloadActiveCart();
                        return _this.router.parseUrl(_this.semanticPathService.get('cart'));
                    }
                    return true;
                }));
        };
        return CartValidationGuard;
    }());
    CartValidationGuard.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartValidationGuard, deps: [{ token: i1__namespace.CartValidationService }, { token: i1__namespace.SemanticPathService }, { token: i1__namespace$1.Router }, { token: i1__namespace.GlobalMessageService }, { token: i1__namespace.ActiveCartService }, { token: CartValidationStateService }, { token: i1__namespace.CartConfigService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    CartValidationGuard.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartValidationGuard, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartValidationGuard, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace.CartValidationService }, { type: i1__namespace.SemanticPathService }, { type: i1__namespace$1.Router }, { type: i1__namespace.GlobalMessageService }, { type: i1__namespace.ActiveCartService }, { type: CartValidationStateService }, { type: i1__namespace.CartConfigService }]; } });

    var BannerComponent = /** @class */ (function () {
        function BannerComponent(component) {
            var _this = this;
            this.component = component;
            this.data$ = this.component.data$.pipe(operators.tap(function (data) { return (_this.styleClasses = data.styleClasses); }));
        }
        /**
         * Returns `_blank` to force opening the link in a new window whenever the
         * `data.external` flag is set to true.
         */
        BannerComponent.prototype.getTarget = function (data) {
            return data.external === 'true' || data.external === true ? '_blank' : null;
        };
        BannerComponent.prototype.getImage = function (data) {
            if (data.media) {
                if ('url' in data.media) {
                    return data.media;
                }
                else {
                    return data.media;
                }
            }
        };
        return BannerComponent;
    }());
    BannerComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: BannerComponent, deps: [{ token: CmsComponentData }], target: i0__namespace.ɵɵFactoryTarget.Component });
    BannerComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: BannerComponent, selector: "cx-banner", host: { properties: { "class": "this.styleClasses" } }, ngImport: i0__namespace, template: "<ng-container *ngIf=\"data$ | async as data\">\n  <cx-generic-link\n    *ngIf=\"data.urlLink\"\n    [url]=\"data.urlLink\"\n    [target]=\"getTarget(data)\"\n  >\n    <p class=\"headline\" *ngIf=\"data.headline\" [innerHTML]=\"data.headline\"></p>\n    <cx-media [container]=\"getImage(data)\"></cx-media>\n    <p class=\"content\" *ngIf=\"data.content\" [innerHTML]=\"data.content\"></p>\n  </cx-generic-link>\n</ng-container>\n", components: [{ type: GenericLinkComponent, selector: "cx-generic-link", inputs: ["url", "target", "id", "class", "style", "title"] }, { type: MediaComponent, selector: "cx-media", inputs: ["container", "format", "alt", "role", "loading"], outputs: ["loaded"] }], directives: [{ type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "async": i3__namespace.AsyncPipe }, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: BannerComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-banner',
                        templateUrl: './banner.component.html',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], ctorParameters: function () { return [{ type: CmsComponentData }]; }, propDecorators: { styleClasses: [{
                    type: i0.HostBinding,
                    args: ['class']
                }] } });

    var BannerModule = /** @class */ (function () {
        function BannerModule() {
        }
        return BannerModule;
    }());
    BannerModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: BannerModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    BannerModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: BannerModule, declarations: [BannerComponent], imports: [i3.CommonModule, i1$1.RouterModule, GenericLinkModule, MediaModule], exports: [BannerComponent] });
    BannerModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: BannerModule, providers: [
            i1.provideDefaultConfig({
                cmsComponents: {
                    SimpleResponsiveBannerComponent: {
                        component: BannerComponent,
                    },
                    BannerComponent: {
                        component: BannerComponent,
                    },
                    SimpleBannerComponent: {
                        component: BannerComponent,
                    },
                },
            }),
        ], imports: [[i3.CommonModule, i1$1.RouterModule, GenericLinkModule, MediaModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: BannerModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [i3.CommonModule, i1$1.RouterModule, GenericLinkModule, MediaModule],
                        providers: [
                            i1.provideDefaultConfig({
                                cmsComponents: {
                                    SimpleResponsiveBannerComponent: {
                                        component: BannerComponent,
                                    },
                                    BannerComponent: {
                                        component: BannerComponent,
                                    },
                                    SimpleBannerComponent: {
                                        component: BannerComponent,
                                    },
                                },
                            }),
                        ],
                        declarations: [BannerComponent],
                        exports: [BannerComponent],
                    }]
            }] });

    /**
     * Default component handler used for dynamically launching cms components implemented
     * as native Angular components.
     */
    var DefaultComponentHandler = /** @class */ (function () {
        function DefaultComponentHandler() {
        }
        DefaultComponentHandler.prototype.hasMatch = function (componentMapping) {
            return typeof componentMapping.component === 'function';
        };
        DefaultComponentHandler.prototype.getPriority = function () {
            return -50 /* FALLBACK */;
        };
        DefaultComponentHandler.prototype.launcher = function (componentMapping, viewContainerRef, elementInjector, module) {
            var _this = this;
            return new rxjs.Observable(function (subscriber) {
                var componentRef;
                var injector = elementInjector !== null && elementInjector !== void 0 ? elementInjector : viewContainerRef.injector;
                var dispose = function () {
                    if (componentRef) {
                        componentRef.destroy();
                    }
                };
                var factory = _this.getComponentFactory(injector, componentMapping.component);
                if (factory) {
                    componentRef = viewContainerRef.createComponent(factory, undefined, injector, undefined, module);
                    subscriber.next({ elementRef: componentRef.location, componentRef: componentRef });
                }
                return dispose;
            });
        };
        DefaultComponentHandler.prototype.getComponentFactory = function (injector, component) {
            if (!component) {
                return null;
            }
            var factory = injector
                .get(i0.ComponentFactoryResolver)
                .resolveComponentFactory(component);
            return factory;
        };
        return DefaultComponentHandler;
    }());
    DefaultComponentHandler.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: DefaultComponentHandler, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    DefaultComponentHandler.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: DefaultComponentHandler, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: DefaultComponentHandler, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }] });

    /**
     * Lazy component handler used for launching lazy loaded cms components implemented
     * as native Angular components.
     */
    var LazyComponentHandler = /** @class */ (function () {
        function LazyComponentHandler(defaultHandler) {
            this.defaultHandler = defaultHandler;
        }
        /**
         * We want to mach dynamic import signature () => import('')
         */
        LazyComponentHandler.prototype.hasMatch = function (componentMapping) {
            return (typeof componentMapping.component === 'function' &&
                this.isNotClass(componentMapping.component));
        };
        LazyComponentHandler.prototype.isNotClass = function (symbol) {
            var signature = symbol.toString().substr(0, 20).replace(' ', '');
            return signature.startsWith('function()') || signature.startsWith('()=>');
        };
        LazyComponentHandler.prototype.getPriority = function () {
            return -10 /* LOW */;
        };
        LazyComponentHandler.prototype.launcher = function (componentMapping, viewContainerRef, elementInjector, module) {
            var _this = this;
            return rxjs.from(componentMapping.component()).pipe(operators.switchMap(function (component) { return _this.defaultHandler.launcher(Object.assign(Object.assign({}, componentMapping), { component: component }), viewContainerRef, elementInjector, module); }));
        };
        return LazyComponentHandler;
    }());
    LazyComponentHandler.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: LazyComponentHandler, deps: [{ token: DefaultComponentHandler }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    LazyComponentHandler.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: LazyComponentHandler, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: LazyComponentHandler, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: DefaultComponentHandler }]; } });

    var InnerComponentsHostDirective = /** @class */ (function () {
        function InnerComponentsHostDirective(data, vcr, 
        // dependencies required for ComponentWrapper directive
        cmsComponentsService, injector, dynamicAttributeService, renderer, componentHandler, cmsInjector) {
            this.data = data;
            this.vcr = vcr;
            this.cmsComponentsService = cmsComponentsService;
            this.injector = injector;
            this.dynamicAttributeService = dynamicAttributeService;
            this.renderer = renderer;
            this.componentHandler = componentHandler;
            this.cmsInjector = cmsInjector;
            this.innerComponents$ = this.data.data$.pipe(operators.map(function (data) { var _a, _b; return (_b = (_a = data === null || data === void 0 ? void 0 : data.composition) === null || _a === void 0 ? void 0 : _a.inner) !== null && _b !== void 0 ? _b : []; }));
            this.componentWrappers = [];
        }
        InnerComponentsHostDirective.prototype.ngOnInit = function () {
            var _this = this;
            this.subscription = this.innerComponents$.subscribe(function (x) {
                _this.renderComponents(x);
            });
        };
        InnerComponentsHostDirective.prototype.renderComponents = function (components) {
            var _this = this;
            this.clearComponents();
            components.forEach(function (component) { return _this.renderComponent(component); });
        };
        InnerComponentsHostDirective.prototype.renderComponent = function (component) {
            var componentWrapper = new ComponentWrapperDirective(this.vcr, this.cmsComponentsService, this.injector, this.dynamicAttributeService, this.renderer, this.componentHandler, this.cmsInjector);
            componentWrapper.cxComponentWrapper = { flexType: component, uid: '' };
            componentWrapper.ngOnInit();
            this.componentWrappers.push(componentWrapper);
        };
        InnerComponentsHostDirective.prototype.clearComponents = function () {
            this.componentWrappers.forEach(function (wrapper) { return wrapper.ngOnDestroy(); });
            this.componentWrappers = [];
        };
        InnerComponentsHostDirective.prototype.ngOnDestroy = function () {
            var _a;
            (_a = this.subscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();
            this.clearComponents();
        };
        return InnerComponentsHostDirective;
    }());
    InnerComponentsHostDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: InnerComponentsHostDirective, deps: [{ token: CmsComponentData }, { token: i0__namespace.ViewContainerRef }, { token: CmsComponentsService }, { token: i0__namespace.Injector }, { token: i1__namespace.DynamicAttributeService }, { token: i0__namespace.Renderer2 }, { token: ComponentHandlerService }, { token: CmsInjectorService }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    InnerComponentsHostDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.5", type: InnerComponentsHostDirective, selector: "[cxInnerComponentsHost]", ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: InnerComponentsHostDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        selector: '[cxInnerComponentsHost]',
                    }]
            }], ctorParameters: function () { return [{ type: CmsComponentData }, { type: i0__namespace.ViewContainerRef }, { type: CmsComponentsService }, { type: i0__namespace.Injector }, { type: i1__namespace.DynamicAttributeService }, { type: i0__namespace.Renderer2 }, { type: ComponentHandlerService }, { type: CmsInjectorService }]; } });

    var PageComponentModule = /** @class */ (function () {
        function PageComponentModule() {
        }
        PageComponentModule.forRoot = function () {
            return {
                ngModule: PageComponentModule,
                providers: [
                    {
                        provide: ComponentHandler,
                        useExisting: DefaultComponentHandler,
                        multi: true,
                    },
                    {
                        provide: ComponentHandler,
                        useExisting: LazyComponentHandler,
                        multi: true,
                    },
                ],
            };
        };
        return PageComponentModule;
    }());
    PageComponentModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PageComponentModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    PageComponentModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PageComponentModule, declarations: [ComponentWrapperDirective, InnerComponentsHostDirective], imports: [i3.CommonModule], exports: [ComponentWrapperDirective, InnerComponentsHostDirective] });
    PageComponentModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PageComponentModule, imports: [[i3.CommonModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PageComponentModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [i3.CommonModule],
                        declarations: [ComponentWrapperDirective, InnerComponentsHostDirective],
                        exports: [ComponentWrapperDirective, InnerComponentsHostDirective],
                    }]
            }] });

    var PageSlotModule = /** @class */ (function () {
        // instantiate PageSlotService ASAP, so it can examine SSR pre-rendered DOM
        function PageSlotModule(_pageSlot) {
        }
        return PageSlotModule;
    }());
    PageSlotModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PageSlotModule, deps: [{ token: PageSlotService }], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    PageSlotModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PageSlotModule, declarations: [PageSlotComponent], imports: [i3.CommonModule, OutletModule, PageComponentModule], exports: [PageSlotComponent] });
    PageSlotModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PageSlotModule, imports: [[i3.CommonModule, OutletModule, PageComponentModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PageSlotModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [i3.CommonModule, OutletModule, PageComponentModule],
                        declarations: [PageSlotComponent],
                        exports: [PageSlotComponent],
                    }]
            }], ctorParameters: function () { return [{ type: PageSlotService }]; } });

    var PageLayoutModule = /** @class */ (function () {
        function PageLayoutModule() {
        }
        return PageLayoutModule;
    }());
    PageLayoutModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PageLayoutModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    PageLayoutModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PageLayoutModule, declarations: [PageLayoutComponent, PageTemplateDirective], imports: [i3.CommonModule, OutletModule, PageSlotModule], exports: [PageLayoutComponent, PageTemplateDirective] });
    PageLayoutModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PageLayoutModule, imports: [[i3.CommonModule, OutletModule, PageSlotModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PageLayoutModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [i3.CommonModule, OutletModule, PageSlotModule],
                        declarations: [PageLayoutComponent, PageTemplateDirective],
                        exports: [PageLayoutComponent, PageTemplateDirective],
                    }]
            }] });

    var PWAModuleConfig = /** @class */ (function () {
        function PWAModuleConfig() {
        }
        return PWAModuleConfig;
    }());
    PWAModuleConfig.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PWAModuleConfig, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    PWAModuleConfig.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PWAModuleConfig, providedIn: 'root', useExisting: i1.Config });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PWAModuleConfig, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                        useExisting: i1.Config,
                    }]
            }] });
    var defaultPWAModuleConfig = {
        pwa: {
            enabled: false,
            addToHomeScreen: false,
        },
    };

    var AddToHomeScreenService = /** @class */ (function () {
        function AddToHomeScreenService(config, globalMessageService, winRef) {
            this.config = config;
            this.globalMessageService = globalMessageService;
            this.winRef = winRef;
            this.canPrompt = new rxjs.BehaviorSubject(false);
            this.canPrompt$ = this.canPrompt.asObservable();
            if (this.config.pwa.addToHomeScreen) {
                this.init();
            }
        }
        AddToHomeScreenService.prototype.init = function () {
            var _this = this;
            if (this.winRef.nativeWindow) {
                this.winRef.nativeWindow.addEventListener('beforeinstallprompt', function (event) {
                    event.preventDefault();
                    _this.deferredEvent = event;
                    _this.enableAddToHomeScreen();
                });
                this.winRef.nativeWindow.addEventListener('appinstalled', function () {
                    _this.globalMessageService.add({ key: 'pwa.addedToHomeScreen' }, i1.GlobalMessageType.MSG_TYPE_CONFIRMATION);
                    _this.disableAddToHomeScreen();
                    _this.deferredEvent = null;
                });
            }
        };
        AddToHomeScreenService.prototype.enableAddToHomeScreen = function () {
            this.canPrompt.next(true);
        };
        AddToHomeScreenService.prototype.disableAddToHomeScreen = function () {
            this.canPrompt.next(false);
        };
        AddToHomeScreenService.prototype.firePrompt = function () {
            if (this.deferredEvent) {
                this.deferredEvent.prompt();
            }
        };
        return AddToHomeScreenService;
    }());
    AddToHomeScreenService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AddToHomeScreenService, deps: [{ token: PWAModuleConfig }, { token: i1__namespace.GlobalMessageService }, { token: i1__namespace.WindowRef }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    AddToHomeScreenService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AddToHomeScreenService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AddToHomeScreenService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: PWAModuleConfig }, { type: i1__namespace.GlobalMessageService }, { type: i1__namespace.WindowRef }]; } });

    // eslint-disable-next-line @angular-eslint/directive-class-suffix
    var AddToHomeScreenComponent = /** @class */ (function () {
        function AddToHomeScreenComponent(addToHomeScreenService) {
            this.addToHomeScreenService = addToHomeScreenService;
        }
        AddToHomeScreenComponent.prototype.ngOnInit = function () {
            this.canPrompt$ = this.addToHomeScreenService.canPrompt$;
        };
        AddToHomeScreenComponent.prototype.prompt = function () {
            this.addToHomeScreenService.firePrompt();
        };
        return AddToHomeScreenComponent;
    }());
    AddToHomeScreenComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AddToHomeScreenComponent, deps: [{ token: AddToHomeScreenService }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    AddToHomeScreenComponent.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.5", type: AddToHomeScreenComponent, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AddToHomeScreenComponent, decorators: [{
                type: i0.Directive
            }], ctorParameters: function () { return [{ type: AddToHomeScreenService }]; } });

    var AddToHomeScreenBannerComponent = /** @class */ (function (_super) {
        __extends(AddToHomeScreenBannerComponent, _super);
        function AddToHomeScreenBannerComponent(addToHomeScreenService) {
            var _this = _super.call(this, addToHomeScreenService) || this;
            _this.addToHomeScreenService = addToHomeScreenService;
            return _this;
        }
        return AddToHomeScreenBannerComponent;
    }(AddToHomeScreenComponent));
    AddToHomeScreenBannerComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AddToHomeScreenBannerComponent, deps: [{ token: AddToHomeScreenService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    AddToHomeScreenBannerComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: AddToHomeScreenBannerComponent, selector: "cx-add-to-home-screen-banner", usesInheritance: true, ngImport: i0__namespace, template: "<div *ngIf=\"canPrompt$ | async\">\n  <div class=\"cx-add-to-home-screen-banner\">\n    <div class=\"cx-add-to-home-screen-banner-inner\">\n      <p>\n        {{ 'pwa.addToHomeScreenDescription' | cxTranslate }}\n      </p>\n      <ul>\n        <li>{{ 'pwa.noInstallationNeeded' | cxTranslate }}</li>\n        <li>{{ 'pwa.fastAccessToApplication' | cxTranslate }}</li>\n      </ul>\n      <button (click)=\"prompt()\" class=\"btn btn-primary\">\n        {{ 'pwa.addToHomeScreen' | cxTranslate }}\n      </button>\n    </div>\n  </div>\n</div>\n", directives: [{ type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "async": i3__namespace.AsyncPipe, "cxTranslate": i1__namespace.TranslatePipe } });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AddToHomeScreenBannerComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-add-to-home-screen-banner',
                        templateUrl: './add-to-home-screen-banner.component.html',
                    }]
            }], ctorParameters: function () { return [{ type: AddToHomeScreenService }]; } });

    var AddToHomeScreenBtnComponent = /** @class */ (function (_super) {
        __extends(AddToHomeScreenBtnComponent, _super);
        function AddToHomeScreenBtnComponent(addToHomeScreenService) {
            var _this = _super.call(this, addToHomeScreenService) || this;
            _this.addToHomeScreenService = addToHomeScreenService;
            return _this;
        }
        return AddToHomeScreenBtnComponent;
    }(AddToHomeScreenComponent));
    AddToHomeScreenBtnComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AddToHomeScreenBtnComponent, deps: [{ token: AddToHomeScreenService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    AddToHomeScreenBtnComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: AddToHomeScreenBtnComponent, selector: "cx-add-to-home-screen-btn", usesInheritance: true, ngImport: i0__namespace, template: "<span (click)=\"prompt()\">\n  <ng-content *ngIf=\"canPrompt$ | async\"></ng-content>\n</span>\n", directives: [{ type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "async": i3__namespace.AsyncPipe } });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AddToHomeScreenBtnComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-add-to-home-screen-btn',
                        templateUrl: './add-to-home-screen-btn.component.html',
                    }]
            }], ctorParameters: function () { return [{ type: AddToHomeScreenService }]; } });

    function pwaConfigurationFactory(pwaConfig) {
        return { enabled: (!i0.isDevMode() && pwaConfig.pwa.enabled) || false };
    }
    function pwaFactory(addToHomeScreenService) {
        var result = function () { return addToHomeScreenService; };
        return result;
    }
    var PwaModule = /** @class */ (function () {
        function PwaModule() {
        }
        return PwaModule;
    }());
    PwaModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PwaModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    PwaModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PwaModule, declarations: [AddToHomeScreenBtnComponent, AddToHomeScreenBannerComponent], imports: [i3.CommonModule, i1__namespace$6.ServiceWorkerModule, i1.I18nModule], exports: [AddToHomeScreenBtnComponent, AddToHomeScreenBannerComponent] });
    PwaModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PwaModule, providers: [
            i1.provideDefaultConfig(defaultPWAModuleConfig),
            {
                provide: i1$6.SwRegistrationOptions,
                useFactory: pwaConfigurationFactory,
                deps: [i1.Config],
            },
            {
                provide: i0.APP_INITIALIZER,
                useFactory: pwaFactory,
                deps: [AddToHomeScreenService],
                multi: true,
            },
        ], imports: [[
                i3.CommonModule,
                i1$6.ServiceWorkerModule.register('ngsw-worker.js'),
                i1.I18nModule,
            ]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PwaModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [
                            i3.CommonModule,
                            i1$6.ServiceWorkerModule.register('ngsw-worker.js'),
                            i1.I18nModule,
                        ],
                        providers: [
                            i1.provideDefaultConfig(defaultPWAModuleConfig),
                            {
                                provide: i1$6.SwRegistrationOptions,
                                useFactory: pwaConfigurationFactory,
                                deps: [i1.Config],
                            },
                            {
                                provide: i0.APP_INITIALIZER,
                                useFactory: pwaFactory,
                                deps: [AddToHomeScreenService],
                                multi: true,
                            },
                        ],
                        declarations: [AddToHomeScreenBtnComponent, AddToHomeScreenBannerComponent],
                        exports: [AddToHomeScreenBtnComponent, AddToHomeScreenBannerComponent],
                    }]
            }] });

    var cmsRoute = {
        path: '**',
        canActivate: [CmsPageGuard],
        component: PageLayoutComponent,
    };
    function addCmsRoute(injector) {
        var result = function () {
            var router = injector.get(i1$1.Router);
            router.config.push(cmsRoute);
        };
        return result;
    }

    var CmsRouteModule = /** @class */ (function () {
        function CmsRouteModule() {
        }
        return CmsRouteModule;
    }());
    CmsRouteModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CmsRouteModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    CmsRouteModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CmsRouteModule });
    CmsRouteModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CmsRouteModule, providers: [
            {
                provide: i0.APP_INITIALIZER,
                multi: true,
                deps: [i0.Injector],
                useFactory: addCmsRoute,
            },
        ] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CmsRouteModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        providers: [
                            {
                                provide: i0.APP_INITIALIZER,
                                multi: true,
                                deps: [i0.Injector],
                                useFactory: addCmsRoute,
                            },
                        ],
                    }]
            }] });

    var defaultStorefrontRoutesConfig = {
        home: { paths: [''] },
        notFound: { paths: ['not-found'] },
        cart: { paths: ['cart'] },
        // semantic links for login related pages
        login: {
            paths: ['login'],
            protected: false,
            authFlow: true,
        },
        register: {
            paths: ['login/register'],
            protected: false,
            authFlow: true,
        },
        forgotPassword: {
            paths: ['login/forgot-password'],
            protected: false,
            authFlow: true,
        },
        resetPassword: {
            paths: ['login/pw/change'],
            protected: false,
            authFlow: true,
        },
        logout: { paths: ['logout'], protected: false, authFlow: true },
        // plp routes
        search: { paths: ['search/:query'] },
        category: {
            paths: ['category/:categoryCode'],
            paramsMapping: { categoryCode: 'code' },
        },
        brand: { paths: ['Brands/:brandName/c/:brandCode'] },
        // pdp routes
        product: {
            paths: ['product/:productCode/:name'],
            paramsMapping: { productCode: 'code' },
        },
        termsAndConditions: { paths: ['terms-and-conditions'] },
        /** @deprecated since 4.2, use order lib instead */
        orders: {
            paths: ['my-account/orders'],
        },
        /** @deprecated since 4.2, use order lib instead */
        orderDetails: {
            paths: ['my-account/order/:orderCode'],
            paramsMapping: { orderCode: 'code' },
        },
        /** @deprecated since 4.2, use order lib instead */
        orderGuest: {
            paths: ['guest/order/:orderCode'],
            paramsMapping: { orderCode: 'code' },
        },
        /** @deprecated since 4.2, use order lib instead */
        orderReturn: {
            paths: ['my-account/order/return/:orderCode'],
            paramsMapping: { orderCode: 'code' },
        },
        /** @deprecated since 4.2, use order lib instead */
        orderReturnConfirmation: {
            paths: ['my-account/order/return/confirmation/:orderCode'],
            paramsMapping: { orderCode: 'code' },
        },
        /** @deprecated since 4.2, use order lib instead */
        orderCancel: {
            paths: ['my-account/order/cancel/:orderCode'],
            paramsMapping: { orderCode: 'code' },
        },
        /** @deprecated since 4.2, use order lib instead */
        orderCancelConfirmation: {
            paths: ['my-account/order/cancel/confirmation/:orderCode'],
            paramsMapping: { orderCode: 'code' },
        },
        /** @deprecated since 4.2, use order lib instead */
        returnRequestDetails: {
            paths: ['my-account/return-request/:returnCode'],
            paramsMapping: { returnCode: 'rma' },
        },
        coupons: { paths: ['my-account/coupons'] },
        couponClaim: {
            paths: ['my-account/coupon/claim/:couponCode'],
            paramsMapping: { couponCode: 'code' },
        },
        /** @deprecated since 4.2, use order lib instead */
        replenishmentOrders: {
            paths: ['my-account/my-replenishments'],
        },
        /** @deprecated since 4.2, use order lib instead */
        replenishmentDetails: {
            paths: ['my-account/my-replenishment/:replenishmentOrderCode'],
            paramsMapping: { replenishmentOrderCode: 'replenishmentOrderCode' },
        },
    };
    var defaultRoutingConfig = {
        routing: {
            routes: defaultStorefrontRoutesConfig,
        },
    };

    var RoutingModule = /** @class */ (function () {
        function RoutingModule() {
        }
        RoutingModule.forRoot = function () {
            return {
                ngModule: RoutingModule,
                providers: [i1.provideDefaultConfig(defaultRoutingConfig)],
            };
        };
        return RoutingModule;
    }());
    RoutingModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: RoutingModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    RoutingModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: RoutingModule, imports: [i1__namespace.RoutingModule, CmsRouteModule] });
    RoutingModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: RoutingModule, imports: [[i1.RoutingModule.forRoot(), CmsRouteModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: RoutingModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [i1.RoutingModule.forRoot(), CmsRouteModule],
                    }]
            }] });

    /**
     * Matches the pattern '[ ** / ] marker / :paramName'
     *
     * @param marker phrase that indicates the start of the match
     * @param paramName name of the parameter present after the marker
     * @param precedingParamName name of the parameter for every preceding url segment
     *        i.e. `param` will result in `param0`, `param1`, ...
     */
    function getSuffixUrlMatcher(_a) {
        var marker = _a.marker, paramName = _a.paramName, precedingParamName = _a.precedingParamName;
        precedingParamName = precedingParamName || 'param';
        var matcher = function suffixUrlMatcher(segments) {
            var _a;
            var markerIndex = findLastIndex(segments, function (_a) {
                var path = _a.path;
                return path === marker;
            });
            var isMarkerLastSegment = markerIndex === segments.length - 1;
            if (markerIndex === -1 || isMarkerLastSegment) {
                return null;
            }
            var paramIndex = markerIndex + 1;
            var posParams = (_a = {},
                _a[paramName] = segments[paramIndex],
                _a);
            for (var i = 0; i < markerIndex; i++) {
                posParams["" + precedingParamName + i] = segments[i];
            }
            return { consumed: segments.slice(0, paramIndex + 1), posParams: posParams };
        };
        if (i0.isDevMode()) {
            matcher['_suffixRouteConfig'] = { marker: marker, paramName: paramName, precedingParamName: precedingParamName }; // property added for easier debugging of routes
        }
        return matcher;
    }
    function findLastIndex(elements, predicate) {
        for (var index = elements.length - 1; index >= 0; index--) {
            if (predicate(elements[index])) {
                return index;
            }
        }
        return -1;
    }

    var PageMetaLinkService = /** @class */ (function () {
        function PageMetaLinkService(winRef, rendererFactory) {
            this.winRef = winRef;
            this.rendererFactory = rendererFactory;
        }
        /**
         * Adds a canonical link element to the document head.
         *
         * If an id is provided, the link will be updated.
         * If no url is provided, the link element will be deleted.
         */
        PageMetaLinkService.prototype.setCanonicalLink = function (url) {
            var link = this.winRef.document.querySelector('link[rel="canonical"]');
            if (!url) {
                // Removing the link is an edge case, but useful if the canonical url
                // is created in CSR while developing/testing.
                link === null || link === void 0 ? void 0 : link.remove();
                return;
            }
            if (!link) {
                link = this.renderer.createElement('link');
                link.rel = 'canonical';
                link.href = url;
                this.renderer.appendChild(this.winRef.document.head, link);
            }
            else {
                link === null || link === void 0 ? void 0 : link.setAttribute('href', url);
            }
        };
        Object.defineProperty(PageMetaLinkService.prototype, "renderer", {
            get: function () {
                return this.rendererFactory.createRenderer(null, null);
            },
            enumerable: false,
            configurable: true
        });
        return PageMetaLinkService;
    }());
    PageMetaLinkService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PageMetaLinkService, deps: [{ token: i1__namespace.WindowRef }, { token: i0__namespace.RendererFactory2 }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    PageMetaLinkService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PageMetaLinkService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PageMetaLinkService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace.WindowRef }, { type: i0__namespace.RendererFactory2 }]; } });

    var SeoMetaService = /** @class */ (function () {
        function SeoMetaService(ngTitle, ngMeta, pageMetaService, pageMetaLinkService) {
            this.ngTitle = ngTitle;
            this.ngMeta = ngMeta;
            this.pageMetaService = pageMetaService;
            this.pageMetaLinkService = pageMetaLinkService;
        }
        SeoMetaService.prototype.init = function () {
            var _this = this;
            this.subscription = this.pageMetaService
                .getMeta()
                .pipe(operators.filter(i1.isNotNullable))
                .subscribe(function (meta) { return (_this.meta = meta); });
        };
        Object.defineProperty(SeoMetaService.prototype, "meta", {
            set: function (meta) {
                this.title = meta.title;
                this.description = meta.description;
                this.image = meta.image;
                this.robots = meta.robots;
                this.canonicalUrl = meta.canonicalUrl;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(SeoMetaService.prototype, "title", {
            set: function (title) {
                this.ngTitle.setTitle(title || '');
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(SeoMetaService.prototype, "description", {
            set: function (value) {
                if (value) {
                    this.addTag({ name: 'description', content: value || '' });
                }
                else {
                    this.ngMeta.removeTag('name="description"');
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(SeoMetaService.prototype, "image", {
            set: function (imageUrl) {
                if (imageUrl) {
                    this.addTag({ name: 'og:image', content: imageUrl });
                }
                else {
                    this.ngMeta.removeTag('name="og:image"');
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(SeoMetaService.prototype, "robots", {
            set: function (value) {
                if (value && value.length > 0) {
                    this.addTag({ name: 'robots', content: value.join(', ') });
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(SeoMetaService.prototype, "canonicalUrl", {
            /**
             * Add the canonical Url to the head of the page.
             *
             * If the canonical url already exists the link is removed. This is quite
             * unlikely though, since canonical links are (typically) only added in SSR.
             */
            set: function (url) {
                var _a;
                (_a = this.pageMetaLinkService) === null || _a === void 0 ? void 0 : _a.setCanonicalLink(url);
            },
            enumerable: false,
            configurable: true
        });
        SeoMetaService.prototype.addTag = function (meta) {
            if (meta.content) {
                this.ngMeta.updateTag(meta);
            }
        };
        SeoMetaService.prototype.ngOnDestroy = function () {
            if (this.subscription) {
                this.subscription.unsubscribe();
            }
        };
        return SeoMetaService;
    }());
    SeoMetaService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SeoMetaService, deps: [{ token: i1__namespace$2.Title }, { token: i1__namespace$2.Meta }, { token: i1__namespace.PageMetaService }, { token: PageMetaLinkService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    SeoMetaService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SeoMetaService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SeoMetaService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace$2.Title }, { type: i1__namespace$2.Meta }, { type: i1__namespace.PageMetaService }, { type: PageMetaLinkService }]; } });

    var defaultSeoConfig = {
        seo: {
            structuredData: {
                disableInDevMode: true,
            },
        },
    };

    var SeoConfig = /** @class */ (function () {
        function SeoConfig() {
        }
        return SeoConfig;
    }());
    SeoConfig.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SeoConfig, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    SeoConfig.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SeoConfig, providedIn: 'root', useExisting: i1.Config });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SeoConfig, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                        useExisting: i1.Config,
                    }]
            }] });

    var htmlLangProvider = {
        provide: i0.APP_INITIALIZER,
        multi: true,
        useFactory: setHtmlLangAttribute,
        deps: [i1.WindowRef, i1.LanguageService],
    };
    /**
     * Sets active language in <html lang="">
     */
    function setHtmlLangAttribute(winRef, languageService) {
        var result = function () {
            languageService.getActive().subscribe(function (lang) {
                winRef.document.documentElement.lang = lang.replace(/_/g, '-');
            });
        };
        return result;
    }

    var JsonLdScriptFactory = /** @class */ (function () {
        function JsonLdScriptFactory(platformId, winRef, rendererFactory, sanitizer, config) {
            this.platformId = platformId;
            this.winRef = winRef;
            this.rendererFactory = rendererFactory;
            this.sanitizer = sanitizer;
            this.config = config;
        }
        JsonLdScriptFactory.prototype.build = function (schema) {
            if (schema && this.isJsonLdRequired()) {
                this.getJsonLdScriptElement().innerHTML = this.sanitize(schema);
            }
        };
        /**
         * Indicates whether json ld data should be generated.
         *
         * This is only required on the server, but can be enabled in dev mode.
         */
        JsonLdScriptFactory.prototype.isJsonLdRequired = function () {
            var _a, _b;
            return (!i3.isPlatformBrowser(this.platformId) ||
                (i0.isDevMode() && !((_b = (_a = this.config.seo) === null || _a === void 0 ? void 0 : _a.structuredData) === null || _b === void 0 ? void 0 : _b.disableInDevMode)));
        };
        /**
         * Creates a json-ld script element. The element is created one, and appended
         * to the html body element.
         *
         * ```html
         * <script id="json-ld" type="application/ld+json">
         * </script>
         * ```
         */
        JsonLdScriptFactory.prototype.getJsonLdScriptElement = function () {
            var id = 'json-ld';
            var scriptElement = (this.winRef.document.getElementById(id));
            if (!scriptElement) {
                var renderer = this.rendererFactory.createRenderer(null, null);
                var script = renderer.createElement('script');
                script.id = id;
                script.type = 'application/ld+json';
                renderer.appendChild(this.winRef.document.body, script);
                scriptElement = script;
            }
            return scriptElement;
        };
        /**
         * Sanitizes the given json-ld schema by leveraging the angular HTML sanitizer.
         *
         * The given schema is not trusted, as malicious code could be injected (XSS)
         * into the json-ld script.
         */
        JsonLdScriptFactory.prototype.sanitize = function (schema) {
            var _this = this;
            return JSON.stringify(schema, function (_key, value) { return typeof value === 'string'
                ? _this.sanitizer.sanitize(i0.SecurityContext.HTML, value)
                : value; });
        };
        return JsonLdScriptFactory;
    }());
    JsonLdScriptFactory.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: JsonLdScriptFactory, deps: [{ token: i0.PLATFORM_ID }, { token: i1__namespace.WindowRef }, { token: i0__namespace.RendererFactory2 }, { token: i1__namespace$2.DomSanitizer }, { token: SeoConfig }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    JsonLdScriptFactory.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: JsonLdScriptFactory, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: JsonLdScriptFactory, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () {
            return [{ type: undefined, decorators: [{
                            type: i0.Inject,
                            args: [i0.PLATFORM_ID]
                        }] }, { type: i1__namespace.WindowRef }, { type: i0__namespace.RendererFactory2 }, { type: i1__namespace$2.DomSanitizer }, { type: SeoConfig }];
        } });

    /**
     * Low level directive that adds a json-ld script tag to the component.
     * This code bypasses the strict XSS security, as otherwise we're not able
     * to append a script tag with JS inside.
     *
     * This helper directive is actually not used in Spartacus, as Spartacus
     * appends json-ld the data to the document body.
     *
     * This directive can however be used by merchants to write static schema data
     * to the DOM in a save way.
     */
    var JsonLdDirective = /** @class */ (function () {
        function JsonLdDirective(jsonLdScriptFactory, sanitizer) {
            this.jsonLdScriptFactory = jsonLdScriptFactory;
            this.sanitizer = sanitizer;
        }
        Object.defineProperty(JsonLdDirective.prototype, "cxJsonLd", {
            /**
             * Writes the schema data to a json-ld script element.
             */
            set: function (schema) {
                this.jsonLD = this.generateJsonLdScript(schema);
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Returns the json-ld script tag with the schema data. The script is
         * _bypassing_ sanitization explicitly.
         */
        JsonLdDirective.prototype.generateJsonLdScript = function (schema) {
            if (schema && this.jsonLdScriptFactory.isJsonLdRequired()) {
                var sanitizedSchema = this.jsonLdScriptFactory.sanitize(schema);
                var html = "<script type=\"application/ld+json\">" + sanitizedSchema + "</script>";
                return this.sanitizer.bypassSecurityTrustHtml(html);
            }
        };
        return JsonLdDirective;
    }());
    JsonLdDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: JsonLdDirective, deps: [{ token: JsonLdScriptFactory }, { token: i1__namespace$2.DomSanitizer }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    JsonLdDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.5", type: JsonLdDirective, selector: "[cxJsonLd]", inputs: { cxJsonLd: "cxJsonLd" }, host: { properties: { "innerHTML": "this.jsonLD" } }, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: JsonLdDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        selector: '[cxJsonLd]',
                    }]
            }], ctorParameters: function () { return [{ type: JsonLdScriptFactory }, { type: i1__namespace$2.DomSanitizer }]; }, propDecorators: { cxJsonLd: [{
                    type: i0.Input
                }], jsonLD: [{
                    type: i0.HostBinding,
                    args: ['innerHTML']
                }] } });

    /**
     * Injection token to extend schema builders for adding structural data (json-ld).
     *
     * Some builders (i.e. `JSONLD_PRODUCT_BUILDER`) might have additional
     * lower level builder to further extend the schema.
     */
    var SCHEMA_BUILDER = new i0.InjectionToken('SchemaBuilderToken');
    /**
     * Injection token to add specific json-ld builders for product related schemas.
     * See see https://schema.org/product for more information.
     */
    var JSONLD_PRODUCT_BUILDER = new i0.InjectionToken('JsonLdProductBuilderToken');

    /**
     * Factory service that is used to build the structured data for
     * all configured schema builders.
     */
    var StructuredDataFactory = /** @class */ (function () {
        function StructuredDataFactory(scriptBuilder, builders) {
            this.scriptBuilder = scriptBuilder;
            this.builders = builders;
            this.subscription = new rxjs.Subscription();
        }
        /**
         * Initiates the build of structured data by collecting all schema
         * builders.
         */
        StructuredDataFactory.prototype.build = function () {
            var _this = this;
            if (this.scriptBuilder.isJsonLdRequired() && this.builders) {
                this.subscription.add(this.collectSchemas().subscribe(function (schema) {
                    _this.scriptBuilder.build(schema);
                }));
            }
        };
        /**
         * Collects all schema builders and observe their structured data.
         */
        StructuredDataFactory.prototype.collectSchemas = function () {
            return rxjs.combineLatest(this.builders.map(function (builder) { return builder.build(); }));
        };
        StructuredDataFactory.prototype.ngOnDestroy = function () {
            this.subscription.unsubscribe();
        };
        return StructuredDataFactory;
    }());
    StructuredDataFactory.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: StructuredDataFactory, deps: [{ token: JsonLdScriptFactory }, { token: SCHEMA_BUILDER, optional: true }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    StructuredDataFactory.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: StructuredDataFactory, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: StructuredDataFactory, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () {
            return [{ type: JsonLdScriptFactory }, { type: undefined, decorators: [{
                            type: i0.Optional
                        }, {
                            type: i0.Inject,
                            args: [SCHEMA_BUILDER]
                        }] }];
        } });

    /**
     * Factory to build the structure data
     * without any interaction with the UI.
     */
    function getStructuredDataFactory(injector) {
        var result = function () {
            var factory = injector.get(StructuredDataFactory);
            factory.build();
        };
        return result;
    }
    var StructuredDataModule = /** @class */ (function () {
        function StructuredDataModule() {
        }
        return StructuredDataModule;
    }());
    StructuredDataModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: StructuredDataModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    StructuredDataModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: StructuredDataModule, declarations: [JsonLdDirective], imports: [i3.CommonModule], exports: [JsonLdDirective] });
    StructuredDataModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: StructuredDataModule, providers: [
            {
                provide: i0.APP_INITIALIZER,
                useFactory: getStructuredDataFactory,
                deps: [i0.Injector],
                multi: true,
            },
        ], imports: [[i3.CommonModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: StructuredDataModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [i3.CommonModule],
                        declarations: [JsonLdDirective],
                        exports: [JsonLdDirective],
                        providers: [
                            {
                                provide: i0.APP_INITIALIZER,
                                useFactory: getStructuredDataFactory,
                                deps: [i0.Injector],
                                multi: true,
                            },
                        ],
                    }]
            }] });

    function initSeoService(injector) {
        var result = function () {
            var service = injector.get(SeoMetaService);
            service.init();
        };
        return result;
    }
    var SeoModule = /** @class */ (function () {
        function SeoModule() {
        }
        return SeoModule;
    }());
    SeoModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SeoModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    SeoModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SeoModule, imports: [StructuredDataModule] });
    SeoModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SeoModule, providers: [
            i1.provideDefaultConfig(defaultSeoConfig),
            {
                provide: i0.APP_INITIALIZER,
                useFactory: initSeoService,
                deps: [i0.Injector],
                multi: true,
            },
            htmlLangProvider,
        ], imports: [[StructuredDataModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SeoModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [StructuredDataModule],
                        providers: [
                            i1.provideDefaultConfig(defaultSeoConfig),
                            {
                                provide: i0.APP_INITIALIZER,
                                useFactory: initSeoService,
                                deps: [i0.Injector],
                                multi: true,
                            },
                            htmlLangProvider,
                        ],
                    }]
            }] });

    var BreadcrumbSchemaBuilder = /** @class */ (function () {
        function BreadcrumbSchemaBuilder(pageMetaService) {
            this.pageMetaService = pageMetaService;
        }
        BreadcrumbSchemaBuilder.prototype.build = function () {
            var _this = this;
            return this.pageMetaService
                .getMeta()
                .pipe(operators.map(function (pageMeta) { return _this.collect(pageMeta); }));
        };
        BreadcrumbSchemaBuilder.prototype.collect = function (pageMeta) {
            if (!(pageMeta === null || pageMeta === void 0 ? void 0 : pageMeta.breadcrumbs)) {
                return;
            }
            var crumbs = pageMeta.breadcrumbs.map(function (crumb, index) {
                return {
                    '@type': 'ListItem',
                    position: index + 1,
                    item: {
                        '@id': crumb.link,
                        name: crumb.label,
                    },
                };
            });
            if (pageMeta.title) {
                crumbs.push({
                    '@type': 'ListItem',
                    position: crumbs.length + 1,
                    item: {
                        '@id': pageMeta.title,
                        name: pageMeta.title,
                    },
                });
            }
            return {
                '@context': 'http://schema.org',
                '@type': 'BreadcrumbList',
                itemListElement: crumbs,
            };
        };
        return BreadcrumbSchemaBuilder;
    }());
    BreadcrumbSchemaBuilder.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: BreadcrumbSchemaBuilder, deps: [{ token: i1__namespace.PageMetaService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    BreadcrumbSchemaBuilder.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: BreadcrumbSchemaBuilder, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: BreadcrumbSchemaBuilder, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace.PageMetaService }]; } });

    /**
     * Builds the basic structured data for the product, see https://schema.org/product.
     * This builder includes data for sku number, name, description, brand and main image.
     */
    var JsonLdBaseProductBuilder = /** @class */ (function () {
        function JsonLdBaseProductBuilder() {
        }
        JsonLdBaseProductBuilder.prototype.build = function (product) {
            return rxjs.of(Object.assign(Object.assign(Object.assign({}, this.getProductBase(product)), this.getProductBrand(product)), this.getProductImage(product)));
        };
        /**
         * Returns the product sku, name and description.
         */
        JsonLdBaseProductBuilder.prototype.getProductBase = function (product) {
            var result = { sku: product.code };
            if (product.name) {
                result.name = product.name;
            }
            if (product.summary) {
                result.description = product.summary;
            }
            return result;
        };
        /**
         * Returns the image object with the main product image url.
         *
         * If the image is not available, an empty object is returned.
         */
        JsonLdBaseProductBuilder.prototype.getProductImage = function (product) {
            var _a, _b, _c;
            var image = (_c = (_b = (_a = product.images) === null || _a === void 0 ? void 0 : _a.PRIMARY) === null || _b === void 0 ? void 0 : _b['zoom']) === null || _c === void 0 ? void 0 : _c.url;
            return image ? { image: image } : {};
        };
        /**
         * Returns the brand object with the product manufacturer.
         *
         * If the brand is not available, an empty object is returned.
         */
        JsonLdBaseProductBuilder.prototype.getProductBrand = function (product) {
            var brand = product.manufacturer;
            return brand ? { brand: brand } : {};
        };
        return JsonLdBaseProductBuilder;
    }());
    JsonLdBaseProductBuilder.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: JsonLdBaseProductBuilder, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    JsonLdBaseProductBuilder.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: JsonLdBaseProductBuilder, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: JsonLdBaseProductBuilder, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }] });

    /**
     * Builds the structured data for the product offer, see https://schema.org/offers.
     * The data includes the price, currency and availability level.
     */
    var JsonLdProductOfferBuilder = /** @class */ (function () {
        function JsonLdProductOfferBuilder() {
        }
        JsonLdProductOfferBuilder.prototype.build = function (product) {
            var _a;
            var schema = { '@type': 'Offer' };
            if ((_a = product.price) === null || _a === void 0 ? void 0 : _a.value) {
                schema.price = product.price.value;
                if (product.price.currencyIso) {
                    schema.priceCurrency = product.price.currencyIso;
                }
            }
            if (product.stock && product.stock.stockLevelStatus) {
                schema.availability =
                    product.stock.stockLevelStatus === 'inStock' ? 'InStock' : 'OutOfStock';
            }
            return rxjs.of({ offers: schema });
        };
        return JsonLdProductOfferBuilder;
    }());
    JsonLdProductOfferBuilder.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: JsonLdProductOfferBuilder, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    JsonLdProductOfferBuilder.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: JsonLdProductOfferBuilder, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: JsonLdProductOfferBuilder, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }] });

    /**
     * Builds the structured data for the product reviews, see https://schema.org/Review.
     * The data includes the aggregated product rating and the individual reviews.
     */
    var JsonLdProductReviewBuilder = /** @class */ (function () {
        function JsonLdProductReviewBuilder(reviewService, config) {
            this.reviewService = reviewService;
            this.config = config;
        }
        JsonLdProductReviewBuilder.prototype.build = function (product) {
            var _this = this;
            return this.reviewService.getByProductCode(product.code).pipe(operators.map(function (reviews) { return (reviews === null || reviews === void 0 ? void 0 : reviews.length) > 0
                ? {
                    aggregateRating: _this.buildAggregatedReviews(product, reviews),
                    review: reviews.map(function (review) { return _this.buildReviews(review); }),
                }
                : {}; }));
        };
        JsonLdProductReviewBuilder.prototype.buildAggregatedReviews = function (product, reviews) {
            var aggregated = {
                '@type': 'AggregateRating',
            };
            if (product.averageRating) {
                aggregated.ratingValue = product.averageRating;
            }
            if (reviews) {
                aggregated.ratingCount = reviews.filter(function (rev) { return !!rev.rating; }).length;
                aggregated.reviewCount = reviews.filter(function (rev) { return !!rev.comment; }).length;
            }
            return aggregated;
        };
        JsonLdProductReviewBuilder.prototype.buildReviews = function (review) {
            var reviewSchema = {
                '@type': 'review',
            };
            if (review.principal && review.principal.name) {
                reviewSchema.author = review.principal.name;
            }
            if (review.date) {
                var date = new Date(review.date);
                reviewSchema.datePublished = date.getFullYear() + "-" + (date.getMonth() + 1) + "-" + date.getDate();
            }
            if (review.headline) {
                reviewSchema.name = review.headline;
            }
            if (review.comment) {
                reviewSchema.description = review.comment;
            }
            if (review.rating) {
                reviewSchema.reviewRating = {
                    '@type': 'Rating',
                    ratingValue: review.rating.toString(),
                };
            }
            return reviewSchema;
        };
        return JsonLdProductReviewBuilder;
    }());
    JsonLdProductReviewBuilder.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: JsonLdProductReviewBuilder, deps: [{ token: i1__namespace.ProductReviewService }, { token: SeoConfig }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    JsonLdProductReviewBuilder.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: JsonLdProductReviewBuilder, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: JsonLdProductReviewBuilder, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace.ProductReviewService }, { type: SeoConfig }]; } });

    /**
     * Adds the minimal structured data for the product, see https://schema.org/product.
     * The actual data collection is delegated to `JsonLdBuilder`s, which can be injected
     * using the `JSONLD_PRODUCT_BUILDER` token.
     */
    var ProductSchemaBuilder = /** @class */ (function () {
        function ProductSchemaBuilder(currentProduct, builders) {
            this.currentProduct = currentProduct;
            this.builders = builders;
        }
        ProductSchemaBuilder.prototype.build = function () {
            var _this = this;
            return this.currentProduct.getProduct().pipe(operators.switchMap(function (product) {
                if (product) {
                    return rxjs.combineLatest(_this.collect(product)).pipe(operators.map(function (res) { return Object.assign.apply(Object, __spreadArray([{}], __read(res))); }));
                }
                return rxjs.of({});
            }));
        };
        ProductSchemaBuilder.prototype.collect = function (product) {
            if (!product || !product.code) {
                return [];
            }
            var builders = this.builders
                ? this.builders.map(function (builder) { return builder.build(product); })
                : [];
            return __spreadArray([
                rxjs.of({
                    '@context': 'http://schema.org',
                    '@type': 'Product',
                })
            ], __read(builders));
        };
        return ProductSchemaBuilder;
    }());
    ProductSchemaBuilder.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductSchemaBuilder, deps: [{ token: CurrentProductService }, { token: JSONLD_PRODUCT_BUILDER, optional: true }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ProductSchemaBuilder.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductSchemaBuilder, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductSchemaBuilder, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () {
            return [{ type: CurrentProductService }, { type: undefined, decorators: [{
                            type: i0.Optional
                        }, {
                            type: i0.Inject,
                            args: [JSONLD_PRODUCT_BUILDER]
                        }] }];
        } });

    /**
     * Provides several standard json-ld builders that contribute
     * to collecting and building json-ld data.
     */
    var JsonLdBuilderModule = /** @class */ (function () {
        function JsonLdBuilderModule() {
        }
        return JsonLdBuilderModule;
    }());
    JsonLdBuilderModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: JsonLdBuilderModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    JsonLdBuilderModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: JsonLdBuilderModule });
    JsonLdBuilderModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: JsonLdBuilderModule, providers: [
            {
                provide: SCHEMA_BUILDER,
                useExisting: ProductSchemaBuilder,
                multi: true,
            },
            {
                provide: SCHEMA_BUILDER,
                useExisting: BreadcrumbSchemaBuilder,
                multi: true,
            },
            // lower level json-ld builder classes offering fine-grained control
            // for product related schemas
            {
                provide: JSONLD_PRODUCT_BUILDER,
                useExisting: JsonLdBaseProductBuilder,
                multi: true,
            },
            {
                provide: JSONLD_PRODUCT_BUILDER,
                useExisting: JsonLdProductOfferBuilder,
                multi: true,
            },
            {
                provide: JSONLD_PRODUCT_BUILDER,
                useExisting: JsonLdProductReviewBuilder,
                multi: true,
            },
        ] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: JsonLdBuilderModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        providers: [
                            {
                                provide: SCHEMA_BUILDER,
                                useExisting: ProductSchemaBuilder,
                                multi: true,
                            },
                            {
                                provide: SCHEMA_BUILDER,
                                useExisting: BreadcrumbSchemaBuilder,
                                multi: true,
                            },
                            // lower level json-ld builder classes offering fine-grained control
                            // for product related schemas
                            {
                                provide: JSONLD_PRODUCT_BUILDER,
                                useExisting: JsonLdBaseProductBuilder,
                                multi: true,
                            },
                            {
                                provide: JSONLD_PRODUCT_BUILDER,
                                useExisting: JsonLdProductOfferBuilder,
                                multi: true,
                            },
                            {
                                provide: JSONLD_PRODUCT_BUILDER,
                                useExisting: JsonLdProductReviewBuilder,
                                multi: true,
                            },
                        ],
                    }]
            }] });

    exports.PageSection = void 0;
    (function (PageSection) {
        PageSection["HEADER"] = "header";
        PageSection["FOOTER"] = "footer";
        PageSection["NAVIGATION"] = "navigation";
    })(exports.PageSection || (exports.PageSection = {}));

    /**
     * Helper function to simplify the creation of static CMS structure (`CmsStructureConfig`).
     * The helper function leverage the `provideConfig`, and is only providing an easy way to
     * generate the cms structure. The function creates a configuration structure for components,
     * page slot and page template. The following example adds a component to a page slot:
     *
     * ```ts
     * provideCmsStructure({
     *   componentId: 'LoginComponent',
     *   pageSlotPosition: 'SiteLogin'
     * })
     * ```
     *
     * @param options.componentId component identifier is used to provide component structure
     * @param options.pageSlotPosition page slot position is used to provide the slot configuration
     * @param options.pageTemplate the page template is used to provide the page slot to the given page template
     * @param options.section the section is used to provide the page slot to the given section
     * @param options.breakpoint the breakpoint is used to provide the page slot for a specific breakpoint
     */
    function provideCmsStructure(options) {
        return i1.provideConfig(Object.assign(Object.assign({}, buildCmsStructure(options)), buildLayoutConfig(options)));
    }
    /**
     * @private
     */
    function buildCmsStructure(_a) {
        var _b, _c;
        var _d = _a === void 0 ? {} : _a, componentId = _d.componentId, pageSlotPosition = _d.pageSlotPosition;
        var config = { cmsStructure: {} };
        if (componentId) {
            config.cmsStructure = {
                components: (_b = {},
                    _b[componentId] = {
                        typeCode: componentId,
                        flexType: componentId,
                    },
                    _b),
            };
        }
        if (componentId && pageSlotPosition) {
            config.cmsStructure.slots = (_c = {},
                _c[pageSlotPosition] = { componentIds: [componentId] },
                _c);
        }
        return config;
    }
    /**
     * @private
     */
    function buildLayoutConfig(_a) {
        var _b, _c;
        var _d = _a === void 0 ? {} : _a, pageTemplate = _d.pageTemplate, pageSlotPosition = _d.pageSlotPosition, breakpoint = _d.breakpoint, section = _d.section;
        var layoutConfig = {};
        if (pageTemplate && pageSlotPosition) {
            var pageTemplateSlots = {};
            if (breakpoint) {
                pageTemplateSlots[breakpoint] = {
                    slots: [pageSlotPosition],
                };
            }
            else {
                pageTemplateSlots.slots = [pageSlotPosition];
            }
            layoutConfig.layoutSlots = (_b = {},
                _b[pageTemplate] = pageTemplateSlots,
                _b);
        }
        if (section && pageSlotPosition) {
            var sectionSlots = {};
            if (breakpoint) {
                sectionSlots[breakpoint] = { slots: [pageSlotPosition] };
            }
            else {
                sectionSlots.slots = [pageSlotPosition];
            }
            if (layoutConfig.layoutSlots) {
                layoutConfig.layoutSlots[section] = sectionSlots;
            }
            else {
                layoutConfig.layoutSlots = (_c = {},
                    _c[section] = sectionSlots,
                    _c);
            }
        }
        return layoutConfig;
    }

    /**
     * Generic carousel that renders CMS Components.
     */
    var BannerCarouselComponent = /** @class */ (function () {
        function BannerCarouselComponent(componentData, cmsService) {
            var _this = this;
            this.componentData = componentData;
            this.cmsService = cmsService;
            this.componentData$ = this.componentData.data$.pipe(operators.filter(Boolean), operators.tap(function (d) { return (_this.theme = d.effect + "-theme"); }));
            this.items$ = this.componentData$.pipe(operators.map(function (data) { return data.banners.trim().split(' '); }), operators.map(function (codes) { return codes.map(function (code) { return _this.cmsService.getComponentData(code); }); }));
            /**
             * Adds a specific theme for the carousel. The effect can be
             * used in CSS customisations.
             */
            this.theme = '';
        }
        /**
         * Returns an Obervable with an Array of Observables. This is done, so that
         * the component UI could consider to lazy load the UI components when they're
         * in the viewpoint.
         */
        BannerCarouselComponent.prototype.getItems = function () {
            return this.items$;
        };
        return BannerCarouselComponent;
    }());
    BannerCarouselComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: BannerCarouselComponent, deps: [{ token: CmsComponentData }, { token: i1__namespace.CmsService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    BannerCarouselComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: BannerCarouselComponent, selector: "cx-banner-carousel", host: { properties: { "class": "this.theme" } }, ngImport: i0__namespace, template: "<cx-carousel\n  [items]=\"getItems() | async\"\n  [template]=\"template\"\n  itemWidth=\"100%\"\n  class=\"inline-navigation\"\n></cx-carousel>\n\n<ng-template #template let-item=\"item\">\n  <ng-container\n    [cxComponentWrapper]=\"{\n      flexType: item.typeCode,\n      typeCode: item.typeCode,\n      uid: item?.uid\n    }\"\n  >\n  </ng-container>\n</ng-template>\n", components: [{ type: CarouselComponent, selector: "cx-carousel", inputs: ["title", "items", "template", "itemWidth", "hideIndicators", "indicatorIcon", "previousIcon", "nextIcon"] }], directives: [{ type: ComponentWrapperDirective, selector: "[cxComponentWrapper]", inputs: ["cxComponentWrapper"], outputs: ["cxComponentRef"] }], pipes: { "async": i3__namespace.AsyncPipe }, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: BannerCarouselComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-banner-carousel',
                        templateUrl: 'banner-carousel.component.html',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], ctorParameters: function () { return [{ type: CmsComponentData }, { type: i1__namespace.CmsService }]; }, propDecorators: { theme: [{
                    type: i0.HostBinding,
                    args: ['class']
                }] } });

    var BannerCarouselModule = /** @class */ (function () {
        function BannerCarouselModule() {
        }
        return BannerCarouselModule;
    }());
    BannerCarouselModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: BannerCarouselModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    BannerCarouselModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: BannerCarouselModule, declarations: [BannerCarouselComponent], imports: [i3.CommonModule, PageComponentModule, CarouselModule, MediaModule], exports: [BannerCarouselComponent] });
    BannerCarouselModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: BannerCarouselModule, providers: [
            i1.provideDefaultConfig({
                cmsComponents: {
                    RotatingImagesComponent: {
                        component: BannerCarouselComponent,
                    },
                },
            }),
        ], imports: [[i3.CommonModule, PageComponentModule, CarouselModule, MediaModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: BannerCarouselModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [i3.CommonModule, PageComponentModule, CarouselModule, MediaModule],
                        providers: [
                            i1.provideDefaultConfig({
                                cmsComponents: {
                                    RotatingImagesComponent: {
                                        component: BannerCarouselComponent,
                                    },
                                },
                            }),
                        ],
                        declarations: [BannerCarouselComponent],
                        exports: [BannerCarouselComponent],
                    }]
            }] });

    var LinkComponent = /** @class */ (function () {
        function LinkComponent(component) {
            var _this = this;
            this.component = component;
            this.data$ = this.component.data$.pipe(operators.tap(function (data) { return (_this.styleClasses = data === null || data === void 0 ? void 0 : data.styleClasses); }));
        }
        /**
         * Returns `_blank` to force opening the link in a new window whenever the
         * `data.target` flag is set to `true`.
         */
        LinkComponent.prototype.getTarget = function (data) {
            return data.target === 'true' || data.target === true ? '_blank' : null;
        };
        return LinkComponent;
    }());
    LinkComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: LinkComponent, deps: [{ token: CmsComponentData }], target: i0__namespace.ɵɵFactoryTarget.Component });
    LinkComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: LinkComponent, selector: "cx-link", host: { properties: { "class": "this.styleClasses" } }, ngImport: i0__namespace, template: "<cx-generic-link\n  *ngIf=\"data$ | async as data\"\n  [url]=\"data.url\"\n  [style]=\"data.styleAttributes\"\n  [target]=\"getTarget(data)\"\n  >{{ data.linkName }}</cx-generic-link\n>\n", components: [{ type: GenericLinkComponent, selector: "cx-generic-link", inputs: ["url", "target", "id", "class", "style", "title"] }], directives: [{ type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "async": i3__namespace.AsyncPipe }, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: LinkComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-link',
                        templateUrl: './link.component.html',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], ctorParameters: function () { return [{ type: CmsComponentData }]; }, propDecorators: { styleClasses: [{
                    type: i0.HostBinding,
                    args: ['class']
                }] } });

    var LinkModule = /** @class */ (function () {
        function LinkModule() {
        }
        return LinkModule;
    }());
    LinkModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: LinkModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    LinkModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: LinkModule, declarations: [LinkComponent], imports: [i3.CommonModule, i1$1.RouterModule, GenericLinkModule], exports: [LinkComponent] });
    LinkModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: LinkModule, providers: [
            i1.provideDefaultConfig({
                cmsComponents: {
                    CMSLinkComponent: { component: LinkComponent },
                },
            }),
        ], imports: [[i3.CommonModule, i1$1.RouterModule, GenericLinkModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: LinkModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [i3.CommonModule, i1$1.RouterModule, GenericLinkModule],
                        providers: [
                            i1.provideDefaultConfig({
                                cmsComponents: {
                                    CMSLinkComponent: { component: LinkComponent },
                                },
                            }),
                        ],
                        declarations: [LinkComponent],
                        exports: [LinkComponent],
                    }]
            }] });

    var ParagraphComponent = /** @class */ (function () {
        function ParagraphComponent(component, router) {
            this.component = component;
            this.router = router;
        }
        ParagraphComponent.prototype.handleClick = function (event) {
            if (this.router && event.target instanceof HTMLAnchorElement) {
                var element = event.target;
                var href = element === null || element === void 0 ? void 0 : element.getAttribute('href');
                // Use router for internal link navigation
                if ((href === null || href === void 0 ? void 0 : href.indexOf('/')) === 0) {
                    event.preventDefault();
                    this.router.navigate(["/" + href]);
                }
            }
        };
        return ParagraphComponent;
    }());
    ParagraphComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ParagraphComponent, deps: [{ token: CmsComponentData }, { token: i1__namespace$1.Router }], target: i0__namespace.ɵɵFactoryTarget.Component });
    ParagraphComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: ParagraphComponent, selector: "cx-paragraph", host: { listeners: { "click": "handleClick($event)" } }, ngImport: i0__namespace, template: "<p\n  *ngIf=\"component.data$ | async as data\"\n  [innerHTML]=\"data.content | cxSupplementHashAnchors\"\n></p>\n", directives: [{ type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "cxSupplementHashAnchors": SupplementHashAnchorsPipe, "async": i3__namespace.AsyncPipe }, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ParagraphComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-paragraph',
                        templateUrl: './paragraph.component.html',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], ctorParameters: function () { return [{ type: CmsComponentData }, { type: i1__namespace$1.Router }]; }, propDecorators: { handleClick: [{
                    type: i0.HostListener,
                    args: ['click', ['$event']]
                }] } });

    var CmsParagraphModule = /** @class */ (function () {
        function CmsParagraphModule() {
        }
        return CmsParagraphModule;
    }());
    CmsParagraphModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CmsParagraphModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    CmsParagraphModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CmsParagraphModule, declarations: [ParagraphComponent], imports: [i3.CommonModule, i1$1.RouterModule, SupplementHashAnchorsModule], exports: [ParagraphComponent] });
    CmsParagraphModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CmsParagraphModule, providers: [
            i1.provideDefaultConfig({
                cmsComponents: {
                    CMSParagraphComponent: {
                        component: ParagraphComponent,
                    },
                    CMSTabParagraphComponent: {
                        component: ParagraphComponent,
                    },
                },
            }),
        ], imports: [[i3.CommonModule, i1$1.RouterModule, SupplementHashAnchorsModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CmsParagraphModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [i3.CommonModule, i1$1.RouterModule, SupplementHashAnchorsModule],
                        providers: [
                            i1.provideDefaultConfig({
                                cmsComponents: {
                                    CMSParagraphComponent: {
                                        component: ParagraphComponent,
                                    },
                                    CMSTabParagraphComponent: {
                                        component: ParagraphComponent,
                                    },
                                },
                            }),
                        ],
                        declarations: [ParagraphComponent],
                        exports: [ParagraphComponent],
                    }]
            }] });

    var TabParagraphContainerComponent = /** @class */ (function () {
        function TabParagraphContainerComponent(componentData, cmsService, winRef, breakpointService) {
            var _this = this;
            this.componentData = componentData;
            this.cmsService = cmsService;
            this.winRef = winRef;
            this.breakpointService = breakpointService;
            this.activeTabNum = 0;
            this.tabTitleParams = [];
            this.components$ = this.componentData.data$.pipe(operators.distinctUntilChanged(function (x, y) { return (x === null || x === void 0 ? void 0 : x.components) === (y === null || y === void 0 ? void 0 : y.components); }), operators.switchMap(function (data) {
                var _a;
                return rxjs.combineLatest(((_a = data === null || data === void 0 ? void 0 : data.components) !== null && _a !== void 0 ? _a : '').split(' ').map(function (component) { return _this.cmsService.getComponentData(component).pipe(operators.distinctUntilChanged(), operators.map(function (tab) {
                    if (!tab) {
                        return undefined;
                    }
                    if (!tab.flexType) {
                        tab = Object.assign(Object.assign({}, tab), { flexType: tab.typeCode });
                    }
                    return Object.assign(Object.assign({}, tab), { title: data.uid + ".tabs." + tab.uid });
                })); }));
            }));
        }
        TabParagraphContainerComponent.prototype.select = function (tabNum, event) {
            var _this = this;
            var _a;
            (_a = this.breakpointService) === null || _a === void 0 ? void 0 : _a.isDown(exports.BREAKPOINT.sm).pipe(operators.take(1)).subscribe(function (res) {
                var _a, _b;
                if (res) {
                    _this.activeTabNum = _this.activeTabNum === tabNum ? -1 : tabNum;
                    if (event && (event === null || event === void 0 ? void 0 : event.target)) {
                        var target = event.target;
                        var parentNode = target.parentNode;
                        (_b = (_a = _this.winRef) === null || _a === void 0 ? void 0 : _a.nativeWindow) === null || _b === void 0 ? void 0 : _b.scrollTo(0, parentNode.offsetTop);
                    }
                }
                else {
                    _this.activeTabNum = tabNum;
                }
            });
        };
        TabParagraphContainerComponent.prototype.ngOnInit = function () {
            var _a, _b, _c, _d, _e;
            this.activeTabNum =
                (_e = (_d = (_c = (_b = (_a = this.winRef) === null || _a === void 0 ? void 0 : _a.nativeWindow) === null || _b === void 0 ? void 0 : _b.history) === null || _c === void 0 ? void 0 : _c.state) === null || _d === void 0 ? void 0 : _d.activeTab) !== null && _e !== void 0 ? _e : this.activeTabNum;
        };
        TabParagraphContainerComponent.prototype.ngAfterViewInit = function () {
            // If the sub cms components data exist, the components created before ngAfterViewInit are called.
            // In this case, the title parameters are directly pulled from them.
            if (this.children.length > 0) {
                this.getTitleParams(this.children);
            }
        };
        TabParagraphContainerComponent.prototype.tabCompLoaded = function (componentRef) {
            this.tabTitleParams.push(componentRef.instance.tabTitleParam$);
        };
        TabParagraphContainerComponent.prototype.getTitleParams = function (children) {
            var _this = this;
            children.forEach(function (comp) {
                var _a;
                if ((_a = comp.cmpRef) === null || _a === void 0 ? void 0 : _a.instance.tabTitleParam$) {
                    _this.tabTitleParams.push(comp.cmpRef.instance.tabTitleParam$);
                }
                else {
                    _this.tabTitleParams.push(null);
                }
            });
        };
        TabParagraphContainerComponent.prototype.ngOnDestroy = function () {
            if (this.subscription) {
                this.subscription.unsubscribe();
            }
        };
        return TabParagraphContainerComponent;
    }());
    TabParagraphContainerComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: TabParagraphContainerComponent, deps: [{ token: CmsComponentData }, { token: i1__namespace.CmsService }, { token: i1__namespace.WindowRef }, { token: BreakpointService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    TabParagraphContainerComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: TabParagraphContainerComponent, selector: "cx-tab-paragraph-container", viewQueries: [{ propertyName: "children", predicate: ComponentWrapperDirective, descendants: true }], ngImport: i0__namespace, template: "<ng-container *ngIf=\"components$ | async as components\">\n  <ng-container *ngFor=\"let component of components; let i = index\">\n    <ng-container *ngIf=\"component\">\n      <button [class.active]=\"i === activeTabNum\" (click)=\"select(i, $event)\">\n        {{\n          component.title | cxTranslate: { param: tabTitleParams[i] | async }\n        }}\n      </button>\n    </ng-container>\n  </ng-container>\n\n  <ng-container *ngFor=\"let component of components; let i = index\">\n    <ng-container *ngIf=\"component\">\n      <div [class.active]=\"i === activeTabNum\">\n        <ng-template [cxOutlet]=\"component.flexType\" [cxOutletContext]=\"{}\">\n          <ng-container\n            [cxComponentWrapper]=\"component\"\n            (cxComponentRef)=\"tabCompLoaded($event)\"\n          ></ng-container>\n        </ng-template>\n      </div>\n    </ng-container>\n  </ng-container>\n</ng-container>\n", directives: [{ type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3__namespace.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: OutletDirective, selector: "[cxOutlet]", inputs: ["cxOutlet", "cxOutletContext", "cxOutletDefer"], outputs: ["loaded"] }, { type: ComponentWrapperDirective, selector: "[cxComponentWrapper]", inputs: ["cxComponentWrapper"], outputs: ["cxComponentRef"] }], pipes: { "async": i3__namespace.AsyncPipe, "cxTranslate": i1__namespace.TranslatePipe }, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: TabParagraphContainerComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-tab-paragraph-container',
                        templateUrl: './tab-paragraph-container.component.html',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], ctorParameters: function () { return [{ type: CmsComponentData }, { type: i1__namespace.CmsService }, { type: i1__namespace.WindowRef }, { type: BreakpointService }]; }, propDecorators: { children: [{
                    type: i0.ViewChildren,
                    args: [ComponentWrapperDirective]
                }] } });

    var TabParagraphContainerModule = /** @class */ (function () {
        function TabParagraphContainerModule() {
        }
        return TabParagraphContainerModule;
    }());
    TabParagraphContainerModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: TabParagraphContainerModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    TabParagraphContainerModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: TabParagraphContainerModule, declarations: [TabParagraphContainerComponent], imports: [i3.CommonModule, PageComponentModule, OutletModule, i1.I18nModule], exports: [TabParagraphContainerComponent] });
    TabParagraphContainerModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: TabParagraphContainerModule, providers: [
            i1.provideDefaultConfig({
                cmsComponents: {
                    CMSTabParagraphContainer: {
                        component: TabParagraphContainerComponent,
                    },
                },
            }),
        ], imports: [[i3.CommonModule, PageComponentModule, OutletModule, i1.I18nModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: TabParagraphContainerModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [i3.CommonModule, PageComponentModule, OutletModule, i1.I18nModule],
                        providers: [
                            i1.provideDefaultConfig({
                                cmsComponents: {
                                    CMSTabParagraphContainer: {
                                        component: TabParagraphContainerComponent,
                                    },
                                },
                            }),
                        ],
                        declarations: [TabParagraphContainerComponent],
                        exports: [TabParagraphContainerComponent],
                    }]
            }] });

    var AddressBookComponentService = /** @class */ (function () {
        function AddressBookComponentService(userAddressService) {
            this.userAddressService = userAddressService;
        }
        AddressBookComponentService.prototype.getAddresses = function () {
            return this.userAddressService.getAddresses();
        };
        AddressBookComponentService.prototype.getAddressesStateLoading = function () {
            return this.userAddressService.getAddressesLoading();
        };
        AddressBookComponentService.prototype.loadAddresses = function () {
            this.userAddressService.loadAddresses();
        };
        AddressBookComponentService.prototype.addUserAddress = function (address) {
            this.userAddressService.addUserAddress(address);
        };
        AddressBookComponentService.prototype.updateUserAddress = function (addressId, address) {
            this.userAddressService.updateUserAddress(addressId, address);
        };
        AddressBookComponentService.prototype.setAddressAsDefault = function (addressId) {
            this.userAddressService.setAddressAsDefault(addressId);
        };
        AddressBookComponentService.prototype.deleteUserAddress = function (addressId) {
            this.userAddressService.deleteUserAddress(addressId);
        };
        return AddressBookComponentService;
    }());
    AddressBookComponentService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AddressBookComponentService, deps: [{ token: i1__namespace.UserAddressService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    AddressBookComponentService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AddressBookComponentService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AddressBookComponentService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace.UserAddressService }]; } });

    var SuggestedAddressDialogComponent = /** @class */ (function () {
        function SuggestedAddressDialogComponent(modalService) {
            this.modalService = modalService;
            this.iconTypes = exports.ICON_TYPE;
        }
        SuggestedAddressDialogComponent.prototype.ngOnInit = function () {
            this.selectedAddress = this.suggestedAddresses.length
                ? this.suggestedAddresses[0]
                : this.enteredAddress;
        };
        SuggestedAddressDialogComponent.prototype.closeModal = function (reason) {
            this.modalService.closeActiveModal(reason);
        };
        return SuggestedAddressDialogComponent;
    }());
    SuggestedAddressDialogComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SuggestedAddressDialogComponent, deps: [{ token: ModalService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    SuggestedAddressDialogComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: SuggestedAddressDialogComponent, selector: "cx-suggested-addresses-dialog", inputs: { suggestedAddresses: "suggestedAddresses", enteredAddress: "enteredAddress" }, ngImport: i0__namespace, template: "<div class=\"cx-dialog-header modal-header\">\n  <div class=\"cx-dialog-title modal-title\">\n    {{ 'addressSuggestion.verifyYourAddress' | cxTranslate }}\n  </div>\n  <button\n    type=\"button\"\n    class=\"close\"\n    [attr.aria-label]=\"'common.close' | cxTranslate\"\n    (click)=\"closeModal()\"\n  >\n    <span aria-hidden=\"true\">\n      <cx-icon [type]=\"iconTypes.CLOSE\"></cx-icon>\n    </span>\n  </button>\n</div>\n<div class=\"cx-dialog-body modal-body\" ngForm>\n  <div class=\"container\">\n    <div class=\"row\">\n      <div class=\"cx-dialog-info col-md-12\">\n        <p>\n          {{ 'addressSuggestion.ensureAccuracySuggestChange' | cxTranslate }}\n          {{ 'addressSuggestion.chooseAddressToUse' | cxTranslate }}\n        </p>\n      </div>\n    </div>\n\n    <div class=\"row\">\n      <div class=\"cx-dialog-options col-md-12\">\n        <div\n          class=\"form-check\"\n          *ngFor=\"let suggestedAddress of suggestedAddresses; let i = index\"\n        >\n          <input\n            class=\"form-check-input\"\n            type=\"radio\"\n            name=\"selectedAddress\"\n            [(ngModel)]=\"selectedAddress\"\n            [value]=\"suggestedAddress\"\n            [id]=\"'suggested-addresses--suggested-' + i\"\n          />\n          <label\n            class=\"form-check-label cx-dialog-label\"\n            [for]=\"'suggested-addresses--suggested-' + i\"\n          >\n            {{ 'addressSuggestion.suggestedAddress' | cxTranslate }}\n            {{ suggestedAddresses?.length > 1 ? i + 1 : null }}\n          </label>\n          <div class=\"cx-dialog-suggested\">\n            {{ suggestedAddress?.firstName }} {{ suggestedAddress?.lastName\n            }}<br />\n            {{ suggestedAddress?.line1 }}<br />\n            <span>{{ suggestedAddress?.line2 }}</span\n            ><br />\n            {{ suggestedAddress?.town }} {{ suggestedAddress?.region?.isocode\n            }}<br />\n            {{ suggestedAddress?.postalCode }}\n          </div>\n        </div>\n        <div class=\"form-check\">\n          <input\n            class=\"form-check-input\"\n            type=\"radio\"\n            name=\"selectedAddress\"\n            [(ngModel)]=\"selectedAddress\"\n            [value]=\"enteredAddress\"\n            id=\"suggested-addresses--entered\"\n          />\n          <label\n            class=\"form-check-label cx-dialog-label\"\n            for=\"suggested-addresses--entered\"\n          >\n            {{ 'addressSuggestion.enteredAddress' | cxTranslate }}\n          </label>\n          <div class=\"cx-dialog-entered\">\n            {{ enteredAddress?.firstName }} {{ enteredAddress?.lastName }}<br />\n            {{ enteredAddress?.line1 }}<br />\n            <span>{{ enteredAddress?.line2 }}</span\n            ><br />\n            {{ enteredAddress?.town }} {{ enteredAddress?.region?.isocode\n            }}<br />\n            {{ enteredAddress?.postalCode }}\n          </div>\n        </div>\n      </div>\n    </div>\n    <div class=\"row\">\n      <div class=\"cx-dialog-actions col-sm-12 col-md-6 offset-md-6\">\n        <button\n          class=\"btn btn-secondary btn-block cx-dialog-buttons\"\n          (click)=\"closeModal()\"\n        >\n          {{ 'addressSuggestion.editAddress' | cxTranslate }}\n        </button>\n        <button\n          cxAutoFocus\n          class=\"btn btn-primary btn-block cx-dialog-buttons\"\n          (click)=\"closeModal(selectedAddress)\"\n        >\n          {{ 'addressSuggestion.saveAddress' | cxTranslate }}\n        </button>\n      </div>\n    </div>\n  </div>\n</div>\n", components: [{ type: IconComponent, selector: "cx-icon,[cxIcon]", inputs: ["cxIcon", "type"] }], directives: [{ type: i3__namespace$1.NgControlStatusGroup, selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { type: i3__namespace$1.NgForm, selector: "form:not([ngNoForm]):not([formGroup]),ng-form,[ngForm]", inputs: ["ngFormOptions"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }, { type: i3__namespace.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i3__namespace$1.RadioControlValueAccessor, selector: "input[type=radio][formControlName],input[type=radio][formControl],input[type=radio][ngModel]", inputs: ["name", "formControlName", "value"] }, { type: i3__namespace$1.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { type: i3__namespace$1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i3__namespace$1.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }], pipes: { "cxTranslate": i1__namespace.TranslatePipe }, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SuggestedAddressDialogComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-suggested-addresses-dialog',
                        templateUrl: './suggested-addresses-dialog.component.html',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], ctorParameters: function () { return [{ type: ModalService }]; }, propDecorators: { suggestedAddresses: [{
                    type: i0.Input
                }], enteredAddress: [{
                    type: i0.Input
                }] } });

    var AddressFormComponent = /** @class */ (function () {
        function AddressFormComponent(fb, userService, userAddressService, globalMessageService, modalService, translation) {
            this.fb = fb;
            this.userService = userService;
            this.userAddressService = userAddressService;
            this.globalMessageService = globalMessageService;
            this.modalService = modalService;
            this.translation = translation;
            this.selectedCountry$ = new rxjs.BehaviorSubject('');
            this.setAsDefaultField = true;
            this.showCancelBtn = true;
            this.submitAddress = new i0.EventEmitter();
            this.backToAddress = new i0.EventEmitter();
            this.addressForm = this.fb.group({
                country: this.fb.group({
                    isocode: [null, i3$1.Validators.required],
                }),
                titleCode: [''],
                firstName: ['', i3$1.Validators.required],
                lastName: ['', i3$1.Validators.required],
                line1: ['', i3$1.Validators.required],
                line2: [''],
                town: ['', i3$1.Validators.required],
                region: this.fb.group({
                    isocode: [null, i3$1.Validators.required],
                }),
                postalCode: ['', i3$1.Validators.required],
                phone: '',
                defaultAddress: [false],
            });
        }
        AddressFormComponent.prototype.ngOnInit = function () {
            var _this = this;
            // Fetching countries
            this.countries$ = this.userAddressService.getDeliveryCountries().pipe(operators.tap(function (countries) {
                if (Object.keys(countries).length === 0) {
                    _this.userAddressService.loadDeliveryCountries();
                }
            }));
            // Fetching titles
            this.titles$ = this.getTitles();
            // Fetching regions
            this.regions$ = this.selectedCountry$.pipe(operators.switchMap(function (country) { return _this.userAddressService.getRegions(country); }), operators.tap(function (regions) {
                var regionControl = _this.addressForm.get('region.isocode');
                if (regions && regions.length > 0) {
                    regionControl.enable();
                }
                else {
                    regionControl.disable();
                }
            }));
            if (this.addressData && Object.keys(this.addressData).length !== 0) {
                this.addressForm.patchValue(this.addressData);
                this.countrySelected(this.addressData.country);
                if (this.addressData.region) {
                    this.regionSelected(this.addressData.region);
                }
            }
            this.addresses$ = this.userAddressService.getAddresses();
        };
        AddressFormComponent.prototype.getTitles = function () {
            return rxjs.combineLatest([
                this.translation.translate('addressForm.defaultTitle'),
                this.userService.getTitles(),
            ]).pipe(operators.map(function (_c) {
                var _d = __read(_c, 2), noneTitleText = _d[0], titles = _d[1];
                var noneTitle = { code: '', name: noneTitleText };
                titles.sort(sortTitles);
                return __spreadArray([noneTitle], __read(titles));
            }));
        };
        AddressFormComponent.prototype.handleAddressVerificationResults = function (results) {
            if (results.decision === 'ACCEPT') {
                this.submitAddress.emit(this.addressForm.value);
            }
            else if (results.decision === 'REJECT') {
                // TODO: Workaround: allow server for decide is titleCode mandatory (if yes, provide personalized message)
                if (results.errors.errors.some(function (error) { return error.subject === 'titleCode'; })) {
                    this.globalMessageService.add({ key: 'addressForm.titleRequired' }, i1.GlobalMessageType.MSG_TYPE_ERROR);
                }
                else {
                    this.globalMessageService.add({ key: 'addressForm.invalidAddress' }, i1.GlobalMessageType.MSG_TYPE_ERROR);
                }
            }
            else if (results.decision === 'REVIEW') {
                this.openSuggestedAddress(results);
            }
        };
        AddressFormComponent.prototype.countrySelected = function (country) {
            var _a, _b;
            (_b = (_a = this.addressForm.get('country')) === null || _a === void 0 ? void 0 : _a.get('isocode')) === null || _b === void 0 ? void 0 : _b.setValue(country.isocode);
            this.selectedCountry$.next(country.isocode);
        };
        AddressFormComponent.prototype.regionSelected = function (region) {
            var _a, _b;
            (_b = (_a = this.addressForm.get('region')) === null || _a === void 0 ? void 0 : _a.get('isocode')) === null || _b === void 0 ? void 0 : _b.setValue(region.isocode);
        };
        AddressFormComponent.prototype.toggleDefaultAddress = function () {
            this.addressForm['controls'].defaultAddress.setValue(this.addressForm.value.defaultAddress);
        };
        AddressFormComponent.prototype.back = function () {
            this.backToAddress.emit();
        };
        AddressFormComponent.prototype.verifyAddress = function () {
            var _this = this;
            if (this.addressForm.valid) {
                if (this.addressForm.get('region').value.isocode) {
                    this.regionsSub = this.regions$.pipe(operators.take(1)).subscribe(function (regions) {
                        var obj = regions.find(function (region) { return region.isocode ===
                            _this.addressForm.controls['region'].value.isocode; });
                        Object.assign(_this.addressForm.value.region, {
                            isocodeShort: obj.isocodeShort,
                        });
                    });
                }
                if (this.addressForm.dirty) {
                    this.userAddressService
                        .verifyAddress(this.addressForm.value)
                        .subscribe(function (result) {
                        _this.handleAddressVerificationResults(result);
                    });
                }
                else {
                    // address form value not changed
                    // ignore duplicate address
                    this.submitAddress.emit(undefined);
                }
            }
            else {
                this.addressForm.markAllAsTouched();
            }
        };
        AddressFormComponent.prototype.openSuggestedAddress = function (results) {
            var _this = this;
            if (!this.suggestedAddressModalRef) {
                this.suggestedAddressModalRef = this.modalService.open(SuggestedAddressDialogComponent, { centered: true, size: 'lg' });
                this.suggestedAddressModalRef.componentInstance.enteredAddress =
                    this.addressForm.value;
                this.suggestedAddressModalRef.componentInstance.suggestedAddresses =
                    results.suggestedAddresses;
                this.suggestedAddressModalRef.result
                    .then(function (address) {
                    if (address) {
                        address = Object.assign({
                            titleCode: _this.addressForm.value.titleCode,
                            phone: _this.addressForm.value.phone,
                            selected: true,
                        }, address);
                        _this.submitAddress.emit(address);
                    }
                    _this.suggestedAddressModalRef = null;
                })
                    .catch(function () {
                    // this  callback is called when modal is closed with Esc key or clicking backdrop
                    var address = Object.assign({
                        selected: true,
                    }, _this.addressForm.value);
                    _this.submitAddress.emit(address);
                    _this.suggestedAddressModalRef = null;
                });
            }
        };
        AddressFormComponent.prototype.ngOnDestroy = function () {
            if (this.addressVerifySub) {
                this.addressVerifySub.unsubscribe();
            }
            if (this.regionsSub) {
                this.regionsSub.unsubscribe();
            }
        };
        return AddressFormComponent;
    }());
    AddressFormComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AddressFormComponent, deps: [{ token: i3__namespace$1.FormBuilder }, { token: i1__namespace.UserService }, { token: i1__namespace.UserAddressService }, { token: i1__namespace.GlobalMessageService }, { token: ModalService }, { token: i1__namespace.TranslationService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    AddressFormComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: AddressFormComponent, selector: "cx-address-form", inputs: { addressData: "addressData", actionBtnLabel: "actionBtnLabel", cancelBtnLabel: "cancelBtnLabel", setAsDefaultField: "setAsDefaultField", showTitleCode: "showTitleCode", showCancelBtn: "showCancelBtn" }, outputs: { submitAddress: "submitAddress", backToAddress: "backToAddress" }, ngImport: i0__namespace, template: "<form (ngSubmit)=\"verifyAddress()\" [formGroup]=\"addressForm\">\n  <div class=\"row\">\n    <div class=\"col-md-12 col-lg-9\">\n      <div class=\"form-group\" formGroupName=\"country\">\n        <ng-container *ngIf=\"countries$ | async as countries\">\n          <div *ngIf=\"countries.length !== 0\">\n            <label>\n              <span class=\"label-content required\">{{\n                'addressForm.country' | cxTranslate\n              }}</span>\n              <ng-select\n                aria-required=\"true\"\n                class=\"country-select\"\n                formControlName=\"isocode\"\n                [searchable]=\"true\"\n                [clearable]=\"false\"\n                [items]=\"countries\"\n                bindLabel=\"name\"\n                bindValue=\"isocode\"\n                placeholder=\"{{ 'addressForm.selectOne' | cxTranslate }}\"\n                (change)=\"countrySelected($event)\"\n              >\n              </ng-select>\n              <cx-form-errors\n                aria-live=\"assertive\"\n                aria-atomic=\"true\"\n                [control]=\"addressForm.get('country.isocode')\"\n              ></cx-form-errors>\n            </label>\n          </div>\n        </ng-container>\n      </div>\n      <div class=\"form-group\" *ngIf=\"showTitleCode\">\n        <ng-container *ngIf=\"titles$ | async as titles\">\n          <div *ngIf=\"titles.length !== 0\">\n            <label>\n              <span class=\"label-content required\">{{\n                'addressForm.title' | cxTranslate\n              }}</span>\n              <ng-select\n                formControlName=\"titleCode\"\n                [searchable]=\"true\"\n                [clearable]=\"false\"\n                [items]=\"titles\"\n                bindLabel=\"name\"\n                bindValue=\"code\"\n                [placeholder]=\"'addressForm.title' | cxTranslate\"\n              >\n              </ng-select>\n            </label>\n          </div>\n        </ng-container>\n      </div>\n      <div class=\"form-group\">\n        <label>\n          <span class=\"label-content required\">{{\n            'addressForm.firstName.label' | cxTranslate\n          }}</span>\n          <input\n            aria-required=\"true\"\n            class=\"form-control\"\n            type=\"text\"\n            placeholder=\"{{\n              'addressForm.firstName.placeholder' | cxTranslate\n            }}\"\n            formControlName=\"firstName\"\n          />\n          <cx-form-errors\n            aria-live=\"assertive\"\n            aria-atomic=\"true\"\n            [control]=\"addressForm.get('firstName')\"\n          ></cx-form-errors>\n        </label>\n      </div>\n      <div class=\"form-group\">\n        <label>\n          <span class=\"label-content required\">{{\n            'addressForm.lastName.label' | cxTranslate\n          }}</span>\n          <input\n            aria-required=\"true\"\n            type=\"text\"\n            class=\"form-control\"\n            placeholder=\"{{ 'addressForm.lastName.placeholder' | cxTranslate }}\"\n            formControlName=\"lastName\"\n          />\n          <cx-form-errors\n            aria-live=\"assertive\"\n            aria-atomic=\"true\"\n            [control]=\"addressForm.get('lastName')\"\n          ></cx-form-errors>\n        </label>\n      </div>\n      <div class=\"form-group\">\n        <label>\n          <span class=\"label-content required\">{{\n            'addressForm.address1' | cxTranslate\n          }}</span>\n          <input\n            aria-required=\"true\"\n            type=\"text\"\n            class=\"form-control\"\n            placeholder=\"{{ 'addressForm.streetAddress' | cxTranslate }}\"\n            formControlName=\"line1\"\n          />\n          <cx-form-errors\n            aria-live=\"assertive\"\n            aria-atomic=\"true\"\n            [control]=\"addressForm.get('line1')\"\n          ></cx-form-errors>\n        </label>\n      </div>\n      <div class=\"form-group\">\n        <label>\n          <span class=\"label-content\">{{\n            'addressForm.address2' | cxTranslate\n          }}</span>\n          <input\n            type=\"text\"\n            class=\"form-control\"\n            placeholder=\"{{ 'addressForm.aptSuite' | cxTranslate }}\"\n            formControlName=\"line2\"\n          />\n        </label>\n      </div>\n      <div class=\"row\">\n        <div class=\"form-group col-md-6\">\n          <label>\n            <span class=\"label-content required\">{{\n              'addressForm.city.label' | cxTranslate\n            }}</span>\n            <input\n              aria-required=\"true\"\n              type=\"text\"\n              class=\"form-control\"\n              placeholder=\"{{ 'addressForm.city.placeholder' | cxTranslate }}\"\n              formControlName=\"town\"\n            />\n            <cx-form-errors\n              aria-live=\"assertive\"\n              aria-atomic=\"true\"\n              [control]=\"addressForm.get('town')\"\n            ></cx-form-errors>\n          </label>\n        </div>\n        <div class=\"form-group col-md-6\">\n          <label>\n            <span class=\"label-content required\">{{\n              'addressForm.zipCode.label' | cxTranslate\n            }}</span>\n            <input\n              aria-required=\"true\"\n              type=\"text\"\n              class=\"form-control\"\n              placeholder=\"{{\n                'addressForm.zipCode.placeholder' | cxTranslate\n              }}\"\n              formControlName=\"postalCode\"\n            />\n            <cx-form-errors\n              aria-live=\"assertive\"\n              aria-atomic=\"true\"\n              [control]=\"addressForm.get('postalCode')\"\n            ></cx-form-errors>\n          </label>\n        </div>\n        <ng-container\n          *ngIf=\"regions$ | async as regions\"\n          formGroupName=\"region\"\n        >\n          <ng-container *ngIf=\"regions.length !== 0\">\n            <div class=\"form-group col-md-6\">\n              <label>\n                <span class=\"label-content required\">{{\n                  'addressForm.state' | cxTranslate\n                }}</span>\n                <ng-select\n                  aria-required=\"true\"\n                  class=\"region-select\"\n                  formControlName=\"isocode\"\n                  [searchable]=\"true\"\n                  [clearable]=\"false\"\n                  [items]=\"regions\"\n                  bindLabel=\"{{ regions[0].name ? 'name' : 'isocode' }}\"\n                  bindValue=\"{{ regions[0].name ? 'isocode' : 'region' }}\"\n                  placeholder=\"{{ 'addressForm.selectOne' | cxTranslate }}\"\n                >\n                </ng-select>\n                <cx-form-errors\n                  aria-live=\"assertive\"\n                  aria-atomic=\"true\"\n                  [control]=\"addressForm.get('region.isocode')\"\n                ></cx-form-errors>\n              </label>\n            </div>\n          </ng-container>\n        </ng-container>\n      </div>\n      <div class=\"form-group\">\n        <label>\n          <span class=\"label-content\">{{\n            'addressForm.phoneNumber.label' | cxTranslate\n          }}</span>\n          <input\n            type=\"tel\"\n            class=\"form-control\"\n            placeholder=\"{{\n              'addressForm.phoneNumber.placeholder' | cxTranslate\n            }}\"\n            formControlName=\"phone\"\n          />\n        </label>\n      </div>\n      <div\n        class=\"form-group\"\n        *ngIf=\"(addresses$ | async).length && setAsDefaultField\"\n      >\n        <div class=\"form-check\">\n          <label>\n            <input\n              type=\"checkbox\"\n              class=\"form-check-input\"\n              formControlName=\"defaultAddress\"\n              (change)=\"toggleDefaultAddress()\"\n            />\n            <span class=\"form-check-label\">{{\n              'addressForm.setAsDefault' | cxTranslate\n            }}</span>\n          </label>\n        </div>\n      </div>\n    </div>\n  </div>\n  <div class=\"cx-address-form-btns row\">\n    <div class=\"col-md-12 col-lg-6\" *ngIf=\"showCancelBtn\">\n      <button class=\"btn btn-block btn-action\" (click)=\"back()\">\n        {{ cancelBtnLabel || ('addressForm.chooseAddress' | cxTranslate) }}\n      </button>\n    </div>\n    <div class=\"col-md-12 col-lg-6\">\n      <button class=\"btn btn-block btn-primary\" type=\"submit\">\n        {{ actionBtnLabel || ('common.continue' | cxTranslate) }}\n      </button>\n    </div>\n  </div>\n</form>\n", components: [{ type: i1__namespace$4.NgSelectComponent, selector: "ng-select", inputs: ["markFirst", "dropdownPosition", "loading", "closeOnSelect", "hideSelected", "selectOnTab", "bufferAmount", "selectableGroup", "selectableGroupAsModel", "searchFn", "trackByFn", "clearOnBackspace", "labelForId", "inputAttrs", "readonly", "searchWhileComposing", "minTermLength", "editableSearchTerm", "keyDownFn", "multiple", "addTag", "searchable", "clearable", "isOpen", "items", "compareWith", "clearSearchOnAdd", "bindLabel", "placeholder", "notFoundText", "typeToSearchText", "addTagText", "loadingText", "clearAllText", "virtualScroll", "openOnEnter", "appendTo", "bindValue", "appearance", "maxSelectedItems", "groupBy", "groupValue", "tabIndex", "typeahead"], outputs: ["blur", "focus", "change", "open", "close", "search", "clear", "add", "remove", "scroll", "scrollToEnd"] }, { type: FormErrorsComponent, selector: "cx-form-errors", inputs: ["prefix", "translationParams", "control"] }], directives: [{ type: i3__namespace$1.ɵNgNoValidate, selector: "form:not([ngNoForm]):not([ngNativeValidate])" }, { type: i3__namespace$1.NgControlStatusGroup, selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { type: i3__namespace$1.FormGroupDirective, selector: "[formGroup]", inputs: ["formGroup"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }, { type: i3__namespace$1.FormGroupName, selector: "[formGroupName]", inputs: ["formGroupName"] }, { type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3__namespace$1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i3__namespace$1.FormControlName, selector: "[formControlName]", inputs: ["disabled", "formControlName", "ngModel"], outputs: ["ngModelChange"] }, { type: i3__namespace$1.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { type: i3__namespace$1.CheckboxControlValueAccessor, selector: "input[type=checkbox][formControlName],input[type=checkbox][formControl],input[type=checkbox][ngModel]" }], pipes: { "async": i3__namespace.AsyncPipe, "cxTranslate": i1__namespace.TranslatePipe }, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AddressFormComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-address-form',
                        templateUrl: './address-form.component.html',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], ctorParameters: function () { return [{ type: i3__namespace$1.FormBuilder }, { type: i1__namespace.UserService }, { type: i1__namespace.UserAddressService }, { type: i1__namespace.GlobalMessageService }, { type: ModalService }, { type: i1__namespace.TranslationService }]; }, propDecorators: { addressData: [{
                    type: i0.Input
                }], actionBtnLabel: [{
                    type: i0.Input
                }], cancelBtnLabel: [{
                    type: i0.Input
                }], setAsDefaultField: [{
                    type: i0.Input
                }], showTitleCode: [{
                    type: i0.Input
                }], showCancelBtn: [{
                    type: i0.Input
                }], submitAddress: [{
                    type: i0.Output
                }], backToAddress: [{
                    type: i0.Output
                }] } });

    var AddressBookComponent = /** @class */ (function () {
        function AddressBookComponent(service, translation) {
            this.service = service;
            this.translation = translation;
            this.showAddAddressForm = false;
            this.showEditAddressForm = false;
        }
        AddressBookComponent.prototype.ngOnInit = function () {
            this.addresses$ = this.service.getAddresses();
            this.addressesStateLoading$ = this.service.getAddressesStateLoading();
            this.service.loadAddresses();
        };
        AddressBookComponent.prototype.addAddressButtonHandle = function () {
            this.showEditAddressForm = false;
            this.showAddAddressForm = true;
        };
        AddressBookComponent.prototype.editAddressButtonHandle = function (address) {
            this.showAddAddressForm = false;
            this.showEditAddressForm = true;
            this.currentAddress = address;
        };
        AddressBookComponent.prototype.addAddressSubmit = function (address) {
            this.showAddAddressForm = false;
            this.service.addUserAddress(address);
        };
        AddressBookComponent.prototype.addAddressCancel = function () {
            this.showAddAddressForm = false;
        };
        AddressBookComponent.prototype.editAddressSubmit = function (address) {
            this.showEditAddressForm = false;
            this.service.updateUserAddress(this.currentAddress['id'], address);
        };
        AddressBookComponent.prototype.editAddressCancel = function () {
            this.showEditAddressForm = false;
        };
        AddressBookComponent.prototype.getCardContent = function (address) {
            return rxjs.combineLatest([
                this.translation.translate('addressCard.default'),
                this.translation.translate('addressCard.setAsDefault'),
                this.translation.translate('common.delete'),
                this.translation.translate('common.edit'),
                this.translation.translate('addressBook.areYouSureToDeleteAddress'),
            ]).pipe(operators.map(function (_a) {
                var _b = __read(_a, 5), defaultText = _b[0], setAsDefaultText = _b[1], textDelete = _b[2], textEdit = _b[3], textVerifyDeleteMsg = _b[4];
                var region = '';
                if (address.region && address.region.isocode) {
                    region = address.region.isocode + ', ';
                }
                var actions = [];
                if (!address.defaultAddress) {
                    actions.push({ name: setAsDefaultText, event: 'default' });
                }
                actions.push({ name: textEdit, event: 'edit' });
                actions.push({ name: textDelete, event: 'delete' });
                return {
                    textBold: address.firstName + ' ' + address.lastName,
                    text: [
                        address.line1,
                        address.line2,
                        address.town + ', ' + region + address.country.isocode,
                        address.postalCode,
                        address.phone,
                    ],
                    actions: actions,
                    header: address.defaultAddress ? "\u2713 " + defaultText : '',
                    deleteMsg: textVerifyDeleteMsg,
                };
            }));
        };
        AddressBookComponent.prototype.setAddressAsDefault = function (addressId) {
            this.service.setAddressAsDefault(addressId);
        };
        AddressBookComponent.prototype.deleteAddress = function (addressId) {
            this.service.deleteUserAddress(addressId);
        };
        AddressBookComponent.prototype.setEdit = function (addressId) {
            if (this.editCard !== addressId) {
                this.editCard = addressId;
            }
            else {
                this.deleteAddress(addressId);
            }
        };
        AddressBookComponent.prototype.cancelCard = function () {
            this.editCard = null;
        };
        return AddressBookComponent;
    }());
    AddressBookComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AddressBookComponent, deps: [{ token: AddressBookComponentService }, { token: i1__namespace.TranslationService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    AddressBookComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: AddressBookComponent, selector: "cx-address-book", ngImport: i0__namespace, template: "<div class=\"cx-section\">\n  <ng-container\n    *ngIf=\"\n      (addresses$ | async).length &&\n      !(showAddAddressForm || showEditAddressForm)\n    \"\n  >\n    <div class=\"row\">\n      <div class=\"col-md-6\">\n        <button\n          class=\"btn btn-block btn-action\"\n          (click)=\"addAddressButtonHandle()\"\n        >\n          {{ 'addressBook.addNewAddress' | cxTranslate }}\n        </button>\n      </div>\n    </div>\n\n    <div\n      class=\"row cx-address-deck\"\n      *ngIf=\"!(addressesStateLoading$ | async); else loading\"\n    >\n      <div\n        *ngFor=\"let address of addresses$ | async\"\n        class=\"col-md-6 cx-address-card\"\n      >\n        <cx-card\n          [border]=\"true\"\n          [fitToContainer]=\"true\"\n          [content]=\"getCardContent(address) | async\"\n          (editCard)=\"editAddressButtonHandle(address)\"\n          (setDefaultCard)=\"setAddressAsDefault(address.id)\"\n          (deleteCard)=\"setEdit(address.id)\"\n          [editMode]=\"address.id === editCard\"\n          (cancelCard)=\"cancelCard()\"\n        ></cx-card>\n      </div>\n    </div>\n  </ng-container>\n\n  <ng-container *ngIf=\"!(addresses$ | async).length || showAddAddressForm\">\n    <section>\n      <p class=\"cx-section-msg\">\n        {{ 'addressBook.addNewShippingAddress' | cxTranslate }}\n      </p>\n      <cx-address-form\n        class=\"cx-form\"\n        showTitleCode=\"true\"\n        [showCancelBtn]=\"!((addresses$ | async).length === 0)\"\n        actionBtnLabel=\"{{ 'addressBook.addAddress' | cxTranslate }}\"\n        cancelBtnLabel=\"{{ 'addressBook.backToAddressList' | cxTranslate }}\"\n        [setAsDefaultField]=\"!((addresses$ | async).length === 0)\"\n        (submitAddress)=\"addAddressSubmit($event)\"\n        (backToAddress)=\"addAddressCancel()\"\n        (cancelCard)=\"cancelCard()\"\n      ></cx-address-form>\n    </section>\n  </ng-container>\n\n  <ng-container *ngIf=\"showEditAddressForm\">\n    <section>\n      <p class=\"cx-section-msg\">\n        {{ 'addressBook.editShippingAddress' | cxTranslate }}\n      </p>\n      <cx-address-form\n        showTitleCode=\"true\"\n        actionBtnLabel=\"{{ 'addressBook.updateAddress' | cxTranslate }}\"\n        cancelBtnLabel=\"{{ 'addressBook.backToAddressList' | cxTranslate }}\"\n        [addressData]=\"currentAddress\"\n        (submitAddress)=\"editAddressSubmit($event)\"\n        (backToAddress)=\"editAddressCancel()\"\n      ></cx-address-form>\n    </section>\n  </ng-container>\n</div>\n\n<ng-template #loading>\n  <div class=\"col-md-12 cx-address-spinner\">\n    <cx-spinner></cx-spinner>\n  </div>\n</ng-template>\n", components: [{ type: CardComponent, selector: "cx-card", inputs: ["border", "editMode", "isDefault", "content", "fitToContainer", "truncateText", "charactersLimit"], outputs: ["deleteCard", "setDefaultCard", "sendCard", "editCard", "cancelCard"] }, { type: AddressFormComponent, selector: "cx-address-form", inputs: ["addressData", "actionBtnLabel", "cancelBtnLabel", "setAsDefaultField", "showTitleCode", "showCancelBtn"], outputs: ["submitAddress", "backToAddress"] }, { type: SpinnerComponent, selector: "cx-spinner" }], directives: [{ type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3__namespace.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], pipes: { "async": i3__namespace.AsyncPipe, "cxTranslate": i1__namespace.TranslatePipe } });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AddressBookComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-address-book',
                        templateUrl: './address-book.component.html',
                    }]
            }], ctorParameters: function () { return [{ type: AddressBookComponentService }, { type: i1__namespace.TranslationService }]; } });

    var AddressFormModule = /** @class */ (function () {
        function AddressFormModule() {
        }
        return AddressFormModule;
    }());
    AddressFormModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AddressFormModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    AddressFormModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AddressFormModule, declarations: [AddressFormComponent, SuggestedAddressDialogComponent], imports: [i3.CommonModule,
            i3$1.ReactiveFormsModule,
            i3$1.FormsModule,
            i1$1.RouterModule,
            i1$4.NgSelectModule,
            IconModule,
            i1.I18nModule,
            FormErrorsModule], exports: [AddressFormComponent, SuggestedAddressDialogComponent] });
    AddressFormModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AddressFormModule, imports: [[
                i3.CommonModule,
                i3$1.ReactiveFormsModule,
                i3$1.FormsModule,
                i1$1.RouterModule,
                i1$4.NgSelectModule,
                IconModule,
                i1.I18nModule,
                FormErrorsModule,
            ]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AddressFormModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [
                            i3.CommonModule,
                            i3$1.ReactiveFormsModule,
                            i3$1.FormsModule,
                            i1$1.RouterModule,
                            i1$4.NgSelectModule,
                            IconModule,
                            i1.I18nModule,
                            FormErrorsModule,
                        ],
                        declarations: [AddressFormComponent, SuggestedAddressDialogComponent],
                        exports: [AddressFormComponent, SuggestedAddressDialogComponent],
                    }]
            }] });

    var AddressBookModule = /** @class */ (function () {
        function AddressBookModule() {
        }
        return AddressBookModule;
    }());
    AddressBookModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AddressBookModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    AddressBookModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AddressBookModule, declarations: [AddressBookComponent], imports: [i3.CommonModule,
            CardModule,
            AddressFormModule,
            SpinnerModule,
            i1.I18nModule], exports: [AddressBookComponent] });
    AddressBookModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AddressBookModule, providers: [
            i1.provideDefaultConfig({
                cmsComponents: {
                    AccountAddressBookComponent: {
                        component: AddressBookComponent,
                        guards: [i1.AuthGuard],
                    },
                },
            }),
            i1.UserAddressService,
        ], imports: [[
                i3.CommonModule,
                CardModule,
                AddressFormModule,
                SpinnerModule,
                i1.I18nModule,
            ]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AddressBookModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [
                            i3.CommonModule,
                            CardModule,
                            AddressFormModule,
                            SpinnerModule,
                            i1.I18nModule,
                        ],
                        declarations: [AddressBookComponent],
                        exports: [AddressBookComponent],
                        providers: [
                            i1.provideDefaultConfig({
                                cmsComponents: {
                                    AccountAddressBookComponent: {
                                        component: AddressBookComponent,
                                        guards: [i1.AuthGuard],
                                    },
                                },
                            }),
                            i1.UserAddressService,
                        ],
                    }]
            }] });

    var MyCouponsComponentService = /** @class */ (function () {
        function MyCouponsComponentService(routingService, translation) {
            this.routingService = routingService;
            this.translation = translation;
            this.RELEVANCE = ':relevance';
            this.CUSTOMER_COUPON_CODE = ':customerCouponCode:';
        }
        MyCouponsComponentService.prototype.launchSearchPage = function (coupon) {
            this.routingService.go({
                cxRoute: 'search',
                params: { query: this.buildSearchParam(coupon) },
            }, {
                queryParams: {
                    couponcode: coupon.couponId,
                },
            });
        };
        MyCouponsComponentService.prototype.buildSearchParam = function (coupon) {
            return coupon.allProductsApplicable
                ? this.RELEVANCE
                : this.RELEVANCE + this.CUSTOMER_COUPON_CODE + coupon.couponId;
        };
        MyCouponsComponentService.prototype.getSortLabels = function () {
            return rxjs.combineLatest([
                this.translation.translate('myCoupons.startDateAsc'),
                this.translation.translate('myCoupons.startDateDesc'),
                this.translation.translate('myCoupons.endDateAsc'),
                this.translation.translate('myCoupons.endDateDesc'),
            ]).pipe(operators.map(function (_a) {
                var _b = __read(_a, 4), textByStartDateAsc = _b[0], textByStartDateDesc = _b[1], textByEndDateAsc = _b[2], textByEndDateDesc = _b[3];
                return {
                    byStartDateAsc: textByStartDateAsc,
                    byStartDateDesc: textByStartDateDesc,
                    byEndDateAsc: textByEndDateAsc,
                    byEndDateDesc: textByEndDateDesc,
                };
            }));
        };
        return MyCouponsComponentService;
    }());
    MyCouponsComponentService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: MyCouponsComponentService, deps: [{ token: i1__namespace.RoutingService }, { token: i1__namespace.TranslationService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    MyCouponsComponentService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: MyCouponsComponentService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: MyCouponsComponentService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace.RoutingService }, { type: i1__namespace.TranslationService }]; } });

    var CouponDialogComponent = /** @class */ (function () {
        function CouponDialogComponent(modalService) {
            this.modalService = modalService;
            this.iconTypes = exports.ICON_TYPE;
        }
        CouponDialogComponent.prototype.dismissModal = function (reason) {
            this.modalService.dismissActiveModal(reason);
        };
        return CouponDialogComponent;
    }());
    CouponDialogComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CouponDialogComponent, deps: [{ token: ModalService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    CouponDialogComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: CouponDialogComponent, selector: "cx-coupon-dialog", viewQueries: [{ propertyName: "dialog", first: true, predicate: ["dialog"], descendants: true, read: i0.ElementRef }], ngImport: i0__namespace, template: "<div #dialog>\n  <!-- Modal Header -->\n\n  <div class=\"cx-dialog-header modal-header\">\n    <div class=\"cx-dialog-title modal-title\">\n      {{ 'myCoupons.dialogTitle' | cxTranslate }}\n    </div>\n    <button\n      type=\"button\"\n      class=\"close\"\n      [attr.aria-label]=\"'common.close' | cxTranslate\"\n      (click)=\"dismissModal('Cross click')\"\n    >\n      <span aria-hidden=\"true\">\n        <cx-icon [type]=\"iconTypes.CLOSE\"></cx-icon>\n      </span>\n    </button>\n  </div>\n  <!-- Modal Body -->\n  <div class=\"cx-dialog-body modal-body\">\n    <div class=\"cx-dialog-row\">\n      <div class=\"cx-dialog-item col-sm-12 col-md-12\">\n        <div class=\"cx-coupon-card-head\">\n          <span class=\"card-label-bold cx-coupon-card-id\">{{\n            coupon?.couponId\n          }}</span>\n          <span>: {{ coupon?.name }}</span>\n        </div>\n        <div class=\"cx-coupon-description\">{{ coupon?.description }}</div>\n\n        <div class=\"cx-coupon-dialog-date\">\n          <p>{{ 'myCoupons.effectiveTitle' | cxTranslate }}</p>\n          <div class=\"cx-coupon-date\">\n            {{ coupon?.startDate | cxDate: 'medium' }} -\n            {{ coupon?.endDate | cxDate: 'medium' }}\n          </div>\n        </div>\n\n        <div class=\"cx-coupon-dialog-status\">\n          <p>{{ 'myCoupons.status' | cxTranslate }}</p>\n          <div class=\"cx-coupon-status {{ coupon?.status | lowercase }}\">\n            {{ 'myCoupons.' + coupon?.status | cxTranslate }}\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n", components: [{ type: IconComponent, selector: "cx-icon,[cxIcon]", inputs: ["cxIcon", "type"] }], pipes: { "cxTranslate": i1__namespace.TranslatePipe, "cxDate": i1__namespace.CxDatePipe, "lowercase": i3__namespace.LowerCasePipe } });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CouponDialogComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-coupon-dialog',
                        templateUrl: './coupon-dialog.component.html',
                    }]
            }], ctorParameters: function () { return [{ type: ModalService }]; }, propDecorators: { dialog: [{
                    type: i0.ViewChild,
                    args: ['dialog', { read: i0.ElementRef }]
                }] } });

    var CouponCardComponent = /** @class */ (function () {
        function CouponCardComponent(modalService, myCouponsComponentService) {
            this.modalService = modalService;
            this.myCouponsComponentService = myCouponsComponentService;
            this.notificationChanged = new i0.EventEmitter();
        }
        CouponCardComponent.prototype.onSubscriptionChange = function () {
            this.notificationChanged.emit({
                couponId: this.coupon.couponId,
                notification: !this.coupon.notificationOn,
            });
        };
        CouponCardComponent.prototype.readMore = function () {
            var modalInstance;
            this.modalRef = this.modalService.open(CouponDialogComponent, {
                centered: true,
                size: 'lg',
            });
            modalInstance = this.modalRef.componentInstance;
            modalInstance.coupon = this.coupon;
        };
        CouponCardComponent.prototype.findProducts = function () {
            this.myCouponsComponentService.launchSearchPage(this.coupon);
        };
        return CouponCardComponent;
    }());
    CouponCardComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CouponCardComponent, deps: [{ token: ModalService }, { token: MyCouponsComponentService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    CouponCardComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: CouponCardComponent, selector: "cx-coupon-card", inputs: { coupon: "coupon", couponSubscriptionLoading$: "couponSubscriptionLoading$" }, outputs: { notificationChanged: "notificationChanged" }, ngImport: i0__namespace, template: "<div class=\"card\">\n  <div class=\"card-body cx-card-body\">\n    <div class=\"cx-coupon-data\">\n      <div class=\"cx-coupon-card-row top\">\n        <div class=\"cx-coupon-card-head\">\n          <span class=\"card-label-bold cx-coupon-card-id\">{{\n            coupon?.couponId\n          }}</span>\n          <span>: {{ coupon?.name }}</span>\n        </div>\n\n        <div class=\"cx-coupon-status {{ coupon?.status | lowercase }}\">\n          {{ 'myCoupons.' + coupon?.status | cxTranslate }}\n        </div>\n      </div>\n\n      <div class=\"cx-coupon-card-date\">\n        <p>{{ 'myCoupons.effectiveTitle' | cxTranslate }}</p>\n        <div class=\"cx-coupon-date\">\n          <div class=\"cx-coupon-date-start\">\n            {{ coupon?.startDate | cxDate: 'medium' }} -&nbsp;\n          </div>\n          <div class=\"cx-coupon-date-end\">\n            {{ coupon?.endDate | cxDate: 'medium' }}\n          </div>\n        </div>\n      </div>\n\n      <a (click)=\"readMore()\" class=\"cx-card-read-more\">{{\n        'myCoupons.readMore' | cxTranslate\n      }}</a>\n\n      <div class=\"cx-coupon-card-row bottom\">\n        <div class=\"cx-coupon-notification form-check\">\n          <label>\n            <input\n              type=\"checkbox\"\n              class=\"form-check-input\"\n              [checked]=\"coupon?.notificationOn\"\n              [class.disabled]=\"couponSubscriptionLoading$ | async\"\n              [disabled]=\"couponSubscriptionLoading$ | async\"\n              (change)=\"onSubscriptionChange()\"\n            />\n            <span class=\"form-check-label\">\n              {{ 'myCoupons.notification' | cxTranslate }}\n            </span>\n          </label>\n        </div>\n\n        <div class=\"cx-coupon-find-product col-lg-6 col-md-12 col-sm-6\">\n          <button class=\"btn btn-block btn-action\" (click)=\"findProducts()\">\n            {{ 'myCoupons.findProducts' | cxTranslate }}\n          </button>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n", pipes: { "lowercase": i3__namespace.LowerCasePipe, "cxTranslate": i1__namespace.TranslatePipe, "cxDate": i1__namespace.CxDatePipe, "async": i3__namespace.AsyncPipe } });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CouponCardComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-coupon-card',
                        templateUrl: './coupon-card.component.html',
                    }]
            }], ctorParameters: function () { return [{ type: ModalService }, { type: MyCouponsComponentService }]; }, propDecorators: { coupon: [{
                    type: i0.Input
                }], couponSubscriptionLoading$: [{
                    type: i0.Input
                }], notificationChanged: [{
                    type: i0.Output
                }] } });

    var MyCouponsComponent = /** @class */ (function () {
        function MyCouponsComponent(couponService, myCouponsComponentService) {
            this.couponService = couponService;
            this.myCouponsComponentService = myCouponsComponentService;
            this.iconTypes = exports.ICON_TYPE;
            this.subscriptions = new rxjs.Subscription();
            this.PAGE_SIZE = 10;
            this.sortMapping = {
                byStartDateAsc: 'startDate:asc',
                byStartDateDesc: 'startDate:desc',
                byEndDateAsc: 'endDate:asc',
                byEndDateDesc: 'endDate:desc',
            };
            this.sort = 'byStartDateAsc';
            this.sortOptions = [
                {
                    code: 'byStartDateAsc',
                    selected: false,
                },
                {
                    code: 'byStartDateDesc',
                    selected: false,
                },
                {
                    code: 'byEndDateAsc',
                    selected: false,
                },
                {
                    code: 'byEndDateDesc',
                    selected: false,
                },
            ];
        }
        MyCouponsComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.couponResult$ = this.couponService
                .getCustomerCoupons(this.PAGE_SIZE)
                .pipe(operators.tap(function (coupons) { return (_this.pagination = {
                currentPage: coupons.pagination.page,
                pageSize: coupons.pagination.count,
                totalPages: coupons.pagination.totalPages,
                totalResults: coupons.pagination.totalCount,
                sort: _this.sort,
            }); }));
            this.couponsLoading$ = this.couponService.getCustomerCouponsLoading();
            this.couponSubscriptionLoading$ = rxjs.combineLatest([
                this.couponService.getSubscribeCustomerCouponResultLoading(),
                this.couponService.getUnsubscribeCustomerCouponResultLoading(),
            ]).pipe(operators.map(function (_a) {
                var _b = __read(_a, 2), subscribing = _b[0], unsubscribing = _b[1];
                return subscribing || unsubscribing;
            }));
            this.sortLabels = this.myCouponsComponentService.getSortLabels();
            this.subscriptions
                .add(this.couponService
                .getSubscribeCustomerCouponResultError()
                .subscribe(function (error) {
                _this.subscriptionFail(error);
            }))
                .add(this.couponService
                .getUnsubscribeCustomerCouponResultError()
                .subscribe(function (error) {
                _this.subscriptionFail(error);
            }));
        };
        MyCouponsComponent.prototype.subscriptionFail = function (error) {
            if (error) {
                this.couponService.loadCustomerCoupons(this.PAGE_SIZE);
            }
        };
        MyCouponsComponent.prototype.sortChange = function (sort) {
            this.sort = sort;
            this.couponService.loadCustomerCoupons(this.PAGE_SIZE, this.pagination.currentPage, this.sortMapping[sort]);
        };
        MyCouponsComponent.prototype.pageChange = function (page) {
            this.couponService.loadCustomerCoupons(this.PAGE_SIZE, page, this.sortMapping[this.sort]);
        };
        MyCouponsComponent.prototype.notificationChange = function (_a) {
            var couponId = _a.couponId, notification = _a.notification;
            if (notification) {
                this.couponService.subscribeCustomerCoupon(couponId);
            }
            else {
                this.couponService.unsubscribeCustomerCoupon(couponId);
            }
        };
        MyCouponsComponent.prototype.ngOnDestroy = function () {
            this.subscriptions.unsubscribe();
        };
        return MyCouponsComponent;
    }());
    MyCouponsComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: MyCouponsComponent, deps: [{ token: i1__namespace.CustomerCouponService }, { token: MyCouponsComponentService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    MyCouponsComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: MyCouponsComponent, selector: "cx-my-coupons", ngImport: i0__namespace, template: "<div class=\"cx-section\">\n  <ng-container *ngIf=\"!(couponsLoading$ | async); else loading\">\n    <ng-container *ngIf=\"couponResult$ | async as couponResult\">\n      <div class=\"cx-my-coupons-header\">\n        <h3>{{ 'myCoupons.myCoupons' | cxTranslate }}</h3>\n      </div>\n\n      <ng-container\n        *ngIf=\"couponResult.pagination.totalCount > 0; else noCoupons\"\n      >\n        <div class=\"cx-my-coupons-sort top row\">\n          <label\n            class=\"\n              cx-my-coupons-form-group\n              form-group\n              col-sm-12 col-md-4 col-lg-4\n            \"\n          >\n            <span>{{ 'myCoupons.sortBy' | cxTranslate }}</span>\n            <cx-sorting\n              [sortOptions]=\"sortOptions\"\n              [sortLabels]=\"sortLabels | async\"\n              (sortListEvent)=\"sortChange($event)\"\n              [selectedOption]=\"sort\"\n            >\n            </cx-sorting>\n          </label>\n          <div class=\"cx-my-coupons-pagination cx-mycoupon-thead-mobile\">\n            <cx-pagination\n              [pagination]=\"pagination\"\n              (viewPageEvent)=\"pageChange($event)\"\n            ></cx-pagination>\n          </div>\n        </div>\n\n        <div class=\"row cx-coupon-deck\">\n          <div\n            *ngFor=\"let coupon of couponResult.coupons\"\n            class=\"col-md-6 cx-coupon-card\"\n          >\n            <cx-coupon-card\n              [coupon]=\"coupon\"\n              [couponSubscriptionLoading$]=\"couponSubscriptionLoading$\"\n              (notificationChanged)=\"notificationChange($event)\"\n            ></cx-coupon-card>\n          </div>\n        </div>\n\n        <div class=\"cx-my-coupons-sort bottom row\">\n          <label\n            class=\"\n              cx-my-coupons-form-group\n              form-group\n              cx-mycoupon-thead-mobile\n              col-sm-12 col-md-4 col-lg-4\n            \"\n          >\n            <span>{{ 'myCoupons.sortBy' | cxTranslate }}</span>\n            <cx-sorting\n              [sortOptions]=\"sortOptions\"\n              [sortLabels]=\"sortLabels | async\"\n              (sortListEvent)=\"sortChange($event)\"\n              [selectedOption]=\"sort\"\n              placeholder=\"{{ 'myCoupons.sortBy' | cxTranslate }}\"\n            >\n            </cx-sorting>\n          </label>\n          <div class=\"cx-my-coupons-pagination\">\n            <cx-pagination\n              [pagination]=\"pagination\"\n              (viewPageEvent)=\"pageChange($event)\"\n            ></cx-pagination>\n          </div>\n        </div>\n        <div class=\"cx-my-coupons-notes\">\n          <span>\n            <cx-icon [type]=\"iconTypes.INFO\"></cx-icon>\n            {{ 'myCoupons.notesPreffix' | cxTranslate\n            }}<a [routerLink]=\"['/my-account/notification-preference']\">{{\n              'myCoupons.notesLink' | cxTranslate\n            }}</a\n            >{{ 'myCoupons.notesSuffix' | cxTranslate }}</span\n          >\n        </div>\n      </ng-container>\n    </ng-container>\n\n    <ng-template #noCoupons>\n      <section>\n        <p class=\"cx-section-msg\">\n          {{ 'myCoupons.noCouponsMessage' | cxTranslate }}\n        </p>\n      </section>\n    </ng-template>\n  </ng-container>\n\n  <ng-template #loading>\n    <div class=\"col-md-12 cx-coupon-spinner\">\n      <cx-spinner></cx-spinner>\n    </div>\n  </ng-template>\n</div>\n", components: [{ type: SortingComponent, selector: "cx-sorting", inputs: ["sortOptions", "selectedOption", "placeholder", "sortLabels"], outputs: ["sortListEvent"] }, { type: PaginationComponent, selector: "cx-pagination", inputs: ["pageRoute", "queryParam", "defaultPage", "pagination"], outputs: ["viewPageEvent"] }, { type: CouponCardComponent, selector: "cx-coupon-card", inputs: ["coupon", "couponSubscriptionLoading$"], outputs: ["notificationChanged"] }, { type: IconComponent, selector: "cx-icon,[cxIcon]", inputs: ["cxIcon", "type"] }, { type: SpinnerComponent, selector: "cx-spinner" }], directives: [{ type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3__namespace.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i1__namespace$1.RouterLinkWithHref, selector: "a[routerLink],area[routerLink]", inputs: ["routerLink", "target", "queryParams", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange", "replaceUrl", "state", "relativeTo"] }], pipes: { "async": i3__namespace.AsyncPipe, "cxTranslate": i1__namespace.TranslatePipe } });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: MyCouponsComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-my-coupons',
                        templateUrl: './my-coupons.component.html',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace.CustomerCouponService }, { type: MyCouponsComponentService }]; } });

    var CouponClaimComponent = /** @class */ (function () {
        function CouponClaimComponent(couponService, routingService, messageService) {
            this.couponService = couponService;
            this.routingService = routingService;
            this.messageService = messageService;
        }
        CouponClaimComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.routingService
                .getRouterState()
                .subscribe(function (k) {
                var couponCode = k.state.params.couponCode;
                if (couponCode) {
                    _this.couponService.claimCustomerCoupon(couponCode);
                    _this.subscription = _this.couponService
                        .getClaimCustomerCouponResultSuccess()
                        .subscribe(function (success) {
                        if (success) {
                            _this.messageService.add({ key: 'myCoupons.claimCustomerCoupon' }, i1.GlobalMessageType.MSG_TYPE_CONFIRMATION);
                        }
                        _this.routingService.go({ cxRoute: 'coupons' });
                    });
                }
                else {
                    _this.routingService.go({ cxRoute: 'notFound' });
                }
            })
                .unsubscribe();
        };
        CouponClaimComponent.prototype.ngOnDestroy = function () {
            if (this.subscription) {
                this.subscription.unsubscribe();
            }
        };
        return CouponClaimComponent;
    }());
    CouponClaimComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CouponClaimComponent, deps: [{ token: i1__namespace.CustomerCouponService }, { token: i1__namespace.RoutingService }, { token: i1__namespace.GlobalMessageService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    CouponClaimComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: CouponClaimComponent, selector: "cx-coupon-claim", ngImport: i0__namespace, template: '', isInline: true });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CouponClaimComponent, decorators: [{
                type: i0.Component,
                args: [{
                        template: '',
                        selector: 'cx-coupon-claim',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace.CustomerCouponService }, { type: i1__namespace.RoutingService }, { type: i1__namespace.GlobalMessageService }]; } });

    var MyCouponsModule = /** @class */ (function () {
        function MyCouponsModule() {
        }
        return MyCouponsModule;
    }());
    MyCouponsModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: MyCouponsModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    MyCouponsModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: MyCouponsModule, declarations: [MyCouponsComponent,
            CouponCardComponent,
            CouponDialogComponent,
            CouponClaimComponent], imports: [i3.CommonModule,
            CardModule,
            SpinnerModule,
            i1.I18nModule,
            i1$1.RouterModule,
            i1.UrlModule,
            IconModule,
            ListNavigationModule, i1__namespace$1.RouterModule], exports: [MyCouponsComponent, CouponClaimComponent] });
    MyCouponsModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: MyCouponsModule, providers: [
            i1.provideDefaultConfig({
                cmsComponents: {
                    MyCouponsComponent: {
                        component: MyCouponsComponent,
                        guards: [i1.AuthGuard],
                    },
                    CouponClaimComponent: {
                        component: CouponClaimComponent,
                        guards: [i1.AuthGuard],
                    },
                },
            }),
        ], imports: [[
                i3.CommonModule,
                CardModule,
                SpinnerModule,
                i1.I18nModule,
                i1$1.RouterModule,
                i1.UrlModule,
                IconModule,
                ListNavigationModule,
                i1$1.RouterModule.forChild([
                    {
                        path: null,
                        canActivate: [i1.AuthGuard, CmsPageGuard],
                        component: PageLayoutComponent,
                        data: { cxRoute: 'couponClaim' },
                    },
                ]),
            ]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: MyCouponsModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [
                            i3.CommonModule,
                            CardModule,
                            SpinnerModule,
                            i1.I18nModule,
                            i1$1.RouterModule,
                            i1.UrlModule,
                            IconModule,
                            ListNavigationModule,
                            i1$1.RouterModule.forChild([
                                {
                                    path: null,
                                    canActivate: [i1.AuthGuard, CmsPageGuard],
                                    component: PageLayoutComponent,
                                    data: { cxRoute: 'couponClaim' },
                                },
                            ]),
                        ],
                        declarations: [
                            MyCouponsComponent,
                            CouponCardComponent,
                            CouponDialogComponent,
                            CouponClaimComponent,
                        ],
                        providers: [
                            i1.provideDefaultConfig({
                                cmsComponents: {
                                    MyCouponsComponent: {
                                        component: MyCouponsComponent,
                                        guards: [i1.AuthGuard],
                                    },
                                    CouponClaimComponent: {
                                        component: CouponClaimComponent,
                                        guards: [i1.AuthGuard],
                                    },
                                },
                            }),
                        ],
                        exports: [MyCouponsComponent, CouponClaimComponent],
                    }]
            }] });

    var MyInterestsComponent = /** @class */ (function () {
        function MyInterestsComponent(productInterestService, translationService, productService) {
            this.productInterestService = productInterestService;
            this.translationService = translationService;
            this.productService = productService;
            this.DEFAULT_PAGE_SIZE = 10;
            this.sortMapping = {
                byNameAsc: 'name:asc',
                byNameDesc: 'name:desc',
            };
            this.sort = 'byNameAsc';
            this.sortOptions = [
                {
                    code: 'byNameAsc',
                    selected: false,
                },
                {
                    code: 'byNameDesc',
                    selected: false,
                },
            ];
        }
        MyInterestsComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.interests$ = this.productInterestService
                .getAndLoadProductInterests(this.DEFAULT_PAGE_SIZE)
                .pipe(operators.tap(function (interests) { return (_this.pagination = {
                currentPage: interests.pagination.page,
                pageSize: interests.pagination.count,
                totalPages: interests.pagination.totalPages,
                totalResults: interests.pagination.totalCount,
                sort: 'byNameAsc',
            }); }), operators.map(function (interest) { return (Object.assign(Object.assign({}, interest), { results: interest.results
                    ? interest.results.map(function (result) { return (Object.assign(Object.assign({}, result), { product$: _this.getProduct(result) })); })
                    : interest.results })); }));
            this.getInterestsloading$ =
                this.productInterestService.getProdutInterestsLoading();
            this.isRemoveDisabled$ = rxjs.combineLatest([
                this.getInterestsloading$,
                this.productInterestService.getRemoveProdutInterestLoading(),
            ]).pipe(operators.map(function (_a) {
                var _b = __read(_a, 2), getLoading = _b[0], removeLoading = _b[1];
                return getLoading || removeLoading;
            }));
            this.sortLabels = this.getSortLabels();
        };
        MyInterestsComponent.prototype.getSortLabels = function () {
            return rxjs.combineLatest([
                this.translationService.translate('myInterests.sorting.byNameAsc'),
                this.translationService.translate('myInterests.sorting.byNameDesc'),
            ]).pipe(operators.map(function (_a) {
                var _b = __read(_a, 2), asc = _b[0], desc = _b[1];
                return {
                    byNameAsc: asc,
                    byNameDesc: desc,
                };
            }));
        };
        MyInterestsComponent.prototype.getProduct = function (interest) {
            return this.productService.get(interest.product.code, "details" /* DETAILS */);
        };
        MyInterestsComponent.prototype.removeInterest = function (relation) {
            this.productInterestService.removeProdutInterest({
                product: relation.product,
                productInterestEntry: relation.productInterestEntry,
            });
        };
        MyInterestsComponent.prototype.sortChange = function (sort) {
            this.sort = sort;
            this.productInterestService.loadProductInterests(this.DEFAULT_PAGE_SIZE, 0, this.sortMapping[sort]);
        };
        MyInterestsComponent.prototype.pageChange = function (page) {
            this.productInterestService.loadProductInterests(this.DEFAULT_PAGE_SIZE, page, this.sortMapping[this.sort]);
        };
        MyInterestsComponent.prototype.ngOnDestroy = function () {
            this.productInterestService.clearProductInterests();
            this.productInterestService.resetRemoveInterestState();
        };
        return MyInterestsComponent;
    }());
    MyInterestsComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: MyInterestsComponent, deps: [{ token: i1__namespace.UserInterestsService }, { token: i1__namespace.TranslationService }, { token: i1__namespace.ProductService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    MyInterestsComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: MyInterestsComponent, selector: "cx-my-interests", ngImport: i0__namespace, template: "<div *ngIf=\"interests$ | async as interests\" class=\"container\">\n  <div class=\"cx-product-interests-title h3\">\n    <h3>{{ 'myInterests.header' | cxTranslate }}</h3>\n  </div>\n  <div\n    class=\"cx-product-interests-body\"\n    *ngIf=\"!(getInterestsloading$ | async); else loading\"\n  >\n    <ng-container *ngIf=\"interests.pagination.totalCount > 0; else noInterest\">\n      <div class=\"cx-product-interests-sort top row\">\n        <label\n          class=\"\n            cx-product-interests-form-group\n            form-group\n            col-sm-12 col-md-4 col-lg-4\n          \"\n          ><span>{{ 'myInterests.sortBy' | cxTranslate }}</span>\n          <cx-sorting\n            [sortOptions]=\"sortOptions\"\n            [sortLabels]=\"sortLabels | async\"\n            (sortListEvent)=\"sortChange($event)\"\n            [selectedOption]=\"sort\"\n            placeholder=\"{{ 'myInterests.sortBy' | cxTranslate }}\"\n          >\n          </cx-sorting>\n        </label>\n        <div\n          class=\"\n            cx-product-interests-pagination cx-product-interests-thead-mobile\n          \"\n        >\n          <cx-pagination\n            [pagination]=\"pagination\"\n            (viewPageEvent)=\"pageChange($event)\"\n          ></cx-pagination>\n        </div>\n      </div>\n      <table class=\"table cx-product-interests-table\">\n        <thead class=\"cx-product-interests-thead-mobile\">\n          <th scope=\"col\">\n            {{ 'myInterests.item' | cxTranslate }}\n          </th>\n          <th scope=\"col\"></th>\n          <th scope=\"col\">\n            {{ 'myInterests.price' | cxTranslate }}\n          </th>\n          <th scope=\"col\">\n            {{ 'myInterests.notifications' | cxTranslate }}\n          </th>\n          <th scope=\"col\"></th>\n        </thead>\n        <tbody>\n          <tr\n            *ngFor=\"let interest of interests.results\"\n            class=\"cx-product-interests-product-item\"\n          >\n            <ng-container *ngIf=\"interest.product$ | async as product\">\n              <td>\n                <div class=\"cx-product-interests-label\">\n                  <a\n                    class=\"cx-product-interests-product-image-link\"\n                    tabindex=\"-1\"\n                    [routerLink]=\"\n                      { cxRoute: 'product', params: product } | cxUrl\n                    \"\n                  >\n                    <cx-media\n                      [container]=\"product.images?.PRIMARY\"\n                      format=\"thumbnail\"\n                    ></cx-media>\n                  </a>\n                </div>\n              </td>\n              <td>\n                <div class=\"cx-info col-10\">\n                  <div class=\"cx-info-container row\">\n                    <div>\n                      <div *ngIf=\"product.name\" class=\"cx-name\">\n                        <a\n                          class=\"cx-link cx-product-interests-product-code-link\"\n                          [routerLink]=\"\n                            { cxRoute: 'product', params: product } | cxUrl\n                          \"\n                        >\n                          {{ product.name }}\n                        </a>\n                      </div>\n                      <div *ngIf=\"product.code\" class=\"cx-code\">\n                        <span>{{\n                          'myInterests.productId'\n                            | cxTranslate: { code: product.code }\n                        }}</span>\n                      </div>\n\n                      <ng-container\n                        *ngFor=\"let baseOptions of product.baseOptions\"\n                      >\n                        <div\n                          *ngFor=\"\n                            let variant of baseOptions.selected\n                              ?.variantOptionQualifiers\n                          \"\n                          class=\"cx-property\"\n                        >\n                          <div\n                            class=\"cx-label cx-product-interests-variant-name\"\n                          >\n                            {{ variant.name }}\n                          </div>\n                          <div\n                            class=\"cx-value cx-product-interests-variant-value\"\n                          >\n                            {{ variant.value }}\n                          </div>\n                        </div>\n                      </ng-container>\n                      <div\n                        class=\"cx-property\"\n                        *ngIf=\"product.stock.stockLevelStatus === 'outOfStock'\"\n                      >\n                        <div\n                          class=\"cx-label cx-product-interests-product-stock\"\n                        >\n                          {{ 'myInterests.outOfStock' | cxTranslate }}\n                        </div>\n                      </div>\n                    </div>\n                  </div>\n                </div>\n              </td>\n              <td>\n                <div class=\"cx-product-interests-product-price\">\n                  <div class=\"d-md-none cx-product-interests-label\">\n                    {{ 'myInterests.price' | cxTranslate }}\n                  </div>\n                  <span>{{ product.price.formattedValue }}</span>\n                </div>\n              </td>\n              <td>\n                <div class=\"cx-product-interests-subscriptions\">\n                  <div class=\"d-md-none cx-product-interests-label\">\n                    {{ 'myInterests.notifications' | cxTranslate }}\n                  </div>\n                  <div\n                    class=\"cx-product-interests-notification\"\n                    *ngFor=\"let interestEntry of interest.productInterestEntry\"\n                  >\n                    <span class=\"cx-product-interests-type\">\n                      {{\n                        'myInterests.' + interestEntry.interestType\n                          | cxTranslate\n                      }}\n                    </span>\n                    <span class=\"cx-product-interests-expiration-date\">\n                      {{\n                        'myInterests.expirationDate'\n                          | cxTranslate\n                            : {\n                                expirationDate:\n                                  interestEntry.expirationDate | date\n                              }\n                      }}\n                    </span>\n                  </div>\n                </div>\n              </td>\n              <td>\n                <div class=\"cx-actions cx-product-interests-remove-button\">\n                  <button\n                    type=\"button\"\n                    class=\"link cx-product-interests-remove-btn\"\n                    [disabled]=\"isRemoveDisabled$ | async\"\n                    (click)=\"removeInterest(interest)\"\n                  >\n                    {{ 'myInterests.remove' | cxTranslate }}\n                  </button>\n                </div>\n              </td>\n            </ng-container>\n          </tr>\n        </tbody>\n      </table>\n      <div class=\"cx-product-interests-sort bottom row\">\n        <label\n          class=\"\n            cx-product-interests-form-group cx-product-interests-thead-mobile\n            form-group\n            col-sm-12 col-md-4 col-lg-4\n          \"\n          ><span>{{ 'myInterests.sortBy' | cxTranslate }}</span>\n          <cx-sorting\n            [sortOptions]=\"sortOptions\"\n            [sortLabels]=\"sortLabels | async\"\n            (sortListEvent)=\"sortChange($event)\"\n            [selectedOption]=\"sort\"\n            placeholder=\"{{ 'myInterests.sortBy' | cxTranslate }}\"\n          >\n          </cx-sorting>\n        </label>\n        <div class=\"cx-product-interests-pagination\">\n          <cx-pagination\n            [pagination]=\"pagination\"\n            (viewPageEvent)=\"pageChange($event)\"\n          ></cx-pagination>\n        </div>\n      </div>\n    </ng-container>\n  </div>\n</div>\n<ng-template #noInterest>\n  <div class=\"cx-product-interests-message\">\n    {{ 'myInterests.noInterests' | cxTranslate }}\n  </div>\n</ng-template>\n<ng-template #loading>\n  <div class=\"cx-spinner\">\n    <cx-spinner></cx-spinner>\n  </div>\n</ng-template>\n", components: [{ type: SortingComponent, selector: "cx-sorting", inputs: ["sortOptions", "selectedOption", "placeholder", "sortLabels"], outputs: ["sortListEvent"] }, { type: PaginationComponent, selector: "cx-pagination", inputs: ["pageRoute", "queryParam", "defaultPage", "pagination"], outputs: ["viewPageEvent"] }, { type: MediaComponent, selector: "cx-media", inputs: ["container", "format", "alt", "role", "loading"], outputs: ["loaded"] }, { type: SpinnerComponent, selector: "cx-spinner" }], directives: [{ type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3__namespace.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i1__namespace$1.RouterLinkWithHref, selector: "a[routerLink],area[routerLink]", inputs: ["routerLink", "target", "queryParams", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange", "replaceUrl", "state", "relativeTo"] }], pipes: { "async": i3__namespace.AsyncPipe, "cxTranslate": i1__namespace.TranslatePipe, "cxUrl": i1__namespace.UrlPipe, "date": i3__namespace.DatePipe }, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: MyInterestsComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-my-interests',
                        templateUrl: './my-interests.component.html',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace.UserInterestsService }, { type: i1__namespace.TranslationService }, { type: i1__namespace.ProductService }]; } });

    var MyInterestsModule = /** @class */ (function () {
        function MyInterestsModule() {
        }
        return MyInterestsModule;
    }());
    MyInterestsModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: MyInterestsModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    MyInterestsModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: MyInterestsModule, declarations: [MyInterestsComponent], imports: [i3.CommonModule,
            i1.I18nModule,
            i1$1.RouterModule,
            ListNavigationModule,
            i1.I18nModule,
            i1.UrlModule,
            MediaModule,
            SpinnerModule], exports: [MyInterestsComponent] });
    MyInterestsModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: MyInterestsModule, providers: [
            i1.provideDefaultConfig({
                cmsComponents: {
                    MyInterestsComponent: {
                        component: MyInterestsComponent,
                        guards: [i1.AuthGuard],
                    },
                },
            }),
        ], imports: [[
                i3.CommonModule,
                i1.I18nModule,
                i1$1.RouterModule,
                ListNavigationModule,
                i1.I18nModule,
                i1.UrlModule,
                MediaModule,
                SpinnerModule,
            ]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: MyInterestsModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        declarations: [MyInterestsComponent],
                        imports: [
                            i3.CommonModule,
                            i1.I18nModule,
                            i1$1.RouterModule,
                            ListNavigationModule,
                            i1.I18nModule,
                            i1.UrlModule,
                            MediaModule,
                            SpinnerModule,
                        ],
                        providers: [
                            i1.provideDefaultConfig({
                                cmsComponents: {
                                    MyInterestsComponent: {
                                        component: MyInterestsComponent,
                                        guards: [i1.AuthGuard],
                                    },
                                },
                            }),
                        ],
                        exports: [MyInterestsComponent],
                    }]
            }] });

    var NotificationPreferenceComponent = /** @class */ (function () {
        function NotificationPreferenceComponent(notificationPreferenceService) {
            this.notificationPreferenceService = notificationPreferenceService;
            this.preferences = [];
        }
        NotificationPreferenceComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.notificationPreferenceService.resetNotificationPreferences();
            this.preferences$ = this.notificationPreferenceService
                .getPreferences()
                .pipe(operators.tap(function (preferences) { return (_this.preferences = preferences); }));
            this.notificationPreferenceService.loadPreferences();
            this.isLoading$ = rxjs.combineLatest([
                this.notificationPreferenceService.getPreferencesLoading(),
                this.notificationPreferenceService.getUpdatePreferencesResultLoading(),
            ]).pipe(operators.map(function (_a) {
                var _b = __read(_a, 2), prefsLoading = _b[0], updateLoading = _b[1];
                return prefsLoading || updateLoading;
            }));
        };
        NotificationPreferenceComponent.prototype.updatePreference = function (preference) {
            var updatedPreferences = [];
            this.preferences.forEach(function (p) {
                if (p.channel === preference.channel) {
                    updatedPreferences.push(Object.assign(Object.assign({}, p), { enabled: !p.enabled }));
                }
                else {
                    updatedPreferences.push(p);
                }
            });
            this.notificationPreferenceService.updatePreferences(updatedPreferences);
        };
        return NotificationPreferenceComponent;
    }());
    NotificationPreferenceComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: NotificationPreferenceComponent, deps: [{ token: i1__namespace.UserNotificationPreferenceService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    NotificationPreferenceComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: NotificationPreferenceComponent, selector: "cx-notification-preference", ngImport: i0__namespace, template: "<ng-container *ngIf=\"preferences$ | async as preferences\">\n  <div *ngIf=\"preferences.length > 0; else loading\">\n    <div class=\"row d-flex justify-content-center\">\n      <div class=\"col-md-8\">\n        <div class=\"pref-header\">\n          {{ 'notificationPreference.message' | cxTranslate }}\n        </div>\n        <div class=\"form-check cx-notification-channels\">\n          <ng-container *ngFor=\"let preference of preferences\">\n            <label *ngIf=\"preference.visible\" class=\"pref-channel\">\n              <input\n                class=\"form-check-input cx-np-checkbox\"\n                role=\"checkbox\"\n                type=\"checkbox\"\n                [checked]=\"preference.enabled\"\n                (change)=\"updatePreference(preference)\"\n                [disabled]=\"isLoading$ | async\"\n              />\n              <span class=\"form-check-label\">\n                {{\n                  'notificationPreference.' + preference.channel | cxTranslate\n                }}\n                {{ preference.value }}\n              </span>\n            </label>\n          </ng-container>\n        </div>\n        <label class=\"pref-note\"\n          ><strong>{{ 'notificationPreference.note' | cxTranslate }}</strong\n          >{{ 'notificationPreference.noteMessage' | cxTranslate }}\n        </label>\n      </div>\n    </div>\n  </div>\n\n  <ng-template #loading>\n    <div class=\"cx-spinner\">\n      <cx-spinner></cx-spinner>\n    </div>\n  </ng-template>\n</ng-container>\n", components: [{ type: SpinnerComponent, selector: "cx-spinner" }], directives: [{ type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3__namespace.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], pipes: { "async": i3__namespace.AsyncPipe, "cxTranslate": i1__namespace.TranslatePipe }, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: NotificationPreferenceComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-notification-preference',
                        templateUrl: './notification-preference.component.html',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace.UserNotificationPreferenceService }]; } });

    var NotificationPreferenceModule = /** @class */ (function () {
        function NotificationPreferenceModule() {
        }
        return NotificationPreferenceModule;
    }());
    NotificationPreferenceModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: NotificationPreferenceModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    NotificationPreferenceModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: NotificationPreferenceModule, declarations: [NotificationPreferenceComponent], imports: [i3.CommonModule, SpinnerModule, i1.I18nModule], exports: [NotificationPreferenceComponent] });
    NotificationPreferenceModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: NotificationPreferenceModule, providers: [
            i1.provideDefaultConfig({
                cmsComponents: {
                    NotificationPreferenceComponent: {
                        component: NotificationPreferenceComponent,
                        guards: [i1.AuthGuard],
                    },
                },
            }),
        ], imports: [[i3.CommonModule, SpinnerModule, i1.I18nModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: NotificationPreferenceModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        declarations: [NotificationPreferenceComponent],
                        imports: [i3.CommonModule, SpinnerModule, i1.I18nModule],
                        providers: [
                            i1.provideDefaultConfig({
                                cmsComponents: {
                                    NotificationPreferenceComponent: {
                                        component: NotificationPreferenceComponent,
                                        guards: [i1.AuthGuard],
                                    },
                                },
                            }),
                        ],
                        exports: [NotificationPreferenceComponent],
                    }]
            }] });

    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var AmendOrderActionsComponent = /** @class */ (function () {
        function AmendOrderActionsComponent(routingService) {
            this.routingService = routingService;
            this.styles = 'row';
        }
        AmendOrderActionsComponent.prototype.continue = function (event) {
            if (this.amendOrderForm.valid) {
                this.routingService.go({
                    cxRoute: this.forwardRoute,
                    params: { code: this.orderCode },
                });
            }
            else {
                this.amendOrderForm.markAllAsTouched();
                event.stopPropagation();
            }
        };
        return AmendOrderActionsComponent;
    }());
    AmendOrderActionsComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AmendOrderActionsComponent, deps: [{ token: i1__namespace.RoutingService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    AmendOrderActionsComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: AmendOrderActionsComponent, selector: "cx-amend-order-actions", inputs: { orderCode: "orderCode", amendOrderForm: "amendOrderForm", backRoute: "backRoute", forwardRoute: "forwardRoute" }, host: { properties: { "class": "this.styles" } }, ngImport: i0__namespace, template: "<div class=\"col-xs-12 col-md-4 col-lg-3\">\n  <a\n    [routerLink]=\"\n      {\n        cxRoute: backRoute,\n        params: { code: orderCode }\n      } | cxUrl\n    \"\n    class=\"btn btn-block btn-action\"\n  >\n    {{ 'common.back' | cxTranslate }}\n  </a>\n</div>\n<div class=\"col-xs-12 col-md-4 col-lg-3\">\n  <button\n    *ngIf=\"forwardRoute\"\n    class=\"btn btn-block btn-primary\"\n    (click)=\"continue($event)\"\n  >\n    {{ 'common.continue' | cxTranslate }}\n  </button>\n\n  <button *ngIf=\"!forwardRoute\" class=\"btn btn-block btn-primary\" type=\"submit\">\n    {{ 'orderDetails.cancellationAndReturn.submit' | cxTranslate }}\n  </button>\n</div>\n", directives: [{ type: i1__namespace$1.RouterLinkWithHref, selector: "a[routerLink],area[routerLink]", inputs: ["routerLink", "target", "queryParams", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange", "replaceUrl", "state", "relativeTo"] }, { type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "cxUrl": i1__namespace.UrlPipe, "cxTranslate": i1__namespace.TranslatePipe }, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AmendOrderActionsComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-amend-order-actions',
                        templateUrl: './amend-order-actions.component.html',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace.RoutingService }]; }, propDecorators: { orderCode: [{
                    type: i0.Input
                }], amendOrderForm: [{
                    type: i0.Input
                }], backRoute: [{
                    type: i0.Input
                }], forwardRoute: [{
                    type: i0.Input
                }], styles: [{
                    type: i0.HostBinding,
                    args: ['class']
                }] } });

    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var AmendOrderActionsModule = /** @class */ (function () {
        function AmendOrderActionsModule() {
        }
        return AmendOrderActionsModule;
    }());
    AmendOrderActionsModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AmendOrderActionsModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    AmendOrderActionsModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AmendOrderActionsModule, declarations: [AmendOrderActionsComponent], imports: [i3.CommonModule, i1$1.RouterModule, i1.UrlModule, i1.I18nModule], exports: [AmendOrderActionsComponent] });
    AmendOrderActionsModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AmendOrderActionsModule, imports: [[i3.CommonModule, i1$1.RouterModule, i1.UrlModule, i1.I18nModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AmendOrderActionsModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [i3.CommonModule, i1$1.RouterModule, i1.UrlModule, i1.I18nModule],
                        declarations: [AmendOrderActionsComponent],
                        exports: [AmendOrderActionsComponent],
                    }]
            }] });

    /**
     * @deprecated since 4.2 - use order lib instead
     */
    exports.AmendOrderType = void 0;
    (function (AmendOrderType) {
        AmendOrderType[AmendOrderType["CANCEL"] = 0] = "CANCEL";
        AmendOrderType[AmendOrderType["RETURN"] = 1] = "RETURN";
    })(exports.AmendOrderType || (exports.AmendOrderType = {}));

    // TODO: remove this token in 5.0
    var OrderDetailsServiceTransitionalToken = /** @class */ (function () {
        function OrderDetailsServiceTransitionalToken() {
        }
        return OrderDetailsServiceTransitionalToken;
    }());

    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var OrderDetailsService = /** @class */ (function () {
        function OrderDetailsService(userOrderService, routingService, unifiedInjector) {
            var _this = this;
            this.userOrderService = userOrderService;
            this.routingService = routingService;
            this.unifiedInjector = unifiedInjector;
            this.orderCode$ = this.routingService.getRouterState().pipe(operators.map(function (routingData) { return routingData.state.params.orderCode; }), operators.distinctUntilChanged());
            this.orderLoad$ = this.orderCode$.pipe(operators.tap(function (orderCode) {
                if (orderCode) {
                    _this.userOrderService.loadOrderDetails(orderCode);
                }
                else {
                    _this.userOrderService.clearOrderDetails();
                }
            }), operators.shareReplay({ bufferSize: 1, refCount: true }));
        }
        OrderDetailsService.prototype.getOrderDetails = function () {
            var _this = this;
            if (this.unifiedInjector) {
                var serivce = i1.getLastValueSync(this.unifiedInjector.get(OrderDetailsServiceTransitionalToken));
                if (serivce) {
                    return serivce.getOrderDetails();
                }
            }
            return this.orderLoad$.pipe(operators.switchMap(function () { return _this.userOrderService.getOrderDetails(); }));
        };
        return OrderDetailsService;
    }());
    OrderDetailsService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OrderDetailsService, deps: [{ token: i1__namespace.UserOrderService }, { token: i1__namespace.RoutingService }, { token: i1__namespace.UnifiedInjector }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    OrderDetailsService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OrderDetailsService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OrderDetailsService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace.UserOrderService }, { type: i1__namespace.RoutingService }, { type: i1__namespace.UnifiedInjector }]; } });

    function ValidateQuantityToCancel(control) {
        if (!control.value) {
            return null;
        }
        var quantity = Object.values(control.value).reduce(function (acc, val) { return acc + val; }, 0);
        return quantity > 0 ? null : { cxNoSelectedItemToCancel: true };
    }
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var OrderAmendService = /** @class */ (function () {
        function OrderAmendService(orderDetailsService) {
            this.orderDetailsService = orderDetailsService;
        }
        /**
         * Returns entries with an amended quantity.
         */
        OrderAmendService.prototype.getAmendedEntries = function () {
            var _this = this;
            return this.getForm().pipe(operators.switchMap(function (form) {
                return _this.getEntries().pipe(operators.map(function (entries) { return entries.filter(function (entry) { return _this.getFormControl(form, entry).value > 0; }); }));
            }));
        };
        OrderAmendService.prototype.getOrder = function () {
            return this.orderDetailsService.getOrderDetails();
        };
        /**
         * returns the form with form data at runtime
         */
        OrderAmendService.prototype.getForm = function () {
            var _this = this;
            return this.getOrder().pipe(operators.tap(function (order) {
                if (!_this.form || _this.form.get('orderCode').value !== order.code) {
                    _this.buildForm(order);
                }
            }), operators.map(function () { return _this.form; }));
        };
        OrderAmendService.prototype.buildForm = function (order) {
            var _this = this;
            this.form = new i3$1.FormGroup({});
            this.form.addControl('orderCode', new i3$1.FormControl(order.code));
            var entryGroup = new i3$1.FormGroup({}, { validators: [ValidateQuantityToCancel] });
            this.form.addControl('entries', entryGroup);
            (order.entries || []).forEach(function (entry) {
                var key = entry.entryNumber.toString();
                entryGroup.addControl(key, new i3$1.FormControl(0, {
                    validators: [
                        i3$1.Validators.min(0),
                        i3$1.Validators.max(_this.getMaxAmendQuantity(entry)),
                    ],
                }));
            });
        };
        OrderAmendService.prototype.getFormControl = function (form, entry) {
            return form.get('entries').get(entry.entryNumber.toString());
        };
        /**
         * As discussed, this calculation is moved to SPA side.
         * The calculation and validation should be in backend facade layer.
         */
        OrderAmendService.prototype.getAmendedPrice = function (entry) {
            var amendedQuantity = this.getFormControl(this.form, entry).value;
            var amendedPrice = Object.assign({}, entry.basePrice);
            amendedPrice.value =
                Math.round(entry.basePrice.value * amendedQuantity * 100) / 100;
            amendedPrice.formattedValue = i3.formatCurrency(amendedPrice.value, 
            // TODO: user current language
            'en', i3.getCurrencySymbol(amendedPrice.currencyIso, 'narrow'), amendedPrice.currencyIso);
            return amendedPrice;
        };
        OrderAmendService.prototype.getMaxAmendQuantity = function (entry) {
            return ((this.isCancellation()
                ? entry.cancellableQuantity
                : entry.returnableQuantity) || entry.quantity);
        };
        OrderAmendService.prototype.isCancellation = function () {
            return this.amendType === exports.AmendOrderType.CANCEL;
        };
        return OrderAmendService;
    }());
    OrderAmendService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OrderAmendService, deps: [{ token: OrderDetailsService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    OrderAmendService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OrderAmendService });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OrderAmendService, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: OrderDetailsService }]; } });

    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var CancelOrReturnItemsComponent = /** @class */ (function () {
        function CancelOrReturnItemsComponent(orderAmendService) {
            this.orderAmendService = orderAmendService;
            this.isConfirmation = false;
            this.form$ = this.orderAmendService.getForm();
        }
        CancelOrReturnItemsComponent.prototype.getControl = function (form, entry) {
            var control = (form.get('entries').get(entry.entryNumber.toString()));
            return control;
        };
        CancelOrReturnItemsComponent.prototype.setAll = function (form) {
            var _this = this;
            this.entries.forEach(function (entry) { return _this.getControl(form, entry).setValue(_this.getMaxAmendQuantity(entry)); });
        };
        CancelOrReturnItemsComponent.prototype.getItemPrice = function (entry) {
            return this.orderAmendService.getAmendedPrice(entry);
        };
        CancelOrReturnItemsComponent.prototype.getMaxAmendQuantity = function (entry) {
            return this.orderAmendService.getMaxAmendQuantity(entry);
        };
        CancelOrReturnItemsComponent.prototype.isCancellation = function () {
            return this.orderAmendService.isCancellation();
        };
        return CancelOrReturnItemsComponent;
    }());
    CancelOrReturnItemsComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CancelOrReturnItemsComponent, deps: [{ token: OrderAmendService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    CancelOrReturnItemsComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: CancelOrReturnItemsComponent, selector: "cx-amend-order-items", inputs: { entries: "entries", isConfirmation: "isConfirmation" }, ngImport: i0__namespace, template: "<div *ngIf=\"form$ | async as form\">\n  <button\n    *ngIf=\"!isConfirmation\"\n    class=\"btn btn-link cx-action-link\"\n    (click)=\"setAll(form)\"\n  >\n    {{ 'orderDetails.cancellationAndReturn.setAll' | cxTranslate }}\n  </button>\n\n  <div class=\"d-none d-md-block cx-item-list-header\">\n    <div class=\"row\">\n      <div class=\"text-left col-6\">\n        {{ 'orderDetails.cancellationAndReturn.item' | cxTranslate }}\n      </div>\n      <div class=\"text-center col-2\">\n        {{ 'orderDetails.cancellationAndReturn.itemPrice' | cxTranslate }}\n      </div>\n      <div *ngIf=\"!isConfirmation\" class=\"text-center col-2\">\n        {{ 'orderDetails.cancellationAndReturn.quantity' | cxTranslate }}\n      </div>\n      <div class=\"cx-item-list-qty col-2 text-right\">\n        {{\n          (isCancellation()\n            ? 'orderDetails.cancellationAndReturn.cancelQty'\n            : 'orderDetails.cancellationAndReturn.returnQty'\n          ) | cxTranslate\n        }}\n      </div>\n      <div *ngIf=\"isConfirmation\" class=\"cx-item-list-total col-2\">\n        {{ 'orderDetails.cancellationAndReturn.totalPrice' | cxTranslate }}\n      </div>\n    </div>\n  </div>\n\n  <div class=\"cx-item-list-row\" *ngFor=\"let item of entries; let i = index\">\n    <div class=\"row cx-item-list-items\">\n      <!-- Item Image -->\n      <cx-media\n        class=\"col-2\"\n        [container]=\"item.product.images?.PRIMARY\"\n        format=\"thumbnail\"\n      ></cx-media>\n\n      <!-- Item Information -->\n      <div class=\"cx-info col-10\">\n        <div class=\"cx-info-container row\">\n          <!-- Item Description -->\n          <div class=\"col-md-4 col-xl-5 cx-list-item-desc\">\n            <div *ngIf=\"item.product.name\" class=\"cx-name\">\n              {{ item.product.name }}\n            </div>\n            <div *ngIf=\"item.product.code\" class=\"cx-code\">\n              {{ 'cartItems.id' | cxTranslate }} {{ item.product.code }}\n            </div>\n            <!-- Variants -->\n            <ng-container *ngIf=\"item.product.baseOptions?.length\">\n              <div\n                *ngFor=\"\n                  let variant of item.product.baseOptions[0]?.selected\n                    ?.variantOptionQualifiers\n                \"\n                class=\"cx-property\"\n              >\n                <div class=\"cx-label\" *ngIf=\"variant.name\">\n                  {{ variant.name }}:\n                </div>\n                <div class=\"cx-value\" *ngIf=\"variant.value\">\n                  {{ variant.value }}\n                </div>\n              </div>\n            </ng-container>\n          </div>\n          <!-- Price -->\n          <div\n            *ngIf=\"item.basePrice\"\n            class=\"cx-price col-md-3 col-lg-3 col-xl-2\"\n          >\n            <div class=\"cx-label d-block d-md-none d-lg-none d-xl-none\">\n              {{ 'orderDetails.cancellationAndReturn.itemPrice' | cxTranslate }}\n            </div>\n            <div *ngIf=\"item.basePrice\" class=\"cx-value\">\n              {{ item.basePrice?.formattedValue }}\n            </div>\n          </div>\n          <!-- item Quantity -->\n          <div *ngIf=\"!isConfirmation\" class=\"cx-request-qty col-md-3\">\n            <div\n              class=\"cx-label d-block d-md-none d-lg-none d-xl-none\"\n              placement=\"left\"\n              title=\"{{ 'cartItems.quantityTitle' | cxTranslate }}\"\n            >\n              {{ 'orderDetails.cancellationAndReturn.quantity' | cxTranslate }}\n            </div>\n            <div class=\"cx-value\">\n              {{ getMaxAmendQuantity(item) }}\n            </div>\n          </div>\n          <!-- Amended Quantity -->\n          <div class=\"cx-quantity col-xs-12 col-md-2 col-sm-12\">\n            <div class=\"cx-label d-block d-md-none d-lg-none d-xl-none\">\n              {{\n                (isCancellation()\n                  ? 'orderDetails.cancellationAndReturn.cancelQty'\n                  : 'orderDetails.cancellationAndReturn.returnQty'\n                ) | cxTranslate\n              }}\n            </div>\n\n            <div\n              *ngIf=\"isConfirmation\"\n              class=\"w-100 text-center cx-order-quantity-value\"\n            >\n              {{ getControl(form, item).value }}\n            </div>\n            <cx-item-counter\n              *ngIf=\"!isConfirmation\"\n              [min]=\"0\"\n              [max]=\"getMaxAmendQuantity(item)\"\n              [control]=\"getControl(form, item)\"\n            >\n            </cx-item-counter>\n          </div>\n          <!-- Total Price -->\n          <div *ngIf=\"isConfirmation\" class=\"cx-total col-3\">\n            <div class=\"cx-label d-block d-md-none\">\n              {{\n                'orderDetails.cancellationAndReturn.totalPrice' | cxTranslate\n              }}\n            </div>\n            <div class=\"cx-value\">\n              {{ getItemPrice(item)?.formattedValue }}\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n", components: [{ type: MediaComponent, selector: "cx-media", inputs: ["container", "format", "alt", "role", "loading"], outputs: ["loaded"] }, { type: ItemCounterComponent, selector: "cx-item-counter", inputs: ["control", "min", "max", "step", "allowZero", "readonly"] }], directives: [{ type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3__namespace.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], pipes: { "async": i3__namespace.AsyncPipe, "cxTranslate": i1__namespace.TranslatePipe }, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CancelOrReturnItemsComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-amend-order-items',
                        templateUrl: './amend-order-items.component.html',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], ctorParameters: function () { return [{ type: OrderAmendService }]; }, propDecorators: { entries: [{
                    type: i0.Input
                }], isConfirmation: [{
                    type: i0.Input
                }] } });

    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var AmendOrderItemsModule = /** @class */ (function () {
        function AmendOrderItemsModule() {
        }
        return AmendOrderItemsModule;
    }());
    AmendOrderItemsModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AmendOrderItemsModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    AmendOrderItemsModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AmendOrderItemsModule, declarations: [CancelOrReturnItemsComponent], imports: [i3.CommonModule,
            i3$1.ReactiveFormsModule,
            i1.I18nModule,
            MediaModule,
            ItemCounterModule,
            i1.FeaturesConfigModule,
            FormErrorsModule], exports: [CancelOrReturnItemsComponent] });
    AmendOrderItemsModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AmendOrderItemsModule, imports: [[
                i3.CommonModule,
                i3$1.ReactiveFormsModule,
                i1.I18nModule,
                MediaModule,
                ItemCounterModule,
                i1.FeaturesConfigModule,
                FormErrorsModule,
            ]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AmendOrderItemsModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [
                            i3.CommonModule,
                            i3$1.ReactiveFormsModule,
                            i1.I18nModule,
                            MediaModule,
                            ItemCounterModule,
                            i1.FeaturesConfigModule,
                            FormErrorsModule,
                        ],
                        declarations: [CancelOrReturnItemsComponent],
                        exports: [CancelOrReturnItemsComponent],
                    }]
            }] });

    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var CancelOrderConfirmationComponent = /** @class */ (function () {
        function CancelOrderConfirmationComponent(orderAmendService) {
            var _this = this;
            this.orderAmendService = orderAmendService;
            this.form$ = this.orderAmendService
                .getForm()
                .pipe(operators.tap(function (form) { return (_this.orderCode = form.value.orderCode); }));
            this.entries$ = this.orderAmendService.getAmendedEntries();
        }
        CancelOrderConfirmationComponent.prototype.submit = function (form) {
            if (form.valid) {
                this.orderAmendService.save();
            }
            else {
                form.markAllAsTouched();
            }
        };
        return CancelOrderConfirmationComponent;
    }());
    CancelOrderConfirmationComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CancelOrderConfirmationComponent, deps: [{ token: OrderAmendService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    CancelOrderConfirmationComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: CancelOrderConfirmationComponent, selector: "cx-cancel-order-confirmation", ngImport: i0__namespace, template: "<form\n  *ngIf=\"form$ | async as form\"\n  [formGroup]=\"form\"\n  (ngSubmit)=\"submit(form)\"\n>\n  <ng-container *ngTemplateOutlet=\"actions\"></ng-container>\n\n  <cx-amend-order-items\n    *ngIf=\"entries$ | async as entries\"\n    [entries]=\"entries\"\n    [isConfirmation]=\"true\"\n  >\n  </cx-amend-order-items>\n\n  <ng-container *ngTemplateOutlet=\"actions\"></ng-container>\n\n  <ng-template #actions>\n    <cx-amend-order-actions\n      *ngIf=\"orderCode\"\n      [orderCode]=\"orderCode\"\n      [amendOrderForm]=\"form\"\n      backRoute=\"orderCancel\"\n    ></cx-amend-order-actions>\n  </ng-template>\n</form>\n", components: [{ type: CancelOrReturnItemsComponent, selector: "cx-amend-order-items", inputs: ["entries", "isConfirmation"] }, { type: AmendOrderActionsComponent, selector: "cx-amend-order-actions", inputs: ["orderCode", "amendOrderForm", "backRoute", "forwardRoute"] }], directives: [{ type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3__namespace$1.ɵNgNoValidate, selector: "form:not([ngNoForm]):not([ngNativeValidate])" }, { type: i3__namespace$1.NgControlStatusGroup, selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { type: i3__namespace$1.FormGroupDirective, selector: "[formGroup]", inputs: ["formGroup"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }, { type: i3__namespace.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }], pipes: { "async": i3__namespace.AsyncPipe }, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CancelOrderConfirmationComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-cancel-order-confirmation',
                        templateUrl: './cancel-order-confirmation.component.html',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], ctorParameters: function () { return [{ type: OrderAmendService }]; } });

    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var OrderCancellationService = /** @class */ (function (_super) {
        __extends(OrderCancellationService, _super);
        function OrderCancellationService(orderDetailsService, userOrderService, routing, globalMessageService) {
            var _this = _super.call(this, orderDetailsService) || this;
            _this.orderDetailsService = orderDetailsService;
            _this.userOrderService = userOrderService;
            _this.routing = routing;
            _this.globalMessageService = globalMessageService;
            _this.amendType = exports.AmendOrderType.CANCEL;
            return _this;
        }
        /**
         * Return cancellable order entries.
         */
        OrderCancellationService.prototype.getEntries = function () {
            return this.getOrder().pipe(operators.filter(function (order) { return !!(order === null || order === void 0 ? void 0 : order.entries); }), operators.map(function (order) { return order.entries.filter(function (entry) { return entry.entryNumber !== -1 && entry.cancellableQuantity > 0; }); }));
        };
        OrderCancellationService.prototype.save = function () {
            var _this = this;
            var orderCode = this.form.value.orderCode;
            var entries = this.form.value.entries;
            var inputs = Object.keys(entries)
                .filter(function (entryNumber) { return entries[entryNumber] > 0; })
                .map(function (entryNumber) { return ({
                orderEntryNumber: Number(entryNumber),
                quantity: entries[entryNumber],
            }); });
            this.form.reset();
            this.userOrderService.cancelOrder(orderCode, {
                cancellationRequestEntryInputs: inputs,
            });
            this.userOrderService
                .getCancelOrderSuccess()
                .pipe(operators.first(Boolean))
                .subscribe(function () { return _this.afterSave(orderCode); });
        };
        OrderCancellationService.prototype.afterSave = function (orderCode) {
            this.userOrderService.resetCancelOrderProcessState();
            this.globalMessageService.add({
                key: 'orderDetails.cancellationAndReturn.cancelSuccess',
                params: { orderCode: orderCode },
            }, i1.GlobalMessageType.MSG_TYPE_CONFIRMATION);
            this.routing.go({
                cxRoute: 'orders',
            });
        };
        return OrderCancellationService;
    }(OrderAmendService));
    OrderCancellationService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OrderCancellationService, deps: [{ token: OrderDetailsService }, { token: i1__namespace.UserOrderService }, { token: i1__namespace.RoutingService }, { token: i1__namespace.GlobalMessageService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    OrderCancellationService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OrderCancellationService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OrderCancellationService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: OrderDetailsService }, { type: i1__namespace.UserOrderService }, { type: i1__namespace.RoutingService }, { type: i1__namespace.GlobalMessageService }]; } });

    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var OrderCancellationGuard = /** @class */ (function () {
        function OrderCancellationGuard(orderAmendService, semanticPathService, router) {
            this.orderAmendService = orderAmendService;
            this.semanticPathService = semanticPathService;
            this.router = router;
        }
        OrderCancellationGuard.prototype.canActivate = function () {
            var _this = this;
            return this.orderAmendService.getForm().pipe(operators.map(function (form) {
                if (!form.valid) {
                    // the order code is not available in the route
                    // as long as we're inside a guard, hence we redirect
                    // to the common orders page.
                    return _this.router.parseUrl(_this.semanticPathService.get('orders'));
                }
                else {
                    return true;
                }
            }));
        };
        return OrderCancellationGuard;
    }());
    OrderCancellationGuard.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OrderCancellationGuard, deps: [{ token: OrderCancellationService }, { token: i1__namespace.SemanticPathService }, { token: i1__namespace$1.Router }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    OrderCancellationGuard.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OrderCancellationGuard, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OrderCancellationGuard, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: OrderCancellationService }, { type: i1__namespace.SemanticPathService }, { type: i1__namespace$1.Router }]; } });

    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var CancelOrderConfirmationModule = /** @class */ (function () {
        function CancelOrderConfirmationModule() {
        }
        return CancelOrderConfirmationModule;
    }());
    CancelOrderConfirmationModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CancelOrderConfirmationModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    CancelOrderConfirmationModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CancelOrderConfirmationModule, declarations: [CancelOrderConfirmationComponent], imports: [i3.CommonModule, i1__namespace$1.RouterModule, i3$1.ReactiveFormsModule,
            AmendOrderItemsModule,
            AmendOrderActionsModule], exports: [CancelOrderConfirmationComponent] });
    CancelOrderConfirmationModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CancelOrderConfirmationModule, providers: [
            i1.provideDefaultConfig({
                cmsComponents: {
                    CancelOrderConfirmationComponent: {
                        component: CancelOrderConfirmationComponent,
                        guards: [i1.AuthGuard, OrderCancellationGuard],
                        providers: [
                            {
                                provide: OrderAmendService,
                                useExisting: OrderCancellationService,
                            },
                        ],
                    },
                },
            }),
        ], imports: [[
                i3.CommonModule,
                i1$1.RouterModule.forChild([
                    {
                        path: null,
                        canActivate: [CmsPageGuard],
                        component: PageLayoutComponent,
                        data: {
                            cxRoute: 'orderCancelConfirmation',
                        },
                    },
                ]),
                i3$1.ReactiveFormsModule,
                AmendOrderItemsModule,
                AmendOrderActionsModule,
            ]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CancelOrderConfirmationModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [
                            i3.CommonModule,
                            i1$1.RouterModule.forChild([
                                {
                                    path: null,
                                    canActivate: [CmsPageGuard],
                                    component: PageLayoutComponent,
                                    data: {
                                        cxRoute: 'orderCancelConfirmation',
                                    },
                                },
                            ]),
                            i3$1.ReactiveFormsModule,
                            AmendOrderItemsModule,
                            AmendOrderActionsModule,
                        ],
                        providers: [
                            i1.provideDefaultConfig({
                                cmsComponents: {
                                    CancelOrderConfirmationComponent: {
                                        component: CancelOrderConfirmationComponent,
                                        guards: [i1.AuthGuard, OrderCancellationGuard],
                                        providers: [
                                            {
                                                provide: OrderAmendService,
                                                useExisting: OrderCancellationService,
                                            },
                                        ],
                                    },
                                },
                            }),
                        ],
                        declarations: [CancelOrderConfirmationComponent],
                        exports: [CancelOrderConfirmationComponent],
                    }]
            }] });

    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var CancelOrderComponent = /** @class */ (function () {
        function CancelOrderComponent(orderAmendService) {
            var _this = this;
            this.orderAmendService = orderAmendService;
            this.form$ = this.orderAmendService
                .getForm()
                .pipe(operators.tap(function (form) { return (_this.orderCode = form.value.orderCode); }));
            this.entries$ = this.orderAmendService.getEntries();
        }
        return CancelOrderComponent;
    }());
    CancelOrderComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CancelOrderComponent, deps: [{ token: OrderAmendService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    CancelOrderComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: CancelOrderComponent, selector: "cx-cancel-order", ngImport: i0__namespace, template: "<ng-container *ngIf=\"form$ | async as form\">\n  <ng-container *ngTemplateOutlet=\"actions\"></ng-container>\n\n  <cx-amend-order-items *ngIf=\"entries$ | async as entries\" [entries]=\"entries\">\n  </cx-amend-order-items>\n\n  <cx-form-errors\n    aria-live=\"assertive\"\n    aria-atomic=\"true\"\n    [control]=\"form.get('entries')\"\n  ></cx-form-errors>\n\n  <ng-container *ngTemplateOutlet=\"actions\"></ng-container>\n\n  <ng-template #actions>\n    <cx-amend-order-actions\n      *ngIf=\"orderCode\"\n      [orderCode]=\"orderCode\"\n      [amendOrderForm]=\"form\"\n      backRoute=\"orderDetails\"\n      forwardRoute=\"orderCancelConfirmation\"\n    ></cx-amend-order-actions>\n  </ng-template>\n</ng-container>\n", components: [{ type: CancelOrReturnItemsComponent, selector: "cx-amend-order-items", inputs: ["entries", "isConfirmation"] }, { type: FormErrorsComponent, selector: "cx-form-errors", inputs: ["prefix", "translationParams", "control"] }, { type: AmendOrderActionsComponent, selector: "cx-amend-order-actions", inputs: ["orderCode", "amendOrderForm", "backRoute", "forwardRoute"] }], directives: [{ type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3__namespace.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }], pipes: { "async": i3__namespace.AsyncPipe }, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CancelOrderComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-cancel-order',
                        templateUrl: './cancel-order.component.html',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], ctorParameters: function () { return [{ type: OrderAmendService }]; } });

    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var CancelOrderModule = /** @class */ (function () {
        function CancelOrderModule() {
        }
        return CancelOrderModule;
    }());
    CancelOrderModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CancelOrderModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    CancelOrderModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CancelOrderModule, declarations: [CancelOrderComponent], imports: [i3.CommonModule, i1__namespace$1.RouterModule, AmendOrderItemsModule,
            AmendOrderActionsModule,
            FormErrorsModule], exports: [CancelOrderComponent] });
    CancelOrderModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CancelOrderModule, providers: [
            i1.provideDefaultConfig({
                cmsComponents: {
                    CancelOrderComponent: {
                        component: CancelOrderComponent,
                        guards: [i1.AuthGuard],
                        providers: [
                            {
                                provide: OrderAmendService,
                                useExisting: OrderCancellationService,
                            },
                        ],
                    },
                },
            }),
        ], imports: [[
                i3.CommonModule,
                i1$1.RouterModule.forChild([
                    {
                        path: null,
                        canActivate: [CmsPageGuard],
                        component: PageLayoutComponent,
                        data: {
                            cxRoute: 'orderCancel',
                        },
                    },
                ]),
                AmendOrderItemsModule,
                AmendOrderActionsModule,
                FormErrorsModule,
            ]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CancelOrderModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [
                            i3.CommonModule,
                            i1$1.RouterModule.forChild([
                                {
                                    path: null,
                                    canActivate: [CmsPageGuard],
                                    component: PageLayoutComponent,
                                    data: {
                                        cxRoute: 'orderCancel',
                                    },
                                },
                            ]),
                            AmendOrderItemsModule,
                            AmendOrderActionsModule,
                            FormErrorsModule,
                        ],
                        providers: [
                            i1.provideDefaultConfig({
                                cmsComponents: {
                                    CancelOrderComponent: {
                                        component: CancelOrderComponent,
                                        guards: [i1.AuthGuard],
                                        providers: [
                                            {
                                                provide: OrderAmendService,
                                                useExisting: OrderCancellationService,
                                            },
                                        ],
                                    },
                                },
                            }),
                        ],
                        declarations: [CancelOrderComponent],
                        exports: [CancelOrderComponent],
                    }]
            }] });

    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var OrderCancellationModule = /** @class */ (function () {
        function OrderCancellationModule() {
        }
        return OrderCancellationModule;
    }());
    OrderCancellationModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OrderCancellationModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    OrderCancellationModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OrderCancellationModule, imports: [CancelOrderModule, CancelOrderConfirmationModule] });
    OrderCancellationModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OrderCancellationModule, imports: [[CancelOrderModule, CancelOrderConfirmationModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OrderCancellationModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [CancelOrderModule, CancelOrderConfirmationModule],
                    }]
            }] });

    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var OrderReturnService = /** @class */ (function (_super) {
        __extends(OrderReturnService, _super);
        function OrderReturnService(orderDetailsService, returnRequestService, routing, globalMessageService) {
            var _this = _super.call(this, orderDetailsService) || this;
            _this.orderDetailsService = orderDetailsService;
            _this.returnRequestService = returnRequestService;
            _this.routing = routing;
            _this.globalMessageService = globalMessageService;
            _this.amendType = exports.AmendOrderType.RETURN;
            return _this;
        }
        OrderReturnService.prototype.getEntries = function () {
            return this.getOrder().pipe(operators.filter(function (order) { return !!order.entries; }), operators.map(function (order) { return order.entries.filter(function (entry) { return entry.entryNumber !== -1 && entry.returnableQuantity > 0; }); }));
        };
        OrderReturnService.prototype.save = function () {
            var _this = this;
            var orderCode = this.form.value.orderCode;
            var entries = this.form.value.entries;
            var inputs = Object.keys(entries)
                .filter(function (entryNumber) { return entries[entryNumber] > 0; })
                .map(function (entryNumber) { return ({
                orderEntryNumber: Number(entryNumber),
                quantity: entries[entryNumber],
            }); });
            this.form.reset();
            this.returnRequestService.createOrderReturnRequest({
                orderCode: orderCode,
                returnRequestEntryInputs: inputs,
            });
            this.returnRequestService
                .getReturnRequestSuccess()
                .pipe(operators.first(Boolean))
                .subscribe(function () { return _this.afterSave(); });
        };
        OrderReturnService.prototype.afterSave = function () {
            var _this = this;
            this.returnRequestService
                .getOrderReturnRequest()
                .pipe(operators.first(function (r) { return !!r; }))
                .subscribe(function (returnRequest) {
                var rma = returnRequest.rma;
                _this.globalMessageService.add({
                    key: 'orderDetails.cancellationAndReturn.returnSuccess',
                    params: { rma: rma },
                }, i1.GlobalMessageType.MSG_TYPE_CONFIRMATION);
                _this.routing.go({
                    cxRoute: 'returnRequestDetails',
                    params: { rma: rma },
                });
            });
        };
        return OrderReturnService;
    }(OrderAmendService));
    OrderReturnService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OrderReturnService, deps: [{ token: OrderDetailsService }, { token: i1__namespace.OrderReturnRequestService }, { token: i1__namespace.RoutingService }, { token: i1__namespace.GlobalMessageService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    OrderReturnService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OrderReturnService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OrderReturnService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: OrderDetailsService }, { type: i1__namespace.OrderReturnRequestService }, { type: i1__namespace.RoutingService }, { type: i1__namespace.GlobalMessageService }]; } });

    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var OrderReturnGuard = /** @class */ (function () {
        function OrderReturnGuard(orderAmendService, semanticPathService, router) {
            this.orderAmendService = orderAmendService;
            this.semanticPathService = semanticPathService;
            this.router = router;
        }
        OrderReturnGuard.prototype.canActivate = function () {
            var _this = this;
            return this.orderAmendService.getForm().pipe(operators.map(function (form) {
                if (!form.valid) {
                    // the order code is not available in the route
                    // as long as we're inside a guard, hence we redirect
                    // to the common orders page.
                    return _this.router.parseUrl(_this.semanticPathService.get('orders'));
                }
                else {
                    return true;
                }
            }));
        };
        return OrderReturnGuard;
    }());
    OrderReturnGuard.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OrderReturnGuard, deps: [{ token: OrderReturnService }, { token: i1__namespace.SemanticPathService }, { token: i1__namespace$1.Router }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    OrderReturnGuard.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OrderReturnGuard, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OrderReturnGuard, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: OrderReturnService }, { type: i1__namespace.SemanticPathService }, { type: i1__namespace$1.Router }]; } });

    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var ReturnOrderConfirmationComponent = /** @class */ (function () {
        function ReturnOrderConfirmationComponent(orderAmendService) {
            var _this = this;
            this.orderAmendService = orderAmendService;
            this.form$ = this.orderAmendService
                .getForm()
                .pipe(operators.tap(function (form) { return (_this.orderCode = form.value.orderCode); }));
            this.entries$ = this.orderAmendService.getAmendedEntries();
        }
        ReturnOrderConfirmationComponent.prototype.submit = function (form) {
            form.disable();
            this.orderAmendService.save();
        };
        return ReturnOrderConfirmationComponent;
    }());
    ReturnOrderConfirmationComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ReturnOrderConfirmationComponent, deps: [{ token: OrderAmendService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    ReturnOrderConfirmationComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: ReturnOrderConfirmationComponent, selector: "cx-return-order-confirmation", ngImport: i0__namespace, template: "<form\n  *ngIf=\"form$ | async as form\"\n  [formGroup]=\"form\"\n  (ngSubmit)=\"submit(form)\"\n>\n  <ng-container *ngTemplateOutlet=\"actions\"></ng-container>\n\n  <cx-amend-order-items\n    *ngIf=\"entries$ | async as entries\"\n    [entries]=\"entries\"\n    [isConfirmation]=\"true\"\n  >\n  </cx-amend-order-items>\n\n  <ng-container *ngTemplateOutlet=\"actions\"></ng-container>\n\n  <ng-template #actions>\n    <cx-amend-order-actions\n      *ngIf=\"orderCode\"\n      [orderCode]=\"orderCode\"\n      [amendOrderForm]=\"form\"\n      backRoute=\"orderReturn\"\n    ></cx-amend-order-actions>\n  </ng-template>\n</form>\n", components: [{ type: CancelOrReturnItemsComponent, selector: "cx-amend-order-items", inputs: ["entries", "isConfirmation"] }, { type: AmendOrderActionsComponent, selector: "cx-amend-order-actions", inputs: ["orderCode", "amendOrderForm", "backRoute", "forwardRoute"] }], directives: [{ type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3__namespace$1.ɵNgNoValidate, selector: "form:not([ngNoForm]):not([ngNativeValidate])" }, { type: i3__namespace$1.NgControlStatusGroup, selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { type: i3__namespace$1.FormGroupDirective, selector: "[formGroup]", inputs: ["formGroup"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }, { type: i3__namespace.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }], pipes: { "async": i3__namespace.AsyncPipe }, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ReturnOrderConfirmationComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-return-order-confirmation',
                        templateUrl: './return-order-confirmation.component.html',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], ctorParameters: function () { return [{ type: OrderAmendService }]; } });

    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var ReturnOrderConfirmationModule = /** @class */ (function () {
        function ReturnOrderConfirmationModule() {
        }
        return ReturnOrderConfirmationModule;
    }());
    ReturnOrderConfirmationModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ReturnOrderConfirmationModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    ReturnOrderConfirmationModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ReturnOrderConfirmationModule, declarations: [ReturnOrderConfirmationComponent], imports: [i3.CommonModule, i1__namespace$1.RouterModule, AmendOrderItemsModule,
            i1.I18nModule,
            i3$1.ReactiveFormsModule,
            AmendOrderActionsModule], exports: [ReturnOrderConfirmationComponent] });
    ReturnOrderConfirmationModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ReturnOrderConfirmationModule, providers: [
            i1.provideDefaultConfig({
                cmsComponents: {
                    ReturnOrderConfirmationComponent: {
                        component: ReturnOrderConfirmationComponent,
                        guards: [i1.AuthGuard, OrderReturnGuard],
                        providers: [
                            {
                                provide: OrderAmendService,
                                useExisting: OrderReturnService,
                            },
                        ],
                    },
                },
            }),
        ], imports: [[
                i3.CommonModule,
                i1$1.RouterModule.forChild([
                    {
                        path: null,
                        canActivate: [CmsPageGuard],
                        component: PageLayoutComponent,
                        data: {
                            cxRoute: 'orderReturnConfirmation',
                        },
                    },
                ]),
                AmendOrderItemsModule,
                i1.I18nModule,
                i3$1.ReactiveFormsModule,
                AmendOrderActionsModule,
            ]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ReturnOrderConfirmationModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [
                            i3.CommonModule,
                            i1$1.RouterModule.forChild([
                                {
                                    path: null,
                                    canActivate: [CmsPageGuard],
                                    component: PageLayoutComponent,
                                    data: {
                                        cxRoute: 'orderReturnConfirmation',
                                    },
                                },
                            ]),
                            AmendOrderItemsModule,
                            i1.I18nModule,
                            i3$1.ReactiveFormsModule,
                            AmendOrderActionsModule,
                        ],
                        providers: [
                            i1.provideDefaultConfig({
                                cmsComponents: {
                                    ReturnOrderConfirmationComponent: {
                                        component: ReturnOrderConfirmationComponent,
                                        guards: [i1.AuthGuard, OrderReturnGuard],
                                        providers: [
                                            {
                                                provide: OrderAmendService,
                                                useExisting: OrderReturnService,
                                            },
                                        ],
                                    },
                                },
                            }),
                        ],
                        declarations: [ReturnOrderConfirmationComponent],
                        exports: [ReturnOrderConfirmationComponent],
                    }]
            }] });

    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var ReturnOrderComponent = /** @class */ (function () {
        function ReturnOrderComponent(orderAmendService) {
            var _this = this;
            this.orderAmendService = orderAmendService;
            this.form$ = this.orderAmendService
                .getForm()
                .pipe(operators.tap(function (form) { return (_this.orderCode = form.value.orderCode); }));
            this.entries$ = this.orderAmendService.getEntries();
        }
        return ReturnOrderComponent;
    }());
    ReturnOrderComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ReturnOrderComponent, deps: [{ token: OrderAmendService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    ReturnOrderComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: ReturnOrderComponent, selector: "cx-return-order", ngImport: i0__namespace, template: "<ng-container *ngIf=\"form$ | async as form\">\n  <ng-container *ngTemplateOutlet=\"actions\"></ng-container>\n\n  <cx-amend-order-items *ngIf=\"entries$ | async as entries\" [entries]=\"entries\">\n  </cx-amend-order-items>\n\n  <cx-form-errors\n    aria-live=\"assertive\"\n    aria-atomic=\"true\"\n    [control]=\"form.get('entries')\"\n  ></cx-form-errors>\n\n  <ng-container *ngTemplateOutlet=\"actions\"></ng-container>\n\n  <ng-template #actions>\n    <cx-amend-order-actions\n      *ngIf=\"orderCode\"\n      [orderCode]=\"orderCode\"\n      [amendOrderForm]=\"form\"\n      backRoute=\"orderDetails\"\n      forwardRoute=\"orderReturnConfirmation\"\n    ></cx-amend-order-actions>\n  </ng-template>\n</ng-container>\n", components: [{ type: CancelOrReturnItemsComponent, selector: "cx-amend-order-items", inputs: ["entries", "isConfirmation"] }, { type: FormErrorsComponent, selector: "cx-form-errors", inputs: ["prefix", "translationParams", "control"] }, { type: AmendOrderActionsComponent, selector: "cx-amend-order-actions", inputs: ["orderCode", "amendOrderForm", "backRoute", "forwardRoute"] }], directives: [{ type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3__namespace.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }], pipes: { "async": i3__namespace.AsyncPipe }, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ReturnOrderComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-return-order',
                        templateUrl: './return-order.component.html',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], ctorParameters: function () { return [{ type: OrderAmendService }]; } });

    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var ReturnOrderModule = /** @class */ (function () {
        function ReturnOrderModule() {
        }
        return ReturnOrderModule;
    }());
    ReturnOrderModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ReturnOrderModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    ReturnOrderModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ReturnOrderModule, declarations: [ReturnOrderComponent], imports: [i3.CommonModule, i1__namespace$1.RouterModule, AmendOrderItemsModule,
            AmendOrderActionsModule,
            FormErrorsModule], exports: [ReturnOrderComponent] });
    ReturnOrderModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ReturnOrderModule, providers: [
            i1.provideDefaultConfig({
                cmsComponents: {
                    ReturnOrderComponent: {
                        component: ReturnOrderComponent,
                        guards: [i1.AuthGuard],
                        providers: [
                            {
                                provide: OrderAmendService,
                                useExisting: OrderReturnService,
                            },
                        ],
                    },
                },
            }),
        ], imports: [[
                i3.CommonModule,
                i1$1.RouterModule.forChild([
                    {
                        path: null,
                        canActivate: [CmsPageGuard],
                        component: PageLayoutComponent,
                        data: {
                            cxRoute: 'orderReturn',
                        },
                    },
                ]),
                AmendOrderItemsModule,
                AmendOrderActionsModule,
                FormErrorsModule,
            ]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ReturnOrderModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [
                            i3.CommonModule,
                            i1$1.RouterModule.forChild([
                                {
                                    path: null,
                                    canActivate: [CmsPageGuard],
                                    component: PageLayoutComponent,
                                    data: {
                                        cxRoute: 'orderReturn',
                                    },
                                },
                            ]),
                            AmendOrderItemsModule,
                            AmendOrderActionsModule,
                            FormErrorsModule,
                        ],
                        providers: [
                            i1.provideDefaultConfig({
                                cmsComponents: {
                                    ReturnOrderComponent: {
                                        component: ReturnOrderComponent,
                                        guards: [i1.AuthGuard],
                                        providers: [
                                            {
                                                provide: OrderAmendService,
                                                useExisting: OrderReturnService,
                                            },
                                        ],
                                    },
                                },
                            }),
                        ],
                        declarations: [ReturnOrderComponent],
                        exports: [ReturnOrderComponent],
                    }]
            }] });

    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var OrderReturnModule = /** @class */ (function () {
        function OrderReturnModule() {
        }
        return OrderReturnModule;
    }());
    OrderReturnModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OrderReturnModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    OrderReturnModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OrderReturnModule, imports: [ReturnOrderModule, ReturnOrderConfirmationModule] });
    OrderReturnModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OrderReturnModule, imports: [[ReturnOrderModule, ReturnOrderConfirmationModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OrderReturnModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [ReturnOrderModule, ReturnOrderConfirmationModule],
                    }]
            }] });

    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var OrderDetailActionsComponent = /** @class */ (function () {
        function OrderDetailActionsComponent(orderDetailsService) {
            this.orderDetailsService = orderDetailsService;
            this.order$ = this.orderDetailsService.getOrderDetails();
        }
        return OrderDetailActionsComponent;
    }());
    OrderDetailActionsComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OrderDetailActionsComponent, deps: [{ token: OrderDetailsService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    OrderDetailActionsComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: OrderDetailActionsComponent, selector: "cx-order-details-actions", ngImport: i0__namespace, template: "<ng-container *ngIf=\"order$ | async as order\">\n  <div class=\"cx-nav row\">\n    <div class=\"col-xs-12 col-md-4 col-lg-3\">\n      <button\n        [routerLink]=\"{ cxRoute: 'orders' } | cxUrl\"\n        class=\"btn btn-block btn-action\"\n      >\n        {{ 'common.back' | cxTranslate }}\n      </button>\n    </div>\n\n    <div class=\"col-xs-12 col-md-4 col-lg-3\">\n      <a\n        *ngIf=\"order.cancellable\"\n        [routerLink]=\"\n          {\n            cxRoute: 'orderCancel',\n            params: order\n          } | cxUrl\n        \"\n        class=\"btn btn-block btn-action\"\n      >\n        {{ 'orderDetails.cancellationAndReturn.cancelAction' | cxTranslate }}\n      </a>\n\n      <a\n        *ngIf=\"order.returnable\"\n        [routerLink]=\"\n          {\n            cxRoute: 'orderReturn',\n            params: order\n          } | cxUrl\n        \"\n        class=\"btn btn-block btn-action\"\n      >\n        {{ 'orderDetails.cancellationAndReturn.returnAction' | cxTranslate }}\n      </a>\n    </div>\n  </div>\n</ng-container>\n", directives: [{ type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i1__namespace$1.RouterLink, selector: ":not(a):not(area)[routerLink]", inputs: ["routerLink", "queryParams", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange", "replaceUrl", "state", "relativeTo"] }, { type: i1__namespace$1.RouterLinkWithHref, selector: "a[routerLink],area[routerLink]", inputs: ["routerLink", "target", "queryParams", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange", "replaceUrl", "state", "relativeTo"] }], pipes: { "async": i3__namespace.AsyncPipe, "cxUrl": i1__namespace.UrlPipe, "cxTranslate": i1__namespace.TranslatePipe } });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OrderDetailActionsComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-order-details-actions',
                        templateUrl: './order-detail-actions.component.html',
                    }]
            }], ctorParameters: function () { return [{ type: OrderDetailsService }]; } });

    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var TrackingEventsComponent = /** @class */ (function () {
        function TrackingEventsComponent(activeModal, userOrderService) {
            this.activeModal = activeModal;
            this.userOrderService = userOrderService;
        }
        TrackingEventsComponent.prototype.ngOnDestroy = function () {
            this.userOrderService.clearConsignmentTracking();
        };
        return TrackingEventsComponent;
    }());
    TrackingEventsComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: TrackingEventsComponent, deps: [{ token: i1__namespace$3.NgbActiveModal }, { token: i1__namespace.UserOrderService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    TrackingEventsComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: TrackingEventsComponent, selector: "cx-tracking-events", ngImport: i0__namespace, template: "<div class=\"cx-consignment-tracking-dialog\">\n  <!-- Modal Header -->\n  <ng-container *ngIf=\"tracking$ | async as consignmentTracking; else loading\">\n    <div class=\"header modal-header\">\n      <div class=\"title modal-title\">\n        {{ 'orderDetails.consignmentTracking.dialog.header' | cxTranslate }}\n      </div>\n      <button\n        type=\"button\"\n        class=\"close\"\n        [attr.aria-label]=\"'common.close' | cxTranslate\"\n        (click)=\"activeModal.dismiss('Cross click')\"\n      >\n        <span aria-hidden=\"true\">&times;</span>\n      </button>\n    </div>\n    <!-- Modal Body -->\n    <!-- shipment header -->\n    <ng-container\n      *ngIf=\"\n        consignmentTracking?.carrierDetails && consignmentTracking?.trackingID;\n        else noTracking\n      \"\n    >\n      <div class=\"shipment-heading\">\n        <div class=\"row\">\n          <div class=\"col-sm-12 col-md-6\">\n            <div class=\"shipment-title\">\n              {{\n                'orderDetails.consignmentTracking.dialog.shipped' | cxTranslate\n              }}\n            </div>\n            <div class=\"shipment-content\">\n              {{ shipDate | cxDate: 'medium' }}\n            </div>\n          </div>\n          <div class=\"col-sm-12 col-md-6\">\n            <div class=\"shipment-title\">\n              {{\n                'orderDetails.consignmentTracking.dialog.estimate' | cxTranslate\n              }}\n            </div>\n            <div class=\"shipment-content\">\n              {{ consignmentTracking?.targetArrivalDate | cxDate: 'medium' }}\n            </div>\n          </div>\n        </div>\n\n        <div class=\"row\">\n          <div class=\"col-sm-12 col-md-6\">\n            <div class=\"shipment-title\">\n              {{\n                'orderDetails.consignmentTracking.dialog.carrier' | cxTranslate\n              }}\n            </div>\n            <div class=\"shipment-content\">\n              {{ consignmentTracking?.carrierDetails?.name }}\n            </div>\n          </div>\n          <div class=\"col-sm-12 col-md-6\">\n            <div class=\"shipment-title\">\n              {{\n                'orderDetails.consignmentTracking.dialog.trackingId'\n                  | cxTranslate\n              }}\n            </div>\n            <div class=\"shipment-content\">\n              <ng-container *ngIf=\"consignmentTracking?.trackingUrl\">\n                <a target=\"_blank\" [href]=\"consignmentTracking.trackingUrl\">{{\n                  consignmentTracking?.trackingID\n                }}</a>\n              </ng-container>\n              <ng-container *ngIf=\"!consignmentTracking?.trackingUrl\">\n                <label>\n                  {{ consignmentTracking?.trackingID }}\n                </label>\n              </ng-container>\n            </div>\n          </div>\n        </div>\n      </div>\n    </ng-container>\n\n    <!-- tracking events -->\n    <div class=\"events modal-body\">\n      <ng-container\n        *ngFor=\"let consignmentEvent of consignmentTracking.trackingEvents\"\n      >\n        <div class=\"event-body\">\n          <div class=\"event-content\">\n            {{ consignmentEvent.eventDate | cxDate: 'medium' }}\n          </div>\n          <div class=\"event-title\">\n            {{ consignmentEvent.referenceCode }}\n          </div>\n          <div class=\"event-content\">{{ consignmentEvent.detail }}</div>\n          <div class=\"event-city\">\n            location: {{ consignmentEvent.location }}\n          </div>\n        </div>\n      </ng-container>\n    </div>\n  </ng-container>\n\n  <ng-template #noTracking>\n    <div class=\"no-tracking-heading\">\n      <div class=\"shipment-content\">\n        {{ 'orderDetails.consignmentTracking.dialog.noTracking' | cxTranslate }}\n      </div>\n    </div>\n  </ng-template>\n\n  <ng-template #loading>\n    <div class=\"tracking-loading\">\n      <div class=\"header modal-header\">\n        <div class=\"title modal-title\">\n          {{\n            'orderDetails.consignmentTracking.dialog.loadingHeader'\n              | cxTranslate\n          }}\n        </div>\n        <button\n          type=\"button\"\n          class=\"close btn-dismiss\"\n          [attr.aria-label]=\"'common.close' | cxTranslate\"\n          (click)=\"activeModal.dismiss('Cross click')\"\n        >\n          <span aria-hidden=\"true\">&times;</span>\n        </button>\n      </div>\n      <!-- Modal Body -->\n      <div class=\"body modal-body\">\n        <div class=\"row\">\n          <div class=\"col-sm-12\">\n            <cx-spinner></cx-spinner>\n          </div>\n        </div>\n      </div>\n    </div>\n  </ng-template>\n</div>\n", components: [{ type: SpinnerComponent, selector: "cx-spinner" }], directives: [{ type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3__namespace.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], pipes: { "async": i3__namespace.AsyncPipe, "cxTranslate": i1__namespace.TranslatePipe, "cxDate": i1__namespace.CxDatePipe } });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: TrackingEventsComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-tracking-events',
                        templateUrl: './tracking-events.component.html',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace$3.NgbActiveModal }, { type: i1__namespace.UserOrderService }]; } });

    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var ConsignmentTrackingComponent = /** @class */ (function () {
        function ConsignmentTrackingComponent(userOrderService, modalService) {
            this.userOrderService = userOrderService;
            this.modalService = modalService;
            this.consignmentStatus = [
                'SHIPPED',
                'IN_TRANSIT',
                'DELIVERY_COMPLETED',
                'DELIVERY_REJECTED',
                'DELIVERING',
            ];
        }
        ConsignmentTrackingComponent.prototype.ngOnInit = function () {
            this.consignmentTracking$ = this.userOrderService.getConsignmentTracking();
        };
        ConsignmentTrackingComponent.prototype.openTrackingDialog = function (consignment) {
            this.userOrderService.loadConsignmentTracking(this.orderCode, consignment.code);
            var modalInstance;
            this.modalRef = this.modalService.open(TrackingEventsComponent, {
                centered: true,
                size: 'lg',
            });
            modalInstance = this.modalRef.componentInstance;
            modalInstance.tracking$ = this.consignmentTracking$;
            modalInstance.shipDate = consignment.statusDate;
            modalInstance.consignmentCode = consignment.code;
        };
        ConsignmentTrackingComponent.prototype.ngOnDestroy = function () {
            this.userOrderService.clearConsignmentTracking();
        };
        return ConsignmentTrackingComponent;
    }());
    ConsignmentTrackingComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ConsignmentTrackingComponent, deps: [{ token: i1__namespace.UserOrderService }, { token: ModalService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    ConsignmentTrackingComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: ConsignmentTrackingComponent, selector: "cx-consignment-tracking", inputs: { consignment: "consignment", orderCode: "orderCode" }, ngImport: i0__namespace, template: "<ng-container *ngIf=\"consignment && consignment.status\">\n  <div *ngIf=\"consignmentStatus.includes(consignment.status)\">\n    <button\n      (click)=\"openTrackingDialog(consignment)\"\n      class=\"btn btn-action btn-track\"\n      type=\"button\"\n    >\n      {{ 'orderDetails.consignmentTracking.action' | cxTranslate }}\n    </button>\n  </div>\n</ng-container>\n", directives: [{ type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "cxTranslate": i1__namespace.TranslatePipe } });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ConsignmentTrackingComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-consignment-tracking',
                        templateUrl: './consignment-tracking.component.html',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace.UserOrderService }, { type: ModalService }]; }, propDecorators: { consignment: [{
                    type: i0.Input
                }], orderCode: [{
                    type: i0.Input
                }] } });

    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var OrderConsignedEntriesComponent = /** @class */ (function () {
        function OrderConsignedEntriesComponent() {
            this.promotionLocation = i1.PromotionLocation.Order;
        }
        OrderConsignedEntriesComponent.prototype.getConsignmentProducts = function (consignment) {
            var products = [];
            consignment.entries.forEach(function (element) {
                products.push(element.orderEntry);
            });
            return products;
        };
        return OrderConsignedEntriesComponent;
    }());
    OrderConsignedEntriesComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OrderConsignedEntriesComponent, deps: [], target: i0__namespace.ɵɵFactoryTarget.Component });
    OrderConsignedEntriesComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: OrderConsignedEntriesComponent, selector: "cx-order-consigned-entries", inputs: { consignments: "consignments", order: "order" }, ngImport: i0__namespace, template: "<div *ngFor=\"let consignment of consignments\" class=\"cx-list row\">\n  <div class=\"cx-list-header col-12\">\n    <div class=\"cx-list-status\">\n      <span *ngIf=\"consignment\">\n        {{ 'orderDetails.deliveryStatus_' + consignment?.status | cxTranslate }}\n      </span>\n    </div>\n    <div *ngIf=\"consignment?.statusDate\" class=\"cx-list-date\">\n      <div>{{ consignment?.statusDate | cxDate }}</div>\n    </div>\n\n    <cx-consignment-tracking\n      [orderCode]=\"order.code\"\n      [consignment]=\"consignment\"\n      *cxFeature=\"'consignmentTracking'\"\n    >\n    </cx-consignment-tracking>\n  </div>\n  <div class=\"cx-list-item col-12\">\n    <cx-cart-item-list\n      [items]=\"consignment.entries\"\n      [readonly]=\"true\"\n      [promotionLocation]=\"promotionLocation\"\n    ></cx-cart-item-list>\n  </div>\n</div>\n", components: [{ type: ConsignmentTrackingComponent, selector: "cx-consignment-tracking", inputs: ["consignment", "orderCode"] }, { type: CartItemListComponent, selector: "cx-cart-item-list", inputs: ["readonly", "hasHeader", "options", "cartId", "items", "promotionLocation", "cartIsLoading"] }], directives: [{ type: i3__namespace.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i1__namespace.FeatureDirective, selector: "[cxFeature]", inputs: ["cxFeature"] }], pipes: { "cxTranslate": i1__namespace.TranslatePipe, "cxDate": i1__namespace.CxDatePipe } });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OrderConsignedEntriesComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-order-consigned-entries',
                        templateUrl: './order-consigned-entries.component.html',
                    }]
            }], propDecorators: { consignments: [{
                    type: i0.Input
                }], order: [{
                    type: i0.Input
                }] } });

    var completedValues = ['DELIVERY_COMPLETED', 'PICKUP_COMPLETE'];
    var cancelledValues = ['CANCELLED'];

    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var OrderDetailItemsComponent = /** @class */ (function () {
        function OrderDetailItemsComponent(orderDetailsService) {
            this.orderDetailsService = orderDetailsService;
            this.promotionLocation = i1.PromotionLocation.Order;
            this.order$ = this.orderDetailsService.getOrderDetails();
        }
        OrderDetailItemsComponent.prototype.ngOnInit = function () {
            this.others$ = this.getOtherStatus.apply(this, __spreadArray(__spreadArray([], __read(completedValues)), __read(cancelledValues)));
            this.completed$ = this.getExactStatus(completedValues);
            this.cancel$ = this.getExactStatus(cancelledValues);
        };
        OrderDetailItemsComponent.prototype.getExactStatus = function (consignmentStatus) {
            return this.order$.pipe(operators.map(function (order) {
                if (Boolean(order.consignments)) {
                    return order.consignments.filter(function (consignment) { return consignmentStatus.includes(consignment.status); });
                }
            }));
        };
        OrderDetailItemsComponent.prototype.getOtherStatus = function () {
            var consignmentStatus = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                consignmentStatus[_i] = arguments[_i];
            }
            return this.order$.pipe(operators.map(function (order) {
                if (Boolean(order.consignments)) {
                    return order.consignments.filter(function (consignment) { return !consignmentStatus.includes(consignment.status); });
                }
            }));
        };
        return OrderDetailItemsComponent;
    }());
    OrderDetailItemsComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OrderDetailItemsComponent, deps: [{ token: OrderDetailsService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    OrderDetailItemsComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: OrderDetailItemsComponent, selector: "cx-order-details-items", ngImport: i0__namespace, template: "<ng-container *ngIf=\"order$ | async as order\">\n  <ng-container\n    *ngIf=\"\n      order.consignments?.length ||\n      order.unconsignedEntries?.length ||\n      order.replenishmentOrderCode\n    \"\n  >\n    <cx-promotions\n      [promotions]=\"order.appliedOrderPromotions || []\"\n    ></cx-promotions>\n  </ng-container>\n\n  <!-- consigned entries -->\n  <ng-container *ngIf=\"order.consignments?.length\">\n    <cx-order-consigned-entries\n      *ngIf=\"others$ | async as others\"\n      [order]=\"order\"\n      [consignments]=\"others\"\n    ></cx-order-consigned-entries>\n\n    <cx-order-consigned-entries\n      *ngIf=\"completed$ | async as completed\"\n      [order]=\"order\"\n      [consignments]=\"completed\"\n    ></cx-order-consigned-entries>\n\n    <cx-order-consigned-entries\n      *ngIf=\"cancel$ | async as cancel\"\n      [order]=\"order\"\n      [consignments]=\"cancel\"\n    ></cx-order-consigned-entries>\n  </ng-container>\n\n  <!-- unconsigned entries OR any entries -->\n  <ng-container\n    *ngIf=\"\n      order?.unconsignedEntries?.length ||\n      (order?.entries && order?.replenishmentOrderCode)\n    \"\n  >\n    <div class=\"cx-list row\">\n      <div *ngIf=\"order?.statusDisplay\" class=\"cx-list-header col-12\">\n        <div class=\"cx-list-status\">\n          {{\n            'orderDetails.statusDisplay_' + order?.statusDisplay | cxTranslate\n          }}\n        </div>\n      </div>\n      <div class=\"cx-list-item col-12\">\n        <cx-cart-item-list\n          [items]=\"\n            order?.unconsignedEntries ? order.unconsignedEntries : order.entries\n          \"\n          [readonly]=\"true\"\n          [promotionLocation]=\"promotionLocation\"\n        ></cx-cart-item-list>\n      </div>\n    </div>\n  </ng-container>\n</ng-container>\n", components: [{ type: PromotionsComponent, selector: "cx-promotions", inputs: ["promotions"] }, { type: OrderConsignedEntriesComponent, selector: "cx-order-consigned-entries", inputs: ["consignments", "order"] }, { type: CartItemListComponent, selector: "cx-cart-item-list", inputs: ["readonly", "hasHeader", "options", "cartId", "items", "promotionLocation", "cartIsLoading"] }], directives: [{ type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "async": i3__namespace.AsyncPipe, "cxTranslate": i1__namespace.TranslatePipe } });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OrderDetailItemsComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-order-details-items',
                        templateUrl: './order-detail-items.component.html',
                    }]
            }], ctorParameters: function () { return [{ type: OrderDetailsService }]; } });

    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var OrderDetailShippingComponent = /** @class */ (function () {
        function OrderDetailShippingComponent(orderDetailsService) {
            this.orderDetailsService = orderDetailsService;
        }
        OrderDetailShippingComponent.prototype.ngOnInit = function () {
            this.order$ = this.orderDetailsService.getOrderDetails();
        };
        return OrderDetailShippingComponent;
    }());
    OrderDetailShippingComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OrderDetailShippingComponent, deps: [{ token: OrderDetailsService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    OrderDetailShippingComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: OrderDetailShippingComponent, selector: "cx-order-details-shipping", ngImport: i0__namespace, template: "<ng-container *ngIf=\"order$ | async as order\">\n  <cx-order-overview [order]=\"order\"></cx-order-overview>\n</ng-container>\n", components: [{ type: OrderOverviewComponent, selector: "cx-order-overview", inputs: ["order"] }], directives: [{ type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "async": i3__namespace.AsyncPipe } });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OrderDetailShippingComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-order-details-shipping',
                        templateUrl: './order-detail-shipping.component.html',
                    }]
            }], ctorParameters: function () { return [{ type: OrderDetailsService }]; } });

    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var OrderDetailTotalsComponent = /** @class */ (function () {
        function OrderDetailTotalsComponent(orderDetailsService) {
            this.orderDetailsService = orderDetailsService;
        }
        OrderDetailTotalsComponent.prototype.ngOnInit = function () {
            this.order$ = this.orderDetailsService.getOrderDetails();
        };
        return OrderDetailTotalsComponent;
    }());
    OrderDetailTotalsComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OrderDetailTotalsComponent, deps: [{ token: OrderDetailsService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    OrderDetailTotalsComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: OrderDetailTotalsComponent, selector: "cx-order-details-totals", ngImport: i0__namespace, template: "<ng-container *ngIf=\"order$ | async as order\">\n  <div class=\"row justify-content-end\">\n    <div class=\"cx-summary col-sm-12 col-md-6 col-lg-5 col-xl-4\">\n      <cx-order-summary [cart]=\"order\"></cx-order-summary>\n    </div>\n  </div>\n</ng-container>\n", components: [{ type: OrderSummaryComponent, selector: "cx-order-summary", inputs: ["cart"] }], directives: [{ type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "async": i3__namespace.AsyncPipe } });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OrderDetailTotalsComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-order-details-totals',
                        templateUrl: './order-detail-totals.component.html',
                    }]
            }], ctorParameters: function () { return [{ type: OrderDetailsService }]; } });

    var moduleComponents$1 = [
        OrderDetailActionsComponent,
        OrderDetailItemsComponent,
        OrderDetailTotalsComponent,
        OrderDetailShippingComponent,
        TrackingEventsComponent,
        ConsignmentTrackingComponent,
        OrderConsignedEntriesComponent,
    ];
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var OrderDetailsModule = /** @class */ (function () {
        function OrderDetailsModule() {
        }
        return OrderDetailsModule;
    }());
    OrderDetailsModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OrderDetailsModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    OrderDetailsModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OrderDetailsModule, declarations: [OrderDetailActionsComponent,
            OrderDetailItemsComponent,
            OrderDetailTotalsComponent,
            OrderDetailShippingComponent,
            TrackingEventsComponent,
            ConsignmentTrackingComponent,
            OrderConsignedEntriesComponent], imports: [CartSharedModule,
            CardModule,
            i3.CommonModule,
            i1.I18nModule,
            i1.FeaturesConfigModule,
            PromotionsModule,
            OrderOverviewModule,
            i1.UrlModule,
            SpinnerModule, i1__namespace$1.RouterModule], exports: [OrderDetailActionsComponent,
            OrderDetailItemsComponent,
            OrderDetailTotalsComponent,
            OrderDetailShippingComponent,
            TrackingEventsComponent,
            ConsignmentTrackingComponent,
            OrderConsignedEntriesComponent] });
    OrderDetailsModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OrderDetailsModule, providers: [
            i1.provideDefaultConfig({
                cmsComponents: {
                    AccountOrderDetailsActionsComponent: {
                        component: OrderDetailActionsComponent,
                    },
                    AccountOrderDetailsItemsComponent: {
                        component: OrderDetailItemsComponent,
                    },
                    AccountOrderDetailsTotalsComponent: {
                        component: OrderDetailTotalsComponent,
                    },
                    AccountOrderDetailsShippingComponent: {
                        component: OrderDetailShippingComponent,
                    },
                },
                features: {
                    consignmentTracking: '1.2',
                },
            }),
            OrderDetailsService,
        ], imports: [[
                CartSharedModule,
                CardModule,
                i3.CommonModule,
                i1.I18nModule,
                i1.FeaturesConfigModule,
                PromotionsModule,
                OrderOverviewModule,
                i1.UrlModule,
                SpinnerModule,
                i1$1.RouterModule.forChild([
                    {
                        path: null,
                        canActivate: [i1.AuthGuard, CmsPageGuard],
                        component: PageLayoutComponent,
                        data: { pageLabel: 'order', cxRoute: 'orderGuest' },
                    },
                    {
                        path: null,
                        canActivate: [i1.AuthGuard, CmsPageGuard],
                        component: PageLayoutComponent,
                        data: { cxRoute: 'orderDetails' },
                    },
                ]),
            ]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OrderDetailsModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [
                            CartSharedModule,
                            CardModule,
                            i3.CommonModule,
                            i1.I18nModule,
                            i1.FeaturesConfigModule,
                            PromotionsModule,
                            OrderOverviewModule,
                            i1.UrlModule,
                            SpinnerModule,
                            i1$1.RouterModule.forChild([
                                {
                                    path: null,
                                    canActivate: [i1.AuthGuard, CmsPageGuard],
                                    component: PageLayoutComponent,
                                    data: { pageLabel: 'order', cxRoute: 'orderGuest' },
                                },
                                {
                                    path: null,
                                    canActivate: [i1.AuthGuard, CmsPageGuard],
                                    component: PageLayoutComponent,
                                    data: { cxRoute: 'orderDetails' },
                                },
                            ]),
                        ],
                        providers: [
                            i1.provideDefaultConfig({
                                cmsComponents: {
                                    AccountOrderDetailsActionsComponent: {
                                        component: OrderDetailActionsComponent,
                                    },
                                    AccountOrderDetailsItemsComponent: {
                                        component: OrderDetailItemsComponent,
                                    },
                                    AccountOrderDetailsTotalsComponent: {
                                        component: OrderDetailTotalsComponent,
                                    },
                                    AccountOrderDetailsShippingComponent: {
                                        component: OrderDetailShippingComponent,
                                    },
                                },
                                features: {
                                    consignmentTracking: '1.2',
                                },
                            }),
                            OrderDetailsService,
                        ],
                        declarations: __spreadArray([], __read(moduleComponents$1)),
                        exports: __spreadArray([], __read(moduleComponents$1)),
                    }]
            }] });

    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var OrderHistoryComponent = /** @class */ (function () {
        function OrderHistoryComponent(routing, userOrderService, translation, userReplenishmentOrderService) {
            var _this = this;
            this.routing = routing;
            this.userOrderService = userOrderService;
            this.translation = translation;
            this.userReplenishmentOrderService = userReplenishmentOrderService;
            this.PAGE_SIZE = 5;
            this.orders$ = this.userOrderService
                .getOrderHistoryList(this.PAGE_SIZE)
                .pipe(operators.tap(function (orders) {
                if (orders.pagination) {
                    _this.sortType = orders.pagination.sort;
                }
            }));
            this.hasReplenishmentOrder$ = this.userReplenishmentOrderService
                .getReplenishmentOrderDetails()
                .pipe(operators.map(function (order) { return order && Object.keys(order).length !== 0; }));
            this.isLoaded$ = this.userOrderService.getOrderHistoryListLoaded();
            /**
             * When "Order Return" feature is enabled, this component becomes one tab in
             * TabParagraphContainerComponent. This can be read from TabParagraphContainer.
             */
            this.tabTitleParam$ = this.orders$.pipe(operators.map(function (order) { var _a; return (_a = order.pagination) === null || _a === void 0 ? void 0 : _a.totalResults; }), operators.filter(i1.isNotUndefined), operators.take(1));
        }
        OrderHistoryComponent.prototype.ngOnDestroy = function () {
            this.userOrderService.clearOrderList();
        };
        OrderHistoryComponent.prototype.changeSortCode = function (sortCode) {
            var event = {
                sortCode: sortCode,
                currentPage: 0,
            };
            this.sortType = sortCode;
            this.fetchOrders(event);
        };
        OrderHistoryComponent.prototype.pageChange = function (page) {
            var event = {
                sortCode: this.sortType,
                currentPage: page,
            };
            this.fetchOrders(event);
        };
        OrderHistoryComponent.prototype.goToOrderDetail = function (order) {
            this.routing.go({
                cxRoute: 'orderDetails',
                params: order,
            });
        };
        OrderHistoryComponent.prototype.getSortLabels = function () {
            return rxjs.combineLatest([
                this.translation.translate('sorting.date'),
                this.translation.translate('sorting.orderNumber'),
            ]).pipe(operators.map(function (_b) {
                var _c = __read(_b, 2), textByDate = _c[0], textByOrderNumber = _c[1];
                return {
                    byDate: textByDate,
                    byOrderNumber: textByOrderNumber,
                };
            }));
        };
        OrderHistoryComponent.prototype.fetchOrders = function (event) {
            this.userOrderService.loadOrderList(this.PAGE_SIZE, event.currentPage, event.sortCode);
        };
        return OrderHistoryComponent;
    }());
    OrderHistoryComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OrderHistoryComponent, deps: [{ token: i1__namespace.RoutingService }, { token: i1__namespace.UserOrderService }, { token: i1__namespace.TranslationService }, { token: i1__namespace.UserReplenishmentOrderService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    OrderHistoryComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: OrderHistoryComponent, selector: "cx-order-history", ngImport: i0__namespace, template: "<ng-container\n  *ngIf=\"{\n    orderHistory: orders$ | async,\n    replenishmentOrder: hasReplenishmentOrder$ | async\n  } as type\"\n>\n  <ng-container *ngIf=\"type.orderHistory\">\n    <div [ngClass]=\"type.replenishmentOrder ? '' : 'container'\">\n      <!-- HEADER -->\n      <div\n        [ngClass]=\"\n          type.replenishmentOrder\n            ? 'cx-replenishment-details-order-history-header'\n            : 'cx-order-history-header'\n        \"\n      >\n        <h4 *ngIf=\"type.replenishmentOrder\">\n          {{ 'orderHistory.replenishmentHistory' | cxTranslate }}\n        </h4>\n        <h3 *ngIf=\"!type.replenishmentOrder\">\n          {{ 'orderHistory.orderHistory' | cxTranslate }}\n        </h3>\n      </div>\n\n      <!-- BODY -->\n      <div class=\"cx-order-history-body\">\n        <ng-container\n          *ngIf=\"type.orderHistory.pagination.totalResults > 0; else noOrder\"\n        >\n          <!-- Select Form and Pagination Top -->\n          <div class=\"cx-order-history-sort top row\">\n            <label\n              class=\"\n                cx-order-history-form-group\n                form-group\n                col-sm-12 col-md-4 col-lg-4\n              \"\n              ><span>\n                {{ 'orderHistory.sortBy' | cxTranslate }}\n              </span>\n              <cx-sorting\n                [sortOptions]=\"type.orderHistory.sorts\"\n                [sortLabels]=\"getSortLabels() | async\"\n                (sortListEvent)=\"changeSortCode($event)\"\n                [selectedOption]=\"type.orderHistory.pagination.sort\"\n                placeholder=\"{{ 'orderHistory.sortBy' | cxTranslate }}\"\n              ></cx-sorting>\n            </label>\n            <div\n              *ngIf=\"type.orderHistory.pagination.totalPages > 1\"\n              class=\"cx-order-history-pagination\"\n            >\n              <cx-pagination\n                [pagination]=\"type.orderHistory.pagination\"\n                (viewPageEvent)=\"pageChange($event)\"\n              ></cx-pagination>\n            </div>\n          </div>\n          <!-- TABLE -->\n          <table class=\"table cx-order-history-table\">\n            <thead class=\"cx-order-history-thead-mobile\">\n              <th scope=\"col\">\n                {{ 'orderHistory.orderId' | cxTranslate }}\n              </th>\n              <th scope=\"col\">{{ 'orderHistory.date' | cxTranslate }}</th>\n              <th scope=\"col\">\n                {{ 'orderHistory.status' | cxTranslate }}\n              </th>\n              <th scope=\"col\">{{ 'orderHistory.total' | cxTranslate }}</th>\n            </thead>\n            <tbody>\n              <tr\n                *ngFor=\"let order of type.orderHistory.orders\"\n                (click)=\"goToOrderDetail(order)\"\n              >\n                <td class=\"cx-order-history-code\">\n                  <div class=\"d-md-none cx-order-history-label\">\n                    {{ 'orderHistory.orderId' | cxTranslate }}\n                  </div>\n                  <a\n                    [routerLink]=\"\n                      {\n                        cxRoute: 'orderDetails',\n                        params: order\n                      } | cxUrl\n                    \"\n                    class=\"cx-order-history-value\"\n                  >\n                    {{ order?.code }}</a\n                  >\n                </td>\n                <td class=\"cx-order-history-placed\">\n                  <div class=\"d-md-none cx-order-history-label\">\n                    {{ 'orderHistory.date' | cxTranslate }}\n                  </div>\n                  <a\n                    [routerLink]=\"\n                      {\n                        cxRoute: 'orderDetails',\n                        params: order\n                      } | cxUrl\n                    \"\n                    class=\"cx-order-history-value\"\n                    >{{ order?.placed | cxDate: 'longDate' }}</a\n                  >\n                </td>\n                <td class=\"cx-order-history-status\">\n                  <div class=\"d-md-none cx-order-history-label\">\n                    {{ 'orderHistory.status' | cxTranslate }}\n                  </div>\n                  <a\n                    [routerLink]=\"\n                      {\n                        cxRoute: 'orderDetails',\n                        params: order\n                      } | cxUrl\n                    \"\n                    class=\"cx-order-history-value\"\n                  >\n                    {{\n                      'orderDetails.statusDisplay_' + order?.statusDisplay\n                        | cxTranslate\n                    }}</a\n                  >\n                </td>\n                <td class=\"cx-order-history-total\">\n                  <div class=\"d-md-none cx-order-history-label\">\n                    {{ 'orderHistory.total' | cxTranslate }}\n                  </div>\n                  <a\n                    [routerLink]=\"\n                      {\n                        cxRoute: 'orderDetails',\n                        params: order\n                      } | cxUrl\n                    \"\n                    class=\"cx-order-history-value\"\n                  >\n                    {{ order?.total.formattedValue }}</a\n                  >\n                </td>\n              </tr>\n            </tbody>\n          </table>\n          <!-- Select Form and Pagination Bottom -->\n          <div class=\"cx-order-history-sort bottom row\">\n            <div\n              *ngIf=\"type.orderHistory.pagination.totalPages > 1\"\n              class=\"cx-order-history-pagination\"\n            >\n              <cx-pagination\n                [pagination]=\"type.orderHistory.pagination\"\n                (viewPageEvent)=\"pageChange($event)\"\n              ></cx-pagination>\n            </div>\n          </div>\n        </ng-container>\n\n        <!-- NO ORDER CONTAINER -->\n        <ng-template #noOrder>\n          <div\n            *ngIf=\"isLoaded$ | async\"\n            [ngClass]=\"\n              type.replenishmentOrder\n                ? 'cx-replenishment-details-order-history-no-order row'\n                : 'cx-order-history-no-order row'\n            \"\n          >\n            <div\n              [ngClass]=\"\n                type.replenishmentOrder ? '' : 'col-sm-12 col-md-6 col-lg-4'\n              \"\n            >\n              <ng-container *ngIf=\"type.replenishmentOrder; else otherOrder\">\n                <div>{{ 'orderHistory.notFound' | cxTranslate }}</div>\n              </ng-container>\n\n              <ng-template #otherOrder>\n                <div>{{ 'orderHistory.noOrders' | cxTranslate }}</div>\n                <a\n                  [routerLink]=\"{ cxRoute: 'home' } | cxUrl\"\n                  routerLinkActive=\"active\"\n                  class=\"btn btn-primary btn-block\"\n                  >{{ 'orderHistory.startShopping' | cxTranslate }}</a\n                >\n              </ng-template>\n            </div>\n          </div>\n        </ng-template>\n      </div>\n    </div>\n  </ng-container>\n</ng-container>\n", components: [{ type: SortingComponent, selector: "cx-sorting", inputs: ["sortOptions", "selectedOption", "placeholder", "sortLabels"], outputs: ["sortListEvent"] }, { type: PaginationComponent, selector: "cx-pagination", inputs: ["pageRoute", "queryParam", "defaultPage", "pagination"], outputs: ["viewPageEvent"] }], directives: [{ type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3__namespace.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { type: i3__namespace.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i1__namespace$1.RouterLinkWithHref, selector: "a[routerLink],area[routerLink]", inputs: ["routerLink", "target", "queryParams", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange", "replaceUrl", "state", "relativeTo"] }, { type: i1__namespace$1.RouterLinkActive, selector: "[routerLinkActive]", inputs: ["routerLinkActiveOptions", "routerLinkActive"], exportAs: ["routerLinkActive"] }], pipes: { "async": i3__namespace.AsyncPipe, "cxTranslate": i1__namespace.TranslatePipe, "cxUrl": i1__namespace.UrlPipe, "cxDate": i1__namespace.CxDatePipe }, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OrderHistoryComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-order-history',
                        templateUrl: './order-history.component.html',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace.RoutingService }, { type: i1__namespace.UserOrderService }, { type: i1__namespace.TranslationService }, { type: i1__namespace.UserReplenishmentOrderService }]; } });

    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var OrderHistoryModule = /** @class */ (function () {
        function OrderHistoryModule() {
        }
        return OrderHistoryModule;
    }());
    OrderHistoryModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OrderHistoryModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    OrderHistoryModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OrderHistoryModule, declarations: [OrderHistoryComponent], imports: [i3.CommonModule, i1__namespace$1.RouterModule, i1$1.RouterModule,
            i3$1.FormsModule,
            i1$4.NgSelectModule,
            ListNavigationModule,
            i1.UrlModule,
            i1.I18nModule], exports: [OrderHistoryComponent] });
    OrderHistoryModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OrderHistoryModule, providers: [
            i1.provideDefaultConfig({
                cmsComponents: {
                    AccountOrderHistoryComponent: {
                        component: OrderHistoryComponent,
                        guards: [i1.AuthGuard],
                    },
                },
            }),
        ], imports: [[
                i3.CommonModule,
                i1$1.RouterModule.forChild([
                    {
                        path: null,
                        canActivate: [i1.AuthGuard, CmsPageGuard],
                        component: PageLayoutComponent,
                        data: { cxRoute: 'orders' },
                    },
                ]),
                i1$1.RouterModule,
                i3$1.FormsModule,
                i1$4.NgSelectModule,
                ListNavigationModule,
                i1.UrlModule,
                i1.I18nModule,
            ]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OrderHistoryModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [
                            i3.CommonModule,
                            i1$1.RouterModule.forChild([
                                {
                                    path: null,
                                    canActivate: [i1.AuthGuard, CmsPageGuard],
                                    component: PageLayoutComponent,
                                    data: { cxRoute: 'orders' },
                                },
                            ]),
                            i1$1.RouterModule,
                            i3$1.FormsModule,
                            i1$4.NgSelectModule,
                            ListNavigationModule,
                            i1.UrlModule,
                            i1.I18nModule,
                        ],
                        declarations: [OrderHistoryComponent],
                        exports: [OrderHistoryComponent],
                        providers: [
                            i1.provideDefaultConfig({
                                cmsComponents: {
                                    AccountOrderHistoryComponent: {
                                        component: OrderHistoryComponent,
                                        guards: [i1.AuthGuard],
                                    },
                                },
                            }),
                        ],
                    }]
            }] });

    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var defaultReplenishmentOrderCancellationLayoutConfig = {
        launch: {
            REPLENISHMENT_ORDER: {
                inline: true,
                component: ReplenishmentOrderCancellationDialogComponent,
                dialogType: exports.DIALOG_TYPE.DIALOG,
            },
        },
    };

    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var ReplenishmentOrderCancellationComponent = /** @class */ (function () {
        function ReplenishmentOrderCancellationComponent(userReplenishmentOrderService, vcr, launchDialogService) {
            this.userReplenishmentOrderService = userReplenishmentOrderService;
            this.vcr = vcr;
            this.launchDialogService = launchDialogService;
            this.subscription = new rxjs.Subscription();
            this.replenishmentOrder$ = this.userReplenishmentOrderService.getReplenishmentOrderDetails();
        }
        ReplenishmentOrderCancellationComponent.prototype.openDialog = function () {
            var dialog = this.launchDialogService.openDialog("REPLENISHMENT_ORDER" /* REPLENISHMENT_ORDER */, this.element, this.vcr);
            if (dialog) {
                this.subscription.add(dialog.pipe(operators.take(1)).subscribe());
            }
        };
        ReplenishmentOrderCancellationComponent.prototype.ngOnDestroy = function () {
            this.subscription.unsubscribe();
            this.userReplenishmentOrderService.clearReplenishmentOrderDetails();
        };
        return ReplenishmentOrderCancellationComponent;
    }());
    ReplenishmentOrderCancellationComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ReplenishmentOrderCancellationComponent, deps: [{ token: i1__namespace.UserReplenishmentOrderService }, { token: i0__namespace.ViewContainerRef }, { token: LaunchDialogService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    ReplenishmentOrderCancellationComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: ReplenishmentOrderCancellationComponent, selector: "cx-replenishment-order-cancellation", viewQueries: [{ propertyName: "element", first: true, predicate: ["element"], descendants: true }], ngImport: i0__namespace, template: "<div class=\"cx-cancel-replenishment-btns row\">\n  <div class=\"col-xs-12 col-md-5 col-lg-4\">\n    <a\n      class=\"btn btn-block btn-action\"\n      [routerLink]=\"\n        {\n          cxRoute: 'replenishmentOrders'\n        } | cxUrl\n      \"\n    >\n      {{ 'common.back' | cxTranslate }}\n    </a>\n  </div>\n  <div\n    *ngIf=\"(replenishmentOrder$ | async).active\"\n    class=\"col-xs-12 col-md-5 col-lg-4\"\n  >\n    <button #element class=\"btn btn-block btn-action\" (click)=\"openDialog()\">\n      {{ 'orderDetails.cancelReplenishment.title' | cxTranslate }}\n    </button>\n  </div>\n</div>\n", directives: [{ type: i1__namespace$1.RouterLinkWithHref, selector: "a[routerLink],area[routerLink]", inputs: ["routerLink", "target", "queryParams", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange", "replaceUrl", "state", "relativeTo"] }, { type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "cxUrl": i1__namespace.UrlPipe, "cxTranslate": i1__namespace.TranslatePipe, "async": i3__namespace.AsyncPipe } });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ReplenishmentOrderCancellationComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-replenishment-order-cancellation',
                        templateUrl: './replenishment-order-cancellation.component.html',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace.UserReplenishmentOrderService }, { type: i0__namespace.ViewContainerRef }, { type: LaunchDialogService }]; }, propDecorators: { element: [{
                    type: i0.ViewChild,
                    args: ['element']
                }] } });

    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var ReplenishmentOrderDetailsService = /** @class */ (function () {
        function ReplenishmentOrderDetailsService(routingService, userReplenishmentOrderService) {
            var _this = this;
            this.routingService = routingService;
            this.userReplenishmentOrderService = userReplenishmentOrderService;
            this.replenishmentOrderCode$ = this.routingService.getRouterState().pipe(operators.map(function (routingData) { return routingData.state.params.replenishmentOrderCode; }), operators.distinctUntilChanged());
            this.replenishmentOrderLoad$ = this.replenishmentOrderCode$.pipe(operators.tap(function (replenishmentOrderCode) {
                if (Boolean(replenishmentOrderCode)) {
                    _this.userReplenishmentOrderService.loadReplenishmentOrderDetails(replenishmentOrderCode);
                }
                else {
                    _this.userReplenishmentOrderService.clearReplenishmentOrderDetails();
                }
            }), operators.shareReplay({ bufferSize: 1, refCount: true }));
        }
        ReplenishmentOrderDetailsService.prototype.getOrderDetails = function () {
            var _this = this;
            return this.replenishmentOrderLoad$.pipe(operators.switchMap(function (_) { return _this.userReplenishmentOrderService.getReplenishmentOrderDetails(); }));
        };
        return ReplenishmentOrderDetailsService;
    }());
    ReplenishmentOrderDetailsService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ReplenishmentOrderDetailsService, deps: [{ token: i1__namespace.RoutingService }, { token: i1__namespace.UserReplenishmentOrderService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ReplenishmentOrderDetailsService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ReplenishmentOrderDetailsService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ReplenishmentOrderDetailsService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace.RoutingService }, { type: i1__namespace.UserReplenishmentOrderService }]; } });

    var moduleComponents = [ReplenishmentOrderCancellationComponent];
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var ReplenishmentOrderDetailsModule = /** @class */ (function () {
        function ReplenishmentOrderDetailsModule() {
        }
        return ReplenishmentOrderDetailsModule;
    }());
    ReplenishmentOrderDetailsModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ReplenishmentOrderDetailsModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    ReplenishmentOrderDetailsModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ReplenishmentOrderDetailsModule, declarations: [ReplenishmentOrderCancellationComponent], imports: [CartSharedModule,
            CardModule,
            i3.CommonModule,
            i1.I18nModule,
            PromotionsModule,
            i1.UrlModule,
            ReplenishmentOrderCancellationDialogModule,
            SpinnerModule,
            ListNavigationModule, i1__namespace$1.RouterModule], exports: [ReplenishmentOrderCancellationComponent] });
    ReplenishmentOrderDetailsModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ReplenishmentOrderDetailsModule, providers: [
            i1.provideConfig(defaultReplenishmentOrderCancellationLayoutConfig),
            i1.provideDefaultConfig({
                cmsComponents: {
                    ReplenishmentDetailItemsComponent: {
                        component: OrderDetailItemsComponent,
                        providers: [
                            {
                                provide: OrderDetailsService,
                                useExisting: ReplenishmentOrderDetailsService,
                            },
                        ],
                    },
                    ReplenishmentDetailTotalsComponent: {
                        component: OrderDetailTotalsComponent,
                        providers: [
                            {
                                provide: OrderDetailsService,
                                useExisting: ReplenishmentOrderDetailsService,
                            },
                        ],
                    },
                    ReplenishmentDetailShippingComponent: {
                        component: OrderDetailShippingComponent,
                        providers: [
                            {
                                provide: OrderDetailsService,
                                useExisting: ReplenishmentOrderDetailsService,
                            },
                        ],
                    },
                    ReplenishmentDetailActionsComponent: {
                        component: ReplenishmentOrderCancellationComponent,
                    },
                    ReplenishmentDetailOrderHistoryComponent: {
                        component: OrderHistoryComponent,
                    },
                },
            }),
        ], imports: [[
                CartSharedModule,
                CardModule,
                i3.CommonModule,
                i1.I18nModule,
                PromotionsModule,
                i1.UrlModule,
                ReplenishmentOrderCancellationDialogModule,
                SpinnerModule,
                ListNavigationModule,
                i1$1.RouterModule.forChild([
                    {
                        path: null,
                        canActivate: [i1.AuthGuard, CmsPageGuard],
                        component: PageLayoutComponent,
                        data: { cxRoute: 'replenishmentDetails' },
                    },
                ]),
            ]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ReplenishmentOrderDetailsModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [
                            CartSharedModule,
                            CardModule,
                            i3.CommonModule,
                            i1.I18nModule,
                            PromotionsModule,
                            i1.UrlModule,
                            ReplenishmentOrderCancellationDialogModule,
                            SpinnerModule,
                            ListNavigationModule,
                            i1$1.RouterModule.forChild([
                                {
                                    path: null,
                                    canActivate: [i1.AuthGuard, CmsPageGuard],
                                    component: PageLayoutComponent,
                                    data: { cxRoute: 'replenishmentDetails' },
                                },
                            ]),
                        ],
                        providers: [
                            i1.provideConfig(defaultReplenishmentOrderCancellationLayoutConfig),
                            i1.provideDefaultConfig({
                                cmsComponents: {
                                    ReplenishmentDetailItemsComponent: {
                                        component: OrderDetailItemsComponent,
                                        providers: [
                                            {
                                                provide: OrderDetailsService,
                                                useExisting: ReplenishmentOrderDetailsService,
                                            },
                                        ],
                                    },
                                    ReplenishmentDetailTotalsComponent: {
                                        component: OrderDetailTotalsComponent,
                                        providers: [
                                            {
                                                provide: OrderDetailsService,
                                                useExisting: ReplenishmentOrderDetailsService,
                                            },
                                        ],
                                    },
                                    ReplenishmentDetailShippingComponent: {
                                        component: OrderDetailShippingComponent,
                                        providers: [
                                            {
                                                provide: OrderDetailsService,
                                                useExisting: ReplenishmentOrderDetailsService,
                                            },
                                        ],
                                    },
                                    ReplenishmentDetailActionsComponent: {
                                        component: ReplenishmentOrderCancellationComponent,
                                    },
                                    ReplenishmentDetailOrderHistoryComponent: {
                                        component: OrderHistoryComponent,
                                    },
                                },
                            }),
                        ],
                        declarations: __spreadArray([], __read(moduleComponents)),
                        exports: __spreadArray([], __read(moduleComponents)),
                    }]
            }] });

    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var ReplenishmentOrderHistoryComponent = /** @class */ (function () {
        function ReplenishmentOrderHistoryComponent(routing, userReplenishmentOrderService, translation, vcr, launchDialogService) {
            var _this = this;
            this.routing = routing;
            this.userReplenishmentOrderService = userReplenishmentOrderService;
            this.translation = translation;
            this.vcr = vcr;
            this.launchDialogService = launchDialogService;
            this.subscription = new rxjs.Subscription();
            this.PAGE_SIZE = 5;
            this.replenishmentOrders$ = this.userReplenishmentOrderService
                .getReplenishmentOrderHistoryList(this.PAGE_SIZE)
                .pipe(operators.tap(function (replenishmentOrders) {
                if (replenishmentOrders.pagination) {
                    _this.sortType = replenishmentOrders.pagination.sort;
                }
            }));
            this.isLoaded$ = this.userReplenishmentOrderService.getReplenishmentOrderHistoryListSuccess();
        }
        ReplenishmentOrderHistoryComponent.prototype.changeSortCode = function (sortCode) {
            var event = {
                sortCode: sortCode,
                currentPage: 0,
            };
            this.sortType = sortCode;
            this.fetchReplenishmentOrders(event);
        };
        ReplenishmentOrderHistoryComponent.prototype.pageChange = function (page) {
            var event = {
                sortCode: this.sortType,
                currentPage: page,
            };
            this.fetchReplenishmentOrders(event);
        };
        ReplenishmentOrderHistoryComponent.prototype.goToOrderDetail = function (order) {
            this.routing.go({
                cxRoute: 'replenishmentDetails',
                params: order,
            });
        };
        ReplenishmentOrderHistoryComponent.prototype.getSortLabels = function () {
            return rxjs.combineLatest([
                this.translation.translate('sorting.date'),
                this.translation.translate('sorting.replenishmentNumber'),
                this.translation.translate('sorting.nextOrderDate'),
            ]).pipe(operators.map(function (_a) {
                var _b = __read(_a, 3), textByDate = _b[0], textByOrderNumber = _b[1], textbyNextOrderDate = _b[2];
                return {
                    byDate: textByDate,
                    byReplenishmentNumber: textByOrderNumber,
                    byNextOrderDate: textbyNextOrderDate,
                };
            }));
        };
        ReplenishmentOrderHistoryComponent.prototype.openDialog = function (event, replenishmentOrderCode) {
            var dialog = this.launchDialogService.openDialog("REPLENISHMENT_ORDER" /* REPLENISHMENT_ORDER */, this.element, this.vcr, replenishmentOrderCode);
            if (dialog) {
                this.subscription.add(dialog.pipe(operators.take(1)).subscribe());
            }
            event.stopPropagation();
        };
        ReplenishmentOrderHistoryComponent.prototype.fetchReplenishmentOrders = function (event) {
            this.userReplenishmentOrderService.loadReplenishmentOrderList(this.PAGE_SIZE, event.currentPage, event.sortCode);
        };
        ReplenishmentOrderHistoryComponent.prototype.ngOnDestroy = function () {
            this.subscription.unsubscribe();
            this.userReplenishmentOrderService.clearReplenishmentOrderList();
        };
        return ReplenishmentOrderHistoryComponent;
    }());
    ReplenishmentOrderHistoryComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ReplenishmentOrderHistoryComponent, deps: [{ token: i1__namespace.RoutingService }, { token: i1__namespace.UserReplenishmentOrderService }, { token: i1__namespace.TranslationService }, { token: i0__namespace.ViewContainerRef }, { token: LaunchDialogService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    ReplenishmentOrderHistoryComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: ReplenishmentOrderHistoryComponent, selector: "cx-replenishment-order-history", viewQueries: [{ propertyName: "element", first: true, predicate: ["element"], descendants: true }], ngImport: i0__namespace, template: "<ng-container *ngIf=\"replenishmentOrders$ | async as replenishmentOrders\">\n  <div class=\"container\">\n    <!-- HEADER -->\n    <div class=\"cx-replenishment-order-history-header\">\n      <h3>\n        {{ 'orderHistory.replenishmentOrderHistory' | cxTranslate }}\n      </h3>\n    </div>\n\n    <!-- BODY -->\n    <div class=\"cx-replenishment-order-history-body\">\n      <ng-container\n        *ngIf=\"replenishmentOrders.pagination.totalResults > 0; else noOrder\"\n      >\n        <!-- Select Form and Pagination Top -->\n        <div class=\"cx-replenishment-order-history-sort top row\">\n          <label\n            class=\"\n              cx-replenishment-order-history-form-group\n              form-group\n              col-sm-12 col-md-4 col-lg-4\n            \"\n          >\n            <span>{{ 'orderHistory.sortBy' | cxTranslate }}</span>\n            <cx-sorting\n              [sortOptions]=\"replenishmentOrders.sorts\"\n              [sortLabels]=\"getSortLabels() | async\"\n              (sortListEvent)=\"changeSortCode($event)\"\n              [selectedOption]=\"replenishmentOrders.pagination.sort\"\n              placeholder=\"{{ 'orderHistory.sortBy' | cxTranslate }}\"\n            ></cx-sorting>\n          </label>\n          <div\n            class=\"cx-replenishment-order-history-pagination\"\n            *ngIf=\"replenishmentOrders.pagination.totalPages > 1\"\n          >\n            <cx-pagination\n              [pagination]=\"replenishmentOrders.pagination\"\n              (viewPageEvent)=\"pageChange($event)\"\n            ></cx-pagination>\n          </div>\n        </div>\n        <!-- TABLE -->\n        <table class=\"table cx-replenishment-order-history-table\">\n          <thead class=\"cx-replenishment-order-history-thead-mobile\">\n            <th scope=\"col\">\n              <span class=\"cx-replenishment-order-history-ellipses\">\n                {{ 'orderHistory.replenishmentOrderId' | cxTranslate }}\n              </span>\n            </th>\n            <th scope=\"col\">\n              <span class=\"cx-replenishment-order-history-ellipses\">\n                {{ 'orderHistory.purchaseOrderNumber' | cxTranslate }}\n              </span>\n            </th>\n            <th scope=\"col\">\n              <span class=\"cx-replenishment-order-history-ellipses\">\n                {{ 'orderHistory.startOn' | cxTranslate }}\n              </span>\n            </th>\n            <th scope=\"col\">\n              <span class=\"cx-replenishment-order-history-ellipses\">\n                {{ 'orderHistory.frequency' | cxTranslate }}\n              </span>\n            </th>\n            <th scope=\"col\">\n              <span class=\"cx-replenishment-order-history-ellipses\">\n                {{ 'orderHistory.nextOrderDate' | cxTranslate }}\n              </span>\n            </th>\n            <th scope=\"col\" class=\"cx-replenishment-order-history-total\">\n              <span class=\"cx-replenishment-order-history-ellipses\">\n                {{ 'orderHistory.total' | cxTranslate }}\n              </span>\n            </th>\n            <th scope=\"col\"></th>\n          </thead>\n          <tbody>\n            <tr\n              *ngFor=\"let order of replenishmentOrders.replenishmentOrders\"\n              (click)=\"goToOrderDetail(order)\"\n            >\n              <td class=\"cx-replenishment-order-history-code\">\n                <div class=\"d-md-none cx-replenishment-order-history-label\">\n                  {{ 'orderHistory.replenishmentOrderId' | cxTranslate }}\n                </div>\n                <a\n                  [routerLink]=\"\n                    {\n                      cxRoute: 'replenishmentDetails',\n                      params: order\n                    } | cxUrl\n                  \"\n                  class=\"cx-replenishment-order-history-value\"\n                >\n                  {{ order?.replenishmentOrderCode }}</a\n                >\n              </td>\n              <td>\n                <div class=\"d-md-none cx-replenishment-order-history-label\">\n                  {{ 'orderHistory.purchaseOrderNumber' | cxTranslate }}\n                </div>\n                <a\n                  [routerLink]=\"\n                    {\n                      cxRoute: 'replenishmentDetails',\n                      params: order\n                    } | cxUrl\n                  \"\n                  class=\"\n                    cx-replenishment-order-history-value\n                    cx-purchase-order-number\n                  \"\n                >\n                  {{\n                    order?.purchaseOrderNumber?.length > 0\n                      ? order?.purchaseOrderNumber\n                      : ('orderHistory.emptyPurchaseOrderId' | cxTranslate)\n                  }}\n                </a>\n              </td>\n              <td>\n                <div class=\"d-md-none cx-replenishment-order-history-label\">\n                  {{ 'orderHistory.startOn' | cxTranslate }}\n                </div>\n                <a\n                  [routerLink]=\"\n                    {\n                      cxRoute: 'replenishmentDetails',\n                      params: order\n                    } | cxUrl\n                  \"\n                  class=\"cx-replenishment-order-history-value\"\n                >\n                  {{ order?.firstDate | cxDate: 'M/d/yyyy' }}</a\n                >\n              </td>\n              <td class=\"cx-replenishment-order-history-frequency\">\n                <div class=\"d-md-none cx-replenishment-order-history-label\">\n                  {{ 'orderHistory.frequency' | cxTranslate }}\n                </div>\n                <a\n                  [routerLink]=\"\n                    {\n                      cxRoute: 'replenishmentDetails',\n                      params: order\n                    } | cxUrl\n                  \"\n                  class=\"cx-replenishment-order-history-value\"\n                >\n                  {{ order?.trigger.displayTimeTable | slice: 0:-12 }}\n                </a>\n              </td>\n              <td>\n                <div class=\"d-md-none cx-replenishment-order-history-label\">\n                  {{ 'orderHistory.nextOrderDate' | cxTranslate }}\n                </div>\n\n                <a\n                  [routerLink]=\"\n                    {\n                      cxRoute: 'replenishmentDetails',\n                      params: order\n                    } | cxUrl\n                  \"\n                  class=\"\n                    cx-replenishment-order-history-value cx-next-order-date\n                  \"\n                >\n                  {{\n                    order?.active\n                      ? (order?.trigger.activationTime | cxDate: 'M/d/yyyy')\n                      : ('orderHistory.cancelled' | cxTranslate)\n                  }}\n                </a>\n              </td>\n              <td class=\"cx-replenishment-order-history-total\">\n                <div class=\"d-md-none cx-replenishment-order-history-label\">\n                  {{ 'orderHistory.total' | cxTranslate }}\n                </div>\n                <a\n                  [routerLink]=\"\n                    {\n                      cxRoute: 'replenishmentDetails',\n                      params: order\n                    } | cxUrl\n                  \"\n                  class=\"cx-replenishment-order-history-value\"\n                >\n                  {{ order?.totalPriceWithTax.formattedValue }}</a\n                >\n              </td>\n              <td class=\"cx-replenishment-order-history-cancel\">\n                <div\n                  class=\"d-md-none cx-replenishment-order-history-label\"\n                ></div>\n                <button\n                  (click)=\"openDialog($event, order?.replenishmentOrderCode)\"\n                  class=\"cx-order-cancel btn btn-link\"\n                  #element\n                  *ngIf=\"order?.active\"\n                >\n                  {{ 'orderHistory.cancel' | cxTranslate }}\n                </button>\n              </td>\n            </tr>\n          </tbody>\n        </table>\n        <!-- Select Form and Pagination Bottom -->\n        <div class=\"cx-replenishment-order-history-sort bottom row\">\n          <div class=\"cx-replenishment-order-history-pagination\">\n            <cx-pagination\n              [pagination]=\"replenishmentOrders.pagination\"\n              (viewPageEvent)=\"pageChange($event)\"\n              *ngIf=\"replenishmentOrders.pagination.totalPages > 1\"\n            ></cx-pagination>\n          </div>\n        </div>\n      </ng-container>\n\n      <!-- NO ORDER CONTAINER -->\n      <ng-template #noOrder>\n        <div\n          class=\"cx-replenishment-order-history-no-order row\"\n          *ngIf=\"isLoaded$ | async\"\n        >\n          <div class=\"col-sm-12 col-md-6 col-lg-4\">\n            <div>{{ 'orderHistory.noReplenishmentOrders' | cxTranslate }}</div>\n            <a\n              [routerLink]=\"{ cxRoute: 'home' } | cxUrl\"\n              routerLinkActive=\"active\"\n              class=\"btn btn-primary btn-block\"\n              >{{ 'orderHistory.startShopping' | cxTranslate }}</a\n            >\n          </div>\n        </div>\n      </ng-template>\n    </div>\n  </div>\n</ng-container>\n", components: [{ type: SortingComponent, selector: "cx-sorting", inputs: ["sortOptions", "selectedOption", "placeholder", "sortLabels"], outputs: ["sortListEvent"] }, { type: PaginationComponent, selector: "cx-pagination", inputs: ["pageRoute", "queryParam", "defaultPage", "pagination"], outputs: ["viewPageEvent"] }], directives: [{ type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3__namespace.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i1__namespace$1.RouterLinkWithHref, selector: "a[routerLink],area[routerLink]", inputs: ["routerLink", "target", "queryParams", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange", "replaceUrl", "state", "relativeTo"] }, { type: i1__namespace$1.RouterLinkActive, selector: "[routerLinkActive]", inputs: ["routerLinkActiveOptions", "routerLinkActive"], exportAs: ["routerLinkActive"] }], pipes: { "async": i3__namespace.AsyncPipe, "cxTranslate": i1__namespace.TranslatePipe, "cxUrl": i1__namespace.UrlPipe, "cxDate": i1__namespace.CxDatePipe, "slice": i3__namespace.SlicePipe }, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ReplenishmentOrderHistoryComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-replenishment-order-history',
                        templateUrl: './replenishment-order-history.component.html',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace.RoutingService }, { type: i1__namespace.UserReplenishmentOrderService }, { type: i1__namespace.TranslationService }, { type: i0__namespace.ViewContainerRef }, { type: LaunchDialogService }]; }, propDecorators: { element: [{
                    type: i0.ViewChild,
                    args: ['element']
                }] } });

    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var ReplenishmentOrderHistoryModule = /** @class */ (function () {
        function ReplenishmentOrderHistoryModule() {
        }
        return ReplenishmentOrderHistoryModule;
    }());
    ReplenishmentOrderHistoryModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ReplenishmentOrderHistoryModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    ReplenishmentOrderHistoryModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ReplenishmentOrderHistoryModule, declarations: [ReplenishmentOrderHistoryComponent], imports: [i3.CommonModule, i1__namespace$1.RouterModule, i1$1.RouterModule,
            ListNavigationModule,
            i1.UrlModule,
            i1.I18nModule], exports: [ReplenishmentOrderHistoryComponent] });
    ReplenishmentOrderHistoryModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ReplenishmentOrderHistoryModule, providers: [
            i1.provideConfig(defaultReplenishmentOrderCancellationLayoutConfig),
            i1.provideDefaultConfig({
                cmsComponents: {
                    AccountReplenishmentHistoryComponent: {
                        component: ReplenishmentOrderHistoryComponent,
                        guards: [i1.AuthGuard],
                    },
                },
            }),
        ], imports: [[
                i3.CommonModule,
                i1$1.RouterModule.forChild([
                    {
                        path: null,
                        canActivate: [i1.AuthGuard, CmsPageGuard],
                        component: PageLayoutComponent,
                        data: { cxRoute: 'replenishmentOrders' },
                    },
                ]),
                i1$1.RouterModule,
                ListNavigationModule,
                i1.UrlModule,
                i1.I18nModule,
            ]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ReplenishmentOrderHistoryModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [
                            i3.CommonModule,
                            i1$1.RouterModule.forChild([
                                {
                                    path: null,
                                    canActivate: [i1.AuthGuard, CmsPageGuard],
                                    component: PageLayoutComponent,
                                    data: { cxRoute: 'replenishmentOrders' },
                                },
                            ]),
                            i1$1.RouterModule,
                            ListNavigationModule,
                            i1.UrlModule,
                            i1.I18nModule,
                        ],
                        providers: [
                            i1.provideConfig(defaultReplenishmentOrderCancellationLayoutConfig),
                            i1.provideDefaultConfig({
                                cmsComponents: {
                                    AccountReplenishmentHistoryComponent: {
                                        component: ReplenishmentOrderHistoryComponent,
                                        guards: [i1.AuthGuard],
                                    },
                                },
                            }),
                        ],
                        declarations: [ReplenishmentOrderHistoryComponent],
                        exports: [ReplenishmentOrderHistoryComponent],
                    }]
            }] });

    var ReturnRequestService = /** @class */ (function () {
        function ReturnRequestService(routingService, returnRequestService, globalMessageService) {
            this.routingService = routingService;
            this.returnRequestService = returnRequestService;
            this.globalMessageService = globalMessageService;
        }
        Object.defineProperty(ReturnRequestService.prototype, "isCancelling$", {
            get: function () {
                return this.returnRequestService.getCancelReturnRequestLoading();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ReturnRequestService.prototype, "isCancelSuccess$", {
            get: function () {
                return this.returnRequestService.getCancelReturnRequestSuccess();
            },
            enumerable: false,
            configurable: true
        });
        ReturnRequestService.prototype.getReturnRequest = function () {
            var _this = this;
            return rxjs.combineLatest([
                this.routingService.getRouterState(),
                this.returnRequestService.getOrderReturnRequest(),
                this.returnRequestService.getReturnRequestLoading(),
            ]).pipe(operators.map(function (_a) {
                var _b = __read(_a, 3), routingState = _b[0], returnRequest = _b[1], isLoading = _b[2];
                return [
                    routingState.state.params['returnCode'],
                    returnRequest,
                    isLoading,
                ];
            }), operators.filter(function (_a) {
                var _b = __read(_a, 1), returnCode = _b[0];
                return Boolean(returnCode);
            }), operators.tap(function (_a) {
                var _b = __read(_a, 3), returnCode = _b[0], returnRequest = _b[1], isLoading = _b[2];
                if ((returnRequest === undefined || returnRequest.rma !== returnCode) &&
                    !isLoading) {
                    _this.returnRequestService.loadOrderReturnRequestDetail(returnCode);
                }
            }), operators.map(function (_a) {
                var _b = __read(_a, 2), _ = _b[0], returnRequest = _b[1];
                return returnRequest;
            }), operators.filter(Boolean), operators.distinctUntilChanged());
        };
        ReturnRequestService.prototype.clearReturnRequest = function () {
            this.returnRequestService.clearOrderReturnRequestDetail();
        };
        ReturnRequestService.prototype.cancelReturnRequest = function (returnRequestCode) {
            this.returnRequestService.cancelOrderReturnRequest(returnRequestCode, {
                status: 'CANCELLING',
            });
        };
        ReturnRequestService.prototype.cancelSuccess = function (rma) {
            this.returnRequestService.resetCancelReturnRequestProcessState();
            this.globalMessageService.add({
                key: 'returnRequest.cancelSuccess',
                params: { rma: rma },
            }, i1.GlobalMessageType.MSG_TYPE_CONFIRMATION);
            this.routingService.go({
                cxRoute: 'orders',
            });
        };
        ReturnRequestService.prototype.backToList = function () {
            this.routingService.go({ cxRoute: 'orders' }, {
                state: {
                    activeTab: 1,
                },
            });
        };
        return ReturnRequestService;
    }());
    ReturnRequestService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ReturnRequestService, deps: [{ token: i1__namespace.RoutingService }, { token: i1__namespace.OrderReturnRequestService }, { token: i1__namespace.GlobalMessageService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ReturnRequestService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ReturnRequestService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ReturnRequestService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace.RoutingService }, { type: i1__namespace.OrderReturnRequestService }, { type: i1__namespace.GlobalMessageService }]; } });

    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var ReturnRequestItemsComponent = /** @class */ (function () {
        function ReturnRequestItemsComponent(returnRequestService) {
            this.returnRequestService = returnRequestService;
            this.returnRequest$ = this.returnRequestService.getReturnRequest();
        }
        return ReturnRequestItemsComponent;
    }());
    ReturnRequestItemsComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ReturnRequestItemsComponent, deps: [{ token: ReturnRequestService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    ReturnRequestItemsComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: ReturnRequestItemsComponent, selector: "cx-return-request-items", ngImport: i0__namespace, template: "<ng-container *ngIf=\"returnRequest$ | async as returnRequest\">\n  <div class=\"d-none d-md-block d-lg-block d-xl-block\">\n    <div class=\"cx-item-list-header row\">\n      <div class=\"cx-item-list-desc col-md-5 col-lg-5 col-xl-6\">\n        {{ 'returnRequest.item' | cxTranslate }}\n      </div>\n      <div class=\"cx-item-list-price col-md-2 col-lg-2 col-xl-2\">\n        {{ 'returnRequest.itemPrice' | cxTranslate }}\n      </div>\n      <div class=\"cx-item-list-qty col-md-3 col-lg-3 col-xl-2\">\n        {{ 'returnRequest.returnQty' | cxTranslate }}\n      </div>\n      <div class=\"cx-item-list-total col-md-2 col-lg-2 col-xl-2\">\n        {{ 'returnRequest.total' | cxTranslate }}\n      </div>\n    </div>\n  </div>\n\n  <div\n    class=\"cx-item-list-row\"\n    *ngFor=\"let returnEntry of returnRequest.returnEntries; let i = index\"\n  >\n    <div class=\"cx-item-list-items\">\n      <div class=\"row\">\n        <!-- Item Image -->\n        <div class=\"col-2 cx-image-container\">\n          <cx-media\n            [container]=\"returnEntry.orderEntry?.product.images?.PRIMARY\"\n            format=\"thumbnail\"\n          ></cx-media>\n        </div>\n        <!-- Item Information -->\n        <div class=\"cx-info col-10\">\n          <div class=\"cx-info-container row\">\n            <!-- Item Description -->\n            <div class=\"col-md-3 col-lg-4 col-xl-5\">\n              <div *ngIf=\"returnEntry.orderEntry?.product.name\" class=\"cx-name\">\n                {{ returnEntry.orderEntry?.product.name }}\n              </div>\n              <div *ngIf=\"returnEntry.orderEntry?.product.code\" class=\"cx-code\">\n                {{ 'cartItems.id' | cxTranslate }}\n                {{ returnEntry.orderEntry?.product.code }}\n              </div>\n              <!-- Variants -->\n              <div\n                *ngFor=\"\n                  let variant of (returnEntry.orderEntry?.product\n                    .baseOptions)[0]?.selected?.variantOptionQualifiers\n                \"\n                class=\"cx-property\"\n              >\n                <div class=\"cx-label\" *ngIf=\"variant.name\">\n                  {{ variant.name }}:\n                </div>\n                <div class=\"cx-value\" *ngIf=\"variant.value\">\n                  {{ variant.value }}\n                </div>\n              </div>\n            </div>\n            <!-- Item Price -->\n            <div\n              *ngIf=\"returnEntry.orderEntry?.basePrice\"\n              class=\"cx-price col-md-3 col-lg-2 col-xl-2\"\n            >\n              <div class=\"cx-label d-block d-md-none d-lg-none d-xl-none\">\n                {{ 'returnRequest.itemPrice' | cxTranslate }}\n              </div>\n              <div class=\"cx-value\">\n                {{ returnEntry.orderEntry?.basePrice?.formattedValue }}\n              </div>\n            </div>\n            <!-- return Quantity -->\n            <div class=\"cx-quantity col-md-3 col-lg-3 col-xl-3\">\n              <div class=\"cx-label d-block d-md-none d-lg-none d-xl-none\">\n                {{ 'returnRequest.returnQty' | cxTranslate }}\n              </div>\n              <div class=\"cx-value\">\n                {{ returnEntry.expectedQuantity }}\n              </div>\n            </div>\n            <!-- Total Price -->\n            <div class=\"cx-total col-md-3 col-lg-3 col-xl-2\">\n              <div class=\"cx-label d-block d-md-none d-lg-none d-xl-none\">\n                {{ 'returnRequest.total' | cxTranslate }}\n              </div>\n              <div class=\"cx-value\">\n                {{ returnEntry.refundAmount?.formattedValue }}\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n</ng-container>\n", components: [{ type: MediaComponent, selector: "cx-media", inputs: ["container", "format", "alt", "role", "loading"], outputs: ["loaded"] }], directives: [{ type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3__namespace.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], pipes: { "async": i3__namespace.AsyncPipe, "cxTranslate": i1__namespace.TranslatePipe }, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ReturnRequestItemsComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-return-request-items',
                        templateUrl: './return-request-items.component.html',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], ctorParameters: function () { return [{ type: ReturnRequestService }]; } });

    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var ReturnRequestOverviewComponent = /** @class */ (function () {
        function ReturnRequestOverviewComponent(returnRequestService) {
            var _this = this;
            this.returnRequestService = returnRequestService;
            this.returnRequest$ = this.returnRequestService
                .getReturnRequest()
                .pipe(operators.tap(function (returnRequest) { return (_this.rma = returnRequest.rma); }));
            this.isCancelling$ = this.returnRequestService.isCancelling$;
        }
        ReturnRequestOverviewComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.subscription = this.returnRequestService.isCancelSuccess$.subscribe(function (success) {
                if (success) {
                    _this.returnRequestService.cancelSuccess(_this.rma);
                }
            });
        };
        ReturnRequestOverviewComponent.prototype.cancelReturn = function (returnRequestCode) {
            this.returnRequestService.cancelReturnRequest(returnRequestCode);
        };
        ReturnRequestOverviewComponent.prototype.back = function () {
            this.returnRequestService.backToList();
        };
        ReturnRequestOverviewComponent.prototype.ngOnDestroy = function () {
            if (this.subscription) {
                this.subscription.unsubscribe();
            }
        };
        return ReturnRequestOverviewComponent;
    }());
    ReturnRequestOverviewComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ReturnRequestOverviewComponent, deps: [{ token: ReturnRequestService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    ReturnRequestOverviewComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: ReturnRequestOverviewComponent, selector: "cx-return-request-overview", ngImport: i0__namespace, template: "<ng-container *ngIf=\"returnRequest$ | async as returnRequest\">\n  <div class=\"cx-nav row\">\n    <div class=\"col-xs-12 col-md-4 col-lg-3\">\n      <button (click)=\"back()\" class=\"btn btn-block btn-action\">\n        {{ 'common.back' | cxTranslate }}\n      </button>\n    </div>\n\n    <div class=\"col-xs-12 col-md-4 col-lg-3\">\n      <button\n        *ngIf=\"returnRequest.cancellable\"\n        class=\"btn btn-block btn-primary\"\n        (click)=\"cancelReturn(returnRequest.rma)\"\n        [disabled]=\"isCancelling$ | async\"\n      >\n        {{ 'returnRequest.cancel' | cxTranslate }}\n      </button>\n    </div>\n  </div>\n  <div class=\"cx-header row\">\n    <div class=\"cx-detail col-sm-12 col-md-4\">\n      <div class=\"cx-detail-label\">\n        {{ 'returnRequest.returnRequestId' | cxTranslate }}\n      </div>\n      <div class=\"cx-detail-value\">{{ returnRequest.rma }}</div>\n    </div>\n    <div class=\"cx-detail col-sm-12 col-md-4\">\n      <div class=\"cx-detail-label\">\n        {{ 'returnRequest.orderCode' | cxTranslate }}\n      </div>\n      <div class=\"cx-detail-value\">{{ returnRequest.order?.code }}</div>\n    </div>\n    <div class=\"cx-detail col-sm-12 col-md-4\">\n      <div class=\"cx-detail-label\">\n        {{ 'returnRequest.status' | cxTranslate }}\n      </div>\n      <div class=\"cx-detail-value\">\n        {{\n          'returnRequestList.statusDisplay_' + returnRequest?.status\n            | cxTranslate\n        }}\n      </div>\n    </div>\n  </div>\n</ng-container>\n", directives: [{ type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "async": i3__namespace.AsyncPipe, "cxTranslate": i1__namespace.TranslatePipe }, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ReturnRequestOverviewComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-return-request-overview',
                        templateUrl: './return-request-overview.component.html',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], ctorParameters: function () { return [{ type: ReturnRequestService }]; } });

    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var ReturnRequestTotalsComponent = /** @class */ (function () {
        function ReturnRequestTotalsComponent(returnRequestService) {
            this.returnRequestService = returnRequestService;
            this.returnRequest$ = this.returnRequestService.getReturnRequest();
        }
        ReturnRequestTotalsComponent.prototype.ngOnDestroy = function () {
            this.returnRequestService.clearReturnRequest();
        };
        return ReturnRequestTotalsComponent;
    }());
    ReturnRequestTotalsComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ReturnRequestTotalsComponent, deps: [{ token: ReturnRequestService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    ReturnRequestTotalsComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: ReturnRequestTotalsComponent, selector: "cx-return-request-totals", ngImport: i0__namespace, template: "<ng-container *ngIf=\"returnRequest$ | async as returnRequest\">\n  <div class=\"row justify-content-end\">\n    <div class=\"cx-summary col-sm-12 col-md-6 col-lg-5 col-xl-4\">\n      <h4>{{ 'returnRequest.summary' | cxTranslate }}</h4>\n      <div class=\"cx-summary-row\">\n        <div class=\"col-6 cx-summary-label\">\n          {{ 'returnRequest.subtotal' | cxTranslate }}\n        </div>\n        <div class=\"col-6 cx-summary-amount\">\n          {{ returnRequest.subTotal?.formattedValue }}\n        </div>\n      </div>\n      <div class=\"cx-summary-row\">\n        <div class=\"col-6 cx-summary-label\">\n          {{ 'returnRequest.deliveryCode' | cxTranslate }}\n        </div>\n        <div class=\"col-6 cx-summary-amount\">\n          {{ returnRequest.deliveryCost?.formattedValue }}\n        </div>\n      </div>\n      <div class=\"cx-summary-row cx-summary-total\">\n        <div class=\"col-6 cx-summary-label\">\n          {{ 'returnRequest.estimatedRefund' | cxTranslate }}\n        </div>\n        <div class=\"col-6 cx-summary-amount\">\n          {{ returnRequest.totalPrice?.formattedValue }}\n        </div>\n      </div>\n      <div class=\"cx-summary-row cx-footnote\">\n        {{ 'returnRequest.note' | cxTranslate }}\n      </div>\n    </div>\n  </div>\n</ng-container>\n", directives: [{ type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "async": i3__namespace.AsyncPipe, "cxTranslate": i1__namespace.TranslatePipe }, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ReturnRequestTotalsComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-return-request-totals',
                        templateUrl: './return-request-totals.component.html',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], ctorParameters: function () { return [{ type: ReturnRequestService }]; } });

    var components = [
        ReturnRequestOverviewComponent,
        ReturnRequestItemsComponent,
        ReturnRequestTotalsComponent,
    ];
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var ReturnRequestDetailModule = /** @class */ (function () {
        function ReturnRequestDetailModule() {
        }
        return ReturnRequestDetailModule;
    }());
    ReturnRequestDetailModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ReturnRequestDetailModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    ReturnRequestDetailModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ReturnRequestDetailModule, declarations: [ReturnRequestOverviewComponent,
            ReturnRequestItemsComponent,
            ReturnRequestTotalsComponent], imports: [i3.CommonModule, i1__namespace$1.RouterModule, i1$1.RouterModule,
            i1.UrlModule,
            i1.I18nModule,
            MediaModule,
            i1.FeaturesConfigModule], exports: [ReturnRequestOverviewComponent,
            ReturnRequestItemsComponent,
            ReturnRequestTotalsComponent] });
    ReturnRequestDetailModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ReturnRequestDetailModule, providers: [
            i1.provideDefaultConfig({
                cmsComponents: {
                    ReturnRequestOverviewComponent: {
                        component: ReturnRequestOverviewComponent,
                    },
                    ReturnRequestItemsComponent: {
                        component: ReturnRequestItemsComponent,
                    },
                    ReturnRequestTotalsComponent: {
                        component: ReturnRequestTotalsComponent,
                    },
                },
            }),
        ], imports: [[
                i3.CommonModule,
                i1$1.RouterModule.forChild([
                    {
                        path: null,
                        canActivate: [i1.AuthGuard, CmsPageGuard],
                        component: PageLayoutComponent,
                        data: { cxRoute: 'returnRequestDetails' },
                    },
                ]),
                i1$1.RouterModule,
                i1.UrlModule,
                i1.I18nModule,
                MediaModule,
                i1.FeaturesConfigModule,
            ]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ReturnRequestDetailModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [
                            i3.CommonModule,
                            i1$1.RouterModule.forChild([
                                {
                                    path: null,
                                    canActivate: [i1.AuthGuard, CmsPageGuard],
                                    component: PageLayoutComponent,
                                    data: { cxRoute: 'returnRequestDetails' },
                                },
                            ]),
                            i1$1.RouterModule,
                            i1.UrlModule,
                            i1.I18nModule,
                            MediaModule,
                            i1.FeaturesConfigModule,
                        ],
                        providers: [
                            i1.provideDefaultConfig({
                                cmsComponents: {
                                    ReturnRequestOverviewComponent: {
                                        component: ReturnRequestOverviewComponent,
                                    },
                                    ReturnRequestItemsComponent: {
                                        component: ReturnRequestItemsComponent,
                                    },
                                    ReturnRequestTotalsComponent: {
                                        component: ReturnRequestTotalsComponent,
                                    },
                                },
                            }),
                        ],
                        declarations: __spreadArray([], __read(components)),
                        exports: __spreadArray([], __read(components)),
                    }]
            }] });

    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var OrderReturnRequestListComponent = /** @class */ (function () {
        function OrderReturnRequestListComponent(returnRequestService, translation) {
            var _this = this;
            this.returnRequestService = returnRequestService;
            this.translation = translation;
            this.PAGE_SIZE = 5;
            this.returnRequests$ = this.returnRequestService
                .getOrderReturnRequestList(this.PAGE_SIZE)
                .pipe(operators.tap(function (requestList) {
                if (requestList.pagination) {
                    _this.sortType = requestList.pagination.sort;
                }
            }));
            /**
             * When "Order Return" feature is enabled, this component becomes one tab in
             * TabParagraphContainerComponent. This can be read from TabParagraphContainer.
             */
            this.tabTitleParam$ = this.returnRequests$.pipe(operators.map(function (returnRequests) { var _a; return (_a = returnRequests.pagination) === null || _a === void 0 ? void 0 : _a.totalResults; }), operators.filter(i1.isNotUndefined), operators.take(1));
        }
        OrderReturnRequestListComponent.prototype.ngOnDestroy = function () {
            this.returnRequestService.clearOrderReturnRequestList();
        };
        OrderReturnRequestListComponent.prototype.changeSortCode = function (sortCode) {
            var event = {
                sortCode: sortCode,
                currentPage: 0,
            };
            this.sortType = sortCode;
            this.fetchReturnRequests(event);
        };
        OrderReturnRequestListComponent.prototype.pageChange = function (page) {
            var event = {
                sortCode: this.sortType,
                currentPage: page,
            };
            this.fetchReturnRequests(event);
        };
        OrderReturnRequestListComponent.prototype.getSortLabels = function () {
            return rxjs.combineLatest([
                this.translation.translate('sorting.date'),
                this.translation.translate('sorting.rma'),
            ]).pipe(operators.map(function (_b) {
                var _c = __read(_b, 2), textByDate = _c[0], textByRma = _c[1];
                return {
                    byDate: textByDate,
                    byRMA: textByRma,
                };
            }));
        };
        OrderReturnRequestListComponent.prototype.fetchReturnRequests = function (event) {
            this.returnRequestService.loadOrderReturnRequestList(this.PAGE_SIZE, event.currentPage, event.sortCode);
        };
        return OrderReturnRequestListComponent;
    }());
    OrderReturnRequestListComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OrderReturnRequestListComponent, deps: [{ token: i1__namespace.OrderReturnRequestService }, { token: i1__namespace.TranslationService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    OrderReturnRequestListComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: OrderReturnRequestListComponent, selector: "cx-order-return-request-list", ngImport: i0__namespace, template: "<ng-container *ngIf=\"returnRequests$ | async as returnRequests\">\n  <div class=\"container\">\n    <!-- BODY -->\n    <div class=\"cx-order-history-body\">\n      <ng-container *ngIf=\"returnRequests.pagination.totalResults > 0\">\n        <!-- Select Form and Pagination Top -->\n        <div class=\"cx-order-history-sort top row\">\n          <label\n            class=\"\n              cx-order-history-form-group\n              form-group\n              col-sm-12 col-md-4 col-lg-4\n            \"\n            ><span>{{ 'returnRequestList.sortBy' | cxTranslate }}</span>\n            <cx-sorting\n              [sortOptions]=\"returnRequests.sorts\"\n              [sortLabels]=\"getSortLabels() | async\"\n              (sortListEvent)=\"changeSortCode($event)\"\n              [selectedOption]=\"returnRequests.pagination.sort\"\n            ></cx-sorting>\n          </label>\n          <div class=\"cx-order-history-pagination\">\n            <cx-pagination\n              [pagination]=\"returnRequests.pagination\"\n              (viewPageEvent)=\"pageChange($event)\"\n            ></cx-pagination>\n          </div>\n        </div>\n        <!-- TABLE -->\n        <table class=\"table cx-order-history-table\">\n          <thead class=\"cx-order-history-thead-mobile\">\n            <th scope=\"col\">\n              {{ 'returnRequestList.returnRequestId' | cxTranslate }}\n            </th>\n            <th scope=\"col\">{{ 'returnRequestList.orderId' | cxTranslate }}</th>\n            <th scope=\"col\">\n              {{ 'returnRequestList.date' | cxTranslate }}\n            </th>\n            <th scope=\"col\">{{ 'returnRequestList.status' | cxTranslate }}</th>\n          </thead>\n          <tbody>\n            <tr *ngFor=\"let return of returnRequests.returnRequests\">\n              <td class=\"cx-order-history-code\">\n                <div class=\"d-md-none cx-order-history-label\">\n                  {{ 'returnRequestList.returnRequestId' | cxTranslate }}\n                </div>\n                <a\n                  [routerLink]=\"\n                    {\n                      cxRoute: 'returnRequestDetails',\n                      params: return\n                    } | cxUrl\n                  \"\n                  class=\"cx-order-history-value\"\n                >\n                  {{ return?.rma }}</a\n                >\n              </td>\n              <td class=\"cx-order-history-code\">\n                <div class=\"d-md-none cx-order-history-label\">\n                  {{ 'returnRequestList.orderId' | cxTranslate }}\n                </div>\n                <a\n                  [routerLink]=\"\n                    {\n                      cxRoute: 'orderDetails',\n                      params: return?.order\n                    } | cxUrl\n                  \"\n                  class=\"cx-order-history-value\"\n                >\n                  {{ return?.order?.code }}</a\n                >\n              </td>\n\n              <td class=\"cx-order-history-placed\">\n                <div class=\"d-md-none cx-order-history-label\">\n                  {{ 'returnRequestList.date' | cxTranslate }}\n                </div>\n                {{ return?.creationTime | cxDate: 'longDate' }}\n              </td>\n              <td class=\"cx-order-history-status\">\n                <div class=\"d-md-none cx-order-history-label\">\n                  {{ 'returnRequestList.status' | cxTranslate }}\n                </div>\n                {{\n                  'returnRequestList.statusDisplay_' + return?.status\n                    | cxTranslate\n                }}\n              </td>\n            </tr>\n          </tbody>\n        </table>\n        <!-- Select Form and Pagination Bottom -->\n        <div class=\"cx-order-history-sort bottom row\">\n          <label\n            class=\"\n              cx-order-history-form-group\n              form-group\n              col-sm-12 col-md-4 col-lg-4\n            \"\n            ><span>{{ 'returnRequestList.sortBy' | cxTranslate }}</span>\n            <cx-sorting\n              [sortOptions]=\"returnRequests.sorts\"\n              [sortLabels]=\"getSortLabels() | async\"\n              (sortListEvent)=\"changeSortCode($event)\"\n              [selectedOption]=\"returnRequests.pagination.sort\"\n            ></cx-sorting>\n          </label>\n          <div class=\"cx-order-history-pagination\">\n            <cx-pagination\n              [pagination]=\"returnRequests.pagination\"\n              (viewPageEvent)=\"pageChange($event)\"\n            ></cx-pagination>\n          </div>\n        </div>\n      </ng-container>\n    </div>\n  </div>\n</ng-container>\n", components: [{ type: SortingComponent, selector: "cx-sorting", inputs: ["sortOptions", "selectedOption", "placeholder", "sortLabels"], outputs: ["sortListEvent"] }, { type: PaginationComponent, selector: "cx-pagination", inputs: ["pageRoute", "queryParam", "defaultPage", "pagination"], outputs: ["viewPageEvent"] }], directives: [{ type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3__namespace.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i1__namespace$1.RouterLinkWithHref, selector: "a[routerLink],area[routerLink]", inputs: ["routerLink", "target", "queryParams", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange", "replaceUrl", "state", "relativeTo"] }], pipes: { "async": i3__namespace.AsyncPipe, "cxTranslate": i1__namespace.TranslatePipe, "cxUrl": i1__namespace.UrlPipe, "cxDate": i1__namespace.CxDatePipe }, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OrderReturnRequestListComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-order-return-request-list',
                        templateUrl: './order-return-request-list.component.html',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace.OrderReturnRequestService }, { type: i1__namespace.TranslationService }]; } });

    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var ReturnRequestListModule = /** @class */ (function () {
        function ReturnRequestListModule() {
        }
        return ReturnRequestListModule;
    }());
    ReturnRequestListModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ReturnRequestListModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    ReturnRequestListModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ReturnRequestListModule, declarations: [OrderReturnRequestListComponent], imports: [i3.CommonModule,
            i1$1.RouterModule,
            ListNavigationModule,
            i1.UrlModule,
            i1.I18nModule], exports: [OrderReturnRequestListComponent] });
    ReturnRequestListModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ReturnRequestListModule, providers: [
            i1.provideDefaultConfig({
                cmsComponents: {
                    OrderReturnRequestListComponent: {
                        component: OrderReturnRequestListComponent,
                        guards: [i1.AuthGuard],
                    },
                },
            }),
        ], imports: [[
                i3.CommonModule,
                i1$1.RouterModule,
                ListNavigationModule,
                i1.UrlModule,
                i1.I18nModule,
            ]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ReturnRequestListModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [
                            i3.CommonModule,
                            i1$1.RouterModule,
                            ListNavigationModule,
                            i1.UrlModule,
                            i1.I18nModule,
                        ],
                        providers: [
                            i1.provideDefaultConfig({
                                cmsComponents: {
                                    OrderReturnRequestListComponent: {
                                        component: OrderReturnRequestListComponent,
                                        guards: [i1.AuthGuard],
                                    },
                                },
                            }),
                        ],
                        declarations: [OrderReturnRequestListComponent],
                        exports: [OrderReturnRequestListComponent],
                    }]
            }] });

    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var OrderModule = /** @class */ (function () {
        function OrderModule() {
        }
        return OrderModule;
    }());
    OrderModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OrderModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    OrderModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OrderModule, imports: [OrderHistoryModule,
            OrderDetailsModule,
            ReplenishmentOrderDetailsModule,
            OrderCancellationModule,
            OrderReturnModule,
            ReplenishmentOrderHistoryModule,
            ReturnRequestListModule,
            ReturnRequestDetailModule] });
    OrderModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OrderModule, imports: [[
                OrderHistoryModule,
                OrderDetailsModule,
                ReplenishmentOrderDetailsModule,
                OrderCancellationModule,
                OrderReturnModule,
                ReplenishmentOrderHistoryModule,
                ReturnRequestListModule,
                ReturnRequestDetailModule,
            ]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OrderModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [
                            OrderHistoryModule,
                            OrderDetailsModule,
                            ReplenishmentOrderDetailsModule,
                            OrderCancellationModule,
                            OrderReturnModule,
                            ReplenishmentOrderHistoryModule,
                            ReturnRequestListModule,
                            ReturnRequestDetailModule,
                        ],
                    }]
            }] });

    var PaymentMethodsComponent = /** @class */ (function () {
        function PaymentMethodsComponent(userPaymentService, translation) {
            this.userPaymentService = userPaymentService;
            this.translation = translation;
            this.iconTypes = exports.ICON_TYPE;
        }
        PaymentMethodsComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.paymentMethods$ = this.userPaymentService.getPaymentMethods().pipe(operators.tap(function (paymentDetails) {
                // Set first payment method to DEFAULT if none is set
                if (paymentDetails.length > 0 &&
                    !paymentDetails.find(function (paymentDetail) { return paymentDetail.defaultPayment; })) {
                    _this.setDefaultPaymentMethod(paymentDetails[0]);
                }
            }));
            this.editCard = null;
            this.loading$ = this.userPaymentService.getPaymentMethodsLoading();
            this.userPaymentService.loadPaymentMethods();
        };
        PaymentMethodsComponent.prototype.getCardContent = function (_a) {
            var _this = this;
            var defaultPayment = _a.defaultPayment, accountHolderName = _a.accountHolderName, expiryMonth = _a.expiryMonth, expiryYear = _a.expiryYear, cardNumber = _a.cardNumber, cardType = _a.cardType;
            return rxjs.combineLatest([
                this.translation.translate('paymentCard.setAsDefault'),
                this.translation.translate('common.delete'),
                this.translation.translate('paymentCard.deleteConfirmation'),
                this.translation.translate('paymentCard.expires', {
                    month: expiryMonth,
                    year: expiryYear,
                }),
                this.translation.translate('paymentCard.defaultPaymentMethod'),
            ]).pipe(operators.map(function (_a) {
                var _b = __read(_a, 5), textSetAsDefault = _b[0], textDelete = _b[1], textDeleteConfirmation = _b[2], textExpires = _b[3], textDefaultPaymentMethod = _b[4];
                var actions = [];
                if (!defaultPayment) {
                    actions.push({ name: textSetAsDefault, event: 'default' });
                }
                actions.push({ name: textDelete, event: 'edit' });
                var card = {
                    header: defaultPayment ? textDefaultPaymentMethod : null,
                    textBold: accountHolderName,
                    text: [cardNumber, textExpires],
                    actions: actions,
                    deleteMsg: textDeleteConfirmation,
                    img: _this.getCardIcon(cardType.code),
                };
                return card;
            }));
        };
        PaymentMethodsComponent.prototype.deletePaymentMethod = function (paymentMethod) {
            this.userPaymentService.deletePaymentMethod(paymentMethod.id);
            this.editCard = null;
        };
        PaymentMethodsComponent.prototype.setEdit = function (paymentMethod) {
            this.editCard = paymentMethod.id;
        };
        PaymentMethodsComponent.prototype.cancelCard = function () {
            this.editCard = null;
        };
        PaymentMethodsComponent.prototype.setDefaultPaymentMethod = function (paymentMethod) {
            this.userPaymentService.setPaymentMethodAsDefault(paymentMethod.id);
        };
        PaymentMethodsComponent.prototype.getCardIcon = function (code) {
            var ccIcon;
            if (code === 'visa') {
                ccIcon = this.iconTypes.VISA;
            }
            else if (code === 'master' || code === 'mastercard_eurocard') {
                ccIcon = this.iconTypes.MASTER_CARD;
            }
            else if (code === 'diners') {
                ccIcon = this.iconTypes.DINERS_CLUB;
            }
            else if (code === 'amex') {
                ccIcon = this.iconTypes.AMEX;
            }
            else {
                ccIcon = this.iconTypes.CREDIT_CARD;
            }
            return ccIcon;
        };
        return PaymentMethodsComponent;
    }());
    PaymentMethodsComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PaymentMethodsComponent, deps: [{ token: i1__namespace.UserPaymentService }, { token: i1__namespace.TranslationService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    PaymentMethodsComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: PaymentMethodsComponent, selector: "cx-payment-methods", ngImport: i0__namespace, template: "<ng-container *ngIf=\"paymentMethods$ | async as paymentMethods\">\n  <div class=\"cx-payment container\">\n    <div class=\"cx-header\">\n      <h3>{{ 'paymentMethods.paymentMethods' | cxTranslate }}</h3>\n    </div>\n\n    <div class=\"cx-body\">\n      <div class=\"cx-msg\">\n        {{\n          'paymentMethods.newPaymentMethodsAreAddedDuringCheckout' | cxTranslate\n        }}\n      </div>\n      <div *ngIf=\"loading$ | async; else cards\"><cx-spinner></cx-spinner></div>\n      <ng-template #cards>\n        <div class=\"cx-existing row\">\n          <div\n            class=\"cx-payment-card col-sm-12 col-md-12 col-lg-6\"\n            *ngFor=\"let paymentMethod of paymentMethods\"\n          >\n            <div class=\"cx-payment-inner\">\n              <cx-card\n                [border]=\"true\"\n                [fitToContainer]=\"true\"\n                [content]=\"getCardContent(paymentMethod) | async\"\n                (deleteCard)=\"deletePaymentMethod(paymentMethod)\"\n                (setDefaultCard)=\"setDefaultPaymentMethod(paymentMethod)\"\n                (editCard)=\"setEdit(paymentMethod)\"\n                [editMode]=\"editCard === paymentMethod.id\"\n                (cancelCard)=\"cancelCard()\"\n              ></cx-card>\n            </div>\n          </div>\n        </div>\n      </ng-template>\n    </div>\n  </div>\n</ng-container>\n", components: [{ type: SpinnerComponent, selector: "cx-spinner" }, { type: CardComponent, selector: "cx-card", inputs: ["border", "editMode", "isDefault", "content", "fitToContainer", "truncateText", "charactersLimit"], outputs: ["deleteCard", "setDefaultCard", "sendCard", "editCard", "cancelCard"] }], directives: [{ type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3__namespace.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], pipes: { "async": i3__namespace.AsyncPipe, "cxTranslate": i1__namespace.TranslatePipe } });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PaymentMethodsComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-payment-methods',
                        templateUrl: './payment-methods.component.html',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace.UserPaymentService }, { type: i1__namespace.TranslationService }]; } });

    var PaymentMethodsModule = /** @class */ (function () {
        function PaymentMethodsModule() {
        }
        return PaymentMethodsModule;
    }());
    PaymentMethodsModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PaymentMethodsModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    PaymentMethodsModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PaymentMethodsModule, declarations: [PaymentMethodsComponent], imports: [i3.CommonModule, CardModule, SpinnerModule, i1.I18nModule], exports: [PaymentMethodsComponent] });
    PaymentMethodsModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PaymentMethodsModule, providers: [
            i1.provideDefaultConfig({
                cmsComponents: {
                    AccountPaymentDetailsComponent: {
                        component: PaymentMethodsComponent,
                        guards: [i1.AuthGuard],
                    },
                },
            }),
        ], imports: [[i3.CommonModule, CardModule, SpinnerModule, i1.I18nModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PaymentMethodsModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [i3.CommonModule, CardModule, SpinnerModule, i1.I18nModule],
                        providers: [
                            i1.provideDefaultConfig({
                                cmsComponents: {
                                    AccountPaymentDetailsComponent: {
                                        component: PaymentMethodsComponent,
                                        guards: [i1.AuthGuard],
                                    },
                                },
                            }),
                        ],
                        declarations: [PaymentMethodsComponent],
                        exports: [PaymentMethodsComponent],
                    }]
            }] });

    var PageTitleComponent = /** @class */ (function () {
        function PageTitleComponent(component, pageMetaService) {
            this.component = component;
            this.pageMetaService = pageMetaService;
        }
        PageTitleComponent.prototype.ngOnInit = function () {
            this.setTitle();
        };
        PageTitleComponent.prototype.setTitle = function () {
            this.title$ = this.pageMetaService.getMeta().pipe(operators.filter(i1.isNotNullable), operators.map(function (meta) { var _a; return (_a = (meta.heading || meta.title)) !== null && _a !== void 0 ? _a : ''; }));
        };
        return PageTitleComponent;
    }());
    PageTitleComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PageTitleComponent, deps: [{ token: CmsComponentData }, { token: i1__namespace.PageMetaService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    PageTitleComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: PageTitleComponent, selector: "cx-page-title", ngImport: i0__namespace, template: "<h1 class=\"cx-visually-hidden\">{{ title$ | async }}</h1>\n", pipes: { "async": i3__namespace.AsyncPipe }, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PageTitleComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-page-title',
                        templateUrl: './page-title.component.html',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], ctorParameters: function () { return [{ type: CmsComponentData }, { type: i1__namespace.PageMetaService }]; } });

    var BreadcrumbComponent = /** @class */ (function (_super) {
        __extends(BreadcrumbComponent, _super);
        function BreadcrumbComponent(component, pageMetaService, translation) {
            var _this = _super.call(this, component, pageMetaService) || this;
            _this.component = component;
            _this.pageMetaService = pageMetaService;
            _this.translation = translation;
            return _this;
        }
        BreadcrumbComponent.prototype.ngOnInit = function () {
            _super.prototype.ngOnInit.call(this);
            this.setCrumbs();
        };
        BreadcrumbComponent.prototype.setCrumbs = function () {
            this.crumbs$ = rxjs.combineLatest([
                this.pageMetaService.getMeta(),
                this.translation.translate('common.home'),
            ]).pipe(operators.map(function (_a) {
                var _b = __read(_a, 2), meta = _b[0], textHome = _b[1];
                return (meta === null || meta === void 0 ? void 0 : meta.breadcrumbs) ? meta.breadcrumbs : [{ label: textHome, link: '/' }];
            }));
        };
        return BreadcrumbComponent;
    }(PageTitleComponent));
    BreadcrumbComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: BreadcrumbComponent, deps: [{ token: CmsComponentData }, { token: i1__namespace.PageMetaService }, { token: i1__namespace.TranslationService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    BreadcrumbComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: BreadcrumbComponent, selector: "cx-breadcrumb", usesInheritance: true, ngImport: i0__namespace, template: "<nav>\n  <span *ngFor=\"let crumb of crumbs$ | async\">\n    <a [routerLink]=\"crumb.link\" [innerHTML]=\"crumb.label\"></a>\n  </span>\n</nav>\n<h1>{{ title$ | async }}</h1>\n", directives: [{ type: i3__namespace.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i1__namespace$1.RouterLinkWithHref, selector: "a[routerLink],area[routerLink]", inputs: ["routerLink", "target", "queryParams", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange", "replaceUrl", "state", "relativeTo"] }], pipes: { "async": i3__namespace.AsyncPipe }, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: BreadcrumbComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-breadcrumb',
                        templateUrl: './breadcrumb.component.html',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], ctorParameters: function () { return [{ type: CmsComponentData }, { type: i1__namespace.PageMetaService }, { type: i1__namespace.TranslationService }]; } });

    var BreadcrumbModule = /** @class */ (function () {
        function BreadcrumbModule() {
        }
        return BreadcrumbModule;
    }());
    BreadcrumbModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: BreadcrumbModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    BreadcrumbModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: BreadcrumbModule, declarations: [BreadcrumbComponent], imports: [i3.CommonModule, i1$1.RouterModule, i1.PageMetaModule], exports: [BreadcrumbComponent] });
    BreadcrumbModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: BreadcrumbModule, providers: [
            i1.provideDefaultConfig({
                cmsComponents: {
                    BreadcrumbComponent: {
                        component: BreadcrumbComponent,
                    },
                },
            }),
        ], imports: [[i3.CommonModule, i1$1.RouterModule, i1.PageMetaModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: BreadcrumbModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [i3.CommonModule, i1$1.RouterModule, i1.PageMetaModule],
                        providers: [
                            i1.provideDefaultConfig({
                                cmsComponents: {
                                    BreadcrumbComponent: {
                                        component: BreadcrumbComponent,
                                    },
                                },
                            }),
                        ],
                        declarations: [BreadcrumbComponent],
                        exports: [BreadcrumbComponent],
                    }]
            }] });

    var NavigationService = /** @class */ (function () {
        function NavigationService(cmsService, semanticPathService) {
            this.cmsService = cmsService;
            this.semanticPathService = semanticPathService;
        }
        NavigationService.prototype.createNavigation = function (data$) {
            return rxjs.combineLatest([data$, this.getNavigationNode(data$)]).pipe(operators.map(function (_b) {
                var _c = __read(_b, 2), data = _c[0], nav = _c[1];
                return data
                    ? {
                        title: data.name,
                        children: [nav],
                    }
                    : undefined;
            }));
        };
        /**
         * returns an observable with the `NavigationNode` for the given `CmsNavigationComponent`.
         * This function will load the navigation underlying entries and children if they haven't been
         * loaded so far.
         */
        NavigationService.prototype.getNavigationNode = function (data$) {
            var _this = this;
            if (!data$) {
                return rxjs.of();
            }
            return data$.pipe(operators.filter(function (data) { return !!data; }), operators.switchMap(function (data) {
                var navigation = data.navigationNode ? data.navigationNode : data;
                return _this.cmsService.getNavigationEntryItems(navigation.uid).pipe(operators.tap(function (items) {
                    if (items === undefined) {
                        _this.loadNavigationEntryItems(navigation, true);
                    }
                    else {
                        // we should check whether the existing node items are what expected
                        var expectedItems = [];
                        _this.loadNavigationEntryItems(navigation, false, expectedItems);
                        var existingItems_1 = Object.keys(items).map(function (key) { return items[key].uid; });
                        var missingItems = expectedItems.filter(function (it) { return !existingItems_1.includes(it.id); });
                        if (missingItems.length > 0) {
                            _this.cmsService.loadNavigationItems(navigation.uid, missingItems);
                        }
                    }
                }), operators.filter(Boolean), operators.map(function (items) { return _this.populateNavigationNode(navigation, items); }));
            }));
        };
        /**
         * Loads all navigation entry items' type and id. Dispatch action to load all these items
         * @param nodeData
         * @param root
         * @param itemsList
         */
        NavigationService.prototype.loadNavigationEntryItems = function (nodeData, root, itemsList) {
            var _this = this;
            if (itemsList === void 0) { itemsList = []; }
            if (nodeData.entries && nodeData.entries.length > 0) {
                nodeData.entries.forEach(function (entry) {
                    itemsList.push({
                        superType: entry.itemSuperType,
                        id: entry.itemId,
                    });
                });
            }
            if (nodeData.children && nodeData.children.length > 0) {
                nodeData.children.forEach(function (child) { return _this.loadNavigationEntryItems(child, false, itemsList); });
            }
            if (root) {
                this.cmsService.loadNavigationItems(nodeData.uid, itemsList);
            }
        };
        /**
         * Create a new node tree for the view
         * @param nodeData
         * @param items
         */
        NavigationService.prototype.populateNavigationNode = function (nodeData, items) {
            var _this = this;
            var _a;
            var node = {};
            if (nodeData.title) {
                // the node title will be populated by the first entry (if any)
                // if there's no nodeData.title available
                node.title = nodeData.title;
            }
            // populate style classes to apply CMS driven styling
            if (nodeData.styleClasses) {
                node.styleClasses = nodeData.styleClasses;
            }
            // populate style attributes to apply CMS driven styling
            if (nodeData.styleAttributes) {
                node.styleAttributes = nodeData.styleAttributes;
            }
            if (nodeData.entries && nodeData.entries.length > 0) {
                this.populateLink(node, nodeData.entries[0], items);
            }
            if (((_a = nodeData.children) === null || _a === void 0 ? void 0 : _a.length) > 0) {
                var children = nodeData.children
                    .map(function (child) { return _this.populateNavigationNode(child, items); })
                    .filter(Boolean);
                if (children.length > 0) {
                    node.children = children;
                }
            }
            // return null in case there are no children
            return Object.keys(node).length === 0 ? null : node;
        };
        /**
         * The node link is driven by the first entry.
         */
        NavigationService.prototype.populateLink = function (node, entry, items) {
            var item = items[entry.itemId + "_" + entry.itemSuperType];
            // now we only consider CMSLinkComponent
            if (item && entry.itemType === 'CMSLinkComponent') {
                if (!node.title) {
                    node.title = item.linkName;
                }
                var url = this.getLink(item);
                // only populate the node link if we have a visible node
                if (node.title && url) {
                    node.url = url;
                    // the backend provide boolean value for the target
                    // in case the link should be opened in a new window
                    if (item.target === 'true' || item.target === true) {
                        node.target = '_blank';
                    }
                }
                // populate style classes to apply CMS driven styling
                if (item.styleClasses) {
                    node.styleClasses = item.styleClasses;
                }
                // populate style attributes to apply CMS driven styling
                if (item.styleAttributes) {
                    node.styleAttributes = item.styleAttributes;
                }
            }
        };
        /**
         *
         * Gets the URL or link to a related item (category),
         * also taking into account content pages (contentPageLabelOrId)
         * and product pages (productCode)
         */
        NavigationService.prototype.getLink = function (item) {
            if (item.url) {
                return item.url;
            }
            else if (item.contentPageLabelOrId) {
                return item.contentPageLabelOrId;
            }
            else if (item.categoryCode) {
                return this.semanticPathService.transform({
                    cxRoute: 'category',
                    params: {
                        code: item.categoryCode,
                        name: item.name,
                    },
                });
            }
            else if (item.productCode) {
                return this.semanticPathService.transform({
                    cxRoute: 'product',
                    params: {
                        code: item.productCode,
                        name: item.name,
                    },
                });
            }
        };
        return NavigationService;
    }());
    NavigationService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: NavigationService, deps: [{ token: i1__namespace.CmsService }, { token: i1__namespace.SemanticPathService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    NavigationService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: NavigationService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: NavigationService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace.CmsService }, { type: i1__namespace.SemanticPathService }]; } });

    var HamburgerMenuService = /** @class */ (function () {
        function HamburgerMenuService(router) {
            var _this = this;
            this.isExpanded = new rxjs.BehaviorSubject(false);
            router.events
                .pipe(operators.filter(function (event) { return event instanceof i1$1.NavigationStart; }))
                .subscribe(function () {
                _this.toggle(true);
            });
        }
        /**
         * toggles the expand state of the hamburger menu
         */
        HamburgerMenuService.prototype.toggle = function (forceCollapse) {
            if (forceCollapse) {
                this.isExpanded.next(false);
            }
            else {
                this.isExpanded.next(!this.isExpanded.value);
            }
        };
        return HamburgerMenuService;
    }());
    HamburgerMenuService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: HamburgerMenuService, deps: [{ token: i1__namespace$1.Router }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    HamburgerMenuService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: HamburgerMenuService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: HamburgerMenuService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace$1.Router }]; } });

    var NavigationUIComponent = /** @class */ (function () {
        function NavigationUIComponent(router, renderer, elemRef, hamburgerMenuService) {
            var _this = this;
            this.router = router;
            this.renderer = renderer;
            this.elemRef = elemRef;
            this.hamburgerMenuService = hamburgerMenuService;
            /**
             * the icon type that will be used for navigation nodes
             * with children.
             */
            this.iconType = exports.ICON_TYPE;
            /**
             * Indicates whether the navigation should support flyout.
             * If flyout is set to true, the
             * nested child navigation nodes will only appear on hover or focus.
             */
            this.flyout = true;
            this.isOpen = false;
            this.openNodes = [];
            this.subscriptions = new rxjs.Subscription();
            this.resize = new i0.EventEmitter();
            this.subscriptions.add(this.router.events
                .pipe(operators.filter(function (event) { return event instanceof i1$1.NavigationEnd; }))
                .subscribe(function () { return _this.clear(); }));
            this.subscriptions.add(this.resize.pipe(operators.debounceTime(50)).subscribe(function () {
                _this.alignWrappersToRightIfStickOut();
            }));
        }
        NavigationUIComponent.prototype.onResize = function () {
            this.resize.next();
        };
        /**
         * During initialization of this component, we will check the resetMenuOnClose flag and attach a menu reset listener if needed.
         */
        NavigationUIComponent.prototype.ngOnInit = function () {
            if (this.resetMenuOnClose) {
                this.resetOnMenuCollapse();
            }
        };
        /**
         * This method performs the action of resetting the menu (close all sub menus and return to main options)
         * when the menu is closed.
         */
        NavigationUIComponent.prototype.resetOnMenuCollapse = function () {
            var _this = this;
            var _a;
            this.subscriptions.add((_a = this.hamburgerMenuService) === null || _a === void 0 ? void 0 : _a.isExpanded.pipe(operators.distinctUntilChanged(), operators.filter(Boolean)).subscribe(function () {
                _this.reinitalizeMenu();
            }));
        };
        /**
         * This method performs the actions required to reset the state of the menu and reset any visual components.
         */
        NavigationUIComponent.prototype.reinitalizeMenu = function () {
            var _a;
            if (((_a = this.openNodes) === null || _a === void 0 ? void 0 : _a.length) > 0) {
                this.clear();
                this.renderer.removeClass(this.elemRef.nativeElement, 'is-open');
            }
        };
        NavigationUIComponent.prototype.toggleOpen = function (event) {
            if (event.type === 'keydown') {
                event.preventDefault();
            }
            var node = event.currentTarget;
            if (this.openNodes.includes(node)) {
                if (event.type === 'keydown') {
                    this.back();
                }
                else {
                    this.openNodes = this.openNodes.filter(function (n) { return n !== node; });
                    this.renderer.removeClass(node, 'is-open');
                }
            }
            else {
                this.openNodes.push(node);
            }
            this.updateClasses();
            event.stopImmediatePropagation();
            event.stopPropagation();
        };
        NavigationUIComponent.prototype.back = function () {
            if (this.openNodes[this.openNodes.length - 1]) {
                this.renderer.removeClass(this.openNodes[this.openNodes.length - 1], 'is-open');
                this.openNodes.pop();
                this.updateClasses();
            }
        };
        NavigationUIComponent.prototype.clear = function () {
            this.openNodes = [];
            this.updateClasses();
        };
        NavigationUIComponent.prototype.onMouseEnter = function (event) {
            this.alignWrapperToRightIfStickOut(event.currentTarget);
            this.focusAfterPreviousClicked(event);
        };
        NavigationUIComponent.prototype.getTotalDepth = function (node, depth) {
            var _this = this;
            if (depth === void 0) { depth = 0; }
            if (node.children && node.children.length > 0) {
                return Math.max.apply(Math, __spreadArray([], __read(node.children.map(function (n) { return _this.getTotalDepth(n, depth + 1); }))));
            }
            else {
                return depth;
            }
        };
        NavigationUIComponent.prototype.getColumnCount = function (length) {
            return Math.round(length / (this.wrapAfter || length));
        };
        NavigationUIComponent.prototype.focusAfterPreviousClicked = function (event) {
            var target = ((event.target || event.relatedTarget));
            if (target.ownerDocument.activeElement.matches('nav[tabindex]') &&
                target.parentElement.matches('.flyout')) {
                target.focus();
            }
            return target.ownerDocument;
        };
        NavigationUIComponent.prototype.ngOnDestroy = function () {
            if (this.subscriptions) {
                this.subscriptions.unsubscribe();
            }
        };
        NavigationUIComponent.prototype.alignWrapperToRightIfStickOut = function (node) {
            var wrapper = node.querySelector('.wrapper');
            var body = node.closest('body');
            if (wrapper) {
                this.renderer.removeStyle(wrapper, 'margin-left');
                if (wrapper.offsetLeft + wrapper.offsetWidth >
                    body.offsetLeft + body.offsetWidth) {
                    this.renderer.setStyle(wrapper, 'margin-left', node.offsetWidth - wrapper.offsetWidth + "px");
                }
            }
        };
        NavigationUIComponent.prototype.alignWrappersToRightIfStickOut = function () {
            var _this = this;
            var navs = this.elemRef.nativeElement.childNodes;
            Array.from(navs)
                .filter(function (node) { return node.tagName === 'NAV'; })
                .forEach(function (nav) { return _this.alignWrapperToRightIfStickOut(nav); });
        };
        NavigationUIComponent.prototype.updateClasses = function () {
            var _this = this;
            this.openNodes.forEach(function (node, i) {
                if (i + 1 < _this.openNodes.length) {
                    _this.renderer.addClass(node, 'is-opened');
                    _this.renderer.removeClass(node, 'is-open');
                }
                else {
                    _this.renderer.removeClass(node, 'is-opened');
                    _this.renderer.addClass(node, 'is-open');
                }
            });
            this.isOpen = this.openNodes.length > 0;
        };
        return NavigationUIComponent;
    }());
    NavigationUIComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: NavigationUIComponent, deps: [{ token: i1__namespace$1.Router }, { token: i0__namespace.Renderer2 }, { token: i0__namespace.ElementRef }, { token: HamburgerMenuService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    NavigationUIComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: NavigationUIComponent, selector: "cx-navigation-ui", inputs: { node: "node", wrapAfter: "wrapAfter", resetMenuOnClose: "resetMenuOnClose", flyout: "flyout", isOpen: "isOpen" }, host: { listeners: { "window:resize": "onResize()" }, properties: { "class.flyout": "this.flyout", "class.is-open": "this.isOpen" } }, ngImport: i0__namespace, template: "<div\n  *ngIf=\"flyout && node?.children.length > 1\"\n  class=\"back is-open\"\n  (click)=\"back()\"\n>\n  <span>\n    <cx-icon [type]=\"iconType.CARET_LEFT\"></cx-icon>\n    {{ 'common.back' | cxTranslate }}\n  </span>\n</div>\n\n<ng-container *ngFor=\"let child of node?.children\">\n  <ng-container *ngTemplateOutlet=\"nav; context: { node: child, depth: 0 }\">\n  </ng-container>\n</ng-container>\n\n<!-- we generate links in a recursive manner -->\n<ng-template #nav let-node=\"node\" let-depth=\"depth\">\n  <nav\n    (click)=\"toggleOpen($event)\"\n    (mouseenter)=\"onMouseEnter($event)\"\n    (keydown.space)=\"toggleOpen($event)\"\n    (keydown.esc)=\"back()\"\n  >\n    <cx-generic-link\n      *ngIf=\"\n        node.url && (!node.children || node.children?.length === 0);\n        else heading\n      \"\n      [url]=\"node.url\"\n      [target]=\"node.target\"\n      [style]=\"node.styleAttributes\"\n      [class]=\"node.styleClasses\"\n    >\n      {{ node.title }}\n      <cx-icon\n        *ngIf=\"flyout && node.children?.length > 0\"\n        [type]=\"iconType.CARET_DOWN\"\n      ></cx-icon>\n    </cx-generic-link>\n\n    <ng-template #heading>\n      <span [attr.tabindex]=\"flyout && (depth === 0 || node.url) ? 0 : -1\">\n        {{ node.title }}\n        <cx-icon\n          *ngIf=\"flyout && node.children?.length > 0\"\n          [type]=\"iconType.CARET_DOWN\"\n        ></cx-icon>\n      </span>\n    </ng-template>\n\n    <!-- we add a wrapper to allow for better layout handling in CSS -->\n    <div class=\"wrapper\" *ngIf=\"node.children?.length > 0\">\n      <cx-generic-link\n        *ngIf=\"node.url\"\n        [url]=\"node.url\"\n        [target]=\"node.target\"\n        class=\"all\"\n      >\n        {{ 'navigation.shopAll' | cxTranslate: { navNode: node.title } }}\n      </cx-generic-link>\n      <div\n        class=\"childs\"\n        [attr.depth]=\"getTotalDepth(node)\"\n        [attr.wrap-after]=\"node.children?.length > wrapAfter ? wrapAfter : null\"\n        [attr.columns]=\"getColumnCount(node.children?.length)\"\n      >\n        <ng-container *ngFor=\"let child of node.children\">\n          <ng-container\n            *ngTemplateOutlet=\"nav; context: { node: child, depth: depth + 1 }\"\n          >\n          </ng-container>\n        </ng-container>\n      </div>\n    </div>\n  </nav>\n</ng-template>\n", components: [{ type: IconComponent, selector: "cx-icon,[cxIcon]", inputs: ["cxIcon", "type"] }, { type: GenericLinkComponent, selector: "cx-generic-link", inputs: ["url", "target", "id", "class", "style", "title"] }], directives: [{ type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3__namespace.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i3__namespace.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }], pipes: { "cxTranslate": i1__namespace.TranslatePipe }, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: NavigationUIComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-navigation-ui',
                        templateUrl: './navigation-ui.component.html',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace$1.Router }, { type: i0__namespace.Renderer2 }, { type: i0__namespace.ElementRef }, { type: HamburgerMenuService }]; }, propDecorators: { node: [{
                    type: i0.Input
                }], wrapAfter: [{
                    type: i0.Input
                }], resetMenuOnClose: [{
                    type: i0.Input
                }], flyout: [{
                    type: i0.Input
                }, {
                    type: i0.HostBinding,
                    args: ['class.flyout']
                }], isOpen: [{
                    type: i0.Input
                }, {
                    type: i0.HostBinding,
                    args: ['class.is-open']
                }], onResize: [{
                    type: i0.HostListener,
                    args: ['window:resize']
                }] } });

    var CategoryNavigationComponent = /** @class */ (function () {
        function CategoryNavigationComponent(componentData, service) {
            this.componentData = componentData;
            this.service = service;
            this.node$ = this.service.getNavigationNode(this.componentData.data$);
            this.data$ = this.componentData.data$;
        }
        return CategoryNavigationComponent;
    }());
    CategoryNavigationComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CategoryNavigationComponent, deps: [{ token: CmsComponentData }, { token: NavigationService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    CategoryNavigationComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: CategoryNavigationComponent, selector: "cx-category-navigation", ngImport: i0__namespace, template: "<cx-navigation-ui\n  *ngIf=\"data$ | async as data\"\n  [node]=\"node$ | async\"\n  [ngClass]=\"data.styleClass\"\n  [wrapAfter]=\"data.wrapAfter\"\n  [resetMenuOnClose]=\"data.resetMenuOnClose\"\n></cx-navigation-ui>\n", components: [{ type: NavigationUIComponent, selector: "cx-navigation-ui", inputs: ["node", "wrapAfter", "resetMenuOnClose", "flyout", "isOpen"] }], directives: [{ type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3__namespace.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }], pipes: { "async": i3__namespace.AsyncPipe }, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CategoryNavigationComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-category-navigation',
                        templateUrl: './category-navigation.component.html',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], ctorParameters: function () { return [{ type: CmsComponentData }, { type: NavigationService }]; } });

    var NavigationComponent = /** @class */ (function () {
        function NavigationComponent(componentData, service) {
            this.componentData = componentData;
            this.service = service;
            this.node$ = this.service.createNavigation(this.componentData.data$);
            this.styleClass$ = this.componentData.data$.pipe(operators.map(function (d) { return d === null || d === void 0 ? void 0 : d.styleClass; }));
        }
        return NavigationComponent;
    }());
    NavigationComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: NavigationComponent, deps: [{ token: CmsComponentData }, { token: NavigationService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    NavigationComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: NavigationComponent, selector: "cx-navigation", ngImport: i0__namespace, template: "<cx-navigation-ui [node]=\"node$ | async\" [ngClass]=\"styleClass$ | async\">\n</cx-navigation-ui>\n", components: [{ type: NavigationUIComponent, selector: "cx-navigation-ui", inputs: ["node", "wrapAfter", "resetMenuOnClose", "flyout", "isOpen"] }], directives: [{ type: i3__namespace.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }], pipes: { "async": i3__namespace.AsyncPipe }, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: NavigationComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-navigation',
                        templateUrl: './navigation.component.html',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], ctorParameters: function () { return [{ type: CmsComponentData }, { type: NavigationService }]; } });

    var NavigationModule = /** @class */ (function () {
        function NavigationModule() {
        }
        return NavigationModule;
    }());
    NavigationModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: NavigationModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    NavigationModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: NavigationModule, declarations: [NavigationComponent, NavigationUIComponent], imports: [i3.CommonModule,
            i1$1.RouterModule,
            IconModule,
            GenericLinkModule,
            i1.I18nModule], exports: [NavigationComponent, NavigationUIComponent] });
    NavigationModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: NavigationModule, providers: [
            i1.provideDefaultConfig({
                cmsComponents: {
                    NavigationComponent: {
                        component: NavigationComponent,
                    },
                },
            }),
        ], imports: [[
                i3.CommonModule,
                i1$1.RouterModule,
                IconModule,
                GenericLinkModule,
                i1.I18nModule,
            ]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: NavigationModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [
                            i3.CommonModule,
                            i1$1.RouterModule,
                            IconModule,
                            GenericLinkModule,
                            i1.I18nModule,
                        ],
                        providers: [
                            i1.provideDefaultConfig({
                                cmsComponents: {
                                    NavigationComponent: {
                                        component: NavigationComponent,
                                    },
                                },
                            }),
                        ],
                        declarations: [NavigationComponent, NavigationUIComponent],
                        exports: [NavigationComponent, NavigationUIComponent],
                    }]
            }] });

    var CategoryNavigationModule = /** @class */ (function () {
        function CategoryNavigationModule() {
        }
        return CategoryNavigationModule;
    }());
    CategoryNavigationModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CategoryNavigationModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    CategoryNavigationModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CategoryNavigationModule, declarations: [CategoryNavigationComponent], imports: [i3.CommonModule, NavigationModule], exports: [CategoryNavigationComponent] });
    CategoryNavigationModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CategoryNavigationModule, providers: [
            i1.provideDefaultConfig({
                cmsComponents: {
                    CategoryNavigationComponent: {
                        component: CategoryNavigationComponent,
                        data: {
                            resetMenuOnClose: true,
                        },
                    },
                },
            }),
        ], imports: [[i3.CommonModule, NavigationModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CategoryNavigationModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [i3.CommonModule, NavigationModule],
                        providers: [
                            i1.provideDefaultConfig({
                                cmsComponents: {
                                    CategoryNavigationComponent: {
                                        component: CategoryNavigationComponent,
                                        data: {
                                            resetMenuOnClose: true,
                                        },
                                    },
                                },
                            }),
                        ],
                        declarations: [CategoryNavigationComponent],
                        exports: [CategoryNavigationComponent],
                    }]
            }] });

    var FooterNavigationComponent = /** @class */ (function () {
        function FooterNavigationComponent(componentData, service) {
            this.componentData = componentData;
            this.service = service;
            this.node$ = this.service.getNavigationNode(this.componentData.data$);
            this.styleClass$ = this.componentData.data$.pipe(operators.map(function (d) { return d === null || d === void 0 ? void 0 : d.styleClass; }));
        }
        return FooterNavigationComponent;
    }());
    FooterNavigationComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: FooterNavigationComponent, deps: [{ token: CmsComponentData }, { token: NavigationService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    FooterNavigationComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: FooterNavigationComponent, selector: "cx-footer-navigation", ngImport: i0__namespace, template: "<cx-navigation-ui\n  [node]=\"node$ | async\"\n  [flyout]=\"false\"\n  [ngClass]=\"styleClass$ | async\"\n></cx-navigation-ui>\n", components: [{ type: NavigationUIComponent, selector: "cx-navigation-ui", inputs: ["node", "wrapAfter", "resetMenuOnClose", "flyout", "isOpen"] }], directives: [{ type: i3__namespace.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }], pipes: { "async": i3__namespace.AsyncPipe }, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: FooterNavigationComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-footer-navigation',
                        templateUrl: './footer-navigation.component.html',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], ctorParameters: function () { return [{ type: CmsComponentData }, { type: NavigationService }]; } });

    var FooterNavigationModule = /** @class */ (function () {
        function FooterNavigationModule() {
        }
        return FooterNavigationModule;
    }());
    FooterNavigationModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: FooterNavigationModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    FooterNavigationModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: FooterNavigationModule, declarations: [FooterNavigationComponent], imports: [i3.CommonModule,
            i1$1.RouterModule,
            NavigationModule,
            GenericLinkModule,
            i1.I18nModule], exports: [FooterNavigationComponent] });
    FooterNavigationModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: FooterNavigationModule, providers: [
            i1.provideDefaultConfig({
                cmsComponents: {
                    FooterNavigationComponent: {
                        component: FooterNavigationComponent,
                    },
                },
            }),
        ], imports: [[
                i3.CommonModule,
                i1$1.RouterModule,
                NavigationModule,
                GenericLinkModule,
                i1.I18nModule,
            ]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: FooterNavigationModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [
                            i3.CommonModule,
                            i1$1.RouterModule,
                            NavigationModule,
                            GenericLinkModule,
                            i1.I18nModule,
                        ],
                        providers: [
                            i1.provideDefaultConfig({
                                cmsComponents: {
                                    FooterNavigationComponent: {
                                        component: FooterNavigationComponent,
                                    },
                                },
                            }),
                        ],
                        declarations: [FooterNavigationComponent],
                        exports: [FooterNavigationComponent],
                    }]
            }] });

    var PageTitleModule = /** @class */ (function () {
        function PageTitleModule() {
        }
        return PageTitleModule;
    }());
    PageTitleModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PageTitleModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    PageTitleModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PageTitleModule, declarations: [PageTitleComponent], imports: [i3.CommonModule, i1$1.RouterModule, i1.PageMetaModule], exports: [PageTitleComponent] });
    PageTitleModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PageTitleModule, providers: [
            i1.provideDefaultConfig({
                cmsComponents: {
                    PageTitleComponent: {
                        component: PageTitleComponent,
                    },
                },
            }),
        ], imports: [[i3.CommonModule, i1$1.RouterModule, i1.PageMetaModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PageTitleModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [i3.CommonModule, i1$1.RouterModule, i1.PageMetaModule],
                        providers: [
                            i1.provideDefaultConfig({
                                cmsComponents: {
                                    PageTitleComponent: {
                                        component: PageTitleComponent,
                                    },
                                },
                            }),
                        ],
                        declarations: [PageTitleComponent],
                        exports: [PageTitleComponent],
                        entryComponents: [PageTitleComponent],
                    }]
            }] });

    var HighlightPipe = /** @class */ (function () {
        function HighlightPipe() {
        }
        HighlightPipe.prototype.transform = function (text, match) {
            if (!match) {
                return text;
            }
            return text.replace(match.trim(), "<span class=\"highlight\">" + match.trim() + "</span>");
        };
        return HighlightPipe;
    }());
    HighlightPipe.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: HighlightPipe, deps: [], target: i0__namespace.ɵɵFactoryTarget.Pipe });
    HighlightPipe.ɵpipe = i0__namespace.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: HighlightPipe, name: "cxHighlight" });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: HighlightPipe, decorators: [{
                type: i0.Pipe,
                args: [{ name: 'cxHighlight' }]
            }] });

    /**
     * Indicates that the user chose a suggestion
     */
    var SearchBoxSuggestionSelectedEvent = /** @class */ (function (_super) {
        __extends(SearchBoxSuggestionSelectedEvent, _super);
        function SearchBoxSuggestionSelectedEvent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return SearchBoxSuggestionSelectedEvent;
    }(i1.CxEvent));
    /**
     * Event's type
     */
    SearchBoxSuggestionSelectedEvent.type = 'SearchBoxSuggestionSelectedEvent';
    /**
     * Indicates that the user chose a product suggestion
     */
    var SearchBoxProductSelectedEvent = /** @class */ (function (_super) {
        __extends(SearchBoxProductSelectedEvent, _super);
        function SearchBoxProductSelectedEvent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return SearchBoxProductSelectedEvent;
    }(i1.CxEvent));
    /**
     * Event's type
     */
    SearchBoxProductSelectedEvent.type = 'SearchBoxProductSelectedEvent';

    var HAS_SEARCH_RESULT_CLASS = 'has-searchbox-results';
    var SearchBoxComponentService = /** @class */ (function () {
        function SearchBoxComponentService(searchService, routingService, translationService, winRef, eventService) {
            this.searchService = searchService;
            this.routingService = routingService;
            this.translationService = translationService;
            this.winRef = winRef;
            this.eventService = eventService;
        }
        /**
         * Executes the search for products and suggestions,
         * unless the configuration is setup to not search for
         * products or suggestions.
         */
        SearchBoxComponentService.prototype.search = function (query, config) {
            if (!query || query === '') {
                this.clearResults();
                return;
            }
            if (config.minCharactersBeforeRequest &&
                query.length < config.minCharactersBeforeRequest) {
                return;
            }
            if (config.displayProducts) {
                this.searchService.search(query, {
                    pageSize: config.maxProducts,
                });
            }
            if (config.displaySuggestions) {
                this.searchService.searchSuggestions(query, {
                    pageSize: config.maxSuggestions,
                });
            }
        };
        /**
         * Returns an observable with the SearchResults. When there's any
         * result, the body tag will get a classname, so that specific style
         * rules can be applied.
         */
        SearchBoxComponentService.prototype.getResults = function (config) {
            var _this = this;
            return rxjs.combineLatest([
                this.getProductResults(config),
                this.getProductSuggestions(config),
                this.getSearchMessage(config),
            ]).pipe(operators.map(function (_a) {
                var _b = __read(_a, 3), productResults = _b[0], suggestions = _b[1], message = _b[2];
                return {
                    products: productResults ? productResults.products : null,
                    suggestions: suggestions,
                    message: message,
                };
            }), operators.tap(function (results) { return _this.toggleBodyClass(HAS_SEARCH_RESULT_CLASS, _this.hasResults(results)); }));
        };
        /**
         * Clears the searchbox results, so that old values are
         * no longer emited upon next search.
         */
        SearchBoxComponentService.prototype.clearResults = function () {
            this.searchService.clearResults();
            this.toggleBodyClass(HAS_SEARCH_RESULT_CLASS, false);
        };
        SearchBoxComponentService.prototype.hasBodyClass = function (className) {
            return this.winRef.document.body.classList.contains(className);
        };
        SearchBoxComponentService.prototype.toggleBodyClass = function (className, add) {
            if (add === undefined) {
                this.winRef.document.body.classList.toggle(className);
            }
            else {
                add
                    ? this.winRef.document.body.classList.add(className)
                    : this.winRef.document.body.classList.remove(className);
            }
        };
        /**
         * Dispatches a searchbox event for product selected
         *
         * @param eventData data for the "SearchBoxProductSelectedEvent"
         */
        SearchBoxComponentService.prototype.dispatchProductSelectedEvent = function (eventData) {
            this.eventService.dispatch({
                freeText: eventData.freeText,
                productCode: eventData.productCode,
            }, SearchBoxProductSelectedEvent);
        };
        /**
         * Dispatches a searchbox event for suggestion selected
         *
         * @param eventData data for the "SearchBoxSuggestionSelectedEvent"
         */
        SearchBoxComponentService.prototype.dispatchSuggestionSelectedEvent = function (eventData) {
            this.eventService.dispatch({
                freeText: eventData.freeText,
                selectedSuggestion: eventData.selectedSuggestion,
                searchSuggestions: eventData.searchSuggestions,
            }, SearchBoxSuggestionSelectedEvent);
        };
        /**
         * For search results model, it returns true when:
         * * there is any product OR
         * * the is any search suggestion OR
         * * there is a message.
         *
         * Otherwise it returns false.
         */
        SearchBoxComponentService.prototype.hasResults = function (results) {
            return ((!!results.products && results.products.length > 0) ||
                (!!results.suggestions && results.suggestions.length > 0) ||
                !!results.message);
        };
        /**
         * Emits product search results in case when the config property `displayProducts` is true.
         * Otherwise it emits an empty object.
         */
        SearchBoxComponentService.prototype.getProductResults = function (config) {
            if (config.displayProducts) {
                return this.searchService.getResults();
            }
            else {
                return rxjs.of({});
            }
        };
        /**
         * Loads suggestions from the backend. In case there's no suggestion
         * available, we try to get an exact match suggestion.
         */
        SearchBoxComponentService.prototype.getProductSuggestions = function (config) {
            var _this = this;
            if (!config.displaySuggestions) {
                return rxjs.of([]);
            }
            else {
                return this.searchService.getSuggestionResults().pipe(operators.map(function (res) { return res.map(function (suggestion) { return suggestion.value; }); }), operators.switchMap(function (suggestions) {
                    if (suggestions.length === 0) {
                        return _this.getExactSuggestion(config).pipe(operators.map(function (match) { return (match ? [match] : []); }));
                    }
                    else {
                        return rxjs.of(suggestions);
                    }
                }));
            }
        };
        /**
         * Whenever there is at least 1 product, we simulate
         * a suggestion to provide easy access to the search result page
         */
        SearchBoxComponentService.prototype.getExactSuggestion = function (config) {
            var _this = this;
            return this.getProductResults(config).pipe(operators.switchMap(function (productResult) {
                return productResult.products && productResult.products.length > 0
                    ? _this.fetchTranslation('searchBox.help.exactMatch', {
                        term: productResult.freeTextSearch,
                    })
                    : rxjs.of(null);
            }));
        };
        /**
         * Emits a 'no match' message, in case the product search results and search suggestions are empty.
         * Otherwise it emits null.
         */
        SearchBoxComponentService.prototype.getSearchMessage = function (config) {
            var _this = this;
            return rxjs.combineLatest([
                this.getProductResults(config),
                this.getProductSuggestions(config),
            ]).pipe(operators.switchMap(function (_a) {
                var _b = __read(_a, 2), productResult = _b[0], suggestions = _b[1];
                if (productResult &&
                    productResult.products &&
                    productResult.products.length === 0 &&
                    suggestions &&
                    suggestions.length === 0) {
                    return _this.fetchTranslation('searchBox.help.noMatch');
                }
                else {
                    return rxjs.of(null);
                }
            }));
        };
        /**
         * Navigates to the search result page with a given query
         */
        SearchBoxComponentService.prototype.launchSearchPage = function (query) {
            this.routingService.go({
                cxRoute: 'search',
                params: { query: query },
            });
        };
        SearchBoxComponentService.prototype.fetchTranslation = function (translationKey, options) {
            return this.translationService.translate(translationKey, options);
        };
        return SearchBoxComponentService;
    }());
    SearchBoxComponentService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SearchBoxComponentService, deps: [{ token: i1__namespace.SearchboxService }, { token: i1__namespace.RoutingService }, { token: i1__namespace.TranslationService }, { token: i1__namespace.WindowRef }, { token: i1__namespace.EventService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    SearchBoxComponentService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SearchBoxComponentService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SearchBoxComponentService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace.SearchboxService }, { type: i1__namespace.RoutingService }, { type: i1__namespace.TranslationService }, { type: i1__namespace.WindowRef }, { type: i1__namespace.EventService }]; } });

    var DEFAULT_SEARCH_BOX_CONFIG = {
        minCharactersBeforeRequest: 1,
        displayProducts: true,
        displaySuggestions: true,
        maxProducts: 5,
        maxSuggestions: 5,
        displayProductImages: true,
    };
    var SearchBoxComponent = /** @class */ (function () {
        function SearchBoxComponent(searchBoxComponentService, componentData, winRef, routingService) {
            var _this = this;
            var _a;
            this.searchBoxComponentService = searchBoxComponentService;
            this.componentData = componentData;
            this.winRef = winRef;
            this.routingService = routingService;
            this.iconTypes = exports.ICON_TYPE;
            /**
             * In some occasions we need to ignore the close event,
             * for example when we click inside the search result section.
             */
            this.ignoreCloseEvent = false;
            this.chosenWord = '';
            /**
             * Returns the SearchBox configuration. The configuration is driven by multiple
             * layers: default configuration, (optional) backend configuration and (optional)
             * input configuration.
             */
            this.config$ = (((_a = this.componentData) === null || _a === void 0 ? void 0 : _a.data$) || rxjs.of({})).pipe(operators.map(function (config) {
                var isBool = function (obj, prop) { return (obj === null || obj === void 0 ? void 0 : obj[prop]) !== 'false' && (obj === null || obj === void 0 ? void 0 : obj[prop]) !== false; };
                return Object.assign(Object.assign(Object.assign(Object.assign({}, DEFAULT_SEARCH_BOX_CONFIG), config), { displayProducts: isBool(config, 'displayProducts'), displayProductImages: isBool(config, 'displayProductImages'), displaySuggestions: isBool(config, 'displaySuggestions') }), _this.config);
            }), operators.tap(function (config) { return (_this.config = config); }));
            this.results$ = this.config$.pipe(operators.switchMap(function (config) { return _this.searchBoxComponentService.getResults(config); }));
        }
        Object.defineProperty(SearchBoxComponent.prototype, "queryText", {
            /**
             * Sets the search box input field
             */
            set: function (value) {
                if (value) {
                    this.search(value);
                }
            },
            enumerable: false,
            configurable: true
        });
        SearchBoxComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.subscription = this.routingService
                .getRouterState()
                .pipe(operators.filter(function (data) { return !data.nextState; }))
                .subscribe(function (data) {
                var _a, _b;
                if (!(((_a = data.state.context) === null || _a === void 0 ? void 0 : _a.id) === 'search' &&
                    ((_b = data.state.context) === null || _b === void 0 ? void 0 : _b.type) === i1.PageType.CONTENT_PAGE))
                    _this.chosenWord = '';
            });
        };
        /**
         * Closes the searchBox and opens the search result page.
         */
        SearchBoxComponent.prototype.search = function (query) {
            this.searchBoxComponentService.search(query, this.config);
            // force the searchBox to open
            this.open();
        };
        /**
         * Opens the type-ahead searchBox
         */
        SearchBoxComponent.prototype.open = function () {
            this.searchBoxComponentService.toggleBodyClass('searchbox-is-active', true);
        };
        /**
         * Dispatch UI events for Suggestion selected
         *
         * @param eventData the data for the event
         */
        SearchBoxComponent.prototype.dispatchSuggestionEvent = function (eventData) {
            this.searchBoxComponentService.dispatchSuggestionSelectedEvent(eventData);
        };
        /**
         * Dispatch UI events for Product selected
         *
         * @param eventData the data for the event
         */
        SearchBoxComponent.prototype.dispatchProductEvent = function (eventData) {
            this.searchBoxComponentService.dispatchProductSelectedEvent(eventData);
        };
        /**
         * Closes the type-ahead searchBox.
         */
        SearchBoxComponent.prototype.close = function (event, force) {
            var _this = this;
            // Use timeout to detect changes
            setTimeout(function () {
                if ((!_this.ignoreCloseEvent && !_this.isSearchBoxFocused()) || force) {
                    _this.blurSearchBox(event);
                }
            });
        };
        SearchBoxComponent.prototype.blurSearchBox = function (event) {
            this.searchBoxComponentService.toggleBodyClass('searchbox-is-active', false);
            if (event && event.target) {
                event.target.blur();
            }
        };
        // Check if focus is on searchbox or result list elements
        SearchBoxComponent.prototype.isSearchBoxFocused = function () {
            return (this.getResultElements().includes(this.getFocusedElement()) ||
                this.winRef.document.querySelector('input[aria-label="Search"]') ===
                    this.getFocusedElement());
        };
        /**
         * Especially in mobile we do not want the search icon
         * to focus the input again when it's already open.
         * */
        SearchBoxComponent.prototype.avoidReopen = function (event) {
            if (this.searchBoxComponentService.hasBodyClass('searchbox-is-active')) {
                this.close(event);
                event.preventDefault();
            }
        };
        // Return result list as HTMLElement array
        SearchBoxComponent.prototype.getResultElements = function () {
            return Array.from(this.winRef.document.querySelectorAll('.products > li a, .suggestions > li a'));
        };
        // Return focused element as HTMLElement
        SearchBoxComponent.prototype.getFocusedElement = function () {
            return this.winRef.document.activeElement;
        };
        SearchBoxComponent.prototype.updateChosenWord = function (chosenWord) {
            this.chosenWord = chosenWord;
        };
        SearchBoxComponent.prototype.getFocusedIndex = function () {
            return this.getResultElements().indexOf(this.getFocusedElement());
        };
        // Focus on previous item in results list
        SearchBoxComponent.prototype.focusPreviousChild = function (event) {
            event.preventDefault(); // Negate normal keyscroll
            var _c = __read([
                this.getResultElements(),
                this.getFocusedIndex(),
            ], 2), results = _c[0], focusedIndex = _c[1];
            // Focus on last index moving to first
            if (results.length) {
                if (focusedIndex < 1) {
                    results[results.length - 1].focus();
                }
                else {
                    results[focusedIndex - 1].focus();
                }
            }
        };
        // Focus on next item in results list
        SearchBoxComponent.prototype.focusNextChild = function (event) {
            this.open();
            event.preventDefault(); // Negate normal keyscroll
            var _c = __read([
                this.getResultElements(),
                this.getFocusedIndex(),
            ], 2), results = _c[0], focusedIndex = _c[1];
            // Focus on first index moving to last
            if (results.length) {
                if (focusedIndex >= results.length - 1) {
                    results[0].focus();
                }
                else {
                    results[focusedIndex + 1].focus();
                }
            }
        };
        /**
         * Opens the PLP with the given query.
         *
         * TODO: if there's a single product match, we could open the PDP.
         */
        SearchBoxComponent.prototype.launchSearchResult = function (event, query) {
            if (!query || query.trim().length === 0) {
                return;
            }
            this.close(event);
            this.searchBoxComponentService.launchSearchPage(query);
        };
        /**
         * Disables closing the search result list.
         */
        SearchBoxComponent.prototype.disableClose = function () {
            this.ignoreCloseEvent = true;
        };
        SearchBoxComponent.prototype.preventDefault = function (ev) {
            ev.preventDefault();
        };
        /**
         * Clears the search box input field
         */
        SearchBoxComponent.prototype.clear = function (el) {
            var _this = this;
            this.disableClose();
            el.value = '';
            this.searchBoxComponentService.clearResults();
            // Use Timeout to run after blur event to prevent the searchbox from closing on mobile
            setTimeout(function () {
                // Retain focus on input lost by clicking on icon
                el.focus();
                _this.ignoreCloseEvent = false;
            });
        };
        SearchBoxComponent.prototype.ngOnDestroy = function () {
            var _a;
            (_a = this.subscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();
        };
        return SearchBoxComponent;
    }());
    SearchBoxComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SearchBoxComponent, deps: [{ token: SearchBoxComponentService }, { token: CmsComponentData, optional: true }, { token: i1__namespace.WindowRef }, { token: i1__namespace.RoutingService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    SearchBoxComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: SearchBoxComponent, selector: "cx-searchbox", inputs: { config: "config", queryText: "queryText" }, ngImport: i0__namespace, template: "<label class=\"searchbox\" [class.dirty]=\"!!searchInput.value\">\n  <input\n    #searchInput\n    [placeholder]=\"'searchBox.placeholder' | cxTranslate\"\n    autocomplete=\"off\"\n    aria-describedby=\"initialDescription\"\n    aria-controls=\"results\"\n    [attr.aria-label]=\"'common.search' | cxTranslate\"\n    (focus)=\"open()\"\n    (click)=\"open()\"\n    (input)=\"search(searchInput.value)\"\n    (blur)=\"close($event)\"\n    (keydown.escape)=\"close($event)\"\n    (keydown.enter)=\"\n      close($event, true);\n      launchSearchResult($event, searchInput.value);\n      updateChosenWord(searchInput.value)\n    \"\n    (keydown.arrowup)=\"focusPreviousChild($event)\"\n    (keydown.arrowdown)=\"focusNextChild($event)\"\n    value=\"{{ chosenWord }}\"\n  />\n\n  <button\n    [attr.aria-label]=\"'common.reset' | cxTranslate\"\n    (mousedown)=\"clear(searchInput)\"\n    (keydown.enter)=\"clear(searchInput)\"\n    class=\"reset\"\n  >\n    <cx-icon [type]=\"iconTypes.RESET\"></cx-icon>\n  </button>\n\n  <div role=\"presentation\" class=\"search-icon\">\n    <cx-icon [type]=\"iconTypes.SEARCH\"></cx-icon>\n  </div>\n\n  <button\n    [attr.aria-label]=\"'common.search' | cxTranslate\"\n    class=\"search\"\n    (click)=\"open()\"\n  >\n    <cx-icon [type]=\"iconTypes.SEARCH\"></cx-icon>\n  </button>\n</label>\n\n<div\n  *ngIf=\"results$ | async as result\"\n  class=\"results\"\n  id=\"results\"\n  (click)=\"close($event, true)\"\n  role=\"listbox\"\n>\n  <div\n    *ngIf=\"result.message\"\n    class=\"message\"\n    [innerHTML]=\"result.message\"\n  ></div>\n\n  <ul\n    class=\"suggestions\"\n    attr.aria-label=\"{{ 'searchBox.ariaLabelSuggestions' | cxTranslate }}\"\n    tabindex=\"0\"\n  >\n    <li *ngFor=\"let suggestion of result.suggestions\">\n      <a\n        [innerHTML]=\"suggestion | cxHighlight: searchInput.value\"\n        [routerLink]=\"\n          {\n            cxRoute: 'search',\n            params: { query: suggestion }\n          } | cxUrl\n        \"\n        (keydown.arrowup)=\"focusPreviousChild($event)\"\n        (keydown.arrowdown)=\"focusNextChild($event)\"\n        (keydown.enter)=\"close($event, true)\"\n        (keydown.escape)=\"close($event, true)\"\n        (blur)=\"close($event)\"\n        (mousedown)=\"preventDefault($event)\"\n        (click)=\"\n          dispatchSuggestionEvent({\n            freeText: searchInput.value,\n            selectedSuggestion: suggestion,\n            searchSuggestions: result.suggestions\n          });\n          updateChosenWord(suggestion)\n        \"\n      >\n      </a>\n    </li>\n  </ul>\n\n  <ul\n    class=\"products\"\n    *ngIf=\"result.products\"\n    attr.aria-label=\"{{ 'searchBox.ariaLabelProducts' | cxTranslate }}\"\n    tabindex=\"0\"\n  >\n    <li *ngFor=\"let product of result.products\">\n      <a\n        [routerLink]=\"\n          {\n            cxRoute: 'product',\n            params: product\n          } | cxUrl\n        \"\n        [class.has-media]=\"config.displayProductImages\"\n        (keydown.arrowup)=\"focusPreviousChild($event)\"\n        (keydown.arrowdown)=\"focusNextChild($event)\"\n        (keydown.enter)=\"close($event, true)\"\n        (keydown.escape)=\"close($event, true)\"\n        (blur)=\"close($event)\"\n        (mousedown)=\"preventDefault($event)\"\n        (click)=\"\n          dispatchProductEvent({\n            freeText: searchInput.value,\n            productCode: product.code\n          })\n        \"\n      >\n        <cx-media\n          *ngIf=\"config.displayProductImages\"\n          [container]=\"product.images?.PRIMARY\"\n          format=\"thumbnail\"\n          role=\"presentation\"\n        ></cx-media>\n        <div class=\"name\" [innerHTML]=\"product.nameHtml\"></div>\n        <span class=\"price\">{{ product.price?.formattedValue }}</span>\n      </a>\n    </li>\n  </ul>\n  <span id=\"initialDescription\" class=\"cx-visually-hidden\">\n    {{ 'searchBox.initialDescription' | cxTranslate }}\n  </span>\n  <div\n    *ngIf=\"result.suggestions?.length || result.products?.length\"\n    aria-live=\"assertive\"\n    class=\"cx-visually-hidden\"\n  >\n    {{\n      'searchBox.suggestionsResult'\n        | cxTranslate: { count: result.suggestions?.length }\n    }}\n    {{\n      'searchBox.productsResult'\n        | cxTranslate: { count: result.products?.length }\n    }}\n    {{ 'searchBox.initialDescription' | cxTranslate }}\n  </div>\n</div>\n", components: [{ type: IconComponent, selector: "cx-icon,[cxIcon]", inputs: ["cxIcon", "type"] }, { type: MediaComponent, selector: "cx-media", inputs: ["container", "format", "alt", "role", "loading"], outputs: ["loaded"] }], directives: [{ type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3__namespace.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i1__namespace$1.RouterLinkWithHref, selector: "a[routerLink],area[routerLink]", inputs: ["routerLink", "target", "queryParams", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange", "replaceUrl", "state", "relativeTo"] }], pipes: { "cxTranslate": i1__namespace.TranslatePipe, "async": i3__namespace.AsyncPipe, "cxHighlight": HighlightPipe, "cxUrl": i1__namespace.UrlPipe }, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SearchBoxComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-searchbox',
                        templateUrl: './search-box.component.html',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], ctorParameters: function () {
            return [{ type: SearchBoxComponentService }, { type: CmsComponentData, decorators: [{
                            type: i0.Optional
                        }] }, { type: i1__namespace.WindowRef }, { type: i1__namespace.RoutingService }];
        }, propDecorators: { config: [{
                    type: i0.Input
                }], queryText: [{
                    type: i0.Input,
                    args: ['queryText']
                }] } });

    var SearchBoxModule = /** @class */ (function () {
        function SearchBoxModule() {
        }
        return SearchBoxModule;
    }());
    SearchBoxModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SearchBoxModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    SearchBoxModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SearchBoxModule, declarations: [SearchBoxComponent, HighlightPipe], imports: [i3.CommonModule,
            i1$1.RouterModule,
            MediaModule,
            IconModule,
            i1.UrlModule,
            i1.I18nModule], exports: [SearchBoxComponent, HighlightPipe] });
    SearchBoxModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SearchBoxModule, providers: [
            i1.provideDefaultConfig({
                cmsComponents: {
                    SearchBoxComponent: {
                        component: SearchBoxComponent,
                    },
                },
            }),
        ], imports: [[
                i3.CommonModule,
                i1$1.RouterModule,
                MediaModule,
                IconModule,
                i1.UrlModule,
                i1.I18nModule,
            ]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SearchBoxModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [
                            i3.CommonModule,
                            i1$1.RouterModule,
                            MediaModule,
                            IconModule,
                            i1.UrlModule,
                            i1.I18nModule,
                        ],
                        providers: [
                            i1.provideDefaultConfig({
                                cmsComponents: {
                                    SearchBoxComponent: {
                                        component: SearchBoxComponent,
                                    },
                                },
                            }),
                        ],
                        declarations: [SearchBoxComponent, HighlightPipe],
                        exports: [SearchBoxComponent, HighlightPipe],
                    }]
            }] });

    var ProductCarouselService = /** @class */ (function () {
        function ProductCarouselService(productService, semanticPathService) {
            this.productService = productService;
            this.semanticPathService = semanticPathService;
        }
        /**
         * Loads the product data and converts it `CarouselItem`.
         */
        ProductCarouselService.prototype.loadProduct = function (code) {
            var _this = this;
            return this.productService.get(code).pipe(operators.filter(Boolean), operators.map(function (product) { return _this.convertProduct(product); }));
        };
        /**
         * Converts the product to a generic CarouselItem
         */
        ProductCarouselService.prototype.convertProduct = function (source, displayTitle, displayProductPrices) {
            if (displayTitle === void 0) { displayTitle = true; }
            if (displayProductPrices === void 0) { displayProductPrices = true; }
            var item = {};
            if (displayTitle) {
                item.title = source.name;
            }
            if (displayProductPrices && source.price && source.price.formattedValue) {
                item.price = source.price.formattedValue;
            }
            if (source.images && source.images.PRIMARY) {
                item.media = {
                    container: source.images.PRIMARY,
                    format: 'product',
                };
            }
            item.route = this.semanticPathService.transform({
                cxRoute: 'product',
                params: source,
            });
            return item;
        };
        return ProductCarouselService;
    }());
    ProductCarouselService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductCarouselService, deps: [{ token: i1__namespace.ProductService }, { token: i1__namespace.SemanticPathService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ProductCarouselService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductCarouselService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductCarouselService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace.ProductService }, { type: i1__namespace.SemanticPathService }]; } });

    var ProductCarouselComponent = /** @class */ (function () {
        function ProductCarouselComponent(componentData, productService) {
            var _this = this;
            this.componentData = componentData;
            this.productService = productService;
            this.PRODUCT_SCOPE = "list" /* LIST */;
            this.componentData$ = this.componentData.data$.pipe(operators.filter(Boolean));
            /**
             * returns an Observable string for the title.
             */
            this.title$ = this.componentData$.pipe(operators.map(function (data) { return data.title; }));
            /**
             * Observable that holds an Array of Observables. This is done, so that
             * the component UI could consider to lazy load the UI components when they're
             * in the viewpoint.
             */
            this.items$ = this.componentData$.pipe(operators.map(function (data) { var _a, _b; return (_b = (_a = data.productCodes) === null || _a === void 0 ? void 0 : _a.trim().split(' ')) !== null && _b !== void 0 ? _b : []; }), operators.map(function (codes) { return codes.map(function (code) { return _this.productService.get(code, [_this.PRODUCT_SCOPE, "price" /* PRICE */]); }); }));
        }
        return ProductCarouselComponent;
    }());
    ProductCarouselComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductCarouselComponent, deps: [{ token: CmsComponentData }, { token: i1__namespace.ProductService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    ProductCarouselComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: ProductCarouselComponent, selector: "cx-product-carousel", ngImport: i0__namespace, template: "<cx-carousel\n  [items]=\"items$ | async\"\n  [title]=\"title$ | async\"\n  [template]=\"carouselItem\"\n  itemWidth=\"285px\"\n>\n</cx-carousel>\n\n<ng-template #carouselItem let-item=\"item\">\n  <a tabindex=\"0\" [routerLink]=\"{ cxRoute: 'product', params: item } | cxUrl\">\n    <cx-media\n      [container]=\"item.images?.PRIMARY\"\n      format=\"product\"\n      [alt]=\"item.name\"\n    ></cx-media>\n    <h3>\n      {{ item.name }}\n    </h3>\n    <div class=\"price\">\n      {{ item.price?.formattedValue }}\n    </div>\n  </a>\n</ng-template>\n", components: [{ type: CarouselComponent, selector: "cx-carousel", inputs: ["title", "items", "template", "itemWidth", "hideIndicators", "indicatorIcon", "previousIcon", "nextIcon"] }, { type: MediaComponent, selector: "cx-media", inputs: ["container", "format", "alt", "role", "loading"], outputs: ["loaded"] }], directives: [{ type: i1__namespace$1.RouterLinkWithHref, selector: "a[routerLink],area[routerLink]", inputs: ["routerLink", "target", "queryParams", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange", "replaceUrl", "state", "relativeTo"] }], pipes: { "async": i3__namespace.AsyncPipe, "cxUrl": i1__namespace.UrlPipe }, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductCarouselComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-product-carousel',
                        templateUrl: './product-carousel.component.html',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], ctorParameters: function () { return [{ type: CmsComponentData }, { type: i1__namespace.ProductService }]; } });

    var ProductCarouselModule = /** @class */ (function () {
        function ProductCarouselModule() {
        }
        return ProductCarouselModule;
    }());
    ProductCarouselModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductCarouselModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    ProductCarouselModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductCarouselModule, declarations: [ProductCarouselComponent], imports: [i3.CommonModule, CarouselModule, MediaModule, i1$1.RouterModule, i1.UrlModule], exports: [ProductCarouselComponent] });
    ProductCarouselModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductCarouselModule, providers: [
            i1.provideDefaultConfig({
                cmsComponents: {
                    ProductCarouselComponent: {
                        component: ProductCarouselComponent,
                    },
                },
            }),
        ], imports: [[i3.CommonModule, CarouselModule, MediaModule, i1$1.RouterModule, i1.UrlModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductCarouselModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [i3.CommonModule, CarouselModule, MediaModule, i1$1.RouterModule, i1.UrlModule],
                        providers: [
                            i1.provideDefaultConfig({
                                cmsComponents: {
                                    ProductCarouselComponent: {
                                        component: ProductCarouselComponent,
                                    },
                                },
                            }),
                        ],
                        declarations: [ProductCarouselComponent],
                        exports: [ProductCarouselComponent],
                    }]
            }] });

    var ProductReferencesComponent = /** @class */ (function () {
        function ProductReferencesComponent(cmsComponentData, currentProductService, productReferenceService) {
            var _this = this;
            this.cmsComponentData = cmsComponentData;
            this.currentProductService = currentProductService;
            this.productReferenceService = productReferenceService;
            /**
             * Observable with an Array of Observables. This is done so that
             * the component UI could consider to lazy load the UI components when they're
             * in the viewpoint.
             */
            this.items$ = this.productCode$.pipe(operators.withLatestFrom(this.componentData$), operators.tap(function (_a) {
                var _b = __read(_a, 2), productCode = _b[0], data = _b[1];
                return _this.productReferenceService.loadProductReferences(productCode, data === null || data === void 0 ? void 0 : data.productReferenceTypes);
            }), operators.switchMap(function (_a) {
                var _b = __read(_a, 2), productCode = _b[0], data = _b[1];
                return _this.getProductReferences(productCode, data === null || data === void 0 ? void 0 : data.productReferenceTypes);
            }));
        }
        Object.defineProperty(ProductReferencesComponent.prototype, "componentData$", {
            get: function () {
                return this.cmsComponentData.data$.pipe(operators.filter(Boolean));
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ProductReferencesComponent.prototype, "productCode$", {
            /**
             * Returns an Observable String for the product code
             */
            get: function () {
                var _this = this;
                return this.currentProductService.getProduct().pipe(operators.filter(i1.isNotNullable), operators.map(function (product) { return product.code; }), operators.tap(function (_) { return _this.productReferenceService.cleanReferences(); }));
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ProductReferencesComponent.prototype, "title$", {
            /**
             * Returns an Observable String for the title
             */
            get: function () {
                return this.componentData$.pipe(operators.map(function (data) { return data === null || data === void 0 ? void 0 : data.title; }));
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Returns an observable for product references
         */
        ProductReferencesComponent.prototype.getProductReferences = function (code, referenceType) {
            return this.productReferenceService
                .getProductReferences(code, referenceType)
                .pipe(operators.filter(Boolean), operators.map(function (references) { return references.map(function (reference) { return rxjs.of(reference.target); }); }));
        };
        return ProductReferencesComponent;
    }());
    ProductReferencesComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductReferencesComponent, deps: [{ token: CmsComponentData }, { token: CurrentProductService }, { token: i1__namespace.ProductReferenceService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    ProductReferencesComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: ProductReferencesComponent, selector: "cx-product-references", ngImport: i0__namespace, template: "<cx-carousel\n  [title]=\"title$ | async\"\n  [items]=\"items$ | async\"\n  [template]=\"carouselItem\"\n>\n</cx-carousel>\n\n<ng-template #carouselItem let-item=\"item\">\n  <a tabindex=\"0\" [routerLink]=\"{ cxRoute: 'product', params: item } | cxUrl\">\n    <cx-media [container]=\"item.images?.PRIMARY\" format=\"product\"></cx-media>\n    <h4>{{ item.name }}</h4>\n    <div class=\"price\">{{ item.price?.formattedValue }}</div>\n  </a>\n</ng-template>\n", components: [{ type: CarouselComponent, selector: "cx-carousel", inputs: ["title", "items", "template", "itemWidth", "hideIndicators", "indicatorIcon", "previousIcon", "nextIcon"] }, { type: MediaComponent, selector: "cx-media", inputs: ["container", "format", "alt", "role", "loading"], outputs: ["loaded"] }], directives: [{ type: i1__namespace$1.RouterLinkWithHref, selector: "a[routerLink],area[routerLink]", inputs: ["routerLink", "target", "queryParams", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange", "replaceUrl", "state", "relativeTo"] }], pipes: { "async": i3__namespace.AsyncPipe, "cxUrl": i1__namespace.UrlPipe }, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductReferencesComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-product-references',
                        templateUrl: './product-references.component.html',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], ctorParameters: function () { return [{ type: CmsComponentData }, { type: CurrentProductService }, { type: i1__namespace.ProductReferenceService }]; } });

    var ProductReferencesModule = /** @class */ (function () {
        function ProductReferencesModule() {
        }
        return ProductReferencesModule;
    }());
    ProductReferencesModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductReferencesModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    ProductReferencesModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductReferencesModule, declarations: [ProductReferencesComponent], imports: [i3.CommonModule, CarouselModule, MediaModule, i1$1.RouterModule, i1.UrlModule], exports: [ProductReferencesComponent] });
    ProductReferencesModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductReferencesModule, providers: [
            i1.provideDefaultConfig({
                cmsComponents: {
                    ProductReferencesComponent: {
                        component: ProductReferencesComponent,
                    },
                },
            }),
        ], imports: [[i3.CommonModule, CarouselModule, MediaModule, i1$1.RouterModule, i1.UrlModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductReferencesModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [i3.CommonModule, CarouselModule, MediaModule, i1$1.RouterModule, i1.UrlModule],
                        providers: [
                            i1.provideDefaultConfig({
                                cmsComponents: {
                                    ProductReferencesComponent: {
                                        component: ProductReferencesComponent,
                                    },
                                },
                            }),
                        ],
                        declarations: [ProductReferencesComponent],
                        exports: [ProductReferencesComponent],
                    }]
            }] });

    var defaultViewConfig = {
        view: {
            defaultPageSize: 12,
            infiniteScroll: {
                active: false,
                productLimit: 0,
                showMoreButton: false,
            },
        },
    };

    var ProductImagesComponent = /** @class */ (function () {
        function ProductImagesComponent(currentProductService) {
            var _this = this;
            this.currentProductService = currentProductService;
            this.mainMediaContainer = new rxjs.BehaviorSubject(null);
            this.product$ = this.currentProductService
                .getProduct()
                .pipe(operators.filter(i1.isNotNullable), operators.distinctUntilChanged(), operators.tap(function (p) {
                var _a;
                _this.mainMediaContainer.next(((_a = p.images) === null || _a === void 0 ? void 0 : _a.PRIMARY) ? p.images.PRIMARY : {});
            }));
            this.thumbs$ = this.product$.pipe(operators.map(function (p) { return _this.createThumbs(p); }));
            this.mainImage$ = rxjs.combineLatest([this.product$, this.mainMediaContainer]).pipe(operators.map(function (_b) {
                var _c = __read(_b, 2), container = _c[1];
                return container;
            }));
        }
        ProductImagesComponent.prototype.openImage = function (item) {
            this.mainMediaContainer.next(item);
        };
        ProductImagesComponent.prototype.isActive = function (thumbnail) {
            return this.mainMediaContainer.pipe(operators.filter(Boolean), operators.map(function (container) {
                return (container.zoom &&
                    container.zoom.url &&
                    thumbnail.zoom &&
                    thumbnail.zoom.url &&
                    container.zoom.url === thumbnail.zoom.url);
            }));
        };
        /** find the index of the main media in the list of media */
        ProductImagesComponent.prototype.getActive = function (thumbs) {
            return this.mainMediaContainer.pipe(operators.filter(Boolean), operators.map(function (container) {
                var current = thumbs.find(function (t) { return t.media &&
                    container.zoom &&
                    t.media.container &&
                    t.media.container.zoom &&
                    t.media.container.zoom.url === container.zoom.url; });
                return thumbs.indexOf(current);
            }));
        };
        /**
         * Return an array of CarouselItems for the product thumbnails.
         * In case there are less then 2 thumbs, we return null.
         */
        ProductImagesComponent.prototype.createThumbs = function (product) {
            if (!product.images ||
                !product.images.GALLERY ||
                product.images.GALLERY.length < 2) {
                return [];
            }
            return product.images.GALLERY.map(function (c) { return rxjs.of({ container: c }); });
        };
        return ProductImagesComponent;
    }());
    ProductImagesComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductImagesComponent, deps: [{ token: CurrentProductService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    ProductImagesComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: ProductImagesComponent, selector: "cx-product-images", ngImport: i0__namespace, template: "<ng-container *ngIf=\"mainImage$ | async as main\">\n  <cx-media [container]=\"main\"></cx-media>\n</ng-container>\n\n<ng-container *ngIf=\"thumbs$ | async as thumbs\">\n  <cx-carousel\n    *ngIf=\"thumbs.length\"\n    class=\"thumbs\"\n    [items]=\"thumbs\"\n    itemWidth=\"120px\"\n    [hideIndicators]=\"false\"\n    [template]=\"thumb\"\n  ></cx-carousel>\n</ng-container>\n\n<ng-template #thumb let-item=\"item\">\n  <cx-media\n    [container]=\"item.container\"\n    tabindex=\"0\"\n    (focus)=\"openImage(item.container)\"\n    [class.is-active]=\"isActive(item.container) | async\"\n    format=\"product\"\n  >\n  </cx-media>\n</ng-template>\n", components: [{ type: MediaComponent, selector: "cx-media", inputs: ["container", "format", "alt", "role", "loading"], outputs: ["loaded"] }, { type: CarouselComponent, selector: "cx-carousel", inputs: ["title", "items", "template", "itemWidth", "hideIndicators", "indicatorIcon", "previousIcon", "nextIcon"] }], directives: [{ type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "async": i3__namespace.AsyncPipe }, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductImagesComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-product-images',
                        templateUrl: './product-images.component.html',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], ctorParameters: function () { return [{ type: CurrentProductService }]; } });

    var ProductImagesModule = /** @class */ (function () {
        function ProductImagesModule() {
        }
        return ProductImagesModule;
    }());
    ProductImagesModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductImagesModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    ProductImagesModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductImagesModule, declarations: [ProductImagesComponent], imports: [i3.CommonModule,
            i1$1.RouterModule,
            MediaModule,
            OutletModule,
            CarouselModule], exports: [ProductImagesComponent] });
    ProductImagesModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductImagesModule, providers: [
            i1.provideDefaultConfig({
                cmsComponents: {
                    ProductImagesComponent: {
                        component: ProductImagesComponent,
                    },
                },
            }),
        ], imports: [[
                i3.CommonModule,
                i1$1.RouterModule,
                MediaModule,
                OutletModule,
                CarouselModule,
            ]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductImagesModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [
                            i3.CommonModule,
                            i1$1.RouterModule,
                            MediaModule,
                            OutletModule,
                            CarouselModule,
                        ],
                        providers: [
                            i1.provideDefaultConfig({
                                cmsComponents: {
                                    ProductImagesComponent: {
                                        component: ProductImagesComponent,
                                    },
                                },
                            }),
                        ],
                        declarations: [ProductImagesComponent],
                        exports: [ProductImagesComponent],
                    }]
            }] });

    var ProductIntroComponent = /** @class */ (function () {
        function ProductIntroComponent(currentProductService, translationService, winRef) {
            this.currentProductService = currentProductService;
            this.translationService = translationService;
            this.winRef = winRef;
            this.reviewsTabAvailable = new rxjs.BehaviorSubject(false);
            this.product$ = this.currentProductService.getProduct();
        }
        ProductIntroComponent.prototype.ngAfterContentChecked = function () {
            this.reviewsTabAvailable.next(!!this.getReviewsComponent());
        };
        // Scroll to views component on page and click "Reviews" tab
        ProductIntroComponent.prototype.showReviews = function () {
            var _this = this;
            // Use translated label for Reviews tab reference
            this.translationService
                .translate('TabPanelContainer.tabs.ProductReviewsTabComponent')
                .subscribe(function (reviewsTabLabel) {
                var tabsComponent = _this.getTabsComponent();
                var reviewsTab = _this.getTabByLabel(reviewsTabLabel, tabsComponent);
                var reviewsComponent = _this.getReviewsComponent();
                if (reviewsTab && reviewsComponent) {
                    _this.clickTabIfInactive(reviewsTab);
                    setTimeout(function () { return reviewsComponent.scrollIntoView({ behavior: 'smooth' }); }, 0);
                }
            })
                .unsubscribe();
        };
        // NOTE: Does not currently exists as its own component
        // but part of tabs component. This is likely to change in refactor.
        ProductIntroComponent.prototype.getReviewsComponent = function () {
            return this.winRef.document.querySelector('cx-product-reviews');
        };
        // Get Tabs Component if exists on page
        ProductIntroComponent.prototype.getTabsComponent = function () {
            return this.winRef.document.querySelector('cx-tab-paragraph-container');
        };
        // Click to activate tab if not already active
        ProductIntroComponent.prototype.clickTabIfInactive = function (tab) {
            if (!tab.classList.contains('active') ||
                tab.classList.contains('toggled')) {
                tab.click();
            }
        };
        // Get Tab by label if exists on page
        ProductIntroComponent.prototype.getTabByLabel = function (label, tabsComponent) {
            var e_1, _a;
            if (tabsComponent) {
                // NOTE: Reads through button tags to click on correct tab
                // There may be a better way of doing this now/after refactor
                var tabElements = tabsComponent.getElementsByTagName('button');
                try {
                    // Look through button tab elements until finding tab with label
                    for (var _b = __values(Array.from(tabElements)), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var buttonElement = _c.value;
                        if (buttonElement.innerHTML.includes(label)) {
                            return buttonElement;
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
        };
        return ProductIntroComponent;
    }());
    ProductIntroComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductIntroComponent, deps: [{ token: CurrentProductService }, { token: i1__namespace.TranslationService }, { token: i1__namespace.WindowRef }], target: i0__namespace.ɵɵFactoryTarget.Component });
    ProductIntroComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: ProductIntroComponent, selector: "cx-product-intro", ngImport: i0__namespace, template: "<ng-container *ngIf=\"product$ | async as product\">\n  <div class=\"rating\" *ngIf=\"product.averageRating\">\n    <cx-star-rating [rating]=\"product?.averageRating\"></cx-star-rating>\n\n    <div class=\"count\">({{ product?.numberOfReviews }})</div>\n\n    <button\n      *ngIf=\"reviewsTabAvailable | async\"\n      class=\"btn btn-link cx-action-link\"\n      (click)=\"showReviews()\"\n      [attr.aria-label]=\"\n        'productSummary.showReviewsDetailed'\n          | cxTranslate\n            : {\n                rating: product.averageRating | number: '1.0-1',\n                count: product?.numberOfReviews\n              }\n      \"\n    >\n      {{ 'productSummary.showReviews' | cxTranslate }}\n    </button>\n  </div>\n  <div class=\"rating\" *ngIf=\"!product.averageRating\">\n    {{ 'productDetails.noReviews' | cxTranslate }}\n  </div>\n  <div class=\"code\">\n    {{ 'productSummary.id' | cxTranslate }} {{ product?.code }}\n  </div>\n</ng-container>\n", components: [{ type: StarRatingComponent, selector: "cx-star-rating", inputs: ["disabled", "rating"], outputs: ["change"] }], directives: [{ type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "async": i3__namespace.AsyncPipe, "cxTranslate": i1__namespace.TranslatePipe, "number": i3__namespace.DecimalPipe }, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductIntroComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-product-intro',
                        templateUrl: './product-intro.component.html',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], ctorParameters: function () { return [{ type: CurrentProductService }, { type: i1__namespace.TranslationService }, { type: i1__namespace.WindowRef }]; } });

    var ProductIntroModule = /** @class */ (function () {
        function ProductIntroModule() {
        }
        return ProductIntroModule;
    }());
    ProductIntroModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductIntroModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    ProductIntroModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductIntroModule, declarations: [ProductIntroComponent], imports: [i3.CommonModule, i1.I18nModule, StarRatingModule], exports: [ProductIntroComponent] });
    ProductIntroModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductIntroModule, providers: [
            i1.provideDefaultConfig({
                cmsComponents: {
                    ProductIntroComponent: {
                        component: ProductIntroComponent,
                    },
                },
            }),
        ], imports: [[i3.CommonModule, i1.I18nModule, StarRatingModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductIntroModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [i3.CommonModule, i1.I18nModule, StarRatingModule],
                        providers: [
                            i1.provideDefaultConfig({
                                cmsComponents: {
                                    ProductIntroComponent: {
                                        component: ProductIntroComponent,
                                    },
                                },
                            }),
                        ],
                        declarations: [ProductIntroComponent],
                        exports: [ProductIntroComponent],
                    }]
            }] });

    /**
     * The `ProductListComponentService` is used to search products. The service is used
     * on the Product Listing Page, for listing products and the facet navigation.
     *
     * The service exposes the product search results based on the category and search
     * route parameters. The route parameters are used to query products by the help of
     * the `ProductSearchService`.
     */
    var ProductListComponentService = /** @class */ (function () {
        function ProductListComponentService(productSearchService, routing, activatedRoute, currencyService, languageService, router, config) {
            var _this = this;
            this.productSearchService = productSearchService;
            this.routing = routing;
            this.activatedRoute = activatedRoute;
            this.currencyService = currencyService;
            this.languageService = languageService;
            this.router = router;
            this.config = config;
            this.RELEVANCE_ALLCATEGORIES = ':relevance:allCategories:';
            /**
             * Emits the search results for the current search query.
             *
             * The `searchResults$` is _not_ concerned with querying, it only observes the
             * `productSearchService.getResults()`
             */
            this.searchResults$ = this.productSearchService
                .getResults()
                .pipe(operators.filter(function (searchResult) { return Object.keys(searchResult).length > 0; }));
            /**
             * Observes the route and performs a search on each route change.
             *
             * Context changes, such as language and currencies are also taken
             * into account, so that the search is performed again.
             */
            this.searchByRouting$ = rxjs.combineLatest(__spreadArray([
                this.routing.getRouterState().pipe(operators.distinctUntilChanged(function (x, y) {
                    // router emits new value also when the anticipated `nextState` changes
                    // but we want to perform search only when current url changes
                    return x.state.url === y.state.url;
                }))
            ], __read(this.siteContext))).pipe(operators.debounceTime(0), operators.map(function (_b) {
                var _c = __read(_b), routerState = _c[0], _context = _c.slice(1);
                return routerState.state;
            }), operators.tap(function (state) {
                var criteria = _this.getCriteriaFromRoute(state.params, state.queryParams);
                _this.search(criteria);
            }));
            /**
             * This stream is used for the Product Listing and Product Facets.
             *
             * It not only emits search results, but also performs a search on every change
             * of the route (i.e. route params or query params).
             *
             * When a user leaves the PLP route, the PLP component unsubscribes from this stream
             * so no longer the search is performed on route change.
             */
            this.model$ = rxjs.using(function () { return _this.searchByRouting$.subscribe(); }, function () { return _this.searchResults$; }).pipe(operators.shareReplay({ bufferSize: 1, refCount: true }));
        }
        /**
         * Expose the `SearchCriteria`. The search criteria are driven by the route parameters.
         *
         * This search route configuration is not yet configurable
         * (see https://github.com/SAP/spartacus/issues/7191).
         */
        ProductListComponentService.prototype.getCriteriaFromRoute = function (routeParams, queryParams) {
            var _a;
            return {
                query: queryParams.query || this.getQueryFromRouteParams(routeParams),
                pageSize: queryParams.pageSize || ((_a = this.config.view) === null || _a === void 0 ? void 0 : _a.defaultPageSize),
                currentPage: queryParams.currentPage,
                sortCode: queryParams.sortCode,
            };
        };
        /**
         * Resolves the search query from the given `ProductListRouteParams`.
         */
        ProductListComponentService.prototype.getQueryFromRouteParams = function (_b) {
            var query = _b.query, categoryCode = _b.categoryCode, brandCode = _b.brandCode;
            if (query) {
                return query;
            }
            if (categoryCode) {
                return this.RELEVANCE_ALLCATEGORIES + categoryCode;
            }
            // TODO: drop support for brands as they should be treated
            // similarly as any category.
            if (brandCode) {
                return this.RELEVANCE_ALLCATEGORIES + brandCode;
            }
        };
        /**
         * Performs a search based on the given search criteria.
         *
         * The search is delegated to the `ProductSearchService`.
         */
        ProductListComponentService.prototype.search = function (criteria) {
            var currentPage = criteria.currentPage;
            var pageSize = criteria.pageSize;
            var sort = criteria.sortCode;
            this.productSearchService.search(criteria.query, 
            // TODO: consider dropping this complex passing of cleaned object
            Object.assign({}, currentPage && { currentPage: currentPage }, pageSize && { pageSize: pageSize }, sort && { sort: sort }));
        };
        /**
         * Get items from a given page without using navigation
         */
        ProductListComponentService.prototype.getPageItems = function (pageNumber) {
            var _this = this;
            this.routing
                .getRouterState()
                .subscribe(function (route) {
                var routeCriteria = _this.getCriteriaFromRoute(route.state.params, route.state.queryParams);
                var criteria = Object.assign(Object.assign({}, routeCriteria), { currentPage: pageNumber });
                _this.search(criteria);
            })
                .unsubscribe();
        };
        /**
         * Sort the search results by the given sort code.
         */
        ProductListComponentService.prototype.sort = function (sortCode) {
            this.route({ sortCode: sortCode });
        };
        /**
         * Routes to the next product listing page, using the given `queryParams`. The
         * `queryParams` support sorting, pagination and querying.
         *
         * The `queryParams` are delegated to the Angular router `NavigationExtras`.
         */
        ProductListComponentService.prototype.route = function (queryParams) {
            this.router.navigate([], {
                queryParams: queryParams,
                queryParamsHandling: 'merge',
                relativeTo: this.activatedRoute,
            });
        };
        Object.defineProperty(ProductListComponentService.prototype, "siteContext", {
            /**
             * The site context is used to update the search query in case of a
             * changing context. The context will typically influence the search data.
             *
             * We keep this private for now, as we're likely refactoring this in the next
             * major version.
             */
            get: function () {
                // TODO: we should refactor this so that custom context will be taken
                // into account automatically. Ideally, we drop the specific context
                // from the constructor, and query a ContextService for all contexts.
                return [this.languageService.getActive(), this.currencyService.getActive()];
            },
            enumerable: false,
            configurable: true
        });
        return ProductListComponentService;
    }());
    ProductListComponentService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductListComponentService, deps: [{ token: i1__namespace.ProductSearchService }, { token: i1__namespace.RoutingService }, { token: i1__namespace$1.ActivatedRoute }, { token: i1__namespace.CurrencyService }, { token: i1__namespace.LanguageService }, { token: i1__namespace$1.Router }, { token: ViewConfig }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ProductListComponentService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductListComponentService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductListComponentService, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }], ctorParameters: function () { return [{ type: i1__namespace.ProductSearchService }, { type: i1__namespace.RoutingService }, { type: i1__namespace$1.ActivatedRoute }, { type: i1__namespace.CurrencyService }, { type: i1__namespace.LanguageService }, { type: i1__namespace$1.Router }, { type: ViewConfig }]; } });

    exports.ViewModes = void 0;
    (function (ViewModes) {
        ViewModes["Grid"] = "grid";
        ViewModes["List"] = "list";
    })(exports.ViewModes || (exports.ViewModes = {}));
    var ProductViewComponent = /** @class */ (function () {
        function ProductViewComponent() {
            this.iconTypes = exports.ICON_TYPE;
            this.modeChange = new i0.EventEmitter();
        }
        Object.defineProperty(ProductViewComponent.prototype, "buttonClass", {
            get: function () {
                var viewName = this.viewMode.toLowerCase();
                return "cx-product-" + viewName;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ProductViewComponent.prototype, "viewMode", {
            /**
             *   Display icons inversely to allow users
             *   to see the view they will navigate to
             */
            get: function () {
                if (this.mode === 'list') {
                    return this.iconTypes.GRID;
                }
                else if (this.mode === 'grid') {
                    return this.iconTypes.LIST;
                }
            },
            enumerable: false,
            configurable: true
        });
        ProductViewComponent.prototype.changeMode = function () {
            var newMode = this.mode === exports.ViewModes.Grid ? exports.ViewModes.List : exports.ViewModes.Grid;
            this.modeChange.emit(newMode);
        };
        return ProductViewComponent;
    }());
    ProductViewComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductViewComponent, deps: [], target: i0__namespace.ɵɵFactoryTarget.Component });
    ProductViewComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: ProductViewComponent, selector: "cx-product-view", inputs: { mode: "mode" }, outputs: { modeChange: "modeChange" }, ngImport: i0__namespace, template: "<button\n  class=\"btn cx-product-layout\"\n  [ngClass]=\"buttonClass\"\n  (click)=\"changeMode()\"\n  tabindex=\"0\"\n  attr.aria-label=\"{{\n    viewMode === iconTypes.GRID\n      ? ('productView.gridView' | cxTranslate)\n      : viewMode === iconTypes.LIST\n      ? ('productView.listView' | cxTranslate)\n      : null\n  }}\"\n>\n  <cx-icon\n    *ngIf=\"viewMode === iconTypes.GRID\"\n    [type]=\"iconTypes.GRID\"\n  ></cx-icon>\n  <cx-icon\n    *ngIf=\"viewMode === iconTypes.LIST\"\n    [type]=\"iconTypes.LIST\"\n  ></cx-icon>\n</button>\n", components: [{ type: IconComponent, selector: "cx-icon,[cxIcon]", inputs: ["cxIcon", "type"] }], directives: [{ type: i3__namespace.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "cxTranslate": i1__namespace.TranslatePipe }, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductViewComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-product-view',
                        templateUrl: './product-view.component.html',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], propDecorators: { mode: [{
                    type: i0.Input
                }], modeChange: [{
                    type: i0.Output
                }] } });

    exports.ProductDetailOutlets = void 0;
    (function (ProductDetailOutlets) {
        ProductDetailOutlets["INTRO"] = "PDP.INTRO";
        ProductDetailOutlets["PRICE"] = "PDP.PRICE";
        ProductDetailOutlets["SHARE"] = "PDP.SHARE";
        ProductDetailOutlets["SUMMARY"] = "PDP.SUMMARY";
    })(exports.ProductDetailOutlets || (exports.ProductDetailOutlets = {}));
    exports.ProductListOutlets = void 0;
    (function (ProductListOutlets) {
        ProductListOutlets["ITEM_ACTIONS"] = "cx-product-list-item.actions";
        ProductListOutlets["ITEM_DETAILS"] = "cx-product-list-item.details";
    })(exports.ProductListOutlets || (exports.ProductListOutlets = {}));

    /**
     * Context for `ProductListItemComponent`.
     */
    var ProductListItemContext = /** @class */ (function () {
        function ProductListItemContext() {
        }
        return ProductListItemContext;
    }());
    ProductListItemContext.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductListItemContext, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ProductListItemContext.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductListItemContext });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductListItemContext, decorators: [{
                type: i0.Injectable
            }] });

    /**
     * Context source for `ProductListItemComponent`.
     *
     * `ProductListItemContext` should be injected instead in child components.
     */
    var ProductListItemContextSource = /** @class */ (function (_super) {
        __extends(ProductListItemContextSource, _super);
        function ProductListItemContextSource() {
            var _this = _super.apply(this, __spreadArray([], __read(arguments))) || this;
            _this.product$ = new rxjs.ReplaySubject(1);
            return _this;
        }
        return ProductListItemContextSource;
    }(ProductListItemContext));
    ProductListItemContextSource.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductListItemContextSource, deps: null, target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ProductListItemContextSource.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductListItemContextSource });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductListItemContextSource, decorators: [{
                type: i0.Injectable
            }] });

    var ProductGridItemComponent = /** @class */ (function () {
        function ProductGridItemComponent(productListItemContextSource) {
            this.productListItemContextSource = productListItemContextSource;
            this.ProductListOutlets = exports.ProductListOutlets;
        }
        ProductGridItemComponent.prototype.ngOnChanges = function (changes) {
            if (changes === null || changes === void 0 ? void 0 : changes.product) {
                this.productListItemContextSource.product$.next(this.product);
            }
        };
        return ProductGridItemComponent;
    }());
    ProductGridItemComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductGridItemComponent, deps: [{ token: ProductListItemContextSource }], target: i0__namespace.ɵɵFactoryTarget.Component });
    ProductGridItemComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: ProductGridItemComponent, selector: "cx-product-grid-item", inputs: { product: "product" }, providers: [
            ProductListItemContextSource,
            {
                provide: ProductListItemContext,
                useExisting: ProductListItemContextSource,
            },
        ], usesOnChanges: true, ngImport: i0__namespace, template: "<a\n  [routerLink]=\"{ cxRoute: 'product', params: product } | cxUrl\"\n  class=\"cx-product-image-container\"\n  tabindex=\"-1\"\n>\n  <cx-media\n    class=\"cx-product-image\"\n    [container]=\"product.images?.PRIMARY\"\n    format=\"product\"\n    [alt]=\"product.summary\"\n  ></cx-media>\n</a>\n<a\n  [routerLink]=\"{ cxRoute: 'product', params: product } | cxUrl\"\n  class=\"cx-product-name\"\n  [innerHTML]=\"product.nameHtml\"\n></a>\n\n<ng-template [cxOutlet]=\"ProductListOutlets.ITEM_DETAILS\">\n  <div class=\"cx-product-rating\">\n    <cx-star-rating\n      *ngIf=\"product.averageRating\"\n      [rating]=\"product?.averageRating\"\n    ></cx-star-rating>\n    <div *ngIf=\"!product.averageRating\">\n      {{ 'productDetails.noReviews' | cxTranslate }}\n    </div>\n  </div>\n  <div class=\"cx-product-price-container\">\n    <div\n      class=\"cx-product-price\"\n      [attr.aria-label]=\"'productDetails.productPrice' | cxTranslate\"\n    >\n      {{ product.price?.formattedValue }}\n    </div>\n  </div>\n</ng-template>\n\n<ng-template [cxOutlet]=\"ProductListOutlets.ITEM_ACTIONS\">\n  <cx-add-to-cart\n    *ngIf=\"product.stock?.stockLevelStatus !== 'outOfStock'\"\n    [showQuantity]=\"false\"\n    [product]=\"product\"\n  ></cx-add-to-cart>\n</ng-template>\n", components: [{ type: MediaComponent, selector: "cx-media", inputs: ["container", "format", "alt", "role", "loading"], outputs: ["loaded"] }, { type: StarRatingComponent, selector: "cx-star-rating", inputs: ["disabled", "rating"], outputs: ["change"] }, { type: AddToCartComponent, selector: "cx-add-to-cart", inputs: ["productCode", "showQuantity", "product"] }], directives: [{ type: i1__namespace$1.RouterLinkWithHref, selector: "a[routerLink],area[routerLink]", inputs: ["routerLink", "target", "queryParams", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange", "replaceUrl", "state", "relativeTo"] }, { type: OutletDirective, selector: "[cxOutlet]", inputs: ["cxOutlet", "cxOutletContext", "cxOutletDefer"], outputs: ["loaded"] }, { type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "cxUrl": i1__namespace.UrlPipe, "cxTranslate": i1__namespace.TranslatePipe }, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductGridItemComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-product-grid-item',
                        templateUrl: './product-grid-item.component.html',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        providers: [
                            ProductListItemContextSource,
                            {
                                provide: ProductListItemContext,
                                useExisting: ProductListItemContextSource,
                            },
                        ],
                    }]
            }], ctorParameters: function () { return [{ type: ProductListItemContextSource }]; }, propDecorators: { product: [{
                    type: i0.Input
                }] } });

    var ProductListItemComponent = /** @class */ (function () {
        function ProductListItemComponent(productListItemContextSource) {
            this.productListItemContextSource = productListItemContextSource;
            this.ProductListOutlets = exports.ProductListOutlets;
        }
        ProductListItemComponent.prototype.ngOnChanges = function (changes) {
            if (changes === null || changes === void 0 ? void 0 : changes.product) {
                this.productListItemContextSource.product$.next(this.product);
            }
        };
        return ProductListItemComponent;
    }());
    ProductListItemComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductListItemComponent, deps: [{ token: ProductListItemContextSource }], target: i0__namespace.ɵɵFactoryTarget.Component });
    ProductListItemComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: ProductListItemComponent, selector: "cx-product-list-item", inputs: { product: "product" }, providers: [
            ProductListItemContextSource,
            {
                provide: ProductListItemContext,
                useExisting: ProductListItemContextSource,
            },
        ], usesOnChanges: true, ngImport: i0__namespace, template: "<div class=\"row\">\n  <div class=\"col-12 col-md-4\">\n    <a\n      [routerLink]=\"{ cxRoute: 'product', params: product } | cxUrl\"\n      class=\"cx-product-image-container\"\n      tabindex=\"-1\"\n    >\n      <cx-media\n        class=\"cx-product-image\"\n        [container]=\"product.images?.PRIMARY\"\n        format=\"product\"\n        [alt]=\"product.summary\"\n      ></cx-media>\n    </a>\n  </div>\n  <div class=\"col-12 col-md-8\">\n    <a\n      [routerLink]=\"{ cxRoute: 'product', params: product } | cxUrl\"\n      class=\"cx-product-name\"\n    >\n      <h2 [innerHtml]=\"product.nameHtml\"></h2>\n    </a>\n\n    <ng-template [cxOutlet]=\"ProductListOutlets.ITEM_DETAILS\">\n      <cx-star-rating\n        *ngIf=\"product.averageRating\"\n        [rating]=\"product?.averageRating\"\n      ></cx-star-rating>\n      <div *ngIf=\"!product.averageRating\" class=\"cx-product-no-review\">\n        {{ 'productDetails.noReviews' | cxTranslate }}\n      </div>\n      <div\n        class=\"cx-product-price\"\n        [attr.aria-label]=\"'productDetails.productPrice' | cxTranslate\"\n      >\n        {{ product.price?.formattedValue }}\n      </div>\n    </ng-template>\n\n    <div class=\"row\">\n      <div class=\"col-12 col-md-8\">\n        <p class=\"cx-product-summary\" [innerHtml]=\"product.summary\">\n          {{ product.summary }}\n        </p>\n      </div>\n      <div class=\"col-12 col-md-4\">\n        <ng-template [cxOutlet]=\"ProductListOutlets.ITEM_ACTIONS\">\n          <cx-add-to-cart\n            *ngIf=\"product.stock?.stockLevelStatus !== 'outOfStock'\"\n            [showQuantity]=\"false\"\n            [product]=\"product\"\n          ></cx-add-to-cart>\n        </ng-template>\n      </div>\n    </div>\n  </div>\n</div>\n", components: [{ type: MediaComponent, selector: "cx-media", inputs: ["container", "format", "alt", "role", "loading"], outputs: ["loaded"] }, { type: StarRatingComponent, selector: "cx-star-rating", inputs: ["disabled", "rating"], outputs: ["change"] }, { type: AddToCartComponent, selector: "cx-add-to-cart", inputs: ["productCode", "showQuantity", "product"] }], directives: [{ type: i1__namespace$1.RouterLinkWithHref, selector: "a[routerLink],area[routerLink]", inputs: ["routerLink", "target", "queryParams", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange", "replaceUrl", "state", "relativeTo"] }, { type: OutletDirective, selector: "[cxOutlet]", inputs: ["cxOutlet", "cxOutletContext", "cxOutletDefer"], outputs: ["loaded"] }, { type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "cxUrl": i1__namespace.UrlPipe, "cxTranslate": i1__namespace.TranslatePipe }, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductListItemComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-product-list-item',
                        templateUrl: './product-list-item.component.html',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        providers: [
                            ProductListItemContextSource,
                            {
                                provide: ProductListItemContext,
                                useExisting: ProductListItemContextSource,
                            },
                        ],
                    }]
            }], ctorParameters: function () { return [{ type: ProductListItemContextSource }]; }, propDecorators: { product: [{
                    type: i0.Input
                }] } });

    var ProductScrollComponent = /** @class */ (function () {
        function ProductScrollComponent(productListComponentService, ref) {
            this.productListComponentService = productListComponentService;
            this.ref = ref;
            this.subscription = new rxjs.Subscription();
            this.ViewModes = exports.ViewModes;
            this.appendProducts = false;
            this.resetList = false;
            this.isMaxProducts = false;
            this.isLastPage = false;
            this.isEmpty = false;
        }
        Object.defineProperty(ProductScrollComponent.prototype, "setConfig", {
            set: function (inputConfig) {
                this.setComponentConfigurations(inputConfig);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ProductScrollComponent.prototype, "setModel", {
            set: function (inputModel) {
                this.infiniteScrollOperations(inputModel);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ProductScrollComponent.prototype, "setViewMode", {
            set: function (inputViewMode) {
                this.inputViewMode = inputViewMode;
                //If viewMode is already set (meaning it is not the first load)
                //Reset the product list
                if (this.viewMode) {
                    this.resetListOnViewModeChange();
                }
                else {
                    //If viewMode is not set (meaning it is the first load)
                    //Set the viewMode
                    this.viewMode = inputViewMode;
                }
            },
            enumerable: false,
            configurable: true
        });
        ProductScrollComponent.prototype.scrollPage = function (pageNumber) {
            this.appendProducts = true;
            this.ref.markForCheck();
            this.productListComponentService.getPageItems(pageNumber);
        };
        ProductScrollComponent.prototype.loadNextPage = function (pageNumber) {
            this.isMaxProducts = false;
            this.scrollPage(pageNumber);
        };
        ProductScrollComponent.prototype.scrollToTop = function () {
            window.scroll(0, 0);
        };
        ProductScrollComponent.prototype.setComponentConfigurations = function (scrollConfig) {
            var _a, _b, _c, _d;
            var isButton = (_b = (_a = scrollConfig.view) === null || _a === void 0 ? void 0 : _a.infiniteScroll) === null || _b === void 0 ? void 0 : _b.showMoreButton;
            var configProductLimit = (_d = (_c = scrollConfig.view) === null || _c === void 0 ? void 0 : _c.infiniteScroll) === null || _d === void 0 ? void 0 : _d.productLimit;
            //Display "show more" button every time when button configuration is true
            //Otherwise, only display "show more" when the configuration product limit is reached
            this.productLimit = isButton ? 1 : configProductLimit;
        };
        ProductScrollComponent.prototype.infiniteScrollOperations = function (inputModel) {
            if (this.appendProducts) {
                this.model = Object.assign(Object.assign({}, inputModel), { products: this.model.products.concat(inputModel.products) });
            }
            else {
                this.model = inputModel;
                this.maxProducts = this.productLimit;
            }
            this.setConditions();
            this.ref.markForCheck();
        };
        ProductScrollComponent.prototype.resetListOnViewModeChange = function () {
            this.scrollToTop();
            this.resetList = true;
            this.productListComponentService.getPageItems(0);
        };
        //Set booleans after model has been retrieved
        ProductScrollComponent.prototype.setConditions = function () {
            this.isEmpty = !this.model.products || this.model.products.length === 0;
            this.isLastPage =
                this.model.pagination.currentPage ===
                    this.model.pagination.totalPages - 1;
            this.isMaxProducts =
                this.productLimit &&
                    this.productLimit !== 0 &&
                    this.model.products.length >= this.maxProducts;
            //Add the productLimit to the current number of products to determine the next max number of products
            if (this.isMaxProducts) {
                this.maxProducts = this.model.products.length + this.productLimit;
            }
            //Only change viewMode once the new model is set
            //This prevents flickering issues
            if (this.viewMode !== this.inputViewMode) {
                this.viewMode = this.inputViewMode;
            }
            this.resetList = false;
            this.appendProducts = false;
        };
        ProductScrollComponent.prototype.ngOnDestroy = function () {
            this.subscription.unsubscribe();
        };
        return ProductScrollComponent;
    }());
    ProductScrollComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductScrollComponent, deps: [{ token: ProductListComponentService }, { token: i0__namespace.ChangeDetectorRef }], target: i0__namespace.ɵɵFactoryTarget.Component });
    ProductScrollComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: ProductScrollComponent, selector: "cx-product-scroll", inputs: { setConfig: ["scrollConfig", "setConfig"], setModel: ["model", "setModel"], setViewMode: ["inputViewMode", "setViewMode"] }, ngImport: i0__namespace, template: "<ng-container *ngIf=\"viewMode === ViewModes.Grid\">\n  <div\n    infiniteScroll\n    [infiniteScrollDistance]=\"5\"\n    [infiniteScrollThrottle]=\"50\"\n    [infiniteScrollDisabled]=\"isMaxProducts || isLastPage || isEmpty\"\n    (scrolled)=\"scrollPage(model?.pagination?.currentPage + 1)\"\n  >\n    <div class=\"row\">\n      <cx-product-grid-item\n        *ngFor=\"let product of model?.products\"\n        [product]=\"product\"\n        class=\"col-12 col-sm-6 col-md-4\"\n      ></cx-product-grid-item>\n    </div>\n    <div\n      [className]=\"\n        !isLastPage && model?.pagination?.currentPage > 0\n          ? 'cx-double-btn-container grid-btn-padding'\n          : 'cx-single-btn-container grid-btn-padding'\n      \"\n    >\n      <div\n        *ngIf=\"\n          (isMaxProducts || isLastPage) && model?.pagination?.currentPage > 0\n        \"\n        (click)=\"scrollToTop()\"\n        class=\"btn btn-block btn-action\"\n      >\n        {{ 'productList.backToTopBtn' | cxTranslate }}\n      </div>\n      <div\n        *ngIf=\"isMaxProducts && !isLastPage\"\n        (click)=\"loadNextPage(model?.pagination?.currentPage + 1)\"\n        class=\"btn btn-block btn-action align-btn\"\n      >\n        {{ 'productList.showMoreBtn' | cxTranslate }}\n      </div>\n    </div>\n    <div *ngIf=\"appendProducts\" class=\"cx-spinner\">\n      <cx-spinner></cx-spinner>\n    </div>\n  </div>\n</ng-container>\n\n<ng-container *ngIf=\"viewMode === ViewModes.List\">\n  <div\n    infiniteScroll\n    [infiniteScrollDistance]=\"3\"\n    [infiniteScrollThrottle]=\"50\"\n    [infiniteScrollDisabled]=\"isMaxProducts || isLastPage || isEmpty\"\n    (scrolled)=\"scrollPage(model?.pagination?.currentPage + 1)\"\n  >\n    <cx-product-list-item\n      *ngFor=\"let product of model?.products\"\n      [product]=\"product\"\n      class=\"cx-product-search-list\"\n    ></cx-product-list-item>\n    <div\n      [className]=\"\n        !isLastPage && model?.pagination?.currentPage > 0\n          ? 'cx-double-btn-container'\n          : 'cx-single-btn-container'\n      \"\n    >\n      <div\n        *ngIf=\"\n          (isMaxProducts || isLastPage) && model?.pagination?.currentPage > 0\n        \"\n        (click)=\"scrollToTop()\"\n        class=\"btn btn-block btn-action\"\n      >\n        {{ 'productList.backToTopBtn' | cxTranslate }}\n      </div>\n      <div\n        *ngIf=\"isMaxProducts && !isLastPage\"\n        (click)=\"loadNextPage(model?.pagination?.currentPage + 1)\"\n        class=\"btn btn-block btn-action align-btn\"\n      >\n        {{ 'productList.showMoreBtn' | cxTranslate }}\n      </div>\n    </div>\n    <div *ngIf=\"appendProducts\" class=\"cx-spinner\">\n      <cx-spinner></cx-spinner>\n    </div>\n  </div>\n</ng-container>\n", components: [{ type: ProductGridItemComponent, selector: "cx-product-grid-item", inputs: ["product"] }, { type: SpinnerComponent, selector: "cx-spinner" }, { type: ProductListItemComponent, selector: "cx-product-list-item", inputs: ["product"] }], directives: [{ type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i6__namespace.InfiniteScrollDirective, selector: "[infiniteScroll], [infinite-scroll], [data-infinite-scroll]", inputs: ["infiniteScrollDistance", "infiniteScrollUpDistance", "infiniteScrollThrottle", "infiniteScrollDisabled", "infiniteScrollContainer", "scrollWindow", "immediateCheck", "horizontal", "alwaysCallback", "fromRoot"], outputs: ["scrolled", "scrolledUp"] }, { type: i3__namespace.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], pipes: { "cxTranslate": i1__namespace.TranslatePipe } });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductScrollComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-product-scroll',
                        templateUrl: './product-scroll.component.html',
                    }]
            }], ctorParameters: function () { return [{ type: ProductListComponentService }, { type: i0__namespace.ChangeDetectorRef }]; }, propDecorators: { setConfig: [{
                    type: i0.Input,
                    args: ['scrollConfig']
                }], setModel: [{
                    type: i0.Input,
                    args: ['model']
                }], setViewMode: [{
                    type: i0.Input,
                    args: ['inputViewMode']
                }] } });

    var ProductListComponent = /** @class */ (function () {
        function ProductListComponent(pageLayoutService, productListComponentService, scrollConfig) {
            this.pageLayoutService = pageLayoutService;
            this.productListComponentService = productListComponentService;
            this.scrollConfig = scrollConfig;
            this.subscription = new rxjs.Subscription();
            this.model$ = this.productListComponentService.model$;
            this.viewMode$ = new rxjs.BehaviorSubject(exports.ViewModes.Grid);
            this.ViewModes = exports.ViewModes;
        }
        ProductListComponent.prototype.ngOnInit = function () {
            var _this = this;
            var _a, _b;
            this.isInfiniteScroll = (_b = (_a = this.scrollConfig.view) === null || _a === void 0 ? void 0 : _a.infiniteScroll) === null || _b === void 0 ? void 0 : _b.active;
            this.subscription.add(this.pageLayoutService.templateName$
                .pipe(operators.take(1))
                .subscribe(function (template) {
                _this.viewMode$.next(template === 'ProductGridPageTemplate'
                    ? exports.ViewModes.Grid
                    : exports.ViewModes.List);
            }));
        };
        ProductListComponent.prototype.sortList = function (sortCode) {
            this.productListComponentService.sort(sortCode);
        };
        ProductListComponent.prototype.setViewMode = function (mode) {
            this.viewMode$.next(mode);
        };
        ProductListComponent.prototype.ngOnDestroy = function () {
            this.subscription.unsubscribe();
        };
        return ProductListComponent;
    }());
    ProductListComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductListComponent, deps: [{ token: PageLayoutService }, { token: ProductListComponentService }, { token: ViewConfig }], target: i0__namespace.ɵɵFactoryTarget.Component });
    ProductListComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: ProductListComponent, selector: "cx-product-list", ngImport: i0__namespace, template: "<div class=\"cx-page\" *ngIf=\"model$ | async as model\">\n  <section class=\"cx-page-section\">\n    <div class=\"container\">\n      <div class=\"row\">\n        <div class=\"col-12 col-lg-12\" *ngIf=\"viewMode$ | async as viewMode\">\n          <div class=\"cx-sorting top\">\n            <div class=\"row\">\n              <label\n                class=\"form-group cx-sort-dropdown col-12 col-lg-4 mr-auto\"\n              >\n                <span>{{ 'productList.sortBy' | cxTranslate }}</span>\n                <cx-sorting\n                  [sortOptions]=\"model.sorts\"\n                  (sortListEvent)=\"sortList($event)\"\n                  [selectedOption]=\"model.pagination.sort\"\n                  placeholder=\"{{ 'productList.sortBy' | cxTranslate }}\"\n                ></cx-sorting>\n              </label>\n              <div *ngIf=\"!isInfiniteScroll\" class=\"col-auto\">\n                <div\n                  class=\"cx-pagination\"\n                  [attr.aria-label]=\"\n                    'productList.productSearchPagination' | cxTranslate\n                  \"\n                >\n                  <cx-pagination\n                    [pagination]=\"model.pagination\"\n                    queryParam=\"currentPage\"\n                    [defaultPage]=\"0\"\n                  ></cx-pagination>\n                </div>\n              </div>\n              <div class=\"col-auto ml-auto ml-lg-0\">\n                <cx-product-view\n                  (modeChange)=\"setViewMode($event)\"\n                  [mode]=\"viewMode\"\n                ></cx-product-view>\n              </div>\n            </div>\n          </div>\n          <div class=\"cx-product-container\">\n            <!-- Product list when using pagination -->\n            <ng-container *ngIf=\"!isInfiniteScroll; else infiniteScroll\">\n              <ng-container *ngIf=\"viewMode === ViewModes.Grid\">\n                <div class=\"row\">\n                  <cx-product-grid-item\n                    *ngFor=\"let product of model?.products\"\n                    [product]=\"product\"\n                    class=\"col-12 col-sm-6 col-md-4\"\n                  ></cx-product-grid-item>\n                </div>\n              </ng-container>\n\n              <ng-container *ngIf=\"viewMode === ViewModes.List\">\n                <cx-product-list-item\n                  *ngFor=\"let product of model?.products\"\n                  [product]=\"product\"\n                  class=\"cx-product-search-list\"\n                ></cx-product-list-item>\n              </ng-container>\n            </ng-container>\n\n            <!-- Product list when using infinite scroll -->\n            <ng-template #infiniteScroll>\n              <cx-product-scroll\n                [scrollConfig]=\"scrollConfig\"\n                [model]=\"model\"\n                [inputViewMode]=\"viewMode\"\n              ></cx-product-scroll>\n            </ng-template>\n          </div>\n          <div class=\"cx-sorting bottom\">\n            <div class=\"row\">\n              <label\n                class=\"form-group cx-sort-dropdown col-12 col-lg-4 mr-auto\"\n              >\n                <span>{{ 'productList.sortBy' | cxTranslate }}</span>\n                <cx-sorting\n                  [sortOptions]=\"model.sorts\"\n                  (sortListEvent)=\"sortList($event)\"\n                  [selectedOption]=\"model.pagination.sort\"\n                  placeholder=\"{{ 'productList.sortBy' | cxTranslate }}\"\n                ></cx-sorting>\n              </label>\n              <div\n                *ngIf=\"!isInfiniteScroll\"\n                class=\"col-auto\"\n                [attr.aria-label]=\"\n                  'productList.productSearchPagination' | cxTranslate\n                \"\n              >\n                <div class=\"cx-pagination\">\n                  <cx-pagination\n                    [pagination]=\"model.pagination\"\n                    queryParam=\"currentPage\"\n                    [defaultPage]=\"0\"\n                  ></cx-pagination>\n                </div>\n              </div>\n              <div class=\"col-auto ml-auto ml-lg-0\">\n                <cx-product-view\n                  (modeChange)=\"setViewMode($event)\"\n                  [mode]=\"viewMode\"\n                ></cx-product-view>\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n  </section>\n</div>\n", components: [{ type: SortingComponent, selector: "cx-sorting", inputs: ["sortOptions", "selectedOption", "placeholder", "sortLabels"], outputs: ["sortListEvent"] }, { type: PaginationComponent, selector: "cx-pagination", inputs: ["pageRoute", "queryParam", "defaultPage", "pagination"], outputs: ["viewPageEvent"] }, { type: ProductViewComponent, selector: "cx-product-view", inputs: ["mode"], outputs: ["modeChange"] }, { type: ProductGridItemComponent, selector: "cx-product-grid-item", inputs: ["product"] }, { type: ProductListItemComponent, selector: "cx-product-list-item", inputs: ["product"] }, { type: ProductScrollComponent, selector: "cx-product-scroll", inputs: ["scrollConfig", "model", "inputViewMode"] }], directives: [{ type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3__namespace.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], pipes: { "async": i3__namespace.AsyncPipe, "cxTranslate": i1__namespace.TranslatePipe } });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductListComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-product-list',
                        templateUrl: './product-list.component.html',
                    }]
            }], ctorParameters: function () { return [{ type: PageLayoutService }, { type: ProductListComponentService }, { type: ViewConfig }]; } });

    exports.FacetGroupCollapsedState = void 0;
    (function (FacetGroupCollapsedState) {
        FacetGroupCollapsedState["EXPANDED"] = "EXPANDED";
        FacetGroupCollapsedState["COLLAPSED"] = "COLLAPSED";
    })(exports.FacetGroupCollapsedState || (exports.FacetGroupCollapsedState = {}));

    /**
     * Provides access to all the facets and active facets for the Product Listing Page.
     */
    var ProductFacetService = /** @class */ (function () {
        function ProductFacetService(routing, productListComponentService) {
            var _this = this;
            this.routing = routing;
            this.productListComponentService = productListComponentService;
            this.routeState$ = this.routing
                .getRouterState()
                .pipe(operators.pluck('state'));
            /**
             * Returns the search results for the current page.
             */
            this.searchResult$ = this.routeState$.pipe(operators.switchMap(function (state) { return _this.productListComponentService.model$.pipe(operators.filter(function (page) { return _this.filterForPage(state, page); }), operators.map(function (page) {
                var _a;
                return (Object.assign(Object.assign({}, page), { breadcrumbs: _this.filterBreadcrumbs((_a = page === null || page === void 0 ? void 0 : page.breadcrumbs) !== null && _a !== void 0 ? _a : [], state.params) }));
            })); }));
            /**
             * Observes the facets and active facets for the given page. The facet data
             * is provided in a `FacetList`.
             */
            this.facetList$ = this.searchResult$.pipe(operators.map(function (result) { return ({
                facets: result.facets,
                activeFacets: result.breadcrumbs,
            }); }));
        }
        /**
         * Filters the current result by verifying if the result is related to the page.
         * This is done to avoid a combination of the next page and the current search results.
         */
        ProductFacetService.prototype.filterForPage = function (state, page) {
            var _a, _b;
            if (!((_b = (_a = page.currentQuery) === null || _a === void 0 ? void 0 : _a.query) === null || _b === void 0 ? void 0 : _b.value)) {
                return false;
            }
            if (state.context.type === i1.PageType.CATEGORY_PAGE) {
                return (page.currentQuery.query.value.indexOf("allCategories:" + state.context.id) > -1);
            }
            if (state.context.type === i1.PageType.CONTENT_PAGE &&
                state.context.id === 'search') {
                return page.currentQuery.query.value.startsWith(state.params.query + ":");
            }
            return false;
        };
        /**
         * Filter breadcrumbs which are not actively selected but coming from
         * the route navigation.
         *
         * The breadcrumbs might include the active category page code, which is not actively
         * selected by the user.
         */
        ProductFacetService.prototype.filterBreadcrumbs = function (breadcrumbs, params) {
            return breadcrumbs
                ? breadcrumbs.filter(function (breadcrumb) { return !(breadcrumb.facetCode === 'allCategories' &&
                    (breadcrumb.facetValueCode === params.categoryCode ||
                        breadcrumb.facetValueCode === params.brandCode)); })
                : [];
        };
        return ProductFacetService;
    }());
    ProductFacetService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductFacetService, deps: [{ token: i1__namespace.RoutingService }, { token: ProductListComponentService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ProductFacetService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductFacetService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductFacetService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace.RoutingService }, { type: ProductListComponentService }]; } });

    /**
     * Provides access to the facets as well as their UI state. The UI state
     * represents user related changes on the facets, such as expanding or
     * collapsing a facet group or expanding the number of _visible_ facet values.
     */
    var FacetService = /** @class */ (function () {
        function FacetService(productFacetService) {
            var _this = this;
            this.productFacetService = productFacetService;
            /**
             * An internal map where we keep the UI state of the facets.
             */
            this.facetState = new Map();
            /**
             * Observes the facets for the given page and configures the initial UI state.
             *
             * Facets are configured on each emission so that we keep the facet UI state.
             * This is mainly done to keep the state during usage of the facet, but also
             * benefitial when the facets are rebuild while using them.
             */
            this.facetList$ = this.productFacetService.facetList$.pipe(operators.tap(function (facetList) {
                facetList.facets.forEach(function (facet) { return _this.initialize(facet); });
            }));
        }
        /**
         * Returns the observed UI state for the facet.
         *
         * The state is initialized using the `initialize` method.
         */
        FacetService.prototype.getState = function (facet) {
            this.initialize(facet);
            return this.facetState.get(facet.name);
        };
        /**
         * Returns the UI state for the facet.
         *
         * The state is initialized using the `initialize` method.
         */
        FacetService.prototype.getStateSnapshot = function (facet) {
            return this.getState(facet).value;
        };
        /**
         * Toggles the facet expanded state. If the expanded state becomes false,
         * the visible values will decrease to the top values only.
         *
         * If the optional value argument is provided the expanded state will be set
         * to this value, regardless of the current `expanded` state.
         */
        FacetService.prototype.toggle = function (facet, isExpanded) {
            var state = this.getStateSnapshot(facet);
            var toggledState = {
                toggled: isExpanded
                    ? exports.FacetGroupCollapsedState.COLLAPSED
                    : exports.FacetGroupCollapsedState.EXPANDED,
            };
            if (toggledState.toggled === exports.FacetGroupCollapsedState.COLLAPSED) {
                toggledState.maxVisible = state.topVisible;
            }
            this.updateState(facet, toggledState);
        };
        /**
         * Increases the visible values to the maximum values of the facet.
         */
        FacetService.prototype.increaseVisibleValues = function (facet) {
            this.updateState(facet, { maxVisible: facet.values.length });
        };
        /**
         * Decreases the visible values to the topValueCount.
         *
         * The topValueCount defaults to 6, but can be controlled in
         * the backend as well.
         */
        FacetService.prototype.decreaseVisibleValues = function (facet) {
            this.updateState(facet, { maxVisible: facet.topValueCount });
        };
        /**
         * Persists the facet state and initializes the default values for the top
         * and max visible values.
         */
        FacetService.prototype.initialize = function (facet) {
            var _a;
            var topFacets = facet.topValueCount > 0 ? facet.topValueCount : ((_a = facet.values) === null || _a === void 0 ? void 0 : _a.length) || 0;
            if (!this.hasState(facet)) {
                this.facetState.set(facet.name, new rxjs.BehaviorSubject({
                    topVisible: topFacets,
                    maxVisible: topFacets,
                }));
            }
        };
        /**
         * Updates the state of the facet in the local facet map.
         */
        FacetService.prototype.updateState = function (facet, property) {
            var state = Object.assign(Object.assign({}, this.getStateSnapshot(facet)), property);
            this.facetState.get(facet.name).next(state);
        };
        FacetService.prototype.hasState = function (facet) {
            return this.facetState.has(facet.name);
        };
        FacetService.prototype.getLinkParams = function (query) {
            return {
                // to avoid encoding issues with facets that have space (' ') in their name,
                // we replace the decoded '+' back to empty space ' '.
                // For more, see https://github.com/SAP/spartacus/issues/7348
                query: new http.HttpUrlEncodingCodec().decodeValue(query).replace(/\+/g, ' '),
            };
        };
        return FacetService;
    }());
    FacetService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: FacetService, deps: [{ token: ProductFacetService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    FacetService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: FacetService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: FacetService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: ProductFacetService }]; } });

    /**
     * Active facets render the applied facet values as a list of focusable buttons
     * which can be used to remove the applied facet value.
     */
    var ActiveFacetsComponent = /** @class */ (function () {
        function ActiveFacetsComponent(facetService) {
            this.facetService = facetService;
            /** Active facets which are applied to the product results. */
            this.facetList$ = this.facetService.facetList$;
            /** Configurable icon which is used for the active facet close button */
            this.closeIcon = exports.ICON_TYPE.CLOSE;
        }
        ActiveFacetsComponent.prototype.getLinkParams = function (facet) {
            var _a, _b;
            return this.facetService.getLinkParams((_b = (_a = facet.removeQuery) === null || _a === void 0 ? void 0 : _a.query) === null || _b === void 0 ? void 0 : _b.value);
        };
        /**
         * The focus key is used to persist the focus on the facet when the DOM is being
         * recreated. We only apply the focus key for the given _active_ facet when there
         * the original facets is not available. This happens for non multi-valued facets.
         *
         * With this approach, the we keep the focus, either at the facet list or on the
         * active facets.
         */
        ActiveFacetsComponent.prototype.getFocusKey = function (facetList, facet) {
            var _a;
            return ((_a = facetList.facets) === null || _a === void 0 ? void 0 : _a.find(function (f) { var _a; return (_a = f.values) === null || _a === void 0 ? void 0 : _a.find(function (val) { return val.name === facet.facetValueName; }); }))
                ? ''
                : facet.facetValueName;
        };
        return ActiveFacetsComponent;
    }());
    ActiveFacetsComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ActiveFacetsComponent, deps: [{ token: FacetService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    ActiveFacetsComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: ActiveFacetsComponent, selector: "cx-active-facets", inputs: { closeIcon: "closeIcon" }, ngImport: i0__namespace, template: "<ng-container *ngIf=\"facetList$ | async as facetList\">\n  <h4 *ngIf=\"facetList?.activeFacets?.length > 0\">\n    {{ 'productList.appliedFilter' | cxTranslate }}\n  </h4>\n\n  <a\n    *ngFor=\"let facet of facetList?.activeFacets\"\n    routerLink=\"./\"\n    [queryParams]=\"getLinkParams(facet)\"\n    [cxFocus]=\"getFocusKey(facetList, facet)\"\n  >\n    <span>{{ facet.facetValueName }}</span>\n    <cx-icon aria-hidden=\"true\" [type]=\"closeIcon\"></cx-icon>\n  </a>\n</ng-container>\n", components: [{ type: IconComponent, selector: "cx-icon,[cxIcon]", inputs: ["cxIcon", "type"] }], directives: [{ type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3__namespace.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i1__namespace$1.RouterLinkWithHref, selector: "a[routerLink],area[routerLink]", inputs: ["routerLink", "target", "queryParams", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange", "replaceUrl", "state", "relativeTo"] }, { type: FocusDirective, selector: "[cxFocus]", inputs: ["cxFocus"] }], pipes: { "async": i3__namespace.AsyncPipe, "cxTranslate": i1__namespace.TranslatePipe }, changeDetection: i0__namespace.ChangeDetectionStrategy.Default });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ActiveFacetsComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-active-facets',
                        templateUrl: './active-facets.component.html',
                        changeDetection: i0.ChangeDetectionStrategy.Default,
                    }]
            }], ctorParameters: function () { return [{ type: FacetService }]; }, propDecorators: { closeIcon: [{
                    type: i0.Input
                }] } });

    var ActiveFacetsModule = /** @class */ (function () {
        function ActiveFacetsModule() {
        }
        return ActiveFacetsModule;
    }());
    ActiveFacetsModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ActiveFacetsModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    ActiveFacetsModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ActiveFacetsModule, declarations: [ActiveFacetsComponent], imports: [i3.CommonModule,
            i1$1.RouterModule,
            i1.I18nModule,
            IconModule,
            KeyboardFocusModule], exports: [ActiveFacetsComponent] });
    ActiveFacetsModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ActiveFacetsModule, imports: [[
                i3.CommonModule,
                i1$1.RouterModule,
                i1.I18nModule,
                IconModule,
                KeyboardFocusModule,
            ]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ActiveFacetsModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [
                            i3.CommonModule,
                            i1$1.RouterModule,
                            i1.I18nModule,
                            IconModule,
                            KeyboardFocusModule,
                        ],
                        declarations: [ActiveFacetsComponent],
                        exports: [ActiveFacetsComponent],
                    }]
            }] });

    var FacetComponent = /** @class */ (function () {
        function FacetComponent(facetService, elementRef, cd) {
            this.facetService = facetService;
            this.elementRef = elementRef;
            this.cd = cd;
            /** configurable icon that is used to collapse the facet group  */
            this.expandIcon = exports.ICON_TYPE.EXPAND;
            this.collapseIcon = exports.ICON_TYPE.COLLAPSE;
        }
        Object.defineProperty(FacetComponent.prototype, "facet", {
            get: function () {
                return this._facet;
            },
            set: function (value) {
                this._facet = value;
                this.isMultiSelect = !!value.multiSelect;
                this.state$ = this.facetService.getState(value);
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Handles clicking the heading of the facet group, which means toggling
         * the visibility of the group (collapse / expand) and optionally focusing
         * the group.
         */
        FacetComponent.prototype.toggleGroup = function (event) {
            var _a;
            var host = this.elementRef.nativeElement;
            var isLocked = (_a = this.keyboardFocus) === null || _a === void 0 ? void 0 : _a.isLocked;
            this.facetService.toggle(this.facet, this.isExpanded);
            if (!isLocked || this.isExpanded) {
                host.focus();
                // we stop propagating the event as otherwise the focus on the host will trigger
                // an unlock event from the LockFocus directive.
                event.stopPropagation();
            }
        };
        Object.defineProperty(FacetComponent.prototype, "isExpanded", {
            get: function () {
                return this.values.first.nativeElement.offsetParent !== null;
            },
            enumerable: false,
            configurable: true
        });
        FacetComponent.prototype.openLink = function (event) {
            event.target.click();
            event.preventDefault();
        };
        /**
         * Increases the number of visible values for the facet. This is delegated
         * to `facetService.increaseVisibleValues`.
         */
        FacetComponent.prototype.increaseVisibleValues = function () {
            this.facetService.increaseVisibleValues(this.facet);
        };
        /**
         * Decreases the number of visible values for the facet. This is delegated
         * to `facetService.decreaseVisibleValues`.
         */
        FacetComponent.prototype.decreaseVisibleValues = function () {
            this.facetService.decreaseVisibleValues(this.facet);
        };
        FacetComponent.prototype.getLinkParams = function (value) {
            var _a;
            return this.facetService.getLinkParams((_a = value.query) === null || _a === void 0 ? void 0 : _a.query.value);
        };
        return FacetComponent;
    }());
    FacetComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: FacetComponent, deps: [{ token: FacetService }, { token: i0__namespace.ElementRef }, { token: i0__namespace.ChangeDetectorRef }], target: i0__namespace.ɵɵFactoryTarget.Component });
    FacetComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: FacetComponent, selector: "cx-facet", inputs: { expandIcon: "expandIcon", collapseIcon: "collapseIcon", facet: "facet" }, host: { properties: { "class.multi-select": "this.isMultiSelect" } }, viewQueries: [{ propertyName: "keyboardFocus", first: true, predicate: FocusDirective, descendants: true }, { propertyName: "values", predicate: ["facetValue"], descendants: true }], ngImport: i0__namespace, template: "<ng-container *ngIf=\"state$ | async as state\">\n  <button class=\"heading\" (click)=\"toggleGroup($event)\">\n    {{ facet.name }}\n    <cx-icon class=\"collapse-icon\" [type]=\"collapseIcon\"></cx-icon>\n    <cx-icon class=\"expand-icon\" [type]=\"expandIcon\"></cx-icon>\n  </button>\n\n  <a\n    *ngFor=\"let value of facet.values | slice: 0:state.topVisible\"\n    #facetValue\n    routerLink=\"./\"\n    [queryParams]=\"getLinkParams(value)\"\n    class=\"value\"\n    [class.selected]=\"value.selected\"\n    [cxFocus]=\"value.name\"\n    (keydown.space)=\"openLink($event)\"\n  >\n    <span>\n      <span class=\"label\">{{ value.name }}</span>\n      <span class=\"count\">{{ value.count }}</span>\n    </span>\n  </a>\n\n  <div class=\"more\">\n    <a\n      *ngFor=\"\n        let value of facet.values | slice: state.topVisible:state.maxVisible\n      \"\n      #facetValue\n      routerLink=\"./\"\n      [queryParams]=\"getLinkParams(value)\"\n      class=\"value\"\n      [class.selected]=\"value.selected\"\n      [cxFocus]=\"value.name\"\n      (keydown.space)=\"openLink($event)\"\n    >\n      <span\n        >{{ value.name }}<span class=\"count\">{{ value.count }}</span></span\n      >\n    </a>\n\n    <button\n      *ngIf=\"state.maxVisible > state.topVisible\"\n      (click)=\"decreaseVisibleValues()\"\n      class=\"cx-action-link\"\n      cxFocus=\"moreorless\"\n    >\n      {{ 'productList.showLess' | cxTranslate }}\n    </button>\n\n    <button\n      *ngIf=\"state.maxVisible > 0 && state.maxVisible < facet.values.length\"\n      (click)=\"increaseVisibleValues()\"\n      class=\"cx-action-link\"\n      cxFocus=\"moreorless\"\n    >\n      {{ 'productList.showMore' | cxTranslate }}\n    </button>\n  </div>\n</ng-container>\n", components: [{ type: IconComponent, selector: "cx-icon,[cxIcon]", inputs: ["cxIcon", "type"] }], directives: [{ type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3__namespace.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i1__namespace$1.RouterLinkWithHref, selector: "a[routerLink],area[routerLink]", inputs: ["routerLink", "target", "queryParams", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange", "replaceUrl", "state", "relativeTo"] }, { type: FocusDirective, selector: "[cxFocus]", inputs: ["cxFocus"] }], pipes: { "async": i3__namespace.AsyncPipe, "slice": i3__namespace.SlicePipe, "cxTranslate": i1__namespace.TranslatePipe }, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: FacetComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-facet',
                        templateUrl: './facet.component.html',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], ctorParameters: function () { return [{ type: FacetService }, { type: i0__namespace.ElementRef }, { type: i0__namespace.ChangeDetectorRef }]; }, propDecorators: { expandIcon: [{
                    type: i0.Input
                }], collapseIcon: [{
                    type: i0.Input
                }], isMultiSelect: [{
                    type: i0.HostBinding,
                    args: ['class.multi-select']
                }], values: [{
                    type: i0.ViewChildren,
                    args: ['facetValue']
                }], keyboardFocus: [{
                    type: i0.ViewChild,
                    args: [FocusDirective]
                }], facet: [{
                    type: i0.Input
                }] } });

    var FacetListComponent = /** @class */ (function () {
        function FacetListComponent(facetService, elementRef, renderer) {
            this.facetService = facetService;
            this.elementRef = elementRef;
            this.renderer = renderer;
            /** Emits when the list must close */
            this.closeList = new i0.EventEmitter();
            /** The list of all facet and values related to the products in the list */
            this.facetList$ = this.facetService.facetList$;
            this.iconTypes = exports.ICON_TYPE;
            this.dialogFocusConfig = {
                trap: true,
                block: true,
                focusOnEscape: true,
                autofocus: 'cx-facet',
            };
        }
        Object.defineProperty(FacetListComponent.prototype, "isDialog", {
            get: function () {
                return this._isDialog;
            },
            /**
             * Indicates that the facet navigation is rendered in dialog.
             */
            set: function (value) {
                this._isDialog = value;
                if (value) {
                    this.renderer.addClass(document.body, 'modal-open');
                }
            },
            enumerable: false,
            configurable: true
        });
        FacetListComponent.prototype.handleClick = function () {
            this.close();
        };
        /**
         * Toggles the facet group in case it is not expanded.
         */
        FacetListComponent.prototype.expandFacetGroup = function (facet, ref) {
            if (!ref.isExpanded) {
                this.facetService.toggle(facet, ref.isExpanded);
            }
        };
        /**
         * Indicates that the facet group has been expanded.
         */
        FacetListComponent.prototype.isExpanded = function (facet) {
            return this.facetService
                .getState(facet)
                .pipe(operators.map(function (value) { return value.toggled === exports.FacetGroupCollapsedState.EXPANDED; }));
        };
        /**
         * Indicates that the facet group has been collapsed.
         */
        FacetListComponent.prototype.isCollapsed = function (facet) {
            return this.facetService
                .getState(facet)
                .pipe(operators.map(function (value) { return value.toggled === exports.FacetGroupCollapsedState.COLLAPSED; }));
        };
        FacetListComponent.prototype.close = function (event) {
            this.renderer.removeClass(document.body, 'modal-open');
            this.closeList.emit(event);
        };
        FacetListComponent.prototype.block = function (event) {
            event.stopPropagation();
        };
        return FacetListComponent;
    }());
    FacetListComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: FacetListComponent, deps: [{ token: FacetService }, { token: i0__namespace.ElementRef }, { token: i0__namespace.Renderer2 }], target: i0__namespace.ɵɵFactoryTarget.Component });
    FacetListComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: FacetListComponent, selector: "cx-facet-list", inputs: { isDialog: "isDialog" }, outputs: { closeList: "closeList" }, host: { listeners: { "click": "handleClick()" } }, ngImport: i0__namespace, template: "<div\n  class=\"inner\"\n  *ngIf=\"(facetList$ | async)?.facets as facets\"\n  [cxFocus]=\"isDialog ? dialogFocusConfig : {}\"\n  (esc)=\"close($event)\"\n  (click)=\"block($event)\"\n>\n  <h4>\n    {{ 'productList.filterBy.label' | cxTranslate }}\n    <button\n      type=\"button\"\n      class=\"close\"\n      [attr.aria-label]=\"'common.close' | cxTranslate\"\n      (click)=\"close()\"\n    >\n      <cx-icon aria-hidden=\"true\" [type]=\"iconTypes.CLOSE\"></cx-icon>\n    </button>\n  </h4>\n\n  <!-- \n      Here we'd like to introduce configurable facet components, \n      either by using specific configuration or generic sproutlets \n  -->\n  <cx-facet\n    *ngFor=\"let facet of facets\"\n    #facetRef\n    [facet]=\"facet\"\n    [cxFocus]=\"{ lock: true, trap: true, autofocus: 'a' }\"\n    (unlock)=\"expandFacetGroup(facet, facetRef)\"\n    [class.expanded]=\"isExpanded(facet) | async\"\n    [class.collapsed]=\"isCollapsed(facet) | async\"\n  ></cx-facet>\n</div>\n", components: [{ type: IconComponent, selector: "cx-icon,[cxIcon]", inputs: ["cxIcon", "type"] }, { type: FacetComponent, selector: "cx-facet", inputs: ["expandIcon", "collapseIcon", "facet"] }], directives: [{ type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: FocusDirective, selector: "[cxFocus]", inputs: ["cxFocus"] }, { type: i3__namespace.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], pipes: { "async": i3__namespace.AsyncPipe, "cxTranslate": i1__namespace.TranslatePipe }, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: FacetListComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-facet-list',
                        templateUrl: './facet-list.component.html',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], ctorParameters: function () { return [{ type: FacetService }, { type: i0__namespace.ElementRef }, { type: i0__namespace.Renderer2 }]; }, propDecorators: { isDialog: [{
                    type: i0.Input
                }], closeList: [{
                    type: i0.Output
                }], handleClick: [{
                    type: i0.HostListener,
                    args: ['click']
                }] } });

    var FacetModule = /** @class */ (function () {
        function FacetModule() {
        }
        return FacetModule;
    }());
    FacetModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: FacetModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    FacetModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: FacetModule, declarations: [FacetComponent], imports: [i3.CommonModule,
            i1$1.RouterModule,
            i1.UrlModule,
            i1.I18nModule,
            IconModule,
            KeyboardFocusModule], exports: [FacetComponent] });
    FacetModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: FacetModule, imports: [[
                i3.CommonModule,
                i1$1.RouterModule,
                i1.UrlModule,
                i1.I18nModule,
                IconModule,
                KeyboardFocusModule,
            ]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: FacetModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [
                            i3.CommonModule,
                            i1$1.RouterModule,
                            i1.UrlModule,
                            i1.I18nModule,
                            IconModule,
                            KeyboardFocusModule,
                        ],
                        declarations: [FacetComponent],
                        exports: [FacetComponent],
                    }]
            }] });

    var FacetListModule = /** @class */ (function () {
        function FacetListModule() {
        }
        return FacetListModule;
    }());
    FacetListModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: FacetListModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    FacetListModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: FacetListModule, declarations: [FacetListComponent], imports: [i3.CommonModule,
            i1.I18nModule,
            IconModule,
            FacetModule,
            KeyboardFocusModule], exports: [FacetListComponent] });
    FacetListModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: FacetListModule, imports: [[
                i3.CommonModule,
                i1.I18nModule,
                IconModule,
                FacetModule,
                KeyboardFocusModule,
            ]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: FacetListModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [
                            i3.CommonModule,
                            i1.I18nModule,
                            IconModule,
                            FacetModule,
                            KeyboardFocusModule,
                        ],
                        declarations: [FacetListComponent],
                        exports: [FacetListComponent],
                    }]
            }] });

    var ProductFacetNavigationComponent = /** @class */ (function () {
        function ProductFacetNavigationComponent(breakpointService) {
            var _this = this;
            this.breakpointService = breakpointService;
            this.iconTypes = exports.ICON_TYPE;
            /**
             * We delay the removal of DOM so that animations can finish playing before the
             * DOM is removed. Removing the DOM, as hidding is not enough to stop elements
             * to be focused.
             */
            this.CLOSE_DELAY = 300;
            this.open$ = new rxjs.BehaviorSubject(false);
            /**
             * Emits the open state that indicates whether the facet list should be rendered.
             * This is either done instantly, or after the user triggers this by using the trigger
             * button. This driven by the visiibility of the trigger, so that the CSS drives
             * the behaviour. This can differ per breakpoint.
             *
             * There's a configurable delay for the closed state, so that the DOM is not removed
             * before some CSS animations are done.
             */
            this.isOpen$ = this.breakpointService.breakpoint$.pipe(
            // deffer emitting a new value to the next micro-task to ensure that the `hasTrigger`
            // method represents the actual UI state.
            operators.observeOn(rxjs.asapScheduler), operators.switchMap(function () { return (_this.hasTrigger ? _this.open$ : rxjs.of(true)); }), operators.delayWhen(function (launched) { return rxjs.interval(launched ? 0 : _this.CLOSE_DELAY); }));
            /**
             * Emits the active state that indicates whether the facet list is activated. Activation
             * is related to the css, so that a animation or transition can visualize opening/closing
             * the list (i.e. dialog).
             */
            this.isActive$ = this.open$.pipe(
            // deffer emitting a new value to the next micro-task to ensure the active class is
            //  applied after the DOM is created
            operators.observeOn(rxjs.asapScheduler));
        }
        ProductFacetNavigationComponent.prototype.launch = function () {
            this.open$.next(true);
        };
        ProductFacetNavigationComponent.prototype.close = function () {
            this.open$.next(false);
            this.trigger.nativeElement.focus();
        };
        Object.defineProperty(ProductFacetNavigationComponent.prototype, "hasTrigger", {
            /**
             * Indicates that the facet navigation should be open explicitely by a trigger.
             * This is fully controlled by CSS, where the trigger button can be hidden
             * (display:none) for certain screen sizes.
             */
            get: function () {
                return this.trigger.nativeElement.offsetParent !== null;
            },
            enumerable: false,
            configurable: true
        });
        return ProductFacetNavigationComponent;
    }());
    ProductFacetNavigationComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductFacetNavigationComponent, deps: [{ token: BreakpointService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    ProductFacetNavigationComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: ProductFacetNavigationComponent, selector: "cx-product-facet-navigation", viewQueries: [{ propertyName: "trigger", first: true, predicate: ["trigger"], descendants: true }], ngImport: i0__namespace, template: "<button\n  #trigger\n  class=\"btn btn-action btn-block dialog-trigger\"\n  (click)=\"launch()\"\n>\n  <cx-icon [type]=\"iconTypes.FILTER\"></cx-icon>\n  {{ 'productList.filterBy.label' | cxTranslate }}\n</button>\n\n<cx-active-facets></cx-active-facets>\n\n<cx-facet-list\n  *ngIf=\"isOpen$ | async\"\n  [isDialog]=\"hasTrigger\"\n  (closeList)=\"close()\"\n  [class.active]=\"isActive$ | async\"\n  [class.dialog]=\"hasTrigger\"\n></cx-facet-list>\n", components: [{ type: IconComponent, selector: "cx-icon,[cxIcon]", inputs: ["cxIcon", "type"] }, { type: ActiveFacetsComponent, selector: "cx-active-facets", inputs: ["closeIcon"] }, { type: FacetListComponent, selector: "cx-facet-list", inputs: ["isDialog"], outputs: ["closeList"] }], directives: [{ type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "cxTranslate": i1__namespace.TranslatePipe, "async": i3__namespace.AsyncPipe }, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductFacetNavigationComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-product-facet-navigation',
                        templateUrl: './product-facet-navigation.component.html',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], ctorParameters: function () { return [{ type: BreakpointService }]; }, propDecorators: { trigger: [{
                    type: i0.ViewChild,
                    args: ['trigger']
                }] } });

    var ProductFacetNavigationModule = /** @class */ (function () {
        function ProductFacetNavigationModule() {
        }
        return ProductFacetNavigationModule;
    }());
    ProductFacetNavigationModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductFacetNavigationModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    ProductFacetNavigationModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductFacetNavigationModule, declarations: [ProductFacetNavigationComponent], imports: [i3.CommonModule,
            FacetListModule,
            ActiveFacetsModule,
            IconModule,
            i1.I18nModule, i1__namespace.ConfigModule], exports: [ProductFacetNavigationComponent] });
    ProductFacetNavigationModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductFacetNavigationModule, imports: [[
                i3.CommonModule,
                FacetListModule,
                ActiveFacetsModule,
                IconModule,
                i1.I18nModule,
                i1.ConfigModule.withConfig({
                    cmsComponents: {
                        ProductRefinementComponent: {
                            component: ProductFacetNavigationComponent,
                        },
                    },
                }),
            ]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductFacetNavigationModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [
                            i3.CommonModule,
                            FacetListModule,
                            ActiveFacetsModule,
                            IconModule,
                            i1.I18nModule,
                            i1.ConfigModule.withConfig({
                                cmsComponents: {
                                    ProductRefinementComponent: {
                                        component: ProductFacetNavigationComponent,
                                    },
                                },
                            }),
                        ],
                        declarations: [ProductFacetNavigationComponent],
                        exports: [ProductFacetNavigationComponent],
                    }]
            }] });

    var ProductListModule = /** @class */ (function () {
        function ProductListModule() {
        }
        return ProductListModule;
    }());
    ProductListModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductListModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    ProductListModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductListModule, declarations: [ProductListComponent,
            ProductListItemComponent,
            ProductGridItemComponent,
            ProductViewComponent,
            ProductScrollComponent], imports: [i3.CommonModule,
            i1$1.RouterModule,
            MediaModule,
            AddToCartModule,
            ItemCounterModule,
            ListNavigationModule,
            i1.UrlModule,
            i1.I18nModule,
            StarRatingModule,
            IconModule,
            SpinnerModule,
            i6.InfiniteScrollModule,
            i1.FeaturesConfigModule,
            OutletModule], exports: [ProductListComponent,
            ProductListItemComponent,
            ProductGridItemComponent,
            ProductViewComponent,
            ProductScrollComponent] });
    ProductListModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductListModule, providers: [
            i1.provideDefaultConfig(defaultViewConfig),
            i1.provideDefaultConfig({
                cmsComponents: {
                    CMSProductListComponent: {
                        component: ProductListComponent,
                    },
                    ProductGridComponent: {
                        component: ProductListComponent,
                    },
                    SearchResultsListComponent: {
                        component: ProductListComponent,
                    },
                },
            }),
        ], imports: [[
                i3.CommonModule,
                i1$1.RouterModule,
                MediaModule,
                AddToCartModule,
                ItemCounterModule,
                ListNavigationModule,
                i1.UrlModule,
                i1.I18nModule,
                StarRatingModule,
                IconModule,
                SpinnerModule,
                i6.InfiniteScrollModule,
                i1.FeaturesConfigModule,
                OutletModule,
            ]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductListModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [
                            i3.CommonModule,
                            i1$1.RouterModule,
                            MediaModule,
                            AddToCartModule,
                            ItemCounterModule,
                            ListNavigationModule,
                            i1.UrlModule,
                            i1.I18nModule,
                            StarRatingModule,
                            IconModule,
                            SpinnerModule,
                            i6.InfiniteScrollModule,
                            i1.FeaturesConfigModule,
                            OutletModule,
                        ],
                        providers: [
                            i1.provideDefaultConfig(defaultViewConfig),
                            i1.provideDefaultConfig({
                                cmsComponents: {
                                    CMSProductListComponent: {
                                        component: ProductListComponent,
                                    },
                                    ProductGridComponent: {
                                        component: ProductListComponent,
                                    },
                                    SearchResultsListComponent: {
                                        component: ProductListComponent,
                                    },
                                },
                            }),
                        ],
                        declarations: [
                            ProductListComponent,
                            ProductListItemComponent,
                            ProductGridItemComponent,
                            ProductViewComponent,
                            ProductScrollComponent,
                        ],
                        exports: [
                            ProductListComponent,
                            ProductListItemComponent,
                            ProductGridItemComponent,
                            ProductViewComponent,
                            ProductScrollComponent,
                        ],
                    }]
            }] });

    var ProductSummaryComponent = /** @class */ (function () {
        function ProductSummaryComponent(currentProductService) {
            this.currentProductService = currentProductService;
            this.outlets = exports.ProductDetailOutlets;
            this.product$ = this.currentProductService.getProduct([
                "details" /* DETAILS */,
                "price" /* PRICE */,
            ]);
        }
        return ProductSummaryComponent;
    }());
    ProductSummaryComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductSummaryComponent, deps: [{ token: CurrentProductService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    ProductSummaryComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: ProductSummaryComponent, selector: "cx-product-summary", ngImport: i0__namespace, template: "<ng-container *ngIf=\"product$ | async as product\">\n  <ng-template\n    [cxOutlet]=\"outlets.PRICE\"\n    [cxOutletContext]=\"{ product: product }\"\n  >\n    <div\n      [attr.aria-label]=\"'productSummary.newItemPrice' | cxTranslate\"\n      class=\"price\"\n    >\n      {{ product?.price?.formattedValue }}\n    </div>\n  </ng-template>\n\n  <ng-template\n    [cxOutlet]=\"outlets.SUMMARY\"\n    [cxOutletContext]=\"{ product: product }\"\n  >\n    <p [innerHTML]=\"product?.summary\" class=\"summary\"></p>\n  </ng-template>\n\n  <!-- @TODO: Temp. Comment out share link while not in use by CMS -->\n  <!-- <ng-container *cxOutlet=\"outlets.SHARE\">\n        <div>\n          <a href=\"#\" class=\"share btn-link\">\n            {{ 'productSummary.share' | cxTranslate }}\n          </a>\n        </div>\n      </ng-container> -->\n</ng-container>\n", directives: [{ type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: OutletDirective, selector: "[cxOutlet]", inputs: ["cxOutlet", "cxOutletContext", "cxOutletDefer"], outputs: ["loaded"] }], pipes: { "async": i3__namespace.AsyncPipe, "cxTranslate": i1__namespace.TranslatePipe }, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductSummaryComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-product-summary',
                        templateUrl: './product-summary.component.html',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], ctorParameters: function () { return [{ type: CurrentProductService }]; } });

    var ProductSummaryModule = /** @class */ (function () {
        function ProductSummaryModule() {
        }
        return ProductSummaryModule;
    }());
    ProductSummaryModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductSummaryModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    ProductSummaryModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductSummaryModule, declarations: [ProductSummaryComponent], imports: [i3.CommonModule, OutletModule, i1.I18nModule], exports: [ProductSummaryComponent] });
    ProductSummaryModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductSummaryModule, providers: [
            i1.provideDefaultConfig({
                cmsComponents: {
                    ProductSummaryComponent: {
                        component: ProductSummaryComponent,
                    },
                },
            }),
        ], imports: [[i3.CommonModule, OutletModule, i1.I18nModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductSummaryModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [i3.CommonModule, OutletModule, i1.I18nModule],
                        providers: [
                            i1.provideDefaultConfig({
                                cmsComponents: {
                                    ProductSummaryComponent: {
                                        component: ProductSummaryComponent,
                                    },
                                },
                            }),
                        ],
                        declarations: [ProductSummaryComponent],
                        exports: [ProductSummaryComponent],
                    }]
            }] });

    var ProductAttributesComponent = /** @class */ (function () {
        function ProductAttributesComponent(currentProductService) {
            this.currentProductService = currentProductService;
            this.product$ = this.currentProductService.getProduct("attributes" /* ATTRIBUTES */);
        }
        return ProductAttributesComponent;
    }());
    ProductAttributesComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductAttributesComponent, deps: [{ token: CurrentProductService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    ProductAttributesComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: ProductAttributesComponent, selector: "cx-product-attributes", ngImport: i0__namespace, template: "<ng-container *ngIf=\"product$ | async as product\">\n  <div class=\"container\">\n    <h2>{{ 'productDetails.specification' | cxTranslate }}</h2>\n    <table *ngFor=\"let class of product?.classifications\">\n      <th>\n        <h3>{{ class.name }}</h3>\n      </th>\n      <tr *ngFor=\"let feature of class.features\">\n        <td>{{ feature.name }}</td>\n        <td>\n          <ul>\n            <li *ngFor=\"let featureValue of feature?.featureValues\">\n              {{ featureValue?.value }}\n              <span\n                *ngIf=\"\n                  feature.featureUnit?.symbol?.length > 0 &&\n                  feature.featureUnit.unitType != '300'\n                \"\n              >\n                {{ feature.featureUnit.symbol }}\n              </span>\n            </li>\n          </ul>\n        </td>\n      </tr>\n    </table>\n  </div>\n</ng-container>\n", directives: [{ type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3__namespace.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], pipes: { "async": i3__namespace.AsyncPipe, "cxTranslate": i1__namespace.TranslatePipe }, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductAttributesComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-product-attributes',
                        templateUrl: './product-attributes.component.html',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], ctorParameters: function () { return [{ type: CurrentProductService }]; } });

    var ProductAttributesModule = /** @class */ (function () {
        function ProductAttributesModule() {
        }
        return ProductAttributesModule;
    }());
    ProductAttributesModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductAttributesModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    ProductAttributesModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductAttributesModule, declarations: [ProductAttributesComponent], imports: [i3.CommonModule, i1.I18nModule], exports: [ProductAttributesComponent] });
    ProductAttributesModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductAttributesModule, providers: [
            i1.provideDefaultConfig({
                cmsComponents: {
                    ProductSpecsTabComponent: {
                        component: ProductAttributesComponent,
                    },
                },
            }),
        ], imports: [[i3.CommonModule, i1.I18nModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductAttributesModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [i3.CommonModule, i1.I18nModule],
                        providers: [
                            i1.provideDefaultConfig({
                                cmsComponents: {
                                    ProductSpecsTabComponent: {
                                        component: ProductAttributesComponent,
                                    },
                                },
                            }),
                        ],
                        declarations: [ProductAttributesComponent],
                        exports: [ProductAttributesComponent],
                    }]
            }] });

    var ProductDetailsTabComponent = /** @class */ (function () {
        function ProductDetailsTabComponent(currentProductService) {
            this.currentProductService = currentProductService;
        }
        ProductDetailsTabComponent.prototype.ngOnInit = function () {
            this.product$ = this.currentProductService.getProduct();
        };
        return ProductDetailsTabComponent;
    }());
    ProductDetailsTabComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductDetailsTabComponent, deps: [{ token: CurrentProductService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    ProductDetailsTabComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: ProductDetailsTabComponent, selector: "cx-product-details-tab", ngImport: i0__namespace, template: "<ng-container *ngIf=\"product$ | async as product\">\n  <div class=\"container\" [innerHTML]=\"product?.description\"></div>\n</ng-container>\n", directives: [{ type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "async": i3__namespace.AsyncPipe }, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductDetailsTabComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-product-details-tab',
                        templateUrl: './product-details-tab.component.html',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], ctorParameters: function () { return [{ type: CurrentProductService }]; } });

    var ProductDetailsTabModule = /** @class */ (function () {
        function ProductDetailsTabModule() {
        }
        return ProductDetailsTabModule;
    }());
    ProductDetailsTabModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductDetailsTabModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    ProductDetailsTabModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductDetailsTabModule, declarations: [ProductDetailsTabComponent], imports: [i3.CommonModule], exports: [ProductDetailsTabComponent] });
    ProductDetailsTabModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductDetailsTabModule, providers: [
            i1.provideDefaultConfig({
                cmsComponents: {
                    ProductDetailsTabComponent: {
                        component: ProductDetailsTabComponent,
                    },
                },
            }),
        ], imports: [[i3.CommonModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductDetailsTabModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [i3.CommonModule],
                        providers: [
                            i1.provideDefaultConfig({
                                cmsComponents: {
                                    ProductDetailsTabComponent: {
                                        component: ProductDetailsTabComponent,
                                    },
                                },
                            }),
                        ],
                        declarations: [ProductDetailsTabComponent],
                        exports: [ProductDetailsTabComponent],
                    }]
            }] });

    var ProductReviewsComponent = /** @class */ (function () {
        function ProductReviewsComponent(reviewService, currentProductService, fb, cd) {
            var _this = this;
            this.reviewService = reviewService;
            this.currentProductService = currentProductService;
            this.fb = fb;
            this.cd = cd;
            this.isWritingReview = false;
            // TODO: configurable
            this.initialMaxListItems = 5;
            this.product$ = this.currentProductService.getProduct();
            this.reviews$ = this.product$.pipe(operators.filter(function (p) { return !!p; }), operators.map(function (p) { return p.code; }), operators.distinctUntilChanged(), operators.switchMap(function (productCode) { return _this.reviewService.getByProductCode(productCode); }), operators.tap(function () {
                _this.resetReviewForm();
                _this.maxListItems = _this.initialMaxListItems;
            }));
        }
        ProductReviewsComponent.prototype.initiateWriteReview = function () {
            this.isWritingReview = true;
            this.cd.detectChanges();
            if (this.titleInput && this.titleInput.nativeElement) {
                this.titleInput.nativeElement.focus();
            }
        };
        ProductReviewsComponent.prototype.cancelWriteReview = function () {
            this.isWritingReview = false;
            this.resetReviewForm();
            this.cd.detectChanges();
            if (this.writeReviewButton && this.writeReviewButton.nativeElement) {
                this.writeReviewButton.nativeElement.focus();
            }
        };
        ProductReviewsComponent.prototype.setRating = function (rating) {
            this.reviewForm.controls.rating.setValue(rating);
        };
        ProductReviewsComponent.prototype.submitReview = function (product) {
            if (this.reviewForm.valid) {
                this.addReview(product);
            }
            else {
                this.reviewForm.markAllAsTouched();
            }
        };
        ProductReviewsComponent.prototype.addReview = function (product) {
            var reviewFormControls = this.reviewForm.controls;
            var review = {
                headline: reviewFormControls.title.value,
                comment: reviewFormControls.comment.value,
                rating: reviewFormControls.rating.value,
                alias: reviewFormControls.reviewerName.value,
            };
            this.reviewService.add(product.code, review);
            this.isWritingReview = false;
            this.resetReviewForm();
            this.cd.detectChanges();
            if (this.writeReviewButton && this.writeReviewButton.nativeElement) {
                this.writeReviewButton.nativeElement.focus();
            }
        };
        ProductReviewsComponent.prototype.resetReviewForm = function () {
            this.reviewForm = this.fb.group({
                title: ['', i3$1.Validators.required],
                comment: ['', i3$1.Validators.required],
                rating: [null, CustomFormValidators.starRatingEmpty],
                reviewerName: '',
            });
        };
        return ProductReviewsComponent;
    }());
    ProductReviewsComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductReviewsComponent, deps: [{ token: i1__namespace.ProductReviewService }, { token: CurrentProductService }, { token: i3__namespace$1.FormBuilder }, { token: i0__namespace.ChangeDetectorRef }], target: i0__namespace.ɵɵFactoryTarget.Component });
    ProductReviewsComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: ProductReviewsComponent, selector: "cx-product-reviews", viewQueries: [{ propertyName: "titleInput", first: true, predicate: ["titleInput"], descendants: true }, { propertyName: "writeReviewButton", first: true, predicate: ["writeReviewButton"], descendants: true }], ngImport: i0__namespace, template: "<div class=\"container\" *ngIf=\"product$ | async as product\">\n  <h2>\n    {{ 'productDetails.reviews' | cxTranslate }} ({{ product.numberOfReviews }})\n  </h2>\n  <ng-container *ngIf=\"!isWritingReview; else writeReview\">\n    <div class=\"header\">\n      <h3>{{ 'productReview.overallRating' | cxTranslate }}</h3>\n      <button\n        #writeReviewButton\n        class=\"btn btn-primary\"\n        (click)=\"initiateWriteReview()\"\n      >\n        {{ 'productReview.writeReview' | cxTranslate }}\n      </button>\n      <cx-star-rating\n        *ngIf=\"product.averageRating\"\n        class=\"rating\"\n        [rating]=\"product.averageRating\"\n      ></cx-star-rating>\n      <div class=\"rating\" *ngIf=\"!product.averageRating\">\n        {{ 'productDetails.noReviews' | cxTranslate }}\n      </div>\n    </div>\n\n    <ng-container *ngIf=\"!isWritingReview; else writeReview\">\n      <ng-container *ngIf=\"reviews$ | async as reviews\">\n        <div\n          class=\"review\"\n          tabindex=\"0\"\n          *ngFor=\"let review of reviews | slice: 0:maxListItems\"\n        >\n          <div class=\"title\">{{ review.headline }}</div>\n          <cx-star-rating [rating]=\"review.rating\"></cx-star-rating>\n          <div class=\"name\">\n            {{ review.alias ? review.alias : review.principal?.name }}\n          </div>\n          <div class=\"date\">{{ review.date | cxDate }}</div>\n          <div class=\"text\">{{ review.comment }}</div>\n        </div>\n        <div *ngIf=\"reviews.length > initialMaxListItems\">\n          <button\n            class=\"btn btn-primary\"\n            (click)=\"maxListItems = reviews.length\"\n            *ngIf=\"maxListItems === initialMaxListItems\"\n          >\n            {{ 'productReview.more' | cxTranslate }}\n          </button>\n          <button\n            class=\"btn btn-primary\"\n            (click)=\"maxListItems = initialMaxListItems\"\n            *ngIf=\"maxListItems !== initialMaxListItems\"\n          >\n            {{ 'productReview.less' | cxTranslate }}\n          </button>\n        </div>\n      </ng-container>\n    </ng-container>\n  </ng-container>\n\n  <ng-template #writeReview>\n    <form (ngSubmit)=\"submitReview(product)\" [formGroup]=\"reviewForm\">\n      <div class=\"form-group\">\n        <label>\n          <span class=\"label-content\">{{\n            'productReview.reviewTitle' | cxTranslate\n          }}</span>\n          <input\n            aria-required=\"true\"\n            #titleInput\n            type=\"text\"\n            class=\"form-control\"\n            formControlName=\"title\"\n          />\n          <cx-form-errors\n            aria-live=\"assertive\"\n            aria-atomic=\"true\"\n            [control]=\"reviewForm.get('title')\"\n          ></cx-form-errors>\n        </label>\n      </div>\n      <div class=\"form-group\">\n        <label>\n          <span class=\"label-content\">{{\n            'productReview.writeYourComments' | cxTranslate\n          }}</span>\n          <textarea\n            aria-required=\"true\"\n            class=\"form-control\"\n            rows=\"3\"\n            formControlName=\"comment\"\n          ></textarea>\n          <cx-form-errors\n            aria-live=\"assertive\"\n            aria-atomic=\"true\"\n            [control]=\"reviewForm.get('comment')\"\n          ></cx-form-errors>\n        </label>\n      </div>\n      <div class=\"form-group\">\n        <label>\n          <span class=\"label-content\">{{\n            'productReview.rating' | cxTranslate\n          }}</span>\n          <input\n            aria-required=\"true\"\n            type=\"number\"\n            formControlName=\"rating\"\n            class=\"rating-input\"\n          />\n          <cx-star-rating\n            (change)=\"setRating($event)\"\n            [disabled]=\"false\"\n          ></cx-star-rating>\n          <cx-form-errors\n            aria-live=\"assertive\"\n            aria-atomic=\"true\"\n            [control]=\"reviewForm.get('rating')\"\n          ></cx-form-errors>\n        </label>\n      </div>\n      <div class=\"form-group\">\n        <label>\n          <span class=\"label-content\">{{\n            'productReview.reviewerName' | cxTranslate\n          }}</span>\n          <input\n            type=\"text\"\n            class=\"form-control\"\n            formControlName=\"reviewerName\"\n          />\n        </label>\n      </div>\n      <div class=\"form-group row\">\n        <div class=\"col-12 col-md-4\">\n          <button\n            type=\"button\"\n            class=\"btn btn-block btn-secondary\"\n            (click)=\"cancelWriteReview()\"\n          >\n            {{ 'common.cancel' | cxTranslate }}\n          </button>\n        </div>\n        <div class=\"col-12 col-md-4\">\n          <button type=\"submit\" class=\"btn btn-block btn-primary\">\n            {{ 'common.submit' | cxTranslate }}\n          </button>\n        </div>\n      </div>\n    </form>\n  </ng-template>\n</div>\n", components: [{ type: StarRatingComponent, selector: "cx-star-rating", inputs: ["disabled", "rating"], outputs: ["change"] }, { type: FormErrorsComponent, selector: "cx-form-errors", inputs: ["prefix", "translationParams", "control"] }], directives: [{ type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3__namespace.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i3__namespace$1.ɵNgNoValidate, selector: "form:not([ngNoForm]):not([ngNativeValidate])" }, { type: i3__namespace$1.NgControlStatusGroup, selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { type: i3__namespace$1.FormGroupDirective, selector: "[formGroup]", inputs: ["formGroup"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }, { type: i3__namespace$1.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { type: i3__namespace$1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i3__namespace$1.FormControlName, selector: "[formControlName]", inputs: ["disabled", "formControlName", "ngModel"], outputs: ["ngModelChange"] }, { type: i3__namespace$1.NumberValueAccessor, selector: "input[type=number][formControlName],input[type=number][formControl],input[type=number][ngModel]" }], pipes: { "async": i3__namespace.AsyncPipe, "cxTranslate": i1__namespace.TranslatePipe, "slice": i3__namespace.SlicePipe, "cxDate": i1__namespace.CxDatePipe }, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductReviewsComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-product-reviews',
                        templateUrl: './product-reviews.component.html',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace.ProductReviewService }, { type: CurrentProductService }, { type: i3__namespace$1.FormBuilder }, { type: i0__namespace.ChangeDetectorRef }]; }, propDecorators: { titleInput: [{
                    type: i0.ViewChild,
                    args: ['titleInput', { static: false }]
                }], writeReviewButton: [{
                    type: i0.ViewChild,
                    args: ['writeReviewButton', { static: false }]
                }] } });

    var ProductReviewsModule = /** @class */ (function () {
        function ProductReviewsModule() {
        }
        return ProductReviewsModule;
    }());
    ProductReviewsModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductReviewsModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    ProductReviewsModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductReviewsModule, declarations: [ProductReviewsComponent], imports: [i3.CommonModule,
            i3$1.ReactiveFormsModule,
            i3$1.FormsModule,
            i1.I18nModule,
            StarRatingModule,
            FormErrorsModule], exports: [ProductReviewsComponent] });
    ProductReviewsModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductReviewsModule, providers: [
            i1.provideDefaultConfig({
                cmsComponents: {
                    ProductReviewsTabComponent: {
                        component: ProductReviewsComponent,
                    },
                },
            }),
        ], imports: [[
                i3.CommonModule,
                i3$1.ReactiveFormsModule,
                i3$1.FormsModule,
                i1.I18nModule,
                StarRatingModule,
                FormErrorsModule,
            ]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductReviewsModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [
                            i3.CommonModule,
                            i3$1.ReactiveFormsModule,
                            i3$1.FormsModule,
                            i1.I18nModule,
                            StarRatingModule,
                            FormErrorsModule,
                        ],
                        providers: [
                            i1.provideDefaultConfig({
                                cmsComponents: {
                                    ProductReviewsTabComponent: {
                                        component: ProductReviewsComponent,
                                    },
                                },
                            }),
                        ],
                        declarations: [ProductReviewsComponent],
                        exports: [ProductReviewsComponent],
                    }]
            }] });

    var ProductTabsModule = /** @class */ (function () {
        function ProductTabsModule() {
        }
        return ProductTabsModule;
    }());
    ProductTabsModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductTabsModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    ProductTabsModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductTabsModule, imports: [ProductAttributesModule,
            ProductDetailsTabModule,
            ProductReviewsModule] });
    ProductTabsModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductTabsModule, imports: [[
                ProductAttributesModule,
                ProductDetailsTabModule,
                ProductReviewsModule,
            ]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductTabsModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [
                            ProductAttributesModule,
                            ProductDetailsTabModule,
                            ProductReviewsModule,
                        ],
                    }]
            }] });

    var StockNotificationDialogComponent = /** @class */ (function () {
        function StockNotificationDialogComponent(modalService, interestsService) {
            this.modalService = modalService;
            this.interestsService = interestsService;
            this.enabledPrefs = [];
        }
        StockNotificationDialogComponent.prototype.close = function () {
            this.modalService.dismissActiveModal();
        };
        StockNotificationDialogComponent.prototype.ngOnDestroy = function () {
            var _this = this;
            if (this.subscribeSuccess$) {
                this.subscribeSuccess$
                    .subscribe(function (success) {
                    if (success) {
                        _this.interestsService.resetAddInterestState();
                    }
                })
                    .unsubscribe();
            }
        };
        return StockNotificationDialogComponent;
    }());
    StockNotificationDialogComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: StockNotificationDialogComponent, deps: [{ token: ModalService }, { token: i1__namespace.UserInterestsService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    StockNotificationDialogComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: StockNotificationDialogComponent, selector: "cx-stock-notification-dialog", ngImport: i0__namespace, template: "<div class=\"cx-dialog-header modal-header\">\n  <div class=\"cx-dialog-title modal-title\">\n    {{ 'stockNotification.subscriptionDialog.header' | cxTranslate }}\n  </div>\n  <button\n    type=\"button\"\n    [attr.aria-label]=\"'common.close' | cxTranslate\"\n    class=\"close\"\n    tabindex=\"-1\"\n    (click)=\"close()\"\n  >\n    <span aria-hidden=\"true\">&times;</span>\n  </button>\n</div>\n\n<ng-container *ngIf=\"subscribeSuccess$ | async; else loading\">\n  <div class=\"cx-dialog-body modal-body\">\n    <div class=\"container\">\n      <p>\n        {{\n          'stockNotification.subscriptionDialog.notifiedPrefix' | cxTranslate\n        }}\n      </p>\n      <p *ngFor=\"let preference of enabledPrefs\" class=\"channels\">\n        <span>{{ preference.channel }}</span\n        ><span *ngIf=\"preference.value\">{{ ': ' + preference.value }}</span>\n      </p>\n      <p>\n        {{\n          'stockNotification.subscriptionDialog.notifiedSuffix' | cxTranslate\n        }}\n      </p>\n      <p>\n        {{\n          'stockNotification.subscriptionDialog.manageChannelsPrefix'\n            | cxTranslate\n        }}\n        <a\n          (click)=\"close()\"\n          [routerLink]=\"['/my-account/notification-preference']\"\n          class=\"link-prefs\"\n        >\n          {{\n            'stockNotification.subscriptionDialog.manageChannelsLink'\n              | cxTranslate\n          }}</a\n        >\n        {{\n          'stockNotification.subscriptionDialog.manageChannelsSuffix'\n            | cxTranslate\n        }}\n      </p>\n\n      <p>\n        {{\n          'stockNotification.subscriptionDialog.manageSubscriptionsPrefix'\n            | cxTranslate\n        }}\n        <a\n          (click)=\"close()\"\n          [routerLink]=\"['/my-account/my-interests']\"\n          class=\"link-interests\"\n        >\n          {{\n            'stockNotification.subscriptionDialog.manageSubscriptionsLink'\n              | cxTranslate\n          }}</a\n        >\n        {{\n          'stockNotification.subscriptionDialog.manageSubscriptionsSuffix'\n            | cxTranslate\n        }}\n      </p>\n      <div class=\"row\">\n        <div class=\"cx-dialog-actions col-sm-12 col-md-3 offset-md-9\">\n          <button\n            class=\"btn btn-primary btn-block btn-ok\"\n            type=\"button\"\n            (click)=\"close()\"\n          >\n            {{ 'stockNotification.subscriptionDialog.okBtn' | cxTranslate }}\n          </button>\n        </div>\n      </div>\n    </div>\n  </div>\n</ng-container>\n\n<ng-template #loading>\n  <div class=\"cx-dialog-body modal-body\">\n    <p>\n      {{ 'stockNotification.subscriptionDialog.subscribing' | cxTranslate }}\n    </p>\n    <div class=\"cx-dialog-row\">\n      <div class=\"col-sm-12\">\n        <cx-spinner></cx-spinner>\n      </div>\n    </div>\n  </div>\n</ng-template>\n", components: [{ type: SpinnerComponent, selector: "cx-spinner" }], directives: [{ type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3__namespace.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i1__namespace$1.RouterLinkWithHref, selector: "a[routerLink],area[routerLink]", inputs: ["routerLink", "target", "queryParams", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange", "replaceUrl", "state", "relativeTo"] }], pipes: { "cxTranslate": i1__namespace.TranslatePipe, "async": i3__namespace.AsyncPipe } });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: StockNotificationDialogComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-stock-notification-dialog',
                        templateUrl: './stock-notification-dialog.component.html',
                    }]
            }], ctorParameters: function () { return [{ type: ModalService }, { type: i1__namespace.UserInterestsService }]; } });

    var StockNotificationComponent = /** @class */ (function () {
        function StockNotificationComponent(currentProductService, globalMessageService, translationService, interestsService, modalService, notificationPrefService, userIdService) {
            this.currentProductService = currentProductService;
            this.globalMessageService = globalMessageService;
            this.translationService = translationService;
            this.interestsService = interestsService;
            this.modalService = modalService;
            this.notificationPrefService = notificationPrefService;
            this.userIdService = userIdService;
            this.anonymous = true;
            this.enabledPrefs = [];
            this.subscriptions = new rxjs.Subscription();
        }
        StockNotificationComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.outOfStock$ = rxjs.combineLatest([
                this.currentProductService.getProduct().pipe(operators.filter(i1.isNotNullable)),
                this.userIdService.getUserId(),
            ]).pipe(operators.tap(function (_a) {
                var _b = __read(_a, 2), product = _b[0], userId = _b[1];
                _this.productCode = product.code;
                if (userId !== i1.OCC_USER_ID_ANONYMOUS) {
                    _this.anonymous = false;
                    _this.notificationPrefService.loadPreferences();
                    _this.interestsService.loadProductInterests(null, null, null, product.code, i1.NotificationType.BACK_IN_STOCK);
                }
            }), operators.map(function (_a) {
                var _b = __read(_a, 1), product = _b[0];
                return !!product.stock && product.stock.stockLevelStatus === 'outOfStock';
            }));
            this.hasProductInterests$ = this.interestsService
                .getProductInterests()
                .pipe(operators.map(function (interests) { return !!interests.results && interests.results.length === 1; }));
            this.subscribeSuccess$ =
                this.interestsService.getAddProductInterestSuccess();
            this.isRemoveInterestLoading$ =
                this.interestsService.getRemoveProdutInterestLoading();
            this.prefsEnabled$ = this.notificationPrefService
                .getEnabledPreferences()
                .pipe(operators.tap(function (prefs) { return (_this.enabledPrefs = prefs); }), operators.map(function (prefs) { return prefs.length > 0; }));
            this.subscriptions.add(this.interestsService.getAddProductInterestError().subscribe(function (error) {
                if (error) {
                    _this.onInterestAddingError();
                }
            }));
            this.subscriptions.add(this.interestsService
                .getRemoveProdutInterestSuccess()
                .subscribe(function (success) {
                if (success) {
                    _this.onInterestRemovingSuccess();
                }
            }));
        };
        StockNotificationComponent.prototype.subscribe = function () {
            this.openDialog();
            this.interestsService.addProductInterest(this.productCode, i1.NotificationType.BACK_IN_STOCK);
        };
        StockNotificationComponent.prototype.unsubscribe = function () {
            this.interestsService.removeProdutInterest({
                product: {
                    code: this.productCode,
                },
                productInterestEntry: [
                    {
                        interestType: i1.NotificationType.BACK_IN_STOCK,
                    },
                ],
            }, true);
        };
        StockNotificationComponent.prototype.onInterestRemovingSuccess = function () {
            var _this = this;
            this.subscriptions.add(this.translationService
                .translate('stockNotification.unsubscribeSuccess')
                .pipe(operators.first())
                .subscribe(function (text) { return _this.globalMessageService.add(text, i1.GlobalMessageType.MSG_TYPE_INFO); }));
            this.interestsService.resetRemoveInterestState();
        };
        StockNotificationComponent.prototype.onInterestAddingError = function () {
            this.modalService.dismissActiveModal();
            this.interestsService.resetAddInterestState();
        };
        StockNotificationComponent.prototype.openDialog = function () {
            var modalInstance = this.modalService.open(StockNotificationDialogComponent, {
                centered: true,
                size: 'lg',
            }).componentInstance;
            modalInstance.subscribeSuccess$ = this.subscribeSuccess$;
            modalInstance.enabledPrefs = this.enabledPrefs;
        };
        StockNotificationComponent.prototype.ngOnDestroy = function () {
            this.subscriptions.unsubscribe();
            this.interestsService.clearProductInterests();
            this.notificationPrefService.clearPreferences();
        };
        return StockNotificationComponent;
    }());
    StockNotificationComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: StockNotificationComponent, deps: [{ token: CurrentProductService }, { token: i1__namespace.GlobalMessageService }, { token: i1__namespace.TranslationService }, { token: i1__namespace.UserInterestsService }, { token: ModalService }, { token: i1__namespace.UserNotificationPreferenceService }, { token: i1__namespace.UserIdService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    StockNotificationComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: StockNotificationComponent, selector: "cx-stock-notification", ngImport: i0__namespace, template: "<ng-container *ngIf=\"outOfStock$ | async\">\n  <ng-container *ngIf=\"!(hasProductInterests$ | async); else stopNotify\">\n    <ng-container *ngIf=\"prefsEnabled$ | async; else disableNotify\">\n      <div class=\"stock-notification-notes\">\n        <p>{{ 'stockNotification.getNotified' | cxTranslate }}</p>\n      </div>\n      <button\n        class=\"btn btn-primary btn-block btn-notify\"\n        type=\"button\"\n        (click)=\"subscribe()\"\n      >\n        {{ 'stockNotification.notifyMe' | cxTranslate }}\n      </button>\n    </ng-container>\n  </ng-container>\n</ng-container>\n\n<ng-template #disableNotify>\n  <div class=\"stock-notification-notes\" id=\"outOfStockMessage\">\n    <p>\n      <ng-container *ngIf=\"anonymous; else loggedIn\">\n        <a [routerLink]=\"{ cxRoute: 'login' } | cxUrl\">\n          {{ 'miniLogin.signInRegister' | cxTranslate }}</a\n        >\n        {{ 'stockNotification.getNotifySuffix' | cxTranslate }}<br />\n      </ng-container>\n      <ng-template #loggedIn>\n        {{ 'stockNotification.getNotify' | cxTranslate }}<br />\n        {{ 'stockNotification.activateChannelsPrefix' | cxTranslate\n        }}<a [routerLink]=\"['/my-account/notification-preference']\">{{\n          'stockNotification.channelsLink' | cxTranslate\n        }}</a\n        >{{ 'stockNotification.activateChannelsSuffix' | cxTranslate }}\n      </ng-template>\n    </p>\n  </div>\n  <button\n    class=\"btn btn-primary btn-block btn-notify\"\n    type=\"button\"\n    disabled=\"true\"\n    aria-describedby=\"outOfStockMessage\"\n  >\n    {{ 'stockNotification.notifyMe' | cxTranslate }}\n  </button>\n</ng-template>\n\n<ng-template #stopNotify>\n  <ng-container *ngIf=\"!(isRemoveInterestLoading$ | async); else loading\">\n    <div class=\"stock-notification-notes\">\n      <p>{{ 'stockNotification.notified' | cxTranslate }}</p>\n    </div>\n    <button\n      class=\"btn btn-primary btn-block btn-stop-notify\"\n      type=\"button\"\n      (click)=\"unsubscribe()\"\n    >\n      {{ 'stockNotification.stopNotify' | cxTranslate }}\n    </button>\n  </ng-container>\n</ng-template>\n\n<ng-template #loading>\n  <div class=\"cx-dialog-body modal-body\">\n    <div class=\"cx-dialog-row\">\n      <div class=\"col-sm-12\">\n        <cx-spinner></cx-spinner>\n      </div>\n    </div>\n  </div>\n</ng-template>\n", components: [{ type: SpinnerComponent, selector: "cx-spinner" }], directives: [{ type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i1__namespace$1.RouterLinkWithHref, selector: "a[routerLink],area[routerLink]", inputs: ["routerLink", "target", "queryParams", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange", "replaceUrl", "state", "relativeTo"] }], pipes: { "async": i3__namespace.AsyncPipe, "cxTranslate": i1__namespace.TranslatePipe, "cxUrl": i1__namespace.UrlPipe }, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: StockNotificationComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-stock-notification',
                        templateUrl: './stock-notification.component.html',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], ctorParameters: function () { return [{ type: CurrentProductService }, { type: i1__namespace.GlobalMessageService }, { type: i1__namespace.TranslationService }, { type: i1__namespace.UserInterestsService }, { type: ModalService }, { type: i1__namespace.UserNotificationPreferenceService }, { type: i1__namespace.UserIdService }]; } });

    var StockNotificationModule = /** @class */ (function () {
        function StockNotificationModule() {
        }
        return StockNotificationModule;
    }());
    StockNotificationModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: StockNotificationModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    StockNotificationModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: StockNotificationModule, declarations: [StockNotificationComponent, StockNotificationDialogComponent], imports: [i3.CommonModule, i1$1.RouterModule, i1.I18nModule, SpinnerModule, i1.UrlModule], exports: [StockNotificationComponent, StockNotificationDialogComponent] });
    StockNotificationModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: StockNotificationModule, providers: [
            i1.provideDefaultConfig({
                cmsComponents: {
                    StockNotificationComponent: {
                        component: StockNotificationComponent,
                    },
                },
            }),
        ], imports: [[i3.CommonModule, i1$1.RouterModule, i1.I18nModule, SpinnerModule, i1.UrlModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: StockNotificationModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        declarations: [StockNotificationComponent, StockNotificationDialogComponent],
                        imports: [i3.CommonModule, i1$1.RouterModule, i1.I18nModule, SpinnerModule, i1.UrlModule],
                        providers: [
                            i1.provideDefaultConfig({
                                cmsComponents: {
                                    StockNotificationComponent: {
                                        component: StockNotificationComponent,
                                    },
                                },
                            }),
                        ],
                        exports: [StockNotificationComponent, StockNotificationDialogComponent],
                    }]
            }] });

    /**
     * Guards the _login_ route.
     *
     * Takes care of routing the user to a auth server login page (if implicit or code flow is used).
     * In case of Resource Owner Password Flow just renders the page as normal CMS page.
     */
    var LoginGuard = /** @class */ (function () {
        function LoginGuard(authService, authRedirectService, authConfigService, cmsPageGuard) {
            this.authService = authService;
            this.authRedirectService = authRedirectService;
            this.authConfigService = authConfigService;
            this.cmsPageGuard = cmsPageGuard;
        }
        LoginGuard.prototype.canActivate = function (route, state) {
            var _this = this;
            return this.authService.isUserLoggedIn().pipe(operators.take(1), operators.switchMap(function (isUserLoggedIn) {
                if (_this.authConfigService.getOAuthFlow() ===
                    i1.OAuthFlow.ResourceOwnerPasswordFlow ||
                    isUserLoggedIn) {
                    return _this.cmsPageGuard.canActivate(route, state);
                }
                else {
                    // Remember the previous url, so we can redirect user to that page after OAuth server callback
                    _this.authRedirectService.reportNotAuthGuard();
                    // This method can trigger redirect to OAuth server that's why we don't return anything in this case
                    var redirected = _this.authService.loginWithRedirect();
                    if (!redirected) {
                        return rxjs.of(false);
                    }
                    return rxjs.EMPTY;
                }
            }));
        };
        return LoginGuard;
    }());
    LoginGuard.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: LoginGuard, deps: [{ token: i1__namespace.AuthService }, { token: i1__namespace.AuthRedirectService }, { token: i1__namespace.AuthConfigService }, { token: CmsPageGuard }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    LoginGuard.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: LoginGuard, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: LoginGuard, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace.AuthService }, { type: i1__namespace.AuthRedirectService }, { type: i1__namespace.AuthConfigService }, { type: CmsPageGuard }]; } });

    /**
     * This module enables to quickly switch from Resource Owner Password Flow
     * to Implicit Flow or Authorization Code Flow. The `login` route in this case will be
     * responsible for initalizing the redirect to OAuth server to login.
     *
     * Instead of manually invoking OAuth redirect you only have to redirect to `login` page.
     */
    var LoginRouteModule = /** @class */ (function () {
        function LoginRouteModule() {
        }
        return LoginRouteModule;
    }());
    LoginRouteModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: LoginRouteModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    LoginRouteModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: LoginRouteModule, imports: [PageLayoutModule, i1__namespace$1.RouterModule] });
    LoginRouteModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: LoginRouteModule, imports: [[
                PageLayoutModule,
                i1$1.RouterModule.forChild([
                    {
                        path: null,
                        canActivate: [LoginGuard],
                        component: PageLayoutComponent,
                        data: { cxRoute: 'login' },
                    },
                ]),
            ]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: LoginRouteModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [
                            PageLayoutModule,
                            i1$1.RouterModule.forChild([
                                {
                                    path: null,
                                    canActivate: [LoginGuard],
                                    component: PageLayoutComponent,
                                    data: { cxRoute: 'login' },
                                },
                            ]),
                        ],
                    }]
            }] });

    /**
     * Guards the _logout_ route.
     *
     * Takes care of routing the user to a logout page (if available) or redirects to
     * the homepage. If the homepage is protected, the user is redirected
     * to the login route instead.
     */
    var LogoutGuard = /** @class */ (function () {
        function LogoutGuard(auth, cms, semanticPathService, protectedRoutes, router, authRedirectService) {
            this.auth = auth;
            this.cms = cms;
            this.semanticPathService = semanticPathService;
            this.protectedRoutes = protectedRoutes;
            this.router = router;
            this.authRedirectService = authRedirectService;
        }
        LogoutGuard.prototype.canActivate = function () {
            var _this = this;
            // Logout route should never be remembered as a redirect url after login (that would cause logout right after login).
            this.authRedirectService.reportNotAuthGuard();
            /**
             * First we want to complete logout process before redirecting to logout page
             * We want to avoid errors like `token is no longer valid`
             */
            return rxjs.from(this.logout()).pipe(operators.switchMap(function () {
                return _this.cms
                    .hasPage({
                    id: _this.semanticPathService.get('logout'),
                    type: i1.PageType.CONTENT_PAGE,
                })
                    .pipe(operators.map(function (hasPage) {
                    if (!hasPage) {
                        return _this.getRedirectUrl();
                    }
                    // TODO(#9385): Use CMS page guard here.
                    return hasPage;
                }));
            }));
        };
        LogoutGuard.prototype.logout = function () {
            return this.auth.coreLogout();
        };
        /**
         * Whenever there is no specific "logout" page configured in the CMS,
         * we redirect after the user is logged out.
         *
         * The user gets redirected to the homepage, unless the homepage is protected
         * (in case of a closed shop). We'll redirect to the login page instead.
         */
        LogoutGuard.prototype.getRedirectUrl = function () {
            var cxRoute = this.protectedRoutes.shouldProtect ? 'login' : 'home';
            return this.router.parseUrl(this.semanticPathService.get(cxRoute));
        };
        return LogoutGuard;
    }());
    LogoutGuard.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: LogoutGuard, deps: [{ token: i1__namespace.AuthService }, { token: i1__namespace.CmsService }, { token: i1__namespace.SemanticPathService }, { token: i1__namespace.ProtectedRoutesService }, { token: i1__namespace$1.Router }, { token: i1__namespace.AuthRedirectService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    LogoutGuard.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: LogoutGuard, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: LogoutGuard, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace.AuthService }, { type: i1__namespace.CmsService }, { type: i1__namespace.SemanticPathService }, { type: i1__namespace.ProtectedRoutesService }, { type: i1__namespace$1.Router }, { type: i1__namespace.AuthRedirectService }]; } });

    var LogoutModule = /** @class */ (function () {
        function LogoutModule() {
        }
        return LogoutModule;
    }());
    LogoutModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: LogoutModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    LogoutModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: LogoutModule, imports: [PageLayoutModule, i1__namespace$1.RouterModule] });
    LogoutModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: LogoutModule, imports: [[
                PageLayoutModule,
                i1$1.RouterModule.forChild([
                    {
                        path: null,
                        canActivate: [LogoutGuard, CmsPageGuard],
                        component: PageLayoutComponent,
                        data: { cxRoute: 'logout' },
                    },
                ]),
            ]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: LogoutModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [
                            PageLayoutModule,
                            i1$1.RouterModule.forChild([
                                {
                                    path: null,
                                    canActivate: [LogoutGuard, CmsPageGuard],
                                    component: PageLayoutComponent,
                                    data: { cxRoute: 'logout' },
                                },
                            ]),
                        ],
                    }]
            }] });

    var UserComponentModule = /** @class */ (function () {
        function UserComponentModule() {
        }
        return UserComponentModule;
    }());
    UserComponentModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserComponentModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    UserComponentModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserComponentModule, imports: [LogoutModule,
            LoginRouteModule,
            i3$1.ReactiveFormsModule,
            i1$1.RouterModule,
            i1.UrlModule] });
    UserComponentModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserComponentModule, imports: [[
                LogoutModule,
                LoginRouteModule,
                i3$1.ReactiveFormsModule,
                i1$1.RouterModule,
                i1.UrlModule,
            ]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserComponentModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [
                            LogoutModule,
                            LoginRouteModule,
                            i3$1.ReactiveFormsModule,
                            i1$1.RouterModule,
                            i1.UrlModule,
                        ],
                    }]
            }] });

    var WishListItemComponent = /** @class */ (function () {
        function WishListItemComponent() {
            this.isLoading = false;
            this.remove = new i0.EventEmitter();
        }
        WishListItemComponent.prototype.removeEntry = function (item) {
            this.remove.emit(item);
        };
        return WishListItemComponent;
    }());
    WishListItemComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: WishListItemComponent, deps: [], target: i0__namespace.ɵɵFactoryTarget.Component });
    WishListItemComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: WishListItemComponent, selector: "cx-wish-list-item", inputs: { isLoading: "isLoading", cartEntry: "cartEntry" }, outputs: { remove: "remove" }, ngImport: i0__namespace, template: "<div class=\"row\">\n  <!-- Item Image -->\n  <div class=\"cx-image-container col-2\">\n    <a\n      [routerLink]=\"{ cxRoute: 'product', params: cartEntry.product } | cxUrl\"\n      tabindex=\"-1\"\n    >\n      <cx-media\n        [container]=\"cartEntry.product.images?.PRIMARY\"\n        format=\"thumbnail\"\n      ></cx-media>\n    </a>\n  </div>\n  <!-- Item Information -->\n  <div class=\"cx-info col-10\">\n    <div class=\"cx-info-container row\">\n      <!-- Item Description -->\n      <div class=\"col-md-5 col-lg-5 col-xl-5\">\n        <div *ngIf=\"cartEntry.product.name\" class=\"cx-name\">\n          <a\n            class=\"cx-link\"\n            [routerLink]=\"\n              { cxRoute: 'product', params: cartEntry.product } | cxUrl\n            \"\n            ><h2>{{ cartEntry.product.name }}</h2></a\n          >\n        </div>\n        <div *ngIf=\"cartEntry.product.code\" class=\"cx-code\">\n          {{ 'cartItems.id' | cxTranslate }} {{ cartEntry.product.code }}\n        </div>\n        <!-- Variants -->\n        <ng-container *ngIf=\"cartEntry.product.baseOptions?.length\">\n          <div\n            *ngFor=\"\n              let variant of cartEntry.product.baseOptions[0]?.selected\n                ?.variantOptionQualifiers\n            \"\n            class=\"cx-property\"\n          >\n            <div class=\"cx-label\" *ngIf=\"variant.name && variant.value\">\n              {{ variant.name }}: {{ variant.value }}\n            </div>\n          </div>\n        </ng-container>\n      </div>\n      <!-- Item Price -->\n      <div\n        *ngIf=\"cartEntry.basePrice\"\n        class=\"cx-price col-md-3 col-lg-4 col-xl-4\"\n      >\n        <div class=\"cx-label d-block d-md-none d-lg-none d-xl-none\">\n          {{ 'cartItems.itemPrice' | cxTranslate }}\n        </div>\n        <div *ngIf=\"cartEntry.basePrice\" class=\"cx-value\">\n          {{ cartEntry.basePrice?.formattedValue }}\n        </div>\n      </div>\n      <!-- Total -->\n      <div class=\"col-sm-8 col-md-4 col-lg-3 col-xl-3 cx-add-to-cart\">\n        <cx-add-to-cart\n          *ngIf=\"\n            cartEntry.product.stock.stockLevelStatus !== 'outOfStock';\n            else outOfStock\n          \"\n          [showQuantity]=\"false\"\n          [product]=\"cartEntry.product\"\n        ></cx-add-to-cart>\n        <ng-template #outOfStock>\n          <span class=\"cx-out-of-stock\">\n            {{ 'addToCart.outOfStock' | cxTranslate }}\n          </span>\n        </ng-template>\n      </div>\n    </div>\n    <div class=\"cx-return-button col-12\">\n      <button\n        class=\"btn cx-action-link\"\n        (click)=\"removeEntry(cartEntry)\"\n        [disabled]=\"isLoading\"\n      >\n        {{ 'common.remove' | cxTranslate }}\n      </button>\n    </div>\n  </div>\n</div>\n", components: [{ type: MediaComponent, selector: "cx-media", inputs: ["container", "format", "alt", "role", "loading"], outputs: ["loaded"] }, { type: AddToCartComponent, selector: "cx-add-to-cart", inputs: ["productCode", "showQuantity", "product"] }], directives: [{ type: i1__namespace$1.RouterLinkWithHref, selector: "a[routerLink],area[routerLink]", inputs: ["routerLink", "target", "queryParams", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange", "replaceUrl", "state", "relativeTo"] }, { type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3__namespace.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], pipes: { "cxUrl": i1__namespace.UrlPipe, "cxTranslate": i1__namespace.TranslatePipe }, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: WishListItemComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-wish-list-item',
                        templateUrl: './wish-list-item.component.html',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], propDecorators: { isLoading: [{
                    type: i0.Input
                }], cartEntry: [{
                    type: i0.Input
                }], remove: [{
                    type: i0.Output
                }] } });

    var WishListComponent = /** @class */ (function () {
        function WishListComponent(wishListService) {
            this.wishListService = wishListService;
            this.wishList$ = this.wishListService.getWishList();
            this.loading$ = this.wishListService.getWishListLoading();
        }
        WishListComponent.prototype.removeEntry = function (item) {
            this.wishListService.removeEntry(item);
        };
        return WishListComponent;
    }());
    WishListComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: WishListComponent, deps: [{ token: i1__namespace.WishListService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    WishListComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: WishListComponent, selector: "cx-wish-list", ngImport: i0__namespace, template: "<ng-container *ngIf=\"wishList$ | async as wishList\">\n  <ng-container *ngIf=\"wishList?.entries?.length > 0; else emptyWishList\">\n    <div class=\"d-none d-md-block d-lg-block d-xl-block\">\n      <div class=\"cx-item-list-header row\">\n        <div class=\"cx-item-list-desc col-md-7 col-lg-6 col-xl-6\">\n          {{ 'cartItems.description' | cxTranslate }}\n        </div>\n        <div class=\"cx-item-list-price col-md-3 col-lg-4 col-xl-4\">\n          {{ 'cartItems.itemPrice' | cxTranslate }}\n        </div>\n        <div class=\"cx-item-list-total col-md-2 col-lg-2 col-xl-2\">\n          {{ 'cartItems.total' | cxTranslate }}\n        </div>\n      </div>\n    </div>\n\n    <div class=\"cx-item-list-row\" *ngFor=\"let entry of wishList?.entries\">\n      <cx-wish-list-item\n        [cartEntry]=\"entry\"\n        [isLoading]=\"loading$ | async\"\n        class=\"cx-wish-list-items\"\n        (remove)=\"removeEntry($event)\"\n      ></cx-wish-list-item>\n    </div>\n  </ng-container>\n</ng-container>\n\n<ng-template #emptyWishList>\n  <h2>{{ 'wishlist.empty' | cxTranslate }}</h2>\n</ng-template>\n", components: [{ type: WishListItemComponent, selector: "cx-wish-list-item", inputs: ["isLoading", "cartEntry"], outputs: ["remove"] }], directives: [{ type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3__namespace.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], pipes: { "async": i3__namespace.AsyncPipe, "cxTranslate": i1__namespace.TranslatePipe } });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: WishListComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-wish-list',
                        templateUrl: './wish-list.component.html',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace.WishListService }]; } });

    var WishListModule = /** @class */ (function () {
        function WishListModule() {
        }
        return WishListModule;
    }());
    WishListModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: WishListModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    WishListModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: WishListModule, declarations: [WishListComponent, WishListItemComponent], imports: [AddToCartModule,
            i3.CommonModule,
            i1.I18nModule,
            MediaModule,
            i1$1.RouterModule,
            StarRatingModule,
            i1.UrlModule,
            ItemCounterModule], exports: [WishListComponent, WishListItemComponent] });
    WishListModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: WishListModule, providers: [
            i1.provideDefaultConfig({
                cmsComponents: {
                    WishListComponent: {
                        component: WishListComponent,
                        guards: [i1.AuthGuard],
                    },
                },
            }),
        ], imports: [[
                AddToCartModule,
                i3.CommonModule,
                i1.I18nModule,
                MediaModule,
                i1$1.RouterModule,
                StarRatingModule,
                i1.UrlModule,
                ItemCounterModule,
            ]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: WishListModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [
                            AddToCartModule,
                            i3.CommonModule,
                            i1.I18nModule,
                            MediaModule,
                            i1$1.RouterModule,
                            StarRatingModule,
                            i1.UrlModule,
                            ItemCounterModule,
                        ],
                        providers: [
                            i1.provideDefaultConfig({
                                cmsComponents: {
                                    WishListComponent: {
                                        component: WishListComponent,
                                        guards: [i1.AuthGuard],
                                    },
                                },
                            }),
                        ],
                        declarations: [WishListComponent, WishListItemComponent],
                        exports: [WishListComponent, WishListItemComponent],
                    }]
            }] });

    function getProductDetailsUrlMatcherFactory(service, defaultMatcherFactory) {
        var factory = function (route) {
            var defaultMatcher = defaultMatcherFactory(route);
            var suffixPDPMatcher = getSuffixUrlMatcher({
                marker: 'p',
                paramName: 'productCode',
            });
            return service.getCombined([defaultMatcher, suffixPDPMatcher]);
        };
        return factory;
    }
    /**
     * Injection token with url matcher factory for PDP.
     * The provided url matcher matches both:
     * - the configured `paths` from routing config and
     * - custom pattern  `** / p / :productCode`
     *
     * If the this matcher doesn't fit the requirements, it can be replaced with the DEFAULT_URL_MATCHER
     * or additional matchers can be added for a specific route.
     *
     * Note: Matchers will "match" a route, but do not contribute to the creation of the route, nor do they guard routes.
     */
    var PRODUCT_DETAILS_URL_MATCHER = new i0.InjectionToken('PRODUCT_DETAILS_URL_MATCHER', {
        providedIn: 'root',
        factory: function () { return getProductDetailsUrlMatcherFactory(i0.inject(i1.UrlMatcherService), i0.inject(i1.DEFAULT_URL_MATCHER)); },
    });

    var ProductDetailsPageModule = /** @class */ (function () {
        function ProductDetailsPageModule() {
        }
        return ProductDetailsPageModule;
    }());
    ProductDetailsPageModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductDetailsPageModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    ProductDetailsPageModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductDetailsPageModule, imports: [i1__namespace$1.RouterModule] });
    ProductDetailsPageModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductDetailsPageModule, providers: [
            i1.provideDefaultConfig({
                routing: {
                    routes: {
                        product: {
                            matchers: [PRODUCT_DETAILS_URL_MATCHER],
                        },
                    },
                },
            }),
        ], imports: [[
                i1$1.RouterModule.forChild([
                    {
                        path: null,
                        canActivate: [CmsPageGuard],
                        component: PageLayoutComponent,
                        data: { cxRoute: 'product' },
                    },
                ]),
            ]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductDetailsPageModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [
                            i1$1.RouterModule.forChild([
                                {
                                    path: null,
                                    canActivate: [CmsPageGuard],
                                    component: PageLayoutComponent,
                                    data: { cxRoute: 'product' },
                                },
                            ]),
                        ],
                        providers: [
                            i1.provideDefaultConfig({
                                routing: {
                                    routes: {
                                        product: {
                                            matchers: [PRODUCT_DETAILS_URL_MATCHER],
                                        },
                                    },
                                },
                            }),
                        ],
                    }]
            }] });

    function getProductListingUrlMatcherFactory(service, defaultMatcherFactory) {
        var factory = function (route) {
            var defaultMatcher = defaultMatcherFactory(route);
            var suffixPLPMatcher = getSuffixUrlMatcher({
                marker: 'c',
                paramName: 'categoryCode',
            });
            return service.getCombined([defaultMatcher, suffixPLPMatcher]);
        };
        return factory;
    }
    /**
     * Injection token with url matcher factory for PLP.
     * The provided url matcher matches both:
     * - the configured `paths` from routing config and
     * - custom pattern  `** / c / :categoryCode`
     *
     * If the this matcher doesn't fit the requirements, it can be replaced with the DEFAULT_URL_MATCHER
     * or additional matchers can be added for a specific route.
     *
     * Note: Matchers will "match" a route, but do not contribute to the creation of the route, nor do they guard routes.
     */
    var PRODUCT_LISTING_URL_MATCHER = new i0.InjectionToken('PRODUCT_LISTING_URL_MATCHER', {
        providedIn: 'root',
        factory: function () { return getProductListingUrlMatcherFactory(i0.inject(i1.UrlMatcherService), i0.inject(i1.DEFAULT_URL_MATCHER)); },
    });

    var ProductListingPageModule = /** @class */ (function () {
        function ProductListingPageModule() {
        }
        return ProductListingPageModule;
    }());
    ProductListingPageModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductListingPageModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    ProductListingPageModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductListingPageModule, imports: [i1__namespace$1.RouterModule] });
    ProductListingPageModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductListingPageModule, providers: [
            i1.provideDefaultConfig({
                routing: {
                    routes: {
                        category: {
                            matchers: [PRODUCT_LISTING_URL_MATCHER],
                        },
                    },
                },
            }),
        ], imports: [[
                i1$1.RouterModule.forChild([
                    {
                        path: null,
                        canActivate: [CmsPageGuard],
                        component: PageLayoutComponent,
                        data: { pageLabel: 'search', cxRoute: 'search' },
                    },
                    {
                        path: null,
                        canActivate: [CmsPageGuard],
                        component: PageLayoutComponent,
                        data: { cxRoute: 'brand' },
                    },
                    {
                        // The 'category' route  may include a greedy suffix url matcher '**/c/:categoryCode'
                        // So not to shadow the specific 'brand' route, the 'category' is the last route in the sequence.
                        path: null,
                        canActivate: [CmsPageGuard],
                        component: PageLayoutComponent,
                        data: { cxRoute: 'category' },
                    },
                ]),
            ]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductListingPageModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [
                            i1$1.RouterModule.forChild([
                                {
                                    path: null,
                                    canActivate: [CmsPageGuard],
                                    component: PageLayoutComponent,
                                    data: { pageLabel: 'search', cxRoute: 'search' },
                                },
                                {
                                    path: null,
                                    canActivate: [CmsPageGuard],
                                    component: PageLayoutComponent,
                                    data: { cxRoute: 'brand' },
                                },
                                {
                                    // The 'category' route  may include a greedy suffix url matcher '**/c/:categoryCode'
                                    // So not to shadow the specific 'brand' route, the 'category' is the last route in the sequence.
                                    path: null,
                                    canActivate: [CmsPageGuard],
                                    component: PageLayoutComponent,
                                    data: { cxRoute: 'category' },
                                },
                            ]),
                        ],
                        providers: [
                            i1.provideDefaultConfig({
                                routing: {
                                    routes: {
                                        category: {
                                            matchers: [PRODUCT_LISTING_URL_MATCHER],
                                        },
                                    },
                                },
                            }),
                        ],
                    }]
            }] });

    /**
     * Resolves the context for the specific route, based on the property `data.cxContext`
     * defined in the Angular Route.
     */
    var RoutingContextService = /** @class */ (function () {
        function RoutingContextService(activatedRoutesService, injector) {
            var _this = this;
            this.activatedRoutesService = activatedRoutesService;
            this.injector = injector;
            /**
             * Combined context token mapping consisting of all mappings defined in currently
             * Activated Angular Routes.
             *
             * The context token mapping is read from each Route's property `data.cxContext`.
             */
            this.contextTokenMapping$ = this.activatedRoutesService.routes$.pipe(operators.map(function (routes) { return _this.getRoutesContextTokenMapping(routes); }), operators.shareReplay({ refCount: true, bufferSize: 1 }));
        }
        /**
         * Returns the merged context token mapping, consisting of mappings
         * defined in all Activated Angular Routes.
         */
        RoutingContextService.prototype.getRoutesContextTokenMapping = function (routes) {
            return Object.assign.apply(Object, __spreadArray([{}], __read(routes.map(function (route) { var _a; return (_a = route === null || route === void 0 ? void 0 : route.data) === null || _a === void 0 ? void 0 : _a.cxContext; }))));
        };
        /**
         * Resolves the specified `contextToken` from `cxContext` data parameter of the activated Angular Routes.
         * @param contextToken
         *
         * @returns instance from the root injector if defined, otherwise `undefined`.
         */
        RoutingContextService.prototype.get = function (contextToken) {
            var _this = this;
            return this.contextTokenMapping$.pipe(operators.map(function (contextMapping) {
                var providerToken = contextMapping === null || contextMapping === void 0 ? void 0 : contextMapping[
                // TODO: remove 'as any' after upgrading TypeScript to v4.4
                // See: https://github.com/Microsoft/TypeScript/issues/24587
                contextToken];
                return _this.injector.get(providerToken, undefined);
            }));
        };
        return RoutingContextService;
    }());
    RoutingContextService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: RoutingContextService, deps: [{ token: i1__namespace.ActivatedRoutesService }, { token: i0__namespace.Injector }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    RoutingContextService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: RoutingContextService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: RoutingContextService, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }], ctorParameters: function () { return [{ type: i1__namespace.ActivatedRoutesService }, { type: i0__namespace.Injector }]; } });

    /**
     * Generic service for resolving the context for the UI components.
     */
    var ContextService = /** @class */ (function () {
        function ContextService(routingContextService) {
            this.routingContextService = routingContextService;
        }
        /**
         * Returns the context for the given token.
         */
        ContextService.prototype.get = function (contextToken) {
            return this.resolveContext(contextToken).pipe(operators.distinctUntilChanged(), operators.shareReplay({ refCount: true, bufferSize: 1 }));
        };
        /**
         * Resolves the context for the given token.
         */
        ContextService.prototype.resolveContext = function (contextToken) {
            return this.routingContextService.get(contextToken);
        };
        return ContextService;
    }());
    ContextService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ContextService, deps: [{ token: RoutingContextService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ContextService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ContextService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ContextService, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }], ctorParameters: function () { return [{ type: RoutingContextService }]; } });

    /**
     * Indicates that a user navigated to an arbitrary page.
     */
    var NavigationEvent = /** @class */ (function (_super) {
        __extends(NavigationEvent, _super);
        function NavigationEvent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return NavigationEvent;
    }(i1.CxEvent));
    /**
     * Event's type
     */
    NavigationEvent.type = 'NavigationEvent';

    /**
     * Indicates that a user visited an arbitrary page.
     */
    var PageEvent = /** @class */ (function (_super) {
        __extends(PageEvent, _super);
        function PageEvent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return PageEvent;
    }(i1.CxEvent));

    /**
     * Indicates that a user visited a cart page.
     */
    var CartPageEvent = /** @class */ (function (_super) {
        __extends(CartPageEvent, _super);
        function CartPageEvent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return CartPageEvent;
    }(PageEvent));
    /** event's type */
    CartPageEvent.type = 'CartPageEvent';

    var CartPageEventBuilder = /** @class */ (function () {
        function CartPageEventBuilder(eventService) {
            this.eventService = eventService;
            this.register();
        }
        CartPageEventBuilder.prototype.register = function () {
            this.eventService.register(CartPageEvent, this.buildCartPageEvent());
        };
        CartPageEventBuilder.prototype.buildCartPageEvent = function () {
            return this.eventService.get(NavigationEvent).pipe(operators.filter(function (navigationEvent) { return navigationEvent.semanticRoute === 'cart'; }), operators.map(function (navigationEvent) { return i1.createFrom(CartPageEvent, {
                navigation: navigationEvent,
            }); }));
        };
        return CartPageEventBuilder;
    }());
    CartPageEventBuilder.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartPageEventBuilder, deps: [{ token: i1__namespace.EventService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    CartPageEventBuilder.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartPageEventBuilder, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartPageEventBuilder, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace.EventService }]; } });

    var CartPageEventModule = /** @class */ (function () {
        function CartPageEventModule(_cartPageEventBuilder) {
        }
        return CartPageEventModule;
    }());
    CartPageEventModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartPageEventModule, deps: [{ token: CartPageEventBuilder }], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    CartPageEventModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartPageEventModule });
    CartPageEventModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartPageEventModule });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartPageEventModule, decorators: [{
                type: i0.NgModule,
                args: [{}]
            }], ctorParameters: function () { return [{ type: CartPageEventBuilder }]; } });

    /**
     * Indicates that a user visited a home page.
     */
    var HomePageEvent = /** @class */ (function (_super) {
        __extends(HomePageEvent, _super);
        function HomePageEvent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return HomePageEvent;
    }(PageEvent));
    /** event's type */
    HomePageEvent.type = 'HomePageEvent';

    var HomePageEventBuilder = /** @class */ (function () {
        function HomePageEventBuilder(eventService) {
            this.eventService = eventService;
            this.register();
        }
        HomePageEventBuilder.prototype.register = function () {
            this.eventService.register(HomePageEvent, this.buildHomePageEvent());
        };
        HomePageEventBuilder.prototype.buildHomePageEvent = function () {
            return this.eventService.get(NavigationEvent).pipe(operators.filter(function (navigationEvent) { return navigationEvent.semanticRoute === 'home'; }), operators.map(function (navigationEvent) { return i1.createFrom(HomePageEvent, {
                navigation: navigationEvent,
            }); }));
        };
        return HomePageEventBuilder;
    }());
    HomePageEventBuilder.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: HomePageEventBuilder, deps: [{ token: i1__namespace.EventService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    HomePageEventBuilder.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: HomePageEventBuilder, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: HomePageEventBuilder, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace.EventService }]; } });

    var HomePageEventModule = /** @class */ (function () {
        function HomePageEventModule(_homePageEventBuilder) {
        }
        return HomePageEventModule;
    }());
    HomePageEventModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: HomePageEventModule, deps: [{ token: HomePageEventBuilder }], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    HomePageEventModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: HomePageEventModule });
    HomePageEventModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: HomePageEventModule });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: HomePageEventModule, decorators: [{
                type: i0.NgModule,
                args: [{}]
            }], ctorParameters: function () { return [{ type: HomePageEventBuilder }]; } });

    /**
     * A builder for the NavigationEvent
     */
    var NavigationEventBuilder = /** @class */ (function () {
        function NavigationEventBuilder(actions, eventService) {
            this.actions = actions;
            this.eventService = eventService;
            this.register();
        }
        /**
         * Registers events
         */
        NavigationEventBuilder.prototype.register = function () {
            this.eventService.register(NavigationEvent, this.buildNavigationEvent());
        };
        /**
         * Builds the navigation events
         */
        NavigationEventBuilder.prototype.buildNavigationEvent = function () {
            return this.getNavigatedEvent().pipe(operators.map(function (state) { return i1.createFrom(NavigationEvent, {
                context: state.context,
                semanticRoute: state.semanticRoute,
                url: state.url,
                params: state.params,
            }); }));
        };
        NavigationEventBuilder.prototype.getNavigatedEvent = function () {
            return this.actions.pipe(effects.ofType(routerStore.ROUTER_NAVIGATED), operators.map(function (event) { return event.payload.routerState; }));
        };
        return NavigationEventBuilder;
    }());
    NavigationEventBuilder.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: NavigationEventBuilder, deps: [{ token: i1__namespace$5.ActionsSubject }, { token: i1__namespace.EventService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    NavigationEventBuilder.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: NavigationEventBuilder, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: NavigationEventBuilder, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace$5.ActionsSubject }, { type: i1__namespace.EventService }]; } });

    var NavigationEventModule = /** @class */ (function () {
        function NavigationEventModule(_navigationEventBuilder) {
        }
        return NavigationEventModule;
    }());
    NavigationEventModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: NavigationEventModule, deps: [{ token: NavigationEventBuilder }], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    NavigationEventModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: NavigationEventModule });
    NavigationEventModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: NavigationEventModule });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: NavigationEventModule, decorators: [{
                type: i0.NgModule,
                args: [{}]
            }], ctorParameters: function () { return [{ type: NavigationEventBuilder }]; } });

    /**
     * Indicates that a user visited a product details page.
     */
    var ProductDetailsPageEvent = /** @class */ (function (_super) {
        __extends(ProductDetailsPageEvent, _super);
        function ProductDetailsPageEvent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return ProductDetailsPageEvent;
    }(PageEvent));
    /** event's type */
    ProductDetailsPageEvent.type = 'ProductDetailsPageEvent';
    /**
     * Indicates that a user visited a category page.
     */
    var CategoryPageResultsEvent = /** @class */ (function (_super) {
        __extends(CategoryPageResultsEvent, _super);
        function CategoryPageResultsEvent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return CategoryPageResultsEvent;
    }(PageEvent));
    /** event's type */
    CategoryPageResultsEvent.type = 'CategoryPageResultsEvent';
    /**
     * Indicates that the a user visited the search results page,
     * and that the search results have been retrieved.
     */
    var SearchPageResultsEvent = /** @class */ (function (_super) {
        __extends(SearchPageResultsEvent, _super);
        function SearchPageResultsEvent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return SearchPageResultsEvent;
    }(PageEvent));
    /** event's type */
    SearchPageResultsEvent.type = 'SearchPageResultsEvent';

    var ProductPageEventBuilder = /** @class */ (function () {
        function ProductPageEventBuilder(eventService, productService, productSearchService) {
            this.eventService = eventService;
            this.productService = productService;
            this.productSearchService = productSearchService;
            this.register();
        }
        ProductPageEventBuilder.prototype.register = function () {
            this.eventService.register(SearchPageResultsEvent, this.buildSearchPageResultsEvent());
            this.eventService.register(ProductDetailsPageEvent, this.buildProductDetailsPageEvent());
            this.eventService.register(CategoryPageResultsEvent, this.buildCategoryResultsPageEvent());
        };
        ProductPageEventBuilder.prototype.buildProductDetailsPageEvent = function () {
            var _this = this;
            return this.eventService.get(NavigationEvent).pipe(operators.filter(function (navigationEvent) { return navigationEvent.semanticRoute === 'product'; }), operators.switchMap(function (navigationEvent) { return _this.productService.get(navigationEvent.context.id).pipe(operators.filter(function (product) { return Boolean(product); }), operators.take(1), operators.map(function (product) { return i1.createFrom(ProductDetailsPageEvent, {
                navigation: navigationEvent,
                categories: product.categories,
                code: product.code,
                name: product.name,
                price: product.price,
            }); })); }));
        };
        ProductPageEventBuilder.prototype.buildCategoryResultsPageEvent = function () {
            var searchResults$ = this.productSearchService.getResults().pipe(
            // skipping the initial value, and preventing emission of the previous search state
            operators.skip(1));
            return this.eventService.get(NavigationEvent).pipe(operators.switchMap(function (navigationEvent) {
                if ((navigationEvent === null || navigationEvent === void 0 ? void 0 : navigationEvent.semanticRoute) !== 'category') {
                    return rxjs.EMPTY;
                }
                return searchResults$.pipe(operators.map(function (searchResults) {
                    var _a, _b, _c, _d;
                    return i1.createFrom(CategoryPageResultsEvent, Object.assign({ navigation: navigationEvent }, {
                        categoryCode: (_a = navigationEvent === null || navigationEvent === void 0 ? void 0 : navigationEvent.context) === null || _a === void 0 ? void 0 : _a.id,
                        numberOfResults: (_c = (_b = searchResults === null || searchResults === void 0 ? void 0 : searchResults.pagination) === null || _b === void 0 ? void 0 : _b.totalResults) !== null && _c !== void 0 ? _c : 0,
                        categoryName: (_d = searchResults.breadcrumbs) === null || _d === void 0 ? void 0 : _d[0].facetValueName,
                    }));
                }));
            }));
        };
        ProductPageEventBuilder.prototype.buildSearchPageResultsEvent = function () {
            var searchResults$ = this.productSearchService.getResults().pipe(
            // skipping the initial value, and preventing emission of the previous search state
            operators.skip(1));
            return this.eventService.get(NavigationEvent).pipe(operators.switchMap(function (navigationEvent) {
                if ((navigationEvent === null || navigationEvent === void 0 ? void 0 : navigationEvent.semanticRoute) !== 'search') {
                    return rxjs.EMPTY;
                }
                return searchResults$.pipe(operators.map(function (searchResults) {
                    var _a, _b, _c;
                    return i1.createFrom(SearchPageResultsEvent, Object.assign({ navigation: navigationEvent }, {
                        searchTerm: (_a = searchResults === null || searchResults === void 0 ? void 0 : searchResults.freeTextSearch) !== null && _a !== void 0 ? _a : '',
                        numberOfResults: (_c = (_b = searchResults === null || searchResults === void 0 ? void 0 : searchResults.pagination) === null || _b === void 0 ? void 0 : _b.totalResults) !== null && _c !== void 0 ? _c : 0,
                    }));
                }));
            }));
        };
        return ProductPageEventBuilder;
    }());
    ProductPageEventBuilder.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductPageEventBuilder, deps: [{ token: i1__namespace.EventService }, { token: i1__namespace.ProductService }, { token: i1__namespace.ProductSearchService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ProductPageEventBuilder.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductPageEventBuilder, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductPageEventBuilder, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace.EventService }, { type: i1__namespace.ProductService }, { type: i1__namespace.ProductSearchService }]; } });

    var ProductPageEventModule = /** @class */ (function () {
        function ProductPageEventModule(_productPageEventBuilder) {
        }
        return ProductPageEventModule;
    }());
    ProductPageEventModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductPageEventModule, deps: [{ token: ProductPageEventBuilder }], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    ProductPageEventModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductPageEventModule });
    ProductPageEventModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductPageEventModule });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductPageEventModule, decorators: [{
                type: i0.NgModule,
                args: [{}]
            }], ctorParameters: function () { return [{ type: ProductPageEventBuilder }]; } });

    var SkipLinkConfig = /** @class */ (function () {
        function SkipLinkConfig() {
        }
        return SkipLinkConfig;
    }());
    SkipLinkConfig.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SkipLinkConfig, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    SkipLinkConfig.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SkipLinkConfig, providedIn: 'root', useExisting: i1.Config });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SkipLinkConfig, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                        useExisting: i1.Config,
                    }]
            }] });
    var SkipLink = /** @class */ (function () {
        function SkipLink() {
        }
        return SkipLink;
    }());
    exports.SkipLinkScrollPosition = void 0;
    (function (SkipLinkScrollPosition) {
        SkipLinkScrollPosition["BEFORE"] = "BEFORE";
        SkipLinkScrollPosition["AFTER"] = "AFTER";
    })(exports.SkipLinkScrollPosition || (exports.SkipLinkScrollPosition = {}));

    var SkipLinkService = /** @class */ (function () {
        function SkipLinkService(config, keyboardFocusService) {
            this.config = config;
            this.keyboardFocusService = keyboardFocusService;
            this.skipLinks$ = new rxjs.BehaviorSubject([]);
        }
        SkipLinkService.prototype.getSkipLinks = function () {
            return this.skipLinks$;
        };
        SkipLinkService.prototype.add = function (key, target) {
            var found = this.config.skipLinks.find(function (skipLink) { return skipLink.key === key; });
            if (found) {
                var existing = this.skipLinks$.value;
                existing.splice(this.getSkipLinkIndexInArray(key), 0, {
                    target: target,
                    i18nKey: found.i18nKey,
                    position: found.position,
                    key: key,
                });
                this.skipLinks$.next(existing);
            }
        };
        SkipLinkService.prototype.remove = function (key) {
            var found = this.config.skipLinks.find(function (skipLink) { return skipLink.key === key; });
            if (found) {
                var existing = this.skipLinks$.value;
                existing = existing.filter(function (skipLink) { return skipLink.key !== key; });
                this.skipLinks$.next(existing);
            }
        };
        SkipLinkService.prototype.scrollToTarget = function (skipLink) {
            var target = skipLink.target instanceof HTMLElement
                ? skipLink.target
                : skipLink.target.parentElement;
            // focus first focusable element in the
            var firstFocusable = this.keyboardFocusService.findFirstFocusable(target) || target;
            // we force a tabindex if not available, to ensure we can focus into the element
            var hasTabindex = firstFocusable.hasAttribute('tabindex');
            if (!hasTabindex) {
                firstFocusable.setAttribute('tabindex', '-1');
            }
            firstFocusable.focus();
            // drop the tmp tabindex
            if (!hasTabindex) {
                firstFocusable.removeAttribute('tabindex');
            }
        };
        SkipLinkService.prototype.getSkipLinkIndexInArray = function (key) {
            var index = this.config.skipLinks.findIndex(function (skipLink) { return skipLink.key === key; });
            var _loop_1 = function () {
                index--;
                var previous = this_1.config.skipLinks[index];
                if (previous) {
                    var existing = this_1.skipLinks$.value;
                    var found = existing.findIndex(function (skipLink) { return skipLink.key === previous.key; });
                    if (found > -1) {
                        return { value: found + 1 };
                    }
                }
            };
            var this_1 = this;
            while (index > 0) {
                var state_1 = _loop_1();
                if (typeof state_1 === "object")
                    return state_1.value;
            }
            return 0;
        };
        return SkipLinkService;
    }());
    SkipLinkService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SkipLinkService, deps: [{ token: SkipLinkConfig }, { token: KeyboardFocusService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    SkipLinkService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SkipLinkService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SkipLinkService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: SkipLinkConfig }, { type: KeyboardFocusService }]; } });

    var SkipLinkComponent = /** @class */ (function () {
        function SkipLinkComponent(skipLinkService) {
            this.skipLinkService = skipLinkService;
            this.skipLinks$ = this.skipLinkService.getSkipLinks();
        }
        SkipLinkComponent.prototype.scrollToTarget = function (skipLink) {
            this.skipLinkService.scrollToTarget(skipLink);
        };
        return SkipLinkComponent;
    }());
    SkipLinkComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SkipLinkComponent, deps: [{ token: SkipLinkService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    SkipLinkComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: SkipLinkComponent, selector: "cx-skip-link", ngImport: i0__namespace, template: "<div [cxFocus]=\"{ tab: true }\" *ngIf=\"skipLinks$ | async as links\">\n  <button *ngFor=\"let link of links\" (click)=\"scrollToTarget(link)\">\n    {{ 'skipLink.skipTo' | cxTranslate }}\n    {{ link.i18nKey | cxTranslate }}\n  </button>\n</div>\n", directives: [{ type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: FocusDirective, selector: "[cxFocus]", inputs: ["cxFocus"] }, { type: i3__namespace.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], pipes: { "async": i3__namespace.AsyncPipe, "cxTranslate": i1__namespace.TranslatePipe }, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SkipLinkComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-skip-link',
                        templateUrl: './skip-link.component.html',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], ctorParameters: function () { return [{ type: SkipLinkService }]; } });

    var defaultSkipLinkConfig = {
        skipLinks: [
            {
                key: 'cx-header',
                i18nKey: 'skipLink.labels.header',
            },
            {
                key: 'cx-main',
                i18nKey: 'skipLink.labels.main',
            },
            { key: 'cx-footer', i18nKey: 'skipLink.labels.footer' },
        ],
    };

    var SkipLinkDirective = /** @class */ (function () {
        function SkipLinkDirective(elementRef, skipLinkService) {
            this.elementRef = elementRef;
            this.skipLinkService = skipLinkService;
        }
        SkipLinkDirective.prototype.ngOnInit = function () {
            this.skipLinkService.add(this.cxSkipLink, this.elementRef.nativeElement);
        };
        SkipLinkDirective.prototype.ngOnDestroy = function () {
            this.skipLinkService.remove(this.cxSkipLink);
        };
        return SkipLinkDirective;
    }());
    SkipLinkDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SkipLinkDirective, deps: [{ token: i0__namespace.ElementRef }, { token: SkipLinkService }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    SkipLinkDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.5", type: SkipLinkDirective, selector: "[cxSkipLink]", inputs: { cxSkipLink: "cxSkipLink" }, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SkipLinkDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        selector: '[cxSkipLink]',
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ElementRef }, { type: SkipLinkService }]; }, propDecorators: { cxSkipLink: [{
                    type: i0.Input
                }] } });

    var SkipLinkModule = /** @class */ (function () {
        function SkipLinkModule() {
        }
        return SkipLinkModule;
    }());
    SkipLinkModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SkipLinkModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    SkipLinkModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SkipLinkModule, declarations: [SkipLinkComponent, SkipLinkDirective], imports: [i3.CommonModule,
            i1.I18nModule, i1__namespace.ConfigModule, KeyboardFocusModule], exports: [SkipLinkDirective] });
    SkipLinkModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SkipLinkModule, providers: [
            i1.provideDefaultConfig(defaultSkipLinkConfig),
            {
                provide: i0.APP_INITIALIZER,
                useFactory: skipLinkFactory,
                deps: [i0.ComponentFactoryResolver, OutletService],
                multi: true,
            },
        ], imports: [[
                i3.CommonModule,
                i1.I18nModule,
                i1.ConfigModule.withConfig(defaultSkipLinkConfig),
                KeyboardFocusModule,
            ]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SkipLinkModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [
                            i3.CommonModule,
                            i1.I18nModule,
                            i1.ConfigModule.withConfig(defaultSkipLinkConfig),
                            KeyboardFocusModule,
                        ],
                        declarations: [SkipLinkComponent, SkipLinkDirective],
                        exports: [SkipLinkDirective],
                        providers: [
                            i1.provideDefaultConfig(defaultSkipLinkConfig),
                            {
                                provide: i0.APP_INITIALIZER,
                                useFactory: skipLinkFactory,
                                deps: [i0.ComponentFactoryResolver, OutletService],
                                multi: true,
                            },
                        ],
                    }]
            }] });
    /**
     * Adds the skip link component before the cx-storefront.
     */
    function skipLinkFactory(componentFactoryResolver, outletService) {
        var isReady = function () {
            var factory = componentFactoryResolver.resolveComponentFactory(SkipLinkComponent);
            outletService.add('cx-storefront', factory, exports.OutletPosition.BEFORE);
        };
        return isReady;
    }

    var defaultLayoutConfig = {
        breakpoints: {
            xs: 576,
            sm: 768,
            md: 992,
            lg: 1200,
            xl: {
                min: 1200,
            },
        },
    };

    /**
     * The direction config provides an easy way to configure "ltr" versus "rtl" direction
     * for the storefront. The direction can be configured to detect the direction by language.
     *
     * The following configuration detects rtl languages by isoCode for Arabic and Hebrew:
     *
     * ```typescript
     * direction: {
     *   detect: true,
     *   default: DirectionMode.LTR,
     *   rtlLanguages: ['ar', 'he']
     * }
     * ```
     */
    var DirectionConfig = /** @class */ (function () {
        function DirectionConfig() {
        }
        return DirectionConfig;
    }());
    DirectionConfig.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: DirectionConfig, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    DirectionConfig.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: DirectionConfig, providedIn: 'root', useExisting: i1.Config });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: DirectionConfig, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                        useExisting: i1.Config,
                    }]
            }] });

    var defaultDirectionConfig = {
        direction: {
            detect: true,
            default: exports.DirectionMode.LTR,
            // we're not polluting the system with all defaults for ltr, but add 2 common used
            // languages (hebrew and arabic) to easily demo directionality
            // see https://meta.wikimedia.org/wiki/Template:List_of_language_names_ordered_by_code
            rtlLanguages: ['he', 'ar'],
        },
    };

    /**
     * The `DirectionService` can be used to add the direction to the overall storefront or individual elements.
     * By default, the direction is added to the `html` element (i.e. `<html dir="ltr">`). The API of this service
     * does however provide methods to add direction to individual elements if needed.
     *
     * The direction is configurable and allows for language driven direction configuration.
     *
     * To react to the active language, the service subscribes to the active language in the initialize method. This
     * is called from an APP_INITIALIZER method and should only happen once.
     */
    var DirectionService = /** @class */ (function () {
        function DirectionService(configInit, languageService, winRef) {
            this.configInit = configInit;
            this.languageService = languageService;
            this.winRef = winRef;
            this.startsDetecting = false;
            this.subscription = new rxjs.Subscription();
        }
        /**
         * Initializes the layout direction for the storefront.
         */
        DirectionService.prototype.initialize = function () {
            var _this = this;
            return this.configInit
                .getStable('direction')
                .pipe(operators.tap(function (config) {
                var _a, _b;
                _this.config = config === null || config === void 0 ? void 0 : config.direction;
                if ((_a = _this.config) === null || _a === void 0 ? void 0 : _a.detect) {
                    _this.detect();
                }
                else {
                    _this.setDirection(_this.winRef.document.documentElement, (_b = _this.config) === null || _b === void 0 ? void 0 : _b.default);
                }
            }))
                .toPromise();
        };
        /**
         * Observes the _active_ language and set the required direction for the given language.
         * The method is guarded to ensure that the active language is observed only once.
         */
        DirectionService.prototype.detect = function () {
            var _this = this;
            if (this.startsDetecting) {
                return;
            }
            this.subscription.add(this.languageService
                .getActive()
                .subscribe(function (isoCode) { return _this.setDirection(_this.winRef.document.documentElement, _this.getDirection(isoCode)); }));
            this.startsDetecting = true;
        };
        /**
         * Sets the direction attribute for the given element. If the direction is undefined, the `dir`
         * attribute is removed.
         */
        DirectionService.prototype.setDirection = function (el, direction) {
            if (direction) {
                el.setAttribute('dir', direction);
            }
            else {
                el.removeAttribute('dir');
            }
        };
        /**
         * Gets the `DirectionMode` for the given language isoCode. The language isoCode is compared
         * to the configured list of languages(`direction.rtlLanguages` vs `direction.ltrLanguages`).
         *
         * If no language is given, or no language mapping could be found, we fallback to the default
         * `direction.mode`.
         */
        DirectionService.prototype.getDirection = function (language) {
            var _a, _b, _c, _d, _e;
            if (language && ((_b = (_a = this.config) === null || _a === void 0 ? void 0 : _a.rtlLanguages) === null || _b === void 0 ? void 0 : _b.includes(language))) {
                return exports.DirectionMode.RTL;
            }
            if (language && ((_d = (_c = this.config) === null || _c === void 0 ? void 0 : _c.ltrLanguages) === null || _d === void 0 ? void 0 : _d.includes(language))) {
                return exports.DirectionMode.LTR;
            }
            return (_e = this.config) === null || _e === void 0 ? void 0 : _e.default;
        };
        DirectionService.prototype.ngOnDestroy = function () {
            // Cleans up the subscription, to avoid memory leaks in SSR.
            this.subscription.unsubscribe();
        };
        return DirectionService;
    }());
    DirectionService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: DirectionService, deps: [{ token: i1__namespace.ConfigInitializerService }, { token: i1__namespace.LanguageService }, { token: i1__namespace.WindowRef }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    DirectionService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: DirectionService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: DirectionService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace.ConfigInitializerService }, { type: i1__namespace.LanguageService }, { type: i1__namespace.WindowRef }]; } });

    function initHtmlDirAttribute(directionService, featureConfigService) {
        var result = function () {
            if (featureConfigService.isLevel('2.1')) {
                return directionService.initialize();
            }
        };
        return result;
    }
    /**
     * Provides a configuration and APP_INITIALIZER to add the correct (language drive) html direction.
     */
    var DirectionModule = /** @class */ (function () {
        function DirectionModule() {
        }
        return DirectionModule;
    }());
    DirectionModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: DirectionModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    DirectionModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: DirectionModule });
    DirectionModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: DirectionModule, providers: [
            {
                provide: i0.APP_INITIALIZER,
                multi: true,
                useFactory: initHtmlDirAttribute,
                deps: [DirectionService, i1.FeatureConfigService],
            },
            i1.provideDefaultConfig(defaultDirectionConfig),
        ] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: DirectionModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        providers: [
                            {
                                provide: i0.APP_INITIALIZER,
                                multi: true,
                                useFactory: initHtmlDirAttribute,
                                deps: [DirectionService, i1.FeatureConfigService],
                            },
                            i1.provideDefaultConfig(defaultDirectionConfig),
                        ],
                    }]
            }] });

    var HamburgerMenuComponent = /** @class */ (function () {
        function HamburgerMenuComponent(hamburgerMenuService) {
            this.hamburgerMenuService = hamburgerMenuService;
        }
        HamburgerMenuComponent.prototype.toggle = function () {
            this.hamburgerMenuService.toggle();
        };
        Object.defineProperty(HamburgerMenuComponent.prototype, "isExpanded", {
            get: function () {
                return this.hamburgerMenuService.isExpanded;
            },
            enumerable: false,
            configurable: true
        });
        return HamburgerMenuComponent;
    }());
    HamburgerMenuComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: HamburgerMenuComponent, deps: [{ token: HamburgerMenuService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    HamburgerMenuComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: HamburgerMenuComponent, selector: "cx-hamburger-menu", ngImport: i0__namespace, template: "<button\n  class=\"cx-hamburger\"\n  type=\"button\"\n  (click)=\"toggle()\"\n  [class.is-active]=\"isExpanded | async\"\n  [attr.aria-expanded]=\"isExpanded | async\"\n  [attr.aria-label]=\"'common.menu' | cxTranslate\"\n  aria-controls=\"header-account-container, header-categories-container, header-locale-container\"\n>\n  <span class=\"hamburger-box\">\n    <span class=\"hamburger-inner\"></span>\n  </span>\n</button>\n", pipes: { "async": i3__namespace.AsyncPipe, "cxTranslate": i1__namespace.TranslatePipe }, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: HamburgerMenuComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-hamburger-menu',
                        templateUrl: './hamburger-menu.component.html',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], ctorParameters: function () { return [{ type: HamburgerMenuService }]; } });

    var HamburgerMenuModule = /** @class */ (function () {
        function HamburgerMenuModule() {
        }
        return HamburgerMenuModule;
    }());
    HamburgerMenuModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: HamburgerMenuModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    HamburgerMenuModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: HamburgerMenuModule, declarations: [HamburgerMenuComponent], imports: [i3.CommonModule, i1.I18nModule], exports: [HamburgerMenuComponent] });
    HamburgerMenuModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: HamburgerMenuModule, providers: [
            i1.provideDefaultConfig({
                cmsComponents: {
                    HamburgerMenuComponent: {
                        component: HamburgerMenuComponent,
                    },
                },
            }),
        ], imports: [[i3.CommonModule, i1.I18nModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: HamburgerMenuModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [i3.CommonModule, i1.I18nModule],
                        providers: [
                            i1.provideDefaultConfig({
                                cmsComponents: {
                                    HamburgerMenuComponent: {
                                        component: HamburgerMenuComponent,
                                    },
                                },
                            }),
                        ],
                        declarations: [HamburgerMenuComponent],
                        exports: [HamburgerMenuComponent],
                    }]
            }] });

    var ThemeService = /** @class */ (function () {
        function ThemeService(config, rendererFactory) {
            this.config = config;
            this.rendererFactory = rendererFactory;
        }
        /**
         * This function is to be called for the root component that is
         * bootstrapped.
         */
        ThemeService.prototype.init = function (rootComponent) {
            var _a;
            this.renderer = this.rendererFactory.createRenderer(null, null);
            this.rootComponent = rootComponent;
            // Theme value is a string. It is put in the generic multi-value
            // property of the SiteContextConfig. So the array's first item
            // is the theme value.
            this.setTheme((_a = this.config.context[i1.THEME_CONTEXT_ID]) === null || _a === void 0 ? void 0 : _a[0]);
        };
        ThemeService.prototype.setTheme = function (theme) {
            if (theme) {
                var element = this.rootComponent.location.nativeElement;
                // remove the old theme
                this.renderer.removeClass(element, this.existingTheme);
                // add the new theme
                this.renderer.addClass(element, theme);
                this.existingTheme = theme;
            }
        };
        return ThemeService;
    }());
    ThemeService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ThemeService, deps: [{ token: i1__namespace.SiteContextConfig }, { token: i0__namespace.RendererFactory2 }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ThemeService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ThemeService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ThemeService, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }], ctorParameters: function () { return [{ type: i1__namespace.SiteContextConfig }, { type: i0__namespace.RendererFactory2 }]; } });

    function initTheme(themeService) {
        var result = function (component) { return themeService.init(component); };
        return result;
    }
    var ThemeModule = /** @class */ (function () {
        function ThemeModule() {
        }
        return ThemeModule;
    }());
    ThemeModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ThemeModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    ThemeModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ThemeModule });
    ThemeModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ThemeModule, providers: [
            {
                provide: i0.APP_BOOTSTRAP_LISTENER,
                multi: true,
                useFactory: initTheme,
                deps: [ThemeService],
            },
        ] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ThemeModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        providers: [
                            {
                                provide: i0.APP_BOOTSTRAP_LISTENER,
                                multi: true,
                                useFactory: initTheme,
                                deps: [ThemeService],
                            },
                        ],
                    }]
            }] });

    var LayoutModule = /** @class */ (function () {
        function LayoutModule() {
        }
        return LayoutModule;
    }());
    LayoutModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: LayoutModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    LayoutModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: LayoutModule, imports: [OutletRefModule, LaunchDialogModule, DirectionModule,
            ThemeModule], exports: [OutletRefModule] });
    LayoutModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: LayoutModule, providers: [i1.provideConfig(defaultLayoutConfig)], imports: [[
                OutletRefModule,
                LaunchDialogModule.forRoot(),
                DirectionModule,
                ThemeModule,
            ], OutletRefModule] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: LayoutModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [
                            OutletRefModule,
                            LaunchDialogModule.forRoot(),
                            DirectionModule,
                            ThemeModule,
                        ],
                        providers: [i1.provideConfig(defaultLayoutConfig)],
                        exports: [OutletRefModule],
                    }]
            }] });

    exports.StorefrontOutlets = void 0;
    (function (StorefrontOutlets) {
        StorefrontOutlets["STOREFRONT"] = "cx-storefront";
    })(exports.StorefrontOutlets || (exports.StorefrontOutlets = {}));

    var StorefrontComponent = /** @class */ (function () {
        function StorefrontComponent(hamburgerMenuService, routingService, elementRef, keyboardFocusService) {
            this.hamburgerMenuService = hamburgerMenuService;
            this.routingService = routingService;
            this.elementRef = elementRef;
            this.keyboardFocusService = keyboardFocusService;
            this.isExpanded$ = this.hamburgerMenuService.isExpanded;
            this.StorefrontOutlets = exports.StorefrontOutlets;
            // required by esc focus
            this.tabindex = '0';
            this.keyboardFocusConfig = {
                focusOnEscape: true,
                focusOnDoubleEscape: true,
            };
        }
        StorefrontComponent.prototype.handleEscape = function (event) {
            this.keyboardFocusService.handleEscape(this.elementRef.nativeElement, this.keyboardFocusConfig, event);
        };
        StorefrontComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.navigateSubscription = this.routingService
                .isNavigating()
                .subscribe(function (val) {
                _this.startNavigating = val === true;
                _this.stopNavigating = val === false;
            });
        };
        StorefrontComponent.prototype.collapseMenuIfClickOutside = function (event) {
            var element = event.target;
            if (element.nodeName.toLowerCase() === 'header' &&
                element.className.includes('is-expanded')) {
                this.collapseMenu();
            }
        };
        StorefrontComponent.prototype.collapseMenu = function () {
            this.hamburgerMenuService.toggle(true);
        };
        StorefrontComponent.prototype.ngOnDestroy = function () {
            if (this.navigateSubscription) {
                this.navigateSubscription.unsubscribe();
            }
        };
        return StorefrontComponent;
    }());
    StorefrontComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: StorefrontComponent, deps: [{ token: HamburgerMenuService }, { token: i1__namespace.RoutingService }, { token: i0__namespace.ElementRef }, { token: KeyboardFocusService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    StorefrontComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: StorefrontComponent, selector: "cx-storefront", host: { listeners: { "keydown.escape": "handleEscape($event)" }, properties: { "class.start-navigating": "this.startNavigating", "class.stop-navigating": "this.stopNavigating", "tabindex": "this.tabindex" } }, viewQueries: [{ propertyName: "child", first: true, predicate: SkipLinkComponent, descendants: true }], ngImport: i0__namespace, template: "<ng-template [cxOutlet]=\"StorefrontOutlets.STOREFRONT\" cxPageTemplateStyle>\n  <ng-template cxOutlet=\"cx-header\">\n    <header\n      cxSkipLink=\"cx-header\"\n      [cxFocus]=\"{ disableMouseFocus: true }\"\n      [class.is-expanded]=\"isExpanded$ | async\"\n      (keydown.escape)=\"collapseMenu()\"\n      (click)=\"collapseMenuIfClickOutside($event)\"\n    >\n      <cx-page-layout section=\"header\"></cx-page-layout>\n      <cx-page-layout section=\"navigation\"></cx-page-layout>\n    </header>\n    <cx-page-slot position=\"BottomHeaderSlot\"></cx-page-slot>\n    <cx-global-message\n      aria-atomic=\"true\"\n      aria-live=\"assertive\"\n    ></cx-global-message>\n  </ng-template>\n\n  <main cxSkipLink=\"cx-main\" [cxFocus]=\"{ disableMouseFocus: true }\">\n    <router-outlet></router-outlet>\n  </main>\n\n  <ng-template cxOutlet=\"cx-footer\">\n    <footer cxSkipLink=\"cx-footer\" [cxFocus]=\"{ disableMouseFocus: true }\">\n      <cx-page-layout section=\"footer\"></cx-page-layout>\n    </footer>\n  </ng-template>\n</ng-template>\n", components: [{ type: PageLayoutComponent, selector: "cx-page-layout", inputs: ["section"] }, { type: PageSlotComponent, selector: "cx-page-slot,[cx-page-slot]", inputs: ["position", "class", "isPageFold", "hasComponents"] }, { type: GlobalMessageComponent, selector: "cx-global-message" }], directives: [{ type: PageTemplateDirective, selector: "[cxPageTemplateStyle]", inputs: ["cxPageTemplateStyle"] }, { type: OutletDirective, selector: "[cxOutlet]", inputs: ["cxOutlet", "cxOutletContext", "cxOutletDefer"], outputs: ["loaded"] }, { type: SkipLinkDirective, selector: "[cxSkipLink]", inputs: ["cxSkipLink"] }, { type: FocusDirective, selector: "[cxFocus]", inputs: ["cxFocus"] }, { type: i1__namespace$1.RouterOutlet, selector: "router-outlet", outputs: ["activate", "deactivate"], exportAs: ["outlet"] }], pipes: { "async": i3__namespace.AsyncPipe } });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: StorefrontComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'cx-storefront',
                        templateUrl: './storefront.component.html',
                    }]
            }], ctorParameters: function () { return [{ type: HamburgerMenuService }, { type: i1__namespace.RoutingService }, { type: i0__namespace.ElementRef }, { type: KeyboardFocusService }]; }, propDecorators: { startNavigating: [{
                    type: i0.HostBinding,
                    args: ['class.start-navigating']
                }], stopNavigating: [{
                    type: i0.HostBinding,
                    args: ['class.stop-navigating']
                }], tabindex: [{
                    type: i0.HostBinding,
                    args: ['tabindex']
                }], child: [{
                    type: i0.ViewChild,
                    args: [SkipLinkComponent]
                }], handleEscape: [{
                    type: i0.HostListener,
                    args: ['keydown.escape', ['$event']]
                }] } });

    var StorefrontComponentModule = /** @class */ (function () {
        function StorefrontComponentModule() {
        }
        return StorefrontComponentModule;
    }());
    StorefrontComponentModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: StorefrontComponentModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    StorefrontComponentModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: StorefrontComponentModule, declarations: [StorefrontComponent], imports: [i3.CommonModule,
            i1$1.RouterModule,
            GlobalMessageComponentModule,
            OutletModule,
            OutletRefModule,
            PageLayoutModule,
            PageSlotModule,
            KeyboardFocusModule,
            SkipLinkModule], exports: [StorefrontComponent] });
    StorefrontComponentModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: StorefrontComponentModule, imports: [[
                i3.CommonModule,
                i1$1.RouterModule,
                GlobalMessageComponentModule,
                OutletModule,
                OutletRefModule,
                PageLayoutModule,
                PageSlotModule,
                KeyboardFocusModule,
                SkipLinkModule,
            ]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: StorefrontComponentModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [
                            i3.CommonModule,
                            i1$1.RouterModule,
                            GlobalMessageComponentModule,
                            OutletModule,
                            OutletRefModule,
                            PageLayoutModule,
                            PageSlotModule,
                            KeyboardFocusModule,
                            SkipLinkModule,
                        ],
                        declarations: [StorefrontComponent],
                        exports: [StorefrontComponent],
                    }]
            }] });

    var mediaConfig = {
        mediaFormats: {
            mobile: { width: 400 },
            tablet: { width: 770 },
            desktop: { width: 1140 },
            widescreen: { width: 1400 },
            // product media
            cartIcon: { width: 65 },
            thumbnail: { width: 96 },
            product: { width: 284 },
            zoom: { width: 515 },
        },
    };

    /**
     * The layout configuration is used to define the overall layout of the storefront.
     * The configuration includes the following aspects:
     * - breakpoint layout (AKA screen layout)
     * - Page sections slot configuration (i.e. header vs footer)
     * - page template slot configuration (i.e. landing page template vs PDP page template)
     * - deferred loading configuration
     *
     * The page slot configurations is directly related to the data in the backend. If you use the
     * Spartacus sample-data, you will have an aligned setup. However, if you introduce custom page
     * templates and/or slots, you most likely need to further adjust or replace this configuration.
     */
    var layoutConfig = {
        // deferredLoading: {
        //   strategy: DeferLoadingStrategy.DEFER,
        //   intersectionMargin: '50px',
        // },
        layoutSlots: {
            header: {
                lg: {
                    slots: [
                        'PreHeader',
                        'SiteContext',
                        'SiteLinks',
                        'SiteLogo',
                        'SearchBox',
                        'SiteLogin',
                        'MiniCart',
                        'NavigationBar',
                    ],
                },
                slots: ['PreHeader', 'SiteLogo', 'SearchBox', 'MiniCart'],
            },
            navigation: {
                lg: { slots: [] },
                slots: ['SiteLogin', 'NavigationBar', 'SiteContext', 'SiteLinks'],
            },
            footer: {
                slots: ['Footer'],
            },
            LandingPage2Template: {
                pageFold: 'Section2B',
                slots: [
                    'Section1',
                    'Section2A',
                    'Section2B',
                    'Section2C',
                    'Section3',
                    'Section4',
                    'Section5',
                ],
            },
            ContentPage1Template: {
                slots: ['Section2A', 'Section2B'],
            },
            CategoryPageTemplate: {
                pageFold: 'Section2',
                slots: ['Section1', 'Section2', 'Section3'],
            },
            ProductListPageTemplate: {
                slots: ['ProductLeftRefinements', 'ProductListSlot'],
            },
            ProductGridPageTemplate: {
                slots: ['ProductLeftRefinements', 'ProductGridSlot'],
            },
            SearchResultsListPageTemplate: {
                slots: [
                    'Section2',
                    'ProductLeftRefinements',
                    'SearchResultsListSlot',
                    'Section4',
                ],
            },
            SearchResultsGridPageTemplate: {
                slots: [
                    'Section2',
                    'ProductLeftRefinements',
                    'SearchResultsGridSlot',
                    'Section4',
                ],
            },
            ProductDetailsPageTemplate: {
                lg: {
                    pageFold: 'UpSelling',
                },
                pageFold: 'Summary',
                slots: [
                    'Summary',
                    'UpSelling',
                    'CrossSelling',
                    'Tabs',
                    'PlaceholderContentSlot',
                ],
            },
            CartPageTemplate: {
                slots: ['TopContent', 'CenterRightContentSlot', 'EmptyCartMiddleContent'],
            },
            AccountPageTemplate: {
                slots: ['BodyContent', 'SideContent'],
            },
            LoginPageTemplate: {
                slots: ['LeftContentSlot', 'RightContentSlot'],
            },
            ErrorPageTemplate: {
                slots: ['TopContent', 'MiddleContent', 'BottomContent'],
            },
            OrderConfirmationPageTemplate: {
                slots: ['BodyContent', 'SideContent'],
            },
            MultiStepCheckoutSummaryPageTemplate: {
                slots: ['TopContent', 'BodyContent', 'SideContent', 'BottomContent'],
            },
            CheckoutLoginPageTemplate: {
                slots: ['RightContentSlot'],
            },
        },
    };

    var defaultCmsContentProviders = [
        provideCmsStructure({
            componentId: 'HamburgerMenuComponent',
            pageSlotPosition: 'PreHeader',
        }),
        provideCmsStructure({
            componentId: 'LoginComponent',
            pageSlotPosition: 'SiteLogin',
        }),
    ];

    var defaultOnNavigateConfig = {
        enableResetViewOnNavigate: {
            active: true,
            ignoreQueryString: false,
            ignoreRoutes: [],
        },
    };

    var OnNavigateConfig = /** @class */ (function () {
        function OnNavigateConfig() {
        }
        return OnNavigateConfig;
    }());
    OnNavigateConfig.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OnNavigateConfig, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    OnNavigateConfig.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OnNavigateConfig, providedIn: 'root', useExisting: i1.Config });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OnNavigateConfig, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                        useExisting: i1.Config,
                    }]
            }] });

    var OnNavigateService = /** @class */ (function () {
        function OnNavigateService(config, router, viewportScroller, injector) {
            this.config = config;
            this.router = router;
            this.viewportScroller = viewportScroller;
            this.injector = injector;
        }
        Object.defineProperty(OnNavigateService.prototype, "hostComponent", {
            get: function () {
                var _a, _b;
                return (_b = (_a = this.injector.get(i0.ApplicationRef)) === null || _a === void 0 ? void 0 : _a.components) === null || _b === void 0 ? void 0 : _b[0];
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Reads configuration and enables features based on flags set.
         */
        OnNavigateService.prototype.initializeWithConfig = function () {
            var _a, _b;
            if ((_b = (_a = this.config) === null || _a === void 0 ? void 0 : _a.enableResetViewOnNavigate) === null || _b === void 0 ? void 0 : _b.active) {
                this.setResetViewOnNavigate(this.config.enableResetViewOnNavigate.active);
            }
        };
        /**
         * Resets view back to the original position when performing a back navigation and to the top when performing a front navigation
         * and sets the focus back to the top of the page before skiplinks for any type of navigation
         * @param enable Enable or disable this feature
         */
        OnNavigateService.prototype.setResetViewOnNavigate = function (enable) {
            var _this = this;
            var _a;
            (_a = this.subscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();
            if (enable) {
                this.subscription = this.router.events
                    .pipe(operators.filter(function (event) { return event instanceof i1$1.Scroll; }), operators.pairwise())
                    .subscribe(function (event) {
                    var _a, _b, _c;
                    var previousRoute = event[0];
                    var currentRoute = event[1];
                    if (currentRoute.position) {
                        // allow the pages to be repainted before scrolling to proper position
                        setTimeout(function () { return _this.viewportScroller.scrollToPosition(currentRoute.position); });
                    }
                    else {
                        if (((_a = _this.config.enableResetViewOnNavigate) === null || _a === void 0 ? void 0 : _a.ignoreQueryString) &&
                            _this.isPathEqual(previousRoute, currentRoute)) {
                            return;
                        }
                        if (_this.isChildRoute(currentRoute)) {
                            return;
                        }
                        setTimeout(function () { return _this.viewportScroller.scrollToPosition([0, 0]); }, 100);
                    }
                    (_c = (_b = _this.hostComponent) === null || _b === void 0 ? void 0 : _b.location) === null || _c === void 0 ? void 0 : _c.nativeElement.focus();
                });
            }
        };
        /**
         * Verifies if the current route is a child route from the given ignore config route
         *
         * @param route
         * @returns boolean whether the route is a child route
         */
        OnNavigateService.prototype.isChildRoute = function (route) {
            var _a, _b, _c;
            return ((_c = (_b = (_a = this.config.enableResetViewOnNavigate) === null || _a === void 0 ? void 0 : _a.ignoreRoutes) === null || _b === void 0 ? void 0 : _b.some(function (configRoute) { return route.routerEvent.urlAfterRedirects.split('/').includes(configRoute); })) !== null && _c !== void 0 ? _c : false);
        };
        /**
         * Verifies if the previous and current route are the same without the query string
         *
         * @param previousRoute
         * @param currentRoute
         * @returns boolean depending on the previous and current route are equal without the query strings
         */
        OnNavigateService.prototype.isPathEqual = function (previousRoute, currentRoute) {
            return (previousRoute.routerEvent.urlAfterRedirects.split('?')[0] ===
                currentRoute.routerEvent.urlAfterRedirects.split('?')[0]);
        };
        return OnNavigateService;
    }());
    OnNavigateService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OnNavigateService, deps: [{ token: OnNavigateConfig }, { token: i1__namespace$1.Router }, { token: i3__namespace.ViewportScroller }, { token: i0__namespace.Injector }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    OnNavigateService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OnNavigateService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OnNavigateService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: OnNavigateConfig }, { type: i1__namespace$1.Router }, { type: i3__namespace.ViewportScroller }, { type: i0__namespace.Injector }]; } });

    var AppRoutingModule = /** @class */ (function () {
        function AppRoutingModule() {
        }
        return AppRoutingModule;
    }());
    AppRoutingModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AppRoutingModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    AppRoutingModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AppRoutingModule, imports: [i1__namespace$1.RouterModule] });
    AppRoutingModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AppRoutingModule, providers: [
            i1.provideDefaultConfig(defaultOnNavigateConfig),
            {
                provide: i0.APP_INITIALIZER,
                useFactory: onNavigateFactory,
                deps: [OnNavigateService],
                multi: true,
            },
        ], imports: [[
                i1$1.RouterModule.forRoot([], {
                    anchorScrolling: 'enabled',
                    relativeLinkResolution: 'corrected',
                    initialNavigation: 'enabled',
                }),
            ]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AppRoutingModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [
                            i1$1.RouterModule.forRoot([], {
                                anchorScrolling: 'enabled',
                                relativeLinkResolution: 'corrected',
                                initialNavigation: 'enabled',
                            }),
                        ],
                        providers: [
                            i1.provideDefaultConfig(defaultOnNavigateConfig),
                            {
                                provide: i0.APP_INITIALIZER,
                                useFactory: onNavigateFactory,
                                deps: [OnNavigateService],
                                multi: true,
                            },
                        ],
                    }]
            }] });
    function onNavigateFactory(onNavigateService) {
        var isReady = function () { return onNavigateService.initializeWithConfig(); };
        return isReady;
    }

    /**
     * Utils for Angular forms
     */
    exports.FormUtils = void 0;
    (function (FormUtils) {
        /**
         * Calls the native Angular method `#updateValueAndValidity` for the given from control
         * and all its descendants (in case when it's `FormGroup` or `FormArray`).
         *
         * In particular it's useful for triggering re-emission of observables
         * `valueChanges` and `statusChanges` for all descendant form controls.
         *
         * _Note: Dropping this function may be considered, when it's implemented natively
         * by Angular. See https://github.com/angular/angular/issues/6170_
         *
         * @param control form control
         * @param options additional options
         * * `emitEvent`: When true or not given (the default), the `statusChanges` and
         * `valueChanges` observables emit the latest status and value. When false,
         * it doesn't trigger observables emission.
         */
        function deepUpdateValueAndValidity(control, options) {
            if (options === void 0) { options = {}; }
            if (control instanceof i3$1.FormGroup || control instanceof i3$1.FormArray) {
                Object.values(control.controls).forEach(function (childControl) {
                    deepUpdateValueAndValidity(childControl, options);
                });
            }
            control.updateValueAndValidity({
                onlySelf: true,
                emitEvent: options.emitEvent,
            });
        }
        FormUtils.deepUpdateValueAndValidity = deepUpdateValueAndValidity;
    })(exports.FormUtils || (exports.FormUtils = {}));

    var BaseStorefrontModule = /** @class */ (function () {
        function BaseStorefrontModule() {
        }
        return BaseStorefrontModule;
    }());
    BaseStorefrontModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: BaseStorefrontModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    BaseStorefrontModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: BaseStorefrontModule, imports: [i1__namespace.BaseCoreModule, i1$1.RouterModule,
            GlobalMessageComponentModule,
            OutletModule,
            OutletRefModule,
            PwaModule,
            PageLayoutModule,
            SeoModule, PageComponentModule, PageSlotModule,
            SkipLinkModule,
            KeyboardFocusModule,
            LayoutModule, RoutingModule, MediaModule, OutletModule, StorefrontComponentModule], exports: [LayoutModule, StorefrontComponentModule] });
    BaseStorefrontModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: BaseStorefrontModule, imports: [[
                i1.BaseCoreModule.forRoot(),
                i1$1.RouterModule,
                GlobalMessageComponentModule,
                OutletModule,
                OutletRefModule,
                PwaModule,
                PageLayoutModule,
                SeoModule,
                PageComponentModule.forRoot(),
                PageSlotModule,
                SkipLinkModule,
                KeyboardFocusModule,
                LayoutModule,
                RoutingModule.forRoot(),
                MediaModule.forRoot(),
                OutletModule.forRoot(),
                StorefrontComponentModule,
            ], LayoutModule, StorefrontComponentModule] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: BaseStorefrontModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [
                            i1.BaseCoreModule.forRoot(),
                            i1$1.RouterModule,
                            GlobalMessageComponentModule,
                            OutletModule,
                            OutletRefModule,
                            PwaModule,
                            PageLayoutModule,
                            SeoModule,
                            PageComponentModule.forRoot(),
                            PageSlotModule,
                            SkipLinkModule,
                            KeyboardFocusModule,
                            LayoutModule,
                            RoutingModule.forRoot(),
                            MediaModule.forRoot(),
                            OutletModule.forRoot(),
                            StorefrontComponentModule,
                        ],
                        exports: [LayoutModule, StorefrontComponentModule],
                    }]
            }] });

    /*
     * Public API Surface of storefrontlib
     */
    /** AUGMENTABLE_TYPES_END */

    /**
     * Generated bundle index. Do not edit.
     */

    exports.AVOID_STACKED_OUTLETS = AVOID_STACKED_OUTLETS;
    exports.ActiveCartOrderEntriesContext = ActiveCartOrderEntriesContext;
    exports.ActiveFacetsComponent = ActiveFacetsComponent;
    exports.ActiveFacetsModule = ActiveFacetsModule;
    exports.AddToCartComponent = AddToCartComponent;
    exports.AddToCartModule = AddToCartModule;
    exports.AddToHomeScreenBannerComponent = AddToHomeScreenBannerComponent;
    exports.AddToHomeScreenBtnComponent = AddToHomeScreenBtnComponent;
    exports.AddToHomeScreenComponent = AddToHomeScreenComponent;
    exports.AddToHomeScreenService = AddToHomeScreenService;
    exports.AddToWishListComponent = AddToWishListComponent;
    exports.AddToWishListModule = AddToWishListModule;
    exports.AddedToCartDialogComponent = AddedToCartDialogComponent;
    exports.AddressBookComponent = AddressBookComponent;
    exports.AddressBookComponentService = AddressBookComponentService;
    exports.AddressBookModule = AddressBookModule;
    exports.AddressFormComponent = AddressFormComponent;
    exports.AddressFormModule = AddressFormModule;
    exports.AmendOrderActionsComponent = AmendOrderActionsComponent;
    exports.AmendOrderActionsModule = AmendOrderActionsModule;
    exports.AmendOrderItemsModule = AmendOrderItemsModule;
    exports.AnonymousConsentDialogComponent = AnonymousConsentDialogComponent;
    exports.AnonymousConsentManagementBannerComponent = AnonymousConsentManagementBannerComponent;
    exports.AnonymousConsentManagementBannerModule = AnonymousConsentManagementBannerModule;
    exports.AnonymousConsentOpenDialogComponent = AnonymousConsentOpenDialogComponent;
    exports.AnonymousConsentsDialogModule = AnonymousConsentsDialogModule;
    exports.AppRoutingModule = AppRoutingModule;
    exports.AppliedCouponsComponent = AppliedCouponsComponent;
    exports.BannerCarouselComponent = BannerCarouselComponent;
    exports.BannerCarouselModule = BannerCarouselModule;
    exports.BannerComponent = BannerComponent;
    exports.BannerModule = BannerModule;
    exports.BaseStorefrontModule = BaseStorefrontModule;
    exports.BreadcrumbComponent = BreadcrumbComponent;
    exports.BreadcrumbModule = BreadcrumbModule;
    exports.BreadcrumbSchemaBuilder = BreadcrumbSchemaBuilder;
    exports.BreakpointService = BreakpointService;
    exports.CancelOrReturnItemsComponent = CancelOrReturnItemsComponent;
    exports.CancelOrderComponent = CancelOrderComponent;
    exports.CancelOrderConfirmationComponent = CancelOrderConfirmationComponent;
    exports.CancelOrderConfirmationModule = CancelOrderConfirmationModule;
    exports.CancelOrderModule = CancelOrderModule;
    exports.CardComponent = CardComponent;
    exports.CardModule = CardModule;
    exports.CarouselComponent = CarouselComponent;
    exports.CarouselModule = CarouselModule;
    exports.CarouselService = CarouselService;
    exports.CartComponentModule = CartComponentModule;
    exports.CartCouponComponent = CartCouponComponent;
    exports.CartCouponModule = CartCouponModule;
    exports.CartDetailsComponent = CartDetailsComponent;
    exports.CartDetailsModule = CartDetailsModule;
    exports.CartItemComponent = CartItemComponent;
    exports.CartItemContext = CartItemContext;
    exports.CartItemContextSource = CartItemContextSource;
    exports.CartItemListComponent = CartItemListComponent;
    exports.CartOrderEntriesContext = CartOrderEntriesContext;
    exports.CartPageEvent = CartPageEvent;
    exports.CartPageEventBuilder = CartPageEventBuilder;
    exports.CartPageEventModule = CartPageEventModule;
    exports.CartPageLayoutHandler = CartPageLayoutHandler;
    exports.CartSharedModule = CartSharedModule;
    exports.CartTotalsComponent = CartTotalsComponent;
    exports.CartTotalsModule = CartTotalsModule;
    exports.CartValidationComponentsModule = CartValidationComponentsModule;
    exports.CartValidationGuard = CartValidationGuard;
    exports.CartValidationStateService = CartValidationStateService;
    exports.CartValidationWarningsComponent = CartValidationWarningsComponent;
    exports.CartValidationWarningsModule = CartValidationWarningsModule;
    exports.CategoryNavigationComponent = CategoryNavigationComponent;
    exports.CategoryNavigationModule = CategoryNavigationModule;
    exports.CategoryPageResultsEvent = CategoryPageResultsEvent;
    exports.CmsComponentData = CmsComponentData;
    exports.CmsComponentsService = CmsComponentsService;
    exports.CmsFeaturesService = CmsFeaturesService;
    exports.CmsGuardsService = CmsGuardsService;
    exports.CmsI18nService = CmsI18nService;
    exports.CmsInjectorService = CmsInjectorService;
    exports.CmsPageGuard = CmsPageGuard;
    exports.CmsPageGuardService = CmsPageGuardService;
    exports.CmsParagraphModule = CmsParagraphModule;
    exports.CmsRouteModule = CmsRouteModule;
    exports.CmsRoutesService = CmsRoutesService;
    exports.ComponentCreateEvent = ComponentCreateEvent;
    exports.ComponentDestroyEvent = ComponentDestroyEvent;
    exports.ComponentEvent = ComponentEvent;
    exports.ComponentHandler = ComponentHandler;
    exports.ComponentHandlerService = ComponentHandlerService;
    exports.ComponentWrapperDirective = ComponentWrapperDirective;
    exports.ConsentManagementComponent = ConsentManagementComponent;
    exports.ConsentManagementFormComponent = ConsentManagementFormComponent;
    exports.ConsentManagementModule = ConsentManagementModule;
    exports.ConsignmentTrackingComponent = ConsignmentTrackingComponent;
    exports.ContextService = ContextService;
    exports.CouponCardComponent = CouponCardComponent;
    exports.CouponClaimComponent = CouponClaimComponent;
    exports.CouponDialogComponent = CouponDialogComponent;
    exports.CurrentProductService = CurrentProductService;
    exports.CustomFormValidators = CustomFormValidators;
    exports.DatePickerComponent = DatePickerComponent;
    exports.DatePickerModule = DatePickerModule;
    exports.DatePickerService = DatePickerService;
    exports.DefaultComponentHandler = DefaultComponentHandler;
    exports.DeferLoaderService = DeferLoaderService;
    exports.DirectionConfig = DirectionConfig;
    exports.DirectionModule = DirectionModule;
    exports.DirectionService = DirectionService;
    exports.ExportCsvFileService = ExportCsvFileService;
    exports.FacetComponent = FacetComponent;
    exports.FacetListComponent = FacetListComponent;
    exports.FacetListModule = FacetListModule;
    exports.FacetModule = FacetModule;
    exports.FacetService = FacetService;
    exports.FileDownloadService = FileDownloadService;
    exports.FileReaderService = FileReaderService;
    exports.FileUploadComponent = FileUploadComponent;
    exports.FileUploadModule = FileUploadModule;
    exports.FilesFormValidators = FilesFormValidators;
    exports.FocusDirective = FocusDirective;
    exports.FooterNavigationComponent = FooterNavigationComponent;
    exports.FooterNavigationModule = FooterNavigationModule;
    exports.FormErrorsComponent = FormErrorsComponent;
    exports.FormErrorsModule = FormErrorsModule;
    exports.GenericLinkComponent = GenericLinkComponent;
    exports.GenericLinkComponentService = GenericLinkComponentService;
    exports.GenericLinkModule = GenericLinkModule;
    exports.GlobalMessageComponent = GlobalMessageComponent;
    exports.GlobalMessageComponentModule = GlobalMessageComponentModule;
    exports.HamburgerMenuComponent = HamburgerMenuComponent;
    exports.HamburgerMenuModule = HamburgerMenuModule;
    exports.HamburgerMenuService = HamburgerMenuService;
    exports.HighlightPipe = HighlightPipe;
    exports.HomePageEvent = HomePageEvent;
    exports.HomePageEventBuilder = HomePageEventBuilder;
    exports.HomePageEventModule = HomePageEventModule;
    exports.IconComponent = IconComponent;
    exports.IconConfig = IconConfig;
    exports.IconLoaderService = IconLoaderService;
    exports.IconModule = IconModule;
    exports.IconTestingModule = IconTestingModule;
    exports.ImportCsvFileService = ImportCsvFileService;
    exports.InlineRenderStrategy = InlineRenderStrategy;
    exports.InlineRootRenderStrategy = InlineRootRenderStrategy;
    exports.InnerComponentsHostDirective = InnerComponentsHostDirective;
    exports.IntersectionService = IntersectionService;
    exports.ItemCounterComponent = ItemCounterComponent;
    exports.ItemCounterModule = ItemCounterModule;
    exports.JSONLD_PRODUCT_BUILDER = JSONLD_PRODUCT_BUILDER;
    exports.JsonLdBaseProductBuilder = JsonLdBaseProductBuilder;
    exports.JsonLdBuilderModule = JsonLdBuilderModule;
    exports.JsonLdDirective = JsonLdDirective;
    exports.JsonLdProductOfferBuilder = JsonLdProductOfferBuilder;
    exports.JsonLdProductReviewBuilder = JsonLdProductReviewBuilder;
    exports.JsonLdScriptFactory = JsonLdScriptFactory;
    exports.KeyboardFocusConfig = KeyboardFocusConfig;
    exports.KeyboardFocusModule = KeyboardFocusModule;
    exports.KeyboardFocusService = KeyboardFocusService;
    exports.KeyboardFocusTestingModule = KeyboardFocusTestingModule;
    exports.LanguageCurrencyComponent = LanguageCurrencyComponent;
    exports.LaunchDialogModule = LaunchDialogModule;
    exports.LaunchDialogService = LaunchDialogService;
    exports.LayoutConfig = LayoutConfig;
    exports.LayoutModule = LayoutModule;
    exports.LazyComponentHandler = LazyComponentHandler;
    exports.LinkComponent = LinkComponent;
    exports.LinkModule = LinkModule;
    exports.ListNavigationModule = ListNavigationModule;
    exports.LoginGuard = LoginGuard;
    exports.LoginRouteModule = LoginRouteModule;
    exports.LogoutGuard = LogoutGuard;
    exports.LogoutModule = LogoutModule;
    exports.MediaComponent = MediaComponent;
    exports.MediaConfig = MediaConfig;
    exports.MediaModule = MediaModule;
    exports.MediaService = MediaService;
    exports.MessageComponent = MessageComponent;
    exports.MessageComponentModule = MessageComponentModule;
    exports.MiniCartComponent = MiniCartComponent;
    exports.MiniCartModule = MiniCartModule;
    exports.MockIconComponent = MockIconComponent;
    exports.MockIconLoaderService = MockIconLoaderService;
    exports.MockKeyboardFocusDirective = MockKeyboardFocusDirective;
    exports.ModalDirective = ModalDirective;
    exports.ModalDirectiveService = ModalDirectiveService;
    exports.ModalModule = ModalModule;
    exports.ModalRef = ModalRef;
    exports.ModalService = ModalService;
    exports.MyCouponsComponent = MyCouponsComponent;
    exports.MyCouponsModule = MyCouponsModule;
    exports.MyInterestsComponent = MyInterestsComponent;
    exports.MyInterestsModule = MyInterestsModule;
    exports.NavigationComponent = NavigationComponent;
    exports.NavigationEvent = NavigationEvent;
    exports.NavigationEventBuilder = NavigationEventBuilder;
    exports.NavigationEventModule = NavigationEventModule;
    exports.NavigationModule = NavigationModule;
    exports.NavigationService = NavigationService;
    exports.NavigationUIComponent = NavigationUIComponent;
    exports.NotificationPreferenceComponent = NotificationPreferenceComponent;
    exports.NotificationPreferenceModule = NotificationPreferenceModule;
    exports.ORDER_ENTRIES_CONTEXT = ORDER_ENTRIES_CONTEXT;
    exports.OnNavigateConfig = OnNavigateConfig;
    exports.OnNavigateService = OnNavigateService;
    exports.OrderAmendService = OrderAmendService;
    exports.OrderCancellationGuard = OrderCancellationGuard;
    exports.OrderCancellationModule = OrderCancellationModule;
    exports.OrderCancellationService = OrderCancellationService;
    exports.OrderConsignedEntriesComponent = OrderConsignedEntriesComponent;
    exports.OrderDetailActionsComponent = OrderDetailActionsComponent;
    exports.OrderDetailItemsComponent = OrderDetailItemsComponent;
    exports.OrderDetailShippingComponent = OrderDetailShippingComponent;
    exports.OrderDetailTotalsComponent = OrderDetailTotalsComponent;
    exports.OrderDetailsModule = OrderDetailsModule;
    exports.OrderDetailsService = OrderDetailsService;
    exports.OrderDetailsServiceTransitionalToken = OrderDetailsServiceTransitionalToken;
    exports.OrderHistoryComponent = OrderHistoryComponent;
    exports.OrderHistoryModule = OrderHistoryModule;
    exports.OrderModule = OrderModule;
    exports.OrderOverviewComponent = OrderOverviewComponent;
    exports.OrderOverviewModule = OrderOverviewModule;
    exports.OrderReturnGuard = OrderReturnGuard;
    exports.OrderReturnModule = OrderReturnModule;
    exports.OrderReturnRequestListComponent = OrderReturnRequestListComponent;
    exports.OrderReturnService = OrderReturnService;
    exports.OrderSummaryComponent = OrderSummaryComponent;
    exports.OutletContextData = OutletContextData;
    exports.OutletDirective = OutletDirective;
    exports.OutletModule = OutletModule;
    exports.OutletRefDirective = OutletRefDirective;
    exports.OutletRefModule = OutletRefModule;
    exports.OutletRenderStrategy = OutletRenderStrategy;
    exports.OutletRendererService = OutletRendererService;
    exports.OutletService = OutletService;
    exports.PAGE_LAYOUT_HANDLER = PAGE_LAYOUT_HANDLER;
    exports.PRODUCT_DETAILS_URL_MATCHER = PRODUCT_DETAILS_URL_MATCHER;
    exports.PRODUCT_LISTING_URL_MATCHER = PRODUCT_LISTING_URL_MATCHER;
    exports.PWAModuleConfig = PWAModuleConfig;
    exports.PageComponentModule = PageComponentModule;
    exports.PageEvent = PageEvent;
    exports.PageLayoutComponent = PageLayoutComponent;
    exports.PageLayoutModule = PageLayoutModule;
    exports.PageLayoutService = PageLayoutService;
    exports.PageMetaLinkService = PageMetaLinkService;
    exports.PageSlotComponent = PageSlotComponent;
    exports.PageSlotModule = PageSlotModule;
    exports.PageSlotService = PageSlotService;
    exports.PageTemplateDirective = PageTemplateDirective;
    exports.PageTitleComponent = PageTitleComponent;
    exports.PageTitleModule = PageTitleModule;
    exports.PaginationBuilder = PaginationBuilder;
    exports.PaginationComponent = PaginationComponent;
    exports.PaginationConfig = PaginationConfig;
    exports.PaginationModule = PaginationModule;
    exports.ParagraphComponent = ParagraphComponent;
    exports.PaymentMethodsComponent = PaymentMethodsComponent;
    exports.PaymentMethodsModule = PaymentMethodsModule;
    exports.PopoverComponent = PopoverComponent;
    exports.PopoverDirective = PopoverDirective;
    exports.PopoverModule = PopoverModule;
    exports.PopoverService = PopoverService;
    exports.PositioningService = PositioningService;
    exports.ProductAttributesComponent = ProductAttributesComponent;
    exports.ProductAttributesModule = ProductAttributesModule;
    exports.ProductCarouselComponent = ProductCarouselComponent;
    exports.ProductCarouselModule = ProductCarouselModule;
    exports.ProductCarouselService = ProductCarouselService;
    exports.ProductDetailsPageEvent = ProductDetailsPageEvent;
    exports.ProductDetailsPageModule = ProductDetailsPageModule;
    exports.ProductDetailsTabComponent = ProductDetailsTabComponent;
    exports.ProductDetailsTabModule = ProductDetailsTabModule;
    exports.ProductFacetNavigationComponent = ProductFacetNavigationComponent;
    exports.ProductFacetNavigationModule = ProductFacetNavigationModule;
    exports.ProductFacetService = ProductFacetService;
    exports.ProductGridItemComponent = ProductGridItemComponent;
    exports.ProductImagesComponent = ProductImagesComponent;
    exports.ProductImagesModule = ProductImagesModule;
    exports.ProductIntroComponent = ProductIntroComponent;
    exports.ProductIntroModule = ProductIntroModule;
    exports.ProductListComponent = ProductListComponent;
    exports.ProductListComponentService = ProductListComponentService;
    exports.ProductListItemComponent = ProductListItemComponent;
    exports.ProductListItemContext = ProductListItemContext;
    exports.ProductListItemContextSource = ProductListItemContextSource;
    exports.ProductListModule = ProductListModule;
    exports.ProductListingPageModule = ProductListingPageModule;
    exports.ProductPageEventBuilder = ProductPageEventBuilder;
    exports.ProductPageEventModule = ProductPageEventModule;
    exports.ProductReferencesComponent = ProductReferencesComponent;
    exports.ProductReferencesModule = ProductReferencesModule;
    exports.ProductReviewsComponent = ProductReviewsComponent;
    exports.ProductReviewsModule = ProductReviewsModule;
    exports.ProductSchemaBuilder = ProductSchemaBuilder;
    exports.ProductScrollComponent = ProductScrollComponent;
    exports.ProductSummaryComponent = ProductSummaryComponent;
    exports.ProductSummaryModule = ProductSummaryModule;
    exports.ProductTabsModule = ProductTabsModule;
    exports.ProductViewComponent = ProductViewComponent;
    exports.ProgressButtonComponent = ProgressButtonComponent;
    exports.ProgressButtonModule = ProgressButtonModule;
    exports.PromotionsComponent = PromotionsComponent;
    exports.PromotionsModule = PromotionsModule;
    exports.PwaModule = PwaModule;
    exports.ReplenishmentOrderCancellationComponent = ReplenishmentOrderCancellationComponent;
    exports.ReplenishmentOrderCancellationDialogComponent = ReplenishmentOrderCancellationDialogComponent;
    exports.ReplenishmentOrderCancellationDialogModule = ReplenishmentOrderCancellationDialogModule;
    exports.ReplenishmentOrderDetailsModule = ReplenishmentOrderDetailsModule;
    exports.ReplenishmentOrderDetailsService = ReplenishmentOrderDetailsService;
    exports.ReplenishmentOrderHistoryComponent = ReplenishmentOrderHistoryComponent;
    exports.ReplenishmentOrderHistoryModule = ReplenishmentOrderHistoryModule;
    exports.ReturnOrderComponent = ReturnOrderComponent;
    exports.ReturnOrderConfirmationComponent = ReturnOrderConfirmationComponent;
    exports.ReturnOrderConfirmationModule = ReturnOrderConfirmationModule;
    exports.ReturnOrderModule = ReturnOrderModule;
    exports.ReturnRequestDetailModule = ReturnRequestDetailModule;
    exports.ReturnRequestItemsComponent = ReturnRequestItemsComponent;
    exports.ReturnRequestListModule = ReturnRequestListModule;
    exports.ReturnRequestOverviewComponent = ReturnRequestOverviewComponent;
    exports.ReturnRequestTotalsComponent = ReturnRequestTotalsComponent;
    exports.RoutingContextService = RoutingContextService;
    exports.RoutingModule = RoutingModule;
    exports.RoutingRenderStrategy = RoutingRenderStrategy;
    exports.SCHEMA_BUILDER = SCHEMA_BUILDER;
    exports.SaveForLaterComponent = SaveForLaterComponent;
    exports.SaveForLaterModule = SaveForLaterModule;
    exports.SearchBoxComponent = SearchBoxComponent;
    exports.SearchBoxComponentService = SearchBoxComponentService;
    exports.SearchBoxModule = SearchBoxModule;
    exports.SearchBoxProductSelectedEvent = SearchBoxProductSelectedEvent;
    exports.SearchBoxSuggestionSelectedEvent = SearchBoxSuggestionSelectedEvent;
    exports.SearchPageResultsEvent = SearchPageResultsEvent;
    exports.SelectFocusUtility = SelectFocusUtility;
    exports.SeoMetaService = SeoMetaService;
    exports.SeoModule = SeoModule;
    exports.SiteContextComponentService = SiteContextComponentService;
    exports.SiteContextSelectorComponent = SiteContextSelectorComponent;
    exports.SiteContextSelectorModule = SiteContextSelectorModule;
    exports.SkipLink = SkipLink;
    exports.SkipLinkComponent = SkipLinkComponent;
    exports.SkipLinkConfig = SkipLinkConfig;
    exports.SkipLinkDirective = SkipLinkDirective;
    exports.SkipLinkModule = SkipLinkModule;
    exports.SkipLinkService = SkipLinkService;
    exports.SortingComponent = SortingComponent;
    exports.SpinnerComponent = SpinnerComponent;
    exports.SpinnerModule = SpinnerModule;
    exports.SplitViewComponent = SplitViewComponent;
    exports.SplitViewModule = SplitViewModule;
    exports.SplitViewService = SplitViewService;
    exports.StarRatingComponent = StarRatingComponent;
    exports.StarRatingModule = StarRatingModule;
    exports.StockNotificationComponent = StockNotificationComponent;
    exports.StockNotificationDialogComponent = StockNotificationDialogComponent;
    exports.StockNotificationModule = StockNotificationModule;
    exports.StorefrontComponent = StorefrontComponent;
    exports.StorefrontComponentModule = StorefrontComponentModule;
    exports.StructuredDataModule = StructuredDataModule;
    exports.SuggestedAddressDialogComponent = SuggestedAddressDialogComponent;
    exports.SupplementHashAnchorsModule = SupplementHashAnchorsModule;
    exports.SupplementHashAnchorsPipe = SupplementHashAnchorsPipe;
    exports.TabParagraphContainerComponent = TabParagraphContainerComponent;
    exports.TabParagraphContainerModule = TabParagraphContainerModule;
    exports.TableComponent = TableComponent;
    exports.TableConfig = TableConfig;
    exports.TableDataCellComponent = TableDataCellComponent;
    exports.TableDataCellModule = TableDataCellModule;
    exports.TableHeaderCellComponent = TableHeaderCellComponent;
    exports.TableHeaderCellModule = TableHeaderCellModule;
    exports.TableModule = TableModule;
    exports.TableRendererService = TableRendererService;
    exports.TableService = TableService;
    exports.ThemeModule = ThemeModule;
    exports.ThemeService = ThemeService;
    exports.TrackingEventsComponent = TrackingEventsComponent;
    exports.TruncatePipe = TruncatePipe;
    exports.TruncateTextPopoverComponent = TruncateTextPopoverComponent;
    exports.TruncateTextPopoverModule = TruncateTextPopoverModule;
    exports.USE_STACKED_OUTLETS = USE_STACKED_OUTLETS;
    exports.UserComponentModule = UserComponentModule;
    exports.ViewComponent = ViewComponent;
    exports.ViewConfig = ViewConfig;
    exports.WishListComponent = WishListComponent;
    exports.WishListItemComponent = WishListItemComponent;
    exports.WishListModule = WishListModule;
    exports.controlsMustMatch = controlsMustMatch;
    exports.defaultCmsContentProviders = defaultCmsContentProviders;
    exports.defaultKeyboardFocusConfig = defaultKeyboardFocusConfig;
    exports.defaultLayoutConfig = defaultLayoutConfig;
    exports.defaultOnNavigateConfig = defaultOnNavigateConfig;
    exports.defaultPWAModuleConfig = defaultPWAModuleConfig;
    exports.defaultPaginationConfig = defaultPaginationConfig;
    exports.defaultReplenishmentOrderCancellationLayoutConfig = defaultReplenishmentOrderCancellationLayoutConfig;
    exports.defaultSkipLinkConfig = defaultSkipLinkConfig;
    exports.defaultTableConfig = defaultTableConfig;
    exports.defaultViewConfig = defaultViewConfig;
    exports.fontawesomeIconConfig = fontawesomeIconConfig;
    exports.getSuffixUrlMatcher = getSuffixUrlMatcher;
    exports.initSeoService = initSeoService;
    exports.keyboardFocusFactory = keyboardFocusFactory;
    exports.layoutConfig = layoutConfig;
    exports.mediaConfig = mediaConfig;
    exports.onNavigateFactory = onNavigateFactory;
    exports.provideCmsStructure = provideCmsStructure;
    exports.provideOutlet = provideOutlet;
    exports.sortTitles = sortTitles;
    exports.titleScores = titleScores;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=spartacus-storefront.umd.js.map
