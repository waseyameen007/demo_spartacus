import * as i3 from '@angular/common';
import { isPlatformBrowser, CommonModule, DOCUMENT, isPlatformServer, formatCurrency, getCurrencySymbol } from '@angular/common';
import * as i0 from '@angular/core';
import { Injectable, Directive, Input, HostBinding, HostListener, EventEmitter, Output, PLATFORM_ID, Inject, APP_INITIALIZER, NgModule, isDevMode, Component, ApplicationRef, Injector, ComponentFactory, TemplateRef, InjectionToken, Optional, ComponentFactoryResolver, ViewChild, ChangeDetectionStrategy, ElementRef, Pipe, forwardRef, InjectFlags, ChangeDetectorRef, SecurityContext, ViewChildren, inject, APP_BOOTSTRAP_LISTENER } from '@angular/core';
import * as i1 from '@spartacus/core';
import { Config, provideDefaultConfig, ConfigModule, resolveApplicable, isNotNullable, DeferLoadingStrategy, ANONYMOUS_CONSENT_STATUS, I18nModule, FeaturesConfigModule, provideConfig, PromotionLocation, isNotUndefined, GlobalMessageType, AuthGuard, UrlModule, isObject, LANGUAGE_CONTEXT_ID, CURRENCY_CONTEXT_ID, SiteContextModule, ContextServiceMap, EMAIL_PATTERN, PASSWORD_PATTERN, CartValidationStatusCode, CartActions, ConfigChunk, DefaultConfigChunk, deepMerge, CxEvent, PageType, CartModule, RoutingModule as RoutingModule$1, WindowRef, LanguageService, UserAddressService, getLastValueSync, PageMetaModule, OCC_USER_ID_ANONYMOUS, NotificationType, OAuthFlow, UrlMatcherService, DEFAULT_URL_MATCHER, createFrom, FeatureConfigService, THEME_CONTEXT_ID, BaseCoreModule } from '@spartacus/core';
import * as i1$1 from '@angular/router';
import { NavigationStart, RouterModule, NavigationEnd, NavigationCancel, Router, Scroll } from '@angular/router';
import { map, distinctUntilChanged, filter, take, tap, first, flatMap, withLatestFrom, startWith, switchMap, shareReplay, switchMapTo, skipWhile, scan, delayWhen, catchError, mapTo, share, finalize, endWith, debounceTime, pluck, observeOn, skip, pairwise } from 'rxjs/operators';
import { of, BehaviorSubject, combineLatest, Subscription, Observable, ReplaySubject, concat, Subject, timer, defer, forkJoin, EMPTY, isObservable, from, using, asapScheduler, interval } from 'rxjs';
import { __decorate, __param } from 'tslib';
import * as i1$2 from '@angular/platform-browser';
import * as i3$1 from '@angular/forms';
import { FormGroup, FormControl, FormsModule, ReactiveFormsModule, NG_VALUE_ACCESSOR, Validators, FormArray } from '@angular/forms';
import * as i1$3 from '@ng-bootstrap/ng-bootstrap';
import { NgbModalRef, NgbModule } from '@ng-bootstrap/ng-bootstrap';
import * as i1$4 from '@ng-select/ng-select';
import { NgSelectModule } from '@ng-select/ng-select';
import { ofType } from '@ngrx/effects';
import * as i1$5 from '@ngrx/store';
import * as i1$6 from '@angular/service-worker';
import { SwRegistrationOptions, ServiceWorkerModule } from '@angular/service-worker';
import * as i6 from 'ngx-infinite-scroll';
import { InfiniteScrollModule } from 'ngx-infinite-scroll';
import { HttpUrlEncodingCodec } from '@angular/common/http';
import { ROUTER_NAVIGATED } from '@ngrx/router-store';

/** The element attribute used to store the focus state */
const FOCUS_ATTR = 'data-cx-focus';
/** The element attribute used to store the focus group state */
const FOCUS_GROUP_ATTR = 'data-cx-focus-group';
var TrapFocus;
(function (TrapFocus) {
    /**
     * Will trap the focus at the start of the focus group.
     */
    TrapFocus["start"] = "start";
    /**
     * Will trap the focus only at the end of the focus group.
     */
    TrapFocus["end"] = "end";
    /**
     * Will not trap the focus in both directions. This is actually not are
     * a great example of focus trap, but it will give the benefit of keyboard
     * tabbing by arrows.
     */
    TrapFocus["both"] = "both";
})(TrapFocus || (TrapFocus = {}));

class BaseFocusService {
}
BaseFocusService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: BaseFocusService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
BaseFocusService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: BaseFocusService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: BaseFocusService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Abstract directive that provides a common interface for all focus directives:
 * - Block Focus
 * - Persist Focus
 * - Escape Focus
 * - Auto Focus
 * - Tab Focus
 * - Trap Focus
 * - Lock Focus
 */
class BaseFocusDirective {
    constructor(elementRef, service) {
        this.elementRef = elementRef;
        this.service = service;
        /**
         * A default config can be provided for each directive if a specific focus directive
         * is used directly. i.e. `<div cxAutoFocus></div>`
         */
        this.defaultConfig = {};
    }
    ngOnInit() {
        this.setDefaultConfiguration();
        this.requiredTabindex = -1;
    }
    // empty, but sub classes might have an implementation
    ngOnChanges(_changes) { }
    /**
     * Override the (input) config if it undefined or an empty string, with the
     * `defaultConfig`. The `defaultConfig` might be specified for each directive
     * differently. If a specific directive is used (i.e. `cxAutoFocus`), the
     * specific (inherited) defaultConfig will be used.
     */
    setDefaultConfiguration() {
        if ((!this.config || this.config === '') && this.defaultConfig) {
            this.config = this.defaultConfig;
        }
    }
    /**
     * Helper method to return the host element for the directive
     * given by the `elementRef`.
     */
    get host() {
        return this.elementRef.nativeElement;
    }
    /**
     * Force a tabindex on the host element if it is _required_ to make the element
     * focusable. If the element is focusable by nature or by a given tabindex, the
     * `tabindex` is not applied.
     *
     * Buttons, active links, etc. do no need an explicit tabindex to receive focus.
     */
    set requiredTabindex(tabindex) {
        if (this.requiresExplicitTabIndex) {
            this.tabindex = tabindex;
        }
    }
    /**
     * Returns true if the host element does not have a tabindex defined
     * and it also doesn't get focus by browsers nature (i.e. button or
     * active link).
     */
    get requiresExplicitTabIndex() {
        return (this.tabindex === undefined &&
            ['button', 'input', 'select', 'textarea'].indexOf(this.host.tagName.toLowerCase()) === -1 &&
            !(this.host.tagName === 'A' &&
                (this.host.hasAttribute('href') ||
                    this.host.hasAttribute('routerlink') ||
                    this.host.getAttribute('ng-reflect-router-link'))));
    }
}
BaseFocusDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: BaseFocusDirective, deps: [{ token: i0.ElementRef }, { token: BaseFocusService }], target: i0.ɵɵFactoryTarget.Directive });
BaseFocusDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.5", type: BaseFocusDirective, inputs: { tabindex: "tabindex" }, host: { properties: { "attr.tabindex": "this.tabindex" } }, usesOnChanges: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: BaseFocusDirective, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: BaseFocusService }]; }, propDecorators: { tabindex: [{
                type: Input
            }, {
                type: HostBinding,
                args: ['attr.tabindex']
            }] } });

/**
 * Directive implementation that adds a CSS class to the host element
 * when the moused is used to focus an element. As soon as the keyboard
 * is used, the class is removed.
 *
 * This feature must be explicitly enabled with the `disableMouseFocus` config.
 *
 * The appearance of the visual focus depends on the CSS implementation to
 * begin with. Spartacus styles add a blue border around each focusable element.
 * This can be considered annoying by keyboard users, as they won't need such a
 * strong indication of the selected element.
 */
class VisibleFocusDirective extends BaseFocusDirective {
    constructor() {
        super(...arguments);
        this.defaultConfig = {
            disableMouseFocus: true,
        };
        /** Controls a css class to hide focus visible CSS rules */
        this.mouseFocus = false;
    }
    handleMousedown() {
        if (this.shouldFocusVisible) {
            this.mouseFocus = true;
        }
    }
    handleKeydown(event) {
        if (this.shouldFocusVisible) {
            this.mouseFocus = !this.isNavigating(event);
        }
    }
    /**
     * Indicates whether the configurations setup to disable visual focus.
     */
    get shouldFocusVisible() {
        var _a;
        return (_a = this.config) === null || _a === void 0 ? void 0 : _a.disableMouseFocus;
    }
    /**
     * Indicates whether the event is used to navigate the storefront. Some keyboard events
     * are used by mouse users to fill a form or interact with the OS or browser.
     */
    isNavigating(event) {
        // when the cmd or ctrl keys are used, the user doesn't navigate the storefront
        if (event.metaKey) {
            return false;
        }
        // when the tab key is used, users are for navigating away from the current (form) element
        if (event.code === 'Tab') {
            return true;
        }
        // If the user fill in a form, we don't considering it part of storefront navigation.
        if (['INPUT', 'TEXTAREA'].includes(event.target.tagName)) {
            return false;
        }
        return true;
    }
}
VisibleFocusDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: VisibleFocusDirective, deps: null, target: i0.ɵɵFactoryTarget.Directive });
VisibleFocusDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.5", type: VisibleFocusDirective, host: { listeners: { "mousedown": "handleMousedown()", "keydown": "handleKeydown($event)" }, properties: { "class.mouse-focus": "this.mouseFocus" } }, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: VisibleFocusDirective, decorators: [{
            type: Directive
        }], propDecorators: { mouseFocus: [{
                type: HostBinding,
                args: ['class.mouse-focus']
            }], handleMousedown: [{
                type: HostListener,
                args: ['mousedown']
            }], handleKeydown: [{
                type: HostListener,
                args: ['keydown', ['$event']]
            }] } });

// { selector: '[cxBlockFocus]' }
class BlockFocusDirective extends VisibleFocusDirective {
    constructor(elementRef, service) {
        super(elementRef, service);
        this.elementRef = elementRef;
        this.service = service;
        this.defaultConfig = { block: true };
        // @Input('cxBlockFocus')
        this.config = {};
    }
    ngOnInit() {
        super.ngOnInit();
        if (this.config.block) {
            this.tabindex = -1;
        }
    }
}
BlockFocusDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: BlockFocusDirective, deps: [{ token: i0.ElementRef }, { token: BaseFocusService }], target: i0.ɵɵFactoryTarget.Directive });
BlockFocusDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.5", type: BlockFocusDirective, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: BlockFocusDirective, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: BaseFocusService }]; } });

const GLOBAL_GROUP = '_g_';
/**
 * Shared service to persist the focus for an element or a group
 * of elements. The persisted element focus can be used to persist
 * the focus for a DOM tree, so that the focus remains after a repaint
 * or reoccurs when a DOM tree is "unlocked".
 */
class PersistFocusService extends BaseFocusService {
    constructor() {
        super(...arguments);
        // this is going to fail as we have sub services. They will al have their own map.
        // We must bring this to a singleton map.
        this.focus = new Map();
    }
    get(group) {
        return this.focus.get(group || GLOBAL_GROUP);
    }
    /**
     * Persist the keyboard focus state for the given key. The focus is stored globally
     * or for the given group.
     */
    set(key, group) {
        if (key) {
            this.focus.set(group || GLOBAL_GROUP, key);
        }
    }
    /**
     * Clears the persisted keyboard focus state globally or for the given group.
     */
    clear(group) {
        this.focus.delete(group || GLOBAL_GROUP);
    }
    /**
     * Returns the group for the host element based on the configured group or
     * by the `data-cx-focus-group` attribute stored on the host.
     */
    getPersistenceGroup(host, config) {
        return (config === null || config === void 0 ? void 0 : config.group) ? config.group : host.getAttribute(FOCUS_GROUP_ATTR);
    }
}
PersistFocusService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PersistFocusService, deps: null, target: i0.ɵɵFactoryTarget.Injectable });
PersistFocusService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PersistFocusService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PersistFocusService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Directive that provides persistence of the focused state. This is useful
 * when a group of focusable elements got refocused or even recreated. That
 * happens often when the DOM is constructed with an `*ngIf` or `*ngFor`.
 *
 * The focus state is based on a configured _key_, which can be passed in the
 * config input, either by using a string primitive or `PersistFocusConfig.key`:
 *
 * ```html
 * <button cxPersistFocus="myKey"></button>
 * <button cxFocus="myKey"></button>
 * <button [cxFocus]="{{key:'myKey'}"></button>
 * ```
 *
 * The focus state can be part of a focus _group_, so that the state is shared
 * and remember for the given group. In order to detect the persistence for a
 * given element, we store the persistence key as a data attribute (`data-cx-focus`):
 *
 * ```html
 * <button data-cx-focus="myKey"></button>
 * ```
 *
 * Other keyboard focus directives can read the key to understand whether the element
 * should retrieve focus.
 *
 */
class PersistFocusDirective extends BlockFocusDirective {
    constructor(elementRef, service) {
        super(elementRef, service);
        this.elementRef = elementRef;
        this.service = service;
        this.defaultConfig = {};
        /**
         * The persistence key can be passed directly or through the `FocusConfig.key`.
         * While this could be considered a global key, the likeliness of conflicts
         * is very small since the key is cleared when the focus is changed.
         */
        // @Input('cxPersistFocus')
        this.config = {};
    }
    handleFocus(event) {
        this.service.set(this.key, this.group);
        event === null || event === void 0 ? void 0 : event.preventDefault();
        event === null || event === void 0 ? void 0 : event.stopPropagation();
    }
    ngOnInit() {
        super.ngOnInit();
        this.attr = this.key ? this.key : undefined;
    }
    setDefaultConfiguration() {
        if (typeof this.config === 'string' && this.config !== '') {
            this.config = { key: this.config };
        }
        super.setDefaultConfiguration();
    }
    /**
     * Focus the element explicitly if it was focused before.
     */
    ngAfterViewInit() {
        if (this.isPersisted) {
            this.host.focus({ preventScroll: true });
        }
    }
    get isPersisted() {
        return !!this.key && this.service.get(this.group) === this.key;
    }
    /**
     * Returns the key for the host element, which is used to persist the
     * focus state. This is useful in cases where the DOM is rebuild.
     */
    get key() {
        var _a;
        return (_a = this.config) === null || _a === void 0 ? void 0 : _a.key;
    }
    /**
     * returns the persistence group (if any) for the focusable elements.
     */
    get group() {
        return this.service.getPersistenceGroup(this.host, this.config);
    }
}
PersistFocusDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PersistFocusDirective, deps: [{ token: i0.ElementRef }, { token: PersistFocusService }], target: i0.ɵɵFactoryTarget.Directive });
PersistFocusDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.5", type: PersistFocusDirective, host: { listeners: { "focus": "handleFocus($event)" }, properties: { "attr.data-cx-focus": "this.attr" } }, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PersistFocusDirective, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: PersistFocusService }]; }, propDecorators: { attr: [{
                type: HostBinding,
                args: [`attr.${FOCUS_ATTR}`]
            }], handleFocus: [{
                type: HostListener,
                args: ['focus', ['$event']]
            }] } });

class SelectFocusUtility {
    constructor() {
        /**
         * Query selectors used to query focusable child elements of the host element.
         * The selectors are supplemented with `:not([disabled])` and `:not([hidden])`.
         */
        this.focusableSelectors = [
            'a[href]',
            'button',
            '[tabindex]',
            'input',
            'select',
            'textarea',
        ];
        // like to leave out the following as we don't use it, and make this list exensible.
        //   `[contentEditable=true]`, // very unlikely to suport as we're not a business tool
        //   `iframe`, // we really don't like iframes...
        //   `area[href]`, // very debatable!
        this.focusableSelectorSuffix = ':not([disabled]):not([hidden])';
    }
    query(host, selector) {
        if (!selector || selector === '') {
            return [];
        }
        return Array.from(host.querySelectorAll(selector));
    }
    findFirstFocusable(host, config = { autofocus: true }) {
        const selector = typeof (config === null || config === void 0 ? void 0 : config.autofocus) === 'string' ? config.autofocus : '[autofocus]';
        // fallback to first focusable
        return (this.query(host, selector).find((el) => !this.isHidden(el)) ||
            this.findFocusable(host).find((el) => Boolean(el)));
    }
    /**
     * returns all focusable child elements of the host element. The element selectors
     * are build from the `focusableSelectors`.
     *
     * @param host the `HTMLElement` used to query focusable elements
     * @param locked indicates whether inactive (`tabindex="-1"`) focusable elements should be returned
     * @param invisible indicates whether hidden focusable elements should be returned
     */
    findFocusable(host, locked = false, invisible = false) {
        let suffix = this.focusableSelectorSuffix;
        if (!locked) {
            suffix += `:not([tabindex='-1'])`;
        }
        const selector = this.focusableSelectors
            .map((s) => (s += suffix))
            .join(',');
        return this.query(host, selector).filter((el) => !invisible ? !this.isHidden(el) : Boolean(el));
    }
    /**
     * Indicates whether the element is hidden by CSS. There are various CSS rules and
     * HTML structures which can lead to an hidden or invisible element. An `offsetParent`
     * of null indicates that the element or any of it's decendants is hidden (`display:none`).
     *
     * Oother techniques use the visibility (`visibility: hidden`), opacity (`opacity`) or
     * phyisical location on the element itself or any of it's anchestor elements. Those
     * technique require to work with the _computed styles_, which will cause a performance
     * downgrade. We don't do this in the standard implementaton.
     */
    isHidden(el) {
        return el.offsetParent === null;
    }
}
SelectFocusUtility.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SelectFocusUtility, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
SelectFocusUtility.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SelectFocusUtility, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SelectFocusUtility, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class EscapeFocusService extends PersistFocusService {
    constructor(selectFocusUtil) {
        super();
        this.selectFocusUtil = selectFocusUtil;
    }
    shouldFocus(config) {
        return !!(config === null || config === void 0 ? void 0 : config.focusOnEscape);
    }
    handleEscape(host, config, event) {
        var _a;
        if (this.shouldFocus(config)) {
            if (host !== event.target) {
                host.focus({ preventScroll: true });
                event.preventDefault();
                event.stopPropagation();
            }
            else {
                if (config === null || config === void 0 ? void 0 : config.focusOnDoubleEscape) {
                    (_a = this.selectFocusUtil
                        .findFirstFocusable(host, { autofocus: true })) === null || _a === void 0 ? void 0 : _a.focus();
                }
            }
        }
    }
}
EscapeFocusService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: EscapeFocusService, deps: [{ token: SelectFocusUtility }], target: i0.ɵɵFactoryTarget.Injectable });
EscapeFocusService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: EscapeFocusService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: EscapeFocusService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: SelectFocusUtility }]; } });

/**
 * Directive to focus the host element whenever the `escape` key is captured.
 * UiEvents bubble up by nature, which is why the `cxEscGroup` can be used
 * on a tree of elements. Each time the escape key is used, the focus will
 * move up in the DOM tree.
 *
 */
class EscapeFocusDirective extends PersistFocusDirective {
    constructor(elementRef, service) {
        super(elementRef, service);
        this.elementRef = elementRef;
        this.service = service;
        this.defaultConfig = { focusOnEscape: true };
        this.esc = new EventEmitter();
    }
    /**
     * Handles the escape key event.
     * @param event the native keyboard event which contains the escape keydown event
     */
    handleEscape(event) {
        if (this.service.shouldFocus(this.config)) {
            this.service.handleEscape(this.host, this.config, event);
        }
        this.esc.emit(this.service.shouldFocus(this.config));
    }
    ngOnInit() {
        if (this.service.shouldFocus(this.config)) {
            this.requiredTabindex = -1;
        }
        super.ngOnInit();
    }
}
EscapeFocusDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: EscapeFocusDirective, deps: [{ token: i0.ElementRef }, { token: EscapeFocusService }], target: i0.ɵɵFactoryTarget.Directive });
EscapeFocusDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.5", type: EscapeFocusDirective, outputs: { esc: "esc" }, host: { listeners: { "keydown.escape": "handleEscape($event)" } }, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: EscapeFocusDirective, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: EscapeFocusService }]; }, propDecorators: { esc: [{
                type: Output
            }], handleEscape: [{
                type: HostListener,
                args: ['keydown.escape', ['$event']]
            }] } });

class AutoFocusService extends EscapeFocusService {
    /**
     * Returns the first focusable child element of the host element.
     */
    findFirstFocusable(host, config = { autofocus: true }) {
        if ((config === null || config === void 0 ? void 0 : config.autofocus) === ':host') {
            return host;
        }
        else if (this.hasPersistedFocus(host, config)) {
            return this.getPersisted(host, this.getPersistenceGroup(host, config));
        }
        else {
            return this.selectFocusUtil.findFirstFocusable(host, config) || host;
        }
    }
    /**
     * Indicates whether any of the focusable child elements is focused.
     */
    hasPersistedFocus(host, config) {
        return !!this.getPersisted(host, this.getPersistenceGroup(host, config));
    }
    /**
     * Returns the element that has a persisted focus state.
     *
     * @param host the `HTMLElement` used to query for focusable children
     * @param group the optional group for the persistent state, to separate different focus
     *   groups and remain the persistence
     */
    getPersisted(host, group) {
        if (!this.get(group)) {
            return;
        }
        const focussed = Array.from(host.querySelectorAll(`[${FOCUS_ATTR}='${this.get(group)}']`));
        return focussed.length > 0 ? focussed[0] : null;
    }
}
AutoFocusService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AutoFocusService, deps: null, target: i0.ɵɵFactoryTarget.Injectable });
AutoFocusService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AutoFocusService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AutoFocusService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Directive that focus the first nested _focusable_ element based on state and configuration:
 *
 * 1. focusable element that was left in a focused state (aka _persisted_ focus)
 * 2. focusable element selected by configured CSS selector (i.e. 'button[type=submit]')
 * 3. focusable element marked with the native HTML5 `autofocus` attribute
 * 4. first focusable element
 * 5. the host element, in case the configured CSS selector is `:host`.
 *
 * Example configurations:
 *
 * `<div cxAutoFocus>[...]</div>`
 *
 * `<div [cxAutoFocus]="{autofocus: false}">[...]</div>`
 *
 * `<div [cxAutoFocus]="{autofocus: 'button.active'}">[...]</div>`
 *
 * `<div [cxAutoFocus]="{autofocus: ':host'}">[...]</div>`
 *
 * When your element is added dynamically (ie. by using an *ngIf or after a DOM change), the
 * focus can be refreshed by using the refreshFocus configuration.
 */
class AutoFocusDirective extends EscapeFocusDirective {
    constructor(elementRef, service) {
        super(elementRef, service);
        this.elementRef = elementRef;
        this.service = service;
        /** The AutoFocusDirective will be using autofocus by default  */
        this.defaultConfig = { autofocus: true };
    }
    /**
     * Focus the element explicitly if it was focussed before.
     */
    ngAfterViewInit() {
        if (this.shouldAutofocus) {
            this.handleFocus();
        }
        if (!this.shouldAutofocus || this.hasPersistedFocus) {
            super.ngAfterViewInit();
        }
    }
    ngOnChanges(changes) {
        var _a;
        // responsible for refresh focus based on the configured refresh property name
        if (!!((_a = changes.config.currentValue) === null || _a === void 0 ? void 0 : _a.refreshFocus)) {
            // ensure the autofocus when it's to provided initially
            if (!this.config.autofocus) {
                this.config.autofocus = true;
            }
            this.handleFocus();
        }
        super.ngOnChanges(changes);
    }
    /**
     * Mimic the focus without setting the actual focus on the host. The first
     * focusable child element will be focussed.
     */
    handleFocus(event) {
        var _a;
        if (this.shouldAutofocus) {
            if (!(event === null || event === void 0 ? void 0 : event.target) || event.target === this.host) {
                (_a = this.firstFocusable) === null || _a === void 0 ? void 0 : _a.focus();
            }
            else {
                event.target.focus();
            }
        }
        super.handleFocus(event);
    }
    /**
     * Helper function to get the first focusable child element
     */
    get hasPersistedFocus() {
        return this.service.hasPersistedFocus(this.host, this.config);
    }
    /**
     * Helper function to indicate whether we should use autofocus for the
     * child elements.
     */
    get shouldAutofocus() {
        var _a;
        return !!((_a = this.config) === null || _a === void 0 ? void 0 : _a.autofocus);
    }
    /**
     * Helper function to get the first focusable child element.
     *
     * We keep this private to not pollute the API.
     */
    get firstFocusable() {
        return this.service.findFirstFocusable(this.host, this.config);
    }
}
AutoFocusDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AutoFocusDirective, deps: [{ token: i0.ElementRef }, { token: AutoFocusService }], target: i0.ɵɵFactoryTarget.Directive });
AutoFocusDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.5", type: AutoFocusDirective, usesInheritance: true, usesOnChanges: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AutoFocusDirective, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: AutoFocusService }]; } });

class TabFocusService extends AutoFocusService {
    /**
     * Moves to the next (or previous) tab.
     */
    moveTab(host, config, increment, event) {
        if (config === null || config === void 0 ? void 0 : config.tab) {
            const next = config.tab === 'scroll'
                ? this.findNextScrollable(host, config, increment)
                : this.findNext(host, config, increment);
            next === null || next === void 0 ? void 0 : next.focus();
            event.preventDefault();
            event.stopPropagation();
        }
    }
    /**
     * builds out virtual slides out of the full scrollable area, to allow
     * for maximum flexibility for the underlying layout without using hardcoded
     * slide sizes.
     */
    findNextScrollable(host, config, increment) {
        var _a;
        const active = this.getActiveChild(host, config);
        if (!active) {
            return;
        }
        // slide count
        const virtualSlideCount = Math.round(host.scrollWidth / host.clientWidth);
        // find current virtual slide
        const currentVirtualSlide = Math.round(active.offsetLeft / (host.scrollWidth / virtualSlideCount));
        let nextVirtualSlide = currentVirtualSlide + increment;
        if (increment === 1 /* NEXT */ &&
            nextVirtualSlide >= virtualSlideCount) {
            nextVirtualSlide = 0;
        }
        if (increment === -1 /* PREV */ && nextVirtualSlide < 0) {
            nextVirtualSlide = virtualSlideCount - 1;
        }
        const firstItemOnNextSlide = (_a = this.getChildren(host, config)) === null || _a === void 0 ? void 0 : _a.find((tab) => tab.offsetLeft >=
            (host.scrollWidth / virtualSlideCount) * nextVirtualSlide);
        return firstItemOnNextSlide;
    }
    findNext(host, config, increment) {
        const childs = this.getChildren(host, config);
        let activeIndex = childs === null || childs === void 0 ? void 0 : childs.findIndex((c) => c === this.getActiveChild(host, config));
        if (!activeIndex || activeIndex === -1) {
            activeIndex = 0;
        }
        activeIndex += increment;
        if (increment === 1 /* NEXT */ && activeIndex >= (childs === null || childs === void 0 ? void 0 : childs.length)) {
            activeIndex = childs.length - 1;
        }
        if (increment === -1 /* PREV */ && activeIndex < 0) {
            activeIndex = 0;
        }
        return childs ? childs[activeIndex] : undefined;
    }
    /**
     * Returns the active focusable child element. If there's no active
     * focusable child element, the first focusable child is returned.
     */
    getActiveChild(host, config) {
        const persisted = this.getPersisted(host, config === null || config === void 0 ? void 0 : config.group);
        if (persisted) {
            return persisted;
        }
        const children = this.getChildren(host, config);
        let index = children.findIndex((tab) => this.isActive(tab));
        if (!index || index === -1) {
            index = 0;
        }
        return children[index];
    }
    getChildren(host, config) {
        if (typeof config.tab === 'string' && config.tab !== 'scroll') {
            return this.selectFocusUtil.query(host, config.tab);
        }
        else {
            return this.findFocusable(host, true);
        }
    }
    /**
     * Returns all focusable child elements of the host element.
     *
     * @param host The host element is used to query child focusable elements.
     * @param locked Indicates if locked elements (tabindex=-1) should be returned, defaults to false.
     * @param invisible Indicates if invisible child elements should be returned, defaults to false.
     */
    findFocusable(host, locked = false, invisible = false) {
        return this.selectFocusUtil.findFocusable(host, locked, invisible);
    }
    isActive(el) {
        const child = document.activeElement;
        const selector = child.tagName;
        return (el === child ||
            !!Array.from(el.querySelectorAll(selector)).find((e) => e === child));
    }
}
TabFocusService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: TabFocusService, deps: null, target: i0.ɵɵFactoryTarget.Injectable });
TabFocusService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: TabFocusService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: TabFocusService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Directive to move the focus of ("locked") child elements. This is useful
 * for a nested list of tabs, carousel slides or any group of elements that
 * requires horizontal navigation.
 */
class TabFocusDirective extends AutoFocusDirective {
    constructor(elementRef, service) {
        super(elementRef, service);
        this.elementRef = elementRef;
        this.service = service;
        /** `tab` defaults to true if the directive `cxTabFocus` is used. */
        this.defaultConfig = { tab: true };
        // @Input('cxTabFocus')
        this.config = {};
    }
    handleNextTab(event) {
        var _a;
        if ((_a = this.config) === null || _a === void 0 ? void 0 : _a.tab) {
            this.service.moveTab(this.host, this.config, 1 /* NEXT */, event);
        }
    }
    handlePreviousTab(event) {
        var _a;
        if ((_a = this.config) === null || _a === void 0 ? void 0 : _a.tab) {
            this.service.moveTab(this.host, this.config, -1 /* PREV */, event);
        }
    }
}
TabFocusDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: TabFocusDirective, deps: [{ token: i0.ElementRef }, { token: TabFocusService }], target: i0.ɵɵFactoryTarget.Directive });
TabFocusDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.5", type: TabFocusDirective, host: { listeners: { "keydown.arrowRight": "handleNextTab($event)", "keydown.arrowLeft": "handlePreviousTab($event)" } }, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: TabFocusDirective, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: TabFocusService }]; }, propDecorators: { handleNextTab: [{
                type: HostListener,
                args: ['keydown.arrowRight', ['$event']]
            }], handlePreviousTab: [{
                type: HostListener,
                args: ['keydown.arrowLeft', ['$event']]
            }] } });

class TrapFocusService extends TabFocusService {
    /**
     * Indicates whether any of the child elements of the host are focusable.
     *
     * @param host `HTMLElement` that is used to query the focusable elements.
     */
    hasFocusableChildren(host) {
        return this.findFocusable(host).length > 0;
    }
    /**
     * Focus the next or previous element of all available focusable elements.
     * The focus is _trapped_ in case there's no next or previous available element.
     * The focus will automatically move the start or end of the list.
     */
    moveFocus(host, config, increment, event) {
        const focusable = this.findFocusable(host);
        let index = focusable.findIndex((v) => v === event.target) + increment;
        const shouldMoveFocus = (index >= 0 && index < focusable.length) ||
            (index < 0 && this.getTrapStart(config.trap)) ||
            (index >= focusable.length && this.getTrapEnd(config.trap));
        if (shouldMoveFocus) {
            if (index >= focusable.length) {
                index = 0;
            }
            if (index < 0) {
                index = focusable.length - 1;
            }
            event.preventDefault();
            event.stopPropagation();
            const el = focusable[index];
            el.focus();
        }
    }
    getTrapStart(trap) {
        return trap === true || trap === TrapFocus.start;
    }
    getTrapEnd(trap) {
        return trap === true || trap === TrapFocus.end;
    }
}
TrapFocusService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: TrapFocusService, deps: null, target: i0.ɵɵFactoryTarget.Injectable });
TrapFocusService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: TrapFocusService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: TrapFocusService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Directive that keeps the focus inside the focusable child elements,
 * also known as a _focus trap_.
 */
class TrapFocusDirective extends TabFocusDirective {
    constructor(elementRef, service) {
        super(elementRef, service);
        this.elementRef = elementRef;
        this.service = service;
        this.defaultConfig = { trap: true };
        // @Input('cxTrapFocus')
        this.config = {};
        this.handleTrapDown = (event) => {
            if (!!this.config.trap) {
                this.moveFocus(event, 1 /* NEXT */);
            }
        };
        this.handleTrapUp = (event) => {
            if (!!this.config.trap) {
                this.moveFocus(event, -1 /* PREV */);
            }
        };
    }
    /**
     * Moves the focus of the element reference up or down, depending on the increment.
     * The focus of the element is trapped to avoid it from going out of the group.
     *
     * @param event UIEvent that is used to get the target element. The event is blocked
     *   from standard execution and further bubbling.
     * @param increment indicates whether the next or previous is focussed.
     */
    moveFocus(event, increment) {
        if (this.service.hasFocusableChildren(this.host)) {
            this.service.moveFocus(this.host, this.config, increment, event);
        }
    }
}
TrapFocusDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: TrapFocusDirective, deps: [{ token: i0.ElementRef }, { token: TrapFocusService }], target: i0.ɵɵFactoryTarget.Directive });
TrapFocusDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.5", type: TrapFocusDirective, host: { listeners: { "keydown.arrowdown": "handleTrapDown($event)", "keydown.tab": "handleTrapDown($event)", "keydown.arrowup": "handleTrapUp($event)", "keydown.shift.tab": "handleTrapUp($event)" } }, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: TrapFocusDirective, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: TrapFocusService }]; }, propDecorators: { handleTrapDown: [{
                type: HostListener,
                args: ['keydown.arrowdown', ['$event']]
            }, {
                type: HostListener,
                args: ['keydown.tab', ['$event']]
            }], handleTrapUp: [{
                type: HostListener,
                args: ['keydown.arrowup', ['$event']]
            }, {
                type: HostListener,
                args: ['keydown.shift.tab', ['$event']]
            }] } });

class LockFocusService extends TrapFocusService {
}
LockFocusService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: LockFocusService, deps: null, target: i0.ɵɵFactoryTarget.Injectable });
LockFocusService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: LockFocusService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: LockFocusService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Focusable elements exclude hidden elements by default, but this contradicts with
 * unlocking (hidden) elements.
 */
const UNLOCK_HIDDEN_ELEMENTS = true;
/**
 * Directive that adds persistence for focussed element in case
 * the elements are being rebuild. This happens often when change
 * detection kicks in because of new data set from the backend.
 */
class LockFocusDirective extends TrapFocusDirective {
    constructor(elementRef, service, renderer) {
        super(elementRef, service);
        this.elementRef = elementRef;
        this.service = service;
        this.renderer = renderer;
        this.defaultConfig = { lock: true };
        // @Input('cxLockFocus')
        this.config = {};
        /**
         * Emits an event when the host is unlocked.
         */
        this.unlock = new EventEmitter();
    }
    /**
     * When the user selects enter or space, the focusable childs are
     * unlocked, which means that the tabindex is set to 0.
     */
    handleEnter(event) {
        if (this.shouldLock && this.host === event.target) {
            this.unlockFocus(event);
            event.preventDefault();
            event.stopPropagation();
        }
    }
    /**
     * In case any of the children elements is touched by the mouse,
     * we unlock the group to not break the mouse-experience.
     */
    handleClick(event) {
        if (this.shouldLock && this.isLocked) {
            this.unlockFocus(event);
            event.stopPropagation();
        }
    }
    lockFocus() {
        this.addTabindexToChildren(-1);
    }
    unlockFocus(event) {
        this.unlock.emit(true);
        this.addTabindexToChildren(0);
        // we focus the host if the event was triggered from a child
        if ((event === null || event === void 0 ? void 0 : event.target) === this.host) {
            // we wait a few milliseconds, mainly because firefox will otherwise apply
            // the mouse event on the new focused child element
            setTimeout(() => {
                super.handleFocus(event);
            }, 100);
        }
    }
    ngOnInit() {
        var _a, _b;
        super.ngOnInit();
        this.shouldLock = (_a = this.config) === null || _a === void 0 ? void 0 : _a.lock;
        if (this.shouldLock) {
            this.tabindex = 0;
            // Locked elements will be set to `autofocus` by default if it's not
            // been configured. This will ensure that autofocus kicks in upon unlock.
            if (!this.config.hasOwnProperty('autofocus')) {
                this.config.autofocus = true;
            }
            // Locked elements will be set to `focusOnEscape` by default if it's not
            // been configured. This will ensure that  the host gets locked again when
            // `escape` is pressed.
            if (!this.config.hasOwnProperty('focusOnEscape')) {
                this.config.focusOnEscape = !(((_b = this.config) === null || _b === void 0 ? void 0 : _b.focusOnEscape) === false);
            }
        }
    }
    ngAfterViewInit() {
        if (this.shouldLock) {
            /**
             * If the component hosts a group of focusable children elements,
             * we persist the group key to the children, so that they can taken this
             * into account when they persist their focus state.
             */
            if (!!this.group) {
                this.service.findFocusable(this.host).forEach((el) => 
                // we must do this in after view init as
                this.renderer.setAttribute(el, FOCUS_GROUP_ATTR, this.group));
            }
            if (this.shouldAutofocus) {
                this.handleFocus();
            }
        }
        super.ngAfterViewInit();
    }
    handleFocus(event) {
        if (this.shouldLock) {
            if (this.shouldUnlockAfterAutofocus(event)) {
                // Delay unlocking in case the host is using `ChangeDetectionStrategy.Default`
                setTimeout(() => this.unlockFocus(event));
            }
            else {
                setTimeout(() => this.lockFocus());
                event === null || event === void 0 ? void 0 : event.stopPropagation();
                return;
            }
        }
        super.handleFocus(event);
    }
    handleEscape(event) {
        if (this.shouldLock) {
            this.service.clear(this.config.group);
        }
        super.handleEscape(event);
    }
    /**
     * When the handleFocus is called without an actual event, it's coming from Autofocus.
     * In this case we unlock the focusable children in case there's a focusable child that
     * was unlocked before.
     *
     * We keep this private to not polute the API.
     */
    shouldUnlockAfterAutofocus(event) {
        return !event && this.service.hasPersistedFocus(this.host, this.config);
    }
    /**
     * Add the tabindex attribute to the focusable children elements
     */
    addTabindexToChildren(i = 0) {
        if (this.shouldLock) {
            this.isLocked = i === -1;
            if (!(this.hasFocusableChildren && i === 0) || i === 0) {
                this.focusable.forEach((el) => this.renderer.setAttribute(el, 'tabindex', i.toString()));
            }
        }
    }
    /**
     * Utility method, returns all focusable children for the host element.
     *
     * We keep this private to not polute the API.
     */
    get hasFocusableChildren() {
        return this.service.hasFocusableChildren(this.host);
    }
    /**
     * Returns the focusable children of the host element. If the host element
     * is configured to be locked, the query is restricted to child elements
     * with a tabindex !== `-1`.
     *
     * We keep this private to not polute the API.
     */
    get focusable() {
        return this.service.findFocusable(this.host, this.shouldLock, UNLOCK_HIDDEN_ELEMENTS);
    }
}
LockFocusDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: LockFocusDirective, deps: [{ token: i0.ElementRef }, { token: LockFocusService }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Directive });
LockFocusDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.5", type: LockFocusDirective, outputs: { unlock: "unlock" }, host: { listeners: { "keydown.enter": "handleEnter($event)", "keydown.space": "handleEnter($event)", "click": "handleClick($event)" }, properties: { "class.focus-lock": "this.shouldLock", "class.is-locked": "this.isLocked" } }, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: LockFocusDirective, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: LockFocusService }, { type: i0.Renderer2 }]; }, propDecorators: { shouldLock: [{
                type: HostBinding,
                args: ['class.focus-lock']
            }], isLocked: [{
                type: HostBinding,
                args: ['class.is-locked']
            }], unlock: [{
                type: Output
            }], handleEnter: [{
                type: HostListener,
                args: ['keydown.enter', ['$event']]
            }, {
                type: HostListener,
                args: ['keydown.space', ['$event']]
            }], handleClick: [{
                type: HostListener,
                args: ['click', ['$event']]
            }] } });

class KeyboardFocusService extends LockFocusService {
}
KeyboardFocusService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: KeyboardFocusService, deps: null, target: i0.ɵɵFactoryTarget.Injectable });
KeyboardFocusService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: KeyboardFocusService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: KeyboardFocusService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class FocusDirective extends LockFocusDirective {
    constructor(elementRef, service, renderer) {
        super(elementRef, service, renderer);
        this.elementRef = elementRef;
        this.service = service;
        this.renderer = renderer;
        this.defaultConfig = {};
        this.config = {};
    }
}
FocusDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: FocusDirective, deps: [{ token: i0.ElementRef }, { token: KeyboardFocusService }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Directive });
FocusDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.5", type: FocusDirective, selector: "[cxFocus]", inputs: { config: ["cxFocus", "config"] }, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: FocusDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cxFocus]',
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: KeyboardFocusService }, { type: i0.Renderer2 }]; }, propDecorators: { config: [{
                type: Input,
                args: ['cxFocus']
            }] } });

/**
 * @deprecated since 4.2, refer to spartacus issues (#13762)
 */
const defaultKeyboardFocusConfig = {
    keyboardFocus: {
        enableResetFocusOnNavigate: false,
        enableResetViewOnNavigate: false,
    },
};

/**
 * @deprecated since 4.2, refer to spartacus issues (#13762)
 */
class KeyboardFocusConfig {
}
KeyboardFocusConfig.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: KeyboardFocusConfig, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
KeyboardFocusConfig.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: KeyboardFocusConfig, providedIn: 'root', useExisting: Config });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: KeyboardFocusConfig, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                    useExisting: Config,
                }]
        }] });

/**
 * The `BREAKPOINT` typing defaults to five default screen names:
 * xs, sm, md, lg, xl.
 *
 * The type can be extended to allow for custom screens, such as XLL or `tablet`.
 *
 * While the screen names are fully configurable, other features might have
 * pre-configured layout settings per screen. Page layouts or table configurations,
 * for example, are driven by screen size. In case you change the screen size or
 * introduce new screen names, you might loose out on these configurations.
 */
var BREAKPOINT;
(function (BREAKPOINT) {
    BREAKPOINT["xs"] = "xs";
    BREAKPOINT["sm"] = "sm";
    BREAKPOINT["md"] = "md";
    BREAKPOINT["lg"] = "lg";
    BREAKPOINT["xl"] = "xl";
})(BREAKPOINT || (BREAKPOINT = {}));
/**
 * The LayoutConfig supports the configuration of page slots by page templates
 * or page sections, such as headers and footers. The configuration also supports
 * adaptive design per breakpoint (not per device type), so that the DOM is (re)rendered
 * por a given breakpoint.
 */
class LayoutConfig {
}
LayoutConfig.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: LayoutConfig, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
LayoutConfig.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: LayoutConfig, providedIn: 'root', useExisting: Config });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: LayoutConfig, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                    useExisting: Config,
                }]
        }] });

/**
 * The `BreakpointService` resolves the various screen sizes that are used in
 * the storefront. The screen sizes are globally configurable based on your
 * layout requirements. You can adjust the screen sizes by setting the minimum
 * and/or maximum size for a breakpoint, as well as extending the configuration
 * with new screens.
 *
 * By default, the `BreakpointService` is based on the breakpoints from the
 * Bootstrap ui library:
 * - `xs`: < 576px
 * - `sm`: 576px - 767px
 * - `md`: 768px - 991px
 * - `lg`: 992px - 1199px
 * - `xl`: >= 1200px
 */
class BreakpointService {
    constructor(winRef, layoutConfig, platform) {
        this.winRef = winRef;
        this.layoutConfig = layoutConfig;
        this.platform = platform;
        this.breakpoint$ = isPlatformBrowser(this.platform)
            ? this.winRef.resize$.pipe(map((event) => this.getBreakpoint(event.target.innerWidth)), distinctUntilChanged())
            : of(this.fallbackBreakpoint);
    }
    /**
     * Returns the breakpoints for the storefront layout.
     *
     * The breakpoints are driven by the `LayoutConfig.breakpoints` and sorted based on
     * the given screen size.
     */
    get breakpoints() {
        if (!this._breakpoints) {
            this._breakpoints = this.resolveBreakpointsFromConfig();
        }
        return this._breakpoints;
    }
    /**
     * Returns the _maximum_ size for the breakpoint, given by the `LayoutConfig.breakpoints`
     * configuration.
     */
    getSize(breakpoint) {
        var _a, _b;
        return ((_a = this.getMaxSize(breakpoint)) !== null && _a !== void 0 ? _a : 
        // if there's no direct max value or explicit max value
        // we must derive the max value from the previous min
        this.getMinSize((_b = this.breakpoints) === null || _b === void 0 ? void 0 : _b[this.breakpoints.indexOf(breakpoint) + 1]));
    }
    /**
     * Indicates whether the current screen size is smaller than the maximum size of the
     * given breakpoint.
     *
     * If the given breakpoint is `BREAKPOINT.md`, the method returns `true` when the
     * window innerWidth is smaller than the configured size of `BREAKPOINT.md`.
     */
    isDown(breakpoint) {
        return this.breakpoint$.pipe(map((br) => this.breakpoints
            .slice(0, this.breakpoints.indexOf(breakpoint) + 1)
            .includes(br)));
    }
    /**
     * Indicates whether the current screen size is larger than the minimum size of the
     * given breakpoint.
     *
     * If the given breakpoint is `BREAKPOINT.md`, the method returns `true` when the
     * window innerWidth is larger than the configured size of `BREAKPOINT.sm`.
     */
    isUp(breakpoint) {
        return this.breakpoint$.pipe(map((br) => this.breakpoints
            .slice(this.breakpoints.indexOf(breakpoint))
            .includes(br)));
    }
    /**
     * Indicates whether the given breakpoint fits in the current screen size.
     */
    isEqual(breakpoint) {
        return this.breakpoint$.pipe(map((br) => br === breakpoint));
    }
    /**
     * Returns the fallback breakpoint in case no breakpoint can be resolved. This is
     * typically the case when we're on SSR without an actual window.
     *
     * Returns the smallest screen size (mobile first).
     */
    get fallbackBreakpoint() {
        var _a;
        return (_a = this.breakpoints) === null || _a === void 0 ? void 0 : _a[0];
    }
    /**
     * Resolves the breakpoints and sorts them according to the configured size.
     *
     * The sort order is by small to large screens.
     */
    resolveBreakpointsFromConfig() {
        const sortByScreenSize = (next, prev) => {
            const maxNext = Math.max(this.getMinSize(next) + 1 || 0, this.getMaxSize(next) || 0);
            const maxPrev = Math.max(this.getMinSize(prev) + 1 || 0, this.getMaxSize(prev) || 0);
            return maxNext < maxPrev ? -1 : 0;
        };
        return Object.keys(this.config).sort(sortByScreenSize);
    }
    /**
     * Returns the _maximum_ size for the breakpoint, given by the
     * `LayoutConfig.breakpoints` configuration. We will try to resolve the
     * max size form the current breakpoint, but if this is not available, we
     * resolve it form the next breakpoint
     */
    getMaxSize(breakpoint) {
        const breakpointConfig = this.config[breakpoint];
        if (!breakpointConfig) {
            return null;
        }
        // we treat numbers as the max number by default
        if (typeof breakpointConfig === 'number') {
            return breakpointConfig;
        }
        else if (breakpointConfig.max) {
            return breakpointConfig.max;
        }
        else {
            return null;
        }
    }
    getMinSize(breakpoint) {
        var _a;
        return (_a = this.config[breakpoint]) === null || _a === void 0 ? void 0 : _a.min;
    }
    /**
     * Returns a `BREAKPOINT` for the given window size.
     *
     * This method tries to match the closest breakpoint for the given
     * window size. We'll fallback to the `largest` size in case the window
     * is greater than the largest configurable breakpoint.
     *
     * The windowWidth should be smaller than the maximum size of any of the
     * screen sizes defined in the `LayoutConfig.breakpoints`.
     */
    getBreakpoint(windowWidth) {
        var _a, _b;
        return ((_a = this.breakpoints.find((br) => windowWidth < this.getSize(br))) !== null && _a !== void 0 ? _a : (_b = this.breakpoints) === null || _b === void 0 ? void 0 : _b[this.breakpoints.length - 1]);
    }
    /**
     * Helper method to return the breakpoint configuration.
     */
    get config() {
        var _a;
        return ((_a = this.layoutConfig) === null || _a === void 0 ? void 0 : _a.breakpoints) || {};
    }
}
BreakpointService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: BreakpointService, deps: [{ token: i1.WindowRef }, { token: LayoutConfig }, { token: PLATFORM_ID }], target: i0.ɵɵFactoryTarget.Injectable });
BreakpointService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: BreakpointService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: BreakpointService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.WindowRef }, { type: LayoutConfig }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [PLATFORM_ID]
                }] }]; } });

/**
 * @deprecated since 4.2, refer to spartacus issues (#13762)
 * Shared service for keyboard focus features called when the browser navigates.
 */
class OnNavigateFocusService {
    constructor(config, router, breakpointService, winRef) {
        this.config = config;
        this.router = router;
        this.breakpointService = breakpointService;
        this.winRef = winRef;
    }
    ngOnDestroy() {
        var _a, _b;
        (_a = this.resetFocusOnNavigate) === null || _a === void 0 ? void 0 : _a.unsubscribe();
        (_b = this.resetViewOnNavigate) === null || _b === void 0 ? void 0 : _b.unsubscribe();
    }
    /**
     * Reads configuration and enables features based on flags set.
     */
    initializeWithConfig() {
        var _a, _b, _c, _d;
        if (!this.winRef.isBrowser()) {
            return;
        }
        if ((_b = (_a = this.config) === null || _a === void 0 ? void 0 : _a.keyboardFocus) === null || _b === void 0 ? void 0 : _b.enableResetFocusOnNavigate) {
            this.setResetFocusOnNavigate(this.config.keyboardFocus.enableResetFocusOnNavigate);
        }
        if ((_d = (_c = this.config) === null || _c === void 0 ? void 0 : _c.keyboardFocus) === null || _d === void 0 ? void 0 : _d.enableResetViewOnNavigate) {
            this.setResetViewOnNavigate(this.config.keyboardFocus.enableResetViewOnNavigate);
        }
    }
    /**
     * Resets focus back to body element in the DOM tree when a navigation is started.
     * @param enable Enable or disable this feature. Set this to an array of BREAKPOINTS to enable for specified screen widths.
     */
    setResetFocusOnNavigate(enable) {
        var _a;
        (_a = this.resetFocusOnNavigate) === null || _a === void 0 ? void 0 : _a.unsubscribe();
        if (enable) {
            this.resetFocusOnNavigate = this.router.events
                .pipe(filter((event) => event instanceof NavigationStart))
                .subscribe(() => {
                if (Array.isArray(enable)) {
                    this.breakpointService.breakpoint$
                        .pipe(take(1))
                        .subscribe((breakpoint) => {
                        if (enable.includes(breakpoint)) {
                            this.winRef.document.body.focus();
                        }
                    });
                }
                else if (typeof enable === 'boolean') {
                    this.winRef.document.body.focus();
                }
            });
        }
    }
    /**
     * Resets view back to body element in the DOM tree when a navigation is started.
     * @param enable Enable or disable this feature. Set this to an array of BREAKPOINTS to enable for specified screen widths.
     */
    setResetViewOnNavigate(enable) {
        var _a;
        (_a = this.resetViewOnNavigate) === null || _a === void 0 ? void 0 : _a.unsubscribe();
        if (enable) {
            this.resetViewOnNavigate = this.router.events
                .pipe(filter((event) => event instanceof NavigationStart))
                .subscribe(() => {
                if (Array.isArray(enable)) {
                    this.breakpointService.breakpoint$
                        .pipe(take(1))
                        .subscribe((breakpoint) => {
                        if (enable.includes(breakpoint)) {
                            this.winRef.document.body.scrollIntoView();
                        }
                    });
                }
                else if (typeof enable === 'boolean') {
                    this.winRef.document.body.scrollIntoView();
                }
            });
        }
    }
}
OnNavigateFocusService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OnNavigateFocusService, deps: [{ token: KeyboardFocusConfig }, { token: i1$1.Router }, { token: BreakpointService }, { token: i1.WindowRef }], target: i0.ɵɵFactoryTarget.Injectable });
OnNavigateFocusService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OnNavigateFocusService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OnNavigateFocusService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: KeyboardFocusConfig }, { type: i1$1.Router }, { type: BreakpointService }, { type: i1.WindowRef }]; } });

const directives = [
    // PersistFocusDirective,
    // VisibleFocusDirective,
    // BlockFocusDirective,
    // AutoFocusDirective,
    // EscapeFocusDirective,
    // LockFocusDirective,
    // TrapFocusDirective,
    // TabFocusDirective,
    FocusDirective,
];
/**
 * @deprecated since 4.2, refer to spartacus issues (#13762)
 * Remove the router module as well as it was part of the old initiative for scroll positiioning
 */
class KeyboardFocusModule {
}
KeyboardFocusModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: KeyboardFocusModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
KeyboardFocusModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: KeyboardFocusModule, declarations: [
        // PersistFocusDirective,
        // VisibleFocusDirective,
        // BlockFocusDirective,
        // AutoFocusDirective,
        // EscapeFocusDirective,
        // LockFocusDirective,
        // TrapFocusDirective,
        // TabFocusDirective,
        FocusDirective], imports: [CommonModule, i1.ConfigModule, RouterModule], exports: [
        // PersistFocusDirective,
        // VisibleFocusDirective,
        // BlockFocusDirective,
        // AutoFocusDirective,
        // EscapeFocusDirective,
        // LockFocusDirective,
        // TrapFocusDirective,
        // TabFocusDirective,
        FocusDirective] });
KeyboardFocusModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: KeyboardFocusModule, providers: [
        provideDefaultConfig(defaultKeyboardFocusConfig),
        {
            provide: APP_INITIALIZER,
            useFactory: keyboardFocusFactory,
            deps: [OnNavigateFocusService],
            multi: true,
        },
    ], imports: [[
            CommonModule,
            ConfigModule.withConfig(defaultKeyboardFocusConfig),
            RouterModule,
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: KeyboardFocusModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        ConfigModule.withConfig(defaultKeyboardFocusConfig),
                        RouterModule,
                    ],
                    declarations: [...directives],
                    providers: [
                        provideDefaultConfig(defaultKeyboardFocusConfig),
                        {
                            provide: APP_INITIALIZER,
                            useFactory: keyboardFocusFactory,
                            deps: [OnNavigateFocusService],
                            multi: true,
                        },
                    ],
                    exports: [...directives],
                }]
        }] });
/**
 *  @deprecated since 4.2, refer to spartacus issues (#13762)
 *  Start keyboard focus services on app initialization.
 */
function keyboardFocusFactory(onNavigateFocusService) {
    const isReady = () => onNavigateFocusService.initializeWithConfig();
    return isReady;
}

class MockKeyboardFocusDirective {
    constructor() {
        this.config = {};
    }
}
MockKeyboardFocusDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: MockKeyboardFocusDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
MockKeyboardFocusDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.5", type: MockKeyboardFocusDirective, selector: "[cxFocus]", inputs: { config: ["cxFocus", "config"] }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: MockKeyboardFocusDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cxFocus]',
                }]
        }], propDecorators: { config: [{
                type: Input,
                args: ['cxFocus']
            }] } });
class KeyboardFocusTestingModule {
}
KeyboardFocusTestingModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: KeyboardFocusTestingModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
KeyboardFocusTestingModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: KeyboardFocusTestingModule, declarations: [MockKeyboardFocusDirective], exports: [MockKeyboardFocusDirective] });
KeyboardFocusTestingModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: KeyboardFocusTestingModule });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: KeyboardFocusTestingModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [MockKeyboardFocusDirective],
                    exports: [MockKeyboardFocusDirective],
                }]
        }] });

// given that we're likely going to refactor the directives, we're
// export * from './autofocus/index';
// export * from './base/index';
// export * from './block/index';
// export * from './escape/index';
// export * from './lock/index';
// export * from './on-navigate/index';
// export * from './persist/index';
// export * from './tab/index';
// export * from './trap/index';
// export * from './visible/index';
// export * from './keyboard-focus.model';

/**
 * Types of dialog openings supported
 */
var DIALOG_TYPE;
(function (DIALOG_TYPE) {
    DIALOG_TYPE["POPOVER"] = "POPOVER";
    DIALOG_TYPE["POPOVER_CENTER"] = "POPOVER_CENTER";
    DIALOG_TYPE["POPOVER_CENTER_BACKDROP"] = "POPOVER_CENTER_BACKDROP";
    DIALOG_TYPE["DIALOG"] = "DIALOG";
    DIALOG_TYPE["SIDEBAR_START"] = "SIDEBAR_START";
    DIALOG_TYPE["SIDEBAR_END"] = "SIDEBAR_END";
})(DIALOG_TYPE || (DIALOG_TYPE = {}));

let LaunchRenderStrategy = class LaunchRenderStrategy {
    constructor(document, rendererFactory) {
        this.document = document;
        this.rendererFactory = rendererFactory;
        // List of called references; only used for rendered elements
        this.renderedCallers = [];
        /**
         * Classes to apply to the component when the dialog is a DIALOG
         */
        this.dialogClasses = ['d-block', 'fade', 'modal', 'show'];
        /**
         * Classes to apply to the component when the dialog is a POPOVER
         */
        this.popoverClasses = ['cx-dialog-popover'];
        /**
         * Classes to apply to the component when the dialog is a POPOVER_CENTER
         */
        this.popoverCenterClasses = ['cx-dialog-popover-center'];
        /**
         * Classes to apply to the component when the dialog is a POPOVER_CENTER with a backdrop
         */
        this.popoverCenterBackdropClasses = [
            'cx-dialog-popover-center-backdrop',
        ];
        /**
         * Classes to apply to the component when the dialog is a SIDEBAR_END
         */
        this.sidebarEndClasses = ['cx-sidebar-end'];
        /**
         * Classes to apply to the component when the dialog is a SIDEBAR_START
         */
        this.sidebarStartClasses = ['cx-sidebar-start'];
        this.renderer = rendererFactory.createRenderer(null, null);
    }
    /**
     * Determines if element should render
     *
     * @param caller
     * @param config
     */
    shouldRender(caller, config) {
        return (Boolean(config.component) &&
            (this.renderedCallers.some((el) => el.caller === caller)
                ? !!config.multi
                : true));
    }
    applyClasses(component, dialogType) {
        let classes = [];
        // TODO: make classes configurable
        switch (dialogType) {
            case DIALOG_TYPE.DIALOG:
                classes = this.dialogClasses;
                this.renderer.addClass(this.document.body, 'modal-open');
                break;
            case DIALOG_TYPE.POPOVER:
                classes = this.popoverClasses;
                break;
            case DIALOG_TYPE.POPOVER_CENTER:
                classes = this.popoverCenterClasses;
                break;
            case DIALOG_TYPE.POPOVER_CENTER_BACKDROP:
                classes = this.popoverCenterBackdropClasses;
                break;
            case DIALOG_TYPE.SIDEBAR_END:
                classes = this.sidebarEndClasses;
                break;
            case DIALOG_TYPE.SIDEBAR_START:
                classes = this.sidebarStartClasses;
                break;
        }
        for (const newClass of classes) {
            this.renderer.addClass(component.location.nativeElement, newClass);
        }
    }
    /**
     * Method to call when rendered element is destroyed
     * The element will be removed from the list of rendered elements
     *
     * @param caller
     * @param _config optional parameters used in children strategies
     */
    remove(caller, config) {
        var _a;
        this.renderedCallers = this.renderedCallers.filter((el) => el.caller !== caller);
        if (((_a = config) === null || _a === void 0 ? void 0 : _a.dialogType) === DIALOG_TYPE.DIALOG) {
            this.renderer.removeClass(this.document.body, 'modal-open');
        }
    }
    getPriority() {
        return -10 /* LOW */; // low, as it's a default matcher
    }
};
LaunchRenderStrategy = __decorate([
    __param(0, Inject(DOCUMENT))
], LaunchRenderStrategy);

class LaunchDialogService {
    constructor(renderStrategies, layoutConfig) {
        this.renderStrategies = renderStrategies;
        this.layoutConfig = layoutConfig;
        this._dialogClose = new BehaviorSubject(undefined);
        this._dataSubject = new BehaviorSubject(undefined);
        this.renderStrategies = this.renderStrategies || [];
    }
    get data$() {
        return this._dataSubject.asObservable();
    }
    /**
     * Open the dialog
     *
     * @param caller LAUNCH_CALLER
     * @param openElement button's Element ref
     * @param vcr View Container Ref of the container for inline rendering
     * @param data optional data which could be passed to dialog
     */
    openDialog(caller, openElement, vcr, data) {
        const component = this.launch(caller, vcr, data);
        if (component) {
            return combineLatest([component, this.dialogClose]).pipe(filter(([, close]) => close !== undefined), tap(([comp]) => {
                openElement === null || openElement === void 0 ? void 0 : openElement.nativeElement.focus();
                this.clear(caller);
                comp.destroy();
            }), map(([comp]) => comp));
        }
    }
    /**
     * Render the element based on the strategy from the launch configuration
     *
     * @param caller LAUNCH_CALLER
     * @param vcr View Container Ref of the container for inline rendering
     */
    launch(caller, vcr, data) {
        const config = this.findConfiguration(caller);
        if (config) {
            const renderer = this.getStrategy(config);
            // Render if the strategy exists
            if (renderer) {
                this._dialogClose.next(undefined);
                this._dataSubject.next(data);
                return renderer.render(config, caller, vcr);
            }
        }
        else if (isDevMode()) {
            console.warn('No configuration provided for caller ' + caller);
        }
    }
    /**
     * Opens dialog and subscribe in the service. Should be used if the trigger component might get destroyed while the component is open.
     *
     * @param caller Launch Caller
     * @param openElement Element to open
     * @param data Data to provide to the rendered element
     */
    openDialogAndSubscribe(caller, openElement, data) {
        var _a;
        (_a = this.openDialog(caller, openElement, undefined, data)) === null || _a === void 0 ? void 0 : _a.pipe(take(1)).subscribe();
    }
    /**
     * Util method to remove element from rendered elements list
     *
     * @param caller LAUNCH_CALLER
     */
    clear(caller) {
        const config = this.findConfiguration(caller);
        if (config) {
            const renderer = this.getStrategy(config);
            // Render if the strategy exists
            if (renderer) {
                renderer.remove(caller, config);
            }
        }
    }
    get dialogClose() {
        return this._dialogClose.asObservable();
    }
    closeDialog(reason) {
        this._dialogClose.next(reason);
    }
    /**
     * Returns the configuration for the caller
     *
     * @param caller LAUNCH_CALLER
     */
    findConfiguration(caller) {
        var _a;
        if ((_a = this.layoutConfig) === null || _a === void 0 ? void 0 : _a.launch) {
            return this.layoutConfig.launch[caller];
        }
        return undefined;
    }
    /**
     * Returns the render strategy based on the configuration
     *
     * @param config Configuration for launch
     */
    getStrategy(config) {
        return resolveApplicable(this.renderStrategies, [config]);
    }
}
LaunchDialogService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: LaunchDialogService, deps: [{ token: LaunchRenderStrategy }, { token: LayoutConfig }], target: i0.ɵɵFactoryTarget.Injectable });
LaunchDialogService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: LaunchDialogService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: LaunchDialogService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [LaunchRenderStrategy]
                }] }, { type: LayoutConfig }]; } });

class AnonymousConsentManagementBannerComponent {
    constructor(anonymousConsentsService, vcr, launchDialogService) {
        this.anonymousConsentsService = anonymousConsentsService;
        this.vcr = vcr;
        this.launchDialogService = launchDialogService;
        this.subscriptions = new Subscription();
        this.bannerVisible$ = this.anonymousConsentsService.isBannerVisible();
    }
    viewDetails() {
        this.hideBanner();
        const dialog = this.launchDialogService.openDialog("ANONYMOUS_CONSENT" /* ANONYMOUS_CONSENT */, null, this.vcr);
        if (dialog) {
            this.subscriptions.add(dialog.subscribe());
        }
    }
    allowAll() {
        this.subscriptions.add(this.anonymousConsentsService
            .giveAllConsents()
            .pipe(tap(() => this.hideBanner()))
            .subscribe());
    }
    hideBanner() {
        this.anonymousConsentsService.toggleBannerDismissed(true);
    }
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
    }
}
AnonymousConsentManagementBannerComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AnonymousConsentManagementBannerComponent, deps: [{ token: i1.AnonymousConsentsService }, { token: i0.ViewContainerRef }, { token: LaunchDialogService }], target: i0.ɵɵFactoryTarget.Component });
AnonymousConsentManagementBannerComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: AnonymousConsentManagementBannerComponent, selector: "cx-anonymous-consent-management-banner", ngImport: i0, template: "<ng-container *ngIf=\"bannerVisible$ | async as bannerVisible\">\n  <div\n    [ngClass]=\"{ 'anonymous-consent-banner-hidden': !bannerVisible }\"\n    class=\"anonymous-consent-banner\"\n  >\n    <div class=\"container\">\n      <div class=\"row\">\n        <div class=\"col-lg-8 col-xs-12\">\n          <div class=\"cx-banner-title\">\n            {{ 'anonymousConsents.banner.title' | cxTranslate }}\n          </div>\n          <div class=\"cx-banner-description\">\n            {{ 'anonymousConsents.banner.description' | cxTranslate }}\n          </div>\n        </div>\n\n        <div class=\"col-lg-4 col-xs-12 cx-banner-buttons\">\n          <button class=\"btn btn-action\" (click)=\"viewDetails()\">\n            {{ 'anonymousConsents.banner.viewDetails' | cxTranslate }}\n          </button>\n          <button class=\"btn btn-primary\" (click)=\"allowAll()\">\n            {{ 'anonymousConsents.banner.allowAll' | cxTranslate }}\n          </button>\n        </div>\n      </div>\n    </div>\n  </div>\n</ng-container>\n", directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }], pipes: { "async": i3.AsyncPipe, "cxTranslate": i1.TranslatePipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AnonymousConsentManagementBannerComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-anonymous-consent-management-banner',
                    templateUrl: './anonymous-consent-management-banner.component.html',
                }]
        }], ctorParameters: function () { return [{ type: i1.AnonymousConsentsService }, { type: i0.ViewContainerRef }, { type: LaunchDialogService }]; } });

class InlineRenderStrategy extends LaunchRenderStrategy {
    constructor(document, rendererFactory, componentFactoryResolver) {
        super(document, rendererFactory);
        this.document = document;
        this.rendererFactory = rendererFactory;
        this.componentFactoryResolver = componentFactoryResolver;
    }
    /**
     * Renders the component from the configuration in the view container ref
     *
     * @param config
     * @param caller
     * @param vcr
     */
    render(config, caller, vcr) {
        // Only render if a ViewContainerRef is provided
        if (vcr && this.shouldRender(caller, config)) {
            const template = this.componentFactoryResolver.resolveComponentFactory(config.component);
            const component = vcr.createComponent(template);
            if (config === null || config === void 0 ? void 0 : config.dialogType) {
                this.applyClasses(component, config === null || config === void 0 ? void 0 : config.dialogType);
            }
            this.renderedCallers.push({ caller, element: vcr.element, component });
            return of(component);
        }
        else if (isDevMode()) {
            if (!vcr) {
                console.warn(`No view container ref provided for ${caller}`);
            }
            else {
                console.warn(`Element for ${caller} already rendered. To allow multi rendering add property multi: true.`);
            }
        }
    }
    hasMatch(config) {
        return Boolean(config.inline);
    }
}
InlineRenderStrategy.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: InlineRenderStrategy, deps: [{ token: DOCUMENT }, { token: i0.RendererFactory2 }, { token: i0.ComponentFactoryResolver }], target: i0.ɵɵFactoryTarget.Injectable });
InlineRenderStrategy.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: InlineRenderStrategy, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: InlineRenderStrategy, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }, { type: i0.RendererFactory2 }, { type: i0.ComponentFactoryResolver }]; } });

class InlineRootRenderStrategy extends LaunchRenderStrategy {
    constructor(document, rendererFactory, componentFactoryResolver, injector) {
        super(document, rendererFactory);
        this.document = document;
        this.rendererFactory = rendererFactory;
        this.componentFactoryResolver = componentFactoryResolver;
        this.injector = injector;
    }
    get hostComponent() {
        var _a, _b;
        return (_b = (_a = this.injector.get(ApplicationRef)) === null || _a === void 0 ? void 0 : _a.components) === null || _b === void 0 ? void 0 : _b[0];
    }
    render(config, caller) {
        var _a, _b;
        if (this.shouldRender(caller, config)) {
            const componentFactory = this.componentFactoryResolver.resolveComponentFactory(config.component);
            const contentInjector = Injector.create({
                providers: [],
            });
            const componentRef = componentFactory.create(contentInjector);
            (_a = this.injector.get(ApplicationRef)) === null || _a === void 0 ? void 0 : _a.attachView(componentRef.hostView);
            this.renderer.appendChild((_b = this.hostComponent) === null || _b === void 0 ? void 0 : _b.location.nativeElement, componentRef.location.nativeElement);
            if (config === null || config === void 0 ? void 0 : config.dialogType) {
                this.applyClasses(componentRef, config === null || config === void 0 ? void 0 : config.dialogType);
            }
            this.renderedCallers.push({ caller, component: componentRef });
            return of(componentRef);
        }
    }
    hasMatch(config) {
        return Boolean(config.inlineRoot);
    }
}
InlineRootRenderStrategy.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: InlineRootRenderStrategy, deps: [{ token: DOCUMENT }, { token: i0.RendererFactory2 }, { token: i0.ComponentFactoryResolver }, { token: i0.Injector }], target: i0.ɵɵFactoryTarget.Injectable });
InlineRootRenderStrategy.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: InlineRootRenderStrategy, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: InlineRootRenderStrategy, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }, { type: i0.RendererFactory2 }, { type: i0.ComponentFactoryResolver }, { type: i0.Injector }]; } });

var OutletPosition;
(function (OutletPosition) {
    OutletPosition["REPLACE"] = "replace";
    OutletPosition["BEFORE"] = "before";
    OutletPosition["AFTER"] = "after";
})(OutletPosition || (OutletPosition = {}));
const AVOID_STACKED_OUTLETS = false;
const USE_STACKED_OUTLETS = true;
/**
 * Token for injecting outlet related context to the component rendered in the outlet
 */
class OutletContextData {
}

class OutletService {
    constructor() {
        this.templatesRefs = {
            [OutletPosition.BEFORE]: new Map(),
            [OutletPosition.REPLACE]: new Map(),
            [OutletPosition.AFTER]: new Map(),
        };
    }
    /**
     * @param templateOrFactory A `ComponentFactory` that inserts a component dynamically.
     */
    add(outlet, templateOrFactory, position = OutletPosition.REPLACE) {
        const store = this.templatesRefs[position];
        if (store) {
            const existing = store.get(outlet) || [];
            const newValue = existing.concat([templateOrFactory]);
            store.set(outlet, newValue);
        }
    }
    /**
     *
     * Returns a single object or multiple objects for the given outlet reference,
     * depending on the `stacked` argument.
     *
     * @param outlet The outlet reference
     * @param position the outlet position, `OutletPosition.before`, `OutletPosition.AFTER` or `OutletPosition.REPLACE`
     * @param stacked Indicates whether an array of outlet components is returned
     */
    get(outlet, position = OutletPosition.REPLACE, stacked = AVOID_STACKED_OUTLETS) {
        const store = this.templatesRefs[position] ||
            this.templatesRefs[OutletPosition.REPLACE];
        const templateRef = store.get(outlet);
        if (templateRef && !stacked) {
            return templateRef[0];
        }
        return templateRef;
    }
    remove(outlet, position = OutletPosition.REPLACE, value) {
        const store = this.templatesRefs[position] ||
            this.templatesRefs[OutletPosition.REPLACE];
        this.removeValueOrAll(store, outlet, value);
    }
    removeValueOrAll(store, outlet, value) {
        if (!value && store.has(outlet)) {
            store.delete(outlet);
        }
        else if (value && store.has(outlet)) {
            let existing = store.get(outlet);
            existing = existing.filter((val) => val !== value);
            store.set(outlet, existing);
        }
    }
}
OutletService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OutletService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
OutletService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OutletService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OutletService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class OutletRefDirective {
    constructor(tpl, outletService) {
        this.tpl = tpl;
        this.outletService = outletService;
    }
    ngOnInit() {
        this.outletService.add(this.cxOutletRef, this.tpl, this.cxOutletPos);
    }
    ngOnDestroy() {
        this.outletService.remove(this.cxOutletRef, this.cxOutletPos, this.tpl);
    }
}
OutletRefDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OutletRefDirective, deps: [{ token: i0.TemplateRef }, { token: OutletService }], target: i0.ɵɵFactoryTarget.Directive });
OutletRefDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.5", type: OutletRefDirective, selector: "[cxOutletRef]", inputs: { cxOutletRef: "cxOutletRef", cxOutletPos: "cxOutletPos" }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OutletRefDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cxOutletRef]',
                }]
        }], ctorParameters: function () { return [{ type: i0.TemplateRef }, { type: OutletService }]; }, propDecorators: { cxOutletRef: [{
                type: Input
            }], cxOutletPos: [{
                type: Input
            }] } });

class OutletRefModule {
}
OutletRefModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OutletRefModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
OutletRefModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OutletRefModule, declarations: [OutletRefDirective], imports: [CommonModule], exports: [OutletRefDirective] });
OutletRefModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OutletRefModule, imports: [[CommonModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OutletRefModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [OutletRefDirective],
                    exports: [OutletRefDirective],
                }]
        }] });

class OutletRendererService {
    constructor() {
        this.outletRefs = new BehaviorSubject(new Map());
    }
    /**
     * Dynamically render the templates in the specified array
     *
     * @param outlet
     */
    render(outlet) {
        if (this.outletRefs.value.size !== 0) {
            this.outletRefs.value.get(outlet).render();
        }
    }
    /**
     * Register outlet to be available to render dynamically
     *
     * @param cxOutlet
     * @param context
     */
    register(cxOutlet, context) {
        this.outletRefs.next(this.outletRefs.value.set(cxOutlet, context));
    }
    /**
     * Returns map of outlets
     *
     */
    getOutletRef(outlet) {
        return this.outletRefs.asObservable().pipe(map((val) => val.get(outlet)), filter(isNotNullable));
    }
}
OutletRendererService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OutletRendererService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
OutletRendererService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OutletRendererService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OutletRendererService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * The IntersectionService uses the native IntersectionObserver (v2), which
 * can be used to implement pre-loading and deferred loading of DOM content.
 *
 */
class IntersectionService {
    constructor(config) {
        this.config = config;
    }
    /**
     * Returns an Observable that emits only once a boolean value whenever
     * the given element has shown in the view port.
     *
     * The returned observable will only emit the first value. The
     * observable must be cleaned up either way, since the value might never emit; it
     *  depends on whether the element appears in the view port.
     */
    isIntersected(element, options) {
        return this.intersects(element, options).pipe(first((v) => v === true));
    }
    /**
     * Indicates whenever the element intersects the view port. An optional margin
     * is used to intersects before the element shows up in the viewport.
     * A value is emitted each time the element intersects.
     *
     * This is private for now, but could be exposed as a public API
     * to introduce additional (css) render effects to the UI.
     */
    intersects(element, options = {}) {
        const elementVisible$ = new Observable((observer) => {
            const rootMargin = this.getRootMargin(options);
            const intersectOptions = { rootMargin, threshold: options.threshold };
            const intersectionObserver = new IntersectionObserver((entries) => {
                observer.next(entries);
            }, intersectOptions);
            intersectionObserver.observe(element);
            return () => {
                intersectionObserver.disconnect();
            };
        }).pipe(flatMap((entries) => entries), map((entry) => entry.isIntersecting), distinctUntilChanged());
        return elementVisible$;
    }
    getRootMargin(options = {}) {
        if (options.rootMargin) {
            return options.rootMargin;
        }
        const layoutConfig = this.config;
        if (layoutConfig.deferredLoading &&
            layoutConfig.deferredLoading.intersectionMargin) {
            return layoutConfig.deferredLoading.intersectionMargin;
        }
    }
}
IntersectionService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: IntersectionService, deps: [{ token: LayoutConfig }], target: i0.ɵɵFactoryTarget.Injectable });
IntersectionService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: IntersectionService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: IntersectionService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: LayoutConfig }]; } });

/**
 * The defer loading serivce is used to defer loading of DOM elements
 * until the elements are required for the user experience.
 */
class DeferLoaderService {
    constructor(platformId, config, intersectionService) {
        this.platformId = platformId;
        this.config = config;
        this.intersectionService = intersectionService;
        this.globalLoadStrategy = config.deferredLoading
            ? config.deferredLoading.strategy
            : DeferLoadingStrategy.INSTANT;
    }
    /**
     * Defer loading till the element intersects the viewport.
     *
     * We evaluate whether we instantly load the element for different reasons:
     * - we run in SSR mode
     * - there's no global strategy given
     * - the global loading strategy is set to INSTANT loading,
     *   and the loading strategy in the given is not set to DEFER
     * - the loading strategy in the given options is set to INSTANT
     */
    load(element, options) {
        if (this.shouldLoadInstantly((options || {}).deferLoading)) {
            return of(true);
        }
        else {
            return this.intersectionService.isIntersected(element, options);
        }
    }
    shouldLoadInstantly(elementLoadingStrategy) {
        return (isPlatformServer(this.platformId) ||
            elementLoadingStrategy === DeferLoadingStrategy.INSTANT ||
            (elementLoadingStrategy !== DeferLoadingStrategy.DEFER &&
                this.globalLoadStrategy === DeferLoadingStrategy.INSTANT));
    }
}
DeferLoaderService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: DeferLoaderService, deps: [{ token: PLATFORM_ID }, { token: LayoutConfig }, { token: IntersectionService }], target: i0.ɵɵFactoryTarget.Injectable });
DeferLoaderService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: DeferLoaderService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: DeferLoaderService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: Object, decorators: [{
                    type: Inject,
                    args: [PLATFORM_ID]
                }] }, { type: LayoutConfig }, { type: IntersectionService }]; } });

class OutletDirective {
    constructor(vcr, templateRef, outletService, deferLoaderService, outletRendererService) {
        this.vcr = vcr;
        this.templateRef = templateRef;
        this.outletService = outletService;
        this.deferLoaderService = deferLoaderService;
        this.outletRendererService = outletRendererService;
        this.renderedTemplate = [];
        this.renderedComponents = new Map();
        /**
         * Observable with current outlet context
         */
        this.outletContext$ = new ReplaySubject(1);
        this.loaded = new EventEmitter(true);
        this.subscription = new Subscription();
    }
    /**
     * Renders view for outlet or defers it, depending on the input `cxOutletDefer`
     */
    render() {
        this.vcr.clear();
        this.renderedTemplate = [];
        this.renderedComponents.clear();
        this.subscription.unsubscribe();
        this.subscription = new Subscription();
        if (this.cxOutletDefer) {
            this.deferLoading();
        }
        else {
            this.build();
        }
    }
    ngOnChanges(changes) {
        if (changes.cxOutlet) {
            this.render();
            this.outletRendererService.register(this.cxOutlet, this);
        }
        if (changes.cxOutletContext) {
            this.outletContext$.next(this.cxOutletContext);
        }
    }
    deferLoading() {
        this.loaded.emit(false);
        const hostElement = this.getHostElement(this.vcr.element.nativeElement);
        // Although the deferLoaderService might emit only once, as long as the hostElement
        // isn't being loaded, there's no value being emitted. Therefore we need to clean up
        // the subscription on destroy.
        this.subscription.add(this.deferLoaderService
            .load(hostElement, this.cxOutletDefer)
            .subscribe(() => {
            this.build();
            this.loaded.emit(true);
        }));
    }
    /**
     * Renders view for outlet
     */
    build() {
        this.buildOutlet(OutletPosition.BEFORE);
        this.buildOutlet(OutletPosition.REPLACE);
        this.buildOutlet(OutletPosition.AFTER);
    }
    /**
     * Renders view in a given position for outlet
     */
    buildOutlet(position) {
        let templates = (this.outletService.get(this.cxOutlet, position, USE_STACKED_OUTLETS));
        templates = templates === null || templates === void 0 ? void 0 : templates.filter((el) => !this.renderedTemplate.includes(el));
        if (!templates && position === OutletPosition.REPLACE) {
            templates = [this.templateRef];
        }
        // Just in case someone extended the `OutletService` and
        // returns a singular object.
        if (!Array.isArray(templates)) {
            templates = [templates];
        }
        const components = [];
        templates.forEach((obj) => {
            const component = this.create(obj, position);
            components.push(component);
        });
        this.renderedComponents.set(position, components);
    }
    /**
     * Renders view based on the given template or component factory
     */
    create(tmplOrFactory, position) {
        this.renderedTemplate.push(tmplOrFactory);
        if (tmplOrFactory instanceof ComponentFactory) {
            const component = this.vcr.createComponent(tmplOrFactory, undefined, this.getComponentInjector(position));
            return component;
        }
        else if (tmplOrFactory instanceof TemplateRef) {
            const view = this.vcr.createEmbeddedView(tmplOrFactory, {
                $implicit: this.cxOutletContext,
            });
            // we do not know if content is created dynamically or not
            // so we apply change detection anyway
            view.markForCheck();
            return view;
        }
    }
    /**
     * Returns injector with OutletContextData that can be injected to the component
     * rendered in the outlet
     */
    getComponentInjector(position) {
        const contextData = {
            reference: this.cxOutlet,
            position,
            context: this.cxOutletContext,
            context$: this.outletContext$.asObservable(),
        };
        return Injector.create({
            providers: [
                {
                    provide: OutletContextData,
                    useValue: contextData,
                },
            ],
            parent: this.vcr.injector,
        });
    }
    /**
     * Returns the closest `HtmlElement`, by iterating over the
     * parent nodes of the given element.
     *
     * We avoid traversing the parent _elements_, as this is blocking
     * ie11 implementations. One of the spare exclusions we make to not
     * supporting ie11.
     *
     * @param element
     */
    getHostElement(element) {
        if (element instanceof HTMLElement) {
            return element;
        }
        return this.getHostElement(element.parentNode);
    }
    ngOnDestroy() {
        this.subscription.unsubscribe();
        this.outletContext$.complete();
    }
}
OutletDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OutletDirective, deps: [{ token: i0.ViewContainerRef }, { token: i0.TemplateRef }, { token: OutletService }, { token: DeferLoaderService }, { token: OutletRendererService }], target: i0.ɵɵFactoryTarget.Directive });
OutletDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.5", type: OutletDirective, selector: "[cxOutlet]", inputs: { cxOutlet: "cxOutlet", cxOutletContext: "cxOutletContext", cxOutletDefer: "cxOutletDefer" }, outputs: { loaded: "loaded" }, usesOnChanges: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OutletDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cxOutlet]',
                }]
        }], ctorParameters: function () { return [{ type: i0.ViewContainerRef }, { type: i0.TemplateRef }, { type: OutletService }, { type: DeferLoaderService }, { type: OutletRendererService }]; }, propDecorators: { cxOutlet: [{
                type: Input
            }], cxOutletContext: [{
                type: Input
            }], cxOutletDefer: [{
                type: Input
            }], loaded: [{
                type: Output
            }] } });

/**
 * @private We plan to drive the outlets by standard configuration
 */
const PROVIDE_OUTLET_OPTIONS = new InjectionToken('PROVIDE_OUTLET_OPTIONS');
/**
 * Helper function to register a component for an outlet.
 *
 * @param options.id unique id of the outlet
 * @param options.component Component to be registered for the outlet
 * @param options.position Component's position in the outlet (default: `OutletPosition.AFTER`)
 */
function provideOutlet(options) {
    return {
        provide: PROVIDE_OUTLET_OPTIONS,
        useValue: options,
        multi: true,
    };
}

/**
 * @private
 */
function registerOutletsFactory(providedOutletOptions, componentFactoryResolver, outletService) {
    const result = () => {
        (providedOutletOptions !== null && providedOutletOptions !== void 0 ? providedOutletOptions : []).forEach((options) => {
            var _a;
            const factory = componentFactoryResolver.resolveComponentFactory(options.component);
            outletService.add(options.id, factory, (_a = options.position) !== null && _a !== void 0 ? _a : OutletPosition.AFTER);
        });
    };
    return result;
}
class OutletModule {
    static forRoot() {
        return {
            ngModule: OutletModule,
            providers: [
                {
                    provide: APP_INITIALIZER,
                    useFactory: registerOutletsFactory,
                    deps: [
                        [new Optional(), PROVIDE_OUTLET_OPTIONS],
                        ComponentFactoryResolver,
                        OutletService,
                    ],
                    multi: true,
                },
            ],
        };
    }
}
OutletModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OutletModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
OutletModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OutletModule, declarations: [OutletDirective], imports: [CommonModule], exports: [OutletDirective] });
OutletModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OutletModule, imports: [[CommonModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OutletModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [OutletDirective],
                    exports: [OutletDirective],
                }]
        }] });

class OutletRenderStrategy extends LaunchRenderStrategy {
    constructor(document, rendererFactory, outletService, componentFactoryResolver, outletRendererService) {
        super(document, rendererFactory);
        this.document = document;
        this.rendererFactory = rendererFactory;
        this.outletService = outletService;
        this.componentFactoryResolver = componentFactoryResolver;
        this.outletRendererService = outletRendererService;
    }
    /**
     * Renders the element in the configured outlet
     *
     * @param config
     * @param caller
     * @param vcr
     */
    render(config, caller) {
        if (this.shouldRender(caller, config)) {
            const template = this.componentFactoryResolver.resolveComponentFactory(config.component);
            this.outletService.add(config.outlet, template, config.position ? config.position : OutletPosition.BEFORE);
            this.outletRendererService.render(config.outlet);
            this.renderedCallers.push({ caller });
            return this.outletRendererService.getOutletRef(config.outlet).pipe(map((outletDirective) => {
                const components = outletDirective.renderedComponents.get(config.position ? config.position : OutletPosition.BEFORE);
                return components
                    .reverse()
                    .find((component) => component.componentType === template.componentType);
            }), tap((component) => {
                if ((config === null || config === void 0 ? void 0 : config.dialogType) && component) {
                    this.applyClasses(component, config === null || config === void 0 ? void 0 : config.dialogType);
                }
            }));
        }
    }
    hasMatch(config) {
        return Boolean(config.outlet);
    }
    remove(caller, config) {
        const template = this.componentFactoryResolver.resolveComponentFactory(config.component);
        this.outletService.remove(config.outlet, config.position ? config.position : OutletPosition.BEFORE, template);
        super.remove(caller, config);
    }
}
OutletRenderStrategy.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OutletRenderStrategy, deps: [{ token: DOCUMENT }, { token: i0.RendererFactory2 }, { token: OutletService }, { token: i0.ComponentFactoryResolver }, { token: OutletRendererService }], target: i0.ɵɵFactoryTarget.Injectable });
OutletRenderStrategy.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OutletRenderStrategy, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OutletRenderStrategy, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }, { type: i0.RendererFactory2 }, { type: OutletService }, { type: i0.ComponentFactoryResolver }, { type: OutletRendererService }]; } });

class RoutingRenderStrategy extends LaunchRenderStrategy {
    constructor(document, rendererFactory, routingService) {
        super(document, rendererFactory);
        this.document = document;
        this.rendererFactory = rendererFactory;
        this.routingService = routingService;
    }
    /**
     * Navigates to the route configured for the caller
     */
    render(config, _caller) {
        this.routingService.go(config);
    }
    hasMatch(config) {
        return Boolean(config.cxRoute);
    }
}
RoutingRenderStrategy.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: RoutingRenderStrategy, deps: [{ token: DOCUMENT }, { token: i0.RendererFactory2 }, { token: i1.RoutingService }], target: i0.ɵɵFactoryTarget.Injectable });
RoutingRenderStrategy.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: RoutingRenderStrategy, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: RoutingRenderStrategy, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }, { type: i0.RendererFactory2 }, { type: i1.RoutingService }]; } });

class LaunchDialogModule {
    static forRoot() {
        return {
            ngModule: LaunchDialogModule,
            providers: [{ provide: LayoutConfig, useExisting: Config }],
        };
    }
}
LaunchDialogModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: LaunchDialogModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
LaunchDialogModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: LaunchDialogModule });
LaunchDialogModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: LaunchDialogModule, providers: [
        {
            provide: LaunchRenderStrategy,
            useExisting: OutletRenderStrategy,
            multi: true,
        },
        {
            provide: LaunchRenderStrategy,
            useExisting: InlineRenderStrategy,
            multi: true,
        },
        {
            provide: LaunchRenderStrategy,
            useExisting: RoutingRenderStrategy,
            multi: true,
        },
        {
            provide: LaunchRenderStrategy,
            useExisting: InlineRootRenderStrategy,
            multi: true,
        },
    ] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: LaunchDialogModule, decorators: [{
            type: NgModule,
            args: [{
                    providers: [
                        {
                            provide: LaunchRenderStrategy,
                            useExisting: OutletRenderStrategy,
                            multi: true,
                        },
                        {
                            provide: LaunchRenderStrategy,
                            useExisting: InlineRenderStrategy,
                            multi: true,
                        },
                        {
                            provide: LaunchRenderStrategy,
                            useExisting: RoutingRenderStrategy,
                            multi: true,
                        },
                        {
                            provide: LaunchRenderStrategy,
                            useExisting: InlineRootRenderStrategy,
                            multi: true,
                        },
                    ],
                }]
        }] });

var ICON_TYPE;
(function (ICON_TYPE) {
    ICON_TYPE["STAR"] = "STAR";
    ICON_TYPE["SEARCH"] = "SEARCH";
    ICON_TYPE["CART"] = "CART";
    ICON_TYPE["INFO"] = "INFO";
    ICON_TYPE["GRID"] = "GRID";
    ICON_TYPE["LIST"] = "LIST";
    ICON_TYPE["CARET_DOWN"] = "CARET_DOWN";
    ICON_TYPE["CARET_UP"] = "CARET_UP";
    ICON_TYPE["CARET_LEFT"] = "CARET_LEFT";
    ICON_TYPE["CARET_RIGHT"] = "CARET_RIGHT";
    ICON_TYPE["CLOSE"] = "CLOSE";
    ICON_TYPE["ERROR"] = "ERROR";
    ICON_TYPE["WARNING"] = "WARNING";
    ICON_TYPE["SUCCESS"] = "SUCCESS";
    ICON_TYPE["VISA"] = "VISA";
    ICON_TYPE["MASTER_CARD"] = "MASTER_CARD";
    ICON_TYPE["AMEX"] = "AMEX";
    ICON_TYPE["DINERS_CLUB"] = "DINERS_CLUB";
    ICON_TYPE["CREDIT_CARD"] = "CREDIT_CARD";
    ICON_TYPE["EXPAND"] = "EXPAND";
    ICON_TYPE["COLLAPSE"] = "COLLAPSE";
    ICON_TYPE["RESET"] = "RESET";
    ICON_TYPE["CIRCLE"] = "CIRCLE";
    ICON_TYPE["HEART"] = "HEART";
    ICON_TYPE["EMPTY_HEART"] = "EMPTY_HEART";
    ICON_TYPE["FILTER"] = "FILTER";
    ICON_TYPE["PENCIL"] = "PENCIL";
    ICON_TYPE["CLOCK"] = "CLOCK";
    ICON_TYPE["TRASH"] = "TRASH";
    ICON_TYPE["ACTIVE"] = "ACTIVE";
    ICON_TYPE["SORT_DOWN"] = "SORT_DOWN";
    ICON_TYPE["SORT"] = "SORT";
    ICON_TYPE["ON"] = "ON";
    ICON_TYPE["OFF"] = "OFF";
    ICON_TYPE["LINK_OUT"] = "LINK_OUT";
    ICON_TYPE["EXPAND_ARROWS"] = "EXPAND_ARROWS";
})(ICON_TYPE || (ICON_TYPE = {}));
class IconConfig {
}
IconConfig.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: IconConfig, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
IconConfig.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: IconConfig, providedIn: 'root', useExisting: Config });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: IconConfig, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                    useExisting: Config,
                }]
        }] });
/**
 * Each ICON type can have an companied resource type, such as SVG, LINK (font) or just TEXT.
 * The resources will be automatically loaded in case they're required for the `ICON_TYPE`.
 */
var IconResourceType;
(function (IconResourceType) {
    /**
     * An svg based icon requires an SVG resource that must be loaded,
     * this is typically a sprite svg file.
     */
    IconResourceType["SVG"] = "svg";
    /**
     * A font based ICON might require an additional CSS file to be loaded.
     */
    IconResourceType["LINK"] = "link";
    /**
     * Text based icons will simply add the ICON string to the DOM. Text icons do not need an image
     * or CSS pseudo class (i.e. :before), as the text itself is the icon (i.e. +)
     */
    IconResourceType["TEXT"] = "text";
})(IconResourceType || (IconResourceType = {}));

const fontawesomeIconConfig = {
    icon: {
        symbols: {
            SEARCH: 'fas fa-search',
            CART: 'fas fa-shopping-cart',
            INFO: 'fas fa-info-circle',
            STAR: 'fas fa-star',
            GRID: 'fas fa-th-large',
            LIST: 'fas fa-bars',
            CARET_UP: 'fas fa-angle-up',
            CARET_DOWN: 'fas fa-angle-down',
            CARET_RIGHT: 'fas fa-angle-right',
            CARET_LEFT: 'fas fa-angle-left',
            ERROR: 'fas fa-exclamation-circle',
            WARNING: 'fas fa-exclamation-triangle',
            SUCCESS: 'fas fa-check-circle',
            CLOSE: 'fas fa-times',
            VISA: 'fab fa-cc-visa',
            MASTER_CARD: 'fab fa-cc-mastercard',
            AMEX: 'fab fa-cc-amex',
            DINERS_CLUB: 'fab fa-cc-diners-club',
            CREDIT_CARD: 'fas fa-credit-card',
            COLLAPSE: 'fas fa-minus',
            EXPAND: 'fas fa-plus',
            RESET: 'fas fa-times-circle',
            CIRCLE: 'fas fa-circle',
            HEART: 'fas fa-heart',
            EMPTY_HEART: 'far fa-heart',
            FILTER: 'fas fa-filter',
            PENCIL: 'fas fa-pencil-alt',
            CLOCK: 'far fa-clock',
            TRASH: 'fas fa-trash',
            ACTIVE: 'fas fa-check',
            ON: 'fas fa-toggle-on',
            OFF: 'fas fa-toggle-off',
            LINK_OUT: 'fas fa-external-link-alt',
            SORT_DOWN: 'fas fa-sort-down',
            SORT: 'fas fa-sort',
            EXPAND_ARROWS: 'fas fa-expand',
        },
        resources: [
            {
                type: IconResourceType.LINK,
                url: 'https://use.fontawesome.com/releases/v5.8.1/css/all.css',
            },
        ],
    },
};

class IconLoaderService {
    constructor(winRef, iconConfig, sanitizer) {
        this.winRef = winRef;
        this.iconConfig = iconConfig;
        this.sanitizer = sanitizer;
        this.loadedResources = [];
    }
    /**
     * Returns an html fragment which can be added to the DOM in a safe way.
     */
    getHtml(type) {
        if (this.isResourceType(type, IconResourceType.SVG)) {
            return this.sanitizer.bypassSecurityTrustHtml(`<svg><use xlink:href="${this.getSvgPath(type)}"></use></svg>`);
        }
        if (this.isResourceType(type, IconResourceType.TEXT)) {
            return this.sanitizer.bypassSecurityTrustHtml(this.getSymbol(type));
        }
    }
    /**
     * Return the direction for which the icon should mirror (ltr vs rtl). The icon direction
     * is configurable, but optional, as only a few icons should be flipped for rtl direction.
     */
    getFlipDirection(type) {
        var _a, _b;
        return (_b = (_a = this.config) === null || _a === void 0 ? void 0 : _a.flipDirection) === null || _b === void 0 ? void 0 : _b[type];
    }
    /**
     *
     * Returns the symbol class(es) for the icon type.
     */
    getStyleClasses(iconType) {
        return this.getSymbol(iconType) || '';
    }
    /**
     * Indicates whether the given `ICON_TYPE` is configured for
     * the given `IconResourceType`.
     */
    isResourceType(iconType, resourceType) {
        return (this.config.resources &&
            !!this.config.resources.find((res) => res.types && res.type === resourceType && res.types.includes(iconType)));
    }
    /**
     * Returns the path to the svg link. The link supports path names
     * as well, if the config a[[s been setup to support a svg file path.
     * Additionally, the icon prefix will be taken into account to prefix the
     * icon IDs in the SVG.
     */
    getSvgPath(iconType) {
        const svgResource = this.config.resources.find((res) => res.type === IconResourceType.SVG &&
            res.types &&
            res.types.includes(iconType));
        if (svgResource) {
            return svgResource.url
                ? `${svgResource.url}#${this.getSymbol(iconType)}`
                : `#${this.getSymbol(iconType)}`;
        }
    }
    /**
     * Loads the resource url (if any) for the given icon.
     * The icon will only be loaded once.
     *
     * NOTE: this is not working when the shadow is used as there's
     * no head element available and the link must be loaded for every
     * web component.
     */
    addLinkResource(iconType) {
        const resource = this.findResource(iconType, IconResourceType.LINK);
        if (resource &&
            resource.url &&
            !this.loadedResources.includes(resource.url)) {
            this.loadedResources.push(resource.url);
            const head = this.winRef.document.getElementsByTagName('head')[0];
            const link = this.winRef.document.createElement('link');
            link.rel = 'stylesheet';
            link.type = 'text/css';
            link.href = resource.url;
            head.appendChild(link);
        }
    }
    findResource(iconType, resourceType) {
        if (!this.config.resources) {
            return;
        }
        let resource = this.config.resources.find((res) => res.type === resourceType && res.types && res.types.includes(iconType));
        // no specific resource found, let's try to find a one-size-fits-all resource
        if (!resource) {
            resource = this.config.resources.find((res) => (res.type === resourceType && !res.types) || res.types === []);
        }
        return resource;
    }
    getSymbol(iconType) {
        if (this.config && this.config.symbols && this.config.symbols[iconType]) {
            return this.config.symbols[iconType];
        }
    }
    get config() {
        return this.iconConfig.icon;
    }
}
IconLoaderService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: IconLoaderService, deps: [{ token: i1.WindowRef }, { token: IconConfig }, { token: i1$2.DomSanitizer }], target: i0.ɵɵFactoryTarget.Injectable });
IconLoaderService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: IconLoaderService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: IconLoaderService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.WindowRef }, { type: IconConfig }, { type: i1$2.DomSanitizer }]; } });

/**
 * The ltr and rtl directions can be used to configure the storefront for a certain direction, both statically
 * or dynamically.
 *
 * The HTML5 "auto" value is not supported in Spartacus, as it's considered to be too fragile for the global
 * direction.
 */
var DirectionMode;
(function (DirectionMode) {
    /**
     * Indicates Left to Right direction.
     */
    DirectionMode["LTR"] = "ltr";
    /**
     * Indicates Right to Left direction.
     */
    DirectionMode["RTL"] = "rtl";
})(DirectionMode || (DirectionMode = {}));

/**
 *
 * The icon component can be added in different ways:
 *
 * With the component selector:
 * `<cx-icon type="SEARCH"></cx-icon>`
 *
 * With the attribute selector:
 * `<span cxIcon="STAR"></span>`
 *
 * Additionally, content can be projected to the icon:
 *
 * `<button cxIcon="HAPPY">happy label</button>`
 *
 * The above button would become (based on a TEXT resource type):
 * `<button>😊happy label</button>`
 *
 * While the content is projected, the icon itself doesn't require an
 * additional DOM node which is an advantage over the component selector.
 */
class IconComponent {
    constructor(iconLoader, elementRef, renderer) {
        this.iconLoader = iconLoader;
        this.elementRef = elementRef;
        this.renderer = renderer;
    }
    /**
     * The cxIcon directive is bound to the icon type. You can feed the `ICON_TYPE` to
     * accomplish a configurable button in the UI.
     */
    set cxIcon(type) {
        this.setIcon(type);
    }
    /**
     * The type input parameter is bound to the icon type. You can feed the `ICON_TYPE` to
     * accomplish a configurable button in the UI.
     */
    set type(type) {
        this.setIcon(type);
    }
    setIcon(type) {
        if (!type || type === '') {
            return;
        }
        this.icon = this.iconLoader.getHtml(type);
        this.addStyleClasses(type);
        this.iconLoader.addLinkResource(type);
        this.flipIcon(type);
    }
    /**
     * The icons supports flipping for some icons to support rtl and ltr directions.
     */
    flipIcon(type) {
        // TODO: this can be dropped with the next major release.
        if (!this.iconLoader.getFlipDirection) {
            return;
        }
        const iconDirection = this.iconLoader.getFlipDirection(type);
        this.flipAtLtr = iconDirection === DirectionMode.LTR;
        this.flipAtRtl = iconDirection === DirectionMode.RTL;
    }
    /**
     * Adds the style classes and the link resource (if available).
     */
    addStyleClasses(type) {
        var _a, _b, _c;
        this.renderer.addClass(this.host, 'cx-icon');
        (_a = this.styleClasses) === null || _a === void 0 ? void 0 : _a.forEach((cls) => this.renderer.removeClass(this.host, cls));
        this.styleClasses = (_b = this.iconLoader.getStyleClasses(type)) === null || _b === void 0 ? void 0 : _b.split(' ');
        (_c = this.styleClasses) === null || _c === void 0 ? void 0 : _c.forEach((cls) => {
            if (cls !== '') {
                this.renderer.addClass(this.host, cls);
            }
        });
    }
    get host() {
        return this.elementRef.nativeElement;
    }
}
IconComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: IconComponent, deps: [{ token: IconLoaderService }, { token: i0.ElementRef }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component });
IconComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: IconComponent, selector: "cx-icon,[cxIcon]", inputs: { cxIcon: "cxIcon", type: "type" }, host: { properties: { "class.flip-at-rtl": "this.flipAtRtl", "class.flip-at-ltr": "this.flipAtLtr" } }, ngImport: i0, template: "<i [outerHTML]=\"icon\"></i><ng-content></ng-content>\n" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: IconComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-icon,[cxIcon]',
                    templateUrl: './icon.component.html',
                }]
        }], ctorParameters: function () { return [{ type: IconLoaderService }, { type: i0.ElementRef }, { type: i0.Renderer2 }]; }, propDecorators: { cxIcon: [{
                type: Input
            }], type: [{
                type: Input
            }], flipAtRtl: [{
                type: HostBinding,
                args: ['class.flip-at-rtl']
            }], flipAtLtr: [{
                type: HostBinding,
                args: ['class.flip-at-ltr']
            }] } });

const defaultIconConfig = {
    icon: {
        flipDirection: {
            CARET_RIGHT: DirectionMode.RTL,
            CARET_LEFT: DirectionMode.RTL,
        },
    },
};

class IconModule {
}
IconModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: IconModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
IconModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: IconModule, declarations: [IconComponent], imports: [CommonModule], exports: [IconComponent] });
IconModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: IconModule, providers: [
        provideDefaultConfig(defaultIconConfig),
        // TODO: move the opinionated fontawesome config to a recipe
        provideDefaultConfig(fontawesomeIconConfig),
    ], imports: [[CommonModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: IconModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [IconComponent],
                    imports: [CommonModule],
                    providers: [
                        provideDefaultConfig(defaultIconConfig),
                        // TODO: move the opinionated fontawesome config to a recipe
                        provideDefaultConfig(fontawesomeIconConfig),
                    ],
                    exports: [IconComponent],
                }]
        }] });

// PRIVATE TESTING UTIL
class MockIconComponent {
}
MockIconComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: MockIconComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
MockIconComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: MockIconComponent, selector: "cx-icon,[cxIcon]", inputs: { cxIcon: "cxIcon", type: "type" }, ngImport: i0, template: `{{ type || cxIcon }}`, isInline: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: MockIconComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-icon,[cxIcon]',
                    template: `{{ type || cxIcon }}`,
                }]
        }], propDecorators: { cxIcon: [{
                type: Input
            }], type: [{
                type: Input
            }] } });
const mockComponents = [MockIconComponent];
class MockIconLoaderService {
    getHtml() { }
    getStyleClasses() { }
    addStyleClasses() { }
    addLinkResource() { }
}
class IconTestingModule {
}
IconTestingModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: IconTestingModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
IconTestingModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: IconTestingModule, declarations: [MockIconComponent], exports: [MockIconComponent] });
IconTestingModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: IconTestingModule, providers: [
        {
            provide: IconLoaderService,
            useClass: MockIconLoaderService,
        },
    ] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: IconTestingModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: mockComponents,
                    exports: mockComponents,
                    providers: [
                        {
                            provide: IconLoaderService,
                            useClass: MockIconLoaderService,
                        },
                    ],
                }]
        }] });

// TODO: Improve a11y with better text appropriate to usage (example: loading cart spinner)
class SpinnerComponent {
    constructor() { }
}
SpinnerComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SpinnerComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
SpinnerComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: SpinnerComponent, selector: "cx-spinner", ngImport: i0, template: "<div class=\"loader-container\">\n  <div class=\"loader\">{{ 'spinner.loading' | cxTranslate }}</div>\n</div>\n", pipes: { "cxTranslate": i1.TranslatePipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SpinnerComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-spinner',
                    templateUrl: './spinner.component.html',
                }]
        }], ctorParameters: function () { return []; } });

class ConsentManagementFormComponent {
    constructor() {
        this.consentGiven = false;
        this.requiredConsents = [];
        this.consentChanged = new EventEmitter();
    }
    ngOnInit() {
        if (this.consent) {
            this.consentGiven = Boolean(this.consent.consentState === ANONYMOUS_CONSENT_STATUS.GIVEN);
        }
        else {
            if (this.consentTemplate && this.consentTemplate.currentConsent) {
                if (this.consentTemplate.currentConsent.consentWithdrawnDate) {
                    this.consentGiven = false;
                }
                else if (this.consentTemplate.currentConsent.consentGivenDate) {
                    this.consentGiven = true;
                }
            }
        }
    }
    onConsentChange() {
        this.consentGiven = !this.consentGiven;
        this.consentChanged.emit({
            given: this.consentGiven,
            template: this.consentTemplate,
        });
    }
    isRequired(templateId) {
        return this.requiredConsents.includes(templateId);
    }
}
ConsentManagementFormComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ConsentManagementFormComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
ConsentManagementFormComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: ConsentManagementFormComponent, selector: "cx-consent-management-form", inputs: { consentTemplate: "consentTemplate", requiredConsents: "requiredConsents", consent: "consent" }, outputs: { consentChanged: "consentChanged" }, ngImport: i0, template: "<div class=\"form-check\">\n  <label>\n    <input\n      type=\"checkbox\"\n      class=\"form-check-input\"\n      (change)=\"onConsentChange()\"\n      [checked]=\"consentGiven\"\n      [disabled]=\"isRequired(consentTemplate?.id)\"\n    />\n    <span class=\"form-check-label cx-be-bold\">\n      {{ consentTemplate?.name }}\n    </span>\n    <br />\n    <span class=\"form-check-label\">\n      {{ consentTemplate?.description }}\n    </span>\n  </label>\n</div>\n" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ConsentManagementFormComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-consent-management-form',
                    templateUrl: './consent-management-form.component.html',
                }]
        }], ctorParameters: function () { return []; }, propDecorators: { consentTemplate: [{
                type: Input
            }], requiredConsents: [{
                type: Input
            }], consent: [{
                type: Input
            }], consentChanged: [{
                type: Output
            }] } });

class AnonymousConsentDialogComponent {
    constructor(config, anonymousConsentsService, el, launchDialogService) {
        this.config = config;
        this.anonymousConsentsService = anonymousConsentsService;
        this.el = el;
        this.launchDialogService = launchDialogService;
        this.role = 'dialog';
        this.modal = true;
        this.subscriptions = new Subscription();
        this.showLegalDescription = true;
        this.iconTypes = ICON_TYPE;
        this.requiredConsents = [];
        this.focusConfig = {
            trap: true,
            block: true,
            autofocus: 'input[type="checkbox"]',
            focusOnEscape: true,
        };
        if (Boolean(this.config.anonymousConsents)) {
            this.showLegalDescription =
                this.config.anonymousConsents.showLegalDescriptionInDialog;
            if (Boolean(this.config.anonymousConsents.requiredConsents)) {
                this.requiredConsents = this.config.anonymousConsents.requiredConsents;
            }
        }
    }
    handleClick(event) {
        // Close on click outside the dialog window
        if (event.target.tagName === this.el.nativeElement.tagName) {
            this.close('Cross click');
        }
    }
    ngOnInit() {
        this.templates$ = this.anonymousConsentsService.getTemplates();
        this.consents$ = this.anonymousConsentsService.getConsents();
        this.loading$ = this.anonymousConsentsService.getLoadTemplatesLoading();
    }
    close(reason) {
        this.launchDialogService.closeDialog(reason);
    }
    rejectAll() {
        this.subscriptions.add(combineLatest([this.templates$, this.consents$])
            .pipe(take(1), distinctUntilChanged(), tap(([templates, consents]) => templates.forEach((template) => {
            const consent = this.getCorrespondingConsent(template, consents);
            if (this.anonymousConsentsService.isConsentGiven(consent)) {
                if (this.isRequiredConsent(template)) {
                    return;
                }
                this.anonymousConsentsService.withdrawConsent(template.id);
            }
        })))
            .subscribe());
        this.close('rejectAll');
    }
    allowAll() {
        this.subscriptions.add(combineLatest([this.templates$, this.consents$])
            .pipe(take(1), distinctUntilChanged(), tap(([templates, consents]) => templates.forEach((template) => {
            const consent = this.getCorrespondingConsent(template, consents);
            if ((consent && consent.consentState == null) ||
                this.anonymousConsentsService.isConsentWithdrawn(consent)) {
                if (this.isRequiredConsent(template)) {
                    return;
                }
                this.anonymousConsentsService.giveConsent(template.id);
            }
        })))
            .subscribe());
        this.close('allowAll');
    }
    isRequiredConsent(template) {
        return (Boolean(this.config.anonymousConsents) &&
            Boolean(this.config.anonymousConsents.requiredConsents) &&
            this.config.anonymousConsents.requiredConsents.includes(template.id));
    }
    onConsentChange({ given, template, }) {
        if (given) {
            this.anonymousConsentsService.giveConsent(template.id);
        }
        else {
            this.anonymousConsentsService.withdrawConsent(template.id);
        }
    }
    getCorrespondingConsent(template, consents = []) {
        for (const consent of consents) {
            if (template.id === consent.templateCode) {
                return consent;
            }
        }
        return null;
    }
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
    }
}
AnonymousConsentDialogComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AnonymousConsentDialogComponent, deps: [{ token: i1.AnonymousConsentsConfig }, { token: i1.AnonymousConsentsService }, { token: i0.ElementRef }, { token: LaunchDialogService }], target: i0.ɵɵFactoryTarget.Component });
AnonymousConsentDialogComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: AnonymousConsentDialogComponent, selector: "cx-anonymous-consent-dialog", host: { listeners: { "click": "handleClick($event)" }, properties: { "attr.role": "this.role", "attr.aria-modal": "this.modal" } }, ngImport: i0, template: "<div\n  class=\"cx-anonymous-consent-dialog\"\n  [cxFocus]=\"focusConfig\"\n  (esc)=\"close('Escape clicked')\"\n>\n  <div class=\"cx-dialog-content\">\n    <div *ngIf=\"loading$ | async; else dialogBody\">\n      <cx-spinner></cx-spinner>\n    </div>\n    <ng-template #dialogBody>\n      <div class=\"cx-dialog-header\">\n        <h3>\n          {{ 'anonymousConsents.dialog.title' | cxTranslate }}\n        </h3>\n        <button\n          type=\"button\"\n          class=\"close\"\n          [attr.aria-label]=\"'common.close' | cxTranslate\"\n          (click)=\"close('Cross click')\"\n        >\n          <span aria-hidden=\"true\">\n            <cx-icon [type]=\"iconTypes.CLOSE\"></cx-icon>\n          </span>\n        </button>\n      </div>\n      <!-- Separator -->\n      <div class=\"cx-dialog-description\" *ngIf=\"showLegalDescription\">\n        {{ 'anonymousConsents.dialog.legalDescription' | cxTranslate }}\n        <div\n          class=\"cx-dialog-separator col-sm-12 d-xs-block d-sm-block d-md-none\"\n        ></div>\n      </div>\n      <!-- Actions -->\n      <div class=\"cx-dialog-buttons\">\n        <a tabindex=\"0\" class=\"btn-link cx-action-link\" (click)=\"rejectAll()\">{{\n          'anonymousConsents.dialog.clearAll' | cxTranslate\n        }}</a>\n        <a tabindex=\"0\" class=\"btn-link cx-action-link\" (click)=\"allowAll()\">{{\n          'anonymousConsents.dialog.selectAll' | cxTranslate\n        }}</a>\n      </div>\n      <!-- Modal Body -->\n      <div class=\"cx-dialog-body\" *ngIf=\"templates$ | async as templates\">\n        <ng-container *ngIf=\"consents$ | async as consents\">\n          <div\n            class=\"cx-dialog-row col-sm-12 col-md-6\"\n            *ngFor=\"let template of templates\"\n          >\n            <cx-consent-management-form\n              [consentTemplate]=\"template\"\n              [requiredConsents]=\"requiredConsents\"\n              [consent]=\"getCorrespondingConsent(template, consents)\"\n              (consentChanged)=\"onConsentChange($event)\"\n            ></cx-consent-management-form>\n          </div>\n        </ng-container>\n      </div>\n    </ng-template>\n  </div>\n</div>\n", components: [{ type: SpinnerComponent, selector: "cx-spinner" }, { type: IconComponent, selector: "cx-icon,[cxIcon]", inputs: ["cxIcon", "type"] }, { type: ConsentManagementFormComponent, selector: "cx-consent-management-form", inputs: ["consentTemplate", "requiredConsents", "consent"], outputs: ["consentChanged"] }], directives: [{ type: FocusDirective, selector: "[cxFocus]", inputs: ["cxFocus"] }, { type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], pipes: { "async": i3.AsyncPipe, "cxTranslate": i1.TranslatePipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AnonymousConsentDialogComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-anonymous-consent-dialog',
                    templateUrl: './anonymous-consent-dialog.component.html',
                }]
        }], ctorParameters: function () { return [{ type: i1.AnonymousConsentsConfig }, { type: i1.AnonymousConsentsService }, { type: i0.ElementRef }, { type: LaunchDialogService }]; }, propDecorators: { role: [{
                type: HostBinding,
                args: ['attr.role']
            }], modal: [{
                type: HostBinding,
                args: ['attr.aria-modal']
            }], handleClick: [{
                type: HostListener,
                args: ['click', ['$event']]
            }] } });

const defaultAnonymousConsentLayoutConfig = {
    launch: {
        ANONYMOUS_CONSENT: {
            inline: true,
            component: AnonymousConsentDialogComponent,
            dialogType: DIALOG_TYPE.DIALOG,
        },
    },
};

class AnonymousConsentOpenDialogComponent {
    constructor(vcr, launchDialogService) {
        this.vcr = vcr;
        this.launchDialogService = launchDialogService;
    }
    openDialog() {
        const dialog = this.launchDialogService.openDialog("ANONYMOUS_CONSENT" /* ANONYMOUS_CONSENT */, this.openElement, this.vcr);
        if (dialog) {
            dialog.pipe(take(1)).subscribe();
        }
    }
}
AnonymousConsentOpenDialogComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AnonymousConsentOpenDialogComponent, deps: [{ token: i0.ViewContainerRef }, { token: LaunchDialogService }], target: i0.ɵɵFactoryTarget.Component });
AnonymousConsentOpenDialogComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: AnonymousConsentOpenDialogComponent, selector: "cx-anonymous-consent-open-dialog", viewQueries: [{ propertyName: "openElement", first: true, predicate: ["open"], descendants: true }], ngImport: i0, template: "<button #open class=\"btn btn-link\" (click)=\"openDialog()\">\n  {{ 'anonymousConsents.preferences' | cxTranslate }}\n</button>\n", pipes: { "cxTranslate": i1.TranslatePipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AnonymousConsentOpenDialogComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-anonymous-consent-open-dialog',
                    templateUrl: './anonymous-consent-open-dialog.component.html',
                }]
        }], ctorParameters: function () { return [{ type: i0.ViewContainerRef }, { type: LaunchDialogService }]; }, propDecorators: { openElement: [{
                type: ViewChild,
                args: ['open']
            }] } });

class AnonymousConsentManagementBannerModule {
}
AnonymousConsentManagementBannerModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AnonymousConsentManagementBannerModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
AnonymousConsentManagementBannerModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AnonymousConsentManagementBannerModule, declarations: [AnonymousConsentManagementBannerComponent,
        AnonymousConsentOpenDialogComponent], imports: [CommonModule,
        I18nModule,
        FeaturesConfigModule,
        KeyboardFocusModule], exports: [AnonymousConsentManagementBannerComponent,
        AnonymousConsentOpenDialogComponent] });
AnonymousConsentManagementBannerModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AnonymousConsentManagementBannerModule, providers: [
        provideConfig(defaultAnonymousConsentLayoutConfig),
        provideDefaultConfig({
            cmsComponents: {
                AnonymousConsentManagementBannerComponent: {
                    component: AnonymousConsentManagementBannerComponent,
                    deferLoading: DeferLoadingStrategy.INSTANT,
                },
                AnonymousConsentOpenDialogComponent: {
                    component: AnonymousConsentOpenDialogComponent,
                },
            },
        }),
    ], imports: [[
            CommonModule,
            I18nModule,
            FeaturesConfigModule,
            KeyboardFocusModule,
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AnonymousConsentManagementBannerModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        I18nModule,
                        FeaturesConfigModule,
                        KeyboardFocusModule,
                    ],
                    providers: [
                        provideConfig(defaultAnonymousConsentLayoutConfig),
                        provideDefaultConfig({
                            cmsComponents: {
                                AnonymousConsentManagementBannerComponent: {
                                    component: AnonymousConsentManagementBannerComponent,
                                    deferLoading: DeferLoadingStrategy.INSTANT,
                                },
                                AnonymousConsentOpenDialogComponent: {
                                    component: AnonymousConsentOpenDialogComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [
                        AnonymousConsentManagementBannerComponent,
                        AnonymousConsentOpenDialogComponent,
                    ],
                    exports: [
                        AnonymousConsentManagementBannerComponent,
                        AnonymousConsentOpenDialogComponent,
                    ],
                }]
        }] });

/**
 * A service to handle modal
 */
class ModalService {
    constructor(ngbModalService, applicationRef) {
        this.ngbModalService = ngbModalService;
        this.applicationRef = applicationRef;
        this.modals = [];
    }
    get rootComponent() {
        var _a, _b, _c, _d;
        return (_d = (_c = (_b = (_a = this.applicationRef) === null || _a === void 0 ? void 0 : _a.components) === null || _b === void 0 ? void 0 : _b[0]) === null || _c === void 0 ? void 0 : _c.location) === null || _d === void 0 ? void 0 : _d.nativeElement;
    }
    open(content, options) {
        let activeModal;
        options = Object.assign({ container: this.rootComponent }, options);
        activeModal = this.ngbModalService.open(content, options);
        this.modals.push(activeModal);
        this.handleModalRemoveEvents(activeModal);
        return activeModal;
    }
    handleModalRemoveEvents(modal) {
        modal.result.finally(() => {
            this.modals = this.modals.filter((m) => m !== modal);
        });
    }
    getActiveModal() {
        const modal = this.modals[this.modals.length - 1];
        return modal ? modal : null;
    }
    dismissActiveModal(reason) {
        const modal = this.getActiveModal();
        if (modal) {
            modal.dismiss(reason);
        }
    }
    closeActiveModal(reason) {
        const modal = this.getActiveModal();
        if (modal) {
            modal.close(reason);
        }
    }
}
ModalService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ModalService, deps: [{ token: i1$3.NgbModal }, { token: i0.ApplicationRef }], target: i0.ɵɵFactoryTarget.Injectable });
ModalService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ModalService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ModalService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1$3.NgbModal }, { type: i0.ApplicationRef }]; } });

/**
 * Identifiers of outlets inside the cart details view.
 */
var CartOutlets;
(function (CartOutlets) {
    CartOutlets["ITEM"] = "cx-cart-item";
    CartOutlets["ITEM_DETAILS"] = "cx-cart-item.details";
    CartOutlets["ITEM_BUNDLE_DETAILS"] = "cx-cart-item.bundle-details";
})(CartOutlets || (CartOutlets = {}));

/**
 * Context source for `CartItemComponent`.
 *
 * `CartItemContext` should be injected instead in child components.
 */
class CartItemContextSource {
    constructor() {
        this.compact$ = new ReplaySubject(1);
        this.readonly$ = new ReplaySubject(1);
        this.item$ = new ReplaySubject(1);
        this.quantityControl$ = new ReplaySubject(1);
        this.location$ = new ReplaySubject(1);
        this.options$ = new ReplaySubject(1);
    }
}
CartItemContextSource.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CartItemContextSource, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
CartItemContextSource.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CartItemContextSource });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CartItemContextSource, decorators: [{
            type: Injectable
        }] });

/**
 * Context for `CartItemComponent`.
 */
class CartItemContext {
}
CartItemContext.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CartItemContext, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
CartItemContext.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CartItemContext });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CartItemContext, decorators: [{
            type: Injectable
        }] });

class CartValidationStateService {
    constructor(routingService) {
        this.routingService = routingService;
        this.NAVIGATION_SKIPS = 2;
        this.navigationIdCount = 0;
        this.subscription = new Subscription();
        this.cartValidationResult$ = new ReplaySubject(1);
        this.checkForValidationResultClear$ = this.routingService
            .getRouterState()
            .pipe(withLatestFrom(this.cartValidationResult$), tap(([routerState, cartModifications]) => {
            if (this.navigationIdCount + this.NAVIGATION_SKIPS <=
                routerState.navigationId &&
                cartModifications.length) {
                this.cartValidationResult$.next([]);
                this.navigationIdCount = routerState.navigationId;
            }
        }));
        this.setInitialState();
    }
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
    setInitialState() {
        this.setNavigationIdStep();
        this.subscription.add(this.checkForValidationResultClear$.subscribe());
    }
    updateValidationResultAndRoutingId(cartModification) {
        this.cartValidationResult$.next(cartModification);
        this.setNavigationIdStep();
    }
    setNavigationIdStep() {
        this.routingService
            .getRouterState()
            .pipe(take(1))
            .subscribe((routerState) => (this.navigationIdCount = routerState.navigationId));
    }
}
CartValidationStateService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CartValidationStateService, deps: [{ token: i1.RoutingService }], target: i0.ɵɵFactoryTarget.Injectable });
CartValidationStateService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CartValidationStateService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CartValidationStateService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.RoutingService }]; } });

class CartItemValidationWarningComponent {
    constructor(cartValidationStateService) {
        this.cartValidationStateService = cartValidationStateService;
        this.iconTypes = ICON_TYPE;
        this.isVisible = true;
        this.cartModification$ = this.cartValidationStateService.cartValidationResult$.pipe(map((modificationList) => modificationList.find((modification) => modification.entry.product.code === this.code)));
    }
}
CartItemValidationWarningComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CartItemValidationWarningComponent, deps: [{ token: CartValidationStateService }], target: i0.ɵɵFactoryTarget.Component });
CartItemValidationWarningComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: CartItemValidationWarningComponent, selector: "cx-cart-item-validation-warning", inputs: { code: "code" }, ngImport: i0, template: "<ng-container *ngIf=\"cartModification$ | async as cartModification\">\n  <div class=\"alert alert-info\" *ngIf=\"isVisible\">\n    <span class=\"alert-icon\">\n      <cx-icon [type]=\"iconTypes.INFO\"></cx-icon>\n    </span>\n    <span>\n      {{\n        'validation.' + cartModification.statusCode\n          | cxTranslate\n            : {\n                quantity: cartModification.quantityAdded\n              }\n      }}\n    </span>\n\n    <button class=\"close\" type=\"button\" (click)=\"isVisible = !isVisible\">\n      <cx-icon [type]=\"iconTypes.CLOSE\"></cx-icon>\n    </button>\n  </div>\n</ng-container>\n", components: [{ type: IconComponent, selector: "cx-icon,[cxIcon]", inputs: ["cxIcon", "type"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "async": i3.AsyncPipe, "cxTranslate": i1.TranslatePipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CartItemValidationWarningComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-cart-item-validation-warning',
                    templateUrl: './cart-item-validation-warning.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: CartValidationStateService }]; }, propDecorators: { code: [{
                type: Input
            }] } });

/**
 * Indicates how the browser should load the image.
 *
 * While this might not add too much value in some scenarios, as we have other
 * optimizations to defer loading of larger pieces of the DOM, there might be
 * components who haven't implemented other lazy loading techniques. Moreover,
 * a server sides rendered page that lands directly in the browser could benefit
 * enormously from the lazy loading of images.
 */
var ImageLoadingStrategy;
(function (ImageLoadingStrategy) {
    /**
     * Loads the image immediately, regardless of whether or not the image
     * is currently within the visible viewport (this is the default value).
     */
    ImageLoadingStrategy["EAGER"] = "eager";
    /**
     * Defers loading the image until it reaches a calculated distance from the viewport,
     * as defined by the browser. The intent is to avoid the network and storage bandwidth
     * needed to handle the image until it's reasonably certain that it will be needed.
     * This generally improves the performance of the content in most typical use cases.
     */
    ImageLoadingStrategy["LAZY"] = "lazy";
})(ImageLoadingStrategy || (ImageLoadingStrategy = {}));

/**
 * Service which generates media URLs. It leverage the MediaContainer and MediaFormats so
 * that URLs and sizes are generated for the same media. This helps to improve performance
 * across difference devices and layouts.
 *
 * Media formats are optional, but highly recommended. The format will help the browser to
 * identify the right media for the right experience.
 *
 * The MediaService will generate absolute URLs in case relative URLs are provided for the Media.
 * The baseUrl is read from the `occConfig.backend.media.baseUrl` or
 * `occConfig.backend.occ.baseUrl`.
 */
class MediaService {
    constructor(config) {
        this.config = config;
    }
    /**
     * Returns a `Media` object with the main media (`src`) and various media (`src`)
     * for specific formats.
     */
    getMedia(mediaContainer, format, alt, role) {
        if (!mediaContainer) {
            return;
        }
        const mainMedia = mediaContainer.url
            ? mediaContainer
            : this.resolveMedia(mediaContainer, format);
        return {
            src: this.resolveAbsoluteUrl(mainMedia === null || mainMedia === void 0 ? void 0 : mainMedia.url),
            alt: alt !== null && alt !== void 0 ? alt : mainMedia === null || mainMedia === void 0 ? void 0 : mainMedia.altText,
            role: role !== null && role !== void 0 ? role : mainMedia === null || mainMedia === void 0 ? void 0 : mainMedia.role,
            srcset: this.resolveSrcSet(mediaContainer, format),
        };
    }
    /**
     * Reads the loading strategy from the `MediaConfig`.
     *
     * Defaults to `ImageLoadingStrategy.EAGER`.
     */
    get loadingStrategy() {
        var _a, _b;
        return ((_b = (_a = this.config) === null || _a === void 0 ? void 0 : _a.imageLoadingStrategy) !== null && _b !== void 0 ? _b : ImageLoadingStrategy.EAGER);
    }
    /**
     * Creates the media formats in a logical sorted order. The map contains the
     * format key and the format size information. We do this only once for performance
     * benefits.
     */
    get sortedFormats() {
        var _a, _b;
        if (!this._sortedFormats && ((_a = this.config) === null || _a === void 0 ? void 0 : _a.mediaFormats)) {
            this._sortedFormats = Object.keys(this.config.mediaFormats)
                .map((key) => ({
                code: key,
                size: this.config.mediaFormats[key],
            }))
                .sort((a, b) => (a.size.width > b.size.width ? 1 : -1));
        }
        return (_b = this._sortedFormats) !== null && _b !== void 0 ? _b : [];
    }
    /**
     * Creates the media formats in a reversed sorted order.
     */
    get reversedFormats() {
        if (!this._reversedFormats) {
            this._reversedFormats = this.sortedFormats.slice().reverse();
        }
        return this._reversedFormats;
    }
    /**
     * Resolves the right media for the given format. The fo
     */
    resolveMedia(media, format) {
        return media[this.resolveFormat(media, format)];
    }
    /**
     * Validates the format against the given mediaContainer. If there is no format available,
     * or if the mediaContainer doesn't contain a media for the given media, the most optimal
     * format is resolved. If even that is not possible, the first format is returned.
     */
    resolveFormat(mediaContainer, format) {
        if (format && mediaContainer[format]) {
            return format;
        }
        return (this.resolveBestFormat(mediaContainer) || Object.keys(mediaContainer)[0]);
    }
    /**
     * Returns the media format code with the best size.
     */
    resolveBestFormat(media) {
        var _a;
        return (_a = this.reversedFormats.find((format) => media.hasOwnProperty(format.code))) === null || _a === void 0 ? void 0 : _a.code;
    }
    /**
     * Returns a set of media for the available media formats. Additionally, the configured media
     * format width is added to the srcset, so that browsers can select the appropriate media.
     *
     * The optional maxFormat indicates that only sources till a certain format should be added
     * to the srcset.
     */
    resolveSrcSet(media, maxFormat) {
        if (!media) {
            return undefined;
        }
        // Only create srcset images that are smaller than the given `maxFormat` (if any)
        let formats = this.sortedFormats;
        const max = formats.findIndex((f) => f.code === maxFormat);
        if (max > -1) {
            formats = formats.slice(0, max + 1);
        }
        const srcset = formats.reduce((set, format) => {
            if (!!media[format.code]) {
                if (set) {
                    set += ', ';
                }
                set += `${this.resolveAbsoluteUrl(media[format.code].url)} ${format.size.width}w`;
            }
            return set;
        }, '');
        return srcset === '' ? undefined : srcset;
    }
    /**
     * Resolves the absolute URL for the given url. In most cases, this URL represents
     * the relative URL on the backend. In that case, we prefix the url with the baseUrl.
     *
     * When we have receive an absolute URL, we return the URL as-is. An absolute URL might also
     * start with double slash, which is used to resolve media cross from http and https.
     */
    resolveAbsoluteUrl(url) {
        return !url || url.startsWith('http') || url.startsWith('//')
            ? url
            : this.getBaseUrl() + url;
    }
    /**
     * The base URL is either driven by a specific `backend.media.baseUrl`, or by the
     * `backend.occ.baseUrl`.
     *
     * The `backend.media.baseUrl` can be used to load media from a different location.
     *
     * In Commerce Cloud, a different location could mean a different "aspect".
     *
     * Defaults to empty string in case no config is provided.
     */
    getBaseUrl() {
        var _a, _b, _c, _d, _e, _f;
        return ((_f = (_c = (_b = (_a = this.config.backend) === null || _a === void 0 ? void 0 : _a.media) === null || _b === void 0 ? void 0 : _b.baseUrl) !== null && _c !== void 0 ? _c : (_e = (_d = this.config.backend) === null || _d === void 0 ? void 0 : _d.occ) === null || _e === void 0 ? void 0 : _e.baseUrl) !== null && _f !== void 0 ? _f : '');
    }
}
MediaService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: MediaService, deps: [{ token: i1.Config }], target: i0.ɵɵFactoryTarget.Injectable });
MediaService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: MediaService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: MediaService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.Config }]; } });

class MediaComponent {
    constructor(mediaService) {
        this.mediaService = mediaService;
        // TODO: Remove type forcing of `this.loadingStrategy` (ie. <ImageLoadingStrategy | null>) in 5.0 (#14236)
        /**
         * Set the loading strategy of the media. Defaults to global loading strategy.
         * Use 'lazy' or 'eager' strategies.
         */
        this.loading = (this.loadingStrategy);
        /**
         * Once the media is loaded, we emit an event.
         */
        this.loaded = new EventEmitter();
        /**
         * The `cx-media` component has an `is-initialized` class as long as the
         * media is being initialized.
         */
        this.isInitialized = false;
        /**
         * The `cx-media` component has a `is-loading` class as long as the
         * media is loaded. Wehn the media is loaded, the `is-initialized` class
         * is added.
         */
        this.isLoading = true;
        /**
         * When there's no media provided for the content, or in case an error
         * happened during loading, we add the `is-missing` class. Visual effects
         * can be controlled by CSS.
         */
        this.isMissing = false;
    }
    ngOnChanges() {
        this.create();
    }
    /**
     * Creates the `Media` object
     */
    create() {
        var _a;
        this.media = this.mediaService.getMedia(this.container instanceof Array ? this.container[0] : this.container, this.format, this.alt, this.role);
        if (!((_a = this.media) === null || _a === void 0 ? void 0 : _a.src)) {
            this.handleMissing();
        }
    }
    /**
     * This handler is called from the UI when the image is loaded.
     */
    loadHandler() {
        this.isLoading = false;
        this.isInitialized = true;
        this.isMissing = false;
        this.loaded.emit(true);
    }
    // TODO: Remove string return type (#14236)
    /**
     * Indicates whether the browser should lazy load the image.
     * @deprecated since 4.2. use ImageLoadingStrategy or null return types only
     */
    get loadingStrategy() {
        return this.mediaService.loadingStrategy === ImageLoadingStrategy.LAZY
            ? ImageLoadingStrategy.LAZY
            : null;
    }
    /**
     * Whenever an error happens during load, we mark the component
     * with css classes to have a missing media.
     */
    errorHandler() {
        this.handleMissing();
    }
    handleMissing() {
        this.isLoading = false;
        this.isInitialized = true;
        this.isMissing = true;
        this.loaded.emit(false);
    }
}
MediaComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: MediaComponent, deps: [{ token: MediaService }], target: i0.ɵɵFactoryTarget.Component });
MediaComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: MediaComponent, selector: "cx-media", inputs: { container: "container", format: "format", alt: "alt", role: "role", loading: "loading" }, outputs: { loaded: "loaded" }, host: { properties: { "class.is-initialized": "this.isInitialized", "class.is-loading": "this.isLoading", "class.is-missing": "this.isMissing" } }, usesOnChanges: true, ngImport: i0, template: "<img\n  *ngIf=\"media?.src\"\n  [attr.src]=\"media.src\"\n  [attr.srcset]=\"media.srcset\"\n  [attr.alt]=\"media.alt\"\n  [attr.role]=\"media.role\"\n  [attr.loading]=\"loading\"\n  (load)=\"loadHandler()\"\n  (error)=\"errorHandler()\"\n/>\n", directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: MediaComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-media',
                    templateUrl: './media.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: MediaService }]; }, propDecorators: { container: [{
                type: Input
            }], format: [{
                type: Input
            }], alt: [{
                type: Input
            }], role: [{
                type: Input
            }], loading: [{
                type: Input
            }], loaded: [{
                type: Output
            }], isInitialized: [{
                type: HostBinding,
                args: ['class.is-initialized']
            }], isLoading: [{
                type: HostBinding,
                args: ['class.is-loading']
            }], isMissing: [{
                type: HostBinding,
                args: ['class.is-missing']
            }] } });

/**
 * Provides a UI to manage the count of the quantity, typically by using
 * increase and decrease functionality. The item counter expects an input `FormControl`
 * so that the state of the control can be managed outside of this component.
 */
class ItemCounterComponent {
    constructor() {
        /**
         * This can be used in case an item has a minmum order quantity.
         * @default 1
         */
        this.min = 1;
        /**
         * The step is used to increment the count. It is supposed to be a
         * positive integer or float.
         * @default 1
         */
        this.step = 1;
        /**
         * Indicates that the input can be manually set to zero,
         * despite the fact that the input controls will be limited to
         * the minimum. The zero value can be used to remove an item.
         */
        this.allowZero = false;
        /**
         * In readonly mode the item counter will only be shown as a label,
         * the form controls are not rendered.
         * Please not that readonly is different from the `disabled` form state.
         * @default false
         */
        this.readonly = false;
    }
    handleClick() {
        this.input.nativeElement.focus();
    }
    ngOnInit() {
        this.sub = this.control.valueChanges
            .pipe(startWith(this.control.value))
            .subscribe((value) => this.control.setValue(this.getValidCount(value), { emitEvent: false }));
    }
    ngOnDestroy() {
        if (this.sub) {
            this.sub.unsubscribe();
        }
    }
    increment() {
        // it's too early to use the `stepUp` and `stepDown` API...
        // let's wait for FF: https://caniuse.com/#search=stepUp
        this.control.setValue(this.control.value + this.step);
        this.control.markAsDirty();
    }
    decrement() {
        this.control.setValue(this.control.value - this.step);
        this.control.markAsDirty();
    }
    /**
     * Validate that the given value is in between
     * the `min` and `max` value. If the value is out
     * of  the min/max range, it will be altered.
     * If `allowZero` is set to true, the 0 value is ignored.
     *
     */
    getValidCount(value) {
        if (value < this.min && !(value === 0 && this.allowZero)) {
            value = this.min;
        }
        if (this.max && value > this.max) {
            value = this.max;
        }
        return value;
    }
}
ItemCounterComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ItemCounterComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
ItemCounterComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: ItemCounterComponent, selector: "cx-item-counter", inputs: { control: "control", min: "min", max: "max", step: "step", allowZero: "allowZero", readonly: "readonly" }, host: { listeners: { "click": "handleClick()" }, properties: { "class.readonly": "this.readonly" } }, viewQueries: [{ propertyName: "input", first: true, predicate: ["qty"], descendants: true }], ngImport: i0, template: "<button\n  type=\"button\"\n  (click)=\"decrement()\"\n  [disabled]=\"control.disabled || control.value <= min\"\n  [tabindex]=\"control.disabled || control.value <= min ? -1 : 0\"\n  attr.aria-label=\"{{ 'itemCounter.removeOne' | cxTranslate }}\"\n>\n  -\n</button>\n<input\n  #qty\n  type=\"number\"\n  [min]=\"min\"\n  [max]=\"max\"\n  [step]=\"step\"\n  [readonly]=\"readonly\"\n  [tabindex]=\"readonly ? -1 : 0\"\n  [formControl]=\"control\"\n  attr.aria-label=\"{{ 'itemCounter.quantity' | cxTranslate }}\"\n/>\n<button\n  type=\"button\"\n  (click)=\"increment()\"\n  [disabled]=\"control.disabled || control.value >= max\"\n  tabindex=\"0\"\n  attr.aria-label=\"{{ 'itemCounter.addOneMore' | cxTranslate }}\"\n>\n  +\n</button>\n", directives: [{ type: i3$1.MinValidator, selector: "input[type=number][min][formControlName],input[type=number][min][formControl],input[type=number][min][ngModel]", inputs: ["min"] }, { type: i3$1.MaxValidator, selector: "input[type=number][max][formControlName],input[type=number][max][formControl],input[type=number][max][ngModel]", inputs: ["max"] }, { type: i3$1.NumberValueAccessor, selector: "input[type=number][formControlName],input[type=number][formControl],input[type=number][ngModel]" }, { type: i3$1.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { type: i3$1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i3$1.FormControlDirective, selector: "[formControl]", inputs: ["disabled", "formControl", "ngModel"], outputs: ["ngModelChange"], exportAs: ["ngForm"] }], pipes: { "cxTranslate": i1.TranslatePipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ItemCounterComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-item-counter',
                    templateUrl: './item-counter.component.html',
                    // do not use OnPush change detection strategy as we would not
                    // get updates of other form control state (disabled). We want to have a
                    // disabled state in order to ensure that the control cannot be used while
                    // the cart is updated.
                }]
        }], propDecorators: { control: [{
                type: Input
            }], min: [{
                type: Input
            }], max: [{
                type: Input
            }], step: [{
                type: Input
            }], allowZero: [{
                type: Input
            }], readonly: [{
                type: HostBinding,
                args: ['class.readonly']
            }, {
                type: Input
            }], input: [{
                type: ViewChild,
                args: ['qty']
            }], handleClick: [{
                type: HostListener,
                args: ['click']
            }] } });

class PromotionsComponent {
    constructor() { }
}
PromotionsComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PromotionsComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
PromotionsComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: PromotionsComponent, selector: "cx-promotions", inputs: { promotions: "promotions" }, ngImport: i0, template: "<div class=\"cx-promotions\" *ngIf=\"promotions\">\n  <ul *ngFor=\"let promotion of promotions\">\n    <li>{{ promotion.description }}</li>\n  </ul>\n</div>\n", directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PromotionsComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-promotions',
                    templateUrl: './promotions.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return []; }, propDecorators: { promotions: [{
                type: Input
            }] } });

/**
 * Service to control the behavior of the DismissModalDirective
 */
class ModalDirectiveService {
    /**
     * Handler for the click event on the directive
     *
     * @param options.type    Action to perform after click - close or dismiss
     * @param options.reason  Reason for dismissing or closing the modal
     * @param url             url (optional) - exists only when the directive is also a `routerLink`.
     */
    onClick(options, activeModal, url) {
        let reason = options.reason;
        if (!reason && url) {
            reason = `Link click: ${url}`;
        }
        if (options.type === 'dismiss') {
            activeModal.dismiss(reason);
        }
        else if (options.type === 'close') {
            activeModal.close(reason);
        }
    }
}
ModalDirectiveService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ModalDirectiveService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
ModalDirectiveService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ModalDirectiveService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ModalDirectiveService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });
/**
 * Directive to dismiss the modal on click
 */
class ModalDirective {
    constructor(service, router, 
    // active modal can be injected only when the directive is projected inside modal
    activeModal, routerLink, routerLinkWithHref) {
        this.service = service;
        this.router = router;
        this.activeModal = activeModal;
        this.routerLink = routerLink;
        this.routerLinkWithHref = routerLinkWithHref;
    }
    /**
     * Returns URL in case when the directive is in the scope of a `routerLink` directive at the same time.
     */
    getUrl() {
        var _a;
        const routerLink = (_a = this.routerLink) !== null && _a !== void 0 ? _a : this.routerLinkWithHref;
        return routerLink
            ? this.router.serializeUrl(routerLink.urlTree)
            : undefined;
    }
    onClick() {
        if (this.activeModal) {
            this.service.onClick(this.options, this.activeModal, this.getUrl());
        }
    }
    /**
     * Converts the directive's inputs to the shape of modal directive options
     */
    get options() {
        return { type: this.cxModal, reason: this.cxModalReason };
    }
}
ModalDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ModalDirective, deps: [{ token: ModalDirectiveService }, { token: i1$1.Router }, { token: i1$3.NgbActiveModal, optional: true }, { token: i1$1.RouterLink, optional: true }, { token: i1$1.RouterLinkWithHref, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
ModalDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.5", type: ModalDirective, selector: "[cxModal]", inputs: { cxModal: "cxModal", cxModalReason: "cxModalReason" }, host: { listeners: { "click": "onClick()" } }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ModalDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cxModal]',
                }]
        }], ctorParameters: function () { return [{ type: ModalDirectiveService }, { type: i1$1.Router }, { type: i1$3.NgbActiveModal, decorators: [{
                    type: Optional
                }] }, { type: i1$1.RouterLink, decorators: [{
                    type: Optional
                }] }, { type: i1$1.RouterLinkWithHref, decorators: [{
                    type: Optional
                }] }]; }, propDecorators: { cxModal: [{
                type: Input
            }], cxModalReason: [{
                type: Input
            }], onClick: [{
                type: HostListener,
                args: ['click']
            }] } });

class CartItemComponent {
    constructor(cartItemContextSource) {
        this.cartItemContextSource = cartItemContextSource;
        this.compact = false;
        this.readonly = false;
        this.promotionLocation = PromotionLocation.ActiveCart;
        // TODO: evaluate whether this is generic enough
        this.options = {
            isSaveForLater: false,
            optionalBtn: null,
        };
        this.iconTypes = ICON_TYPE;
        this.CartOutlets = CartOutlets;
    }
    ngOnChanges(changes) {
        if (changes === null || changes === void 0 ? void 0 : changes.compact) {
            this.cartItemContextSource.compact$.next(this.compact);
        }
        if (changes === null || changes === void 0 ? void 0 : changes.readonly) {
            this.cartItemContextSource.readonly$.next(this.readonly);
        }
        if (changes === null || changes === void 0 ? void 0 : changes.item) {
            this.cartItemContextSource.item$.next(this.item);
        }
        if (changes === null || changes === void 0 ? void 0 : changes.quantityControl) {
            this.cartItemContextSource.quantityControl$.next(this.quantityControl);
        }
        if (changes === null || changes === void 0 ? void 0 : changes.promotionLocation) {
            this.cartItemContextSource.location$.next(this.promotionLocation);
        }
        if (changes === null || changes === void 0 ? void 0 : changes.options) {
            this.cartItemContextSource.options$.next(this.options);
        }
    }
    isProductOutOfStock(product) {
        // TODO Move stocklevelstatuses across the app to an enum
        return (product &&
            product.stock &&
            product.stock.stockLevelStatus === 'outOfStock');
    }
    removeItem() {
        this.quantityControl.setValue(0);
        this.quantityControl.markAsDirty();
    }
}
CartItemComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CartItemComponent, deps: [{ token: CartItemContextSource }], target: i0.ɵɵFactoryTarget.Component });
CartItemComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: CartItemComponent, selector: "cx-cart-item", inputs: { compact: "compact", item: "item", readonly: "readonly", quantityControl: "quantityControl", promotionLocation: "promotionLocation", options: "options" }, providers: [
        CartItemContextSource,
        { provide: CartItemContext, useExisting: CartItemContextSource },
    ], usesOnChanges: true, ngImport: i0, template: "<!-- Item Start Outlet -->\n<ng-template [cxOutlet]=\"CartOutlets.ITEM\">\n  <ng-container *cxFeatureLevel=\"'4.2'\">\n    <cx-cart-item-validation-warning\n      [code]=\"item.product.code\"\n    ></cx-cart-item-validation-warning>\n  </ng-container>\n  <div [ngClass]=\"compact ? 'cx-compact row' : 'row'\">\n    <!-- Item Image -->\n    <div class=\"col-2 cx-image-container\">\n      <a\n        [routerLink]=\"{ cxRoute: 'product', params: item.product } | cxUrl\"\n        cxModal=\"dismiss\"\n        tabindex=\"-1\"\n      >\n        <cx-media\n          [container]=\"item.product.images?.PRIMARY\"\n          format=\"cartIcon\"\n        ></cx-media>\n      </a>\n    </div>\n    <!-- Item Information -->\n    <div class=\"cx-info col-10\">\n      <div class=\"cx-info-container row\">\n        <!-- Item Description -->\n        <div [ngClass]=\"compact ? '' : ' col-md-3 col-lg-3 col-xl-5'\">\n          <div *ngIf=\"item.product.name\" class=\"cx-name\">\n            <a\n              class=\"cx-link\"\n              [routerLink]=\"\n                { cxRoute: 'product', params: item.product } | cxUrl\n              \"\n              cxModal=\"dismiss\"\n              ><h2>{{ item.product.name }}</h2></a\n            >\n          </div>\n          <div *ngIf=\"item.product.code\" class=\"cx-code\">\n            {{ 'cartItems.id' | cxTranslate }} {{ item.product.code }}\n          </div>\n\n          <!-- Item Details Outlet -->\n          <ng-template [cxOutlet]=\"CartOutlets.ITEM_DETAILS\"> </ng-template>\n\n          <!-- Variants -->\n          <ng-container *ngIf=\"item.product.baseOptions?.length\">\n            <div\n              *ngFor=\"\n                let variant of item.product.baseOptions[0]?.selected\n                  ?.variantOptionQualifiers\n              \"\n              class=\"cx-property\"\n            >\n              <div class=\"cx-label\" *ngIf=\"variant.name && variant.value\">\n                {{ variant.name }}: {{ variant.value }}\n              </div>\n            </div>\n          </ng-container>\n        </div>\n        <!-- Item Price -->\n        <div\n          *ngIf=\"item.basePrice\"\n          class=\"cx-price\"\n          [ngClass]=\"compact ? '' : ' col-md-3 col-lg-3 col-xl-2'\"\n        >\n          <div\n            class=\"cx-label\"\n            [ngClass]=\"compact ? '' : ' d-block d-md-none d-lg-none d-xl-none'\"\n          >\n            {{ 'cartItems.itemPrice' | cxTranslate }}\n          </div>\n          <div *ngIf=\"item.basePrice\" class=\"cx-value\">\n            {{ item.basePrice?.formattedValue }}\n          </div>\n        </div>\n        <!-- Item Quantity -->\n        <div class=\"cx-quantity\" [ngClass]=\"compact ? '' : ' col-3'\">\n          <div\n            class=\"cx-label\"\n            [ngClass]=\"compact ? '' : ' d-block d-md-none d-lg-none d-xl-none'\"\n            placement=\"left\"\n            title=\"{{ 'cartItems.quantityTitle' | cxTranslate }}\"\n          >\n            {{ 'cartItems.quantity' | cxTranslate }}\n          </div>\n          <div class=\"cx-value\" [class.readonly-value]=\"readonly\">\n            <cx-item-counter\n              [control]=\"quantityControl\"\n              [readonly]=\"\n                !item.updateable || readonly || options.isSaveForLater\n              \"\n              [max]=\"item.product.stock?.stockLevel\"\n              [allowZero]=\"true\"\n            >\n            </cx-item-counter>\n          </div>\n        </div>\n        <!-- Total -->\n        <ng-container *ngIf=\"options.isSaveForLater; else total\">\n          <div\n            class=\"cx-total\"\n            [ngClass]=\"compact ? '' : ' col-md-3 col-lg-3 col-xl-2'\"\n          >\n            <div\n              class=\"cx-label\"\n              [ngClass]=\"\n                compact ? '' : ' d-block d-md-none d-lg-none d-xl-none'\n              \"\n            >\n              {{ 'saveForLaterItems.stock' | cxTranslate }}\n            </div>\n            <div\n              *ngIf=\"item.product?.stock?.stockLevel >= 0; else forceInstock\"\n              class=\"cx-value\"\n            >\n              {{ item.product.stock.stockLevel }}\n            </div>\n            <ng-template #forceInstock>\n              <div class=\"cx-value\">\n                {{ 'saveForLaterItems.forceInStock' | cxTranslate }}\n              </div>\n            </ng-template>\n          </div>\n        </ng-container>\n      </div>\n      <!-- Availability -->\n      <div\n        *ngIf=\"isProductOutOfStock(item.product)\"\n        class=\"cx-availability col-12\"\n      >\n        {{ 'addToCart.outOfStock' | cxTranslate }}\n      </div>\n\n      <!-- Item Bundle Details Outlet -->\n      <ng-template [cxOutlet]=\"CartOutlets.ITEM_BUNDLE_DETAILS\"> </ng-template>\n\n      <!-- Promotion -->\n\n      <cx-promotions [promotions]=\"item.promotions\"></cx-promotions>\n\n      <!-- Actions -->\n      <div\n        *ngIf=\"(!readonly || options.isSaveForLater) && item.updateable\"\n        class=\"cx-actions col-12\"\n      >\n        <ng-container *ngIf=\"!isProductOutOfStock(item.product)\">\n          <ng-container\n            *ngTemplateOutlet=\"\n              options.optionalBtn;\n              context: {\n                $implicit: { loading: quantityControl.disabled, item: item }\n              }\n            \"\n          ></ng-container>\n        </ng-container>\n\n        <div class=\"col-md-3 cx-remove-btn\">\n          <button\n            class=\"link cx-action-link\"\n            [disabled]=\"quantityControl.disabled\"\n            (click)=\"removeItem()\"\n            attr.aria-label=\"{{ 'addToCart.removeFromCart' | cxTranslate }}\"\n          >\n            {{ 'common.remove' | cxTranslate }}\n          </button>\n        </div>\n      </div>\n    </div>\n  </div>\n\n  <ng-template #total>\n    <div\n      *ngIf=\"item.totalPrice\"\n      class=\"cx-total\"\n      [ngClass]=\"compact ? '' : ' col-md-3 col-xl-2'\"\n    >\n      <div\n        class=\"cx-label\"\n        [ngClass]=\"compact ? '' : ' d-block d-md-none d-lg-none d-xl-none'\"\n      >\n        {{ 'cartItems.total' | cxTranslate }}\n      </div>\n      <div class=\"cx-value\">{{ item.totalPrice.formattedValue }}</div>\n    </div>\n  </ng-template>\n</ng-template>\n", components: [{ type: CartItemValidationWarningComponent, selector: "cx-cart-item-validation-warning", inputs: ["code"] }, { type: MediaComponent, selector: "cx-media", inputs: ["container", "format", "alt", "role", "loading"], outputs: ["loaded"] }, { type: ItemCounterComponent, selector: "cx-item-counter", inputs: ["control", "min", "max", "step", "allowZero", "readonly"] }, { type: PromotionsComponent, selector: "cx-promotions", inputs: ["promotions"] }], directives: [{ type: OutletDirective, selector: "[cxOutlet]", inputs: ["cxOutlet", "cxOutletContext", "cxOutletDefer"], outputs: ["loaded"] }, { type: i1.FeatureLevelDirective, selector: "[cxFeatureLevel]", inputs: ["cxFeatureLevel"] }, { type: i3.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { type: i1$1.RouterLinkWithHref, selector: "a[routerLink],area[routerLink]", inputs: ["routerLink", "target", "queryParams", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange", "replaceUrl", "state", "relativeTo"] }, { type: ModalDirective, selector: "[cxModal]", inputs: ["cxModal", "cxModalReason"] }, { type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i3.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }], pipes: { "cxUrl": i1.UrlPipe, "cxTranslate": i1.TranslatePipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CartItemComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-cart-item',
                    templateUrl: './cart-item.component.html',
                    providers: [
                        CartItemContextSource,
                        { provide: CartItemContext, useExisting: CartItemContextSource },
                    ],
                }]
        }], ctorParameters: function () { return [{ type: CartItemContextSource }]; }, propDecorators: { compact: [{
                type: Input
            }], item: [{
                type: Input
            }], readonly: [{
                type: Input
            }], quantityControl: [{
                type: Input
            }], promotionLocation: [{
                type: Input
            }], options: [{
                type: Input
            }] } });

class AddedToCartDialogComponent {
    constructor(modalService, cartService) {
        this.modalService = modalService;
        this.cartService = cartService;
        this.iconTypes = ICON_TYPE;
        this.promotionLocation = PromotionLocation.ActiveCart;
        this.quantity = 0;
        this.modalIsOpen = false;
        this.form = new FormGroup({});
    }
    /**
     * Returns an observable formControl with the quantity of the cartEntry,
     * but also updates the entry in case of a changed value.
     * The quantity can be set to zero in order to remove the entry.
     */
    getQuantityControl() {
        if (!this.quantityControl$) {
            this.quantityControl$ = this.entry$.pipe(filter((e) => !!e), map((entry) => this.getQuantityFormControl(entry)), switchMap(() => this.form.valueChanges.pipe(
            // eslint-disable-next-line import/no-deprecated
            startWith(null), tap((valueChange) => {
                if (valueChange) {
                    this.cartService.updateEntry(valueChange.entryNumber, valueChange.quantity);
                    if (valueChange.quantity === 0) {
                        this.dismissModal('Removed');
                    }
                }
                else {
                    this.form.markAsPristine();
                }
            }))), map(() => this.form.get('quantity')), shareReplay({ bufferSize: 1, refCount: true }));
        }
        return this.quantityControl$;
    }
    ngOnInit() {
        this.addedEntryWasMerged$ = this.loaded$.pipe(filter((loaded) => loaded), switchMapTo(this.cartService.getEntries()), map((entries) => entries.length === this.numberOfEntriesBeforeAdd));
    }
    /**
     * Adds quantity and entryNumber form controls to the FormGroup.
     * Returns quantity form control.
     */
    getQuantityFormControl(entry) {
        if (!this.form.get('quantity')) {
            const quantity = new FormControl(entry.quantity, { updateOn: 'blur' });
            this.form.addControl('quantity', quantity);
            const entryNumber = new FormControl(entry.entryNumber);
            this.form.addControl('entryNumber', entryNumber);
        }
        return this.form.get('quantity');
    }
    dismissModal(reason) {
        this.modalService.dismissActiveModal(reason);
    }
}
AddedToCartDialogComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AddedToCartDialogComponent, deps: [{ token: ModalService }, { token: i1.ActiveCartService }], target: i0.ɵɵFactoryTarget.Component });
AddedToCartDialogComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: AddedToCartDialogComponent, selector: "cx-added-to-cart-dialog", viewQueries: [{ propertyName: "dialog", first: true, predicate: ["dialog"], descendants: true, read: ElementRef }], ngImport: i0, template: "<div #dialog>\n  <!-- Modal Header -->\n  <ng-container *ngIf=\"(loaded$ | async) || modalIsOpen; else loading\">\n    <div class=\"cx-dialog-header modal-header\">\n      <div\n        class=\"cx-dialog-title modal-title\"\n        aria-live=\"polite\"\n        aria-atomic=\"true\"\n      >\n        {{\n          (addedEntryWasMerged$ | async)\n            ? ('addToCart.itemsIncrementedInYourCart' | cxTranslate)\n            : ('addToCart.itemsAddedToYourCart' | cxTranslate)\n        }}\n      </div>\n      <button\n        type=\"button\"\n        class=\"close\"\n        attr.aria-label=\"{{ 'addToCart.closeModal' | cxTranslate }}\"\n        cxModal=\"dismiss\"\n        cxModalReason=\"Cross click\"\n      >\n        <span aria-hidden=\"true\">\n          <cx-icon [type]=\"iconTypes.CLOSE\"></cx-icon>\n        </span>\n      </button>\n    </div>\n    <!-- Modal Body -->\n    <div class=\"cx-dialog-body modal-body\" *ngIf=\"entry$ | async as entry\">\n      <div class=\"cx-dialog-row\">\n        <div class=\"cx-dialog-item col-sm-12 col-md-6\">\n          <cx-cart-item\n            [item]=\"entry\"\n            [compact]=\"true\"\n            [quantityControl]=\"getQuantityControl() | async\"\n            [promotionLocation]=\"promotionLocation\"\n          ></cx-cart-item>\n        </div>\n        <!-- Separator -->\n        <div\n          class=\"cx-dialog-separator col-sm-12 d-xs-block d-sm-block d-md-none\"\n        ></div>\n        <!-- Total container -->\n        <div\n          class=\"cx-dialog-actions col-sm-12 col-md-6\"\n          *ngIf=\"cart$ | async as cart\"\n        >\n          <div class=\"cx-dialog-total\">\n            <div>\n              {{\n                'cartItems.cartTotal'\n                  | cxTranslate: { count: cart.deliveryItemsQuantity }\n              }}\n            </div>\n\n            <div>{{ cart.subTotal?.formattedValue }}</div>\n          </div>\n\n          <!-- Promotions -->\n          <div class=\"cx-dialog-promotions\">\n            <cx-promotions\n              [promotions]=\"\n                (cart.appliedOrderPromotions || []).concat(\n                  cart.potentialOrderPromotions || []\n                )\n              \"\n            ></cx-promotions>\n          </div>\n\n          <!-- Actions -->\n          <div class=\"cx-dialog-buttons\">\n            <a\n              [class.disabled]=\"form.dirty\"\n              [routerLink]=\"{ cxRoute: 'cart' } | cxUrl\"\n              cxModal=\"dismiss\"\n              cxModalReason=\"View Cart click\"\n              class=\"btn btn-primary\"\n              autofocus\n              >{{ 'addToCart.viewCart' | cxTranslate }}</a\n            >\n            <a\n              [class.disabled]=\"form.dirty\"\n              [routerLink]=\"{ cxRoute: 'checkout' } | cxUrl\"\n              cxModal=\"dismiss\"\n              cxModalReason=\"Proceed To Checkout click\"\n              class=\"btn btn-secondary\"\n              >{{ 'addToCart.proceedToCheckout' | cxTranslate }}</a\n            >\n          </div>\n        </div>\n      </div>\n    </div>\n  </ng-container>\n\n  <ng-template #loading>\n    <div class=\"cx-dialog-header modal-header\">\n      <div class=\"cx-dialog-title modal-title\">\n        {{ 'addToCart.updatingCart' | cxTranslate }}\n      </div>\n      <button\n        type=\"button\"\n        class=\"close\"\n        [attr.aria-label]=\"'common.close' | cxTranslate\"\n        cxModal=\"dismiss\"\n        cxModalReason=\"Cross click\"\n      >\n        <span aria-hidden=\"true\">\n          <cx-icon [type]=\"iconTypes.CLOSE\"></cx-icon>\n        </span>\n      </button>\n    </div>\n    <!-- Modal Body -->\n    <div class=\"cx-dialog-body modal-body\">\n      <div class=\"cx-dialog-row\">\n        <div class=\"col-sm-12\"><cx-spinner></cx-spinner></div>\n      </div>\n    </div>\n  </ng-template>\n</div>\n", components: [{ type: IconComponent, selector: "cx-icon,[cxIcon]", inputs: ["cxIcon", "type"] }, { type: CartItemComponent, selector: "cx-cart-item", inputs: ["compact", "item", "readonly", "quantityControl", "promotionLocation", "options"] }, { type: PromotionsComponent, selector: "cx-promotions", inputs: ["promotions"] }, { type: SpinnerComponent, selector: "cx-spinner" }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: ModalDirective, selector: "[cxModal]", inputs: ["cxModal", "cxModalReason"] }, { type: i1$1.RouterLinkWithHref, selector: "a[routerLink],area[routerLink]", inputs: ["routerLink", "target", "queryParams", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange", "replaceUrl", "state", "relativeTo"] }], pipes: { "async": i3.AsyncPipe, "cxTranslate": i1.TranslatePipe, "cxUrl": i1.UrlPipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AddedToCartDialogComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-added-to-cart-dialog',
                    templateUrl: './added-to-cart-dialog.component.html',
                }]
        }], ctorParameters: function () { return [{ type: ModalService }, { type: i1.ActiveCartService }]; }, propDecorators: { dialog: [{
                type: ViewChild,
                args: ['dialog', { read: ElementRef }]
            }] } });

class CurrentProductService {
    constructor(routingService, productService) {
        this.routingService = routingService;
        this.productService = productService;
        this.DEFAULT_PRODUCT_SCOPE = "details" /* DETAILS */;
    }
    /**
     * Returns an observable for the current product
     * @returns Product
     * @returns null if product can't be found
     *
     * @param scopes
     */
    getProduct(scopes) {
        return this.getCode().pipe(distinctUntilChanged(), switchMap((productCode) => {
            return productCode
                ? this.productService.get(productCode, scopes || this.DEFAULT_PRODUCT_SCOPE)
                : of(null);
        }), filter(isNotUndefined));
    }
    getCode() {
        return this.routingService
            .getRouterState()
            .pipe(map((state) => state.state.params['productCode']));
    }
}
CurrentProductService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CurrentProductService, deps: [{ token: i1.RoutingService }, { token: i1.ProductService }], target: i0.ɵɵFactoryTarget.Injectable });
CurrentProductService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CurrentProductService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CurrentProductService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.RoutingService }, { type: i1.ProductService }]; } });

class CmsComponentData {
}

class AddToCartComponent {
    constructor(modalService, currentProductService, cd, activeCartService, component) {
        var _a;
        this.modalService = modalService;
        this.currentProductService = currentProductService;
        this.cd = cd;
        this.activeCartService = activeCartService;
        this.component = component;
        this.showQuantity = true;
        this.hasStock = false;
        this.inventoryThreshold = false;
        this.showInventory$ = (_a = this.component) === null || _a === void 0 ? void 0 : _a.data$.pipe(map((data) => data.inventoryDisplay));
        this.quantity = 1;
        this.numberOfEntriesBeforeAdd = 0;
        this.addToCartForm = new FormGroup({
            quantity: new FormControl(1, { updateOn: 'blur' }),
        });
    }
    ngOnInit() {
        var _a;
        if (this.product) {
            this.productCode = (_a = this.product.code) !== null && _a !== void 0 ? _a : '';
            this.setStockInfo(this.product);
            this.cd.markForCheck();
        }
        else if (this.productCode) {
            // force hasStock and quantity for the time being, as we do not have more info:
            this.quantity = 1;
            this.hasStock = true;
            this.cd.markForCheck();
        }
        else {
            this.subscription = this.currentProductService
                .getProduct()
                .pipe(filter(isNotNullable))
                .subscribe((product) => {
                var _a;
                this.productCode = (_a = product.code) !== null && _a !== void 0 ? _a : '';
                this.setStockInfo(product);
                this.cd.markForCheck();
            });
        }
    }
    setStockInfo(product) {
        var _a, _b, _c, _d;
        this.quantity = 1;
        this.hasStock = Boolean(((_a = product.stock) === null || _a === void 0 ? void 0 : _a.stockLevelStatus) !== 'outOfStock');
        this.inventoryThreshold = (_c = (_b = product.stock) === null || _b === void 0 ? void 0 : _b.isValueRounded) !== null && _c !== void 0 ? _c : false;
        if (this.hasStock && ((_d = product.stock) === null || _d === void 0 ? void 0 : _d.stockLevel)) {
            this.maxQuantity = product.stock.stockLevel;
        }
    }
    /**
     * In specific scenarios, we need to omit displaying the stock level or append a plus to the value.
     * When backoffice forces a product to be in stock, omit showing the stock level.
     * When product stock level is limited by a threshold value, append '+' at the end.
     * When out of stock, display no numerical value.
     */
    getInventory() {
        if (this.hasStock) {
            const quantityDisplay = this.maxQuantity
                ? this.maxQuantity.toString()
                : '';
            return this.inventoryThreshold ? quantityDisplay + '+' : quantityDisplay;
        }
        else {
            return '';
        }
    }
    updateCount(value) {
        this.quantity = value;
    }
    addToCart() {
        const quantity = this.addToCartForm.get('quantity').value;
        if (!this.productCode || quantity <= 0) {
            return;
        }
        this.activeCartService
            .getEntries()
            .pipe(take(1))
            .subscribe((entries) => {
            this.numberOfEntriesBeforeAdd = entries.length;
            this.openModal();
            this.activeCartService.addEntry(this.productCode, quantity);
        });
    }
    /**
     * Provides required data and opens AddedToCartDialogComponent modal
     */
    openModal() {
        let modalInstance;
        this.modalRef = this.modalService.open(AddedToCartDialogComponent, {
            centered: true,
            size: 'lg',
        });
        modalInstance = this.modalRef.componentInstance;
        // Display last entry for new product code. This always corresponds to
        // our new item, independently of whether merging occured or not
        modalInstance.entry$ = this.activeCartService.getLastEntry(this.productCode);
        modalInstance.cart$ = this.activeCartService.getActive();
        modalInstance.loaded$ = this.activeCartService.isStable();
        modalInstance.quantity = this.quantity;
        modalInstance.numberOfEntriesBeforeAdd = this.numberOfEntriesBeforeAdd;
    }
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
    }
}
AddToCartComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AddToCartComponent, deps: [{ token: ModalService }, { token: CurrentProductService }, { token: i0.ChangeDetectorRef }, { token: i1.ActiveCartService }, { token: CmsComponentData, optional: true }], target: i0.ɵɵFactoryTarget.Component });
AddToCartComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: AddToCartComponent, selector: "cx-add-to-cart", inputs: { productCode: "productCode", showQuantity: "showQuantity", product: "product" }, ngImport: i0, template: "<form *ngIf=\"productCode\" [formGroup]=\"addToCartForm\" (submit)=\"addToCart()\">\n  <div class=\"quantity\" *ngIf=\"showQuantity\">\n    <label>{{ 'addToCart.quantity' | cxTranslate }}</label>\n    <cx-item-counter\n      *ngIf=\"hasStock\"\n      [max]=\"maxQuantity\"\n      [control]=\"addToCartForm.get('quantity')\"\n    ></cx-item-counter>\n\n    <span class=\"info\">\n      <span *ngIf=\"showInventory$ | async\">{{ getInventory() }}</span>\n      {{\n        hasStock\n          ? ('addToCart.inStock' | cxTranslate)\n          : ('addToCart.outOfStock' | cxTranslate)\n      }}</span\n    >\n  </div>\n\n  <button\n    *ngIf=\"hasStock\"\n    class=\"btn btn-primary btn-block\"\n    type=\"submit\"\n    [disabled]=\"quantity <= 0 || quantity > maxQuantity\"\n  >\n    {{ 'addToCart.addToCart' | cxTranslate }}\n  </button>\n</form>\n", components: [{ type: ItemCounterComponent, selector: "cx-item-counter", inputs: ["control", "min", "max", "step", "allowZero", "readonly"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3$1.ɵNgNoValidate, selector: "form:not([ngNoForm]):not([ngNativeValidate])" }, { type: i3$1.NgControlStatusGroup, selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { type: i3$1.FormGroupDirective, selector: "[formGroup]", inputs: ["formGroup"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }], pipes: { "cxTranslate": i1.TranslatePipe, "async": i3.AsyncPipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AddToCartComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-add-to-cart',
                    templateUrl: './add-to-cart.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: ModalService }, { type: CurrentProductService }, { type: i0.ChangeDetectorRef }, { type: i1.ActiveCartService }, { type: CmsComponentData, decorators: [{
                    type: Optional
                }] }]; }, propDecorators: { productCode: [{
                type: Input
            }], showQuantity: [{
                type: Input
            }], product: [{
                type: Input
            }] } });

class SpinnerModule {
}
SpinnerModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SpinnerModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
SpinnerModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SpinnerModule, declarations: [SpinnerComponent], imports: [CommonModule, I18nModule], exports: [SpinnerComponent] });
SpinnerModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SpinnerModule, imports: [[CommonModule, I18nModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SpinnerModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, I18nModule],
                    declarations: [SpinnerComponent],
                    exports: [SpinnerComponent],
                }]
        }] });

class ConsentManagementComponent {
    constructor(userConsentService, globalMessageService, anonymousConsentsConfig, anonymousConsentsService, authService) {
        this.userConsentService = userConsentService;
        this.globalMessageService = globalMessageService;
        this.anonymousConsentsConfig = anonymousConsentsConfig;
        this.anonymousConsentsService = anonymousConsentsService;
        this.authService = authService;
        this.subscriptions = new Subscription();
        this.allConsentsLoading = new BehaviorSubject(false);
        this.requiredConsents = [];
    }
    ngOnInit() {
        this.loading$ = combineLatest([
            this.userConsentService.getConsentsResultLoading(),
            this.userConsentService.getGiveConsentResultLoading(),
            this.userConsentService.getWithdrawConsentResultLoading(),
            this.authService.isUserLoggedIn(),
            this.allConsentsLoading,
        ]).pipe(map(([consentLoading, giveConsentLoading, withdrawConsentLoading, isUserLoggedIn, allConsentsLoading,]) => consentLoading ||
            giveConsentLoading ||
            withdrawConsentLoading ||
            !isUserLoggedIn ||
            allConsentsLoading));
        this.consentListInit();
        this.giveConsentInit();
        this.withdrawConsentInit();
    }
    consentListInit() {
        this.templateList$ = this.userConsentService.getConsents().pipe(withLatestFrom(this.anonymousConsentsService.getTemplates(), this.authService.isUserLoggedIn()), filter(([_templateList, _anonymousTemplates, isUserLoggedIn]) => isUserLoggedIn), tap(([templateList, _anonymousTemplates]) => {
            if (!this.consentsExists(templateList)) {
                this.userConsentService.loadConsents();
            }
        }), map(([templateList, anonymousTemplates]) => {
            if (Boolean(this.anonymousConsentsConfig.anonymousConsents)) {
                if (Boolean(this.anonymousConsentsConfig.anonymousConsents.requiredConsents)) {
                    this.requiredConsents =
                        this.anonymousConsentsConfig.anonymousConsents.requiredConsents;
                }
                if (Boolean(this.anonymousConsentsConfig.anonymousConsents
                    .consentManagementPage)) {
                    return this.hideAnonymousConsents(templateList, anonymousTemplates);
                }
            }
            return templateList;
        }));
    }
    hideAnonymousConsents(templateList, anonymousTemplates = []) {
        let hideTemplateIds = [];
        if (!this.anonymousConsentsConfig.anonymousConsents.consentManagementPage
            .showAnonymousConsents) {
            hideTemplateIds = anonymousTemplates.map((template) => template.id);
            return this.userConsentService.filterConsentTemplates(templateList, hideTemplateIds);
        }
        if (Boolean(this.anonymousConsentsConfig.anonymousConsents.consentManagementPage
            .hideConsents) &&
            this.anonymousConsentsConfig.anonymousConsents.consentManagementPage
                .hideConsents.length > 0) {
            hideTemplateIds =
                this.anonymousConsentsConfig.anonymousConsents.consentManagementPage
                    .hideConsents;
        }
        return this.userConsentService.filterConsentTemplates(templateList, hideTemplateIds);
    }
    giveConsentInit() {
        this.userConsentService.resetGiveConsentProcessState();
        this.subscriptions.add(this.userConsentService
            .getGiveConsentResultSuccess()
            .subscribe((success) => this.onConsentGivenSuccess(success)));
    }
    withdrawConsentInit() {
        this.userConsentService.resetWithdrawConsentProcessState();
        this.subscriptions.add(this.userConsentService
            .getWithdrawConsentResultLoading()
            .pipe(skipWhile(Boolean), withLatestFrom(this.userConsentService.getWithdrawConsentResultSuccess()), map(([, withdrawalSuccess]) => withdrawalSuccess), tap((withdrawalSuccess) => {
            if (withdrawalSuccess) {
                this.userConsentService.loadConsents();
            }
        }))
            .subscribe((withdrawalSuccess) => this.onConsentWithdrawnSuccess(withdrawalSuccess)));
    }
    consentsExists(templateList) {
        return Boolean(templateList) && templateList.length > 0;
    }
    onConsentChange({ given, template, }) {
        if (given) {
            this.userConsentService.giveConsent(template.id, template.version);
        }
        else {
            this.userConsentService.withdrawConsent(template.currentConsent.code);
        }
    }
    onConsentGivenSuccess(success) {
        if (success) {
            this.userConsentService.resetGiveConsentProcessState();
            this.globalMessageService.add({ key: 'consentManagementForm.message.success.given' }, GlobalMessageType.MSG_TYPE_CONFIRMATION);
        }
    }
    onConsentWithdrawnSuccess(success) {
        if (success) {
            this.userConsentService.resetWithdrawConsentProcessState();
            this.globalMessageService.add({ key: 'consentManagementForm.message.success.withdrawn' }, GlobalMessageType.MSG_TYPE_CONFIRMATION);
        }
    }
    rejectAll(templates = []) {
        const consentsToWithdraw = [];
        templates.forEach((template) => {
            if (this.userConsentService.isConsentGiven(template.currentConsent)) {
                if (this.isRequiredConsent(template)) {
                    return;
                }
                consentsToWithdraw.push(template);
            }
        });
        this.allConsentsLoading.next(true);
        this.subscriptions.add(this.setupWithdrawalStream(consentsToWithdraw)
            .pipe(tap((_timesLoaded) => this.allConsentsLoading.next(false)))
            .subscribe());
    }
    setupWithdrawalStream(consentsToWithdraw = []) {
        const loading$ = concat(this.userConsentService.getWithdrawConsentResultLoading()).pipe(distinctUntilChanged(), filter((loading) => !loading));
        const count$ = loading$.pipe(scan((acc, _value) => acc + 1, -1));
        const withdraw$ = count$.pipe(tap((i) => {
            if (i < consentsToWithdraw.length) {
                this.userConsentService.withdrawConsent(consentsToWithdraw[i].currentConsent.code);
            }
        }));
        const checkTimesLoaded$ = withdraw$.pipe(filter((timesLoaded) => timesLoaded === consentsToWithdraw.length));
        return checkTimesLoaded$;
    }
    allowAll(templates = []) {
        const consentsToGive = [];
        templates.forEach((template) => {
            if (this.userConsentService.isConsentWithdrawn(template.currentConsent)) {
                if (this.isRequiredConsent(template)) {
                    return;
                }
            }
            consentsToGive.push(template);
        });
        this.allConsentsLoading.next(true);
        this.subscriptions.add(this.setupGiveStream(consentsToGive)
            .pipe(tap((_timesLoaded) => this.allConsentsLoading.next(false)))
            .subscribe());
    }
    setupGiveStream(consentsToGive = []) {
        const loading$ = concat(this.userConsentService.getGiveConsentResultLoading()).pipe(distinctUntilChanged(), filter((loading) => !loading));
        const count$ = loading$.pipe(scan((acc, _value) => acc + 1, -1));
        const giveConsent$ = count$.pipe(tap((i) => {
            if (i < consentsToGive.length) {
                this.userConsentService.giveConsent(consentsToGive[i].id, consentsToGive[i].version);
            }
        }));
        const checkTimesLoaded$ = giveConsent$.pipe(filter((timesLoaded) => timesLoaded === consentsToGive.length));
        return checkTimesLoaded$;
    }
    isRequiredConsent(template) {
        return (Boolean(this.anonymousConsentsConfig.anonymousConsents) &&
            Boolean(this.anonymousConsentsConfig.anonymousConsents.requiredConsents) &&
            this.anonymousConsentsConfig.anonymousConsents.requiredConsents.includes(template.id));
    }
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
        this.allConsentsLoading.unsubscribe();
        this.userConsentService.resetGiveConsentProcessState();
        this.userConsentService.resetWithdrawConsentProcessState();
    }
}
ConsentManagementComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ConsentManagementComponent, deps: [{ token: i1.UserConsentService }, { token: i1.GlobalMessageService }, { token: i1.AnonymousConsentsConfig }, { token: i1.AnonymousConsentsService }, { token: i1.AuthService }], target: i0.ɵɵFactoryTarget.Component });
ConsentManagementComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: ConsentManagementComponent, selector: "cx-consent-management", ngImport: i0, template: "<div *ngIf=\"loading$ | async; else consentManagementForm\">\n  <div class=\"cx-spinner\">\n    <cx-spinner></cx-spinner>\n  </div>\n</div>\n\n<ng-template #consentManagementForm>\n  <ng-container *ngIf=\"templateList$ | async as templateList\">\n    <div class=\"cx-consent-action-links\">\n      <div class=\"col-sm-12 col-md-8 col-lg-6\">\n        <button\n          tabindex=\"0\"\n          class=\"btn btn-link cx-action-link\"\n          (click)=\"rejectAll(templateList)\"\n        >\n          {{ 'consentManagementForm.clearAll' | cxTranslate }}\n        </button>\n        <button\n          tabindex=\"0\"\n          class=\"btn btn-link cx-action-link\"\n          (click)=\"allowAll(templateList)\"\n        >\n          {{ 'consentManagementForm.selectAll' | cxTranslate }}\n        </button>\n      </div>\n    </div>\n\n    <div class=\"cx-consent-toggles\">\n      <div class=\"col-sm-12 col-md-8 col-lg-6\">\n        <cx-consent-management-form\n          *ngFor=\"let consentTemplate of templateList\"\n          [consentTemplate]=\"consentTemplate\"\n          [requiredConsents]=\"requiredConsents\"\n          (consentChanged)=\"onConsentChange($event)\"\n        ></cx-consent-management-form>\n      </div>\n    </div>\n  </ng-container>\n</ng-template>\n", components: [{ type: SpinnerComponent, selector: "cx-spinner" }, { type: ConsentManagementFormComponent, selector: "cx-consent-management-form", inputs: ["consentTemplate", "requiredConsents", "consent"], outputs: ["consentChanged"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], pipes: { "async": i3.AsyncPipe, "cxTranslate": i1.TranslatePipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ConsentManagementComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-consent-management',
                    templateUrl: './consent-management.component.html',
                }]
        }], ctorParameters: function () { return [{ type: i1.UserConsentService }, { type: i1.GlobalMessageService }, { type: i1.AnonymousConsentsConfig }, { type: i1.AnonymousConsentsService }, { type: i1.AuthService }]; } });

class ConsentManagementModule {
}
ConsentManagementModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ConsentManagementModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ConsentManagementModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ConsentManagementModule, declarations: [ConsentManagementComponent, ConsentManagementFormComponent], imports: [CommonModule,
        FormsModule,
        ReactiveFormsModule,
        SpinnerModule,
        I18nModule,
        IconModule], exports: [ConsentManagementComponent, ConsentManagementFormComponent] });
ConsentManagementModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ConsentManagementModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                ConsentManagementComponent: {
                    component: ConsentManagementComponent,
                    guards: [AuthGuard],
                },
            },
        }),
    ], imports: [[
            CommonModule,
            FormsModule,
            ReactiveFormsModule,
            SpinnerModule,
            I18nModule,
            IconModule,
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ConsentManagementModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        FormsModule,
                        ReactiveFormsModule,
                        SpinnerModule,
                        I18nModule,
                        IconModule,
                    ],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                ConsentManagementComponent: {
                                    component: ConsentManagementComponent,
                                    guards: [AuthGuard],
                                },
                            },
                        }),
                    ],
                    declarations: [ConsentManagementComponent, ConsentManagementFormComponent],
                    exports: [ConsentManagementComponent, ConsentManagementFormComponent],
                }]
        }] });

class AnonymousConsentsDialogModule {
}
AnonymousConsentsDialogModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AnonymousConsentsDialogModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
AnonymousConsentsDialogModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AnonymousConsentsDialogModule, declarations: [AnonymousConsentDialogComponent], imports: [CommonModule,
        I18nModule,
        IconModule,
        SpinnerModule,
        ConsentManagementModule,
        KeyboardFocusModule], exports: [AnonymousConsentDialogComponent] });
AnonymousConsentsDialogModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AnonymousConsentsDialogModule, imports: [[
            CommonModule,
            I18nModule,
            IconModule,
            SpinnerModule,
            ConsentManagementModule,
            KeyboardFocusModule,
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AnonymousConsentsDialogModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        I18nModule,
                        IconModule,
                        SpinnerModule,
                        ConsentManagementModule,
                        KeyboardFocusModule,
                    ],
                    declarations: [AnonymousConsentDialogComponent],
                    exports: [AnonymousConsentDialogComponent],
                }]
        }] });

var PopoverEvent;
(function (PopoverEvent) {
    PopoverEvent["INSIDE_CLICK"] = "insideClick";
    PopoverEvent["OUTSIDE_CLICK"] = "outsideClick";
    PopoverEvent["ESCAPE_KEYDOWN"] = "escapeKeydown";
    PopoverEvent["CLOSE_BUTTON_CLICK"] = "closeButtonClick";
    PopoverEvent["CLOSE_BUTTON_KEYDOWN"] = "closeButtonKeydown";
    PopoverEvent["ROUTE_CHANGE"] = "routeChange";
    PopoverEvent["OPEN"] = "open";
    PopoverEvent["OPEN_BY_KEYBOARD"] = "openByKeyboard";
})(PopoverEvent || (PopoverEvent = {}));

class PositioningService {
    constructor(winRef) {
        this.winRef = winRef;
    }
    get allowedPlacements() {
        return [
            'top',
            'bottom',
            'left',
            'right',
            'top-left',
            'top-right',
            'bottom-left',
            'bottom-right',
            'left-top',
            'left-bottom',
            'right-top',
            'right-bottom',
        ];
    }
    get placementSeparator() {
        return /\s+/;
    }
    get window() {
        return this.winRef.nativeWindow;
    }
    get document() {
        return this.winRef.document;
    }
    getAllStyles(element) {
        var _a;
        return (_a = this.window) === null || _a === void 0 ? void 0 : _a.getComputedStyle(element);
    }
    getPositionStyleProperty(element) {
        const styles = this.getAllStyles(element);
        if (styles)
            return styles['position'] || undefined;
    }
    isStaticPositioned(element) {
        return (this.getPositionStyleProperty(element) || 'static') === 'static';
    }
    offsetParent(element) {
        let offsetParentEl = element.offsetParent || this.document.documentElement;
        while (offsetParentEl &&
            offsetParentEl !== this.document.documentElement &&
            this.isStaticPositioned(offsetParentEl)) {
            offsetParentEl = offsetParentEl.offsetParent;
        }
        return offsetParentEl || this.document.documentElement;
    }
    position(element, round = true) {
        let elPosition;
        let parentOffset = {
            width: 0,
            height: 0,
            top: 0,
            bottom: 0,
            left: 0,
            right: 0,
        };
        if (this.getPositionStyleProperty(element) === 'fixed') {
            elPosition = element.getBoundingClientRect();
            elPosition = {
                top: elPosition.top,
                bottom: elPosition.bottom,
                left: elPosition.left,
                right: elPosition.right,
                height: elPosition.height,
                width: elPosition.width,
            };
        }
        else {
            const offsetParentEl = this.offsetParent(element);
            elPosition = this.offset(element, false);
            if (offsetParentEl !== this.document.documentElement) {
                parentOffset = this.offset(offsetParentEl, false);
            }
            parentOffset.top += offsetParentEl.clientTop;
            parentOffset.left += offsetParentEl.clientLeft;
        }
        elPosition.top -= parentOffset.top;
        elPosition.bottom -= parentOffset.top;
        elPosition.left -= parentOffset.left;
        elPosition.right -= parentOffset.left;
        if (round) {
            elPosition.top = Math.round(elPosition.top);
            elPosition.bottom = Math.round(elPosition.bottom);
            elPosition.left = Math.round(elPosition.left);
            elPosition.right = Math.round(elPosition.right);
        }
        return elPosition;
    }
    offset(element, round = true) {
        const elBcr = element.getBoundingClientRect();
        const viewportOffset = {
            top: (this.window &&
                this.window.pageYOffset - this.document.documentElement.clientTop) ||
                0,
            left: (this.window &&
                this.window.pageXOffset - this.document.documentElement.clientLeft) ||
                0,
        };
        const elOffset = {
            height: elBcr.height || element.offsetHeight,
            width: elBcr.width || element.offsetWidth,
            top: elBcr.top + viewportOffset.top,
            bottom: elBcr.bottom + viewportOffset.top,
            left: elBcr.left + viewportOffset.left,
            right: elBcr.right + viewportOffset.left,
        };
        if (round) {
            elOffset.height = Math.round(elOffset.height);
            elOffset.width = Math.round(elOffset.width);
            elOffset.top = Math.round(elOffset.top);
            elOffset.bottom = Math.round(elOffset.bottom);
            elOffset.left = Math.round(elOffset.left);
            elOffset.right = Math.round(elOffset.right);
        }
        return elOffset;
    }
    /*
      Return false if the element to position is outside the viewport.
    */
    _positionElements(hostElement, targetElement, placement, appendToBody) {
        var _a, _b;
        const [placementPrimary = 'top', placementSecondary = 'center'] = placement.split('-');
        const hostElPosition = appendToBody
            ? this.offset(hostElement, false)
            : this.position(hostElement, false);
        const targetElStyles = this.getAllStyles(targetElement);
        if (targetElStyles) {
            const marginTop = parseFloat(targetElStyles.marginTop);
            const marginBottom = parseFloat(targetElStyles.marginBottom);
            const marginLeft = parseFloat(targetElStyles.marginLeft);
            const marginRight = parseFloat(targetElStyles.marginRight);
            let topPosition = 0;
            let leftPosition = 0;
            switch (placementPrimary) {
                case 'top':
                    topPosition =
                        hostElPosition.top -
                            (targetElement.offsetHeight + marginTop + marginBottom);
                    break;
                case 'bottom':
                    topPosition = hostElPosition.top + hostElPosition.height;
                    break;
                case 'left':
                    leftPosition =
                        hostElPosition.left -
                            (targetElement.offsetWidth + marginLeft + marginRight);
                    break;
                case 'right':
                    leftPosition = hostElPosition.left + hostElPosition.width;
                    break;
            }
            switch (placementSecondary) {
                case 'top':
                    topPosition = hostElPosition.top;
                    break;
                case 'bottom':
                    topPosition =
                        hostElPosition.top +
                            hostElPosition.height -
                            targetElement.offsetHeight;
                    break;
                case 'left':
                    leftPosition = hostElPosition.left;
                    break;
                case 'right':
                    leftPosition =
                        hostElPosition.left +
                            hostElPosition.width -
                            targetElement.offsetWidth;
                    break;
                case 'center':
                    if (placementPrimary === 'top' || placementPrimary === 'bottom') {
                        leftPosition =
                            hostElPosition.left +
                                hostElPosition.width / 2 -
                                targetElement.offsetWidth / 2;
                    }
                    else {
                        topPosition =
                            hostElPosition.top +
                                hostElPosition.height / 2 -
                                targetElement.offsetHeight / 2;
                    }
                    break;
            }
            targetElement.style.transform = `translate(${Math.round(leftPosition)}px, ${Math.round(topPosition)}px)`;
            // Check if the targetElement is inside the viewport
            const targetElBCR = targetElement.getBoundingClientRect();
            const html = this.document.documentElement;
            const windowHeight = ((_a = this.window) === null || _a === void 0 ? void 0 : _a.innerHeight) || html.clientHeight;
            const windowWidth = ((_b = this.window) === null || _b === void 0 ? void 0 : _b.innerWidth) || html.clientWidth;
            return (targetElBCR.left >= 0 &&
                targetElBCR.top >= 0 &&
                targetElBCR.right <= windowWidth &&
                targetElBCR.bottom <= windowHeight);
        }
        return false;
    }
    /*
     * Accept the placement array and applies the appropriate placement dependent on the viewport.
     * Returns the applied placement.
     * In case of auto placement, placements are selected in order
     *   'top', 'bottom', 'left', 'right',
     *   'top-left', 'top-right',
     *   'bottom-left', 'bottom-right',
     *   'left-top', 'left-bottom',
     *   'right-top', 'right-bottom'.
     * */
    positionElements(hostElement, targetElement, placement, appendToBody) {
        const placementVals = Array.isArray(placement)
            ? placement
            : placement.split(this.placementSeparator);
        let hasAuto = placementVals.findIndex((val) => val === 'auto');
        if (hasAuto >= 0) {
            this.allowedPlacements.forEach((obj) => {
                if (placementVals.find((val) => val.search('^' + obj) !== -1) == null) {
                    placementVals.splice(hasAuto++, 1, obj);
                }
            });
        }
        const style = targetElement.style;
        style.position = 'absolute';
        style.top = '0';
        style.left = '0';
        let testPlacement = 'auto';
        let isInViewport = false;
        for (testPlacement of placementVals) {
            if (this._positionElements(hostElement, targetElement, testPlacement, appendToBody)) {
                isInViewport = true;
                break;
            }
        }
        if (!isInViewport) {
            this._positionElements(hostElement, targetElement, testPlacement, appendToBody);
        }
        return testPlacement;
    }
    getPositioningClass(position, autoPositioning) {
        let positionClass = `${position || 'top'}`;
        if (autoPositioning && positionClass !== 'auto') {
            positionClass = `${positionClass} auto`;
        }
        return positionClass;
    }
}
PositioningService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PositioningService, deps: [{ token: i1.WindowRef }], target: i0.ɵɵFactoryTarget.Injectable });
PositioningService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PositioningService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PositioningService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.WindowRef }]; } });

class PopoverComponent {
    constructor(positioningService, winRef, changeDetectionRef, renderer, router) {
        this.positioningService = positioningService;
        this.winRef = winRef;
        this.changeDetectionRef = changeDetectionRef;
        this.renderer = renderer;
        this.router = router;
        /**
         * Icon types for close button icon.
         */
        this.iconTypes = ICON_TYPE;
    }
    /**
     * Listens for click inside popover component wrapper.
     */
    insideClick() {
        this.eventSubject.next(PopoverEvent.INSIDE_CLICK);
    }
    /**
     * Listens for every document click and ignores clicks
     * inside component.
     */
    outsideClick(event) {
        if (!this.isClickedOnPopover(event) && !this.isClickedOnDirective(event)) {
            this.eventSubject.next(PopoverEvent.OUTSIDE_CLICK);
        }
    }
    /**
     * Listens for `escape` keydown event.
     */
    escapeKeydown() {
        this.eventSubject.next(PopoverEvent.ESCAPE_KEYDOWN);
    }
    isClickedOnPopover(event) {
        return this.popoverInstance.location.nativeElement.contains(event.target);
    }
    isClickedOnDirective(event) {
        return this.triggerElement.nativeElement.contains(event.target);
    }
    /**
     * Emits close event trigger.
     */
    close(event) {
        event.preventDefault();
        if (event instanceof MouseEvent) {
            this.eventSubject.next(PopoverEvent.CLOSE_BUTTON_CLICK);
        }
        else {
            this.eventSubject.next(PopoverEvent.CLOSE_BUTTON_KEYDOWN);
        }
    }
    /**
     * Method uses `Renderer2` service to listen window scroll event.
     *
     * Registered only if property `positionOnScroll` is set to `true`.
     */
    triggerScrollEvent() {
        this.scrollEventUnlistener = this.renderer.listen(this.winRef.nativeWindow, 'scroll', () => this.positionPopover());
    }
    /**
     * Method uses positioning service calculation and based on that
     * updates class name for popover component instance.
     */
    positionPopover() {
        this.popoverClass = this.positioningService.positionElements(this.triggerElement.nativeElement, this.popoverInstance.location.nativeElement, this.positioningService.getPositioningClass(this.position, this.autoPositioning), this.appendToBody);
        this.changeDetectionRef.markForCheck();
        this.baseClass = `${this.customClass} ${this.popoverClass} opened`;
    }
    ngOnInit() {
        this.isTemplate = this.content instanceof TemplateRef;
        if (!this.customClass)
            this.customClass = 'cx-popover';
        if (!this.position)
            this.position = 'top';
        if (this.autoPositioning === undefined)
            this.autoPositioning = true;
        this.baseClass = `${this.customClass}`;
        this.resizeSub = this.winRef.resize$.subscribe(() => {
            this.positionPopover();
        });
        this.routeChangeSub = this.router.events
            .pipe(filter((event) => event instanceof NavigationStart))
            .subscribe(() => {
            this.eventSubject.next(PopoverEvent.ROUTE_CHANGE);
        });
        if (this.positionOnScroll) {
            this.triggerScrollEvent();
        }
    }
    ngAfterViewChecked() {
        this.positionPopover();
    }
    ngOnDestroy() {
        if (this.resizeSub) {
            this.resizeSub.unsubscribe();
        }
        if (this.routeChangeSub) {
            this.routeChangeSub.unsubscribe();
        }
        if (this.scrollEventUnlistener) {
            this.scrollEventUnlistener();
        }
    }
}
PopoverComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PopoverComponent, deps: [{ token: PositioningService }, { token: i1.WindowRef }, { token: i0.ChangeDetectorRef }, { token: i0.Renderer2 }, { token: i1$1.Router }], target: i0.ɵɵFactoryTarget.Component });
PopoverComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: PopoverComponent, selector: "cx-popover", host: { listeners: { "click": "insideClick()", "document:click": "outsideClick($event)", "keydown.escape": "escapeKeydown()" }, properties: { "className": "this.baseClass" } }, ngImport: i0, template: "<div class=\"arrow\"></div>\n<div class=\"popover-body\" [cxFocus]=\"focusConfig\">\n  <div class=\"cx-close-row\">\n    <button\n      *ngIf=\"displayCloseButton\"\n      type=\"button\"\n      class=\"close\"\n      (keydown.enter)=\"close($event)\"\n      (keydown.space)=\"close($event)\"\n      (click)=\"close($event)\"\n    >\n      <cx-icon [type]=\"iconTypes.CLOSE\"></cx-icon>\n    </button>\n  </div>\n  <ng-container *ngIf=\"isTemplate\">\n    <ng-container *ngTemplateOutlet=\"content\"></ng-container>\n  </ng-container>\n  <span *ngIf=\"!isTemplate\">{{ content }}</span>\n</div>\n", components: [{ type: IconComponent, selector: "cx-icon,[cxIcon]", inputs: ["cxIcon", "type"] }], directives: [{ type: FocusDirective, selector: "[cxFocus]", inputs: ["cxFocus"] }, { type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PopoverComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-popover',
                    templateUrl: './popover.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: PositioningService }, { type: i1.WindowRef }, { type: i0.ChangeDetectorRef }, { type: i0.Renderer2 }, { type: i1$1.Router }]; }, propDecorators: { baseClass: [{
                type: HostBinding,
                args: ['className']
            }], insideClick: [{
                type: HostListener,
                args: ['click']
            }], outsideClick: [{
                type: HostListener,
                args: ['document:click', ['$event']]
            }], escapeKeydown: [{
                type: HostListener,
                args: ['keydown.escape']
            }] } });

class PopoverService {
    /**
     * For a11y improvements method returns different `FocusConfig`
     * based on which event popover was triggered.
     */
    getFocusConfig(event, appendToBody) {
        let config = {};
        if (event === PopoverEvent.OPEN_BY_KEYBOARD && appendToBody) {
            config = {
                trap: true,
                block: true,
                focusOnEscape: false,
                autofocus: true,
            };
        }
        return config;
    }
    setFocusOnElement(element, focusConfig, appendToBody) {
        if (focusConfig && appendToBody) {
            element.nativeElement.focus();
        }
    }
}
PopoverService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PopoverService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
PopoverService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PopoverService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PopoverService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Directive to bind popover with any DOM element.
 */
class PopoverDirective {
    constructor(element, viewContainer, componentFactoryResolver, renderer, changeDetectorRef, popoverService, winRef) {
        this.element = element;
        this.viewContainer = viewContainer;
        this.componentFactoryResolver = componentFactoryResolver;
        this.renderer = renderer;
        this.changeDetectorRef = changeDetectorRef;
        this.popoverService = popoverService;
        this.winRef = winRef;
        /**
         * An event emitted when the popover is opened.
         */
        this.openPopover = new EventEmitter();
        /**
         * An event emitted when the popover is closed.
         */
        this.closePopover = new EventEmitter();
        /**
         * Subject which emits specific type of `PopoverEvent`.
         */
        this.eventSubject = new Subject();
        this.openTriggerEvents = [
            PopoverEvent.OPEN,
            PopoverEvent.OPEN_BY_KEYBOARD,
        ];
        this.focusPopoverTriggerEvents = [
            PopoverEvent.OPEN_BY_KEYBOARD,
        ];
        this.closeTriggerEvents = [
            PopoverEvent.ROUTE_CHANGE,
            PopoverEvent.ESCAPE_KEYDOWN,
            PopoverEvent.OUTSIDE_CLICK,
            PopoverEvent.CLOSE_BUTTON_KEYDOWN,
            PopoverEvent.CLOSE_BUTTON_CLICK,
        ];
        this.focusDirectiveTriggerEvents = [
            PopoverEvent.ESCAPE_KEYDOWN,
            PopoverEvent.CLOSE_BUTTON_KEYDOWN,
        ];
    }
    /**
     * Listen events fired on element binded to popover directive.
     *
     * Based on event type some a11y improvements can be made.
     * For example if popover was opened by `space` or `enter` key
     * dedicated `FocusConfig` can be set to autofocus first
     * focusable element in popover container.
     */
    handlePress(event) {
        event === null || event === void 0 ? void 0 : event.preventDefault();
        if ((event === null || event === void 0 ? void 0 : event.target) === this.element.nativeElement && !this.isOpen) {
            this.eventSubject.next(PopoverEvent.OPEN_BY_KEYBOARD);
        }
        else if (this.isOpen) {
            this.eventSubject.next(PopoverEvent.CLOSE_BUTTON_KEYDOWN);
        }
    }
    handleTab() {
        var _a;
        if (!((_a = this.focusConfig) === null || _a === void 0 ? void 0 : _a.trap) && this.isOpen) {
            this.eventSubject.next(PopoverEvent.CLOSE_BUTTON_KEYDOWN);
        }
    }
    handleEscape() {
        this.eventSubject.next(PopoverEvent.ESCAPE_KEYDOWN);
    }
    handleClick(event) {
        event === null || event === void 0 ? void 0 : event.preventDefault();
        if ((event === null || event === void 0 ? void 0 : event.target) === this.element.nativeElement && !this.isOpen) {
            this.eventSubject.next(PopoverEvent.OPEN);
        }
        else if (this.isOpen) {
            this.eventSubject.next(PopoverEvent.CLOSE_BUTTON_CLICK);
        }
    }
    /**
     * Method performs open action for popover component.
     */
    open(event) {
        var _a, _b;
        if (!((_a = this.cxPopoverOptions) === null || _a === void 0 ? void 0 : _a.disable)) {
            this.isOpen = true;
            this.focusConfig = this.popoverService.getFocusConfig(event, ((_b = this.cxPopoverOptions) === null || _b === void 0 ? void 0 : _b.appendToBody) || false);
            this.renderPopover();
            this.openPopover.emit();
        }
    }
    /**
     * Method performs close action for popover component.
     */
    close() {
        this.isOpen = false;
        this.viewContainer.clear();
        this.closePopover.emit();
    }
    /**
     * Method subscribes for events emitted by popover component
     * and based on event performs specific action.
     */
    handlePopoverEvents() {
        this.eventSubject.subscribe((event) => {
            var _a;
            if (this.openTriggerEvents.includes(event)) {
                this.open(event);
            }
            if (this.focusPopoverTriggerEvents.includes(event)) {
                this.popoverContainer.location.nativeElement.focus();
            }
            if (this.closeTriggerEvents.includes(event)) {
                this.close();
            }
            if (this.focusDirectiveTriggerEvents.includes(event)) {
                this.popoverService.setFocusOnElement(this.element, this.focusConfig, (_a = this.cxPopoverOptions) === null || _a === void 0 ? void 0 : _a.appendToBody);
            }
        });
    }
    /**
     * Method creates instance and pass parameters to popover component.
     */
    renderPopover() {
        var _a, _b, _c, _d, _e, _f, _g;
        const containerFactory = this.componentFactoryResolver.resolveComponentFactory(PopoverComponent);
        this.popoverContainer =
            this.viewContainer.createComponent(containerFactory);
        const componentInstance = this.popoverContainer.instance;
        if (componentInstance) {
            componentInstance.content = this.cxPopover;
            componentInstance.triggerElement = this.element;
            componentInstance.popoverInstance = this.popoverContainer;
            componentInstance.focusConfig = this.focusConfig;
            componentInstance.eventSubject = this.eventSubject;
            componentInstance.position = (_a = this.cxPopoverOptions) === null || _a === void 0 ? void 0 : _a.placement;
            componentInstance.customClass = (_b = this.cxPopoverOptions) === null || _b === void 0 ? void 0 : _b.class;
            componentInstance.appendToBody = (_c = this.cxPopoverOptions) === null || _c === void 0 ? void 0 : _c.appendToBody;
            componentInstance.positionOnScroll =
                (_d = this.cxPopoverOptions) === null || _d === void 0 ? void 0 : _d.positionOnScroll;
            componentInstance.displayCloseButton =
                (_e = this.cxPopoverOptions) === null || _e === void 0 ? void 0 : _e.displayCloseButton;
            componentInstance.autoPositioning =
                (_f = this.cxPopoverOptions) === null || _f === void 0 ? void 0 : _f.autoPositioning;
            if ((_g = this.cxPopoverOptions) === null || _g === void 0 ? void 0 : _g.appendToBody) {
                this.renderer.appendChild(this.winRef.document.body, this.popoverContainer.location.nativeElement);
            }
            this.popoverContainer.changeDetectorRef.detectChanges();
        }
    }
    ngOnInit() {
        this.handlePopoverEvents();
    }
}
PopoverDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PopoverDirective, deps: [{ token: i0.ElementRef }, { token: i0.ViewContainerRef }, { token: i0.ComponentFactoryResolver }, { token: i0.Renderer2 }, { token: i0.ChangeDetectorRef }, { token: PopoverService }, { token: i1.WindowRef }], target: i0.ɵɵFactoryTarget.Directive });
PopoverDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.5", type: PopoverDirective, selector: "[cxPopover]", inputs: { cxPopover: "cxPopover", cxPopoverOptions: "cxPopoverOptions" }, outputs: { openPopover: "openPopover", closePopover: "closePopover" }, host: { listeners: { "keydown.enter": "handlePress($event)", "keydown.space": "handlePress($event)", "keydown.tab": "handleTab()", "keydown.shift.tab": "handleTab()", "keydown.escape": "handleEscape()", "click": "handleClick($event)" } }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PopoverDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cxPopover]',
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.ViewContainerRef }, { type: i0.ComponentFactoryResolver }, { type: i0.Renderer2 }, { type: i0.ChangeDetectorRef }, { type: PopoverService }, { type: i1.WindowRef }]; }, propDecorators: { cxPopover: [{
                type: Input
            }], cxPopoverOptions: [{
                type: Input
            }], openPopover: [{
                type: Output
            }], closePopover: [{
                type: Output
            }], handlePress: [{
                type: HostListener,
                args: ['keydown.enter', ['$event']]
            }, {
                type: HostListener,
                args: ['keydown.space', ['$event']]
            }], handleTab: [{
                type: HostListener,
                args: ['keydown.tab']
            }, {
                type: HostListener,
                args: ['keydown.shift.tab']
            }], handleEscape: [{
                type: HostListener,
                args: ['keydown.escape']
            }], handleClick: [{
                type: HostListener,
                args: ['click', ['$event']]
            }] } });

const defaultLimit = 20;
class TruncatePipe {
    /**
     * example usage {{ exampleString | cxTruncate: [1, ''] }}
     */
    transform(value, args) {
        if (!args) {
            return value;
        }
        let trail = '...';
        const limit = args.length > 0 && args[0] && Number.isInteger(+args[0])
            ? args[0]
            : defaultLimit;
        if (args.length > 1 && args[1] !== undefined) {
            trail = args[1];
        }
        return value.length > limit ? value.substring(0, limit) + trail : value;
    }
}
TruncatePipe.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: TruncatePipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe });
TruncatePipe.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: TruncatePipe, name: "cxTruncate" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: TruncatePipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'cxTruncate',
                }]
        }] });

class TruncateTextPopoverComponent {
    constructor() {
        /**
         * The maximum length of the characters after which the text will be truncated
         */
        this.charactersLimit = 100;
    }
    get isTruncated() {
        return this.content.length > +this.charactersLimit;
    }
}
TruncateTextPopoverComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: TruncateTextPopoverComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
TruncateTextPopoverComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: TruncateTextPopoverComponent, selector: "cx-truncate-text-popover", inputs: { content: "content", charactersLimit: "charactersLimit" }, ngImport: i0, template: "<ng-container>\n  <ng-container>\n    <span class=\"truncated-text\">\n      {{ content | cxTruncate: [charactersLimit] }}\n    </span>\n  </ng-container>\n\n  <ng-template #fullText>\n    {{ content }}\n  </ng-template>\n\n  <button\n    *ngIf=\"isTruncated\"\n    [cxPopover]=\"fullText\"\n    [cxPopoverOptions]=\"{\n      placement: 'auto',\n      appendToBody: true,\n      displayCloseButton: true\n    }\"\n    class=\"ml-1 link cx-action-link\"\n  >\n    {{ 'common.more' | cxTranslate }}\n  </button>\n</ng-container>\n", directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: PopoverDirective, selector: "[cxPopover]", inputs: ["cxPopover", "cxPopoverOptions"], outputs: ["openPopover", "closePopover"] }], pipes: { "cxTruncate": TruncatePipe, "cxTranslate": i1.TranslatePipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: TruncateTextPopoverComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-truncate-text-popover',
                    templateUrl: './truncate-text-popover.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], propDecorators: { content: [{
                type: Input
            }], charactersLimit: [{
                type: Input
            }] } });

class CardComponent {
    constructor() {
        this.iconTypes = ICON_TYPE;
        this.deleteCard = new EventEmitter();
        this.setDefaultCard = new EventEmitter();
        this.sendCard = new EventEmitter();
        this.editCard = new EventEmitter();
        this.cancelCard = new EventEmitter();
        this.border = false;
        this.editMode = false;
        this.isDefault = false;
        this.fitToContainer = false;
        this.truncateText = false;
        this.charactersLimit = 100;
    }
    // ACTIONS
    setEditMode() {
        this.editMode = true;
    }
    cancelEdit() {
        this.editMode = false;
        this.cancelCard.emit(5);
    }
    delete() {
        this.deleteCard.emit(1);
    }
    setDefault() {
        this.isDefault = true;
        this.setDefaultCard.emit(2);
    }
    send() {
        this.sendCard.emit(3);
    }
    edit() {
        this.editCard.emit(4);
    }
    ngOnInit() { }
}
CardComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CardComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
CardComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: CardComponent, selector: "cx-card", inputs: { border: "border", editMode: "editMode", isDefault: "isDefault", content: "content", fitToContainer: "fitToContainer", truncateText: "truncateText", charactersLimit: "charactersLimit" }, outputs: { deleteCard: "deleteCard", setDefaultCard: "setDefaultCard", sendCard: "sendCard", editCard: "editCard", cancelCard: "cancelCard" }, ngImport: i0, template: "<div\n  *ngIf=\"content\"\n  class=\"cx-card\"\n  [class.cx-card-border]=\"border\"\n  [class.cx-card-fit-to-container]=\"fitToContainer\"\n>\n  <!-- Card Header -->\n  <div *ngIf=\"content.header && !editMode\" class=\"card-header\">\n    {{ content.header }}\n  </div>\n  <!-- Card Body -->\n  <div class=\"card-body cx-card-body\" [class.cx-card-delete]=\"editMode\">\n    <!-- Edit message -->\n    <div *ngIf=\"editMode\" class=\"cx-card-delete-msg\">\n      {{ content.deleteMsg }}\n    </div>\n    <!-- Card title -->\n    <h3 *ngIf=\"content.title\" class=\"cx-card-title\">\n      {{ content.title }}\n    </h3>\n    <!-- Card Content -->\n    <div class=\"cx-card-container\">\n      <!-- Card Label -->\n      <div class=\"cx-card-label-container\">\n        <div *ngIf=\"content.textBold\" class=\"cx-card-label-bold\">\n          {{ content.textBold }}\n        </div>\n        <div *ngFor=\"let line of content.text\">\n          <div *ngIf=\"!truncateText; else truncate\" class=\"cx-card-label\">\n            {{ line }}\n          </div>\n\n          <ng-template #truncate>\n            <cx-truncate-text-popover\n              [charactersLimit]=\"charactersLimit\"\n              [content]=\"line\"\n            ></cx-truncate-text-popover>\n          </ng-template>\n        </div>\n        <div class=\"cx-card-paragraph\" *ngFor=\"let item of content.paragraphs\">\n          <div class=\"cx-card-paragraph-title\">{{ item.title }}</div>\n          <div *ngFor=\"let text of item.text\">\n            <div class=\"cx-card-paragraph-text\">\n              {{ text }}\n            </div>\n          </div>\n        </div>\n      </div>\n      <!-- Image -->\n      <div *ngIf=\"content.img\" class=\"cx-card-img-container\">\n        <cx-icon [type]=\"content.img\"></cx-icon>\n      </div>\n    </div>\n    <!-- Edit Mode Actions -->\n    <div *ngIf=\"editMode\" class=\"row cx-card-body-delete\">\n      <div class=\"col-md-6\">\n        <button class=\"btn btn-block btn-secondary\" (click)=\"cancelEdit()\">\n          {{ 'common.cancel' | cxTranslate }}\n        </button>\n      </div>\n      <div class=\"col-md-6\">\n        <button class=\"btn btn-block btn-primary\" (click)=\"delete()\">\n          {{ 'common.delete' | cxTranslate }}\n        </button>\n      </div>\n    </div>\n    <!-- Actions -->\n    <div *ngIf=\"content.actions && !editMode\" class=\"cx-card-actions\">\n      <div *ngFor=\"let action of content.actions\">\n        <div [ngSwitch]=\"action.event\">\n          <a\n            *ngSwitchCase=\"'delete'\"\n            class=\"cx-card-link card-link btn-link cx-action-link\"\n            (click)=\"delete()\"\n            (keydown.enter)=\"delete()\"\n            tabindex=\"0\"\n            >{{ action.name }}</a\n          >\n          <a\n            *ngSwitchCase=\"'default'\"\n            class=\"cx-card-link card-link btn-link cx-action-link\"\n            (click)=\"setDefault()\"\n            (keydown.enter)=\"setDefault()\"\n            tabindex=\"0\"\n            >{{ action.name }}</a\n          >\n          <a\n            *ngSwitchCase=\"'send'\"\n            class=\"cx-card-link card-link btn-link cx-action-link\"\n            (click)=\"send()\"\n            (keydown.enter)=\"send()\"\n            tabindex=\"0\"\n            >{{ action.name }}</a\n          >\n          <a\n            *ngSwitchCase=\"'edit'\"\n            class=\"cx-card-link card-link btn-link cx-action-link\"\n            (click)=\"edit()\"\n            (keydown.enter)=\"edit()\"\n            tabindex=\"0\"\n            >{{ action.name }}</a\n          >\n          <a\n            *ngSwitchDefault\n            href=\"{{ action.link }}\"\n            class=\"card-link btn-link cx-action-link\"\n            tabindex=\"0\"\n            >{{ action.name }}</a\n          >\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n", components: [{ type: TruncateTextPopoverComponent, selector: "cx-truncate-text-popover", inputs: ["content", "charactersLimit"] }, { type: IconComponent, selector: "cx-icon,[cxIcon]", inputs: ["cxIcon", "type"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i3.NgSwitch, selector: "[ngSwitch]", inputs: ["ngSwitch"] }, { type: i3.NgSwitchCase, selector: "[ngSwitchCase]", inputs: ["ngSwitchCase"] }, { type: i3.NgSwitchDefault, selector: "[ngSwitchDefault]" }], pipes: { "cxTranslate": i1.TranslatePipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CardComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-card',
                    templateUrl: './card.component.html',
                }]
        }], ctorParameters: function () { return []; }, propDecorators: { deleteCard: [{
                type: Output
            }], setDefaultCard: [{
                type: Output
            }], sendCard: [{
                type: Output
            }], editCard: [{
                type: Output
            }], cancelCard: [{
                type: Output
            }], border: [{
                type: Input
            }], editMode: [{
                type: Input
            }], isDefault: [{
                type: Input
            }], content: [{
                type: Input
            }], fitToContainer: [{
                type: Input
            }], truncateText: [{
                type: Input
            }], charactersLimit: [{
                type: Input
            }] } });

class PopoverModule {
}
PopoverModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PopoverModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
PopoverModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PopoverModule, declarations: [PopoverDirective, PopoverComponent], imports: [CommonModule, RouterModule, KeyboardFocusModule, IconModule], exports: [PopoverDirective, PopoverComponent] });
PopoverModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PopoverModule, imports: [[CommonModule, RouterModule, KeyboardFocusModule, IconModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PopoverModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, RouterModule, KeyboardFocusModule, IconModule],
                    declarations: [PopoverDirective, PopoverComponent],
                    exports: [PopoverDirective, PopoverComponent],
                }]
        }] });

class TruncateTextPopoverModule {
}
TruncateTextPopoverModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: TruncateTextPopoverModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
TruncateTextPopoverModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: TruncateTextPopoverModule, declarations: [TruncateTextPopoverComponent, TruncatePipe], imports: [CommonModule, I18nModule, PopoverModule], exports: [TruncateTextPopoverComponent, TruncatePipe] });
TruncateTextPopoverModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: TruncateTextPopoverModule, imports: [[CommonModule, I18nModule, PopoverModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: TruncateTextPopoverModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, I18nModule, PopoverModule],
                    declarations: [TruncateTextPopoverComponent, TruncatePipe],
                    exports: [TruncateTextPopoverComponent, TruncatePipe],
                }]
        }] });

class CardModule {
}
CardModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CardModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
CardModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CardModule, declarations: [CardComponent], imports: [CommonModule, I18nModule, IconModule, TruncateTextPopoverModule], exports: [CardComponent] });
CardModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CardModule, imports: [[CommonModule, I18nModule, IconModule, TruncateTextPopoverModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CardModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, I18nModule, IconModule, TruncateTextPopoverModule],
                    declarations: [CardComponent],
                    exports: [CardComponent],
                }]
        }] });

class CarouselService {
    constructor(winRef) {
        this.winRef = winRef;
    }
    /**
     * The number of items per slide is calculated by the help of
     * the item width and the available width of the host element.
     * This appoach makes it possible to place the carousel in different
     * layouts. Instead of using the page breakpoints, the host size is
     * taken into account.
     *
     * Since there's no element resize API available, we use the
     * window `resize` event, so that we can adjust the number of items
     * whenever the window got resized.
     */
    getItemsPerSlide(nativeElement, itemWidth) {
        return this.winRef.resize$.pipe(map(() => nativeElement.clientWidth), map((totalWidth) => this.calculateItems(totalWidth, itemWidth)));
    }
    /**
     * Calculates the number of items per given hostSize.  calculated based on the given
     * intended size in pixels or percentages. The
     *
     * @param availableWidth The available width in pixels for the carousel items.
     * @param itemWidth The width per carousel item, in px or percentage.
     */
    calculateItems(availableWidth, itemWidth) {
        let calculatedItems = 0;
        if (itemWidth.endsWith('px')) {
            const num = itemWidth.substring(0, itemWidth.length - 2);
            calculatedItems = availableWidth / num;
        }
        if (itemWidth.endsWith('%')) {
            const perc = itemWidth.substring(0, itemWidth.length - 1);
            calculatedItems =
                availableWidth / (availableWidth * (perc / 100));
        }
        return Math.floor(calculatedItems) || 1;
    }
}
CarouselService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CarouselService, deps: [{ token: i1.WindowRef }], target: i0.ɵɵFactoryTarget.Injectable });
CarouselService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CarouselService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CarouselService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.WindowRef }]; } });

/**
 * Generic carousel component that can be used to render any carousel items,
 * such as products, images, banners, or any component. Carousel items are
 * rendered in so-called carousel slides, and the previous/next buttons as well as
 * the indicator-buttons can used to navigate the slides.
 *
 * The component uses an array of Observables (`items$`) as an input, to allow
 * for lazy loading of items.
 *
 * The number of items per slide is calculated with the `itemWidth`, which can given
 * in pixels or percentage.
 *
 * To allow for flexible rendering of items, the rendering is delegated to the
 * given `template`. This allows for maximum flexibility.
 */
class CarouselComponent {
    constructor(el, service) {
        this.el = el;
        this.service = service;
        /**
         * Specifies the minimum size of the carousel item, either in px or %.
         * This value is used for the calculation of numbers per carousel, so that
         * the number of carousel items is dynamic. The calculation uses the `itemWidth`
         * and the host element `clientWidth`, so that the carousel is reusable in
         * different layouts (for example in a 50% grid).
         */
        this.itemWidth = '300px';
        /**
         * Indicates whether the visual indicators are used.
         */
        this.hideIndicators = false;
        this.indicatorIcon = ICON_TYPE.CIRCLE;
        this.previousIcon = ICON_TYPE.CARET_LEFT;
        this.nextIcon = ICON_TYPE.CARET_RIGHT;
    }
    set setItems(inputItems) {
        this.items = inputItems;
        //Reset slider when changing products
        this.activeSlide = 0;
    }
    ngOnInit() {
        if (!this.template && isDevMode()) {
            console.error('No template reference provided to render the carousel items for the `cx-carousel`');
            return;
        }
        this.size$ = this.service
            .getItemsPerSlide(this.el.nativeElement, this.itemWidth)
            .pipe(tap(() => (this.activeSlide = 0)));
    }
    getSlideNumber(size, currentIndex) {
        let normalizedCurrentIndex = currentIndex + 1;
        return Math.ceil(normalizedCurrentIndex / size);
    }
}
CarouselComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CarouselComponent, deps: [{ token: i0.ElementRef }, { token: CarouselService }], target: i0.ɵɵFactoryTarget.Component });
CarouselComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: CarouselComponent, selector: "cx-carousel", inputs: { title: "title", setItems: ["items", "setItems"], template: "template", itemWidth: "itemWidth", hideIndicators: "hideIndicators", indicatorIcon: "indicatorIcon", previousIcon: "previousIcon", nextIcon: "nextIcon" }, ngImport: i0, template: "<ng-container *ngIf=\"items?.length > 0 && (size$ | async) as size\">\n  <h2 *ngIf=\"title\">{{ title }}</h2>\n\n  <div class=\"carousel-panel\" [ngClass]=\"'size-' + size\">\n    <button\n      *ngIf=\"size < items.length\"\n      class=\"previous\"\n      (click)=\"activeSlide = activeSlide - size\"\n      [disabled]=\"activeSlide === 0\"\n      [attr.aria-label]=\"'carousel.previousSlide' | cxTranslate\"\n    >\n      <cx-icon [type]=\"previousIcon\"></cx-icon>\n    </button>\n\n    <div class=\"slides\">\n      <ng-container *ngFor=\"let _ of items; let i = index\">\n        <div\n          class=\"slide\"\n          *ngIf=\"i % size === 0\"\n          [class.active]=\"i === activeSlide\"\n        >\n          <ng-container\n            *ngFor=\"let item of items | slice: i:i + size; let j = index\"\n          >\n            <div\n              *ngIf=\"item | async as data\"\n              class=\"item\"\n              [class.active]=\"i === activeSlide\"\n            >\n              <ng-container\n                *ngTemplateOutlet=\"template; context: { item: data }\"\n              ></ng-container>\n            </div>\n          </ng-container>\n        </div>\n      </ng-container>\n    </div>\n\n    <button\n      *ngIf=\"size < items.length\"\n      class=\"next\"\n      (click)=\"activeSlide = activeSlide + size\"\n      tabindex=\"-1\"\n      [disabled]=\"activeSlide > items.length - size - 1\"\n      [attr.aria-label]=\"'carousel.nextSlide' | cxTranslate\"\n    >\n      <cx-icon [type]=\"nextIcon\"></cx-icon>\n    </button>\n  </div>\n\n  <div *ngIf=\"!hideIndicators && size < items.length\" class=\"indicators\">\n    <ng-container *ngFor=\"let _ of items; let i = index\">\n      <button\n        *ngIf=\"i % size === 0\"\n        (focus)=\"activeSlide = i\"\n        [disabled]=\"i === activeSlide\"\n        [attr.aria-label]=\"\n          'carousel.slideNumber'\n            | cxTranslate: { currentSlideNumber: getSlideNumber(size, i) }\n        \"\n        tabindex=\"-1\"\n      >\n        <cx-icon [type]=\"indicatorIcon\" aria-hidden=\"true\"></cx-icon>\n      </button>\n    </ng-container>\n  </div>\n</ng-container>\n", components: [{ type: IconComponent, selector: "cx-icon,[cxIcon]", inputs: ["cxIcon", "type"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i3.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }], pipes: { "async": i3.AsyncPipe, "cxTranslate": i1.TranslatePipe, "slice": i3.SlicePipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CarouselComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-carousel',
                    templateUrl: './carousel.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: CarouselService }]; }, propDecorators: { title: [{
                type: Input
            }], setItems: [{
                type: Input,
                args: ['items']
            }], template: [{
                type: Input
            }], itemWidth: [{
                type: Input
            }], hideIndicators: [{
                type: Input
            }], indicatorIcon: [{
                type: Input
            }], previousIcon: [{
                type: Input
            }], nextIcon: [{
                type: Input
            }] } });

class MediaModule {
    static forRoot() {
        return {
            ngModule: MediaModule,
        };
    }
}
MediaModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: MediaModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
MediaModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: MediaModule, declarations: [MediaComponent], imports: [CommonModule], exports: [MediaComponent] });
MediaModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: MediaModule, imports: [[CommonModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: MediaModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [MediaComponent],
                    exports: [MediaComponent],
                }]
        }] });

class CarouselModule {
}
CarouselModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CarouselModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
CarouselModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CarouselModule, declarations: [CarouselComponent], imports: [CommonModule,
        RouterModule,
        IconModule,
        MediaModule,
        UrlModule,
        I18nModule], exports: [CarouselComponent] });
CarouselModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CarouselModule, imports: [[
            CommonModule,
            RouterModule,
            IconModule,
            MediaModule,
            UrlModule,
            I18nModule,
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CarouselModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        RouterModule,
                        IconModule,
                        MediaModule,
                        UrlModule,
                        I18nModule,
                    ],
                    declarations: [CarouselComponent],
                    exports: [CarouselComponent],
                }]
        }] });

/**
 * Service that provides the placeholder and input pattern for date pickers. This is
 * used in Spartacus to support browser that won't support the native html5 date picker
 * using `<input type="date">`.
 *
 * While the placeholder is configurable, you should be aware that the placeholder format
 * defaults to `yyyy-mm-dd` to align with Safaris limited support of ISO 8601.
 * Another consideration is the support of date formats in the backend. In case you change
 * this format, you might need to serialize the date to the supported date format in the
 * backend.
 *
 */
class DatePickerService {
    get placeholder() {
        return 'yyyy-mm-dd';
    }
    /**
     * The default date pattern is based on the placeholder string;
     */
    get pattern() {
        return this.placeholder
            .replace('yyyy', '\\d{4}')
            .replace('mm', '\\d{1,2}')
            .replace('dd', '\\d{1,2}');
    }
    /**
     * Validates if the string based date value is a valid date.
     */
    isValidFormat(date, pattern) {
        const patternRegex = new RegExp(`^${pattern !== null && pattern !== void 0 ? pattern : this.pattern}$`);
        return patternRegex.test(date);
    }
    /**
     * Since Safari doesn't support proper date formats (ISO 8601), we need to do this
     * ourselves. We cannot rely on `new Date('2020-1-1')`. This will fail, only
     * `new Date('2020-01-01')` works.
     */
    getDate(value) {
        if (!value) {
            return;
        }
        const delimiter = this.placeholder
            .replace('yyyy', '')
            .replace('mm', '')
            .replace('dd', '')
            .substr(0, 1);
        const dateParts = value.split(delimiter);
        const placeholderParts = this.placeholder.split(delimiter);
        const y = placeholderParts.indexOf('yyyy');
        const m = placeholderParts.indexOf('mm');
        const d = placeholderParts.indexOf('dd');
        return new Date(Number(dateParts[y]), Number(dateParts[m]) - 1, Number(dateParts[d]));
    }
}
DatePickerService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: DatePickerService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
DatePickerService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: DatePickerService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: DatePickerService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Renders translated form errors for a given form control, based on its `errors` property.
 *
 * The translation key consists of the optional input `prefix`
 * concatenated with the error key.
 *
 * And the translation params object consist of the error details
 * (if only it's an object) merged with the optional input object `translationParams`.
 */
class FormErrorsComponent {
    constructor() {
        /**
         * Prefix prepended to the translation key.
         */
        this.prefix = 'formErrors';
    }
    set control(control) {
        this._control = control;
        this.errorsDetails$ = control === null || control === void 0 ? void 0 : control.statusChanges.pipe(startWith({}), map(() => control.errors || {}), map((errors) => Object.entries(errors).filter(([_key, details]) => details)));
        this.errors$ = this.errorsDetails$.pipe(map((errors) => errors.map(([key, _details]) => key)));
    }
    get control() {
        return this._control;
    }
    /**
     * Returns translation params composed of
     * the argument `errorDetails` (if only is an object) merged with
     * the component input object `translationParams`.
     *
     * In case of a conflicting object key, the value from
     * `translationParams` takes precedence.
     */
    getTranslationParams(errorDetails) {
        errorDetails = isObject(errorDetails) ? errorDetails : {};
        return Object.assign(Object.assign({}, errorDetails), this.translationParams);
    }
    get invalid() {
        var _a;
        return (_a = this.control) === null || _a === void 0 ? void 0 : _a.invalid;
    }
    get dirty() {
        var _a;
        return (_a = this.control) === null || _a === void 0 ? void 0 : _a.dirty;
    }
    get touched() {
        var _a;
        return (_a = this.control) === null || _a === void 0 ? void 0 : _a.touched;
    }
}
FormErrorsComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: FormErrorsComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
FormErrorsComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: FormErrorsComponent, selector: "cx-form-errors", inputs: { prefix: "prefix", translationParams: "translationParams", control: "control" }, host: { properties: { "class.control-invalid": "this.invalid", "class.control-dirty": "this.dirty", "class.control-touched": "this.touched" } }, ngImport: i0, template: "<p *ngFor=\"let error of errorsDetails$ | async\">\n  {{ prefix + '.' + error[0] | cxTranslate: getTranslationParams(error[1]) }}\n</p>\n", directives: [{ type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], pipes: { "async": i3.AsyncPipe, "cxTranslate": i1.TranslatePipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: FormErrorsComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-form-errors',
                    templateUrl: './form-errors.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], propDecorators: { prefix: [{
                type: Input
            }], translationParams: [{
                type: Input
            }], control: [{
                type: Input
            }], invalid: [{
                type: HostBinding,
                args: ['class.control-invalid']
            }], dirty: [{
                type: HostBinding,
                args: ['class.control-dirty']
            }], touched: [{
                type: HostBinding,
                args: ['class.control-touched']
            }] } });

/**
 * Component that adds a date control. While the native date picker works in most
 * modern browsers, some browsers need more guidance (placeholder), validation and
 * date conversion.
 *
 * The data picker supports (optional) min and max form controls, so that you can
 * limit the start and/or end date.
 *
 * Most of the implementation is done in the `DatePickerFallbackDirective`.
 */
class DatePickerComponent {
    constructor(service) {
        this.service = service;
        this.update = new EventEmitter();
    }
    change() {
        this.update.emit();
    }
    get placeholder() {
        return this.service.placeholder;
    }
    get pattern() {
        return this.service.pattern;
    }
    /**
     * Only returns the date if we have a valid format. We do this to avoid
     * loads of console errors coming from the datePipe while the user is typing
     * (in those browsers where the date picker isn't supported).
     */
    getDate(date) {
        return this.service.isValidFormat(date) ? date : null;
    }
}
DatePickerComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: DatePickerComponent, deps: [{ token: DatePickerService }], target: i0.ɵɵFactoryTarget.Component });
DatePickerComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: DatePickerComponent, selector: "cx-date-picker", inputs: { control: "control", min: "min", max: "max" }, outputs: { update: "update" }, ngImport: i0, template: "<input\n  class=\"form-control\"\n  type=\"date\"\n  [formControl]=\"control\"\n  [attr.min]=\"min\"\n  [attr.max]=\"max\"\n  (change)=\"change()\"\n  [placeholder]=\"placeholder\"\n  [pattern]=\"pattern\"\n/>\n<cx-form-errors\n  aria-live=\"assertive\"\n  aria-atomic=\"true\"\n  [control]=\"control\"\n  prefix=\"formErrors.date\"\n  [translationParams]=\"{\n    max: getDate(max) | cxDate,\n    min: getDate(min) | cxDate\n  }\"\n></cx-form-errors>\n", components: [{ type: FormErrorsComponent, selector: "cx-form-errors", inputs: ["prefix", "translationParams", "control"] }], directives: [{ type: i3$1.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { type: i3$1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i3$1.FormControlDirective, selector: "[formControl]", inputs: ["disabled", "formControl", "ngModel"], outputs: ["ngModelChange"], exportAs: ["ngForm"] }, { type: i3$1.PatternValidator, selector: "[pattern][formControlName],[pattern][formControl],[pattern][ngModel]", inputs: ["pattern"] }], pipes: { "cxDate": i1.CxDatePipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: DatePickerComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-date-picker',
                    templateUrl: './date-picker.component.html',
                    // we cannot use onPush change detection as the form state isn't updated without explicit
                    // change detection, see https://github.com/angular/angular/issues/10816
                }]
        }], ctorParameters: function () { return [{ type: DatePickerService }]; }, propDecorators: { control: [{
                type: Input
            }], min: [{
                type: Input
            }], max: [{
                type: Input
            }], update: [{
                type: Output
            }] } });

class FormErrorsModule {
}
FormErrorsModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: FormErrorsModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
FormErrorsModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: FormErrorsModule, declarations: [FormErrorsComponent], imports: [CommonModule, I18nModule], exports: [FormErrorsComponent] });
FormErrorsModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: FormErrorsModule, imports: [[CommonModule, I18nModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: FormErrorsModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, I18nModule],
                    declarations: [FormErrorsComponent],
                    exports: [FormErrorsComponent],
                }]
        }] });

class DatePickerModule {
}
DatePickerModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: DatePickerModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
DatePickerModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: DatePickerModule, declarations: [DatePickerComponent], imports: [CommonModule, ReactiveFormsModule, FormErrorsModule, I18nModule], exports: [DatePickerComponent] });
DatePickerModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: DatePickerModule, imports: [[CommonModule, ReactiveFormsModule, FormErrorsModule, I18nModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: DatePickerModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, ReactiveFormsModule, FormErrorsModule, I18nModule],
                    declarations: [DatePickerComponent],
                    exports: [DatePickerComponent],
                }]
        }] });

/**
 * Component that adds a file upload control.
 */
class FileUploadComponent {
    constructor() {
        /**
         * Allowed file types. It's setting attribute used for OS window for choosing files.
         */
        this.accept = '*';
        /**
         * Allows selecting multiple files.
         */
        this.multiple = false;
        // TODO: remove this event. Now it's used only to trigger some logic in the parent component.
        // Prerequisites (changes in the parent component):
        // - use an async validator that "opens file" using the value of the form control
        // - "open file" on form submit, but not on the form control change
        this.update = new EventEmitter();
        // ControlValueAccessor START
        this.onChangeCallback = () => { };
        this.onTouchedCallback = () => { };
    }
    selectFile($event) {
        var _a;
        const files = (_a = $event.target) === null || _a === void 0 ? void 0 : _a.files;
        this.onChangeCallback(files);
        this.update.emit(files);
    }
    get selectedFiles() {
        return Array.from(this.fileInput.nativeElement.files);
    }
    registerOnChange(callback) {
        this.onChangeCallback = callback;
    }
    registerOnTouched(callback) {
        this.onTouchedCallback = callback;
    }
    setDisabledState(disabled) {
        this.fileInput.nativeElement.disabled = disabled;
    }
    writeValue(value) {
        if (value instanceof FileList) {
            this.fileInput.nativeElement.files = value;
        }
    }
}
FileUploadComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: FileUploadComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
FileUploadComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: FileUploadComponent, selector: "cx-file-upload", inputs: { accept: "accept", multiple: "multiple" }, outputs: { update: "update" }, providers: [
        {
            provide: NG_VALUE_ACCESSOR,
            useExisting: forwardRef(() => FileUploadComponent),
            multi: true,
        },
    ], viewQueries: [{ propertyName: "fileInput", first: true, predicate: ["fileInput"], descendants: true, static: true }], ngImport: i0, template: "<input\n  type=\"file\"\n  aria-hidden=\"true\"\n  [accept]=\"accept\"\n  [multiple]=\"multiple\"\n  (change)=\"selectFile($event)\"\n  #fileInput\n/>\n<button\n  [attr.aria-label]=\"'common.selectFile' | cxTranslate\"\n  class=\"btn btn-action\"\n  type=\"button\"\n  (click)=\"fileInput.click()\"\n>\n  <ng-content></ng-content>\n</button>\n<p *ngFor=\"let file of selectedFiles\">\n  {{ file?.name }}\n</p>\n", directives: [{ type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], pipes: { "cxTranslate": i1.TranslatePipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: FileUploadComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-file-upload',
                    templateUrl: './file-upload.component.html',
                    providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: forwardRef(() => FileUploadComponent),
                            multi: true,
                        },
                    ],
                    // we cannot use onPush change detection as the form state isn't updated without explicit
                    // change detection, see https://github.com/angular/angular/issues/10816
                }]
        }], propDecorators: { accept: [{
                type: Input
            }], multiple: [{
                type: Input
            }], update: [{
                type: Output
            }], fileInput: [{
                type: ViewChild,
                args: ['fileInput', { static: true }]
            }] } });

class FileUploadModule {
}
FileUploadModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: FileUploadModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
FileUploadModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: FileUploadModule, declarations: [FileUploadComponent], imports: [CommonModule, ReactiveFormsModule, FormErrorsModule, I18nModule], exports: [FileUploadComponent] });
FileUploadModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: FileUploadModule, imports: [[CommonModule, ReactiveFormsModule, FormErrorsModule, I18nModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: FileUploadModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, ReactiveFormsModule, FormErrorsModule, I18nModule],
                    declarations: [FileUploadComponent],
                    exports: [FileUploadComponent],
                }]
        }] });

class GenericLinkComponentService {
    constructor() {
        /**
         * Pattern matching string starting with `http://` or `https://`.
         */
        this.HTTP_PROTOCOL_REGEX = /^https?:\/\//i;
        /**
         * Pattern matching string starting with `mailto:`.
         */
        this.MAILTO_PROTOCOL_REGEX = /^mailto:/i;
        /**
         * Pattern matching string starting with `tel:`.
         */
        this.TEL_PROTOCOL_REGEX = /^tel:/i;
    }
    /**
     * Returns true when the @Input `url` is a string starting with `http://`, `https://`, `mailto:`, `tel:`.
     */
    isExternalUrl(url) {
        return (typeof url === 'string' &&
            (this.HTTP_PROTOCOL_REGEX.test(url) ||
                this.MAILTO_PROTOCOL_REGEX.test(url) ||
                this.TEL_PROTOCOL_REGEX.test(url)));
    }
}
GenericLinkComponentService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: GenericLinkComponentService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
GenericLinkComponentService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: GenericLinkComponentService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: GenericLinkComponentService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * This component navigates using [routerLink] attribute when input 'url' is a relative url. Otherwise (when it's absolute), [href] is used.
 */
class GenericLinkComponent {
    constructor(router, service) {
        this.router = router;
        this.service = service;
        /**
         * Pattern matching string starting with `http://` or `https://`.
         */
        this.PROTOCOL_REGEX = /^https?:\/\//i;
        /**
         * Pattern matching string starting with `mailto:`.
         */
        this.MAILTO_PROTOCOL_REGEX = /^mailto:/i;
        /**
         * Pattern matching string starting with `tel:`.
         */
        this.TEL_PROTOCOL_REGEX = /^tel:/i;
        /**
         * Used to split url into 2 parts:
         * 1. the path
         * 2. query params + hash fragment
         */
        this.URL_SPLIT = /(^[^#?]*)(.*)/;
        /**
         * Parsed parts of the @Input `url`, when it's a local URL.
         * It should not be used when the `url` is external.
         * @see `url`
         */
        this.routeParts = {};
    }
    isExternalUrl() {
        var _a;
        return (((_a = this.service) === null || _a === void 0 ? void 0 : _a.isExternalUrl(this.url)) ||
            (typeof this.url === 'string' &&
                (this.PROTOCOL_REGEX.test(this.url) ||
                    this.MAILTO_PROTOCOL_REGEX.test(this.url) ||
                    this.TEL_PROTOCOL_REGEX.test(this.url))));
    }
    get rel() {
        return this.target === '_blank' ? 'noopener' : null;
    }
    ngOnChanges(changes) {
        if (changes['url']) {
            this.setUrlParts(changes['url'].currentValue);
        }
    }
    /**
     * The part with the path of the local url.
     */
    get routerUrl() {
        return this.routeParts.path;
    }
    /**
     * The part with the query params of the local url.
     */
    get queryParams() {
        return this.routeParts.queryParams;
    }
    /**
     * The part with the hash fragment of the local url.
     */
    get fragment() {
        return this.routeParts.fragment;
    }
    /**
     * Parses the given url and sets the property `urlParts` accordingly.
     */
    setUrlParts(url) {
        if (typeof url === 'string') {
            url = this.getAbsoluteUrl(url); // string links in CMS sometimes don't have the leading slash, so fix it here
            this.routeParts = this.splitUrl(url);
        }
        else {
            this.routeParts = { path: url };
        }
    }
    /**
     * Parses the given string into 3 parts:
     * - string path (wrapped in an array to be compatible with Angular syntax for the `routerLink`)
     * - query params (as an object)
     * - hash fragment (string)
     */
    splitUrl(url = '') {
        const { queryParams, fragment } = this.router.parseUrl(url);
        const [, path] = url.match(this.URL_SPLIT);
        // wrap path in an array, to have the Angular-like path format
        return { path: [path], queryParams, fragment };
    }
    /**
     * Prepends a leading slash to the given URL string, in case it doesn't have it.
     */
    getAbsoluteUrl(url) {
        return url.startsWith('/') ? url : '/' + url;
    }
}
GenericLinkComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: GenericLinkComponent, deps: [{ token: i1$1.Router }, { token: GenericLinkComponentService }], target: i0.ɵɵFactoryTarget.Component });
GenericLinkComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: GenericLinkComponent, selector: "cx-generic-link", inputs: { url: "url", target: "target", id: "id", class: "class", style: "style", title: "title" }, usesOnChanges: true, ngImport: i0, template: "<!-- https://github.com/angular/angular/issues/24567 -->\n\n<ng-container *ngIf=\"isExternalUrl(); else isLocalUrl\">\n  <a\n    [href]=\"url\"\n    [attr.target]=\"target\"\n    [attr.rel]=\"rel\"\n    [attr.id]=\"id\"\n    [attr.class]=\"class\"\n    [attr.style]=\"style\"\n    [attr.title]=\"title\"\n  >\n    <ng-container *ngTemplateOutlet=\"content\"></ng-container>\n  </a>\n</ng-container>\n\n<ng-template #isLocalUrl>\n  <a\n    [routerLink]=\"routerUrl\"\n    [queryParams]=\"queryParams\"\n    [fragment]=\"fragment\"\n    [target]=\"target\"\n    [attr.id]=\"id\"\n    [attr.class]=\"class\"\n    [attr.style]=\"style\"\n    [attr.title]=\"title\"\n  >\n    <ng-container *ngTemplateOutlet=\"content\"></ng-container>\n  </a>\n</ng-template>\n\n<ng-template #content>\n  <ng-content></ng-content>\n</ng-template>\n", directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }, { type: i1$1.RouterLinkWithHref, selector: "a[routerLink],area[routerLink]", inputs: ["routerLink", "target", "queryParams", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange", "replaceUrl", "state", "relativeTo"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: GenericLinkComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-generic-link',
                    templateUrl: './generic-link.component.html',
                }]
        }], ctorParameters: function () { return [{ type: i1$1.Router }, { type: GenericLinkComponentService }]; }, propDecorators: { url: [{
                type: Input
            }], target: [{
                type: Input
            }], id: [{
                type: Input
            }], class: [{
                type: Input
            }], style: [{
                type: Input
            }], title: [{
                type: Input
            }] } });

class GenericLinkModule {
}
GenericLinkModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: GenericLinkModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
GenericLinkModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: GenericLinkModule, declarations: [GenericLinkComponent], imports: [CommonModule, RouterModule], exports: [GenericLinkComponent] });
GenericLinkModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: GenericLinkModule, imports: [[CommonModule, RouterModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: GenericLinkModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, RouterModule],
                    declarations: [GenericLinkComponent],
                    exports: [GenericLinkComponent],
                }]
        }] });

class ItemCounterModule {
}
ItemCounterModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ItemCounterModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ItemCounterModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ItemCounterModule, declarations: [ItemCounterComponent], imports: [CommonModule, ReactiveFormsModule, I18nModule], exports: [ItemCounterComponent] });
ItemCounterModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ItemCounterModule, imports: [[CommonModule, ReactiveFormsModule, I18nModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ItemCounterModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, ReactiveFormsModule, I18nModule],
                    declarations: [ItemCounterComponent],
                    exports: [ItemCounterComponent],
                }]
        }] });

const defaultPaginationConfig = {
    pagination: {
        addStart: true,
        addEnd: true,
    },
};

class PaginationConfig {
}
PaginationConfig.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PaginationConfig, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
PaginationConfig.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PaginationConfig, providedIn: 'root', useExisting: Config });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PaginationConfig, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                    useExisting: Config,
                }]
        }] });

/**
 * The item type is used to add semantic structure to the
 * PaginationItem, so that the UI understands the usage.
 */
var PaginationItemType;
(function (PaginationItemType) {
    PaginationItemType["GAP"] = "gap";
    PaginationItemType["FIRST"] = "first";
    PaginationItemType["LAST"] = "last";
    PaginationItemType["PREVIOUS"] = "previous";
    PaginationItemType["NEXT"] = "next";
    PaginationItemType["START"] = "start";
    PaginationItemType["END"] = "end";
    PaginationItemType["PAGE"] = "page";
})(PaginationItemType || (PaginationItemType = {}));
var PaginationNavigationPosition;
(function (PaginationNavigationPosition) {
    PaginationNavigationPosition["ASIDE"] = "aside";
    PaginationNavigationPosition["BEFORE"] = "before";
    PaginationNavigationPosition["AFTER"] = "after";
})(PaginationNavigationPosition || (PaginationNavigationPosition = {}));

const FALLBACK_PAGINATION_OPTIONS = {
    rangeCount: 3,
    dotsLabel: '...',
    startLabel: '«',
    previousLabel: '‹',
    nextLabel: '›',
    endLabel: '»',
};
/**
 * Builds a pagination structures based on a pageCount and current page number.
 * There are various {@link PaginationConfig} options which can be used to configure
 * the behavior of the build. Alternatively, CSS can be used to further customize
 * the pagination.
 *
 * Examples:
 * The full blown pagination items contain the follow elements:
 *
 * `« ‹ 1 ... 4 (5) 6 ... 9 › »`
 *
 * This includes pagination items to the following pages:
 * - start page
 * - previous page
 * - first page
 * - page range
 * - last page
 * - next page
 * - end page
 *
 * All of those links are configurable, including the size of the page range.
 * The current page will always be centered in the page range to provide direct access
 * to the previous and next page.
 */
class PaginationBuilder {
    constructor(paginationConfig) {
        this.paginationConfig = paginationConfig;
    }
    /**
     * Builds a list of `PaginationItem`. The give pageCount and current are used
     * to build out the full pagination. There are various {@link PaginationConfig} options
     * which can be used to configure the behavior of the build. Alternatively, CSS
     * can be used to further specialize visibility of the pagination.
     *
     * @param pageCount The total number of pages
     * @param current The current page number, 0-index based
     * @returns An array of `PaginationItem`
     */
    paginate(pageCount, current) {
        const pages = [];
        if (!pageCount || pageCount < 2) {
            return pages;
        }
        this.addPages(pages, pageCount, current);
        this.addDots(pages, pageCount);
        this.addFirstLast(pages, pageCount);
        this.addNavigation(pages, pageCount, current);
        return pages;
    }
    /**
     * Returns the current page with surrounding pages (based on the `config.rangeCount`).
     * The current page is always centered to provide direct access to the previous and next page.
     *
     * @param pages The list of page items that is used to amend
     * @param pageCount The total number of pages
     * @param current The current page number, 0-index based
     */
    addPages(pages, pageCount, current) {
        const start = this.getStartOfRange(pageCount, current);
        const max = Math.min(this.config.rangeCount, pageCount);
        Array.from(Array(max)).forEach((_, i) => {
            pages.push({
                number: i + start,
                label: String(i + start + 1),
                type: PaginationItemType.PAGE,
            });
        });
    }
    /**
     * Adds dots before and after the given pages, if configured (defaults to true).
     * If the dots only represent a single page, the page number is added instead of
     * the dots, unless the configuration requires dots always.
     *
     * @param pages The list of page items that is used to amend
     * @param pageCount The total number of pages
     */
    addDots(pages, pageCount) {
        if (!this.config.addDots) {
            return;
        }
        const addFirstGap = () => {
            const firstItemNumber = pages[0].number;
            const gapNumber = this.config.addFirst ? 1 : 0;
            if (firstItemNumber > gapNumber) {
                const isGap = !this.config.substituteDotsForSingularPage ||
                    firstItemNumber !== gapNumber + 1;
                const isSubstituted = this.config.addFirst &&
                    this.config.substituteDotsForSingularPage &&
                    gapNumber === 0;
                const type = isGap
                    ? PaginationItemType.GAP
                    : isSubstituted
                        ? PaginationItemType.FIRST
                        : PaginationItemType.PAGE;
                return [
                    Object.assign({
                        label: isGap ? this.config.dotsLabel : String(gapNumber + 1),
                        type,
                    }, isGap ? null : { number: gapNumber }),
                ];
            }
            else
                return [];
        };
        const addLastGap = () => {
            const nextPageNumber = pages[pages.length - 1].number + 1;
            const last = pageCount - (this.config.addLast ? 2 : 1);
            if (nextPageNumber <= last) {
                const isSubstituted = this.config.addLast &&
                    this.config.substituteDotsForSingularPage &&
                    nextPageNumber === last;
                const isGap = nextPageNumber <
                    pageCount -
                        (this.config.substituteDotsForSingularPage ? 1 : 0) -
                        (this.config.addLast ? 1 : 0);
                const type = isGap
                    ? PaginationItemType.GAP
                    : isSubstituted
                        ? PaginationItemType.LAST
                        : PaginationItemType.PAGE;
                return [
                    Object.assign({
                        label: isGap ? this.config.dotsLabel : String(nextPageNumber + 1),
                        type,
                    }, isGap ? null : { number: nextPageNumber }),
                ];
            }
            else
                return [];
        };
        pages.unshift(...addFirstGap());
        pages.push(...addLastGap());
    }
    /**
     * Add links to the first and last page, if configured to do so.
     *
     * @param pages The list of page items that is used to amend
     * @param pageCount The total number of pages
     *
     */
    addFirstLast(pages, pageCount) {
        if (this.config.addFirst && pages[0].number !== 0) {
            pages.unshift({
                number: 0,
                label: '1',
                type: PaginationItemType.FIRST,
            });
        }
        if (this.config.addLast &&
            pages[pages.length - 1].number !== pageCount - 1) {
            pages.push({
                number: pageCount - 1,
                label: String(pageCount),
                type: PaginationItemType.LAST,
            });
        }
    }
    /**
     * Add links to the start, previous, next and last page, if configured to do so.
     * The order of the links can be configured by using the {@link PaginationConfig},
     * using the `PaginationNavigationPosition` (`BEFORE` or `AFTER`).
     * The `PaginationNavigationPosition` allows for 3 flavours:
     *
     * - by default the pagination starts with start and previous and ends with the next and end links
     * - BEFORE – all navigation links are added in the front of the pagination list
     * - AFTER – all navigation links are pushed to the end of the pagination list
     *
     * @param pages The list of page items that is used to amend
     * @param pageCount The total number of pages
     * @param current The current page number, 0-index based
     *
     */
    addNavigation(pages, pageCount, current) {
        const before = this.getBeforeLinks(current);
        const after = this.getAfterLinks(pageCount, current);
        const pos = this.config.navigationPosition;
        if (!pos || pos === PaginationNavigationPosition.ASIDE) {
            pages.unshift(...before);
            pages.push(...after);
        }
        else {
            if (pos === PaginationNavigationPosition.BEFORE) {
                pages.unshift(...before, ...after);
            }
            if (pos === PaginationNavigationPosition.AFTER) {
                pages.push(...before, ...after);
            }
        }
    }
    /**
     * Returns the start and previous links, if applicable.
     */
    getBeforeLinks(current) {
        const list = [];
        if (this.config.addStart) {
            const start = () => {
                return Object.assign({
                    label: this.config.startLabel,
                    type: PaginationItemType.START,
                }, current > 0 ? { number: 0 } : null);
            };
            list.push(start());
        }
        if (this.config.addPrevious) {
            const previous = () => {
                return Object.assign({
                    label: this.config.previousLabel,
                    type: PaginationItemType.PREVIOUS,
                }, current > 0 ? { number: current - 1 } : null);
            };
            list.push(previous());
        }
        return list;
    }
    /**
     * Returns the next and end links, if applicable.
     */
    getAfterLinks(pageCount, current) {
        const list = [];
        if (this.config.addNext) {
            const next = () => {
                return Object.assign({
                    label: this.config.nextLabel,
                    type: PaginationItemType.NEXT,
                }, current < pageCount - 1 ? { number: current + 1 } : null);
            };
            list.push(next());
        }
        if (this.config.addEnd) {
            const end = () => {
                return Object.assign({
                    label: this.config.endLabel,
                    type: PaginationItemType.END,
                }, current < pageCount - 1 ? { number: pageCount - 1 } : null);
            };
            list.push(end());
        }
        return list;
    }
    /**
     * Resolves the first page of the range we need to build.
     * This is the page that is leading up to the range of the
     * current page.
     *
     * @param pageCount The total number of pages.
     * @param current The current page number, 0-index based.
     */
    getStartOfRange(pageCount, current) {
        const count = this.config.rangeCount - 1;
        // the least number of pages before and after the current
        const delta = Math.round(count / 2);
        // ensure that we start with at least the first page
        const minStart = Math.max(0, current - delta);
        // ensures that we start with at least 1 and do not pass the last range
        const maxStart = Math.max(0, pageCount - count - 1);
        // ensure that we get at least a full range at the end
        return Math.min(maxStart, minStart);
    }
    /**
     * Returns the pagination configuration. The configuration is driven by the
     * (default) application configuration.
     *
     * The default application is limited to adding the start and end link:
     * ```ts
     *   addStart: true,
     *   addEnd: true
     * ```
     *
     * The application configuration is however merged into the following static configuration:
     * ```ts
     * {
     *   rangeCount: 3,
     *   dotsLabel: '...',
     *   startLabel: '«',
     *   previousLabel: '‹',
     *   nextLabel: '›',
     *   endLabel: '»'
     * }
     * ```
     */
    get config() {
        return Object.assign(FALLBACK_PAGINATION_OPTIONS, this.paginationConfig.pagination);
    }
}
PaginationBuilder.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PaginationBuilder, deps: [{ token: PaginationConfig }], target: i0.ɵɵFactoryTarget.Injectable });
PaginationBuilder.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PaginationBuilder, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PaginationBuilder, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: PaginationConfig }]; } });

/**
 * The `PaginationComponent` is a generic component that is used for
 * all lists in Spartacus that require pagination. The component supports
 * all common features, which can be configured or hidden by CSS.
 */
class PaginationComponent {
    constructor(paginationBuilder, activatedRoute) {
        this.paginationBuilder = paginationBuilder;
        this.activatedRoute = activatedRoute;
        this.viewPageEvent = new EventEmitter();
        this.pages = [];
    }
    get pagination() {
        return this._pagination;
    }
    set pagination(value) {
        this._pagination = value;
        this.render(value);
    }
    render(pagination) {
        if (!pagination) {
            return;
        }
        this.pages = this.paginationBuilder.paginate(pagination.totalPages, pagination.currentPage);
    }
    /**
     * Format aria-label based on pagination item type.
     *
     * @param label string
     * @param type PaginationItemType
     * @returns string
     */
    getAriaLabel(label, type) {
        // Convert 'Start' to First, and 'End' to Last for a more natural screen read.
        type = type === PaginationItemType.START ? PaginationItemType.FIRST : type;
        type = type === PaginationItemType.END ? PaginationItemType.LAST : type;
        return type === PaginationItemType.PAGE
            ? `${type} ${label}`
            : `${type} ${PaginationItemType.PAGE}`;
    }
    /**
     * Indicates whether the given item is the current item.
     *
     * @param item PaginationItem
     * @returns boolean
     */
    isCurrent(item) {
        return (item.type === PaginationItemType.PAGE &&
            item.number === this.pagination.currentPage);
    }
    /**
     * Indicates whether the pagination item is inactive. This is used
     * to disabled a link or set the tabindex to `-1`.
     *
     * Defaults to true
     *
     * @param item PaginationItem
     * @returns returns -1 in case of a disabled
     */
    isInactive(item) {
        return (!item.hasOwnProperty('number') ||
            item.number === this.pagination.currentPage);
    }
    getQueryParams(item) {
        const queryParams = Object.assign({}, this.activatedRoute.snapshot.queryParams);
        if (this.queryParam &&
            item.number < this.pagination.totalPages &&
            !this.isCurrent(item)) {
            queryParams[this.queryParam] = item.number;
        }
        // omit the page number from the query parameters in case it's the default
        // to clean up the experience and avoid unnecessary polluting of the URL
        if (queryParams[this.queryParam] === this.defaultPage) {
            delete queryParams[this.queryParam];
        }
        return queryParams;
    }
    pageChange(page) {
        this.viewPageEvent.emit(page.number);
    }
}
PaginationComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PaginationComponent, deps: [{ token: PaginationBuilder }, { token: i1$1.ActivatedRoute }], target: i0.ɵɵFactoryTarget.Component });
PaginationComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: PaginationComponent, selector: "cx-pagination", inputs: { pageRoute: "pageRoute", queryParam: "queryParam", defaultPage: "defaultPage", pagination: "pagination" }, outputs: { viewPageEvent: "viewPageEvent" }, ngImport: i0, template: "<a\n  *ngFor=\"let item of pages\"\n  [class]=\"item.type\"\n  [class.disabled]=\"isInactive(item)\"\n  [class.current]=\"isCurrent(item)\"\n  [routerLink]=\"pageRoute\"\n  [queryParams]=\"getQueryParams(item)\"\n  [tabIndex]=\"isInactive(item) ? -1 : 0\"\n  (click)=\"pageChange(item)\"\n  [attr.aria-label]=\"getAriaLabel(item.label, item.type)\"\n>\n  {{ item.label }}\n</a>\n", directives: [{ type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i1$1.RouterLinkWithHref, selector: "a[routerLink],area[routerLink]", inputs: ["routerLink", "target", "queryParams", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange", "replaceUrl", "state", "relativeTo"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PaginationComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-pagination',
                    templateUrl: './pagination.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: PaginationBuilder }, { type: i1$1.ActivatedRoute }]; }, propDecorators: { pageRoute: [{
                type: Input
            }], queryParam: [{
                type: Input
            }], defaultPage: [{
                type: Input
            }], pagination: [{
                type: Input
            }], viewPageEvent: [{
                type: Output
            }] } });

class PaginationModule {
}
PaginationModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PaginationModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
PaginationModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PaginationModule, declarations: [PaginationComponent], imports: [CommonModule, RouterModule], exports: [PaginationComponent] });
PaginationModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PaginationModule, providers: [provideDefaultConfig(defaultPaginationConfig)], imports: [[CommonModule, RouterModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PaginationModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, RouterModule],
                    providers: [provideDefaultConfig(defaultPaginationConfig)],
                    declarations: [PaginationComponent],
                    exports: [PaginationComponent],
                }]
        }] });

class SortingComponent {
    constructor() {
        this.sortListEvent = new EventEmitter();
    }
    sortList(sortCode) {
        this.sortListEvent.emit(sortCode);
    }
    get selectedLabel() {
        var _a, _b, _c, _d;
        return ((_c = (_b = (_a = this.sortOptions) === null || _a === void 0 ? void 0 : _a.find((sort) => sort.code === this.selectedOption)) === null || _b === void 0 ? void 0 : _b.name) !== null && _c !== void 0 ? _c : (_d = this.sortLabels) === null || _d === void 0 ? void 0 : _d[this.selectedOption]);
    }
}
SortingComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SortingComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
SortingComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: SortingComponent, selector: "cx-sorting", inputs: { sortOptions: "sortOptions", selectedOption: "selectedOption", placeholder: "placeholder", sortLabels: "sortLabels" }, outputs: { sortListEvent: "sortListEvent" }, ngImport: i0, template: "<ng-select\n  [searchable]=\"false\"\n  [clearable]=\"false\"\n  placeholder=\"{{ placeholder }}\"\n  (change)=\"sortList($event)\"\n  [ngModel]=\"selectedOption\"\n  [attr.aria-label]=\"selectedLabel || placeholder\"\n>\n  <ng-option *ngFor=\"let sort of sortOptions\" [value]=\"sort.code\">{{\n    sort.name ? sort.name : sortLabels ? sortLabels[sort.code] : ''\n  }}</ng-option>\n</ng-select>\n", components: [{ type: i1$4.NgSelectComponent, selector: "ng-select", inputs: ["markFirst", "dropdownPosition", "loading", "closeOnSelect", "hideSelected", "selectOnTab", "bufferAmount", "selectableGroup", "selectableGroupAsModel", "searchFn", "trackByFn", "clearOnBackspace", "labelForId", "inputAttrs", "readonly", "searchWhileComposing", "minTermLength", "editableSearchTerm", "keyDownFn", "multiple", "addTag", "searchable", "clearable", "isOpen", "items", "compareWith", "clearSearchOnAdd", "bindLabel", "placeholder", "notFoundText", "typeToSearchText", "addTagText", "loadingText", "clearAllText", "virtualScroll", "openOnEnter", "appendTo", "bindValue", "appearance", "maxSelectedItems", "groupBy", "groupValue", "tabIndex", "typeahead"], outputs: ["blur", "focus", "change", "open", "close", "search", "clear", "add", "remove", "scroll", "scrollToEnd"] }, { type: i1$4.ɵr, selector: "ng-option", inputs: ["disabled", "value"] }], directives: [{ type: i3$1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i3$1.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SortingComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-sorting',
                    templateUrl: './sorting.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return []; }, propDecorators: { sortOptions: [{
                type: Input
            }], selectedOption: [{
                type: Input
            }], placeholder: [{
                type: Input
            }], sortLabels: [{
                type: Input
            }], sortListEvent: [{
                type: Output
            }] } });

class ListNavigationModule {
}
ListNavigationModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ListNavigationModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ListNavigationModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ListNavigationModule, declarations: [SortingComponent], imports: [CommonModule,
        NgSelectModule,
        FormsModule,
        ReactiveFormsModule,
        IconModule,
        PaginationModule], exports: [SortingComponent, PaginationComponent] });
ListNavigationModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ListNavigationModule, imports: [[
            CommonModule,
            NgSelectModule,
            FormsModule,
            ReactiveFormsModule,
            IconModule,
            PaginationModule,
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ListNavigationModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        NgSelectModule,
                        FormsModule,
                        ReactiveFormsModule,
                        IconModule,
                        PaginationModule,
                    ],
                    declarations: [SortingComponent],
                    exports: [SortingComponent, PaginationComponent],
                }]
        }] });

/**
 * Provides configuration specific to Media, such as images. This is used to optimize
 * rendering of the media, SEO and performance.
 */
class MediaConfig {
}
MediaConfig.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: MediaConfig, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
MediaConfig.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: MediaConfig, providedIn: 'root', useExisting: Config });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: MediaConfig, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                    useExisting: Config,
                }]
        }] });

/**
 * A reference to a newly opened modal
 *
 * @todo remove ngb dependency and create our own implementation of ModalRef
 */
class ModalRef extends NgbModalRef {
}

class ModalModule {
}
ModalModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ModalModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ModalModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ModalModule, declarations: [ModalDirective], exports: [ModalDirective] });
ModalModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ModalModule });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ModalModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [ModalDirective],
                    exports: [ModalDirective],
                }]
        }] });

class OrderOverviewComponent {
    constructor(translation) {
        this.translation = translation;
    }
    set setOrder(order) {
        this.order = order;
    }
    getReplenishmentCodeCardContent(orderCode) {
        return this.translation.translate('orderDetails.replenishmentId').pipe(filter(() => Boolean(orderCode)), map((textTitle) => ({
            title: textTitle,
            text: [orderCode],
        })));
    }
    getReplenishmentActiveCardContent(active) {
        return combineLatest([
            this.translation.translate('orderDetails.status'),
            this.translation.translate('orderDetails.active'),
            this.translation.translate('orderDetails.cancelled'),
        ]).pipe(map(([textTitle, textActive, textCancelled]) => ({
            title: textTitle,
            text: [active ? textActive : textCancelled],
        })));
    }
    getReplenishmentStartOnCardContent(isoDate) {
        return this.translation.translate('orderDetails.startOn').pipe(filter(() => Boolean(isoDate)), map((textTitle) => {
            return {
                title: textTitle,
                text: [isoDate],
            };
        }));
    }
    getReplenishmentFrequencyCardContent(frequency) {
        return this.translation.translate('orderDetails.frequency').pipe(filter(() => Boolean(frequency)), map((textTitle) => ({
            title: textTitle,
            text: [frequency],
        })));
    }
    getReplenishmentNextDateCardContent(isoDate) {
        return this.translation.translate('orderDetails.nextOrderDate').pipe(filter(() => Boolean(isoDate)), map((textTitle) => {
            return {
                title: textTitle,
                text: [isoDate],
            };
        }));
    }
    getOrderCodeCardContent(orderCode) {
        return this.translation.translate('orderDetails.orderNumber').pipe(filter(() => Boolean(orderCode)), map((textTitle) => ({
            title: textTitle,
            text: [orderCode],
        })));
    }
    getOrderCurrentDateCardContent(isoDate) {
        return this.translation.translate('orderDetails.placedOn').pipe(filter(() => Boolean(isoDate)), map((textTitle) => {
            return {
                title: textTitle,
                text: [isoDate],
            };
        }));
    }
    getOrderStatusCardContent(status) {
        return combineLatest([
            this.translation.translate('orderDetails.status'),
            this.translation.translate('orderDetails.statusDisplay_' + status),
        ]).pipe(map(([textTitle, textStatus]) => ({
            title: textTitle,
            text: [textStatus],
        })));
    }
    getPurchaseOrderNumber(poNumber) {
        return combineLatest([
            this.translation.translate('orderDetails.purchaseOrderNumber'),
            this.translation.translate('orderDetails.emptyPurchaseOrderId'),
        ]).pipe(map(([textTitle, noneTextTitle]) => ({
            title: textTitle,
            text: [poNumber ? poNumber : noneTextTitle],
        })));
    }
    getMethodOfPaymentCardContent(hasPaymentInfo) {
        return combineLatest([
            this.translation.translate('orderDetails.methodOfPayment'),
            this.translation.translate('paymentTypes.paymentType_ACCOUNT'),
            this.translation.translate('paymentTypes.paymentType_CARD'),
        ]).pipe(map(([textTitle, textAccount, textCard]) => ({
            title: textTitle,
            text: [Boolean(hasPaymentInfo) ? textCard : textAccount],
        })));
    }
    getCostCenterCardContent(costCenter) {
        return this.translation.translate('orderDetails.costCenter').pipe(filter(() => Boolean(costCenter)), map((textTitle) => {
            var _a;
            return ({
                title: textTitle,
                textBold: costCenter === null || costCenter === void 0 ? void 0 : costCenter.name,
                text: ['(' + ((_a = costCenter === null || costCenter === void 0 ? void 0 : costCenter.unit) === null || _a === void 0 ? void 0 : _a.name) + ')'],
            });
        }));
    }
    getAddressCardContent(deliveryAddress) {
        return this.translation.translate('addressCard.shipTo').pipe(filter(() => Boolean(deliveryAddress)), map((textTitle) => {
            const formattedAddress = this.normalizeFormattedAddress(deliveryAddress.formattedAddress);
            return {
                title: textTitle,
                textBold: `${deliveryAddress.firstName} ${deliveryAddress.lastName}`,
                text: [formattedAddress, deliveryAddress.country.name],
            };
        }));
    }
    getDeliveryModeCardContent(deliveryMode) {
        return this.translation.translate('orderDetails.shippingMethod').pipe(filter(() => Boolean(deliveryMode)), map((textTitle) => {
            var _a, _b;
            return ({
                title: textTitle,
                textBold: deliveryMode.name,
                text: [
                    deliveryMode.description,
                    ((_a = deliveryMode.deliveryCost) === null || _a === void 0 ? void 0 : _a.formattedValue)
                        ? (_b = deliveryMode.deliveryCost) === null || _b === void 0 ? void 0 : _b.formattedValue
                        : '',
                ],
            });
        }));
    }
    getPaymentInfoCardContent(payment) {
        return combineLatest([
            this.translation.translate('paymentForm.payment'),
            this.translation.translate('paymentCard.expires', {
                month: Boolean(payment) ? payment.expiryMonth : '',
                year: Boolean(payment) ? payment.expiryYear : '',
            }),
        ]).pipe(filter(() => Boolean(payment)), map(([textTitle, textExpires]) => ({
            title: textTitle,
            textBold: payment.accountHolderName,
            text: [payment.cardNumber, textExpires],
        })));
    }
    getBillingAddressCardContent(billingAddress) {
        return this.translation.translate('paymentForm.billingAddress').pipe(filter(() => Boolean(billingAddress)), map((textTitle) => ({
            title: textTitle,
            textBold: `${billingAddress.firstName} ${billingAddress.lastName}`,
            text: [billingAddress.formattedAddress, billingAddress.country.name],
        })));
    }
    normalizeFormattedAddress(formattedAddress) {
        const addresses = formattedAddress
            .split(',')
            .map((address) => address.trim());
        const newFormattedAddress = addresses.filter(Boolean).join(', ');
        return newFormattedAddress;
    }
}
OrderOverviewComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OrderOverviewComponent, deps: [{ token: i1.TranslationService }], target: i0.ɵɵFactoryTarget.Component });
OrderOverviewComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: OrderOverviewComponent, selector: "cx-order-overview", inputs: { setOrder: ["order", "setOrder"] }, ngImport: i0, template: "<div class=\"cx-order-summary\">\n  <div class=\"container\">\n    <ng-container *ngIf=\"order.replenishmentOrderCode; else otherOrder\">\n      <div class=\"cx-summary-card\">\n        <cx-card\n          [content]=\"\n            getReplenishmentCodeCardContent(order?.replenishmentOrderCode)\n              | async\n          \"\n        ></cx-card>\n\n        <cx-card\n          [content]=\"getReplenishmentActiveCardContent(order?.active) | async\"\n        ></cx-card>\n      </div>\n\n      <div class=\"cx-summary-card\">\n        <cx-card\n          [content]=\"\n            getReplenishmentStartOnCardContent(order?.firstDate | cxDate)\n              | async\n          \"\n        ></cx-card>\n\n        <cx-card\n          [content]=\"\n            getReplenishmentFrequencyCardContent(\n              order?.trigger?.displayTimeTable\n            ) | async\n          \"\n        ></cx-card>\n\n        <cx-card\n          [content]=\"\n            getReplenishmentNextDateCardContent(\n              order?.trigger?.activationTime | cxDate\n            ) | async\n          \"\n        ></cx-card>\n      </div>\n    </ng-container>\n\n    <ng-template #otherOrder>\n      <div class=\"cx-summary-card\">\n        <cx-card\n          [content]=\"getOrderCodeCardContent(order?.code) | async\"\n        ></cx-card>\n\n        <cx-card\n          [content]=\"\n            getOrderCurrentDateCardContent(order?.created | cxDate) | async\n          \"\n        ></cx-card>\n\n        <cx-card\n          [content]=\"getOrderStatusCardContent(order.statusDisplay) | async\"\n        ></cx-card>\n      </div>\n    </ng-template>\n\n    <ng-container\n      *ngIf=\"order.purchaseOrderNumber || order.purchaseOrderNumber === ''\"\n    >\n      <div class=\"cx-summary-card\">\n        <cx-card\n          [content]=\"getPurchaseOrderNumber(order?.purchaseOrderNumber) | async\"\n        ></cx-card>\n\n        <cx-card\n          [content]=\"getMethodOfPaymentCardContent(order.paymentInfo) | async\"\n        ></cx-card>\n\n        <ng-container *ngIf=\"order.costCenter\">\n          <cx-card\n            [content]=\"getCostCenterCardContent(order?.costCenter) | async\"\n          ></cx-card>\n        </ng-container>\n      </div>\n    </ng-container>\n\n    <div class=\"cx-summary-card\">\n      <ng-container *ngIf=\"order.deliveryAddress\">\n        <cx-card\n          [content]=\"getAddressCardContent(order?.deliveryAddress) | async\"\n        ></cx-card>\n      </ng-container>\n\n      <ng-container *ngIf=\"order.deliveryMode\">\n        <cx-card\n          [content]=\"getDeliveryModeCardContent(order?.deliveryMode) | async\"\n        ></cx-card>\n      </ng-container>\n    </div>\n\n    <ng-container *ngIf=\"order.paymentInfo\">\n      <div class=\"cx-summary-card\">\n        <cx-card\n          [content]=\"getPaymentInfoCardContent(order?.paymentInfo) | async\"\n        ></cx-card>\n\n        <cx-card\n          [content]=\"\n            getBillingAddressCardContent(order?.paymentInfo?.billingAddress)\n              | async\n          \"\n        ></cx-card>\n      </div>\n    </ng-container>\n  </div>\n</div>\n", components: [{ type: CardComponent, selector: "cx-card", inputs: ["border", "editMode", "isDefault", "content", "fitToContainer", "truncateText", "charactersLimit"], outputs: ["deleteCard", "setDefaultCard", "sendCard", "editCard", "cancelCard"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "async": i3.AsyncPipe, "cxDate": i1.CxDatePipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OrderOverviewComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-order-overview',
                    templateUrl: './order-overview.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: i1.TranslationService }]; }, propDecorators: { setOrder: [{
                type: Input,
                args: ['order']
            }] } });

class OrderOverviewModule {
}
OrderOverviewModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OrderOverviewModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
OrderOverviewModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OrderOverviewModule, declarations: [OrderOverviewComponent], imports: [CommonModule, I18nModule, CardModule], exports: [OrderOverviewComponent] });
OrderOverviewModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OrderOverviewModule, imports: [[CommonModule, I18nModule, CardModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OrderOverviewModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, I18nModule, CardModule],
                    declarations: [OrderOverviewComponent],
                    exports: [OrderOverviewComponent],
                }]
        }] });

class ProgressButtonComponent {
    constructor() {
        this.ariaLabel = '';
        this.class = '';
        this.disabled = false;
        this.loading = false;
        this.clikEvent = new EventEmitter();
    }
}
ProgressButtonComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProgressButtonComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
ProgressButtonComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: ProgressButtonComponent, selector: "cx-progress-button", inputs: { ariaLabel: "ariaLabel", class: "class", disabled: "disabled", loading: "loading" }, outputs: { clikEvent: "clikEvent" }, ngImport: i0, template: "<button\n  (click)=\"clikEvent.emit()\"\n  [attr.aria-label]=\"ariaLabel\"\n  [disabled]=\"disabled || loading\"\n  [ngClass]=\"class\"\n  class=\"btn btn-primary\"\n>\n  <div class=\"cx-progress-button-container\">\n    <div *ngIf=\"loading\" class=\"loader-container\">\n      <div class=\"loader\">{{ 'spinner.loading' | cxTranslate }}</div>\n    </div>\n\n    <ng-content></ng-content>\n  </div>\n</button>\n", directives: [{ type: i3.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "cxTranslate": i1.TranslatePipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProgressButtonComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-progress-button',
                    templateUrl: './progress-button.component.html',
                }]
        }], ctorParameters: function () { return []; }, propDecorators: { ariaLabel: [{
                type: Input
            }], class: [{
                type: Input
            }], disabled: [{
                type: Input
            }], loading: [{
                type: Input
            }], clikEvent: [{
                type: Output
            }] } });

class ProgressButtonModule {
}
ProgressButtonModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProgressButtonModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ProgressButtonModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProgressButtonModule, declarations: [ProgressButtonComponent], imports: [CommonModule, I18nModule], exports: [ProgressButtonComponent] });
ProgressButtonModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProgressButtonModule, imports: [[CommonModule, I18nModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProgressButtonModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, I18nModule],
                    declarations: [ProgressButtonComponent],
                    exports: [ProgressButtonComponent],
                }]
        }] });

/**
 * @deprecated since 4.2 - use order lib instead
 */
class ReplenishmentOrderCancellationDialogComponent {
    constructor(userReplenishmentOrderService, globalMessageService, launchDialogService, el) {
        this.userReplenishmentOrderService = userReplenishmentOrderService;
        this.globalMessageService = globalMessageService;
        this.launchDialogService = launchDialogService;
        this.el = el;
        this.subscription = new Subscription();
        this.focusConfig = {
            trap: true,
            block: true,
            autofocus: 'button',
            focusOnEscape: true,
        };
    }
    handleClick(event) {
        // Close on click outside the dialog window
        if (event.target.tagName === this.el.nativeElement.tagName) {
            this.close('Cross click');
        }
    }
    ngOnInit() {
        this.subscription.add(combineLatest([
            this.userReplenishmentOrderService
                .getReplenishmentOrderDetails()
                .pipe(startWith(null)),
            this.launchDialogService.data$,
        ]).subscribe(([replenishmentOrder, code]) => {
            this.replenishmentOrderCode =
                code || replenishmentOrder.replenishmentOrderCode;
        }));
        this.subscription.add(this.userReplenishmentOrderService
            .getCancelReplenishmentOrderSuccess()
            .subscribe((value) => this.onSuccess(value)));
    }
    onSuccess(value) {
        if (value) {
            this.launchDialogService.closeDialog('Successffully cancelled replenishment');
            this.globalMessageService.add({
                key: 'orderDetails.cancelReplenishment.cancelSuccess',
                params: {
                    replenishmentOrderCode: this.replenishmentOrderCode,
                },
            }, GlobalMessageType.MSG_TYPE_CONFIRMATION);
        }
        this.userReplenishmentOrderService.clearCancelReplenishmentOrderProcessState();
    }
    close(reason) {
        this.launchDialogService.closeDialog(reason);
    }
    cancelReplenishment() {
        this.userReplenishmentOrderService.cancelReplenishmentOrder(this.replenishmentOrderCode);
    }
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
}
ReplenishmentOrderCancellationDialogComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ReplenishmentOrderCancellationDialogComponent, deps: [{ token: i1.UserReplenishmentOrderService }, { token: i1.GlobalMessageService }, { token: LaunchDialogService }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component });
ReplenishmentOrderCancellationDialogComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: ReplenishmentOrderCancellationDialogComponent, selector: "cx-replenishment-order-cancellation-dialog", host: { listeners: { "click": "handleClick($event)" } }, ngImport: i0, template: "<div\n  [cxFocus]=\"focusConfig\"\n  (esc)=\"close('Escape clicked')\"\n  class=\"cx-cancel-replenishment-dialog-foreground\"\n>\n  <div class=\"cx-cancel-replenishment-dialog-content\">\n    <div class=\"cx-cancel-replenishment-dialog-header\">\n      <h3>\n        {{ 'orderDetails.cancelReplenishment.title' | cxTranslate }}\n      </h3>\n    </div>\n    <div class=\"cx-cancel-replenishment-dialog-description\">\n      {{ 'orderDetails.cancelReplenishment.description' | cxTranslate }}\n    </div>\n\n    <div class=\"cx-cancel-replenishment-dialog-body\">\n      <div class=\"cx-cancel-replenishment-btns row\">\n        <div class=\"col-md-6\">\n          <button\n            class=\"btn btn-block btn-action\"\n            (click)=\"close('Close Replenishment Dialog')\"\n          >\n            {{ 'orderDetails.cancelReplenishment.reject' | cxTranslate }}\n          </button>\n        </div>\n        <div class=\"col-md-6\">\n          <button\n            class=\"btn btn-block btn-primary\"\n            (click)=\"cancelReplenishment()\"\n          >\n            {{ 'orderDetails.cancelReplenishment.accept' | cxTranslate }}\n          </button>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n", directives: [{ type: FocusDirective, selector: "[cxFocus]", inputs: ["cxFocus"] }], pipes: { "cxTranslate": i1.TranslatePipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ReplenishmentOrderCancellationDialogComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-replenishment-order-cancellation-dialog',
                    templateUrl: './replenishment-order-cancellation-dialog.component.html',
                }]
        }], ctorParameters: function () { return [{ type: i1.UserReplenishmentOrderService }, { type: i1.GlobalMessageService }, { type: LaunchDialogService }, { type: i0.ElementRef }]; }, propDecorators: { handleClick: [{
                type: HostListener,
                args: ['click', ['$event']]
            }] } });

/**
 * @deprecated since 4.2 - use order lib instead
 */
class ReplenishmentOrderCancellationDialogModule {
}
ReplenishmentOrderCancellationDialogModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ReplenishmentOrderCancellationDialogModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ReplenishmentOrderCancellationDialogModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ReplenishmentOrderCancellationDialogModule, declarations: [ReplenishmentOrderCancellationDialogComponent], imports: [CommonModule, I18nModule, KeyboardFocusModule], exports: [ReplenishmentOrderCancellationDialogComponent] });
ReplenishmentOrderCancellationDialogModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ReplenishmentOrderCancellationDialogModule, imports: [[CommonModule, I18nModule, KeyboardFocusModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ReplenishmentOrderCancellationDialogModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, I18nModule, KeyboardFocusModule],
                    declarations: [ReplenishmentOrderCancellationDialogComponent],
                    exports: [ReplenishmentOrderCancellationDialogComponent],
                }]
        }] });

/**
 * Supposed to be injected in the split view component, so that the split view state
 * is maintained for a single split view.
 */
class SplitViewService {
    constructor() {
        /**
         * Newly added views are hidden by default, unless it is the first view of the split view.
         * The default hide mode can be overridden.
         */
        this.defaultHideMode = true;
        this.splitViewCount = 1;
        this._views$ = new BehaviorSubject([]);
    }
    /**
     * Adds a view to the list of views. The view is initialized with the `SplitViewState`
     * state. If no state is provided, the state is created with the hidden property. The hidden
     * property is provided by the `defaultHideMode`, unless it's the first view (position: 0).
     */
    add(position, initialState) {
        const state = Object.assign({ hidden: position === 0 ? false : this.defaultHideMode }, initialState);
        if (!this.views[position]) {
            this.views[position] = state;
            this.updateState(position, state.hidden);
            this._views$.next(this.views);
        }
    }
    /**
     * The split view is based on a number of views that can be used next to each other.
     * When the number changes (i.e. if the screen goes from wide to small), the visibility state
     * of the views should be updated.
     */
    updateSplitView(splitViewCount) {
        if (splitViewCount !== this.splitViewCount) {
            this.splitViewCount = splitViewCount;
            this.updateState();
        }
    }
    /**
     * Returns an observable with the active view number. The active view number
     * represents the last visible view.
     */
    getActiveView() {
        return this._views$.pipe(map((views) => this.getActive(views)), distinctUntilChanged());
    }
    /**
     * Returns an observable with the SplitViewState for the given view position.
     */
    getViewState(position) {
        return this._views$.pipe(map((views) => views[position]), 
        // we must filter here, since outlet driven views will destroyed the view
        filter((view) => Boolean(view)));
    }
    /**
     * Removes a view from the list of views.
     *
     * Removing a view is different from hiding a view. Removing a view is typically done
     * when a component is destroyed.
     *
     * When the view is removed, the SplitViewState is updated to reflect that new organization
     * of views.
     */
    remove(position) {
        const activePosition = this.getActive(this.views);
        this._views$.next(this.views.splice(0, position));
        if (activePosition >= position) {
            this.updateState(position);
        }
    }
    /**
     * Returns the next view position. This is useful for views that do not want to be bothered
     * with controlling view numbers.
     */
    get nextPosition() {
        return this.views.length || 0;
    }
    /**
     * Toggles the visibility of the views based on the given view position. If the view
     * is already visible, we close the view and active the former view. Unless the hide flag
     * is used, to force the view.
     *
     * The view state of other views in the split view are updated as well.
     *
     * @param position The zero-based position number of the view.
     * @param forceHide The (optional) hide state for the view position.
     */
    toggle(position, forceHide) {
        // add the view if it hasn't been added before.
        if (!this.views[position]) {
            this.add(position, { hidden: forceHide !== null && forceHide !== void 0 ? forceHide : false });
        }
        // If the position is already visible, we move to a previous position. Only if the hide
        // state is forced, we keep the current position.
        if (this.views[position] &&
            forceHide === undefined &&
            !this.views[position].hidden) {
            position--;
        }
        this.updateState(position, forceHide === true);
    }
    /**
     * Updates the hidden state of all the views.
     */
    updateState(position, hide) {
        const views = [...this.views];
        if (hide !== undefined && views[position]) {
            views[position].hidden = hide;
        }
        let lastVisible = views.length - [...views].reverse().findIndex((view) => !view.hidden) - 1;
        if (lastVisible === views.length) {
            if (position) {
                // When there's only 1 view (mobile), we might not find any active
                // if the user navigates back.
                lastVisible = position - 1;
            }
            else {
                lastVisible = views.length - 1;
            }
        }
        views.forEach((view, pos) => {
            if (view && pos !== position) {
                // hide other views that are outside the split view
                view.hidden =
                    pos > lastVisible || pos < lastVisible - (this.splitViewCount - 1);
            }
        });
        this._views$.next(views);
    }
    /**
     * Returns the active view count for the list of views.
     */
    getActive(views) {
        // we reverse the list to find the last visible view
        const l = [...views]
            .reverse()
            .findIndex((view) => !view.hidden);
        const last = l === -1 ? 0 : views.length - l - 1;
        return last;
    }
    /**
     * Utility method that resolves all views from the subject.
     */
    get views() {
        return this._views$.value;
    }
}
SplitViewService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SplitViewService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
SplitViewService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SplitViewService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SplitViewService, decorators: [{
            type: Injectable
        }] });

/**
 * The split-view component supports an unlimited number of nested views. The component
 * is a host to those view components and doesn't add any restrictions to it's content;
 * content is projected as-is.
 *
 * ```html
 * <cx-split-view>
 *   <cx-view></cx-view>
 *   <cx-view></cx-view>
 *   <any-wrapper>
 *     <cx-view></cx-view>
 *   </any-wrapper>
 * </cx-split-view>
 * ```
 *
 * The split view component is only concerned with tracking the underlying _visible_
 * view components, so that the `lastVisibleView` can be updated accordingly. The actual
 * visibility of views is controlled by CSS. To allow for maximum flexibility, the CSS
 * implementation is using CSS variables. The `lastVisibleView` is bind to the
 * `--cx-active-view` on the host, so that all descendants views will inherit the
 * property conveniently.
 */
class SplitViewComponent {
    constructor(splitService, breakpointService, elementRef) {
        this.splitService = splitService;
        this.breakpointService = breakpointService;
        this.elementRef = elementRef;
        this.subscription = new Subscription();
        /**
         * Indicates the last visible view in the range of views that is visible. This
         * is bind to a css variable `--cx-active-view` so that the experience
         * can be fully controlled by css.
         */
        this.lastVisibleView = 1;
    }
    /**
     * Sets the default hide mode for views. This mode is useful in case views are dynamically being created,
     * for example when they are created by router components.
     *
     * The mode defaults to true, unless this is the first view; the first view is never hidden.
     */
    set hideMode(mode) {
        this.splitService.defaultHideMode = mode;
    }
    ngOnInit() {
        this.subscription.add(this.splitService
            .getActiveView()
            .subscribe((lastVisible) => (this.lastVisibleView = lastVisible + 1)));
        this.subscription.add(this.breakpointService.breakpoint$.subscribe(() => {
            this.splitService.updateSplitView(this.splitViewCount);
        }));
    }
    /**
     * Returns the maximum number of views per split-view. The number is based on the
     * CSS custom property `--cx-max-views`.
     */
    get splitViewCount() {
        return Number(getComputedStyle(this.elementRef.nativeElement).getPropertyValue('--cx-max-views'));
    }
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
}
SplitViewComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SplitViewComponent, deps: [{ token: SplitViewService }, { token: BreakpointService }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component });
SplitViewComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: SplitViewComponent, selector: "cx-split-view", inputs: { hideMode: "hideMode" }, host: { properties: { "style.--cx-active-view": "this.lastVisibleView", "attr.active-view": "this.lastVisibleView" } }, providers: [SplitViewService], ngImport: i0, template: "<ng-content></ng-content>\n", changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SplitViewComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-split-view',
                    templateUrl: './split-view.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [SplitViewService],
                }]
        }], ctorParameters: function () { return [{ type: SplitViewService }, { type: BreakpointService }, { type: i0.ElementRef }]; }, propDecorators: { hideMode: [{
                type: Input
            }], lastVisibleView: [{
                type: HostBinding,
                args: ['style.--cx-active-view']
            }, {
                type: HostBinding,
                args: ['attr.active-view']
            }] } });

/**
 * The view component is part of the `SplitViewComponent`. The view
 * contains the navigable content that should be split up. It maintains
 * a view position and allows to show or hide the view.
 *
 * The ViewComponent interacts with the `SplitViewService` for handing over the
 * view state, so that the overarching `SplitViewComponent` can manage the
 * overall experience.
 */
class ViewComponent {
    constructor(splitService, elementRef, cd) {
        this.splitService = splitService;
        this.elementRef = elementRef;
        this.cd = cd;
        /**
         * The disappeared flag is added to the
         */
        this.disappeared = true;
        /**
         * An update of the view visibility is emitted to the hiddenChange output.
         */
        this.hiddenChange = new EventEmitter();
    }
    /**
     * The hidden input is used to set the initial visible state of the view.
     * The hidden state defaults to false.
     *
     * The hidden input supports 2-way binding, see `hiddenChange` property.
     */
    set hidden(hidden) {
        this._hidden = hidden;
        this.splitService.toggle(this.viewPosition, hidden);
    }
    ngOnInit() {
        const hidden = this._hidden ? { hidden: this._hidden } : {};
        this.splitService.add(this.viewPosition, hidden);
        this.subscription = this.splitService
            .getViewState(this.viewPosition)
            // delay the disappeared state, so that the (CSS driven) animation has time to finish
            .pipe(delayWhen((view) => timer(view.hidden ? this.duration * 1.25 : 0)))
            .subscribe((view) => {
            this.hiddenChange.emit(view.hidden);
            this._hidden = view.hidden;
            this.disappeared = view.hidden;
            this.cd.markForCheck();
        });
    }
    /**
     * Toggles the visibility of the view.
     *
     * An optional force flag can be used to explicitly show or hide view component.
     */
    toggle(force) {
        this.splitService.toggle(this.viewPosition, force);
    }
    /**
     * Returns the position for the view.
     *
     * The position is either taken from the input `position` or generated by the `SplitService`.
     */
    get viewPosition() {
        if (!(Number(this.position) >= 0)) {
            this.position = this.splitService.nextPosition.toString();
        }
        return Number(this.position);
    }
    /**
     * Returns the duration in milliseconds. The duration is based on the CSS custom property
     * `--cx-transition-duration`. Defaults to 300 milliseconds.
     */
    get duration() {
        const duration = getComputedStyle(this.elementRef.nativeElement)
            .getPropertyValue('--cx-transition-duration')
            .trim();
        if (duration.indexOf('ms') > -1) {
            return Number(duration.split('ms')[0]);
        }
        else if (duration.indexOf('s') > -1) {
            return Number(duration.split('s')[0]) * 1000;
        }
        else {
            return 300;
        }
    }
    /**
     * The view is removed from the `SplitService` so that the view no longer
     * plays a role in the overall split view.
     */
    ngOnDestroy() {
        var _a;
        this.splitService.remove(this.viewPosition);
        (_a = this.subscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();
    }
}
ViewComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ViewComponent, deps: [{ token: SplitViewService }, { token: i0.ElementRef }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
ViewComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: ViewComponent, selector: "cx-view", inputs: { position: "position", hidden: "hidden" }, outputs: { hiddenChange: "hiddenChange" }, host: { properties: { "attr.position": "this.position", "style.--cx-view-position": "this.position", "attr.disappeared": "this.disappeared" } }, ngImport: i0, template: "<ng-content></ng-content>\n", changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ViewComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-view',
                    templateUrl: './view.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: SplitViewService }, { type: i0.ElementRef }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { position: [{
                type: Input
            }, {
                type: HostBinding,
                args: ['attr.position']
            }, {
                type: HostBinding,
                args: ['style.--cx-view-position']
            }], disappeared: [{
                type: HostBinding,
                args: ['attr.disappeared']
            }], hidden: [{
                type: Input
            }], hiddenChange: [{
                type: Output
            }] } });

/**
 * The split-view component supports an unlimited number of nested views. Nested views are rendered
 * next to each other. The views can be rendered next to each other, but the max number of visible
 * views can be limisted as well. This is configurable in the CSS layer, so that the max number of views
 * per split-view can be different for each component.
 *
 * The basic structure of the split-view component is shown below:
 *
 *
 * ```
 * <cx-split-view>
 * </cx-split-view>
 * ```
 *
 * The UX pattern used for the split-view is driven by an initial view, which gets splitted into
 * more views as soon as the user starts interacting with the initial and subsequantial views.
 * The views can be driven by routes, which means that you can navigate through the splitted views
 * by using the browser history as well as share or bookmark splitted views.
 *
 * The UI is implemented in the style layer, with only a few generic style rules. Most of the split
 * view style is driven by CSS properties, so that alternative split-view styles can be introduced
 * per page or component.
 *
 * The max number of views per split-view on mobile is limited to 1 by default, where as on tablet
 * (and higher) it is set to 2. Spartacus has a pretty narrow layout, which is why 2 is maximum,
 * but customers could alter the layout to bring in more views in the same split-view at the time.
 *
 */
class SplitViewModule {
}
SplitViewModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SplitViewModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
SplitViewModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SplitViewModule, declarations: [SplitViewComponent, ViewComponent], imports: [CommonModule, RouterModule], exports: [SplitViewComponent, ViewComponent] });
SplitViewModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SplitViewModule, imports: [[CommonModule, RouterModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SplitViewModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [SplitViewComponent, ViewComponent],
                    imports: [CommonModule, RouterModule],
                    exports: [SplitViewComponent, ViewComponent],
                }]
        }] });

class GlobalMessageComponent {
    constructor(globalMessageService) {
        this.globalMessageService = globalMessageService;
        this.iconTypes = ICON_TYPE;
        this.messageType = GlobalMessageType;
    }
    ngOnInit() {
        this.messages$ = this.globalMessageService.get();
    }
    clear(type, index) {
        this.globalMessageService.remove(type, index);
    }
}
GlobalMessageComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: GlobalMessageComponent, deps: [{ token: i1.GlobalMessageService }], target: i0.ɵɵFactoryTarget.Component });
GlobalMessageComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: GlobalMessageComponent, selector: "cx-global-message", ngImport: i0, template: "<div *ngIf=\"messages$ | async as messages\">\n  <div\n    class=\"alert alert-success\"\n    *ngFor=\"\n      let confMsg of messages[messageType.MSG_TYPE_CONFIRMATION];\n      let i = index\n    \"\n  >\n    <span class=\"alert-icon\">\n      <cx-icon [type]=\"iconTypes.SUCCESS\"></cx-icon>\n    </span>\n    <span>{{ confMsg | cxTranslate }}</span>\n    <button\n      class=\"close\"\n      type=\"button\"\n      (click)=\"clear(messageType.MSG_TYPE_CONFIRMATION, i)\"\n    >\n      <cx-icon [type]=\"iconTypes.CLOSE\"></cx-icon>\n    </button>\n  </div>\n  <div\n    class=\"alert alert-info\"\n    *ngFor=\"let infoMsg of messages[messageType.MSG_TYPE_INFO]; let i = index\"\n  >\n    <span class=\"alert-icon\">\n      <cx-icon [type]=\"iconTypes.INFO\"></cx-icon>\n    </span>\n    <span>{{ infoMsg | cxTranslate }}</span>\n    <button\n      class=\"close\"\n      type=\"button\"\n      (click)=\"clear(messageType.MSG_TYPE_INFO, i)\"\n    >\n      <cx-icon [type]=\"iconTypes.CLOSE\"></cx-icon>\n    </button>\n  </div>\n  <div\n    class=\"alert alert-warning\"\n    *ngFor=\"\n      let infoMsg of messages[messageType.MSG_TYPE_WARNING];\n      let i = index\n    \"\n  >\n    <span class=\"alert-icon\">\n      <cx-icon [type]=\"iconTypes.WARNING\"></cx-icon>\n    </span>\n    <span>{{ infoMsg | cxTranslate }}</span>\n    <button\n      class=\"close\"\n      type=\"button\"\n      (click)=\"clear(messageType.MSG_TYPE_WARNING, i)\"\n    >\n      <cx-icon [type]=\"iconTypes.CLOSE\"></cx-icon>\n    </button>\n  </div>\n  <div\n    class=\"alert alert-danger\"\n    *ngFor=\"let errorMsg of messages[messageType.MSG_TYPE_ERROR]; let i = index\"\n  >\n    <span class=\"alert-icon\">\n      <cx-icon [type]=\"iconTypes.ERROR\"></cx-icon>\n    </span>\n    <span>{{ errorMsg | cxTranslate }}</span>\n    <button\n      class=\"close\"\n      type=\"button\"\n      (click)=\"clear(messageType.MSG_TYPE_ERROR, i)\"\n    >\n      <cx-icon [type]=\"iconTypes.CLOSE\"></cx-icon>\n    </button>\n  </div>\n</div>\n", components: [{ type: IconComponent, selector: "cx-icon,[cxIcon]", inputs: ["cxIcon", "type"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], pipes: { "async": i3.AsyncPipe, "cxTranslate": i1.TranslatePipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: GlobalMessageComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-global-message',
                    templateUrl: './global-message.component.html',
                }]
        }], ctorParameters: function () { return [{ type: i1.GlobalMessageService }]; } });

class GlobalMessageComponentModule {
}
GlobalMessageComponentModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: GlobalMessageComponentModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
GlobalMessageComponentModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: GlobalMessageComponentModule, declarations: [GlobalMessageComponent], imports: [CommonModule, IconModule, I18nModule], exports: [GlobalMessageComponent] });
GlobalMessageComponentModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: GlobalMessageComponentModule, imports: [[CommonModule, IconModule, I18nModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: GlobalMessageComponentModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, IconModule, I18nModule],
                    declarations: [GlobalMessageComponent],
                    exports: [GlobalMessageComponent],
                }]
        }] });

class MessageComponent {
    constructor() {
        this.showBody = false;
        this.isVisibleCloseButton = true;
        this.closeMessage = new EventEmitter();
        this.buttonAction = new EventEmitter();
        this.iconTypes = ICON_TYPE;
    }
    get getCssClassesForMessage() {
        return {
            'cx-message-success': this.type === GlobalMessageType.MSG_TYPE_CONFIRMATION,
            'cx-message-info': this.type === GlobalMessageType.MSG_TYPE_INFO,
            'cx-message-warning': this.type === GlobalMessageType.MSG_TYPE_WARNING,
            'cx-message-danger': this.type === GlobalMessageType.MSG_TYPE_ERROR,
        };
    }
    get getIconType() {
        switch (this.type) {
            case GlobalMessageType.MSG_TYPE_CONFIRMATION:
                return ICON_TYPE.SUCCESS;
            case GlobalMessageType.MSG_TYPE_WARNING:
                return ICON_TYPE.WARNING;
            case GlobalMessageType.MSG_TYPE_ERROR:
                return ICON_TYPE.ERROR;
            case GlobalMessageType.MSG_TYPE_INFO:
                return ICON_TYPE.INFO;
        }
    }
}
MessageComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: MessageComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
MessageComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: MessageComponent, selector: "cx-message", inputs: { text: "text", actionButtonText: "actionButtonText", accordionText: "accordionText", showBody: "showBody", isVisibleCloseButton: "isVisibleCloseButton", type: "type" }, outputs: { closeMessage: "closeMessage", buttonAction: "buttonAction" }, ngImport: i0, template: "<div [ngClass]=\"getCssClassesForMessage\" class=\"cx-message\">\n  <div class=\"cx-message-content\">\n    <div class=\"cx-message-header\">\n      <span class=\"cx-message-icon\">\n        <cx-icon [type]=\"getIconType\"></cx-icon>\n      </span>\n\n      <span class=\"cx-message-text\">\n        {{ text }}\n        <button\n          *ngIf=\"accordionText\"\n          (click)=\"showBody = !showBody\"\n          class=\"cx-message-accordion-button link cx-action-link\"\n          type=\"button\"\n        >\n          {{ accordionText }}\n          <cx-icon\n            [type]=\"showBody ? 'CARET_UP' : 'CARET_DOWN'\"\n            class=\"cx-message-accordion-icon\"\n          ></cx-icon>\n        </button>\n        <button\n          *ngIf=\"actionButtonText\"\n          (click)=\"buttonAction.emit()\"\n          class=\"btn btn-link cx-action-link\"\n          type=\"button\"\n        >\n          {{ actionButtonText }}\n        </button>\n      </span>\n\n      <button\n        *ngIf=\"isVisibleCloseButton\"\n        (click)=\"closeMessage.emit()\"\n        class=\"close\"\n        type=\"button\"\n      >\n        <cx-icon [type]=\"iconTypes.CLOSE\"></cx-icon>\n      </button>\n    </div>\n\n    <div *ngIf=\"showBody || !accordionText\" class=\"cx-message-body\">\n      <ng-content></ng-content>\n    </div>\n  </div>\n</div>\n", components: [{ type: IconComponent, selector: "cx-icon,[cxIcon]", inputs: ["cxIcon", "type"] }], directives: [{ type: i3.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: MessageComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-message',
                    templateUrl: './message.component.html',
                }]
        }], ctorParameters: function () { return []; }, propDecorators: { text: [{
                type: Input
            }], actionButtonText: [{
                type: Input
            }], accordionText: [{
                type: Input
            }], showBody: [{
                type: Input
            }], isVisibleCloseButton: [{
                type: Input
            }], type: [{
                type: Input
            }], closeMessage: [{
                type: Output
            }], buttonAction: [{
                type: Output
            }] } });

class MessageComponentModule {
}
MessageComponentModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: MessageComponentModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
MessageComponentModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: MessageComponentModule, declarations: [MessageComponent], imports: [CommonModule, IconModule, I18nModule], exports: [MessageComponent] });
MessageComponentModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: MessageComponentModule, imports: [[CommonModule, IconModule, I18nModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: MessageComponentModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, IconModule, I18nModule],
                    declarations: [MessageComponent],
                    exports: [MessageComponent],
                }]
        }] });

class PromotionsModule {
}
PromotionsModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PromotionsModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
PromotionsModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PromotionsModule, declarations: [PromotionsComponent], imports: [CommonModule], exports: [PromotionsComponent] });
PromotionsModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PromotionsModule, imports: [[CommonModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PromotionsModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [PromotionsComponent],
                    exports: [PromotionsComponent],
                }]
        }] });

const LABELS = {
    [LANGUAGE_CONTEXT_ID]: 'Language',
    [CURRENCY_CONTEXT_ID]: 'Currency',
};
class SiteContextComponentService {
    constructor(componentData, contextServiceMap, injector) {
        this.componentData = componentData;
        this.contextServiceMap = contextServiceMap;
        this.injector = injector;
    }
    getItems(context) {
        return this.getService(context).pipe(switchMap((service) => service.getAll()), switchMap((items) => this.getContext(context).pipe(switchMap((ctx) => {
            const itemsCopy = [];
            for (const item of items) {
                itemsCopy.push(Object.assign(Object.assign({}, item), { label: this.getOptionLabel(item, ctx) }));
            }
            return of(itemsCopy);
        }))));
    }
    getActiveItem(context) {
        return this.getService(context).pipe(switchMap((service) => service.getActive()));
    }
    getLabel(context) {
        return this.getContext(context).pipe(map((ctx) => {
            return LABELS[ctx];
        }));
    }
    setActive(value, context) {
        this.getService(context)
            .pipe(take(1))
            .subscribe((service) => {
            service.setActive(value);
        });
    }
    getService(context) {
        return this.getContext(context).pipe(map((ctx) => (ctx ? this.getInjectedService(ctx) : undefined)), filter((s) => !!s));
    }
    getContext(context) {
        if (context) {
            return of(context);
        }
        else if (this.componentData) {
            return this.componentData.data$.pipe(map((data) => data === null || data === void 0 ? void 0 : data.context), map((ctx) => {
                switch (ctx) {
                    case 'LANGUAGE':
                        return LANGUAGE_CONTEXT_ID;
                    case 'CURRENCY':
                        return CURRENCY_CONTEXT_ID;
                    default:
                        return ctx;
                }
            }));
        }
    }
    getInjectedService(context) {
        return this.injector.get(this.contextServiceMap[context], null);
    }
    getOptionLabel(item, context) {
        switch (context) {
            case LANGUAGE_CONTEXT_ID:
                return item.nativeName;
            case CURRENCY_CONTEXT_ID:
                return item.symbol + ' ' + item.isocode;
            default:
                return item.isocode;
        }
    }
}
SiteContextComponentService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SiteContextComponentService, deps: [{ token: CmsComponentData, optional: true }, { token: i1.ContextServiceMap }, { token: i0.Injector }], target: i0.ɵɵFactoryTarget.Injectable });
SiteContextComponentService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SiteContextComponentService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SiteContextComponentService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: CmsComponentData, decorators: [{
                    type: Optional
                }] }, { type: i1.ContextServiceMap }, { type: i0.Injector }]; } });

class SiteContextSelectorComponent {
    constructor(componentService) {
        this.componentService = componentService;
        this.iconTypes = ICON_TYPE;
    }
    get items$() {
        return this.componentService.getItems(this.context);
    }
    get activeItem$() {
        return this.componentService.getActiveItem(this.context);
    }
    set active(value) {
        this.componentService.setActive(value, this.context);
    }
    get label$() {
        return this.componentService.getLabel(this.context);
    }
}
SiteContextSelectorComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SiteContextSelectorComponent, deps: [{ token: SiteContextComponentService }], target: i0.ɵɵFactoryTarget.Component });
SiteContextSelectorComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: SiteContextSelectorComponent, selector: "cx-site-context-selector", inputs: { context: "context" }, ngImport: i0, template: "<label *ngIf=\"(items$ | async)?.length > 1 && (items$ | async) as items\">\n  <span>{{ label$ | async }}</span>\n  <select (change)=\"active = $event.target.value\">\n    <option\n      *ngFor=\"let item of items\"\n      value=\"{{ item.isocode }}\"\n      [selected]=\"(activeItem$ | async) === item.isocode\"\n    >\n      {{ item.label }}\n    </option></select\n  ><cx-icon [type]=\"iconTypes.CARET_DOWN\" class=\"small\"></cx-icon>\n</label>\n", components: [{ type: IconComponent, selector: "cx-icon,[cxIcon]", inputs: ["cxIcon", "type"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], pipes: { "async": i3.AsyncPipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SiteContextSelectorComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-site-context-selector',
                    templateUrl: './site-context-selector.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: SiteContextComponentService }]; }, propDecorators: { context: [{
                type: Input
            }] } });

class LanguageCurrencyComponent {
}
LanguageCurrencyComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: LanguageCurrencyComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
LanguageCurrencyComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: LanguageCurrencyComponent, selector: "cx-language-currency-selector", ngImport: i0, template: `
    <cx-site-context-selector context="language"></cx-site-context-selector>
    <cx-site-context-selector context="currency"></cx-site-context-selector>
  `, isInline: true, components: [{ type: SiteContextSelectorComponent, selector: "cx-site-context-selector", inputs: ["context"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: LanguageCurrencyComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-language-currency-selector',
                    template: `
    <cx-site-context-selector context="language"></cx-site-context-selector>
    <cx-site-context-selector context="currency"></cx-site-context-selector>
  `,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }] });

class SiteContextSelectorModule {
}
SiteContextSelectorModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SiteContextSelectorModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
SiteContextSelectorModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SiteContextSelectorModule, declarations: [SiteContextSelectorComponent, LanguageCurrencyComponent], imports: [CommonModule, RouterModule, SiteContextModule, IconModule], exports: [SiteContextSelectorComponent, LanguageCurrencyComponent] });
SiteContextSelectorModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SiteContextSelectorModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                CMSSiteContextComponent: {
                    component: SiteContextSelectorComponent,
                    providers: [
                        {
                            provide: SiteContextComponentService,
                            useClass: SiteContextComponentService,
                            deps: [CmsComponentData, ContextServiceMap, Injector],
                        },
                    ],
                },
                LanguageCurrencyComponent: {
                    component: LanguageCurrencyComponent,
                },
            },
        }),
        SiteContextComponentService,
    ], imports: [[CommonModule, RouterModule, SiteContextModule, IconModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SiteContextSelectorModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, RouterModule, SiteContextModule, IconModule],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                CMSSiteContextComponent: {
                                    component: SiteContextSelectorComponent,
                                    providers: [
                                        {
                                            provide: SiteContextComponentService,
                                            useClass: SiteContextComponentService,
                                            deps: [CmsComponentData, ContextServiceMap, Injector],
                                        },
                                    ],
                                },
                                LanguageCurrencyComponent: {
                                    component: LanguageCurrencyComponent,
                                },
                            },
                        }),
                        SiteContextComponentService,
                    ],
                    declarations: [SiteContextSelectorComponent, LanguageCurrencyComponent],
                    exports: [SiteContextSelectorComponent, LanguageCurrencyComponent],
                }]
        }] });

var SiteContextType;
(function (SiteContextType) {
    SiteContextType["LANGUAGE"] = "LANGUAGE";
    SiteContextType["CURRENCY"] = "CURRENCY";
})(SiteContextType || (SiteContextType = {}));

/**
 * Star rating component can be used to view existing ratings as well
 * as create new ratings. The component can be used for any ratings.
 */
class StarRatingComponent {
    constructor() {
        this.initialRate = 0;
        this.icon = ICON_TYPE.STAR;
        /**
         * The rating component can be used in disabled mode,
         * so that the interaction is not provided.
         *
         * Defaults to true.
         */
        this.disabled = true;
        /**
         * The rating is used to color the rating stars. It can have a
         * precise number. The rating number is used for a CSS custom property
         * (AKA css variable) value. The actually coloring is done in CSS.
         */
        this.rating = this.initialRate;
        /**
         * Emits the given rating when the user clicks on a star.
         */
        // eslint-disable-next-line @angular-eslint/no-output-native
        this.change = new EventEmitter();
    }
    setRate(value) {
        if (this.disabled) {
            return;
        }
        this.rating = value;
    }
    reset() {
        var _a;
        if (this.disabled) {
            return;
        }
        this.rating = (_a = this.initialRate) !== null && _a !== void 0 ? _a : 0;
    }
    saveRate(rating) {
        if (this.disabled) {
            return;
        }
        this.initialRate = rating;
        this.setRate(rating);
        this.change.emit(rating);
    }
}
StarRatingComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: StarRatingComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
StarRatingComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: StarRatingComponent, selector: "cx-star-rating", inputs: { disabled: "disabled", rating: "rating" }, outputs: { change: "change" }, host: { listeners: { "mouseout": "reset()" }, properties: { "attr.disabled": "this.disabled", "style.--star-fill": "this.rating" } }, ngImport: i0, template: "<cx-icon\n  *ngFor=\"let i of [1, 2, 3, 4, 5]\"\n  [type]=\"icon\"\n  class=\"star\"\n  (mouseover)=\"setRate(i)\"\n  (click)=\"saveRate(i)\"\n  (keydown.space)=\"saveRate(i)\"\n  [attr.tabindex]=\"disabled ? null : 0\"\n></cx-icon>\n", components: [{ type: IconComponent, selector: "cx-icon,[cxIcon]", inputs: ["cxIcon", "type"] }], directives: [{ type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: StarRatingComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-star-rating',
                    templateUrl: './star-rating.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], propDecorators: { disabled: [{
                type: Input
            }, {
                type: HostBinding,
                args: ['attr.disabled']
            }], rating: [{
                type: Input
            }, {
                type: HostBinding,
                args: ['style.--star-fill']
            }], change: [{
                type: Output
            }], reset: [{
                type: HostListener,
                args: ['mouseout']
            }] } });

class StarRatingModule {
}
StarRatingModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: StarRatingModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
StarRatingModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: StarRatingModule, declarations: [StarRatingComponent], imports: [CommonModule, IconModule], exports: [StarRatingComponent] });
StarRatingModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: StarRatingModule, imports: [[CommonModule, IconModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: StarRatingModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, IconModule],
                    declarations: [StarRatingComponent],
                    exports: [StarRatingComponent],
                }]
        }] });

class TableDataCellComponent {
    constructor(outlet) {
        this.outlet = outlet;
    }
    get value() {
        return this.model[this.field];
    }
    get model() {
        var _a;
        return (_a = this.outlet) === null || _a === void 0 ? void 0 : _a.context;
    }
    get field() {
        var _a, _b;
        return (_b = (_a = this.outlet) === null || _a === void 0 ? void 0 : _a.context) === null || _b === void 0 ? void 0 : _b._field;
    }
}
TableDataCellComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: TableDataCellComponent, deps: [{ token: OutletContextData }], target: i0.ɵɵFactoryTarget.Component });
TableDataCellComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: TableDataCellComponent, selector: "cx-table-data-cell", host: { properties: { "attr.title": "this.value" } }, ngImport: i0, template: `{{ value }}`, isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: TableDataCellComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-table-data-cell',
                    template: `{{ value }}`,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: OutletContextData }]; }, propDecorators: { value: [{
                type: HostBinding,
                args: ['attr.title']
            }] } });

class TableHeaderCellComponent {
    constructor(outlet) {
        this.outlet = outlet;
    }
    /**
     * Returns the static label for the given field, if available.
     */
    get header() {
        var _a;
        if (typeof ((_a = this.fieldOptions) === null || _a === void 0 ? void 0 : _a.label) === 'string') {
            return this.fieldOptions.label;
        }
    }
    /**
     * Returns the localized label for the given field.
     *
     * The localized label is either driven by the configured `label.i18nKey`
     * or concatenated by the table `type` and field `key`:
     *
     * `[tableType].[fieldKey]`
     *
     * The localized header can be translated with the `cxTranslate` pipe or `TranslationService`.
     */
    get localizedHeader() {
        var _a, _b;
        return (((_b = (_a = this.fieldOptions) === null || _a === void 0 ? void 0 : _a.label) === null || _b === void 0 ? void 0 : _b.i18nKey) ||
            `${this.i18nRoot}.${this.field}`);
    }
    get fieldOptions() {
        var _a, _b, _c;
        return (_c = (_b = (_a = this.outlet) === null || _a === void 0 ? void 0 : _a.context._options) === null || _b === void 0 ? void 0 : _b.cells) === null || _c === void 0 ? void 0 : _c[this.field];
    }
    get field() {
        var _a, _b;
        return (_b = (_a = this.outlet) === null || _a === void 0 ? void 0 : _a.context) === null || _b === void 0 ? void 0 : _b._field;
    }
    get type() {
        var _a, _b;
        return (_b = (_a = this.outlet) === null || _a === void 0 ? void 0 : _a.context) === null || _b === void 0 ? void 0 : _b._type;
    }
    get i18nRoot() {
        var _a, _b;
        return (_b = (_a = this.outlet) === null || _a === void 0 ? void 0 : _a.context) === null || _b === void 0 ? void 0 : _b._i18nRoot;
    }
}
TableHeaderCellComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: TableHeaderCellComponent, deps: [{ token: OutletContextData }], target: i0.ɵɵFactoryTarget.Component });
TableHeaderCellComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: TableHeaderCellComponent, selector: "cx-table-header-cell", ngImport: i0, template: `{{ header || (localizedHeader | cxTranslate) }}`, isInline: true, pipes: { "cxTranslate": i1.TranslatePipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: TableHeaderCellComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-table-header-cell',
                    template: `{{ header || (localizedHeader | cxTranslate) }}`,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: OutletContextData }]; } });

const defaultTableConfig = {
    tableOptions: {
        headerComponent: TableHeaderCellComponent,
        dataComponent: TableDataCellComponent,
    },
};

/**
 * The `TableConfig` provides a table configurations for specific table types. You can define
 * an all-screen table structure as well as a breakpoint specific table structure. The various
 * table structures are merged from small to large screen configurations, depending on the users
 * screen size.
 *
 * The `table.type` is used as a key to distinguish the various table configurations in the application.
 */
class TableConfig {
}
TableConfig.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: TableConfig, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
TableConfig.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: TableConfig, providedIn: 'root', useExisting: Config });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: TableConfig, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                    useExisting: Config,
                }]
        }] });

class TableDataCellModule {
}
TableDataCellModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: TableDataCellModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
TableDataCellModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: TableDataCellModule, declarations: [TableDataCellComponent], imports: [CommonModule] });
TableDataCellModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: TableDataCellModule, imports: [[CommonModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: TableDataCellModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [TableDataCellComponent],
                }]
        }] });

class TableHeaderCellModule {
}
TableHeaderCellModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: TableHeaderCellModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
TableHeaderCellModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: TableHeaderCellModule, declarations: [TableHeaderCellComponent], imports: [CommonModule, I18nModule] });
TableHeaderCellModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: TableHeaderCellModule, imports: [[CommonModule, I18nModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: TableHeaderCellModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, I18nModule],
                    declarations: [TableHeaderCellComponent],
                }]
        }] });

/**
 * The table renderer service adds a component for each table cells (th and td)
 * based on a fine grained configuration. Each table type can configure both global
 * components for headers and cells as well as individual components for field
 * specific cells.
 *
 * The components are added to the outlet slots for the corresponding cells. The table
 * structure and data is added to the outlet context.
 */
class TableRendererService {
    constructor(outletService, componentFactoryResolver, config) {
        this.outletService = outletService;
        this.componentFactoryResolver = componentFactoryResolver;
        this.config = config;
        // keep a list of outletRefs to avoid recreation
        this.outletRefs = new Map();
    }
    /**
     * Adds the configured table component for the header and data.
     */
    add(structure) {
        var _a;
        (_a = structure === null || structure === void 0 ? void 0 : structure.cells) === null || _a === void 0 ? void 0 : _a.forEach((field) => {
            const thRenderer = this.getHeaderRenderer(structure, field);
            if (thRenderer) {
                const ref = this.getHeaderOutletRef(structure.type, field);
                this.render(ref, thRenderer);
            }
            const tdRenderer = this.getDataRenderer(structure, field);
            if (tdRenderer) {
                const ref = this.getDataOutletRef(structure.type, field);
                this.render(ref, tdRenderer);
            }
        });
    }
    render(outletRef, renderer) {
        if (this.outletRefs.has(outletRef)) {
            return;
        }
        this.outletRefs.set(outletRef, true);
        const template = this.componentFactoryResolver.resolveComponentFactory(renderer);
        this.outletService.add(outletRef, template);
    }
    /**
     * Returns the header render component for the given field.
     */
    getHeaderRenderer(structure, field) {
        var _a, _b, _c, _d, _e;
        return (((_c = (_b = (_a = structure.options) === null || _a === void 0 ? void 0 : _a.cells) === null || _b === void 0 ? void 0 : _b[field]) === null || _c === void 0 ? void 0 : _c.headerComponent) ||
            ((_d = structure.options) === null || _d === void 0 ? void 0 : _d.headerComponent) ||
            ((_e = this.config.tableOptions) === null || _e === void 0 ? void 0 : _e.headerComponent));
    }
    /**
     * Returns the data render component for the given field.
     */
    getDataRenderer(structure, field) {
        var _a, _b, _c, _d, _e;
        return (((_c = (_b = (_a = structure.options) === null || _a === void 0 ? void 0 : _a.cells) === null || _b === void 0 ? void 0 : _b[field]) === null || _c === void 0 ? void 0 : _c.dataComponent) ||
            ((_d = structure.options) === null || _d === void 0 ? void 0 : _d.dataComponent) ||
            ((_e = this.config.tableOptions) === null || _e === void 0 ? void 0 : _e.dataComponent));
    }
    /**
     * Returns the header (th) outlet reference for the given field.
     *
     * The outlet reference is generated as:
     * `table.[tableType].header.[field]`
     */
    getHeaderOutletRef(type, field) {
        return `table.${type}.header.${field}`;
    }
    /**
     * Returns the header (th) outlet context for the given field.
     */
    getHeaderOutletContext(type, options, i18nRoot, field) {
        return {
            _type: type,
            _options: options,
            _field: field,
            _i18nRoot: i18nRoot,
        };
    }
    /**
     * Returns the data (td) outlet reference for the given field.
     *
     * The field is generated as:
     * `table.[tableType].data.[tableField]`
     */
    getDataOutletRef(type, field) {
        return `table.${type}.data.${field}`;
    }
    /**
     * Returns the data (td) outlet context for the given field.
     */
    getDataOutletContext(type, options, i18nRoot, field, data) {
        return Object.assign(Object.assign({}, data), { _type: type, _options: options, _field: field, _i18nRoot: i18nRoot });
    }
}
TableRendererService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: TableRendererService, deps: [{ token: OutletService }, { token: i0.ComponentFactoryResolver }, { token: TableConfig }], target: i0.ɵɵFactoryTarget.Injectable });
TableRendererService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: TableRendererService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: TableRendererService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: OutletService }, { type: i0.ComponentFactoryResolver }, { type: TableConfig }]; } });

/**
 * Layout orientation for the table configuration.
 */
var TableLayout;
(function (TableLayout) {
    /**
     * Renders the table vertically, with a heading on top of the table.
     *
     * Vertical layout is most common and the default layout.
     */
    TableLayout[TableLayout["VERTICAL"] = 1] = "VERTICAL";
    /**
     * Stacks items in a tables by generating a `tbody` for each item.
     */
    TableLayout[TableLayout["VERTICAL_STACKED"] = 2] = "VERTICAL_STACKED";
    /**
     * Horizontal oriented table layout renders the table headers in the first column of the table.
     */
    TableLayout[TableLayout["HORIZONTAL"] = 3] = "HORIZONTAL";
})(TableLayout || (TableLayout = {}));

/**
 * The table component provides a generic table DOM structure, with 3 layout types:
 * horizontal, vertical and _stacked vertical_ layout. The layout is driven by the
 * table structure.
 *
 * The implementation is fairly "dumb" and only renders string based content for TH
 * and TD elements. The actual cell rendering is delegated to a (configurable) cell
 * component. Additionally, each cell is registered as an outlet, so that customizations
 * can be done by both outlet templates and components.
 *
 * The outlet references are concatenated from the table `type` and header `key`. The
 * following snippet shows an outlet generated for a table header, for the table type
 * "cost-center" with a header key "name":
 *
 * ```
 * <th>
 *   <template cxOutlet="table.cost-center.header.name">
 *   </template>
 * </th>
 * ```
 *
 * Similarly, the data cells (`<td>`) are generated with the outlet template reference
 * `table.cost-center.data.name`.
 */
class TableComponent {
    constructor(rendererService) {
        this.rendererService = rendererService;
        this.launch = new EventEmitter();
    }
    set structure(structure) {
        this._structure = structure;
        this.init();
    }
    get structure() {
        return this._structure;
    }
    init() {
        this.verticalLayout = !this.layout || this.layout === TableLayout.VERTICAL;
        this.verticalStackedLayout = this.layout === TableLayout.VERTICAL_STACKED;
        this.horizontalLayout = this.layout === TableLayout.HORIZONTAL;
        this.rendererService.add(this.structure);
        this.addTableDebugInfo();
    }
    launchItem(item) {
        this.launch.emit(item);
    }
    /**
     * Indicates whether the given item is the current item.
     *
     * The current item is driven by the `currentItem`, that holds a
     * property and value to compare.
     */
    isCurrentItem(item) {
        var _a, _b;
        if (!this.currentItem || !this.currentItem.value) {
            return false;
        }
        return ((_a = this.currentItem) === null || _a === void 0 ? void 0 : _a.value) === (item === null || item === void 0 ? void 0 : item[(_b = this.currentItem) === null || _b === void 0 ? void 0 : _b.property]);
    }
    /**
     * Returns the header (th) outlet reference for the given field.
     */
    getHeaderOutletRef(field) {
        return this.rendererService.getHeaderOutletRef(this.type, field);
    }
    /**
     * Returns the header (th) outlet context for the given field.
     */
    getHeaderOutletContext(field) {
        return this.rendererService.getHeaderOutletContext(this.type, this.options, this.i18nRoot, field);
    }
    /**
     * Returns the data (td) outlet reference for the given field.
     */
    getDataOutletRef(field) {
        return this.rendererService.getDataOutletRef(this.type, field);
    }
    /**
     * Returns the data (td) outlet context for the given field.
     */
    getDataOutletContext(field, data) {
        return this.rendererService.getDataOutletContext(this.type, this.options, this.i18nRoot, field, data);
    }
    trackData(_i, item) {
        return JSON.stringify(item);
    }
    /**
     * Generates the table type into the UI in devMode, so that developers
     * can easily get the notion of the table type.
     */
    addTableDebugInfo() {
        if (isDevMode() && this.type) {
            this.tableType = this.type;
        }
    }
    /**
     * Helper method to return the deeply nested orientation configuration.
     */
    get layout() {
        var _a, _b;
        return (_b = (_a = this.structure) === null || _a === void 0 ? void 0 : _a.options) === null || _b === void 0 ? void 0 : _b.layout;
    }
    /**
     * Helper method to return the deeply nested type.
     */
    get type() {
        var _a;
        return (_a = this.structure) === null || _a === void 0 ? void 0 : _a.type;
    }
    get options() {
        var _a;
        return (_a = this.structure) === null || _a === void 0 ? void 0 : _a.options;
    }
}
TableComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: TableComponent, deps: [{ token: TableRendererService }], target: i0.ɵɵFactoryTarget.Component });
TableComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: TableComponent, selector: "cx-table", inputs: { structure: "structure", data: "data", i18nRoot: "i18nRoot", currentItem: "currentItem" }, outputs: { launch: "launch" }, host: { properties: { "attr.__cx-table-type": "this.tableType", "class.horizontal": "this.horizontalLayout", "class.vertical": "this.verticalLayout", "class.vertical-stacked": "this.verticalStackedLayout" } }, ngImport: i0, template: "<table *ngIf=\"structure\">\n  <ng-container *ngIf=\"verticalStackedLayout\">\n    <tbody\n      *ngFor=\"let item of data; trackBy: trackData\"\n      (click)=\"launchItem(item)\"\n      [class.is-current]=\"isCurrentItem(item)\"\n    >\n      <tr *ngFor=\"let cell of structure.cells\" [class]=\"cell\">\n        <th>\n          <ng-template\n            [cxOutlet]=\"getHeaderOutletRef(cell)\"\n            [cxOutletContext]=\"getHeaderOutletContext(cell)\"\n          >\n            {{ cell }}\n          </ng-template>\n        </th>\n        <td>\n          <ng-template\n            [cxOutlet]=\"getDataOutletRef(cell)\"\n            [cxOutletContext]=\"getDataOutletContext(cell, item)\"\n          >\n            {{ item[cell] }}\n          </ng-template>\n        </td>\n      </tr>\n    </tbody>\n  </ng-container>\n\n  <!-- vertical tables render the item  -->\n  <ng-container *ngIf=\"verticalLayout\">\n    <thead>\n      <tr>\n        <th scope=\"col\" *ngFor=\"let cell of structure.cells\" [class]=\"cell\">\n          <ng-template\n            [cxOutlet]=\"getHeaderOutletRef(cell)\"\n            [cxOutletContext]=\"getHeaderOutletContext(cell)\"\n          >\n            {{ cell }}\n          </ng-template>\n        </th>\n      </tr>\n    </thead>\n\n    <tr\n      *ngFor=\"let item of data; trackBy: trackData\"\n      [class.is-current]=\"isCurrentItem(item)\"\n      (click)=\"launchItem(item)\"\n    >\n      <td *ngFor=\"let cell of structure.cells; let i = index\" [class]=\"cell\">\n        <ng-template\n          [cxOutlet]=\"getDataOutletRef(cell)\"\n          [cxOutletContext]=\"getDataOutletContext(cell, item)\"\n        >\n          {{ item[cell] }}\n        </ng-template>\n      </td>\n    </tr>\n  </ng-container>\n\n  <ng-container *ngIf=\"horizontalLayout\">\n    <tr *ngFor=\"let cell of structure.cells\" [class]=\"cell\">\n      <th scope=\"col\">\n        <ng-template\n          [cxOutlet]=\"getHeaderOutletRef(cell)\"\n          [cxOutletContext]=\"getHeaderOutletContext(cell)\"\n        >\n          {{ cell }}\n        </ng-template>\n      </th>\n      <td\n        *ngFor=\"let item of data; trackBy: trackData\"\n        [class.is-current]=\"isCurrentItem(item)\"\n        (click)=\"launchItem(item)\"\n      >\n        <ng-template\n          [cxOutlet]=\"getDataOutletRef(cell)\"\n          [cxOutletContext]=\"getDataOutletContext(cell, item)\"\n        >\n          {{ item[cell] }}\n        </ng-template>\n      </td>\n    </tr>\n  </ng-container>\n</table>\n", directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: OutletDirective, selector: "[cxOutlet]", inputs: ["cxOutlet", "cxOutletContext", "cxOutletDefer"], outputs: ["loaded"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: TableComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-table',
                    templateUrl: './table.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: TableRendererService }]; }, propDecorators: { tableType: [{
                type: HostBinding,
                args: ['attr.__cx-table-type']
            }], horizontalLayout: [{
                type: HostBinding,
                args: ['class.horizontal']
            }], verticalLayout: [{
                type: HostBinding,
                args: ['class.vertical']
            }], verticalStackedLayout: [{
                type: HostBinding,
                args: ['class.vertical-stacked']
            }], structure: [{
                type: Input
            }], data: [{
                type: Input
            }], i18nRoot: [{
                type: Input
            }], currentItem: [{
                type: Input
            }], launch: [{
                type: Output
            }] } });

/**
 * The TableModule provides a table component that is driven by (responsible) configuration.
 */
class TableModule {
}
TableModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: TableModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
TableModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: TableModule, declarations: [TableComponent], imports: [CommonModule,
        OutletModule,
        TableHeaderCellModule,
        TableDataCellModule], exports: [TableComponent] });
TableModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: TableModule, providers: [provideConfig(defaultTableConfig)], imports: [[
            CommonModule,
            OutletModule,
            TableHeaderCellModule,
            TableDataCellModule,
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: TableModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        OutletModule,
                        TableHeaderCellModule,
                        TableDataCellModule,
                    ],
                    declarations: [TableComponent],
                    exports: [TableComponent],
                    providers: [provideConfig(defaultTableConfig)],
                }]
        }] });

/**
 * Responsive table service.
 *
 * The `TableService` is used to build a `TableStructure` by configuration. The configuration
 * allows for breakpoint specific configuration, so that the table can differentiate for
 * various screen sizes.
 *
 * While there are some global options, the configuration is mainly driven by the table _type_.
 *
 * If there is no table configuration for the given type found, a table header structure
 * is generated based on the actual data (if available) or randomly by generating 5 random headers.
 */
class TableService {
    constructor(breakpointService, config) {
        this.breakpointService = breakpointService;
        this.config = config;
    }
    /**
     * Builds the table structure.
     *
     * @param tableType The table type is used  to find the specific table configuration.
     * @param defaultStructure (optional) Default table structure that contains fallback options. More specific options are merged with the default structure.
     * @param data$ (optional) The actual data can be passed in to generate the table structure based on actual data.
     */
    buildStructure(tableType, defaultStructure) {
        if (this.hasTableConfig(tableType)) {
            return this.buildStructureFromConfig(tableType, defaultStructure);
        }
        else {
            return this.buildRandomStructure(tableType);
        }
    }
    /**
     * Returns the table structure by configuration. The configuration can be
     * breakpoint-driven, which means that an alternative header structure can
     * be created per screen size.
     *
     * The breakpoint is resolved by teh `BreakpointService`.
     */
    buildStructureFromConfig(type, defaultStructure) {
        return this.breakpointService.breakpoint$.pipe(map((breakpoint) => (Object.assign(Object.assign({}, this.getTableConfig(type, breakpoint, defaultStructure)), { type }))));
    }
    /**
     * Finds all applicable table configuration for the given type and breakpoint.
     * The default table configuration is merged with all relevant breakpoint
     * configurations.
     *
     * This allows to have some default configurations that apply to all screens, and
     * add configuration options for some screens.
     */
    getTableConfig(type, breakpoint, defaultStructure) {
        var _a, _b;
        if (!((_a = this.config.table) === null || _a === void 0 ? void 0 : _a[type])) {
            return null;
        }
        const relevant = this.findRelevantBreakpoints(breakpoint);
        const closestBreakpoint = [...relevant]
            .reverse()
            .find((br) => { var _a; return !!((_a = this.config.table[type][br]) === null || _a === void 0 ? void 0 : _a.cells); });
        const cells = ((_b = this.config.table[type][closestBreakpoint]) === null || _b === void 0 ? void 0 : _b.cells) ||
            this.config.table[type].cells ||
            (defaultStructure === null || defaultStructure === void 0 ? void 0 : defaultStructure.cells);
        // add all default table configurations
        let options = Object.assign(Object.assign({}, defaultStructure === null || defaultStructure === void 0 ? void 0 : defaultStructure.options), this.config.table[type].options);
        // We merge all table options for smaller breakpoints into the global
        // options, so we inherit options.
        relevant.forEach((br) => {
            var _a, _b, _c;
            options = Object.assign(Object.assign(Object.assign({}, options), (_a = defaultStructure === null || defaultStructure === void 0 ? void 0 : defaultStructure[br]) === null || _a === void 0 ? void 0 : _a.options), (_c = (_b = this.config.table[type]) === null || _b === void 0 ? void 0 : _b[br]) === null || _c === void 0 ? void 0 : _c.options);
        });
        return { cells, options };
    }
    /**
     * Generates the table structure by the help of the first data row.
     */
    buildStructureFromData(type, data$) {
        this.logWarning(`No table configuration found to render table with type "${type}". The table header for "${type}" is generated by the help of the first data item`);
        return data$.pipe(map((data) => {
            const cells = Object.keys(data === null || data === void 0 ? void 0 : data[0]).map((key) => key);
            return { type, cells };
        }));
    }
    /**
     * As a last resort, the table structure is randomly created. The random structure
     * contains 5 headers, so that some of the unknown data is visualized.
     */
    buildRandomStructure(type) {
        this.logWarning(`No data available for "${type}", a random structure is generated (with hidden table headers).`);
        return of({
            type,
            cells: ['unknown', 'unknown', 'unknown', 'unknown', 'unknown'],
        });
    }
    /**
     * Finds all the breakpoints can contribute to the table configuration, from small
     * to current.
     *
     * For example, if the current breakpoint is `MD`, this returns `[XS, SM, MD]`.
     */
    findRelevantBreakpoints(breakpoint) {
        const current = this.breakpointService.breakpoints.indexOf(breakpoint);
        return this.breakpointService.breakpoints.slice(0, current + 1);
    }
    /**
     * Indicates if the there is a configuration for the table available.
     */
    hasTableConfig(tableType) {
        var _a;
        return !!((_a = this.config.table) === null || _a === void 0 ? void 0 : _a[tableType]);
    }
    /**
     * Logs a message in the console to increase developer experience.
     *
     * The message is only logged in dev mode.
     */
    logWarning(message) {
        if (isDevMode()) {
            console.warn(message);
        }
    }
}
TableService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: TableService, deps: [{ token: BreakpointService }, { token: TableConfig }], target: i0.ɵɵFactoryTarget.Injectable });
TableService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: TableService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: TableService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: BreakpointService }, { type: TableConfig }]; } });

class ViewConfig {
}
ViewConfig.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ViewConfig, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
ViewConfig.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ViewConfig, providedIn: 'root', useExisting: Config });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ViewConfig, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                    useExisting: Config,
                }]
        }] });

/*
 * Supplements the anchor links that contain only the hash fragment in the `href` attribute,
 * (e.g. `<a href="#someId">`), by prepending the current location (path and query params),
 * so it becomes a link to a full url
 * e.g. `<a href="https://domain.com/current/path?and=query-params#someId">`.
 *
 * This helps to avoid the undesirable navigation to the homepage URL (`/#someId`)
 * when clicking the original link.
 *
 * It's useful for example for cms-provided content passed to the [innerHTML] directive.
 */
class SupplementHashAnchorsPipe {
    constructor(renderer, winRef) {
        this.renderer = renderer;
        this.winRef = winRef;
    }
    getPath(anchorId) {
        const currentUrlWithoutFragment = this.winRef.location.href.replace(/#.*$/, '');
        return `${currentUrlWithoutFragment}${anchorId}`;
    }
    transform(html) {
        const template = this.renderer.createElement('template');
        template.innerHTML = html.trim();
        const linkNodes = template.content.querySelectorAll('a');
        Array.from(linkNodes).forEach((link) => {
            const href = link.getAttribute('href');
            if ((href === null || href === void 0 ? void 0 : href.indexOf('#')) === 0) {
                this.renderer.setProperty(link, 'href', this.getPath(href));
            }
        });
        return template.innerHTML;
    }
}
SupplementHashAnchorsPipe.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SupplementHashAnchorsPipe, deps: [{ token: i0.Renderer2 }, { token: i1.WindowRef }], target: i0.ɵɵFactoryTarget.Pipe });
SupplementHashAnchorsPipe.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SupplementHashAnchorsPipe, name: "cxSupplementHashAnchors" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SupplementHashAnchorsPipe, decorators: [{
            type: Pipe,
            args: [{ name: 'cxSupplementHashAnchors' }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }, { type: i1.WindowRef }]; } });

class SupplementHashAnchorsModule {
}
SupplementHashAnchorsModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SupplementHashAnchorsModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
SupplementHashAnchorsModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SupplementHashAnchorsModule, declarations: [SupplementHashAnchorsPipe], exports: [SupplementHashAnchorsPipe] });
SupplementHashAnchorsModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SupplementHashAnchorsModule });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SupplementHashAnchorsModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [SupplementHashAnchorsPipe],
                    exports: [SupplementHashAnchorsPipe],
                }]
        }] });

class FileDownloadService {
    /**
     * Triggers the browser downloading of the file from the given URL.
     *
     * @param {string} url URL to file.
     * @param {string} [fileName] The optional parameter for defining filename
     * (including the extension) when saving the file.
     */
    download(url, fileName) {
        const link = document.createElement('a');
        link.setAttribute('href', url);
        link.setAttribute('download', `${fileName}`);
        link.style.visibility = 'hidden';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }
}
FileDownloadService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: FileDownloadService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
FileDownloadService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: FileDownloadService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: FileDownloadService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class ExportCsvFileService {
    constructor(fileDownloadService) {
        this.fileDownloadService = fileDownloadService;
    }
    /**
     * Converts array of objects into CSV data structure.
     *
     * @param objectsArray Array of objects which should be converted to CSV.
     * @param separator Separator for CSV data.
     * @returns Processed string ready to be saved into file.
     */
    convert(objectsArray, separator) {
        return objectsArray.reduce((csvString, row) => {
            const line = row.reduce((currentLine, column) => {
                currentLine += currentLine !== '' ? separator : '';
                const cell = column.includes(separator) ? `"${column}"` : column;
                return `${currentLine}${cell}`;
            }, '');
            return `${csvString}${line}\r\n`;
        }, '');
    }
    /**
     * Creates and download CSV file.
     *
     * @param objectsArray Array of objects which should be converted to CSV.
     * @param separator Separator for CSV data.
     * @param fileOptions Exported file options.
     */
    download(objectsArray, separator, fileOptions) {
        const { fileName, type, extension } = fileOptions;
        const fileContent = this.convert(objectsArray, separator);
        const blob = new Blob([fileContent], { type });
        const url = URL.createObjectURL(blob);
        this.fileDownloadService.download(url, `${fileName}.${extension}`);
    }
}
ExportCsvFileService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ExportCsvFileService, deps: [{ token: FileDownloadService }], target: i0.ɵɵFactoryTarget.Injectable });
ExportCsvFileService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ExportCsvFileService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ExportCsvFileService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: FileDownloadService }]; } });

class FileReaderService {
    /**
     * Load text file
     *
     * @param file text file to extract the data
     * @returns Observable from file reader
     */
    loadTextFile(file) {
        return new Observable((observer) => {
            const fileReader = new FileReader();
            fileReader.readAsText(file);
            fileReader.onload = () => {
                observer.next(fileReader.result);
                observer.complete();
            };
            fileReader.onerror = (error) => {
                fileReader.abort();
                observer.error(error);
            };
        });
    }
}
FileReaderService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: FileReaderService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
FileReaderService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: FileReaderService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: FileReaderService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class ImportCsvFileService {
    constructor(fileReaderService) {
        this.fileReaderService = fileReaderService;
    }
    /**
     * Load CSV file.
     *
     * @param file File we want to load as CSV.
     * @param separator Separator for CSV data.
     * @return {Observable<string[][]>} Imported file
     */
    loadFile(file, separator) {
        return this.fileReaderService
            .loadTextFile(file)
            .pipe(map((res) => this.parse(res, separator)));
    }
    /**
     * Combined csv validation
     *
     * @param file File we want to load as CSV.
     * @param separator Separator for CSV data.
     * @param isDataParsable (optional) Callback for verify that structure type is proper.
     * @param maxEntries (optional) Limitation for maximum entries count.
     * @return {Observable<CsvFileValidationErrors | null>} Result of validation
     */
    validateFile(file, { separator, isDataParsable, maxEntries, }) {
        const errors = {};
        return this.fileReaderService.loadTextFile(file).pipe(tap((data) => {
            this.validateEmpty(data, errors);
        }), map((res) => this.parse(res, separator)), tap((data) => {
            this.validateNotParsable(data, errors, isDataParsable);
            this.validateTooManyEntries(data, errors, maxEntries);
        }), catchError((errors) => of(errors)), map(() => (Object.keys(errors).length === 0 ? null : errors)));
    }
    /**
     * Processes the CSV data
     *
     * @param csvString raw extracted data from CSV
     * @param separator for csv data
     * @param ignoreHeader (optional) flag allows for ignore headers row while reading
     * @returns {string[][]} Parsed file
     */
    parse(csvString, separator, ignoreHeader = true) {
        return csvString
            .split('\n')
            .map((row) => row.split(separator).map((cell) => cell.replace(/"/g, '')))
            .filter((value, index) => !(ignoreHeader && index === 0) && value[0] !== '');
    }
    validateEmpty(data, errors) {
        if (data.toString().length === 0) {
            errors.empty = true;
            throw errors;
        }
    }
    validateTooManyEntries(data, errors, maxEntries) {
        if (maxEntries && data.length > maxEntries) {
            errors.tooManyEntries = { maxEntries };
            throw errors;
        }
    }
    validateNotParsable(data, errors, isDataParsable) {
        if (isDataParsable && !isDataParsable(data)) {
            errors.notParsable = true;
            throw errors;
        }
    }
}
ImportCsvFileService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ImportCsvFileService, deps: [{ token: FileReaderService }], target: i0.ɵɵFactoryTarget.Injectable });
ImportCsvFileService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ImportCsvFileService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ImportCsvFileService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: FileReaderService }]; } });

class FilesFormValidators {
    /**
     * Checks max size of file
     *
     * @param {number} maxSize Max size [MB]
     * @returns Uses 'tooLarge' validator error with maxSize property
     * @memberOf FilesFormValidators
     */
    maxSize(maxSize) {
        return (control) => {
            const errors = {};
            if (maxSize) {
                const files = Array.from(control.value);
                files.forEach((file) => {
                    var _a, _b;
                    if (file.size > maxSize * 1000000) {
                        const invalidFiles = (_b = (_a = errors.tooLarge) === null || _a === void 0 ? void 0 : _a.invalidFiles) !== null && _b !== void 0 ? _b : [];
                        errors.tooLarge = {
                            maxSize,
                            invalidFiles: [...invalidFiles, file.name],
                        };
                    }
                });
            }
            return Object.keys(errors).length === 0 ? null : errors;
        };
    }
}
FilesFormValidators.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: FilesFormValidators, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
FilesFormValidators.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: FilesFormValidators, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: FilesFormValidators, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class CustomFormValidators {
    /**
     * Checks control's value with predefined email regexp
     *
     * NOTE: Use it as a control validator
     *
     * @static
     * @param {AbstractControl} control
     * @returns {(ValidationErrors | null)} Uses 'cxInvalidEmail' validator error
     * @memberof CustomFormValidators
     */
    static emailValidator(control) {
        const email = control.value;
        return email && (!email.length || email.match(EMAIL_PATTERN))
            ? null
            : { cxInvalidEmail: true };
    }
    /**
     * Checks control's value with predefined password regexp
     *
     * NOTE: Use it as a control validator
     *
     * @static
     * @param {AbstractControl} control
     * @returns {(ValidationErrors | null)} Uses 'cxInvalidPassword' validator error
     * @memberof CustomFormValidators
     */
    static passwordValidator(control) {
        const password = control.value;
        return password && (!password.length || password.match(PASSWORD_PATTERN))
            ? null
            : { cxInvalidPassword: true };
    }
    /**
     * Checks if control's value is between 1 and 5
     *
     * NOTE: Use it as a control validator
     *
     * @static
     * @param {AbstractControl} control
     * @returns {(ValidationErrors | null)} Uses 'cxStarRatingEmpty' validator error
     * @memberof CustomFormValidators
     */
    static starRatingEmpty(control) {
        const rating = control.value;
        return rating >= 1 && rating <= 5 ? null : { cxStarRatingEmpty: true };
    }
    /**
     * Checks if two password controls match
     *
     * NOTE: Use it as a form validator and pass password control names as parameters
     *
     * @static
     * @param {string} password First password control name
     * @param {string} passwordConfirmation Second password control name
     * @returns Uses 'cxPasswordsMustMatch' validator error
     * @memberof CustomFormValidators
     */
    static passwordsMustMatch(password, passwordConfirmation) {
        const validator = (formGroup) => controlsMustMatch(formGroup, password, passwordConfirmation, 'cxPasswordsMustMatch');
        return validator;
    }
    /**
     * Checks if two email controls match
     *
     * NOTE: Use it as a form validator and pass email control names as parameters
     *
     * @static
     * @param {string} email First email control name
     * @param {string} emailConfirmation Second email control name
     * @returns Uses 'cxEmailsMustMatch' validator error
     * @memberof CustomFormValidators
     */
    static emailsMustMatch(email, emailConfirmation) {
        const validator = (formGroup) => controlsMustMatch(formGroup, email, emailConfirmation, 'cxEmailsMustMatch');
        return validator;
    }
    /**
     * Checks if control's value is euqal or greater than 0
     *
     * NOTE: Use it as a control validator
     *
     * @static
     * @param {AbstractControl} control
     * @returns {(ValidationErrors | null)} Uses 'cxNegativeAmount' validator error
     * @memberof CustomFormValidators
     */
    static mustBePositive(control) {
        const amount = control.value;
        return amount >= 0 ? null : { cxNegativeAmount: true };
    }
    /**
     * Checks if control's value does not contain any special characters
     *
     * NOTE: Use it as a control validator
     *
     * @static
     * @param {AbstractControl} control
     * @returns {(ValidationErrors | null)} Uses 'cxContainsSpecialCharacters' validator error
     * @memberof CustomFormValidators
     */
    static noSpecialCharacters(control) {
        const forbiddenChars = ['/'];
        const str = String(control.value);
        const containsSpecialChars = forbiddenChars.some((char) => str.includes(char));
        return !containsSpecialChars ? null : { cxContainsSpecialCharacters: true };
    }
    /**
     * Checks if control's value passes pattern
     *
     * NOTE: Use it as a control validator
     *
     * @static
     * @param {(date: string) => boolean} isValidFormat Pattern verification function
     * @returns {(control: AbstractControl): ValidationErrors | null} Uses 'pattern' validator error
     * @memberof CustomFormValidators
     */
    static patternValidation(isValidFormat) {
        const validator = (control) => {
            const errors = {};
            if (control.value &&
                control.value !== '' &&
                !isValidFormat(control.value)) {
                errors.pattern = true;
            }
            return Object.keys(errors).length === 0 ? null : errors;
        };
        return validator;
    }
    /**
     * Checks if two email controls match
     *
     * NOTE: Use it as a form validator and pass dates for range
     *
     * @static
     * @param {string} startDateKey First date control name
     * @param {string} endDateKey Second date control name
     * @param {(value: string) => Date} getDate Converting function
     * @returns Uses 'min' and 'max validator error
     * @memberof CustomFormValidators
     */
    static dateRange(startDateKey, endDateKey, getDate) {
        const validator = (formGroup) => {
            var _a, _b;
            const startDateControl = formGroup.controls[startDateKey];
            const endDateControl = formGroup.controls[endDateKey];
            const startDate = getDate(startDateControl.value);
            const endDate = getDate(endDateControl.value);
            if (!((_a = startDateControl.errors) === null || _a === void 0 ? void 0 : _a.pattern)) {
                if (startDate > endDate) {
                    startDateControl.setErrors({ max: true });
                }
            }
            if (!((_b = endDateControl.errors) === null || _b === void 0 ? void 0 : _b.pattern)) {
                if (endDate < startDate) {
                    endDateControl.setErrors({ min: true });
                }
            }
            return null;
        };
        return validator;
    }
}
/**
 * Generic function for validators, which checks if two passed controls match.
 *
 * @param formGroup
 * @param firstControlName First control to check
 * @param secondControlName Second control to check
 * @param errorName Error which will be returned by validator
 */
function controlsMustMatch(formGroup, firstControlName, secondControlName, errorName) {
    const firstControl = formGroup.controls[firstControlName];
    const secondControl = formGroup.controls[secondControlName];
    if (secondControl.errors && !secondControl.errors[errorName]) {
        return;
    }
    secondControl.setErrors(firstControl.value !== secondControl.value ? { [errorName]: true } : null);
}

const titleScores = {
    mr: 1,
    mrs: 2,
    miss: 3,
    ms: 4,
    dr: 5,
    rev: 6,
};
function sortTitles(title1, title2) {
    if (!titleScores[title1.code] || !titleScores[title2.code]) {
        return 1;
    }
    else {
        return titleScores[title1.code] - titleScores[title2.code];
    }
}

class AppliedCouponsComponent {
    constructor(cartVoucherService) {
        this.cartVoucherService = cartVoucherService;
        this.cartIsLoading = false;
        this.isReadOnly = false;
        this.iconTypes = ICON_TYPE;
    }
    get sortedVouchers() {
        this.vouchers = this.vouchers || [];
        return this.vouchers.slice().sort((a, b) => {
            return a.code.localeCompare(b.code);
        });
    }
    removeVoucher(voucherId) {
        this.cartVoucherService.removeVoucher(voucherId);
    }
}
AppliedCouponsComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AppliedCouponsComponent, deps: [{ token: i1.CartVoucherService }], target: i0.ɵɵFactoryTarget.Component });
AppliedCouponsComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: AppliedCouponsComponent, selector: "cx-applied-coupons", inputs: { vouchers: "vouchers", cartIsLoading: "cartIsLoading", isReadOnly: "isReadOnly" }, ngImport: i0, template: "<div *ngIf=\"isReadOnly; else editableCoupons\">\n  <div *ngIf=\"sortedVouchers.length > 0\">\n    <div class=\"cx-applied-coupon-title\">\n      {{ 'voucher.vouchersApplied' | cxTranslate }}\n    </div>\n  </div>\n  <div\n    *ngFor=\"let voucher of sortedVouchers\"\n    class=\"coupon-summary cx-coupon-card textonly\"\n    role=\"filter\"\n  >\n    <span class=\"cx-applied-coupon-code\">{{ voucher.voucherCode }}</span>\n  </div>\n</div>\n\n<ng-template #editableCoupons>\n  <div class=\"row\">\n    <div\n      *ngFor=\"let voucher of sortedVouchers\"\n      class=\"col-sm-12 col-md-6 col-lg-12 cx-coupon-card-grid\"\n      role=\"filter\"\n    >\n      <div class=\"cx-coupon-apply cx-coupon-card cx-coupon-list-wrap\">\n        <span class=\"cx-cart-coupon-code\">{{ voucher.voucherCode }}</span>\n        <button\n          type=\"button\"\n          class=\"close\"\n          [attr.aria-label]=\"'common.close' | cxTranslate\"\n          (click)=\"removeVoucher(voucher.voucherCode)\"\n          [disabled]=\"cartIsLoading\"\n          [class.disabled]=\"cartIsLoading\"\n        >\n          <span aria-hidden=\"true\">\n            <cx-icon [type]=\"iconTypes.CLOSE\"></cx-icon>\n          </span>\n        </button>\n      </div>\n    </div>\n  </div>\n</ng-template>\n", components: [{ type: IconComponent, selector: "cx-icon,[cxIcon]", inputs: ["cxIcon", "type"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], pipes: { "cxTranslate": i1.TranslatePipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AppliedCouponsComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-applied-coupons',
                    templateUrl: './applied-coupons.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: i1.CartVoucherService }]; }, propDecorators: { vouchers: [{
                type: Input
            }], cartIsLoading: [{
                type: Input
            }], isReadOnly: [{
                type: Input
            }] } });

class CartCouponComponent {
    constructor(cartVoucherService, formBuilder, customerCouponService, activeCartService) {
        this.cartVoucherService = cartVoucherService;
        this.formBuilder = formBuilder;
        this.customerCouponService = customerCouponService;
        this.activeCartService = activeCartService;
        this.MAX_CUSTOMER_COUPON_PAGE = 100;
        this.ignoreCloseEvent = false;
        this.subscription = new Subscription();
        this.couponBoxIsActive = false;
    }
    ngOnInit() {
        if (this.customerCouponService) {
            this.customerCouponService.loadCustomerCoupons(this.MAX_CUSTOMER_COUPON_PAGE);
        }
        this.cart$ = combineLatest([
            this.activeCartService.getActive(),
            this.activeCartService.getActiveCartId(),
            this.customerCouponService.getCustomerCoupons(this.MAX_CUSTOMER_COUPON_PAGE),
        ]).pipe(tap(([cart, activeCardId, customerCoupons]) => {
            this.cartId = activeCardId;
            this.getApplicableCustomerCoupons(cart, customerCoupons.coupons);
        }), map(([cart]) => cart));
        this.cartIsLoading$ = this.activeCartService
            .isStable()
            .pipe(map((loaded) => !loaded));
        this.cartVoucherService.resetAddVoucherProcessingState();
        this.couponForm = this.formBuilder.group({
            couponCode: ['', [Validators.required]],
        });
        // TODO(#7241): Replace process subscriptions with event listeners and drop process for ADD_VOUCHER
        this.subscription.add(this.cartVoucherService
            .getAddVoucherResultSuccess()
            .subscribe((success) => {
            this.onSuccess(success);
        }));
        // TODO(#7241): Replace process subscriptions with event listeners and drop process for ADD_VOUCHER
        this.subscription.add(this.cartVoucherService.getAddVoucherResultError().subscribe((error) => {
            this.onError(error);
        }));
    }
    onError(error) {
        if (error) {
            this.customerCouponService.loadCustomerCoupons(this.MAX_CUSTOMER_COUPON_PAGE);
            this.cartVoucherService.resetAddVoucherProcessingState();
        }
    }
    onSuccess(success) {
        if (success) {
            this.couponForm.reset();
            this.cartVoucherService.resetAddVoucherProcessingState();
        }
    }
    getApplicableCustomerCoupons(cart, coupons) {
        this.applicableCoupons = coupons || [];
        if (cart.appliedVouchers) {
            cart.appliedVouchers.forEach((appliedVoucher) => {
                this.applicableCoupons = this.applicableCoupons.filter((coupon) => coupon.couponId !== appliedVoucher.code);
            });
        }
    }
    applyVoucher() {
        if (this.couponForm.valid) {
            this.cartVoucherService.addVoucher(this.couponForm.value.couponCode, this.cartId);
        }
        else {
            this.couponForm.markAllAsTouched();
        }
    }
    applyCustomerCoupon(couponId) {
        this.cartVoucherService.addVoucher(couponId, this.cartId);
        this.couponBoxIsActive = false;
    }
    close(event) {
        if (!this.ignoreCloseEvent) {
            this.couponBoxIsActive = false;
            if (event && event.target) {
                event.target.blur();
            }
        }
        this.ignoreCloseEvent = false;
    }
    disableClose() {
        this.ignoreCloseEvent = true;
    }
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
        this.cartVoucherService.resetAddVoucherProcessingState();
    }
}
CartCouponComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CartCouponComponent, deps: [{ token: i1.CartVoucherService }, { token: i3$1.FormBuilder }, { token: i1.CustomerCouponService }, { token: i1.ActiveCartService }], target: i0.ɵɵFactoryTarget.Component });
CartCouponComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: CartCouponComponent, selector: "cx-cart-coupon", ngImport: i0, template: "<ng-container *ngIf=\"cart$ | async as cart\">\n  <div class=\"cx-cart-coupon-title\">\n    {{ 'voucher.coupon' | cxTranslate }}\n  </div>\n  <div class=\"form-group\">\n    <form (ngSubmit)=\"applyVoucher()\" [formGroup]=\"couponForm\">\n      <div class=\"cx-cart-coupon-container\">\n        <input\n          aria-required=\"true\"\n          type=\"text\"\n          class=\"form-control input-coupon-code\"\n          formControlName=\"couponCode\"\n          placeholder=\"{{ 'voucher.placeholder' | cxTranslate }} \"\n        />\n        <button\n          class=\"btn btn-block btn-action apply-coupon-button\"\n          type=\"submit\"\n          [disabled]=\"cartIsLoading$ | async\"\n          [class.disabled]=\"cartIsLoading$ | async\"\n        >\n          {{ 'voucher.apply' | cxTranslate }}\n        </button>\n        <cx-form-errors\n          aria-live=\"assertive\"\n          aria-atomic=\"true\"\n          [control]=\"couponForm.get('couponCode')\"\n        ></cx-form-errors>\n      </div>\n    </form>\n  </div>\n\n  <cx-applied-coupons\n    [vouchers]=\"cart.appliedVouchers\"\n    [cartIsLoading]=\"cartIsLoading$ | async\"\n    [isReadOnly]=\"false\"\n  >\n  </cx-applied-coupons>\n\n  <ng-container *ngIf=\"applicableCoupons && applicableCoupons.length > 0\">\n    <div class=\"cx-available-coupon\">\n      <div class=\"title cx-cart-coupon-title\">\n        {{ 'voucher.availableCoupons' | cxTranslate }}\n      </div>\n      <div class=\"message\">\n        {{ 'voucher.availableCouponsLabel' | cxTranslate }}\n      </div>\n      <div class=\"scroll\">\n        <div class=\"coupons card\" *ngFor=\"let coupon of applicableCoupons\">\n          <button\n            (click)=\"applyCustomerCoupon(coupon.couponId)\"\n            class=\"coupon-id link\"\n            [disabled]=\"cartIsLoading$ | async\"\n            [class.disabled]=\"cartIsLoading$ | async\"\n          >\n            {{ coupon.couponId }}\n          </button>\n        </div>\n      </div>\n    </div>\n  </ng-container>\n</ng-container>\n", components: [{ type: FormErrorsComponent, selector: "cx-form-errors", inputs: ["prefix", "translationParams", "control"] }, { type: AppliedCouponsComponent, selector: "cx-applied-coupons", inputs: ["vouchers", "cartIsLoading", "isReadOnly"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3$1.ɵNgNoValidate, selector: "form:not([ngNoForm]):not([ngNativeValidate])" }, { type: i3$1.NgControlStatusGroup, selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { type: i3$1.FormGroupDirective, selector: "[formGroup]", inputs: ["formGroup"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }, { type: i3$1.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { type: i3$1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i3$1.FormControlName, selector: "[formControlName]", inputs: ["disabled", "formControlName", "ngModel"], outputs: ["ngModelChange"] }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], pipes: { "async": i3.AsyncPipe, "cxTranslate": i1.TranslatePipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CartCouponComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-cart-coupon',
                    templateUrl: './cart-coupon.component.html',
                }]
        }], ctorParameters: function () { return [{ type: i1.CartVoucherService }, { type: i3$1.FormBuilder }, { type: i1.CustomerCouponService }, { type: i1.ActiveCartService }]; } });

class CartCouponModule {
}
CartCouponModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CartCouponModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
CartCouponModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CartCouponModule, declarations: [CartCouponComponent, AppliedCouponsComponent], imports: [CommonModule,
        NgSelectModule,
        FormsModule,
        ReactiveFormsModule,
        I18nModule,
        IconModule,
        FormErrorsModule], exports: [CartCouponComponent, AppliedCouponsComponent] });
CartCouponModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CartCouponModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                CartApplyCouponComponent: {
                    component: CartCouponComponent,
                },
            },
        }),
    ], imports: [[
            CommonModule,
            NgSelectModule,
            FormsModule,
            ReactiveFormsModule,
            I18nModule,
            IconModule,
            FormErrorsModule,
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CartCouponModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [CartCouponComponent, AppliedCouponsComponent],
                    exports: [CartCouponComponent, AppliedCouponsComponent],
                    imports: [
                        CommonModule,
                        NgSelectModule,
                        FormsModule,
                        ReactiveFormsModule,
                        I18nModule,
                        IconModule,
                        FormErrorsModule,
                    ],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                CartApplyCouponComponent: {
                                    component: CartCouponComponent,
                                },
                            },
                        }),
                    ],
                }]
        }] });

class CartItemListComponent {
    constructor(activeCartService, selectiveCartService, userIdService, multiCartService) {
        this.activeCartService = activeCartService;
        this.selectiveCartService = selectiveCartService;
        this.userIdService = userIdService;
        this.multiCartService = multiCartService;
        this.subscription = new Subscription();
        this.readonly = false;
        this.hasHeader = true;
        this.options = {
            isSaveForLater: false,
            optionalBtn: null,
        };
        this._items = [];
        this.form = new FormGroup({});
        this.promotionLocation = PromotionLocation.ActiveCart;
    }
    set items(items) {
        this.resolveItems(items);
        this.createForm();
    }
    get items() {
        return this._items;
    }
    set setLoading(value) {
        if (!this.readonly) {
            // Whenever the cart is loading, we disable the complete form
            // to avoid any user interaction with the cart.
            value
                ? this.form.disable({ emitEvent: false })
                : this.form.enable({ emitEvent: false });
        }
    }
    ngOnInit() {
        var _a;
        this.subscription.add((_a = this.userIdService) === null || _a === void 0 ? void 0 : _a.getUserId().subscribe((userId) => (this.userId = userId)));
    }
    /**
     * Resolves items passed to component input and updates 'items' field
     */
    resolveItems(items) {
        var _a;
        if (!items) {
            this._items = [];
            return;
        }
        // The items we're getting from the input do not have a consistent model.
        // In case of a `consignmentEntry`, we need to normalize the data from the orderEntry.
        if (items.every((item) => item.hasOwnProperty('orderEntry'))) {
            this._items = items.map((consignmentEntry) => {
                const entry = Object.assign({}, consignmentEntry.orderEntry);
                entry.quantity = consignmentEntry.quantity;
                return entry;
            });
        }
        else {
            // We'd like to avoid the unnecessary re-renders of unchanged cart items after the data reload.
            // OCC cart entries don't have any unique identifier that we could use in Angular `trackBy`.
            // So we update each array element to the new object only when it's any different to the previous one.
            for (let i = 0; i < Math.max(items.length, this._items.length); i++) {
                if (JSON.stringify((_a = this._items) === null || _a === void 0 ? void 0 : _a[i]) !== JSON.stringify(items[i])) {
                    if (this._items[i] && this.form) {
                        this.form.removeControl(this.getControlName(this._items[i]));
                    }
                    if (!items[i]) {
                        this._items.splice(i, 1);
                    }
                    else {
                        this._items[i] = items[i];
                    }
                }
            }
        }
    }
    /**
     * Creates form models for list items
     */
    createForm() {
        this._items.forEach((item) => {
            const controlName = this.getControlName(item);
            const group = new FormGroup({
                entryNumber: new FormControl(item.entryNumber),
                quantity: new FormControl(item.quantity, { updateOn: 'blur' }),
            });
            this.form.addControl(controlName, group);
            // If we disable form group before adding, disabled status will reset
            // Which forces us to disable control after including to form object
            if (!item.updateable || this.readonly) {
                this.form.controls[controlName].disable();
            }
        });
    }
    getControlName(item) {
        return item.entryNumber.toString();
    }
    removeEntry(item) {
        var _a;
        if (this.selectiveCartService && this.options.isSaveForLater) {
            this.selectiveCartService.removeEntry(item);
        }
        else if (this.cartId && this.userId) {
            (_a = this.multiCartService) === null || _a === void 0 ? void 0 : _a.removeEntry(this.userId, this.cartId, item.entryNumber);
        }
        else {
            this.activeCartService.removeEntry(item);
        }
        delete this.form.controls[this.getControlName(item)];
    }
    getControl(item) {
        return this.form.get(this.getControlName(item)).valueChanges.pipe(
        // eslint-disable-next-line import/no-deprecated
        startWith(null), tap((value) => {
            var _a;
            if (item.updateable && value && !this.readonly) {
                if (this.selectiveCartService && this.options.isSaveForLater) {
                    this.selectiveCartService.updateEntry(value.entryNumber, value.quantity);
                }
                else if (this.cartId && this.userId) {
                    (_a = this.multiCartService) === null || _a === void 0 ? void 0 : _a.updateEntry(this.userId, this.cartId, value.entryNumber, value.quantity);
                }
                else {
                    this.activeCartService.updateEntry(value.entryNumber, value.quantity);
                }
            }
        }), map(() => this.form.get(this.getControlName(item))));
    }
    ngOnDestroy() {
        var _a;
        (_a = this.subscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();
    }
}
CartItemListComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CartItemListComponent, deps: [{ token: i1.ActiveCartService }, { token: i1.SelectiveCartService }, { token: i1.UserIdService }, { token: i1.MultiCartService }], target: i0.ɵɵFactoryTarget.Component });
CartItemListComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: CartItemListComponent, selector: "cx-cart-item-list", inputs: { readonly: "readonly", hasHeader: "hasHeader", options: "options", cartId: "cartId", items: "items", promotionLocation: "promotionLocation", setLoading: ["cartIsLoading", "setLoading"] }, ngImport: i0, template: "<div *ngIf=\"hasHeader\" class=\"d-none d-md-block d-lg-block d-xl-block\">\n  <div class=\"cx-item-list-header row\">\n    <div class=\"cx-item-list-desc col-md-5 col-lg-5 col-xl-6\">\n      {{ 'cartItems.description' | cxTranslate }}\n    </div>\n    <div class=\"cx-item-list-price col-md-3 col-lg-2 col-xl-2\">\n      {{ 'cartItems.itemPrice' | cxTranslate }}\n    </div>\n    <div class=\"cx-item-list-qty col-md-2 col-lg-3 col-xl-2\">\n      {{ 'cartItems.quantity' | cxTranslate }}\n    </div>\n\n    <ng-container *ngIf=\"options.isSaveForLater; else totalHeader\">\n      <div class=\"cx-item-list-total col-md-2 col-lg-2 col-xl-2\">\n        {{ 'saveForLaterItems.stock' | cxTranslate }}\n      </div>\n    </ng-container>\n  </div>\n</div>\n\n<div class=\"cx-item-list-row\" *ngFor=\"let item of items; let i = index\">\n  <div\n    *ngIf=\"getControl(item) | async as control\"\n    class=\"cx-item-list-items\"\n    [class.is-changed]=\"control.get('quantity').disabled\"\n  >\n    <cx-cart-item\n      [item]=\"item\"\n      [quantityControl]=\"control.get('quantity')\"\n      [readonly]=\"readonly\"\n      [promotionLocation]=\"promotionLocation\"\n      [options]=\"options\"\n    >\n    </cx-cart-item>\n  </div>\n</div>\n\n<ng-template #totalHeader>\n  <div class=\"cx-item-list-total col-md-2 col-lg-2 col-xl-2\">\n    {{ 'cartItems.total' | cxTranslate }}\n  </div>\n</ng-template>\n", components: [{ type: CartItemComponent, selector: "cx-cart-item", inputs: ["compact", "item", "readonly", "quantityControl", "promotionLocation", "options"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], pipes: { "cxTranslate": i1.TranslatePipe, "async": i3.AsyncPipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CartItemListComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-cart-item-list',
                    templateUrl: './cart-item-list.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: i1.ActiveCartService }, { type: i1.SelectiveCartService }, { type: i1.UserIdService }, { type: i1.MultiCartService }]; }, propDecorators: { readonly: [{
                type: Input
            }], hasHeader: [{
                type: Input
            }], options: [{
                type: Input
            }], cartId: [{
                type: Input
            }], items: [{
                type: Input,
                args: ['items']
            }], promotionLocation: [{
                type: Input
            }], setLoading: [{
                type: Input,
                args: ['cartIsLoading']
            }] } });

class OrderSummaryComponent {
}
OrderSummaryComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OrderSummaryComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
OrderSummaryComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: OrderSummaryComponent, selector: "cx-order-summary", inputs: { cart: "cart" }, ngImport: i0, template: "<h3>{{ 'orderCost.orderSummary' | cxTranslate }}</h3>\n\n<div class=\"cx-summary-partials\" *ngIf=\"cart\">\n  <div class=\"cx-summary-row\">\n    <div class=\"col-6 cx-summary-label\">\n      {{ 'orderCost.subtotal' | cxTranslate }}\n    </div>\n    <div class=\"col-6 cx-summary-amount\">\n      {{ cart.subTotal?.formattedValue }}\n    </div>\n  </div>\n  <div class=\"cx-summary-row\">\n    <div class=\"col-6 cx-summary-label\">\n      {{\n        (cart.deliveryCost?.formattedValue\n          ? 'orderCost.shipping'\n          : 'orderCost.estimatedShipping'\n        ) | cxTranslate\n      }}\n    </div>\n    <div class=\"col-6 cx-summary-amount\">\n      {{\n        cart.deliveryCost?.formattedValue\n          ? cart.deliveryCost.formattedValue\n          : ('orderCost.toBeDetermined' | cxTranslate)\n      }}\n    </div>\n  </div>\n  <div class=\"cx-summary-row\" *ngIf=\"cart.net; else cartWithoutNet\">\n    <div class=\"col-6 cx-summary-label\">\n      {{ 'orderCost.salesTax' | cxTranslate }}\n    </div>\n    <div class=\"col-6 cx-summary-amount\">\n      {{ cart.totalTax?.formattedValue }}\n    </div>\n  </div>\n  <div class=\"cx-summary-row cx-summary-total\">\n    <div class=\"col-6 cx-summary-label\">\n      {{ 'orderCost.total' | cxTranslate }}\n    </div>\n    <div class=\"col-6 cx-summary-amount\">\n      {{ cart.totalPriceWithTax?.formattedValue }}\n    </div>\n  </div>\n  <div class=\"cx-summary-row\" *ngIf=\"cart.totalDiscounts?.value > 0\">\n    {{ 'orderCost.discount' | cxTranslate }}\n    {{ cart.totalDiscounts?.formattedValue }}\n  </div>\n  <ng-template #cartWithoutNet>\n    <div class=\"cx-summary-row\">\n      {{\n        cart.totalPriceWithTax?.value !== cart.totalPrice?.value\n          ? ('orderCost.grossTax' | cxTranslate)\n          : ('orderCost.grossIncludeTax' | cxTranslate)\n      }}\n      {{ cart.totalTax?.formattedValue }}.\n    </div>\n  </ng-template>\n</div>\n\n<!--\n<cx-promotions\n  *ngIf=\"cart\"\n  [promotions]=\"cart.appliedOrderPromotions\"\n></cx-promotions>\n-->\n\n<ng-container *cxFeatureLevel=\"'1.3'\">\n  <cx-applied-coupons\n    [vouchers]=\"cart.appliedVouchers\"\n    [isReadOnly]=\"true\"\n  ></cx-applied-coupons>\n</ng-container>\n", components: [{ type: AppliedCouponsComponent, selector: "cx-applied-coupons", inputs: ["vouchers", "cartIsLoading", "isReadOnly"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i1.FeatureLevelDirective, selector: "[cxFeatureLevel]", inputs: ["cxFeatureLevel"] }], pipes: { "cxTranslate": i1.TranslatePipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OrderSummaryComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-order-summary',
                    templateUrl: './order-summary.component.html',
                }]
        }], propDecorators: { cart: [{
                type: Input
            }] } });

class CartItemValidationWarningModule {
}
CartItemValidationWarningModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CartItemValidationWarningModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
CartItemValidationWarningModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CartItemValidationWarningModule, declarations: [CartItemValidationWarningComponent], imports: [CommonModule, RouterModule, I18nModule, UrlModule, IconModule], exports: [CartItemValidationWarningComponent] });
CartItemValidationWarningModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CartItemValidationWarningModule, imports: [[CommonModule, RouterModule, I18nModule, UrlModule, IconModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CartItemValidationWarningModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, RouterModule, I18nModule, UrlModule, IconModule],
                    exports: [CartItemValidationWarningComponent],
                    declarations: [CartItemValidationWarningComponent],
                }]
        }] });

class CartSharedModule {
}
CartSharedModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CartSharedModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
CartSharedModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CartSharedModule, declarations: [CartItemComponent,
        OrderSummaryComponent,
        CartItemListComponent], imports: [CommonModule,
        RouterModule,
        CartCouponModule,
        ReactiveFormsModule,
        UrlModule,
        NgbModule,
        PromotionsModule,
        I18nModule,
        IconModule,
        MediaModule,
        ItemCounterModule,
        FeaturesConfigModule,
        ModalModule,
        OutletModule,
        CartItemValidationWarningModule], exports: [CartItemComponent, CartItemListComponent, OrderSummaryComponent] });
CartSharedModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CartSharedModule, imports: [[
            CommonModule,
            RouterModule,
            CartCouponModule,
            ReactiveFormsModule,
            UrlModule,
            NgbModule,
            PromotionsModule,
            I18nModule,
            IconModule,
            MediaModule,
            ItemCounterModule,
            FeaturesConfigModule,
            ModalModule,
            OutletModule,
            CartItemValidationWarningModule,
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CartSharedModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        RouterModule,
                        CartCouponModule,
                        ReactiveFormsModule,
                        UrlModule,
                        NgbModule,
                        PromotionsModule,
                        I18nModule,
                        IconModule,
                        MediaModule,
                        ItemCounterModule,
                        FeaturesConfigModule,
                        ModalModule,
                        OutletModule,
                        CartItemValidationWarningModule,
                    ],
                    declarations: [
                        CartItemComponent,
                        OrderSummaryComponent,
                        CartItemListComponent,
                    ],
                    exports: [CartItemComponent, CartItemListComponent, OrderSummaryComponent],
                }]
        }] });

class AddToCartModule {
}
AddToCartModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AddToCartModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
AddToCartModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AddToCartModule, declarations: [AddToCartComponent, AddedToCartDialogComponent], imports: [CommonModule,
        ReactiveFormsModule,
        CartSharedModule,
        RouterModule,
        SpinnerModule,
        PromotionsModule,
        FeaturesConfigModule,
        UrlModule,
        IconModule,
        I18nModule,
        ItemCounterModule,
        KeyboardFocusModule,
        ModalModule], exports: [AddToCartComponent, AddedToCartDialogComponent] });
AddToCartModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AddToCartModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                ProductAddToCartComponent: {
                    component: AddToCartComponent,
                    data: {
                        inventoryDisplay: false,
                    },
                },
            },
        }),
    ], imports: [[
            CommonModule,
            ReactiveFormsModule,
            CartSharedModule,
            RouterModule,
            SpinnerModule,
            PromotionsModule,
            FeaturesConfigModule,
            UrlModule,
            IconModule,
            I18nModule,
            ItemCounterModule,
            KeyboardFocusModule,
            ModalModule,
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AddToCartModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        ReactiveFormsModule,
                        CartSharedModule,
                        RouterModule,
                        SpinnerModule,
                        PromotionsModule,
                        FeaturesConfigModule,
                        UrlModule,
                        IconModule,
                        I18nModule,
                        ItemCounterModule,
                        KeyboardFocusModule,
                        ModalModule,
                    ],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                ProductAddToCartComponent: {
                                    component: AddToCartComponent,
                                    data: {
                                        inventoryDisplay: false,
                                    },
                                },
                            },
                        }),
                    ],
                    declarations: [AddToCartComponent, AddedToCartDialogComponent],
                    exports: [AddToCartComponent, AddedToCartDialogComponent],
                }]
        }] });

class AddToWishListComponent {
    constructor(wishListService, currentProductService, authService) {
        this.wishListService = wishListService;
        this.currentProductService = currentProductService;
        this.authService = authService;
        this.product$ = this.currentProductService.getProduct().pipe(filter(isNotNullable), tap((product) => this.setStockInfo(product)));
        this.wishListEntries$ = this.wishListService
            .getWishList()
            .pipe(filter((wishlist) => Boolean(wishlist)), map((wishList) => wishList.entries));
        this.userLoggedIn$ = this.authService.isUserLoggedIn();
        this.loading$ = this.wishListService.getWishListLoading();
        this.hasStock = false;
        this.iconTypes = ICON_TYPE;
    }
    add(product) {
        this.wishListService.addEntry(product.code);
    }
    remove(entry) {
        this.wishListService.removeEntry(entry);
    }
    getProductInWishList(product, entries) {
        const item = entries.find((entry) => entry.product.code === product.code);
        return item;
    }
    setStockInfo(product) {
        this.hasStock = Boolean(product.stock && product.stock.stockLevelStatus !== 'outOfStock');
    }
}
AddToWishListComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AddToWishListComponent, deps: [{ token: i1.WishListService }, { token: CurrentProductService }, { token: i1.AuthService }], target: i0.ɵɵFactoryTarget.Component });
AddToWishListComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: AddToWishListComponent, selector: "cx-add-to-wishlist", ngImport: i0, template: "<ng-container *ngIf=\"product$ | async as product\">\n  <ng-container *ngIf=\"userLoggedIn$ | async; else loginPrompt\">\n    <ng-container *ngIf=\"wishListEntries$ | async as entries\">\n      <ng-container *ngIf=\"hasStock\">\n        <div\n          *ngIf=\"getProductInWishList(product, entries) as entry; else addItem\"\n        >\n          <button\n            class=\"btn btn-link button-remove cx-action-link\"\n            (click)=\"remove(entry)\"\n            [disabled]=\"loading$ | async\"\n          >\n            <cx-icon [type]=\"iconTypes.HEART\"></cx-icon>\n            <span class=\"button-text\">{{\n              'addToWishList.remove' | cxTranslate\n            }}</span>\n          </button>\n        </div>\n        <ng-template #addItem>\n          <button\n            class=\"btn btn-link button-add cx-action-link\"\n            (click)=\"add(product)\"\n            [disabled]=\"loading$ | async\"\n          >\n            <cx-icon [type]=\"iconTypes.EMPTY_HEART\"></cx-icon>\n            <span class=\"button-text\">{{\n              'addToWishList.add' | cxTranslate\n            }}</span>\n          </button>\n        </ng-template>\n      </ng-container>\n    </ng-container>\n  </ng-container>\n</ng-container>\n\n<ng-template #loginPrompt>\n  <ng-container *ngIf=\"hasStock\">\n    <a\n      class=\"btn btn-link button-add-link cx-action-link\"\n      [routerLink]=\"{ cxRoute: 'login' } | cxUrl\"\n    >\n      <cx-icon [type]=\"iconTypes.EMPTY_HEART\"></cx-icon>\n      <span class=\"button-text\">{{\n        'addToWishList.anonymous' | cxTranslate\n      }}</span>\n    </a>\n  </ng-container>\n</ng-template>\n", components: [{ type: IconComponent, selector: "cx-icon,[cxIcon]", inputs: ["cxIcon", "type"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i1$1.RouterLinkWithHref, selector: "a[routerLink],area[routerLink]", inputs: ["routerLink", "target", "queryParams", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange", "replaceUrl", "state", "relativeTo"] }], pipes: { "async": i3.AsyncPipe, "cxTranslate": i1.TranslatePipe, "cxUrl": i1.UrlPipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AddToWishListComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-add-to-wishlist',
                    templateUrl: './add-to-wish-list.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: i1.WishListService }, { type: CurrentProductService }, { type: i1.AuthService }]; } });

class AddToWishListModule {
}
AddToWishListModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AddToWishListModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
AddToWishListModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AddToWishListModule, declarations: [AddToWishListComponent], imports: [CommonModule, I18nModule, IconModule, RouterModule, UrlModule], exports: [AddToWishListComponent] });
AddToWishListModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AddToWishListModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                AddToWishListComponent: {
                    component: AddToWishListComponent,
                },
            },
        }),
    ], imports: [[CommonModule, I18nModule, IconModule, RouterModule, UrlModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AddToWishListModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, I18nModule, IconModule, RouterModule, UrlModule],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                AddToWishListComponent: {
                                    component: AddToWishListComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [AddToWishListComponent],
                    exports: [AddToWishListComponent],
                }]
        }] });

class CartValidationWarningsComponent {
    constructor(cartValidationStateService) {
        this.cartValidationStateService = cartValidationStateService;
        this.iconTypes = ICON_TYPE;
        this.visibleWarnings = {};
        this.cartModifications$ = this.cartValidationStateService.cartValidationResult$.pipe(map((modificationList) => {
            const result = modificationList.filter((modification) => modification.statusCode === CartValidationStatusCode.NO_STOCK);
            result.forEach((modification) => {
                var _a, _b;
                if ((_b = (_a = modification.entry) === null || _a === void 0 ? void 0 : _a.product) === null || _b === void 0 ? void 0 : _b.code) {
                    this.visibleWarnings[modification.entry.product.code] = true;
                }
            });
            return result;
        }));
    }
    removeMessage(cartModification) {
        var _a, _b;
        if ((_b = (_a = cartModification.entry) === null || _a === void 0 ? void 0 : _a.product) === null || _b === void 0 ? void 0 : _b.code) {
            this.visibleWarnings[cartModification.entry.product.code] = false;
        }
    }
}
CartValidationWarningsComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CartValidationWarningsComponent, deps: [{ token: CartValidationStateService }], target: i0.ɵɵFactoryTarget.Component });
CartValidationWarningsComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: CartValidationWarningsComponent, selector: "cx-cart-validation-warnings", ngImport: i0, template: "<ng-container *ngFor=\"let cartModification of cartModifications$ | async\">\n  <div\n    class=\"alert alert-danger\"\n    *ngIf=\"visibleWarnings[cartModification.entry.product.code]\"\n  >\n    <span class=\"alert-icon\">\n      <cx-icon [type]=\"iconTypes.ERROR\"></cx-icon>\n    </span>\n    <span>\n      <a\n        [routerLink]=\"\n          { cxRoute: 'product', params: cartModification.entry.product } | cxUrl\n        \"\n      >\n        {{ cartModification.entry.product.name }}\n      </a>\n      {{ 'validation.productOutOfStock' | cxTranslate }}\n    </span>\n\n    <button\n      class=\"close\"\n      type=\"button\"\n      (click)=\"removeMessage(cartModification)\"\n    >\n      <cx-icon [type]=\"iconTypes.CLOSE\"></cx-icon>\n    </button>\n  </div>\n</ng-container>\n", components: [{ type: IconComponent, selector: "cx-icon,[cxIcon]", inputs: ["cxIcon", "type"] }], directives: [{ type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i1$1.RouterLinkWithHref, selector: "a[routerLink],area[routerLink]", inputs: ["routerLink", "target", "queryParams", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange", "replaceUrl", "state", "relativeTo"] }], pipes: { "async": i3.AsyncPipe, "cxUrl": i1.UrlPipe, "cxTranslate": i1.TranslatePipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CartValidationWarningsComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-cart-validation-warnings',
                    templateUrl: './cart-validation-warnings.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: CartValidationStateService }]; } });

class CartDetailsComponent {
    constructor(activeCartService, selectiveCartService, authService, routingService) {
        this.activeCartService = activeCartService;
        this.selectiveCartService = selectiveCartService;
        this.authService = authService;
        this.routingService = routingService;
        this.loggedIn = false;
        this.promotionLocation = PromotionLocation.ActiveCart;
    }
    ngOnInit() {
        this.cart$ = this.activeCartService.getActive();
        this.entries$ = this.activeCartService
            .getEntries()
            .pipe(filter((entries) => entries.length > 0));
        this.selectiveCartEnabled = this.selectiveCartService.isEnabled();
        this.cartLoaded$ = combineLatest([
            this.activeCartService.isStable(),
            this.selectiveCartEnabled
                ? this.selectiveCartService.isStable()
                : of(false),
            this.authService.isUserLoggedIn(),
        ]).pipe(tap(([, , loggedIn]) => (this.loggedIn = loggedIn)), map(([cartLoaded, sflLoaded, loggedIn]) => loggedIn && this.selectiveCartEnabled
            ? cartLoaded && sflLoaded
            : cartLoaded));
    }
    saveForLater(item) {
        if (this.loggedIn) {
            this.activeCartService.removeEntry(item);
            this.selectiveCartService.addEntry(item.product.code, item.quantity);
        }
        else {
            this.routingService.go({ cxRoute: 'login' });
        }
    }
}
CartDetailsComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CartDetailsComponent, deps: [{ token: i1.ActiveCartService }, { token: i1.SelectiveCartService }, { token: i1.AuthService }, { token: i1.RoutingService }], target: i0.ɵɵFactoryTarget.Component });
CartDetailsComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: CartDetailsComponent, selector: "cx-cart-details", ngImport: i0, template: "<ng-container *ngIf=\"cart$ | async as cart\">\n  <ng-container *ngIf=\"entries$ | async as entries\">\n    <div *ngIf=\"cart.totalItems > 0\" class=\"cart-details-wrapper\">\n      <ng-container *cxFeatureLevel=\"'4.2'\">\n        <cx-cart-validation-warnings></cx-cart-validation-warnings>\n      </ng-container>\n\n      <h4 class=\"cx-total\">\n        {{ 'cartDetails.cartName' | cxTranslate: { code: cart.code } }}\n      </h4>\n\n      <cx-promotions\n        [promotions]=\"\n          (cart.appliedOrderPromotions || []).concat(\n            cart.potentialOrderPromotions || []\n          )\n        \"\n      ></cx-promotions>\n\n      <cx-cart-item-list\n        [items]=\"entries\"\n        [cartIsLoading]=\"!(cartLoaded$ | async)\"\n        [promotionLocation]=\"promotionLocation\"\n        [options]=\"{\n          isSaveForLater: false,\n          optionalBtn: saveForLaterBtn\n        }\"\n      ></cx-cart-item-list>\n    </div>\n  </ng-container>\n</ng-container>\n\n<ng-template let-ctx #saveForLaterBtn>\n  <div\n    *ngIf=\"selectiveCartEnabled\"\n    class=\"col-md-3 col-lg-3 col-xl-3 cx-sfl-btn\"\n  >\n    <button\n      class=\"link cx-action-link\"\n      [disabled]=\"ctx.loading\"\n      (click)=\"saveForLater(ctx.item)\"\n      type=\"button\"\n    >\n      {{ 'saveForLaterItems.saveForLater' | cxTranslate }}\n    </button>\n  </div>\n</ng-template>\n", components: [{ type: CartValidationWarningsComponent, selector: "cx-cart-validation-warnings" }, { type: PromotionsComponent, selector: "cx-promotions", inputs: ["promotions"] }, { type: CartItemListComponent, selector: "cx-cart-item-list", inputs: ["readonly", "hasHeader", "options", "cartId", "items", "promotionLocation", "cartIsLoading"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i1.FeatureLevelDirective, selector: "[cxFeatureLevel]", inputs: ["cxFeatureLevel"] }], pipes: { "async": i3.AsyncPipe, "cxTranslate": i1.TranslatePipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CartDetailsComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-cart-details',
                    templateUrl: './cart-details.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: i1.ActiveCartService }, { type: i1.SelectiveCartService }, { type: i1.AuthService }, { type: i1.RoutingService }]; } });

class CartValidationWarningsModule {
}
CartValidationWarningsModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CartValidationWarningsModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
CartValidationWarningsModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CartValidationWarningsModule, declarations: [CartValidationWarningsComponent], imports: [CommonModule, RouterModule, I18nModule, UrlModule, IconModule], exports: [CartValidationWarningsComponent] });
CartValidationWarningsModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CartValidationWarningsModule, imports: [[CommonModule, RouterModule, I18nModule, UrlModule, IconModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CartValidationWarningsModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, RouterModule, I18nModule, UrlModule, IconModule],
                    exports: [CartValidationWarningsComponent],
                    declarations: [CartValidationWarningsComponent],
                }]
        }] });

class CartDetailsModule {
}
CartDetailsModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CartDetailsModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
CartDetailsModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CartDetailsModule, declarations: [CartDetailsComponent], imports: [CartSharedModule,
        CommonModule,
        CartCouponModule,
        RouterModule,
        UrlModule,
        PromotionsModule,
        FeaturesConfigModule,
        I18nModule,
        CartValidationWarningsModule], exports: [CartDetailsComponent] });
CartDetailsModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CartDetailsModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                CartComponent: {
                    component: CartDetailsComponent,
                },
            },
        }),
    ], imports: [[
            CartSharedModule,
            CommonModule,
            CartCouponModule,
            RouterModule,
            UrlModule,
            PromotionsModule,
            FeaturesConfigModule,
            I18nModule,
            CartValidationWarningsModule,
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CartDetailsModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CartSharedModule,
                        CommonModule,
                        CartCouponModule,
                        RouterModule,
                        UrlModule,
                        PromotionsModule,
                        FeaturesConfigModule,
                        I18nModule,
                        CartValidationWarningsModule,
                    ],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                CartComponent: {
                                    component: CartDetailsComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [CartDetailsComponent],
                    exports: [CartDetailsComponent],
                }]
        }] });

class CartPageLayoutHandler {
    constructor(activeCartService, selectiveCartService) {
        this.activeCartService = activeCartService;
        this.selectiveCartService = selectiveCartService;
    }
    handle(slots$, pageTemplate, section) {
        if (pageTemplate === 'CartPageTemplate' && !section) {
            return combineLatest([
                slots$,
                this.activeCartService.getActive(),
                this.selectiveCartService.isEnabled()
                    ? this.selectiveCartService.getCart()
                    : of({}),
                this.activeCartService.getLoading(),
            ]).pipe(map(([slots, cart, selectiveCart, loadingCart]) => {
                const exclude = (arr, args) => arr.filter((item) => args.every((arg) => arg !== item));
                return Object.keys(cart).length === 0 && loadingCart
                    ? exclude(slots, [
                        'TopContent',
                        'CenterRightContentSlot',
                        'EmptyCartMiddleContent',
                    ])
                    : cart.totalItems
                        ? exclude(slots, ['EmptyCartMiddleContent'])
                        : selectiveCart.totalItems
                            ? exclude(slots, [
                                'EmptyCartMiddleContent',
                                'CenterRightContentSlot',
                            ])
                            : exclude(slots, ['TopContent', 'CenterRightContentSlot']);
            }));
        }
        return slots$;
    }
}
CartPageLayoutHandler.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CartPageLayoutHandler, deps: [{ token: i1.ActiveCartService }, { token: i1.SelectiveCartService }], target: i0.ɵɵFactoryTarget.Injectable });
CartPageLayoutHandler.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CartPageLayoutHandler, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CartPageLayoutHandler, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.ActiveCartService }, { type: i1.SelectiveCartService }]; } });

var ProductImportStatus;
(function (ProductImportStatus) {
    ProductImportStatus["SUCCESS"] = "success";
    ProductImportStatus["LOW_STOCK"] = "lowStock";
    ProductImportStatus["NO_STOCK"] = "noStock";
    ProductImportStatus["UNKNOWN_IDENTIFIER"] = "unknownIdentifier";
    ProductImportStatus["UNKNOWN_ERROR"] = "unknownError";
    ProductImportStatus["LIMIT_EXCEEDED"] = "limitExceeded";
})(ProductImportStatus || (ProductImportStatus = {}));

/**
 * An abstract class for contexts based on cart (active cart, saved cart) which share part of logic - mainly handle cart actions and map results.
 */
class CartOrderEntriesContext {
    constructor(actionsSubject) {
        this.actionsSubject = actionsSubject;
    }
    addEntries(products) {
        return this.add(products).pipe(switchMap((cartId) => this.getResults(cartId)), take(products.length));
    }
    /**
     * Get emission of add entry results from actions subject
     *
     * @param {string} cartId
     * @returns {Observable<ProductImportInfo>}
     */
    getResults(cartId) {
        return this.actionsSubject.pipe(ofType(CartActions.CART_ADD_ENTRY_SUCCESS, CartActions.CART_ADD_ENTRY_FAIL), filter((action) => action.payload.cartId === cartId), map((action) => this.mapMessages(action)));
    }
    /**
     * Map actions to summary messages
     *
     * @param {CartActions.CartAddEntrySuccess | CartActions.CartAddEntryFail} action
     * @returns ProductImportInfo
     */
    mapMessages(action) {
        var _a, _b, _c;
        const { productCode } = action.payload;
        if (action instanceof CartActions.CartAddEntrySuccess) {
            const { quantity, quantityAdded, entry, statusCode } = action.payload;
            if (statusCode === ProductImportStatus.LOW_STOCK) {
                return {
                    productCode,
                    statusCode,
                    productName: (_a = entry === null || entry === void 0 ? void 0 : entry.product) === null || _a === void 0 ? void 0 : _a.name,
                    quantity,
                    quantityAdded,
                };
            }
            if (statusCode === ProductImportStatus.SUCCESS ||
                statusCode === ProductImportStatus.NO_STOCK) {
                return { productCode, statusCode, productName: (_b = entry === null || entry === void 0 ? void 0 : entry.product) === null || _b === void 0 ? void 0 : _b.name };
            }
        }
        else if (action instanceof CartActions.CartAddEntryFail) {
            const { error } = action.payload;
            if (((_c = error === null || error === void 0 ? void 0 : error.details[0]) === null || _c === void 0 ? void 0 : _c.type) === 'UnknownIdentifierError') {
                return {
                    productCode,
                    statusCode: ProductImportStatus.UNKNOWN_IDENTIFIER,
                };
            }
        }
        if (isDevMode()) {
            console.warn('Unrecognized cart add entry action type while mapping messages', action);
        }
        return { productCode, statusCode: ProductImportStatus.UNKNOWN_ERROR };
    }
}

var OrderEntriesSource;
(function (OrderEntriesSource) {
    OrderEntriesSource["ACTIVE_CART"] = "ACTIVE_CART";
    OrderEntriesSource["NEW_SAVED_CART"] = "NEW_SAVED_CART";
    OrderEntriesSource["QUICK_ORDER"] = "QUICK_ORDER";
    OrderEntriesSource["SAVED_CART"] = "SAVED_CART";
    OrderEntriesSource["ORDER_CONFIRMATION"] = "ORDER_CONFIRMATION";
    OrderEntriesSource["ORDER_DETAILS"] = "ORDER_DETAILS";
})(OrderEntriesSource || (OrderEntriesSource = {}));

class ActiveCartOrderEntriesContext extends CartOrderEntriesContext {
    constructor(actionsSubject, activeCartService) {
        super(actionsSubject);
        this.actionsSubject = actionsSubject;
        this.activeCartService = activeCartService;
        this.type = OrderEntriesSource.ACTIVE_CART;
    }
    getEntries() {
        return this.activeCartService.getEntries();
    }
    add(products) {
        this.activeCartService.addEntries(this.mapProductsToOrderEntries(products));
        return this.activeCartService.getActiveCartId();
    }
    mapProductsToOrderEntries(products) {
        return products.map((product) => ({
            product: { code: product.productCode },
            quantity: product.quantity,
        }));
    }
}
ActiveCartOrderEntriesContext.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ActiveCartOrderEntriesContext, deps: [{ token: i1$5.ActionsSubject }, { token: i1.ActiveCartService }], target: i0.ɵɵFactoryTarget.Injectable });
ActiveCartOrderEntriesContext.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ActiveCartOrderEntriesContext, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ActiveCartOrderEntriesContext, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1$5.ActionsSubject }, { type: i1.ActiveCartService }]; } });

class CartTotalsComponent {
    constructor(activeCartService, router) {
        this.activeCartService = activeCartService;
        this.router = router;
        this.cartValidationInProgress = false;
        this.subscription = new Subscription();
    }
    ngOnInit() {
        var _a;
        this.cart$ = this.activeCartService.getActive();
        this.entries$ = this.activeCartService
            .getEntries()
            .pipe(filter((entries) => entries.length > 0));
        this.subscription.add((_a = this.router) === null || _a === void 0 ? void 0 : _a.events.subscribe((event) => {
            if (event instanceof NavigationEnd ||
                event instanceof NavigationCancel) {
                this.cartValidationInProgress = false;
            }
        }));
    }
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
    disableButtonWhileNavigation() {
        this.cartValidationInProgress = true;
    }
}
CartTotalsComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CartTotalsComponent, deps: [{ token: i1.ActiveCartService }, { token: i1$1.Router }], target: i0.ɵɵFactoryTarget.Component });
CartTotalsComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: CartTotalsComponent, selector: "cx-cart-totals", ngImport: i0, template: "<ng-container *ngIf=\"cart$ | async as cart\">\n  <ng-container *ngIf=\"entries$ | async as entries\">\n    <cx-order-summary [cart]=\"cart\"></cx-order-summary>\n    <ng-container *cxFeatureLevel=\"'!4.2'\">\n      <button\n        [routerLink]=\"{ cxRoute: 'checkout' } | cxUrl\"\n        *ngIf=\"entries.length\"\n        class=\"btn btn-primary btn-block\"\n        type=\"button\"\n      >\n        {{ 'cartDetails.proceedToCheckout' | cxTranslate }}\n      </button>\n    </ng-container>\n\n    <ng-container *cxFeatureLevel=\"'4.2'\">\n      <cx-progress-button\n        *ngIf=\"entries.length\"\n        [routerLink]=\"{ cxRoute: 'checkout' } | cxUrl\"\n        [loading]=\"cartValidationInProgress\"\n        [disabled]=\"cartValidationInProgress\"\n        [class]=\"'btn btn-primary btn-block'\"\n        (clikEvent)=\"disableButtonWhileNavigation()\"\n      >\n        {{\n          (!cartValidationInProgress ? 'cartDetails.proceedToCheckout' : '')\n            | cxTranslate\n        }}\n      </cx-progress-button>\n    </ng-container>\n  </ng-container>\n</ng-container>\n", components: [{ type: OrderSummaryComponent, selector: "cx-order-summary", inputs: ["cart"] }, { type: ProgressButtonComponent, selector: "cx-progress-button", inputs: ["ariaLabel", "class", "disabled", "loading"], outputs: ["clikEvent"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i1.FeatureLevelDirective, selector: "[cxFeatureLevel]", inputs: ["cxFeatureLevel"] }, { type: i1$1.RouterLink, selector: ":not(a):not(area)[routerLink]", inputs: ["routerLink", "queryParams", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange", "replaceUrl", "state", "relativeTo"] }], pipes: { "async": i3.AsyncPipe, "cxUrl": i1.UrlPipe, "cxTranslate": i1.TranslatePipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CartTotalsComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-cart-totals',
                    templateUrl: './cart-totals.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: i1.ActiveCartService }, { type: i1$1.Router }]; } });

class CartTotalsModule {
}
CartTotalsModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CartTotalsModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
CartTotalsModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CartTotalsModule, declarations: [CartTotalsComponent], imports: [CommonModule,
        RouterModule,
        UrlModule,
        CartSharedModule,
        I18nModule,
        CartCouponModule,
        FeaturesConfigModule,
        ProgressButtonModule], exports: [CartTotalsComponent] });
CartTotalsModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CartTotalsModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                CartTotalsComponent: {
                    component: CartTotalsComponent,
                },
            },
        }),
    ], imports: [[
            CommonModule,
            RouterModule,
            UrlModule,
            CartSharedModule,
            I18nModule,
            CartCouponModule,
            FeaturesConfigModule,
            ProgressButtonModule,
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CartTotalsModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        RouterModule,
                        UrlModule,
                        CartSharedModule,
                        I18nModule,
                        CartCouponModule,
                        FeaturesConfigModule,
                        ProgressButtonModule,
                    ],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                CartTotalsComponent: {
                                    component: CartTotalsComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [CartTotalsComponent],
                    exports: [CartTotalsComponent],
                }]
        }] });

const PAGE_LAYOUT_HANDLER = new InjectionToken('PageLayoutHandler');

class PageLayoutService {
    constructor(cms, config, breakpointService, handlers) {
        this.cms = cms;
        this.config = config;
        this.breakpointService = breakpointService;
        this.handlers = handlers;
        // Prints warn messages for missing layout configs.
        // The warnings are only printed once per config
        // to not pollute the console log.
        this.warnLogMessages = {};
        this.logSlots = {};
    }
    getSlots(section) {
        return combineLatest([this.page$, this.breakpointService.breakpoint$]).pipe(map(([page, breakpoint]) => {
            const pageTemplate = page.template;
            const slots = this.resolveSlots(page, section, breakpoint);
            return { slots, pageTemplate, breakpoint };
        }), switchMap(({ slots, pageTemplate, breakpoint }) => {
            let result = of(slots);
            for (const handler of this.handlers || []) {
                result = handler.handle(result, pageTemplate, section, breakpoint);
            }
            return result;
        }), distinctUntilChanged((a, b) => {
            if (a.length !== b.length) {
                return false;
            }
            for (let i = 0; i < a.length; i++) {
                if (a[i] !== b[i]) {
                    return false;
                }
            }
            return true;
        }));
    }
    /**
     * Returns an observable with the last page slot above-the-fold
     * for the given pageTemplate / breakpoint.
     *
     * The page fold is configurable in the `LayoutConfig` for each page layout.
     */
    getPageFoldSlot(pageTemplate) {
        return this.breakpointService.breakpoint$.pipe(map((breakpoint) => {
            if (!this.config.layoutSlots) {
                // no layout config available
                return null;
            }
            const pageTemplateConfig = this.config.layoutSlots[pageTemplate];
            const config = this.getResponsiveSlotConfig(pageTemplateConfig, 'pageFold', breakpoint);
            return config ? config.pageFold : null;
        }));
    }
    resolveSlots(page, section, breakpoint) {
        const config = this.getSlotConfig(page.template, 'slots', section, breakpoint);
        if (config && config.slots) {
            const pageSlots = Object.keys(page.slots);
            return config.slots.filter((slot) => pageSlots.includes(slot));
        }
        else if (!section) {
            this.logMissingLayoutConfig(page);
            return Object.keys(page.slots);
        }
        else {
            this.logMissingLayoutConfig(page, section);
            return [];
        }
    }
    get page$() {
        return this.cms.getCurrentPage().pipe(filter((page) => !!page));
    }
    get templateName$() {
        return this.page$.pipe(filter((page) => !!page.template), map((page) => page.template));
    }
    /**
     * load slots from the layout configuration. The breakpoint is used
     * to load a specific configuration for the given breakpoint. If there's
     * no configuration available for the given breakpoint the default slot
     * configuration is returned.
     */
    getSlotConfig(templateUid, configAttribute, section, breakpoint) {
        if (!this.config.layoutSlots) {
            return null;
        }
        const pageTemplateConfig = this.config.layoutSlots[templateUid];
        if (section) {
            return this.getSlotConfigForSection(templateUid, configAttribute, section, breakpoint);
        }
        if (pageTemplateConfig) {
            return this.getResponsiveSlotConfig(pageTemplateConfig, configAttribute, breakpoint);
        }
    }
    getSlotConfigForSection(templateUid, configAttribute, section, breakpoint) {
        const pageTemplateConfig = this.config.layoutSlots[templateUid];
        if (!pageTemplateConfig) {
            return null;
        }
        // if there's no section config on the page layout
        // we fall back to the global section config
        const sectionConfig = pageTemplateConfig[section]
            ? pageTemplateConfig[section]
            : this.config.layoutSlots[section];
        if (!sectionConfig) {
            return null;
        }
        const responsiveConfig = this.getResponsiveSlotConfig(sectionConfig, configAttribute, breakpoint);
        if (responsiveConfig.hasOwnProperty(configAttribute)) {
            return responsiveConfig;
        }
        else if (pageTemplateConfig[section].hasOwnProperty(configAttribute)) {
            return pageTemplateConfig[section];
        }
        else if (this.config.layoutSlots[section]) {
            return this.config.layoutSlots[section];
        }
    }
    /**
     * Returns a list of slots for a breakpoint specific configuration
     * If there's no specific configuration for the breakpoint,
     * the closest available configuration will be returned.
     */
    getResponsiveSlotConfig(layoutSlotConfig, configAttribute, breakpoint) {
        let slotConfig = layoutSlotConfig;
        // fallback to default slot config
        if (!layoutSlotConfig || !breakpoint) {
            return slotConfig;
        }
        // we have a config for the specific breakpoint
        if (layoutSlotConfig[breakpoint] &&
            layoutSlotConfig[breakpoint].hasOwnProperty(configAttribute)) {
            return layoutSlotConfig[breakpoint];
        }
        // find closest config
        const all = this.breakpointService.breakpoints;
        for (const br of all.slice(0, all.indexOf(breakpoint))) {
            if (layoutSlotConfig[br] &&
                layoutSlotConfig[br].hasOwnProperty(configAttribute)) {
                slotConfig = layoutSlotConfig[br];
            }
        }
        return slotConfig;
    }
    /**
     * In order to help developers, we print some detailed log information in
     * case there's no layout configuration available for the given page template
     * or section. Additionally, the slot positions are printed in the console
     * in a format that can be copied / paste to the configuration.
     */
    logMissingLayoutConfig(page, section) {
        if (!isDevMode()) {
            return;
        }
        if (!this.logSlots[page.template]) {
            // the info log is not printed in production
            // eslint-disable-next-line no-console
            console.info(`Available CMS page slots: '${Object.keys(page.slots).join(`','`)}'`);
            this.logSlots[page.template] = true;
        }
        const cacheKey = section || page.template;
        if (!this.warnLogMessages[cacheKey]) {
            console.warn(`No layout config found for ${cacheKey}, you can configure a 'LayoutConfig' to control the rendering of page slots.`);
            this.warnLogMessages[cacheKey] = true;
        }
    }
}
PageLayoutService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PageLayoutService, deps: [{ token: i1.CmsService }, { token: LayoutConfig }, { token: BreakpointService }, { token: PAGE_LAYOUT_HANDLER, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });
PageLayoutService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PageLayoutService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PageLayoutService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.CmsService }, { type: LayoutConfig }, { type: BreakpointService }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [PAGE_LAYOUT_HANDLER]
                }] }]; } });

/**
 * Service responsible for resolving cms config based feature modules.
 */
class CmsFeaturesService {
    constructor(configInitializer, featureModules) {
        this.configInitializer = configInitializer;
        this.featureModules = featureModules;
        // maps componentType to feature
        this.componentFeatureMap = new Map();
        /*
         * Contains either FeatureInstance or FeatureInstance resolver for not yet
         * resolved feature modules
         */
        this.featureInstances = new Map();
        this.initFeatureMap();
    }
    initFeatureMap() {
        this.configInitializer
            .getStable('featureModules')
            .subscribe((config) => {
            var _a, _b;
            this.featureModulesConfig = (_a = config.featureModules) !== null && _a !== void 0 ? _a : {};
            for (const [featureName, featureConfig] of Object.entries(this.featureModulesConfig)) {
                if (typeof featureConfig !== 'string' &&
                    (featureConfig === null || featureConfig === void 0 ? void 0 : featureConfig.module) &&
                    ((_b = featureConfig === null || featureConfig === void 0 ? void 0 : featureConfig.cmsComponents) === null || _b === void 0 ? void 0 : _b.length)) {
                    for (const component of featureConfig.cmsComponents) {
                        this.componentFeatureMap.set(component, featureName);
                    }
                }
            }
        });
    }
    /**
     * Check if there is feature module configuration that covers specified
     * component type
     */
    hasFeatureFor(componentType) {
        return this.componentFeatureMap.has(componentType);
    }
    /**
     * Return full CmsComponent mapping defined in feature module
     */
    getCmsMapping(componentType) {
        const feature = this.componentFeatureMap.get(componentType);
        if (!feature) {
            return of(undefined);
        }
        return this.resolveFeatureInstance(feature).pipe(map((featureInstance) => { var _a; return (_a = featureInstance.componentsMappings) === null || _a === void 0 ? void 0 : _a[componentType]; }));
    }
    /**
     * Resolves feature module for provided component type
     *
     * @param componentType
     */
    getModule(componentType) {
        var _a;
        const feature = this.componentFeatureMap.get(componentType);
        if (!feature) {
            return undefined;
        }
        let module;
        // we are returning injectors only for already resolved features
        (_a = this.featureInstances
            .get(feature)) === null || _a === void 0 ? void 0 : _a.subscribe((featureInstance) => {
            module = featureInstance.moduleRef;
        }).unsubscribe();
        return module;
    }
    /**
     * Resolve feature based on feature name, if feature was not yet resolved
     *
     * It will first resolve all module dependencies if defined
     */
    resolveFeatureInstance(featureName) {
        return defer(() => {
            if (!this.featureInstances.has(featureName)) {
                this.featureInstances.set(featureName, this.featureModules.resolveFeature(featureName).pipe(map((moduleRef) => this.createFeatureInstance(moduleRef, featureName)), shareReplay()));
            }
            return this.featureInstances.get(featureName);
        });
    }
    /**
     * Create feature instance from feature's moduleRef
     */
    createFeatureInstance(moduleRef, feature) {
        var _a, _b, _c;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const featureConfig = this.featureModulesConfig[feature];
        const featureInstance = {
            moduleRef,
            componentsMappings: {},
        };
        // resolve configuration for feature module
        const resolvedConfiguration = this.resolveFeatureConfiguration(moduleRef.injector);
        // extract cms components configuration from feature config
        for (const componentType of (_a = featureConfig.cmsComponents) !== null && _a !== void 0 ? _a : []) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            featureInstance.componentsMappings[componentType] =
                (_c = (_b = resolvedConfiguration.cmsComponents) === null || _b === void 0 ? void 0 : _b[componentType]) !== null && _c !== void 0 ? _c : {};
        }
        return featureInstance;
    }
    /**
     * Returns configuration provided in feature module
     */
    resolveFeatureConfiguration(featureInjector) {
        // get config chunks from feature lib
        const featureConfigChunks = featureInjector.get(ConfigChunk, [], InjectFlags.Self);
        // get default config chunks from feature lib
        const featureDefaultConfigChunks = featureInjector.get(DefaultConfigChunk, [], InjectFlags.Self);
        return deepMerge({}, ...(featureDefaultConfigChunks !== null && featureDefaultConfigChunks !== void 0 ? featureDefaultConfigChunks : []), ...(featureConfigChunks !== null && featureConfigChunks !== void 0 ? featureConfigChunks : []));
    }
}
CmsFeaturesService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CmsFeaturesService, deps: [{ token: i1.ConfigInitializerService }, { token: i1.FeatureModulesService }], target: i0.ɵɵFactoryTarget.Injectable });
CmsFeaturesService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CmsFeaturesService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CmsFeaturesService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.ConfigInitializerService }, { type: i1.FeatureModulesService }]; } });

/**
 * Service with logic related to resolving component from cms mapping
 */
class CmsComponentsService {
    constructor(config, platformId, featureModules, configInitializer) {
        this.config = config;
        this.platformId = platformId;
        this.featureModules = featureModules;
        this.configInitializer = configInitializer;
        // Component mappings that were identified as missing
        this.missingComponents = [];
        // Already resolved mappings
        this.mappings = {};
        // Contains already initialized resolvers for specified component typez
        this.mappingResolvers = new Map();
        this.configInitializer
            .getStable('cmsComponents')
            .subscribe((cmsConfig) => {
            // we want to grab cms configuration available at config initialization phase
            // as lazy-loaded modules can affect global configuration resulting in
            // non-deterministic state
            this.staticCmsConfig = Object.assign({}, cmsConfig.cmsComponents);
        });
    }
    /**
     * Should be called to make sure all component mappings are determined,
     * especially lazy loaded ones.
     *
     * It's recommended way to make sure all other methods of CmsComponentService
     * will be able to work synchronously for asked component types and avoid risk
     * of potential errors that could be thrown otherwise.
     */
    determineMappings(componentTypes) {
        return defer(() => {
            var _a, _b;
            // we use defer, to be sure the logic below used to compose final observable
            // will be executed at subscription time (with up to date state at the time,
            // when it will be needed)
            const featureResolvers = [];
            for (const componentType of componentTypes) {
                if (!this.mappings[componentType]) {
                    const staticConfig = (_b = ((_a = this.staticCmsConfig) !== null && _a !== void 0 ? _a : this.config.cmsComponents)) === null || _b === void 0 ? void 0 : _b[componentType];
                    // check if this component type is managed by feature module
                    if (this.featureModules.hasFeatureFor(componentType)) {
                        featureResolvers.push(
                        // we delegate populating this.mappings to feature resolver
                        this.getFeatureMappingResolver(componentType, staticConfig));
                    }
                    else {
                        // simply use only static config
                        this.mappings[componentType] = staticConfig;
                    }
                }
            }
            if (featureResolvers.length) {
                return forkJoin(featureResolvers).pipe(mapTo(componentTypes));
            }
            else {
                return of(componentTypes);
            }
        });
    }
    getFeatureMappingResolver(componentType, staticConfig) {
        if (!this.mappingResolvers.has(componentType)) {
            const mappingResolver$ = this.featureModules
                .getCmsMapping(componentType)
                .pipe(tap((featureComponentMapping) => {
                // We treat cms mapping configuration from a feature as a default,
                // that can be overridden by app/static configuration
                this.mappings[componentType] = deepMerge({}, featureComponentMapping, staticConfig);
                this.mappingResolvers.delete(componentType);
            }), share());
            this.mappingResolvers.set(componentType, mappingResolver$);
        }
        return this.mappingResolvers.get(componentType);
    }
    /**
     * Returns the feature module for a cms component.
     * It will only work for cms components provided by feature modules.
     *
     * @param componentType
     */
    getModule(componentType) {
        return (this.featureModules.hasFeatureFor(componentType) &&
            this.featureModules.getModule(componentType));
    }
    /**
     * Return collection of component mapping configuration for specified list of
     * component types.
     *
     * If component mapping can't be determined synchronously, for example, lazy
     * loaded one, it will throw an error.
     *
     * To make sure component mapping is available, determineMappings()
     * should be called and completed first.
     */
    getMapping(componentType) {
        var _a, _b, _c;
        const componentConfig = (_a = this.mappings[componentType]) !== null && _a !== void 0 ? _a : (_c = ((_b = this.staticCmsConfig) !== null && _b !== void 0 ? _b : this.config.cmsComponents)) === null || _c === void 0 ? void 0 : _c[componentType];
        if (isDevMode() && !componentConfig) {
            if (!this.missingComponents.includes(componentType)) {
                this.missingComponents.push(componentType);
                console.warn(`No component implementation found for the CMS component type '${componentType}'.\n`, `Make sure you implement a component and register it in the mapper.`);
            }
        }
        return componentConfig;
    }
    /**
     * Checks, if component should be rendered as some components
     * could be disabled for server side renderings
     */
    shouldRender(componentType) {
        var _a;
        const isSSR = isPlatformServer(this.platformId);
        return !(isSSR && ((_a = this.getMapping(componentType)) === null || _a === void 0 ? void 0 : _a.disableSSR));
    }
    /**
     * Return DeferLoadingStrategy for component type.
     */
    getDeferLoadingStrategy(componentType) {
        var _a, _b, _c;
        return (_c = (_b = ((_a = this.staticCmsConfig) !== null && _a !== void 0 ? _a : this.config.cmsComponents)) === null || _b === void 0 ? void 0 : _b[componentType]) === null || _c === void 0 ? void 0 : _c.deferLoading;
    }
    /**
     * Get cms driven child routes for components
     */
    getChildRoutes(componentTypes) {
        var _a, _b;
        const configs = [];
        for (const componentType of componentTypes) {
            if (this.shouldRender(componentType)) {
                configs.push((_b = (_a = this.getMapping(componentType)) === null || _a === void 0 ? void 0 : _a.childRoutes) !== null && _b !== void 0 ? _b : []);
            }
        }
        return this.standardizeChildRoutes(configs);
    }
    /**
     * Returns the static data for the component type.
     */
    getStaticData(componentType) {
        var _a;
        return (_a = this.getMapping(componentType)) === null || _a === void 0 ? void 0 : _a.data;
    }
    /**
     * Standardizes the format of `childRoutes` config.
     *
     * Some `childRoutes` configs are simple arrays of Routes (without the notion of the parent route).
     * But some configs can be an object with children routes and their parent defined in separate property.
     */
    standardizeChildRoutes(childRoutesConfigs) {
        const result = { children: [] };
        (childRoutesConfigs || []).forEach((config) => {
            if (Array.isArray(config)) {
                result.children.push(...config);
            }
            else {
                result.children.push(...(config.children || []));
                if (config.parent) {
                    result.parent = config.parent;
                }
            }
        });
        return result;
    }
    /**
     * Get cms driven guards for components
     */
    getGuards(componentTypes) {
        var _a, _b;
        const guards = new Set();
        for (const componentType of componentTypes) {
            (_b = (_a = this.getMapping(componentType)) === null || _a === void 0 ? void 0 : _a.guards) === null || _b === void 0 ? void 0 : _b.forEach((guard) => guards.add(guard));
        }
        return Array.from(guards);
    }
    /**
     * Get i18n keys associated with components
     */
    getI18nKeys(componentTypes) {
        var _a, _b;
        const i18nKeys = new Set();
        for (const componentType of componentTypes) {
            if (this.shouldRender(componentType)) {
                (_b = (_a = this.getMapping(componentType)) === null || _a === void 0 ? void 0 : _a.i18nKeys) === null || _b === void 0 ? void 0 : _b.forEach((key) => i18nKeys.add(key));
            }
        }
        return Array.from(i18nKeys);
    }
}
CmsComponentsService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CmsComponentsService, deps: [{ token: i1.CmsConfig }, { token: PLATFORM_ID }, { token: CmsFeaturesService }, { token: i1.ConfigInitializerService }], target: i0.ɵɵFactoryTarget.Injectable });
CmsComponentsService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CmsComponentsService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CmsComponentsService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.CmsConfig }, { type: Object, decorators: [{
                    type: Inject,
                    args: [PLATFORM_ID]
                }] }, { type: CmsFeaturesService }, { type: i1.ConfigInitializerService }]; } });

class PageSlotService {
    constructor(cmsComponentsService, platformId, document) {
        this.cmsComponentsService = cmsComponentsService;
        this.platformId = platformId;
        this.document = document;
        this.resolvePrerenderedSlots();
    }
    /**
     * Finds all slots visible in the SSR pre-rendered DOM
     */
    resolvePrerenderedSlots() {
        if (isPlatformBrowser(this.platformId)) {
            this.prerenderedSlots = Array.from(this.document.querySelectorAll('cx-page-slot'))
                .filter((el) => el.getBoundingClientRect().top <
                this.document.documentElement.clientHeight)
                .map((el) => el.getAttribute('position'));
        }
    }
    /**
     * Indicates if certain slot should be rendered instantly.
     *
     * It's especially useful when transitioning from SSR to CSR application,
     * where we don't want to apply deferring logic to slots that are visible
     * to avoid unnecessary flickering.
     */
    shouldNotDefer(slot) {
        var _a;
        if ((_a = this.prerenderedSlots) === null || _a === void 0 ? void 0 : _a.includes(slot)) {
            this.prerenderedSlots.splice(this.prerenderedSlots.indexOf(slot), 1);
            return true;
        }
        return false;
    }
    /**
     * Returns the defer options for the given component. If the wrapping
     * page slot is prerendered, we would ignore the defer options altogether.
     */
    getComponentDeferOptions(slot, componentType) {
        if (this.shouldNotDefer(slot)) {
            return { deferLoading: DeferLoadingStrategy.INSTANT };
        }
        const deferLoading = this.cmsComponentsService.getDeferLoadingStrategy(componentType);
        return { deferLoading };
    }
}
PageSlotService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PageSlotService, deps: [{ token: CmsComponentsService }, { token: PLATFORM_ID }, { token: DOCUMENT }], target: i0.ɵɵFactoryTarget.Injectable });
PageSlotService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PageSlotService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PageSlotService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: CmsComponentsService }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [PLATFORM_ID]
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }]; } });

/**
 * Lifecycle events for the creation and removal of CMS components.
 *
 * Triggers when the component is added or removed from the DOM, using
 * sub event `ComponentCreateEvent` and `ComponentDestroyEvent`.
 */
class ComponentEvent extends CxEvent {
}
/**
 * Indicates that the component is added to the DOM.
 */
class ComponentCreateEvent extends ComponentEvent {
}
/**
 * Event's type
 */
ComponentCreateEvent.type = 'ComponentCreate';
/**
 * Indicates that the component is removed from the DOM.
 */
class ComponentDestroyEvent extends ComponentEvent {
}
/**
 * Event's type
 */
ComponentDestroyEvent.type = 'ComponentDestroy';

/**
 * ComponentHandler implementations can be used for instantiating and launching
 * different types of CMS mapped components
 */
class ComponentHandler {
}

/**
 * Responsible for obtaining component handler for specified component mapping
 */
class ComponentHandlerService {
    constructor(handlers) {
        this.handlers = handlers;
        this.invalidMappings = new Set();
    }
    /**
     * Get best matching component handler
     *
     * @param componentMapping
     */
    resolve(componentMapping) {
        const handler = resolveApplicable(this.handlers, [componentMapping]);
        if (isDevMode() && !handler) {
            if (!this.invalidMappings.has(componentMapping)) {
                this.invalidMappings.add(componentMapping);
                console.warn("Can't resolve handler for component mapping: ", componentMapping);
            }
        }
        return handler;
    }
    /**
     * Get launcher for specified component mapping
     *
     * @param componentMapping
     * @param viewContainerRef
     * @param elementInjector
     */
    getLauncher(componentMapping, viewContainerRef, elementInjector, module) {
        var _a;
        return (_a = this.resolve(componentMapping)) === null || _a === void 0 ? void 0 : _a.launcher(componentMapping, viewContainerRef, elementInjector, module);
    }
}
ComponentHandlerService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ComponentHandlerService, deps: [{ token: ComponentHandler, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });
ComponentHandlerService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ComponentHandlerService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ComponentHandlerService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [ComponentHandler]
                }] }]; } });

/**
 * Provides data for `CmsComponentData`. This is used while component is injected
 * dynamically, so that the component implementation can access the data.
 *
 * The data is resolved from dynamic data (CMS api) as well as static configured data.
 */
class ComponentDataProvider {
    constructor(componentsService, cmsService) {
        this.componentsService = componentsService;
        this.cmsService = cmsService;
    }
    /**
     * Return the component data for a component given by the `uid`.
     *
     * If the `type` is provided, static component data (if available) is
     * merged into the component data. The static data is complemented and
     * overridden with data retrieved from the cms service.
     */
    get(uid, type) {
        return defer(() => {
            let staticComponentData;
            if (type) {
                staticComponentData = this.componentsService.getStaticData(type);
            }
            if (uid) {
                if (staticComponentData) {
                    return this.cmsService.getComponentData(uid).pipe(map((data) => (Object.assign(Object.assign({}, staticComponentData), data))), startWith(staticComponentData));
                }
                else {
                    return this.cmsService.getComponentData(uid);
                }
            }
            else {
                return staticComponentData ? of(staticComponentData) : EMPTY;
            }
        });
    }
}
ComponentDataProvider.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ComponentDataProvider, deps: [{ token: CmsComponentsService }, { token: i1.CmsService }], target: i0.ɵɵFactoryTarget.Injectable });
ComponentDataProvider.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ComponentDataProvider, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ComponentDataProvider, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: CmsComponentsService }, { type: i1.CmsService }]; } });

/**
 * Used to prepare injector for CMS components.
 *
 * Injector will take into account configured providers and provides CmsComponentData
 * for specified component's uid
 */
class CmsInjectorService {
    constructor(cmsComponentsService, injector) {
        this.cmsComponentsService = cmsComponentsService;
        this.injector = injector;
    }
    getInjector(type, uid, parentInjector) {
        var _a, _b;
        const configProviders = (_b = (_a = this.cmsComponentsService.getMapping(type)) === null || _a === void 0 ? void 0 : _a.providers) !== null && _b !== void 0 ? _b : [];
        return Injector.create({
            providers: [
                {
                    provide: CmsComponentData,
                    useFactory: (dataProvider) => ({
                        uid,
                        data$: dataProvider.get(uid, type),
                    }),
                    deps: [ComponentDataProvider],
                },
                ...configProviders,
            ],
            parent: parentInjector !== null && parentInjector !== void 0 ? parentInjector : this.injector,
        });
    }
}
CmsInjectorService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CmsInjectorService, deps: [{ token: CmsComponentsService }, { token: i0.Injector }], target: i0.ɵɵFactoryTarget.Injectable });
CmsInjectorService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CmsInjectorService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CmsInjectorService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: CmsComponentsService }, { type: i0.Injector }]; } });

/**
 * Directive used to facilitate instantiation of CMS driven dynamic components
 */
class ComponentWrapperDirective {
    constructor(vcr, cmsComponentsService, injector, dynamicAttributeService, renderer, componentHandler, cmsInjector, eventService) {
        this.vcr = vcr;
        this.cmsComponentsService = cmsComponentsService;
        this.injector = injector;
        this.dynamicAttributeService = dynamicAttributeService;
        this.renderer = renderer;
        this.componentHandler = componentHandler;
        this.cmsInjector = cmsInjector;
        this.eventService = eventService;
        this.cxComponentRef = new EventEmitter();
    }
    ngOnInit() {
        this.cmsComponentsService
            .determineMappings([this.cxComponentWrapper.flexType])
            .subscribe(() => {
            if (this.cmsComponentsService.shouldRender(this.cxComponentWrapper.flexType)) {
                this.launchComponent();
            }
        });
    }
    launchComponent() {
        const componentMapping = this.cmsComponentsService.getMapping(this.cxComponentWrapper.flexType);
        if (!componentMapping) {
            return;
        }
        this.launcherResource = this.componentHandler
            .getLauncher(componentMapping, this.vcr, this.cmsInjector.getInjector(this.cxComponentWrapper.flexType, this.cxComponentWrapper.uid, this.injector), this.cmsComponentsService.getModule(this.cxComponentWrapper.flexType))
            .pipe(tap(({ elementRef, componentRef }) => {
            this.cmpRef = componentRef;
            this.cxComponentRef.emit(componentRef);
            this.dispatchEvent(ComponentCreateEvent, elementRef);
            this.decorate(elementRef);
            this.injector.get(ChangeDetectorRef).markForCheck();
        }), finalize(() => this.dispatchEvent(ComponentDestroyEvent)))
            .subscribe();
    }
    /**
     * Dispatch the component event.
     *
     * The event is dispatched during creation and removal of the component.
     */
    dispatchEvent(event, elementRef) {
        var _a;
        const payload = {
            typeCode: this.cxComponentWrapper.typeCode,
            id: this.cxComponentWrapper.uid,
        };
        if (event === ComponentCreateEvent) {
            payload.host = elementRef === null || elementRef === void 0 ? void 0 : elementRef.nativeElement;
        }
        (_a = this.eventService) === null || _a === void 0 ? void 0 : _a.dispatch(payload, event);
    }
    decorate(elementRef) {
        this.dynamicAttributeService.addAttributesToComponent(elementRef.nativeElement, this.renderer, this.cxComponentWrapper);
    }
    ngOnDestroy() {
        if (this.launcherResource) {
            this.launcherResource.unsubscribe();
        }
    }
}
ComponentWrapperDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ComponentWrapperDirective, deps: [{ token: i0.ViewContainerRef }, { token: CmsComponentsService }, { token: i0.Injector }, { token: i1.DynamicAttributeService }, { token: i0.Renderer2 }, { token: ComponentHandlerService }, { token: CmsInjectorService }, { token: i1.EventService, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
ComponentWrapperDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.5", type: ComponentWrapperDirective, selector: "[cxComponentWrapper]", inputs: { cxComponentWrapper: "cxComponentWrapper" }, outputs: { cxComponentRef: "cxComponentRef" }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ComponentWrapperDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cxComponentWrapper]',
                }]
        }], ctorParameters: function () { return [{ type: i0.ViewContainerRef }, { type: CmsComponentsService }, { type: i0.Injector }, { type: i1.DynamicAttributeService }, { type: i0.Renderer2 }, { type: ComponentHandlerService }, { type: CmsInjectorService }, { type: i1.EventService, decorators: [{
                    type: Optional
                }] }]; }, propDecorators: { cxComponentWrapper: [{
                type: Input
            }], cxComponentRef: [{
                type: Output
            }] } });

/**
 * The `PageSlotComponent` is used to render the CMS page slot and it's components.
 *
 * The Page slot host element will be supplemented with css classes so that the layout
 * can be fully controlled by customers:
 * - The page slot _position_ is added as a css class by default.
 * - The `cx-pending` is added for as long as the slot hasn't start loading.
 * - The `page-fold` style class is added for the page slot which is configured as the page fold.
 */
class PageSlotComponent {
    constructor(cmsService, dynamicAttributeService, renderer, elementRef, cd, pageSlotService) {
        this.cmsService = cmsService;
        this.dynamicAttributeService = dynamicAttributeService;
        this.renderer = renderer;
        this.elementRef = elementRef;
        this.cd = cd;
        this.pageSlotService = pageSlotService;
        /**
         * Indicates that the page slot is the last page slot above the fold.
         */
        this.isPageFold = false;
        /**
         * Indicates that the components of the page slot haven't been loaded as long
         * as the isPending state is true.
         */
        this.isPending = true;
        /**
         * Indicates that the page slot doesn't contain any components. This is no
         * longer used in spartacus, but kept for backwards compatibility.
         */
        this.hasComponents = false;
        this.position$ = new BehaviorSubject(undefined);
        this.slot$ = this.position$.pipe(switchMap((position) => this.cmsService.getContentSlot(position)), distinctUntilChanged(this.isDistinct));
        /** Observes the components for the given page slot. */
        this.components$ = this.slot$.pipe(map((slot) => { var _a; return (_a = slot === null || slot === void 0 ? void 0 : slot.components) !== null && _a !== void 0 ? _a : []; }));
        this.subscription = new Subscription();
        /** Keeps track of the pending components that must be loaded for the page slot */
        this.pendingComponentCount = 0;
    }
    /**
     * The position represents the unique key for a page slot on a single page, but can
     * be reused cross pages.
     *
     * The position is used to find the CMS components for the page slot. It is also
     * added as an additional CSS class so that layout can be applied.
     */
    set position(value) {
        this.position$.next(value);
    }
    get position() {
        return this.position$.value;
    }
    ngOnInit() {
        this.subscription.add(this.slot$.pipe(tap((slot) => this.decorate(slot))).subscribe((value) => {
            this.components = (value === null || value === void 0 ? void 0 : value.components) || [];
            this.cd.markForCheck();
        }));
    }
    decorate(slot) {
        var _a, _b;
        let cls = this.class || '';
        if (this.lastPosition && cls.indexOf(this.lastPosition) > -1) {
            cls = cls.replace(this.lastPosition, '');
        }
        if (this.position$.value) {
            cls += ` ${this.position$.value}`;
            this.lastPosition = this.position$.value;
        }
        // host bindings
        this.pending = ((_a = slot === null || slot === void 0 ? void 0 : slot.components) === null || _a === void 0 ? void 0 : _a.length) || 0;
        this.hasComponents = ((_b = slot === null || slot === void 0 ? void 0 : slot.components) === null || _b === void 0 ? void 0 : _b.length) > 0;
        if (cls && cls !== this.class) {
            this.class = cls;
        }
        if (slot) {
            this.dynamicAttributeService.addAttributesToSlot(this.elementRef.nativeElement, this.renderer, slot);
        }
    }
    /**
     * Sets the pending count for the page slot components. Once all pending components are
     * loaded, the `isPending` flag is updated, so that the associated class can be updated
     */
    set pending(count) {
        this.pendingComponentCount = count;
        this.isPending = this.pendingComponentCount > 0;
    }
    get pending() {
        return this.pendingComponentCount;
    }
    /*
     * Is triggered when a component is added to the view. This is used to
     * update the pending count
     */
    isLoaded(loadState) {
        if (loadState) {
            this.pending--;
            this.cd.markForCheck();
        }
    }
    /**
     * The `DeferLoadingStrategy` indicates whether the component should be
     * rendered instantly or whether it should be deferred.
     */
    getComponentDeferOptions(componentType) {
        return this.pageSlotService.getComponentDeferOptions(this.position, componentType);
    }
    isDistinct(old, current) {
        var _a;
        return (current.components &&
            ((_a = old.components) === null || _a === void 0 ? void 0 : _a.length) === current.components.length &&
            !old.components.find((el, index) => el.uid !== current.components[index].uid));
    }
    ngOnDestroy() {
        var _a;
        (_a = this.subscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();
    }
}
PageSlotComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PageSlotComponent, deps: [{ token: i1.CmsService }, { token: i1.DynamicAttributeService }, { token: i0.Renderer2 }, { token: i0.ElementRef }, { token: i0.ChangeDetectorRef }, { token: PageSlotService }], target: i0.ɵɵFactoryTarget.Component });
PageSlotComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: PageSlotComponent, selector: "cx-page-slot,[cx-page-slot]", inputs: { position: "position", class: "class", isPageFold: "isPageFold", hasComponents: "hasComponents" }, host: { properties: { "attr.position": "this.position", "class": "this.class", "class.page-fold": "this.isPageFold", "class.cx-pending": "this.isPending", "class.has-components": "this.hasComponents" } }, ngImport: i0, template: "<ng-template\n  [cxOutlet]=\"position\"\n  [cxOutletContext]=\"{ components$: components$ }\"\n>\n  <ng-template\n    *ngFor=\"let component of components\"\n    [cxOutlet]=\"component.flexType\"\n    [cxOutletContext]=\"{ component: component }\"\n    [cxOutletDefer]=\"getComponentDeferOptions(component.flexType)\"\n    (loaded)=\"isLoaded($event)\"\n  >\n    <ng-container [cxComponentWrapper]=\"component\"></ng-container>\n  </ng-template>\n</ng-template>\n", directives: [{ type: OutletDirective, selector: "[cxOutlet]", inputs: ["cxOutlet", "cxOutletContext", "cxOutletDefer"], outputs: ["loaded"] }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: ComponentWrapperDirective, selector: "[cxComponentWrapper]", inputs: ["cxComponentWrapper"], outputs: ["cxComponentRef"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PageSlotComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-page-slot,[cx-page-slot]',
                    templateUrl: './page-slot.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: i1.CmsService }, { type: i1.DynamicAttributeService }, { type: i0.Renderer2 }, { type: i0.ElementRef }, { type: i0.ChangeDetectorRef }, { type: PageSlotService }]; }, propDecorators: { position: [{
                type: HostBinding,
                args: ['attr.position']
            }, {
                type: Input
            }], class: [{
                type: Input
            }, {
                type: HostBinding
            }], isPageFold: [{
                type: HostBinding,
                args: ['class.page-fold']
            }, {
                type: Input
            }], isPending: [{
                type: HostBinding,
                args: ['class.cx-pending']
            }], hasComponents: [{
                type: HostBinding,
                args: ['class.has-components']
            }, {
                type: Input
            }] } });

/**
 * Directive that Adds a style class to the host element based on the cms page
 * template. The CMS page template is driven by the CMS structure, which is configurable
 * in the backend.
 *
 * The style class is added to the host element of the directive. The host element is resolved
 * from the `elementRef`, or, in case the directive is used in an `ng-template`, by the
 * `TemplateRef`.
 *
 * An example of the usage is given below:
 *
 * ```html
 * <cx-storefront class="LandingPageTemplate">
 *   <ng-template cxPageTemplateStyle>...</ng-template>
 * <cx-storefront>
 * ```
 *
 * The style class can also be provided by an input:
 *
 * ```html
 * <ng-template [cxPageTemplateStyle]="pageTemplateName">
 * ```
 *
 */
class PageTemplateDirective {
    constructor(pageLayoutService, elementRef, templateRef, cd) {
        this.pageLayoutService = pageLayoutService;
        this.elementRef = elementRef;
        this.templateRef = templateRef;
        this.cd = cd;
        // Maintains the page template subscription
        this.subscription = new Subscription();
    }
    /**
     * Adds a style class to the host element based on the cms page template, unless
     * the class is given as an input.
     *
     * The host element is either the actual host, or the parent element in case this
     * is used inside an `ng-template`.
     */
    set setTemplate(template) {
        if (template && template !== '') {
            this.useTemplateFromInput = true;
            this.addStyleClass(template);
        }
        else if (this.useTemplateFromInput) {
            // we only clear the template if it has been provided by the input before
            this.clear();
        }
    }
    ngOnInit() {
        if (!this.useTemplateFromInput) {
            this.subscription.add(this.pageLayoutService.templateName$.subscribe((template) => this.addStyleClass(template)));
        }
    }
    /**
     * Adds the page template as a style class to the given element. If any
     * page template was added before, we clean it up.
     *
     * We'll not use hostBinding for the style class, as it will potential drop
     * an existing class name on the host. This is why we need to work with
     * the lower level change detection api.
     */
    addStyleClass(template, el) {
        this.clear(el);
        if (template) {
            this.currentTemplate = template;
            (el !== null && el !== void 0 ? el : this.host).classList.add(this.currentTemplate);
            this.cd.markForCheck();
        }
    }
    /**
     * Cleans up the class host binding, if a template class was assigned before.
     */
    clear(el) {
        var _a;
        if (this.currentTemplate) {
            (_a = (el !== null && el !== void 0 ? el : this.host).classList) === null || _a === void 0 ? void 0 : _a.remove(this.currentTemplate);
            this.cd.markForCheck();
        }
    }
    /**
     * Returns the host element (`HTMLElement`).
     *
     * If the directive is used on an `ng-template`, we take the parent element,
     * to ensure that we're not ending up with a comment.
     */
    get host() {
        return !!this.templateRef
            ? this.templateRef.elementRef.nativeElement.parentElement
            : this.elementRef.nativeElement;
    }
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
}
PageTemplateDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PageTemplateDirective, deps: [{ token: PageLayoutService }, { token: i0.ElementRef }, { token: i0.TemplateRef, optional: true }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Directive });
PageTemplateDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.5", type: PageTemplateDirective, selector: "[cxPageTemplateStyle]", inputs: { setTemplate: ["cxPageTemplateStyle", "setTemplate"] }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PageTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cxPageTemplateStyle]',
                }]
        }], ctorParameters: function () { return [{ type: PageLayoutService }, { type: i0.ElementRef }, { type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { setTemplate: [{
                type: Input,
                args: ['cxPageTemplateStyle']
            }] } });

class PageLayoutComponent {
    constructor(pageLayoutService) {
        this.pageLayoutService = pageLayoutService;
        this.section$ = new BehaviorSubject(undefined);
        this.templateName$ = this.pageLayoutService.templateName$;
        this.layoutName$ = this.section$.pipe(switchMap((section) => (section ? of(section) : this.templateName$)));
        this.slots$ = this.section$.pipe(switchMap((section) => this.pageLayoutService.getSlots(section)));
        this.pageFoldSlot$ = this.templateName$.pipe(switchMap((templateName) => this.pageLayoutService.getPageFoldSlot(templateName)), distinctUntilChanged());
    }
    set section(value) {
        this.section$.next(value);
    }
}
PageLayoutComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PageLayoutComponent, deps: [{ token: PageLayoutService }], target: i0.ɵɵFactoryTarget.Component });
PageLayoutComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: PageLayoutComponent, selector: "cx-page-layout", inputs: { section: "section" }, ngImport: i0, template: "<ng-template\n  [cxPageTemplateStyle]=\"layoutName$ | async\"\n  [cxOutlet]=\"layoutName$ | async\"\n  [cxOutletContext]=\"{\n    templateName$: templateName$,\n    slots$: slots$,\n    section$: section$\n  }\"\n>\n  <ng-content></ng-content>\n\n  <cx-page-slot\n    *ngFor=\"let slot of slots$ | async\"\n    [position]=\"slot\"\n    [isPageFold]=\"slot === (pageFoldSlot$ | async)\"\n  ></cx-page-slot>\n</ng-template>\n", components: [{ type: PageSlotComponent, selector: "cx-page-slot,[cx-page-slot]", inputs: ["position", "class", "isPageFold", "hasComponents"] }], directives: [{ type: PageTemplateDirective, selector: "[cxPageTemplateStyle]", inputs: ["cxPageTemplateStyle"] }, { type: OutletDirective, selector: "[cxOutlet]", inputs: ["cxOutlet", "cxOutletContext", "cxOutletDefer"], outputs: ["loaded"] }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], pipes: { "async": i3.AsyncPipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PageLayoutComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-page-layout',
                    templateUrl: './page-layout.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: PageLayoutService }]; }, propDecorators: { section: [{
                type: Input
            }] } });

// This service should be exposed in public API only after the refactor planned in https://github.com/SAP/spartacus/issues/7070
class CmsRoutesImplService {
    constructor(router, cmsComponentsService) {
        this.router = router;
        this.cmsComponentsService = cmsComponentsService;
    }
    cmsRouteExists(url) {
        const isCmsDrivenRoute = url.startsWith('/');
        if (!isCmsDrivenRoute) {
            return false;
        }
        const routePath = url.substr(1);
        return (isCmsDrivenRoute &&
            !!this.router.config.find((route) => route.data && route.data.cxCmsRouteContext && route.path === routePath));
    }
    /**
     * Contains Cms driven routing logic intended for use use in guards, especially in canActivate method.
     *
     * Will return true, when logic wont have to modify routing (so canActivate could be easily resolved to true)
     * or will return false, when routing configuration was updated and redirection to newly generated route was initiated.
     *
     * @param pageContext
     * @param currentUrl
     */
    handleCmsRoutesInGuard(pageContext, componentTypes, currentUrl, currentPageLabel) {
        var _a;
        if (this.cmsRouteExists(currentPageLabel)) {
            return true;
        }
        const childRoutesConfig = this.cmsComponentsService.getChildRoutes(componentTypes);
        if ((_a = childRoutesConfig === null || childRoutesConfig === void 0 ? void 0 : childRoutesConfig.children) === null || _a === void 0 ? void 0 : _a.length) {
            if (this.updateRouting(pageContext, currentPageLabel, childRoutesConfig)) {
                this.router.navigateByUrl(currentUrl);
                return false;
            }
        }
        return true;
    }
    updateRouting(pageContext, pageLabel, childRoutesConfig) {
        var _a, _b;
        if (pageContext.type === PageType.CONTENT_PAGE &&
            pageLabel.startsWith('/') &&
            pageLabel.length > 1) {
            const newRoute = {
                path: pageLabel.substr(1),
                component: PageLayoutComponent,
                children: childRoutesConfig.children,
                data: deepMerge({}, (_b = (_a = childRoutesConfig === null || childRoutesConfig === void 0 ? void 0 : childRoutesConfig.parent) === null || _a === void 0 ? void 0 : _a.data) !== null && _b !== void 0 ? _b : {}, {
                    cxCmsRouteContext: {
                        type: pageContext.type,
                        id: pageLabel,
                    },
                }),
            };
            this.router.resetConfig([newRoute, ...this.router.config]);
            return true;
        }
        return false;
    }
}
CmsRoutesImplService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CmsRoutesImplService, deps: [{ token: i1$1.Router }, { token: CmsComponentsService }], target: i0.ɵɵFactoryTarget.Injectable });
CmsRoutesImplService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CmsRoutesImplService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CmsRoutesImplService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: function () { return [{ type: i1$1.Router }, { type: CmsComponentsService }]; } });

// Public injection token for the private implementation of the service `CmsRoutesImplService`.
// After #7070, this class should be replaced with a real implementation.
class CmsRoutesService {
}
CmsRoutesService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CmsRoutesService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
CmsRoutesService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CmsRoutesService, providedIn: 'root', useExisting: CmsRoutesImplService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CmsRoutesService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                    useExisting: CmsRoutesImplService,
                }]
        }] });

class CmsI18nService {
    constructor(cmsComponentsService, translation, translationChunk) {
        this.cmsComponentsService = cmsComponentsService;
        this.translation = translation;
        this.translationChunk = translationChunk;
    }
    loadForComponents(componentTypes) {
        const i18nKeys = this.cmsComponentsService.getI18nKeys(componentTypes);
        const i18nChunks = new Set();
        for (const key of i18nKeys) {
            i18nChunks.add(this.translationChunk.getChunkNameForKey(key));
        }
        this.translation.loadChunks(Array.from(i18nChunks));
    }
}
CmsI18nService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CmsI18nService, deps: [{ token: CmsComponentsService }, { token: i1.TranslationService }, { token: i1.TranslationChunkService }], target: i0.ɵɵFactoryTarget.Injectable });
CmsI18nService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CmsI18nService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CmsI18nService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: CmsComponentsService }, { type: i1.TranslationService }, { type: i1.TranslationChunkService }]; } });

class CmsGuardsService {
    constructor(cmsComponentsService, injector) {
        this.cmsComponentsService = cmsComponentsService;
        this.injector = injector;
    }
    cmsPageCanActivate(componentTypes, route, state) {
        const guards = this.cmsComponentsService.getGuards(componentTypes);
        if (guards.length) {
            const canActivateObservables = guards.map((guardClass) => {
                const guard = this.injector.get(guardClass, null);
                if (isCanActivate(guard)) {
                    return wrapIntoObservable(guard.canActivate(route, state)).pipe(first());
                }
                else {
                    throw new Error('Invalid CanActivate guard in cmsMapping');
                }
            });
            return concat(...canActivateObservables).pipe(skipWhile((canActivate) => canActivate === true), endWith(true), first());
        }
        else {
            return of(true);
        }
    }
}
CmsGuardsService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CmsGuardsService, deps: [{ token: CmsComponentsService }, { token: i0.Injector }], target: i0.ɵɵFactoryTarget.Injectable });
CmsGuardsService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CmsGuardsService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CmsGuardsService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: CmsComponentsService }, { type: i0.Injector }]; } });
function wrapIntoObservable(value) {
    if (isObservable(value)) {
        return value;
    }
    if (isPromise(value)) {
        return from(Promise.resolve(value));
    }
    return of(value);
}
function isPromise(obj) {
    return !!obj && typeof obj.then === 'function';
}
function isCanActivate(guard) {
    return guard && isFunction(guard.canActivate);
}
function isFunction(v) {
    return typeof v === 'function';
}

/**
 * Helper service for `CmsPageGuard`
 */
class CmsPageGuardService {
    constructor(semanticPathService, cmsService, cmsRoutes, cmsI18n, cmsGuards, cmsComponentsService, routing) {
        this.semanticPathService = semanticPathService;
        this.cmsService = cmsService;
        this.cmsRoutes = cmsRoutes;
        this.cmsI18n = cmsI18n;
        this.cmsGuards = cmsGuards;
        this.cmsComponentsService = cmsComponentsService;
        this.routing = routing;
    }
    /**
     * Takes CMS components types in the current CMS page, triggers (configurable) side effects and returns a boolean - whether the route can be activated.
     *
     * Based on `cmsComponents` config for the components in the page:
     * - Evaluates components' guards; if one of them emits false or UrlTree - the route cannot be activated or redirects to the given UrlTree, respectively.
     * - If all components' guards emitted true, then the route can be activated
     * - Then we trigger loading of configured i18n chunks in parallel
     * - And we register the configured children routes of cms components
     *
     * @param pageContext current cms page context
     * @param pageData cms page data
     * @param route activated route snapshot
     * @param state router state snapshot
     *
     * @returns boolean observable - whether the route can be activated
     */
    canActivatePage(pageContext, pageData, route, state) {
        return this.cmsService.getPageComponentTypes(pageContext).pipe(take(1), switchMap((componentTypes) => this.cmsComponentsService.determineMappings(componentTypes)), switchMap((componentTypes) => this.cmsGuards
            .cmsPageCanActivate(componentTypes, route, state)
            .pipe(withLatestFrom(of(componentTypes)))), tap(([canActivate, componentTypes]) => {
            if (canActivate === true) {
                this.cmsI18n.loadForComponents(componentTypes);
            }
        }), map(([canActivate, componentTypes]) => {
            var _a;
            const pageLabel = pageData.label || pageContext.id; // for content pages the page label returned from backend can be different than ID initially assumed from route
            if (canActivate === true && !((_a = route === null || route === void 0 ? void 0 : route.data) === null || _a === void 0 ? void 0 : _a.cxCmsRouteContext)) {
                return this.cmsRoutes.handleCmsRoutesInGuard(pageContext, componentTypes, state.url, pageLabel);
            }
            return canActivate;
        }));
    }
    /**
     * Activates the "NOT FOUND" cms page.
     *
     * It loads cms page data for the "NOT FOUND" page and puts it in the state of the the requested page label.
     * Then it processes its CMS components with the method `canActivatePage()` of this service. For more, see its docs.
     */
    canActivateNotFoundPage(pageContext, route, state) {
        const notFoundCmsPageContext = {
            type: PageType.CONTENT_PAGE,
            id: this.semanticPathService.get('notFound'),
        };
        return this.cmsService.getPage(notFoundCmsPageContext).pipe(switchMap((notFoundPage) => {
            if (notFoundPage) {
                return this.cmsService.getPageIndex(notFoundCmsPageContext).pipe(tap((notFoundIndex) => {
                    this.cmsService.setPageFailIndex(pageContext, notFoundIndex);
                    this.routing.changeNextPageContext(notFoundCmsPageContext);
                }), switchMap((notFoundIndex) => this.cmsService.getPageIndex(pageContext).pipe(
                // we have to wait for page index update
                filter((index) => index === notFoundIndex))), switchMap(() => this.canActivatePage(pageContext, notFoundPage, route, state)));
            }
            return of(false);
        }));
    }
}
CmsPageGuardService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CmsPageGuardService, deps: [{ token: i1.SemanticPathService }, { token: i1.CmsService }, { token: CmsRoutesService }, { token: CmsI18nService }, { token: CmsGuardsService }, { token: CmsComponentsService }, { token: i1.RoutingService }], target: i0.ɵɵFactoryTarget.Injectable });
CmsPageGuardService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CmsPageGuardService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CmsPageGuardService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.SemanticPathService }, { type: i1.CmsService }, { type: CmsRoutesService }, { type: CmsI18nService }, { type: CmsGuardsService }, { type: CmsComponentsService }, { type: i1.RoutingService }]; } });

class CmsPageGuard {
    constructor(routingService, cmsService, protectedRoutesGuard, service, routingConfig) {
        this.routingService = routingService;
        this.cmsService = cmsService;
        this.protectedRoutesGuard = protectedRoutesGuard;
        this.service = service;
        this.routingConfig = routingConfig;
    }
    /**
     * Tries to load the CMS page data for the anticipated route and returns:
     * - `true` - if it can be activated
     * - `false` - if it cannot be activated
     * - `UrlTree` - if user should be redirected to a given `UrlTree`
     *
     * If the route can be activated, it fires additional calculations on the CMS components present on this CMS page,
     * based on their configuration (`cmsComponents` config).
     *
     * For more, see docs of the `CmsPageGuardService.canActivatePage`.
     */
    canActivate(route, state) {
        return this.protectedRoutesGuard.canActivate(route).pipe(switchMap((canActivate) => canActivate === true
            ? this.routingService.getNextPageContext().pipe(take(1), switchMap((pageContext) => this.cmsService.getPage(pageContext, this.shouldReload()).pipe(first(), switchMap((pageData) => pageData
                ? this.service.canActivatePage(pageContext, pageData, route, state)
                : this.service.canActivateNotFoundPage(pageContext, route, state)))))
            : of(canActivate)));
    }
    /**
     * Returns whether we should reload the CMS page data, even when it was loaded before.
     */
    shouldReload() {
        return this.routingConfig.getLoadStrategy() !== "once" /* ONCE */;
    }
}
CmsPageGuard.guardName = 'CmsPageGuard';
CmsPageGuard.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CmsPageGuard, deps: [{ token: i1.RoutingService }, { token: i1.CmsService }, { token: i1.ProtectedRoutesGuard }, { token: CmsPageGuardService }, { token: i1.RoutingConfigService }], target: i0.ɵɵFactoryTarget.Injectable });
CmsPageGuard.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CmsPageGuard, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CmsPageGuard, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.RoutingService }, { type: i1.CmsService }, { type: i1.ProtectedRoutesGuard }, { type: CmsPageGuardService }, { type: i1.RoutingConfigService }]; } });

class MiniCartComponent {
    constructor(activeCartService) {
        this.activeCartService = activeCartService;
        this.iconTypes = ICON_TYPE;
        this.quantity$ = this.activeCartService.getActive().pipe(startWith({ deliveryItemsQuantity: 0 }), map((cart) => cart.deliveryItemsQuantity || 0));
        this.total$ = this.activeCartService.getActive().pipe(filter((cart) => !!cart.totalPrice), map((cart) => cart.totalPrice.formattedValue));
    }
}
MiniCartComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: MiniCartComponent, deps: [{ token: i1.ActiveCartService }], target: i0.ɵɵFactoryTarget.Component });
MiniCartComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: MiniCartComponent, selector: "cx-mini-cart", ngImport: i0, template: "<a\n  [attr.aria-label]=\"\n    'miniCart.item' | cxTranslate: { count: quantity$ | async }\n  \"\n  [routerLink]=\"{ cxRoute: 'cart' } | cxUrl\"\n>\n  <cx-icon [type]=\"iconTypes.CART\"></cx-icon>\n\n  <span class=\"total\">\n    {{ 'miniCart.total' | cxTranslate: { total: total$ | async } }}\n  </span>\n\n  <span class=\"count\">\n    {{ 'miniCart.count' | cxTranslate: { count: quantity$ | async } }}\n  </span>\n</a>\n", components: [{ type: IconComponent, selector: "cx-icon,[cxIcon]", inputs: ["cxIcon", "type"] }], directives: [{ type: i1$1.RouterLinkWithHref, selector: "a[routerLink],area[routerLink]", inputs: ["routerLink", "target", "queryParams", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange", "replaceUrl", "state", "relativeTo"] }], pipes: { "cxTranslate": i1.TranslatePipe, "async": i3.AsyncPipe, "cxUrl": i1.UrlPipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: MiniCartComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-mini-cart',
                    templateUrl: './mini-cart.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: i1.ActiveCartService }]; } });

class MiniCartModule {
}
MiniCartModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: MiniCartModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
MiniCartModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: MiniCartModule, declarations: [MiniCartComponent], imports: [CommonModule, RouterModule, UrlModule, IconModule, I18nModule], exports: [MiniCartComponent] });
MiniCartModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: MiniCartModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                MiniCartComponent: {
                    component: MiniCartComponent,
                },
            },
        }),
    ], imports: [[CommonModule, RouterModule, UrlModule, IconModule, I18nModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: MiniCartModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, RouterModule, UrlModule, IconModule, I18nModule],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                MiniCartComponent: {
                                    component: MiniCartComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [MiniCartComponent],
                    exports: [MiniCartComponent],
                }]
        }] });

const ORDER_ENTRIES_CONTEXT = Symbol('ORDER_ENTRIES_CONTEXT');

class SaveForLaterComponent {
    constructor(cmsService, cartService, selectiveCartService) {
        this.cmsService = cmsService;
        this.cartService = cartService;
        this.selectiveCartService = selectiveCartService;
        this.CartLocation = PromotionLocation;
    }
    ngOnInit() {
        this.isCartEmpty$ = this.cartService
            .getActive()
            .pipe(map((cart) => !(cart && cart.totalItems && cart.totalItems > 0)));
        this.saveForLater$ = this.selectiveCartService.getCart();
        this.entries$ = this.selectiveCartService
            .getEntries()
            .pipe(filter((entries) => entries.length > 0));
        this.cartLoaded$ = combineLatest([
            this.cartService.isStable(),
            this.selectiveCartService.isStable(),
        ]).pipe(map(([cartLoaded, sflLoaded]) => cartLoaded && sflLoaded));
        this.data$ = this.cmsService.getComponentData('EmptyCartParagraphComponent');
    }
    moveToCart(item) {
        this.selectiveCartService.removeEntry(item);
        this.cartService.addEntry(item.product.code, item.quantity);
    }
}
SaveForLaterComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SaveForLaterComponent, deps: [{ token: i1.CmsService }, { token: i1.ActiveCartService }, { token: i1.SelectiveCartService }], target: i0.ɵɵFactoryTarget.Component });
SaveForLaterComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: SaveForLaterComponent, selector: "cx-save-for-later", ngImport: i0, template: "<ng-container *ngIf=\"isCartEmpty$ | async\">\n  <p\n    *ngIf=\"data$ | async as data\"\n    [innerHTML]=\"data.content\"\n    class=\"cx-empty-cart-info\"\n  ></p>\n</ng-container>\n\n<ng-container *ngIf=\"saveForLater$ | async as saveForLater\">\n  <ng-container *ngIf=\"entries$ | async as entries\">\n    <div *ngIf=\"saveForLater.totalItems > 0\" class=\"cart-details-wrapper\">\n      <div class=\"cx-total\">\n        {{\n          'saveForLaterItems.itemTotal'\n            | cxTranslate: { count: saveForLater.totalItems }\n        }}\n      </div>\n      <cx-cart-item-list\n        [items]=\"entries\"\n        [readonly]=\"false\"\n        [cartIsLoading]=\"!(cartLoaded$ | async)\"\n        [promotionLocation]=\"CartLocation.SaveForLater\"\n        [options]=\"{\n          isSaveForLater: true,\n          optionalBtn: moveToCartBtn\n        }\"\n      ></cx-cart-item-list>\n    </div>\n  </ng-container>\n</ng-container>\n\n<ng-template let-ctx #moveToCartBtn>\n  <div class=\"col-md-3 col-lg-3 col-xl-3 cx-sfl-btn\">\n    <button\n      class=\"link cx-action-link\"\n      [disabled]=\"ctx.loading\"\n      (click)=\"moveToCart(ctx.item)\"\n      type=\"button\"\n    >\n      {{ 'saveForLaterItems.moveToCart' | cxTranslate }}\n    </button>\n  </div>\n</ng-template>\n", components: [{ type: CartItemListComponent, selector: "cx-cart-item-list", inputs: ["readonly", "hasHeader", "options", "cartId", "items", "promotionLocation", "cartIsLoading"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "async": i3.AsyncPipe, "cxTranslate": i1.TranslatePipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SaveForLaterComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-save-for-later',
                    templateUrl: './save-for-later.component.html',
                }]
        }], ctorParameters: function () { return [{ type: i1.CmsService }, { type: i1.ActiveCartService }, { type: i1.SelectiveCartService }]; } });

class SaveForLaterModule {
}
SaveForLaterModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SaveForLaterModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
SaveForLaterModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SaveForLaterModule, declarations: [SaveForLaterComponent], imports: [CommonModule, I18nModule, CartSharedModule], exports: [SaveForLaterComponent] });
SaveForLaterModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SaveForLaterModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                SaveForLaterComponent: {
                    component: SaveForLaterComponent,
                },
            },
        }),
    ], imports: [[CommonModule, I18nModule, CartSharedModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SaveForLaterModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, I18nModule, CartSharedModule],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                SaveForLaterComponent: {
                                    component: SaveForLaterComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [SaveForLaterComponent],
                    exports: [SaveForLaterComponent],
                }]
        }] });

class CartComponentModule {
}
CartComponentModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CartComponentModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
CartComponentModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CartComponentModule, imports: [NgbModule,
        CartDetailsModule,
        CartTotalsModule,
        CartSharedModule,
        SaveForLaterModule, i1$1.RouterModule], exports: [AddToWishListModule,
        CartDetailsModule,
        CartTotalsModule,
        CartSharedModule,
        AddToCartModule,
        MiniCartModule,
        CartModule,
        SaveForLaterModule] });
CartComponentModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CartComponentModule, providers: [
        {
            provide: PAGE_LAYOUT_HANDLER,
            useExisting: CartPageLayoutHandler,
            multi: true,
        },
    ], imports: [[
            NgbModule,
            CartDetailsModule,
            CartTotalsModule,
            CartSharedModule,
            SaveForLaterModule,
            RouterModule.forChild([
                {
                    // @ts-ignore
                    path: null,
                    canActivate: [CmsPageGuard],
                    component: PageLayoutComponent,
                    data: {
                        cxRoute: 'cart',
                        cxContext: {
                            [ORDER_ENTRIES_CONTEXT]: ActiveCartOrderEntriesContext,
                        },
                    },
                },
            ]),
        ], AddToWishListModule,
        CartDetailsModule,
        CartTotalsModule,
        CartSharedModule,
        AddToCartModule,
        MiniCartModule,
        CartModule,
        SaveForLaterModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CartComponentModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        NgbModule,
                        CartDetailsModule,
                        CartTotalsModule,
                        CartSharedModule,
                        SaveForLaterModule,
                        RouterModule.forChild([
                            {
                                // @ts-ignore
                                path: null,
                                canActivate: [CmsPageGuard],
                                component: PageLayoutComponent,
                                data: {
                                    cxRoute: 'cart',
                                    cxContext: {
                                        [ORDER_ENTRIES_CONTEXT]: ActiveCartOrderEntriesContext,
                                    },
                                },
                            },
                        ]),
                    ],
                    exports: [
                        AddToWishListModule,
                        CartDetailsModule,
                        CartTotalsModule,
                        CartSharedModule,
                        AddToCartModule,
                        MiniCartModule,
                        CartModule,
                        SaveForLaterModule,
                    ],
                    declarations: [],
                    providers: [
                        {
                            provide: PAGE_LAYOUT_HANDLER,
                            useExisting: CartPageLayoutHandler,
                            multi: true,
                        },
                    ],
                }]
        }] });

class CartValidationComponentsModule {
}
CartValidationComponentsModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CartValidationComponentsModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
CartValidationComponentsModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CartValidationComponentsModule, imports: [CartValidationWarningsModule, CartItemValidationWarningModule] });
CartValidationComponentsModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CartValidationComponentsModule, providers: [], imports: [[CartValidationWarningsModule, CartItemValidationWarningModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CartValidationComponentsModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CartValidationWarningsModule, CartItemValidationWarningModule],
                    providers: [],
                }]
        }] });

class CartValidationGuard {
    constructor(cartValidationService, semanticPathService, router, globalMessageService, activeCartService, cartValidationStateService, cartConfigService) {
        this.cartValidationService = cartValidationService;
        this.semanticPathService = semanticPathService;
        this.router = router;
        this.globalMessageService = globalMessageService;
        this.activeCartService = activeCartService;
        this.cartValidationStateService = cartValidationStateService;
        this.cartConfigService = cartConfigService;
        this.GLOBAL_MESSAGE_TIMEOUT = 10000;
    }
    canActivate() {
        return !this.cartConfigService.isCartValidationEnabled()
            ? of(true)
            : this.cartValidationService.validateCart().pipe(withLatestFrom(this.activeCartService.getEntries()), map(([cartModificationList, cartEntries]) => {
                var _a;
                this.cartValidationStateService.updateValidationResultAndRoutingId(cartModificationList === null || cartModificationList === void 0 ? void 0 : cartModificationList.cartModifications);
                if (((_a = cartModificationList === null || cartModificationList === void 0 ? void 0 : cartModificationList.cartModifications) === null || _a === void 0 ? void 0 : _a.length) !== 0) {
                    let validationResultMessage;
                    if (cartEntries.length === 1 &&
                        cartEntries[0].product.code ===
                            (cartModificationList === null || cartModificationList === void 0 ? void 0 : cartModificationList.cartModifications[0].entry.product.code) &&
                        (cartModificationList === null || cartModificationList === void 0 ? void 0 : cartModificationList.cartModifications[0].statusCode) ===
                            CartValidationStatusCode.NO_STOCK) {
                        validationResultMessage = {
                            key: 'validation.cartEntryRemoved',
                            params: {
                                name: cartModificationList === null || cartModificationList === void 0 ? void 0 : cartModificationList.cartModifications[0].entry.product.name,
                            },
                        };
                    }
                    else {
                        validationResultMessage = {
                            key: 'validation.cartEntriesChangeDuringCheckout',
                        };
                    }
                    this.globalMessageService.add(validationResultMessage, GlobalMessageType.MSG_TYPE_ERROR, this.GLOBAL_MESSAGE_TIMEOUT);
                    this.activeCartService.reloadActiveCart();
                    return this.router.parseUrl(this.semanticPathService.get('cart'));
                }
                return true;
            }));
    }
}
CartValidationGuard.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CartValidationGuard, deps: [{ token: i1.CartValidationService }, { token: i1.SemanticPathService }, { token: i1$1.Router }, { token: i1.GlobalMessageService }, { token: i1.ActiveCartService }, { token: CartValidationStateService }, { token: i1.CartConfigService }], target: i0.ɵɵFactoryTarget.Injectable });
CartValidationGuard.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CartValidationGuard, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CartValidationGuard, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.CartValidationService }, { type: i1.SemanticPathService }, { type: i1$1.Router }, { type: i1.GlobalMessageService }, { type: i1.ActiveCartService }, { type: CartValidationStateService }, { type: i1.CartConfigService }]; } });

class BannerComponent {
    constructor(component) {
        this.component = component;
        this.data$ = this.component.data$.pipe(tap((data) => (this.styleClasses = data.styleClasses)));
    }
    /**
     * Returns `_blank` to force opening the link in a new window whenever the
     * `data.external` flag is set to true.
     */
    getTarget(data) {
        return data.external === 'true' || data.external === true ? '_blank' : null;
    }
    getImage(data) {
        if (data.media) {
            if ('url' in data.media) {
                return data.media;
            }
            else {
                return data.media;
            }
        }
    }
}
BannerComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: BannerComponent, deps: [{ token: CmsComponentData }], target: i0.ɵɵFactoryTarget.Component });
BannerComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: BannerComponent, selector: "cx-banner", host: { properties: { "class": "this.styleClasses" } }, ngImport: i0, template: "<ng-container *ngIf=\"data$ | async as data\">\n  <cx-generic-link\n    *ngIf=\"data.urlLink\"\n    [url]=\"data.urlLink\"\n    [target]=\"getTarget(data)\"\n  >\n    <p class=\"headline\" *ngIf=\"data.headline\" [innerHTML]=\"data.headline\"></p>\n    <cx-media [container]=\"getImage(data)\"></cx-media>\n    <p class=\"content\" *ngIf=\"data.content\" [innerHTML]=\"data.content\"></p>\n  </cx-generic-link>\n</ng-container>\n", components: [{ type: GenericLinkComponent, selector: "cx-generic-link", inputs: ["url", "target", "id", "class", "style", "title"] }, { type: MediaComponent, selector: "cx-media", inputs: ["container", "format", "alt", "role", "loading"], outputs: ["loaded"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "async": i3.AsyncPipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: BannerComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-banner',
                    templateUrl: './banner.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: CmsComponentData }]; }, propDecorators: { styleClasses: [{
                type: HostBinding,
                args: ['class']
            }] } });

class BannerModule {
}
BannerModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: BannerModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
BannerModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: BannerModule, declarations: [BannerComponent], imports: [CommonModule, RouterModule, GenericLinkModule, MediaModule], exports: [BannerComponent] });
BannerModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: BannerModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                SimpleResponsiveBannerComponent: {
                    component: BannerComponent,
                },
                BannerComponent: {
                    component: BannerComponent,
                },
                SimpleBannerComponent: {
                    component: BannerComponent,
                },
            },
        }),
    ], imports: [[CommonModule, RouterModule, GenericLinkModule, MediaModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: BannerModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, RouterModule, GenericLinkModule, MediaModule],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                SimpleResponsiveBannerComponent: {
                                    component: BannerComponent,
                                },
                                BannerComponent: {
                                    component: BannerComponent,
                                },
                                SimpleBannerComponent: {
                                    component: BannerComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [BannerComponent],
                    exports: [BannerComponent],
                }]
        }] });

/**
 * Default component handler used for dynamically launching cms components implemented
 * as native Angular components.
 */
class DefaultComponentHandler {
    hasMatch(componentMapping) {
        return typeof componentMapping.component === 'function';
    }
    getPriority() {
        return -50 /* FALLBACK */;
    }
    launcher(componentMapping, viewContainerRef, elementInjector, module) {
        return new Observable((subscriber) => {
            let componentRef;
            const injector = elementInjector !== null && elementInjector !== void 0 ? elementInjector : viewContainerRef.injector;
            const dispose = () => {
                if (componentRef) {
                    componentRef.destroy();
                }
            };
            const factory = this.getComponentFactory(injector, componentMapping.component);
            if (factory) {
                componentRef = viewContainerRef.createComponent(factory, undefined, injector, undefined, module);
                subscriber.next({ elementRef: componentRef.location, componentRef });
            }
            return dispose;
        });
    }
    getComponentFactory(injector, component) {
        if (!component) {
            return null;
        }
        const factory = injector
            .get(ComponentFactoryResolver)
            .resolveComponentFactory(component);
        return factory;
    }
}
DefaultComponentHandler.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: DefaultComponentHandler, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
DefaultComponentHandler.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: DefaultComponentHandler, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: DefaultComponentHandler, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Lazy component handler used for launching lazy loaded cms components implemented
 * as native Angular components.
 */
class LazyComponentHandler {
    constructor(defaultHandler) {
        this.defaultHandler = defaultHandler;
    }
    /**
     * We want to mach dynamic import signature () => import('')
     */
    hasMatch(componentMapping) {
        return (typeof componentMapping.component === 'function' &&
            this.isNotClass(componentMapping.component));
    }
    isNotClass(symbol) {
        const signature = symbol.toString().substr(0, 20).replace(' ', '');
        return signature.startsWith('function()') || signature.startsWith('()=>');
    }
    getPriority() {
        return -10 /* LOW */;
    }
    launcher(componentMapping, viewContainerRef, elementInjector, module) {
        return from(componentMapping.component()).pipe(switchMap((component) => this.defaultHandler.launcher(Object.assign(Object.assign({}, componentMapping), { component }), viewContainerRef, elementInjector, module)));
    }
}
LazyComponentHandler.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: LazyComponentHandler, deps: [{ token: DefaultComponentHandler }], target: i0.ɵɵFactoryTarget.Injectable });
LazyComponentHandler.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: LazyComponentHandler, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: LazyComponentHandler, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: DefaultComponentHandler }]; } });

class InnerComponentsHostDirective {
    constructor(data, vcr, 
    // dependencies required for ComponentWrapper directive
    cmsComponentsService, injector, dynamicAttributeService, renderer, componentHandler, cmsInjector) {
        this.data = data;
        this.vcr = vcr;
        this.cmsComponentsService = cmsComponentsService;
        this.injector = injector;
        this.dynamicAttributeService = dynamicAttributeService;
        this.renderer = renderer;
        this.componentHandler = componentHandler;
        this.cmsInjector = cmsInjector;
        this.innerComponents$ = this.data.data$.pipe(map((data) => { var _a, _b; return (_b = (_a = data === null || data === void 0 ? void 0 : data.composition) === null || _a === void 0 ? void 0 : _a.inner) !== null && _b !== void 0 ? _b : []; }));
        this.componentWrappers = [];
    }
    ngOnInit() {
        this.subscription = this.innerComponents$.subscribe((x) => {
            this.renderComponents(x);
        });
    }
    renderComponents(components) {
        this.clearComponents();
        components.forEach((component) => this.renderComponent(component));
    }
    renderComponent(component) {
        const componentWrapper = new ComponentWrapperDirective(this.vcr, this.cmsComponentsService, this.injector, this.dynamicAttributeService, this.renderer, this.componentHandler, this.cmsInjector);
        componentWrapper.cxComponentWrapper = { flexType: component, uid: '' };
        componentWrapper.ngOnInit();
        this.componentWrappers.push(componentWrapper);
    }
    clearComponents() {
        this.componentWrappers.forEach((wrapper) => wrapper.ngOnDestroy());
        this.componentWrappers = [];
    }
    ngOnDestroy() {
        var _a;
        (_a = this.subscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();
        this.clearComponents();
    }
}
InnerComponentsHostDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: InnerComponentsHostDirective, deps: [{ token: CmsComponentData }, { token: i0.ViewContainerRef }, { token: CmsComponentsService }, { token: i0.Injector }, { token: i1.DynamicAttributeService }, { token: i0.Renderer2 }, { token: ComponentHandlerService }, { token: CmsInjectorService }], target: i0.ɵɵFactoryTarget.Directive });
InnerComponentsHostDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.5", type: InnerComponentsHostDirective, selector: "[cxInnerComponentsHost]", ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: InnerComponentsHostDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cxInnerComponentsHost]',
                }]
        }], ctorParameters: function () { return [{ type: CmsComponentData }, { type: i0.ViewContainerRef }, { type: CmsComponentsService }, { type: i0.Injector }, { type: i1.DynamicAttributeService }, { type: i0.Renderer2 }, { type: ComponentHandlerService }, { type: CmsInjectorService }]; } });

class PageComponentModule {
    static forRoot() {
        return {
            ngModule: PageComponentModule,
            providers: [
                {
                    provide: ComponentHandler,
                    useExisting: DefaultComponentHandler,
                    multi: true,
                },
                {
                    provide: ComponentHandler,
                    useExisting: LazyComponentHandler,
                    multi: true,
                },
            ],
        };
    }
}
PageComponentModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PageComponentModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
PageComponentModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PageComponentModule, declarations: [ComponentWrapperDirective, InnerComponentsHostDirective], imports: [CommonModule], exports: [ComponentWrapperDirective, InnerComponentsHostDirective] });
PageComponentModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PageComponentModule, imports: [[CommonModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PageComponentModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [ComponentWrapperDirective, InnerComponentsHostDirective],
                    exports: [ComponentWrapperDirective, InnerComponentsHostDirective],
                }]
        }] });

class PageSlotModule {
    // instantiate PageSlotService ASAP, so it can examine SSR pre-rendered DOM
    constructor(_pageSlot) { }
}
PageSlotModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PageSlotModule, deps: [{ token: PageSlotService }], target: i0.ɵɵFactoryTarget.NgModule });
PageSlotModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PageSlotModule, declarations: [PageSlotComponent], imports: [CommonModule, OutletModule, PageComponentModule], exports: [PageSlotComponent] });
PageSlotModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PageSlotModule, imports: [[CommonModule, OutletModule, PageComponentModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PageSlotModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, OutletModule, PageComponentModule],
                    declarations: [PageSlotComponent],
                    exports: [PageSlotComponent],
                }]
        }], ctorParameters: function () { return [{ type: PageSlotService }]; } });

class PageLayoutModule {
}
PageLayoutModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PageLayoutModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
PageLayoutModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PageLayoutModule, declarations: [PageLayoutComponent, PageTemplateDirective], imports: [CommonModule, OutletModule, PageSlotModule], exports: [PageLayoutComponent, PageTemplateDirective] });
PageLayoutModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PageLayoutModule, imports: [[CommonModule, OutletModule, PageSlotModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PageLayoutModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, OutletModule, PageSlotModule],
                    declarations: [PageLayoutComponent, PageTemplateDirective],
                    exports: [PageLayoutComponent, PageTemplateDirective],
                }]
        }] });

class PWAModuleConfig {
}
PWAModuleConfig.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PWAModuleConfig, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
PWAModuleConfig.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PWAModuleConfig, providedIn: 'root', useExisting: Config });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PWAModuleConfig, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                    useExisting: Config,
                }]
        }] });
const defaultPWAModuleConfig = {
    pwa: {
        enabled: false,
        addToHomeScreen: false,
    },
};

class AddToHomeScreenService {
    constructor(config, globalMessageService, winRef) {
        this.config = config;
        this.globalMessageService = globalMessageService;
        this.winRef = winRef;
        this.canPrompt = new BehaviorSubject(false);
        this.canPrompt$ = this.canPrompt.asObservable();
        if (this.config.pwa.addToHomeScreen) {
            this.init();
        }
    }
    init() {
        if (this.winRef.nativeWindow) {
            this.winRef.nativeWindow.addEventListener('beforeinstallprompt', (event) => {
                event.preventDefault();
                this.deferredEvent = event;
                this.enableAddToHomeScreen();
            });
            this.winRef.nativeWindow.addEventListener('appinstalled', () => {
                this.globalMessageService.add({ key: 'pwa.addedToHomeScreen' }, GlobalMessageType.MSG_TYPE_CONFIRMATION);
                this.disableAddToHomeScreen();
                this.deferredEvent = null;
            });
        }
    }
    enableAddToHomeScreen() {
        this.canPrompt.next(true);
    }
    disableAddToHomeScreen() {
        this.canPrompt.next(false);
    }
    firePrompt() {
        if (this.deferredEvent) {
            this.deferredEvent.prompt();
        }
    }
}
AddToHomeScreenService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AddToHomeScreenService, deps: [{ token: PWAModuleConfig }, { token: i1.GlobalMessageService }, { token: i1.WindowRef }], target: i0.ɵɵFactoryTarget.Injectable });
AddToHomeScreenService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AddToHomeScreenService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AddToHomeScreenService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: PWAModuleConfig }, { type: i1.GlobalMessageService }, { type: i1.WindowRef }]; } });

// eslint-disable-next-line @angular-eslint/directive-class-suffix
class AddToHomeScreenComponent {
    constructor(addToHomeScreenService) {
        this.addToHomeScreenService = addToHomeScreenService;
    }
    ngOnInit() {
        this.canPrompt$ = this.addToHomeScreenService.canPrompt$;
    }
    prompt() {
        this.addToHomeScreenService.firePrompt();
    }
}
AddToHomeScreenComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AddToHomeScreenComponent, deps: [{ token: AddToHomeScreenService }], target: i0.ɵɵFactoryTarget.Directive });
AddToHomeScreenComponent.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.5", type: AddToHomeScreenComponent, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AddToHomeScreenComponent, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: AddToHomeScreenService }]; } });

class AddToHomeScreenBannerComponent extends AddToHomeScreenComponent {
    constructor(addToHomeScreenService) {
        super(addToHomeScreenService);
        this.addToHomeScreenService = addToHomeScreenService;
    }
}
AddToHomeScreenBannerComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AddToHomeScreenBannerComponent, deps: [{ token: AddToHomeScreenService }], target: i0.ɵɵFactoryTarget.Component });
AddToHomeScreenBannerComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: AddToHomeScreenBannerComponent, selector: "cx-add-to-home-screen-banner", usesInheritance: true, ngImport: i0, template: "<div *ngIf=\"canPrompt$ | async\">\n  <div class=\"cx-add-to-home-screen-banner\">\n    <div class=\"cx-add-to-home-screen-banner-inner\">\n      <p>\n        {{ 'pwa.addToHomeScreenDescription' | cxTranslate }}\n      </p>\n      <ul>\n        <li>{{ 'pwa.noInstallationNeeded' | cxTranslate }}</li>\n        <li>{{ 'pwa.fastAccessToApplication' | cxTranslate }}</li>\n      </ul>\n      <button (click)=\"prompt()\" class=\"btn btn-primary\">\n        {{ 'pwa.addToHomeScreen' | cxTranslate }}\n      </button>\n    </div>\n  </div>\n</div>\n", directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "async": i3.AsyncPipe, "cxTranslate": i1.TranslatePipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AddToHomeScreenBannerComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-add-to-home-screen-banner',
                    templateUrl: './add-to-home-screen-banner.component.html',
                }]
        }], ctorParameters: function () { return [{ type: AddToHomeScreenService }]; } });

class AddToHomeScreenBtnComponent extends AddToHomeScreenComponent {
    constructor(addToHomeScreenService) {
        super(addToHomeScreenService);
        this.addToHomeScreenService = addToHomeScreenService;
    }
}
AddToHomeScreenBtnComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AddToHomeScreenBtnComponent, deps: [{ token: AddToHomeScreenService }], target: i0.ɵɵFactoryTarget.Component });
AddToHomeScreenBtnComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: AddToHomeScreenBtnComponent, selector: "cx-add-to-home-screen-btn", usesInheritance: true, ngImport: i0, template: "<span (click)=\"prompt()\">\n  <ng-content *ngIf=\"canPrompt$ | async\"></ng-content>\n</span>\n", directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "async": i3.AsyncPipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AddToHomeScreenBtnComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-add-to-home-screen-btn',
                    templateUrl: './add-to-home-screen-btn.component.html',
                }]
        }], ctorParameters: function () { return [{ type: AddToHomeScreenService }]; } });

function pwaConfigurationFactory(pwaConfig) {
    return { enabled: (!isDevMode() && pwaConfig.pwa.enabled) || false };
}
function pwaFactory(addToHomeScreenService) {
    const result = () => addToHomeScreenService;
    return result;
}
class PwaModule {
}
PwaModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PwaModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
PwaModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PwaModule, declarations: [AddToHomeScreenBtnComponent, AddToHomeScreenBannerComponent], imports: [CommonModule, i1$6.ServiceWorkerModule, I18nModule], exports: [AddToHomeScreenBtnComponent, AddToHomeScreenBannerComponent] });
PwaModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PwaModule, providers: [
        provideDefaultConfig(defaultPWAModuleConfig),
        {
            provide: SwRegistrationOptions,
            useFactory: pwaConfigurationFactory,
            deps: [Config],
        },
        {
            provide: APP_INITIALIZER,
            useFactory: pwaFactory,
            deps: [AddToHomeScreenService],
            multi: true,
        },
    ], imports: [[
            CommonModule,
            ServiceWorkerModule.register('ngsw-worker.js'),
            I18nModule,
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PwaModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        ServiceWorkerModule.register('ngsw-worker.js'),
                        I18nModule,
                    ],
                    providers: [
                        provideDefaultConfig(defaultPWAModuleConfig),
                        {
                            provide: SwRegistrationOptions,
                            useFactory: pwaConfigurationFactory,
                            deps: [Config],
                        },
                        {
                            provide: APP_INITIALIZER,
                            useFactory: pwaFactory,
                            deps: [AddToHomeScreenService],
                            multi: true,
                        },
                    ],
                    declarations: [AddToHomeScreenBtnComponent, AddToHomeScreenBannerComponent],
                    exports: [AddToHomeScreenBtnComponent, AddToHomeScreenBannerComponent],
                }]
        }] });

const cmsRoute = {
    path: '**',
    canActivate: [CmsPageGuard],
    component: PageLayoutComponent,
};
function addCmsRoute(injector) {
    const result = () => {
        const router = injector.get(Router);
        router.config.push(cmsRoute);
    };
    return result;
}

class CmsRouteModule {
}
CmsRouteModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CmsRouteModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
CmsRouteModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CmsRouteModule });
CmsRouteModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CmsRouteModule, providers: [
        {
            provide: APP_INITIALIZER,
            multi: true,
            deps: [Injector],
            useFactory: addCmsRoute,
        },
    ] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CmsRouteModule, decorators: [{
            type: NgModule,
            args: [{
                    providers: [
                        {
                            provide: APP_INITIALIZER,
                            multi: true,
                            deps: [Injector],
                            useFactory: addCmsRoute,
                        },
                    ],
                }]
        }] });

const defaultStorefrontRoutesConfig = {
    home: { paths: [''] },
    notFound: { paths: ['not-found'] },
    cart: { paths: ['cart'] },
    // semantic links for login related pages
    login: {
        paths: ['login'],
        protected: false,
        authFlow: true,
    },
    register: {
        paths: ['login/register'],
        protected: false,
        authFlow: true,
    },
    forgotPassword: {
        paths: ['login/forgot-password'],
        protected: false,
        authFlow: true,
    },
    resetPassword: {
        paths: ['login/pw/change'],
        protected: false,
        authFlow: true,
    },
    logout: { paths: ['logout'], protected: false, authFlow: true },
    // plp routes
    search: { paths: ['search/:query'] },
    category: {
        paths: ['category/:categoryCode'],
        paramsMapping: { categoryCode: 'code' },
    },
    brand: { paths: ['Brands/:brandName/c/:brandCode'] },
    // pdp routes
    product: {
        paths: ['product/:productCode/:name'],
        paramsMapping: { productCode: 'code' },
    },
    termsAndConditions: { paths: ['terms-and-conditions'] },
    /** @deprecated since 4.2, use order lib instead */
    orders: {
        paths: ['my-account/orders'],
    },
    /** @deprecated since 4.2, use order lib instead */
    orderDetails: {
        paths: ['my-account/order/:orderCode'],
        paramsMapping: { orderCode: 'code' },
    },
    /** @deprecated since 4.2, use order lib instead */
    orderGuest: {
        paths: ['guest/order/:orderCode'],
        paramsMapping: { orderCode: 'code' },
    },
    /** @deprecated since 4.2, use order lib instead */
    orderReturn: {
        paths: ['my-account/order/return/:orderCode'],
        paramsMapping: { orderCode: 'code' },
    },
    /** @deprecated since 4.2, use order lib instead */
    orderReturnConfirmation: {
        paths: ['my-account/order/return/confirmation/:orderCode'],
        paramsMapping: { orderCode: 'code' },
    },
    /** @deprecated since 4.2, use order lib instead */
    orderCancel: {
        paths: ['my-account/order/cancel/:orderCode'],
        paramsMapping: { orderCode: 'code' },
    },
    /** @deprecated since 4.2, use order lib instead */
    orderCancelConfirmation: {
        paths: ['my-account/order/cancel/confirmation/:orderCode'],
        paramsMapping: { orderCode: 'code' },
    },
    /** @deprecated since 4.2, use order lib instead */
    returnRequestDetails: {
        paths: ['my-account/return-request/:returnCode'],
        paramsMapping: { returnCode: 'rma' },
    },
    coupons: { paths: ['my-account/coupons'] },
    couponClaim: {
        paths: ['my-account/coupon/claim/:couponCode'],
        paramsMapping: { couponCode: 'code' },
    },
    /** @deprecated since 4.2, use order lib instead */
    replenishmentOrders: {
        paths: ['my-account/my-replenishments'],
    },
    /** @deprecated since 4.2, use order lib instead */
    replenishmentDetails: {
        paths: ['my-account/my-replenishment/:replenishmentOrderCode'],
        paramsMapping: { replenishmentOrderCode: 'replenishmentOrderCode' },
    },
};
const defaultRoutingConfig = {
    routing: {
        routes: defaultStorefrontRoutesConfig,
    },
};

class RoutingModule {
    static forRoot() {
        return {
            ngModule: RoutingModule,
            providers: [provideDefaultConfig(defaultRoutingConfig)],
        };
    }
}
RoutingModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: RoutingModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
RoutingModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: RoutingModule, imports: [i1.RoutingModule, CmsRouteModule] });
RoutingModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: RoutingModule, imports: [[RoutingModule$1.forRoot(), CmsRouteModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: RoutingModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [RoutingModule$1.forRoot(), CmsRouteModule],
                }]
        }] });

/**
 * Matches the pattern '[ ** / ] marker / :paramName'
 *
 * @param marker phrase that indicates the start of the match
 * @param paramName name of the parameter present after the marker
 * @param precedingParamName name of the parameter for every preceding url segment
 *        i.e. `param` will result in `param0`, `param1`, ...
 */
function getSuffixUrlMatcher({ marker, paramName, precedingParamName, }) {
    precedingParamName = precedingParamName || 'param';
    const matcher = function suffixUrlMatcher(segments) {
        const markerIndex = findLastIndex(segments, ({ path }) => path === marker);
        const isMarkerLastSegment = markerIndex === segments.length - 1;
        if (markerIndex === -1 || isMarkerLastSegment) {
            return null;
        }
        const paramIndex = markerIndex + 1;
        const posParams = {
            [paramName]: segments[paramIndex],
        };
        for (let i = 0; i < markerIndex; i++) {
            posParams[`${precedingParamName}${i}`] = segments[i];
        }
        return { consumed: segments.slice(0, paramIndex + 1), posParams };
    };
    if (isDevMode()) {
        matcher['_suffixRouteConfig'] = { marker, paramName, precedingParamName }; // property added for easier debugging of routes
    }
    return matcher;
}
function findLastIndex(elements, predicate) {
    for (let index = elements.length - 1; index >= 0; index--) {
        if (predicate(elements[index])) {
            return index;
        }
    }
    return -1;
}

class PageMetaLinkService {
    constructor(winRef, rendererFactory) {
        this.winRef = winRef;
        this.rendererFactory = rendererFactory;
    }
    /**
     * Adds a canonical link element to the document head.
     *
     * If an id is provided, the link will be updated.
     * If no url is provided, the link element will be deleted.
     */
    setCanonicalLink(url) {
        let link = this.winRef.document.querySelector('link[rel="canonical"]');
        if (!url) {
            // Removing the link is an edge case, but useful if the canonical url
            // is created in CSR while developing/testing.
            link === null || link === void 0 ? void 0 : link.remove();
            return;
        }
        if (!link) {
            link = this.renderer.createElement('link');
            link.rel = 'canonical';
            link.href = url;
            this.renderer.appendChild(this.winRef.document.head, link);
        }
        else {
            link === null || link === void 0 ? void 0 : link.setAttribute('href', url);
        }
    }
    get renderer() {
        return this.rendererFactory.createRenderer(null, null);
    }
}
PageMetaLinkService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PageMetaLinkService, deps: [{ token: i1.WindowRef }, { token: i0.RendererFactory2 }], target: i0.ɵɵFactoryTarget.Injectable });
PageMetaLinkService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PageMetaLinkService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PageMetaLinkService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.WindowRef }, { type: i0.RendererFactory2 }]; } });

class SeoMetaService {
    constructor(ngTitle, ngMeta, pageMetaService, pageMetaLinkService) {
        this.ngTitle = ngTitle;
        this.ngMeta = ngMeta;
        this.pageMetaService = pageMetaService;
        this.pageMetaLinkService = pageMetaLinkService;
    }
    init() {
        this.subscription = this.pageMetaService
            .getMeta()
            .pipe(filter(isNotNullable))
            .subscribe((meta) => (this.meta = meta));
    }
    set meta(meta) {
        this.title = meta.title;
        this.description = meta.description;
        this.image = meta.image;
        this.robots = meta.robots;
        this.canonicalUrl = meta.canonicalUrl;
    }
    set title(title) {
        this.ngTitle.setTitle(title || '');
    }
    set description(value) {
        if (value) {
            this.addTag({ name: 'description', content: value || '' });
        }
        else {
            this.ngMeta.removeTag('name="description"');
        }
    }
    set image(imageUrl) {
        if (imageUrl) {
            this.addTag({ name: 'og:image', content: imageUrl });
        }
        else {
            this.ngMeta.removeTag('name="og:image"');
        }
    }
    set robots(value) {
        if (value && value.length > 0) {
            this.addTag({ name: 'robots', content: value.join(', ') });
        }
    }
    /**
     * Add the canonical Url to the head of the page.
     *
     * If the canonical url already exists the link is removed. This is quite
     * unlikely though, since canonical links are (typically) only added in SSR.
     */
    set canonicalUrl(url) {
        var _a;
        (_a = this.pageMetaLinkService) === null || _a === void 0 ? void 0 : _a.setCanonicalLink(url);
    }
    addTag(meta) {
        if (meta.content) {
            this.ngMeta.updateTag(meta);
        }
    }
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
    }
}
SeoMetaService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SeoMetaService, deps: [{ token: i1$2.Title }, { token: i1$2.Meta }, { token: i1.PageMetaService }, { token: PageMetaLinkService }], target: i0.ɵɵFactoryTarget.Injectable });
SeoMetaService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SeoMetaService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SeoMetaService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1$2.Title }, { type: i1$2.Meta }, { type: i1.PageMetaService }, { type: PageMetaLinkService }]; } });

const defaultSeoConfig = {
    seo: {
        structuredData: {
            disableInDevMode: true,
        },
    },
};

class SeoConfig {
}
SeoConfig.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SeoConfig, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
SeoConfig.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SeoConfig, providedIn: 'root', useExisting: Config });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SeoConfig, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                    useExisting: Config,
                }]
        }] });

const htmlLangProvider = {
    provide: APP_INITIALIZER,
    multi: true,
    useFactory: setHtmlLangAttribute,
    deps: [WindowRef, LanguageService],
};
/**
 * Sets active language in <html lang="">
 */
function setHtmlLangAttribute(winRef, languageService) {
    const result = () => {
        languageService.getActive().subscribe((lang) => {
            winRef.document.documentElement.lang = lang.replace(/_/g, '-');
        });
    };
    return result;
}

class JsonLdScriptFactory {
    constructor(platformId, winRef, rendererFactory, sanitizer, config) {
        this.platformId = platformId;
        this.winRef = winRef;
        this.rendererFactory = rendererFactory;
        this.sanitizer = sanitizer;
        this.config = config;
    }
    build(schema) {
        if (schema && this.isJsonLdRequired()) {
            this.getJsonLdScriptElement().innerHTML = this.sanitize(schema);
        }
    }
    /**
     * Indicates whether json ld data should be generated.
     *
     * This is only required on the server, but can be enabled in dev mode.
     */
    isJsonLdRequired() {
        var _a, _b;
        return (!isPlatformBrowser(this.platformId) ||
            (isDevMode() && !((_b = (_a = this.config.seo) === null || _a === void 0 ? void 0 : _a.structuredData) === null || _b === void 0 ? void 0 : _b.disableInDevMode)));
    }
    /**
     * Creates a json-ld script element. The element is created one, and appended
     * to the html body element.
     *
     * ```html
     * <script id="json-ld" type="application/ld+json">
     * </script>
     * ```
     */
    getJsonLdScriptElement() {
        const id = 'json-ld';
        let scriptElement = (this.winRef.document.getElementById(id));
        if (!scriptElement) {
            const renderer = this.rendererFactory.createRenderer(null, null);
            const script = renderer.createElement('script');
            script.id = id;
            script.type = 'application/ld+json';
            renderer.appendChild(this.winRef.document.body, script);
            scriptElement = script;
        }
        return scriptElement;
    }
    /**
     * Sanitizes the given json-ld schema by leveraging the angular HTML sanitizer.
     *
     * The given schema is not trusted, as malicious code could be injected (XSS)
     * into the json-ld script.
     */
    sanitize(schema) {
        return JSON.stringify(schema, (_key, value) => typeof value === 'string'
            ? this.sanitizer.sanitize(SecurityContext.HTML, value)
            : value);
    }
}
JsonLdScriptFactory.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: JsonLdScriptFactory, deps: [{ token: PLATFORM_ID }, { token: i1.WindowRef }, { token: i0.RendererFactory2 }, { token: i1$2.DomSanitizer }, { token: SeoConfig }], target: i0.ɵɵFactoryTarget.Injectable });
JsonLdScriptFactory.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: JsonLdScriptFactory, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: JsonLdScriptFactory, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [PLATFORM_ID]
                }] }, { type: i1.WindowRef }, { type: i0.RendererFactory2 }, { type: i1$2.DomSanitizer }, { type: SeoConfig }]; } });

/**
 * Low level directive that adds a json-ld script tag to the component.
 * This code bypasses the strict XSS security, as otherwise we're not able
 * to append a script tag with JS inside.
 *
 * This helper directive is actually not used in Spartacus, as Spartacus
 * appends json-ld the data to the document body.
 *
 * This directive can however be used by merchants to write static schema data
 * to the DOM in a save way.
 */
class JsonLdDirective {
    constructor(jsonLdScriptFactory, sanitizer) {
        this.jsonLdScriptFactory = jsonLdScriptFactory;
        this.sanitizer = sanitizer;
    }
    /**
     * Writes the schema data to a json-ld script element.
     */
    set cxJsonLd(schema) {
        this.jsonLD = this.generateJsonLdScript(schema);
    }
    /**
     * Returns the json-ld script tag with the schema data. The script is
     * _bypassing_ sanitization explicitly.
     */
    generateJsonLdScript(schema) {
        if (schema && this.jsonLdScriptFactory.isJsonLdRequired()) {
            const sanitizedSchema = this.jsonLdScriptFactory.sanitize(schema);
            const html = `<script type="application/ld+json">${sanitizedSchema}</script>`;
            return this.sanitizer.bypassSecurityTrustHtml(html);
        }
    }
}
JsonLdDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: JsonLdDirective, deps: [{ token: JsonLdScriptFactory }, { token: i1$2.DomSanitizer }], target: i0.ɵɵFactoryTarget.Directive });
JsonLdDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.5", type: JsonLdDirective, selector: "[cxJsonLd]", inputs: { cxJsonLd: "cxJsonLd" }, host: { properties: { "innerHTML": "this.jsonLD" } }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: JsonLdDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cxJsonLd]',
                }]
        }], ctorParameters: function () { return [{ type: JsonLdScriptFactory }, { type: i1$2.DomSanitizer }]; }, propDecorators: { cxJsonLd: [{
                type: Input
            }], jsonLD: [{
                type: HostBinding,
                args: ['innerHTML']
            }] } });

/**
 * Injection token to extend schema builders for adding structural data (json-ld).
 *
 * Some builders (i.e. `JSONLD_PRODUCT_BUILDER`) might have additional
 * lower level builder to further extend the schema.
 */
const SCHEMA_BUILDER = new InjectionToken('SchemaBuilderToken');
/**
 * Injection token to add specific json-ld builders for product related schemas.
 * See see https://schema.org/product for more information.
 */
const JSONLD_PRODUCT_BUILDER = new InjectionToken('JsonLdProductBuilderToken');

/**
 * Factory service that is used to build the structured data for
 * all configured schema builders.
 */
class StructuredDataFactory {
    constructor(scriptBuilder, builders) {
        this.scriptBuilder = scriptBuilder;
        this.builders = builders;
        this.subscription = new Subscription();
    }
    /**
     * Initiates the build of structured data by collecting all schema
     * builders.
     */
    build() {
        if (this.scriptBuilder.isJsonLdRequired() && this.builders) {
            this.subscription.add(this.collectSchemas().subscribe((schema) => {
                this.scriptBuilder.build(schema);
            }));
        }
    }
    /**
     * Collects all schema builders and observe their structured data.
     */
    collectSchemas() {
        return combineLatest(this.builders.map((builder) => builder.build()));
    }
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
}
StructuredDataFactory.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: StructuredDataFactory, deps: [{ token: JsonLdScriptFactory }, { token: SCHEMA_BUILDER, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });
StructuredDataFactory.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: StructuredDataFactory, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: StructuredDataFactory, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: JsonLdScriptFactory }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [SCHEMA_BUILDER]
                }] }]; } });

/**
 * Factory to build the structure data
 * without any interaction with the UI.
 */
function getStructuredDataFactory(injector) {
    const result = () => {
        const factory = injector.get(StructuredDataFactory);
        factory.build();
    };
    return result;
}
class StructuredDataModule {
}
StructuredDataModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: StructuredDataModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
StructuredDataModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: StructuredDataModule, declarations: [JsonLdDirective], imports: [CommonModule], exports: [JsonLdDirective] });
StructuredDataModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: StructuredDataModule, providers: [
        {
            provide: APP_INITIALIZER,
            useFactory: getStructuredDataFactory,
            deps: [Injector],
            multi: true,
        },
    ], imports: [[CommonModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: StructuredDataModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [JsonLdDirective],
                    exports: [JsonLdDirective],
                    providers: [
                        {
                            provide: APP_INITIALIZER,
                            useFactory: getStructuredDataFactory,
                            deps: [Injector],
                            multi: true,
                        },
                    ],
                }]
        }] });

function initSeoService(injector) {
    const result = () => {
        const service = injector.get(SeoMetaService);
        service.init();
    };
    return result;
}
class SeoModule {
}
SeoModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SeoModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
SeoModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SeoModule, imports: [StructuredDataModule] });
SeoModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SeoModule, providers: [
        provideDefaultConfig(defaultSeoConfig),
        {
            provide: APP_INITIALIZER,
            useFactory: initSeoService,
            deps: [Injector],
            multi: true,
        },
        htmlLangProvider,
    ], imports: [[StructuredDataModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SeoModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [StructuredDataModule],
                    providers: [
                        provideDefaultConfig(defaultSeoConfig),
                        {
                            provide: APP_INITIALIZER,
                            useFactory: initSeoService,
                            deps: [Injector],
                            multi: true,
                        },
                        htmlLangProvider,
                    ],
                }]
        }] });

class BreadcrumbSchemaBuilder {
    constructor(pageMetaService) {
        this.pageMetaService = pageMetaService;
    }
    build() {
        return this.pageMetaService
            .getMeta()
            .pipe(map((pageMeta) => this.collect(pageMeta)));
    }
    collect(pageMeta) {
        if (!(pageMeta === null || pageMeta === void 0 ? void 0 : pageMeta.breadcrumbs)) {
            return;
        }
        const crumbs = pageMeta.breadcrumbs.map((crumb, index) => {
            return {
                '@type': 'ListItem',
                position: index + 1,
                item: {
                    '@id': crumb.link,
                    name: crumb.label,
                },
            };
        });
        if (pageMeta.title) {
            crumbs.push({
                '@type': 'ListItem',
                position: crumbs.length + 1,
                item: {
                    '@id': pageMeta.title,
                    name: pageMeta.title,
                },
            });
        }
        return {
            '@context': 'http://schema.org',
            '@type': 'BreadcrumbList',
            itemListElement: crumbs,
        };
    }
}
BreadcrumbSchemaBuilder.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: BreadcrumbSchemaBuilder, deps: [{ token: i1.PageMetaService }], target: i0.ɵɵFactoryTarget.Injectable });
BreadcrumbSchemaBuilder.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: BreadcrumbSchemaBuilder, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: BreadcrumbSchemaBuilder, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.PageMetaService }]; } });

/**
 * Builds the basic structured data for the product, see https://schema.org/product.
 * This builder includes data for sku number, name, description, brand and main image.
 */
class JsonLdBaseProductBuilder {
    build(product) {
        return of(Object.assign(Object.assign(Object.assign({}, this.getProductBase(product)), this.getProductBrand(product)), this.getProductImage(product)));
    }
    /**
     * Returns the product sku, name and description.
     */
    getProductBase(product) {
        const result = { sku: product.code };
        if (product.name) {
            result.name = product.name;
        }
        if (product.summary) {
            result.description = product.summary;
        }
        return result;
    }
    /**
     * Returns the image object with the main product image url.
     *
     * If the image is not available, an empty object is returned.
     */
    getProductImage(product) {
        var _a, _b, _c;
        const image = (_c = (_b = (_a = product.images) === null || _a === void 0 ? void 0 : _a.PRIMARY) === null || _b === void 0 ? void 0 : _b['zoom']) === null || _c === void 0 ? void 0 : _c.url;
        return image ? { image } : {};
    }
    /**
     * Returns the brand object with the product manufacturer.
     *
     * If the brand is not available, an empty object is returned.
     */
    getProductBrand(product) {
        const brand = product.manufacturer;
        return brand ? { brand } : {};
    }
}
JsonLdBaseProductBuilder.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: JsonLdBaseProductBuilder, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
JsonLdBaseProductBuilder.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: JsonLdBaseProductBuilder, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: JsonLdBaseProductBuilder, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Builds the structured data for the product offer, see https://schema.org/offers.
 * The data includes the price, currency and availability level.
 */
class JsonLdProductOfferBuilder {
    build(product) {
        var _a;
        const schema = { '@type': 'Offer' };
        if ((_a = product.price) === null || _a === void 0 ? void 0 : _a.value) {
            schema.price = product.price.value;
            if (product.price.currencyIso) {
                schema.priceCurrency = product.price.currencyIso;
            }
        }
        if (product.stock && product.stock.stockLevelStatus) {
            schema.availability =
                product.stock.stockLevelStatus === 'inStock' ? 'InStock' : 'OutOfStock';
        }
        return of({ offers: schema });
    }
}
JsonLdProductOfferBuilder.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: JsonLdProductOfferBuilder, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
JsonLdProductOfferBuilder.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: JsonLdProductOfferBuilder, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: JsonLdProductOfferBuilder, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Builds the structured data for the product reviews, see https://schema.org/Review.
 * The data includes the aggregated product rating and the individual reviews.
 */
class JsonLdProductReviewBuilder {
    constructor(reviewService, config) {
        this.reviewService = reviewService;
        this.config = config;
    }
    build(product) {
        return this.reviewService.getByProductCode(product.code).pipe(map((reviews) => (reviews === null || reviews === void 0 ? void 0 : reviews.length) > 0
            ? {
                aggregateRating: this.buildAggregatedReviews(product, reviews),
                review: reviews.map((review) => this.buildReviews(review)),
            }
            : {}));
    }
    buildAggregatedReviews(product, reviews) {
        const aggregated = {
            '@type': 'AggregateRating',
        };
        if (product.averageRating) {
            aggregated.ratingValue = product.averageRating;
        }
        if (reviews) {
            aggregated.ratingCount = reviews.filter((rev) => !!rev.rating).length;
            aggregated.reviewCount = reviews.filter((rev) => !!rev.comment).length;
        }
        return aggregated;
    }
    buildReviews(review) {
        const reviewSchema = {
            '@type': 'review',
        };
        if (review.principal && review.principal.name) {
            reviewSchema.author = review.principal.name;
        }
        if (review.date) {
            const date = new Date(review.date);
            reviewSchema.datePublished = `${date.getFullYear()}-${date.getMonth() + 1}-${date.getDate()}`;
        }
        if (review.headline) {
            reviewSchema.name = review.headline;
        }
        if (review.comment) {
            reviewSchema.description = review.comment;
        }
        if (review.rating) {
            reviewSchema.reviewRating = {
                '@type': 'Rating',
                ratingValue: review.rating.toString(),
            };
        }
        return reviewSchema;
    }
}
JsonLdProductReviewBuilder.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: JsonLdProductReviewBuilder, deps: [{ token: i1.ProductReviewService }, { token: SeoConfig }], target: i0.ɵɵFactoryTarget.Injectable });
JsonLdProductReviewBuilder.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: JsonLdProductReviewBuilder, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: JsonLdProductReviewBuilder, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.ProductReviewService }, { type: SeoConfig }]; } });

/**
 * Adds the minimal structured data for the product, see https://schema.org/product.
 * The actual data collection is delegated to `JsonLdBuilder`s, which can be injected
 * using the `JSONLD_PRODUCT_BUILDER` token.
 */
class ProductSchemaBuilder {
    constructor(currentProduct, builders) {
        this.currentProduct = currentProduct;
        this.builders = builders;
    }
    build() {
        return this.currentProduct.getProduct().pipe(switchMap((product) => {
            if (product) {
                return combineLatest(this.collect(product)).pipe(map((res) => Object.assign({}, ...res)));
            }
            return of({});
        }));
    }
    collect(product) {
        if (!product || !product.code) {
            return [];
        }
        const builders = this.builders
            ? this.builders.map((builder) => builder.build(product))
            : [];
        return [
            of({
                '@context': 'http://schema.org',
                '@type': 'Product',
            }),
            ...builders,
        ];
    }
}
ProductSchemaBuilder.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductSchemaBuilder, deps: [{ token: CurrentProductService }, { token: JSONLD_PRODUCT_BUILDER, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });
ProductSchemaBuilder.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductSchemaBuilder, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductSchemaBuilder, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: CurrentProductService }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [JSONLD_PRODUCT_BUILDER]
                }] }]; } });

/**
 * Provides several standard json-ld builders that contribute
 * to collecting and building json-ld data.
 */
class JsonLdBuilderModule {
}
JsonLdBuilderModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: JsonLdBuilderModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
JsonLdBuilderModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: JsonLdBuilderModule });
JsonLdBuilderModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: JsonLdBuilderModule, providers: [
        {
            provide: SCHEMA_BUILDER,
            useExisting: ProductSchemaBuilder,
            multi: true,
        },
        {
            provide: SCHEMA_BUILDER,
            useExisting: BreadcrumbSchemaBuilder,
            multi: true,
        },
        // lower level json-ld builder classes offering fine-grained control
        // for product related schemas
        {
            provide: JSONLD_PRODUCT_BUILDER,
            useExisting: JsonLdBaseProductBuilder,
            multi: true,
        },
        {
            provide: JSONLD_PRODUCT_BUILDER,
            useExisting: JsonLdProductOfferBuilder,
            multi: true,
        },
        {
            provide: JSONLD_PRODUCT_BUILDER,
            useExisting: JsonLdProductReviewBuilder,
            multi: true,
        },
    ] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: JsonLdBuilderModule, decorators: [{
            type: NgModule,
            args: [{
                    providers: [
                        {
                            provide: SCHEMA_BUILDER,
                            useExisting: ProductSchemaBuilder,
                            multi: true,
                        },
                        {
                            provide: SCHEMA_BUILDER,
                            useExisting: BreadcrumbSchemaBuilder,
                            multi: true,
                        },
                        // lower level json-ld builder classes offering fine-grained control
                        // for product related schemas
                        {
                            provide: JSONLD_PRODUCT_BUILDER,
                            useExisting: JsonLdBaseProductBuilder,
                            multi: true,
                        },
                        {
                            provide: JSONLD_PRODUCT_BUILDER,
                            useExisting: JsonLdProductOfferBuilder,
                            multi: true,
                        },
                        {
                            provide: JSONLD_PRODUCT_BUILDER,
                            useExisting: JsonLdProductReviewBuilder,
                            multi: true,
                        },
                    ],
                }]
        }] });

var PageSection;
(function (PageSection) {
    PageSection["HEADER"] = "header";
    PageSection["FOOTER"] = "footer";
    PageSection["NAVIGATION"] = "navigation";
})(PageSection || (PageSection = {}));

/**
 * Helper function to simplify the creation of static CMS structure (`CmsStructureConfig`).
 * The helper function leverage the `provideConfig`, and is only providing an easy way to
 * generate the cms structure. The function creates a configuration structure for components,
 * page slot and page template. The following example adds a component to a page slot:
 *
 * ```ts
 * provideCmsStructure({
 *   componentId: 'LoginComponent',
 *   pageSlotPosition: 'SiteLogin'
 * })
 * ```
 *
 * @param options.componentId component identifier is used to provide component structure
 * @param options.pageSlotPosition page slot position is used to provide the slot configuration
 * @param options.pageTemplate the page template is used to provide the page slot to the given page template
 * @param options.section the section is used to provide the page slot to the given section
 * @param options.breakpoint the breakpoint is used to provide the page slot for a specific breakpoint
 */
function provideCmsStructure(options) {
    return provideConfig(Object.assign(Object.assign({}, buildCmsStructure(options)), buildLayoutConfig(options)));
}
/**
 * @private
 */
function buildCmsStructure({ componentId, pageSlotPosition, } = {}) {
    const config = { cmsStructure: {} };
    if (componentId) {
        config.cmsStructure = {
            components: {
                [componentId]: {
                    typeCode: componentId,
                    flexType: componentId,
                },
            },
        };
    }
    if (componentId && pageSlotPosition) {
        config.cmsStructure.slots = {
            [pageSlotPosition]: { componentIds: [componentId] },
        };
    }
    return config;
}
/**
 * @private
 */
function buildLayoutConfig({ pageTemplate, pageSlotPosition, breakpoint, section, } = {}) {
    const layoutConfig = {};
    if (pageTemplate && pageSlotPosition) {
        const pageTemplateSlots = {};
        if (breakpoint) {
            pageTemplateSlots[breakpoint] = {
                slots: [pageSlotPosition],
            };
        }
        else {
            pageTemplateSlots.slots = [pageSlotPosition];
        }
        layoutConfig.layoutSlots = {
            [pageTemplate]: pageTemplateSlots,
        };
    }
    if (section && pageSlotPosition) {
        const sectionSlots = {};
        if (breakpoint) {
            sectionSlots[breakpoint] = { slots: [pageSlotPosition] };
        }
        else {
            sectionSlots.slots = [pageSlotPosition];
        }
        if (layoutConfig.layoutSlots) {
            layoutConfig.layoutSlots[section] = sectionSlots;
        }
        else {
            layoutConfig.layoutSlots = {
                [section]: sectionSlots,
            };
        }
    }
    return layoutConfig;
}

/**
 * Generic carousel that renders CMS Components.
 */
class BannerCarouselComponent {
    constructor(componentData, cmsService) {
        this.componentData = componentData;
        this.cmsService = cmsService;
        this.componentData$ = this.componentData.data$.pipe(filter(Boolean), tap((d) => (this.theme = `${d.effect}-theme`)));
        this.items$ = this.componentData$.pipe(map((data) => data.banners.trim().split(' ')), map((codes) => codes.map((code) => this.cmsService.getComponentData(code))));
        /**
         * Adds a specific theme for the carousel. The effect can be
         * used in CSS customisations.
         */
        this.theme = '';
    }
    /**
     * Returns an Obervable with an Array of Observables. This is done, so that
     * the component UI could consider to lazy load the UI components when they're
     * in the viewpoint.
     */
    getItems() {
        return this.items$;
    }
}
BannerCarouselComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: BannerCarouselComponent, deps: [{ token: CmsComponentData }, { token: i1.CmsService }], target: i0.ɵɵFactoryTarget.Component });
BannerCarouselComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: BannerCarouselComponent, selector: "cx-banner-carousel", host: { properties: { "class": "this.theme" } }, ngImport: i0, template: "<cx-carousel\n  [items]=\"getItems() | async\"\n  [template]=\"template\"\n  itemWidth=\"100%\"\n  class=\"inline-navigation\"\n></cx-carousel>\n\n<ng-template #template let-item=\"item\">\n  <ng-container\n    [cxComponentWrapper]=\"{\n      flexType: item.typeCode,\n      typeCode: item.typeCode,\n      uid: item?.uid\n    }\"\n  >\n  </ng-container>\n</ng-template>\n", components: [{ type: CarouselComponent, selector: "cx-carousel", inputs: ["title", "items", "template", "itemWidth", "hideIndicators", "indicatorIcon", "previousIcon", "nextIcon"] }], directives: [{ type: ComponentWrapperDirective, selector: "[cxComponentWrapper]", inputs: ["cxComponentWrapper"], outputs: ["cxComponentRef"] }], pipes: { "async": i3.AsyncPipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: BannerCarouselComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-banner-carousel',
                    templateUrl: 'banner-carousel.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: CmsComponentData }, { type: i1.CmsService }]; }, propDecorators: { theme: [{
                type: HostBinding,
                args: ['class']
            }] } });

class BannerCarouselModule {
}
BannerCarouselModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: BannerCarouselModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
BannerCarouselModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: BannerCarouselModule, declarations: [BannerCarouselComponent], imports: [CommonModule, PageComponentModule, CarouselModule, MediaModule], exports: [BannerCarouselComponent] });
BannerCarouselModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: BannerCarouselModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                RotatingImagesComponent: {
                    component: BannerCarouselComponent,
                },
            },
        }),
    ], imports: [[CommonModule, PageComponentModule, CarouselModule, MediaModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: BannerCarouselModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, PageComponentModule, CarouselModule, MediaModule],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                RotatingImagesComponent: {
                                    component: BannerCarouselComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [BannerCarouselComponent],
                    exports: [BannerCarouselComponent],
                }]
        }] });

class LinkComponent {
    constructor(component) {
        this.component = component;
        this.data$ = this.component.data$.pipe(tap((data) => (this.styleClasses = data === null || data === void 0 ? void 0 : data.styleClasses)));
    }
    /**
     * Returns `_blank` to force opening the link in a new window whenever the
     * `data.target` flag is set to `true`.
     */
    getTarget(data) {
        return data.target === 'true' || data.target === true ? '_blank' : null;
    }
}
LinkComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: LinkComponent, deps: [{ token: CmsComponentData }], target: i0.ɵɵFactoryTarget.Component });
LinkComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: LinkComponent, selector: "cx-link", host: { properties: { "class": "this.styleClasses" } }, ngImport: i0, template: "<cx-generic-link\n  *ngIf=\"data$ | async as data\"\n  [url]=\"data.url\"\n  [style]=\"data.styleAttributes\"\n  [target]=\"getTarget(data)\"\n  >{{ data.linkName }}</cx-generic-link\n>\n", components: [{ type: GenericLinkComponent, selector: "cx-generic-link", inputs: ["url", "target", "id", "class", "style", "title"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "async": i3.AsyncPipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: LinkComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-link',
                    templateUrl: './link.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: CmsComponentData }]; }, propDecorators: { styleClasses: [{
                type: HostBinding,
                args: ['class']
            }] } });

class LinkModule {
}
LinkModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: LinkModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
LinkModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: LinkModule, declarations: [LinkComponent], imports: [CommonModule, RouterModule, GenericLinkModule], exports: [LinkComponent] });
LinkModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: LinkModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                CMSLinkComponent: { component: LinkComponent },
            },
        }),
    ], imports: [[CommonModule, RouterModule, GenericLinkModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: LinkModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, RouterModule, GenericLinkModule],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                CMSLinkComponent: { component: LinkComponent },
                            },
                        }),
                    ],
                    declarations: [LinkComponent],
                    exports: [LinkComponent],
                }]
        }] });

class ParagraphComponent {
    constructor(component, router) {
        this.component = component;
        this.router = router;
    }
    handleClick(event) {
        if (this.router && event.target instanceof HTMLAnchorElement) {
            const element = event.target;
            const href = element === null || element === void 0 ? void 0 : element.getAttribute('href');
            // Use router for internal link navigation
            if ((href === null || href === void 0 ? void 0 : href.indexOf('/')) === 0) {
                event.preventDefault();
                this.router.navigate([`/${href}`]);
            }
        }
    }
}
ParagraphComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ParagraphComponent, deps: [{ token: CmsComponentData }, { token: i1$1.Router }], target: i0.ɵɵFactoryTarget.Component });
ParagraphComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: ParagraphComponent, selector: "cx-paragraph", host: { listeners: { "click": "handleClick($event)" } }, ngImport: i0, template: "<p\n  *ngIf=\"component.data$ | async as data\"\n  [innerHTML]=\"data.content | cxSupplementHashAnchors\"\n></p>\n", directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "cxSupplementHashAnchors": SupplementHashAnchorsPipe, "async": i3.AsyncPipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ParagraphComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-paragraph',
                    templateUrl: './paragraph.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: CmsComponentData }, { type: i1$1.Router }]; }, propDecorators: { handleClick: [{
                type: HostListener,
                args: ['click', ['$event']]
            }] } });

class CmsParagraphModule {
}
CmsParagraphModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CmsParagraphModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
CmsParagraphModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CmsParagraphModule, declarations: [ParagraphComponent], imports: [CommonModule, RouterModule, SupplementHashAnchorsModule], exports: [ParagraphComponent] });
CmsParagraphModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CmsParagraphModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                CMSParagraphComponent: {
                    component: ParagraphComponent,
                },
                CMSTabParagraphComponent: {
                    component: ParagraphComponent,
                },
            },
        }),
    ], imports: [[CommonModule, RouterModule, SupplementHashAnchorsModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CmsParagraphModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, RouterModule, SupplementHashAnchorsModule],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                CMSParagraphComponent: {
                                    component: ParagraphComponent,
                                },
                                CMSTabParagraphComponent: {
                                    component: ParagraphComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [ParagraphComponent],
                    exports: [ParagraphComponent],
                }]
        }] });

class TabParagraphContainerComponent {
    constructor(componentData, cmsService, winRef, breakpointService) {
        this.componentData = componentData;
        this.cmsService = cmsService;
        this.winRef = winRef;
        this.breakpointService = breakpointService;
        this.activeTabNum = 0;
        this.tabTitleParams = [];
        this.components$ = this.componentData.data$.pipe(distinctUntilChanged((x, y) => (x === null || x === void 0 ? void 0 : x.components) === (y === null || y === void 0 ? void 0 : y.components)), switchMap((data) => {
            var _a;
            return combineLatest(((_a = data === null || data === void 0 ? void 0 : data.components) !== null && _a !== void 0 ? _a : '').split(' ').map((component) => this.cmsService.getComponentData(component).pipe(distinctUntilChanged(), map((tab) => {
                if (!tab) {
                    return undefined;
                }
                if (!tab.flexType) {
                    tab = Object.assign(Object.assign({}, tab), { flexType: tab.typeCode });
                }
                return Object.assign(Object.assign({}, tab), { title: `${data.uid}.tabs.${tab.uid}` });
            }))));
        }));
    }
    select(tabNum, event) {
        var _a;
        (_a = this.breakpointService) === null || _a === void 0 ? void 0 : _a.isDown(BREAKPOINT.sm).pipe(take(1)).subscribe((res) => {
            var _a, _b;
            if (res) {
                this.activeTabNum = this.activeTabNum === tabNum ? -1 : tabNum;
                if (event && (event === null || event === void 0 ? void 0 : event.target)) {
                    const target = event.target;
                    const parentNode = target.parentNode;
                    (_b = (_a = this.winRef) === null || _a === void 0 ? void 0 : _a.nativeWindow) === null || _b === void 0 ? void 0 : _b.scrollTo(0, parentNode.offsetTop);
                }
            }
            else {
                this.activeTabNum = tabNum;
            }
        });
    }
    ngOnInit() {
        var _a, _b, _c, _d, _e;
        this.activeTabNum =
            (_e = (_d = (_c = (_b = (_a = this.winRef) === null || _a === void 0 ? void 0 : _a.nativeWindow) === null || _b === void 0 ? void 0 : _b.history) === null || _c === void 0 ? void 0 : _c.state) === null || _d === void 0 ? void 0 : _d.activeTab) !== null && _e !== void 0 ? _e : this.activeTabNum;
    }
    ngAfterViewInit() {
        // If the sub cms components data exist, the components created before ngAfterViewInit are called.
        // In this case, the title parameters are directly pulled from them.
        if (this.children.length > 0) {
            this.getTitleParams(this.children);
        }
    }
    tabCompLoaded(componentRef) {
        this.tabTitleParams.push(componentRef.instance.tabTitleParam$);
    }
    getTitleParams(children) {
        children.forEach((comp) => {
            var _a;
            if ((_a = comp.cmpRef) === null || _a === void 0 ? void 0 : _a.instance.tabTitleParam$) {
                this.tabTitleParams.push(comp.cmpRef.instance.tabTitleParam$);
            }
            else {
                this.tabTitleParams.push(null);
            }
        });
    }
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
    }
}
TabParagraphContainerComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: TabParagraphContainerComponent, deps: [{ token: CmsComponentData }, { token: i1.CmsService }, { token: i1.WindowRef }, { token: BreakpointService }], target: i0.ɵɵFactoryTarget.Component });
TabParagraphContainerComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: TabParagraphContainerComponent, selector: "cx-tab-paragraph-container", viewQueries: [{ propertyName: "children", predicate: ComponentWrapperDirective, descendants: true }], ngImport: i0, template: "<ng-container *ngIf=\"components$ | async as components\">\n  <ng-container *ngFor=\"let component of components; let i = index\">\n    <ng-container *ngIf=\"component\">\n      <button [class.active]=\"i === activeTabNum\" (click)=\"select(i, $event)\">\n        {{\n          component.title | cxTranslate: { param: tabTitleParams[i] | async }\n        }}\n      </button>\n    </ng-container>\n  </ng-container>\n\n  <ng-container *ngFor=\"let component of components; let i = index\">\n    <ng-container *ngIf=\"component\">\n      <div [class.active]=\"i === activeTabNum\">\n        <ng-template [cxOutlet]=\"component.flexType\" [cxOutletContext]=\"{}\">\n          <ng-container\n            [cxComponentWrapper]=\"component\"\n            (cxComponentRef)=\"tabCompLoaded($event)\"\n          ></ng-container>\n        </ng-template>\n      </div>\n    </ng-container>\n  </ng-container>\n</ng-container>\n", directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: OutletDirective, selector: "[cxOutlet]", inputs: ["cxOutlet", "cxOutletContext", "cxOutletDefer"], outputs: ["loaded"] }, { type: ComponentWrapperDirective, selector: "[cxComponentWrapper]", inputs: ["cxComponentWrapper"], outputs: ["cxComponentRef"] }], pipes: { "async": i3.AsyncPipe, "cxTranslate": i1.TranslatePipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: TabParagraphContainerComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-tab-paragraph-container',
                    templateUrl: './tab-paragraph-container.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: CmsComponentData }, { type: i1.CmsService }, { type: i1.WindowRef }, { type: BreakpointService }]; }, propDecorators: { children: [{
                type: ViewChildren,
                args: [ComponentWrapperDirective]
            }] } });

class TabParagraphContainerModule {
}
TabParagraphContainerModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: TabParagraphContainerModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
TabParagraphContainerModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: TabParagraphContainerModule, declarations: [TabParagraphContainerComponent], imports: [CommonModule, PageComponentModule, OutletModule, I18nModule], exports: [TabParagraphContainerComponent] });
TabParagraphContainerModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: TabParagraphContainerModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                CMSTabParagraphContainer: {
                    component: TabParagraphContainerComponent,
                },
            },
        }),
    ], imports: [[CommonModule, PageComponentModule, OutletModule, I18nModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: TabParagraphContainerModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, PageComponentModule, OutletModule, I18nModule],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                CMSTabParagraphContainer: {
                                    component: TabParagraphContainerComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [TabParagraphContainerComponent],
                    exports: [TabParagraphContainerComponent],
                }]
        }] });

class AddressBookComponentService {
    constructor(userAddressService) {
        this.userAddressService = userAddressService;
    }
    getAddresses() {
        return this.userAddressService.getAddresses();
    }
    getAddressesStateLoading() {
        return this.userAddressService.getAddressesLoading();
    }
    loadAddresses() {
        this.userAddressService.loadAddresses();
    }
    addUserAddress(address) {
        this.userAddressService.addUserAddress(address);
    }
    updateUserAddress(addressId, address) {
        this.userAddressService.updateUserAddress(addressId, address);
    }
    setAddressAsDefault(addressId) {
        this.userAddressService.setAddressAsDefault(addressId);
    }
    deleteUserAddress(addressId) {
        this.userAddressService.deleteUserAddress(addressId);
    }
}
AddressBookComponentService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AddressBookComponentService, deps: [{ token: i1.UserAddressService }], target: i0.ɵɵFactoryTarget.Injectable });
AddressBookComponentService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AddressBookComponentService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AddressBookComponentService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.UserAddressService }]; } });

class SuggestedAddressDialogComponent {
    constructor(modalService) {
        this.modalService = modalService;
        this.iconTypes = ICON_TYPE;
    }
    ngOnInit() {
        this.selectedAddress = this.suggestedAddresses.length
            ? this.suggestedAddresses[0]
            : this.enteredAddress;
    }
    closeModal(reason) {
        this.modalService.closeActiveModal(reason);
    }
}
SuggestedAddressDialogComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SuggestedAddressDialogComponent, deps: [{ token: ModalService }], target: i0.ɵɵFactoryTarget.Component });
SuggestedAddressDialogComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: SuggestedAddressDialogComponent, selector: "cx-suggested-addresses-dialog", inputs: { suggestedAddresses: "suggestedAddresses", enteredAddress: "enteredAddress" }, ngImport: i0, template: "<div class=\"cx-dialog-header modal-header\">\n  <div class=\"cx-dialog-title modal-title\">\n    {{ 'addressSuggestion.verifyYourAddress' | cxTranslate }}\n  </div>\n  <button\n    type=\"button\"\n    class=\"close\"\n    [attr.aria-label]=\"'common.close' | cxTranslate\"\n    (click)=\"closeModal()\"\n  >\n    <span aria-hidden=\"true\">\n      <cx-icon [type]=\"iconTypes.CLOSE\"></cx-icon>\n    </span>\n  </button>\n</div>\n<div class=\"cx-dialog-body modal-body\" ngForm>\n  <div class=\"container\">\n    <div class=\"row\">\n      <div class=\"cx-dialog-info col-md-12\">\n        <p>\n          {{ 'addressSuggestion.ensureAccuracySuggestChange' | cxTranslate }}\n          {{ 'addressSuggestion.chooseAddressToUse' | cxTranslate }}\n        </p>\n      </div>\n    </div>\n\n    <div class=\"row\">\n      <div class=\"cx-dialog-options col-md-12\">\n        <div\n          class=\"form-check\"\n          *ngFor=\"let suggestedAddress of suggestedAddresses; let i = index\"\n        >\n          <input\n            class=\"form-check-input\"\n            type=\"radio\"\n            name=\"selectedAddress\"\n            [(ngModel)]=\"selectedAddress\"\n            [value]=\"suggestedAddress\"\n            [id]=\"'suggested-addresses--suggested-' + i\"\n          />\n          <label\n            class=\"form-check-label cx-dialog-label\"\n            [for]=\"'suggested-addresses--suggested-' + i\"\n          >\n            {{ 'addressSuggestion.suggestedAddress' | cxTranslate }}\n            {{ suggestedAddresses?.length > 1 ? i + 1 : null }}\n          </label>\n          <div class=\"cx-dialog-suggested\">\n            {{ suggestedAddress?.firstName }} {{ suggestedAddress?.lastName\n            }}<br />\n            {{ suggestedAddress?.line1 }}<br />\n            <span>{{ suggestedAddress?.line2 }}</span\n            ><br />\n            {{ suggestedAddress?.town }} {{ suggestedAddress?.region?.isocode\n            }}<br />\n            {{ suggestedAddress?.postalCode }}\n          </div>\n        </div>\n        <div class=\"form-check\">\n          <input\n            class=\"form-check-input\"\n            type=\"radio\"\n            name=\"selectedAddress\"\n            [(ngModel)]=\"selectedAddress\"\n            [value]=\"enteredAddress\"\n            id=\"suggested-addresses--entered\"\n          />\n          <label\n            class=\"form-check-label cx-dialog-label\"\n            for=\"suggested-addresses--entered\"\n          >\n            {{ 'addressSuggestion.enteredAddress' | cxTranslate }}\n          </label>\n          <div class=\"cx-dialog-entered\">\n            {{ enteredAddress?.firstName }} {{ enteredAddress?.lastName }}<br />\n            {{ enteredAddress?.line1 }}<br />\n            <span>{{ enteredAddress?.line2 }}</span\n            ><br />\n            {{ enteredAddress?.town }} {{ enteredAddress?.region?.isocode\n            }}<br />\n            {{ enteredAddress?.postalCode }}\n          </div>\n        </div>\n      </div>\n    </div>\n    <div class=\"row\">\n      <div class=\"cx-dialog-actions col-sm-12 col-md-6 offset-md-6\">\n        <button\n          class=\"btn btn-secondary btn-block cx-dialog-buttons\"\n          (click)=\"closeModal()\"\n        >\n          {{ 'addressSuggestion.editAddress' | cxTranslate }}\n        </button>\n        <button\n          cxAutoFocus\n          class=\"btn btn-primary btn-block cx-dialog-buttons\"\n          (click)=\"closeModal(selectedAddress)\"\n        >\n          {{ 'addressSuggestion.saveAddress' | cxTranslate }}\n        </button>\n      </div>\n    </div>\n  </div>\n</div>\n", components: [{ type: IconComponent, selector: "cx-icon,[cxIcon]", inputs: ["cxIcon", "type"] }], directives: [{ type: i3$1.NgControlStatusGroup, selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { type: i3$1.NgForm, selector: "form:not([ngNoForm]):not([formGroup]),ng-form,[ngForm]", inputs: ["ngFormOptions"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i3$1.RadioControlValueAccessor, selector: "input[type=radio][formControlName],input[type=radio][formControl],input[type=radio][ngModel]", inputs: ["name", "formControlName", "value"] }, { type: i3$1.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { type: i3$1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i3$1.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }], pipes: { "cxTranslate": i1.TranslatePipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SuggestedAddressDialogComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-suggested-addresses-dialog',
                    templateUrl: './suggested-addresses-dialog.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: ModalService }]; }, propDecorators: { suggestedAddresses: [{
                type: Input
            }], enteredAddress: [{
                type: Input
            }] } });

class AddressFormComponent {
    constructor(fb, userService, userAddressService, globalMessageService, modalService, translation) {
        this.fb = fb;
        this.userService = userService;
        this.userAddressService = userAddressService;
        this.globalMessageService = globalMessageService;
        this.modalService = modalService;
        this.translation = translation;
        this.selectedCountry$ = new BehaviorSubject('');
        this.setAsDefaultField = true;
        this.showCancelBtn = true;
        this.submitAddress = new EventEmitter();
        this.backToAddress = new EventEmitter();
        this.addressForm = this.fb.group({
            country: this.fb.group({
                isocode: [null, Validators.required],
            }),
            titleCode: [''],
            firstName: ['', Validators.required],
            lastName: ['', Validators.required],
            line1: ['', Validators.required],
            line2: [''],
            town: ['', Validators.required],
            region: this.fb.group({
                isocode: [null, Validators.required],
            }),
            postalCode: ['', Validators.required],
            phone: '',
            defaultAddress: [false],
        });
    }
    ngOnInit() {
        // Fetching countries
        this.countries$ = this.userAddressService.getDeliveryCountries().pipe(tap((countries) => {
            if (Object.keys(countries).length === 0) {
                this.userAddressService.loadDeliveryCountries();
            }
        }));
        // Fetching titles
        this.titles$ = this.getTitles();
        // Fetching regions
        this.regions$ = this.selectedCountry$.pipe(switchMap((country) => this.userAddressService.getRegions(country)), tap((regions) => {
            const regionControl = this.addressForm.get('region.isocode');
            if (regions && regions.length > 0) {
                regionControl.enable();
            }
            else {
                regionControl.disable();
            }
        }));
        if (this.addressData && Object.keys(this.addressData).length !== 0) {
            this.addressForm.patchValue(this.addressData);
            this.countrySelected(this.addressData.country);
            if (this.addressData.region) {
                this.regionSelected(this.addressData.region);
            }
        }
        this.addresses$ = this.userAddressService.getAddresses();
    }
    getTitles() {
        return combineLatest([
            this.translation.translate('addressForm.defaultTitle'),
            this.userService.getTitles(),
        ]).pipe(map(([noneTitleText, titles]) => {
            const noneTitle = { code: '', name: noneTitleText };
            titles.sort(sortTitles);
            return [noneTitle, ...titles];
        }));
    }
    handleAddressVerificationResults(results) {
        if (results.decision === 'ACCEPT') {
            this.submitAddress.emit(this.addressForm.value);
        }
        else if (results.decision === 'REJECT') {
            // TODO: Workaround: allow server for decide is titleCode mandatory (if yes, provide personalized message)
            if (results.errors.errors.some((error) => error.subject === 'titleCode')) {
                this.globalMessageService.add({ key: 'addressForm.titleRequired' }, GlobalMessageType.MSG_TYPE_ERROR);
            }
            else {
                this.globalMessageService.add({ key: 'addressForm.invalidAddress' }, GlobalMessageType.MSG_TYPE_ERROR);
            }
        }
        else if (results.decision === 'REVIEW') {
            this.openSuggestedAddress(results);
        }
    }
    countrySelected(country) {
        var _a, _b;
        (_b = (_a = this.addressForm.get('country')) === null || _a === void 0 ? void 0 : _a.get('isocode')) === null || _b === void 0 ? void 0 : _b.setValue(country.isocode);
        this.selectedCountry$.next(country.isocode);
    }
    regionSelected(region) {
        var _a, _b;
        (_b = (_a = this.addressForm.get('region')) === null || _a === void 0 ? void 0 : _a.get('isocode')) === null || _b === void 0 ? void 0 : _b.setValue(region.isocode);
    }
    toggleDefaultAddress() {
        this.addressForm['controls'].defaultAddress.setValue(this.addressForm.value.defaultAddress);
    }
    back() {
        this.backToAddress.emit();
    }
    verifyAddress() {
        if (this.addressForm.valid) {
            if (this.addressForm.get('region').value.isocode) {
                this.regionsSub = this.regions$.pipe(take(1)).subscribe((regions) => {
                    const obj = regions.find((region) => region.isocode ===
                        this.addressForm.controls['region'].value.isocode);
                    Object.assign(this.addressForm.value.region, {
                        isocodeShort: obj.isocodeShort,
                    });
                });
            }
            if (this.addressForm.dirty) {
                this.userAddressService
                    .verifyAddress(this.addressForm.value)
                    .subscribe((result) => {
                    this.handleAddressVerificationResults(result);
                });
            }
            else {
                // address form value not changed
                // ignore duplicate address
                this.submitAddress.emit(undefined);
            }
        }
        else {
            this.addressForm.markAllAsTouched();
        }
    }
    openSuggestedAddress(results) {
        if (!this.suggestedAddressModalRef) {
            this.suggestedAddressModalRef = this.modalService.open(SuggestedAddressDialogComponent, { centered: true, size: 'lg' });
            this.suggestedAddressModalRef.componentInstance.enteredAddress =
                this.addressForm.value;
            this.suggestedAddressModalRef.componentInstance.suggestedAddresses =
                results.suggestedAddresses;
            this.suggestedAddressModalRef.result
                .then((address) => {
                if (address) {
                    address = Object.assign({
                        titleCode: this.addressForm.value.titleCode,
                        phone: this.addressForm.value.phone,
                        selected: true,
                    }, address);
                    this.submitAddress.emit(address);
                }
                this.suggestedAddressModalRef = null;
            })
                .catch(() => {
                // this  callback is called when modal is closed with Esc key or clicking backdrop
                const address = Object.assign({
                    selected: true,
                }, this.addressForm.value);
                this.submitAddress.emit(address);
                this.suggestedAddressModalRef = null;
            });
        }
    }
    ngOnDestroy() {
        if (this.addressVerifySub) {
            this.addressVerifySub.unsubscribe();
        }
        if (this.regionsSub) {
            this.regionsSub.unsubscribe();
        }
    }
}
AddressFormComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AddressFormComponent, deps: [{ token: i3$1.FormBuilder }, { token: i1.UserService }, { token: i1.UserAddressService }, { token: i1.GlobalMessageService }, { token: ModalService }, { token: i1.TranslationService }], target: i0.ɵɵFactoryTarget.Component });
AddressFormComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: AddressFormComponent, selector: "cx-address-form", inputs: { addressData: "addressData", actionBtnLabel: "actionBtnLabel", cancelBtnLabel: "cancelBtnLabel", setAsDefaultField: "setAsDefaultField", showTitleCode: "showTitleCode", showCancelBtn: "showCancelBtn" }, outputs: { submitAddress: "submitAddress", backToAddress: "backToAddress" }, ngImport: i0, template: "<form (ngSubmit)=\"verifyAddress()\" [formGroup]=\"addressForm\">\n  <div class=\"row\">\n    <div class=\"col-md-12 col-lg-9\">\n      <div class=\"form-group\" formGroupName=\"country\">\n        <ng-container *ngIf=\"countries$ | async as countries\">\n          <div *ngIf=\"countries.length !== 0\">\n            <label>\n              <span class=\"label-content required\">{{\n                'addressForm.country' | cxTranslate\n              }}</span>\n              <ng-select\n                aria-required=\"true\"\n                class=\"country-select\"\n                formControlName=\"isocode\"\n                [searchable]=\"true\"\n                [clearable]=\"false\"\n                [items]=\"countries\"\n                bindLabel=\"name\"\n                bindValue=\"isocode\"\n                placeholder=\"{{ 'addressForm.selectOne' | cxTranslate }}\"\n                (change)=\"countrySelected($event)\"\n              >\n              </ng-select>\n              <cx-form-errors\n                aria-live=\"assertive\"\n                aria-atomic=\"true\"\n                [control]=\"addressForm.get('country.isocode')\"\n              ></cx-form-errors>\n            </label>\n          </div>\n        </ng-container>\n      </div>\n      <div class=\"form-group\" *ngIf=\"showTitleCode\">\n        <ng-container *ngIf=\"titles$ | async as titles\">\n          <div *ngIf=\"titles.length !== 0\">\n            <label>\n              <span class=\"label-content required\">{{\n                'addressForm.title' | cxTranslate\n              }}</span>\n              <ng-select\n                formControlName=\"titleCode\"\n                [searchable]=\"true\"\n                [clearable]=\"false\"\n                [items]=\"titles\"\n                bindLabel=\"name\"\n                bindValue=\"code\"\n                [placeholder]=\"'addressForm.title' | cxTranslate\"\n              >\n              </ng-select>\n            </label>\n          </div>\n        </ng-container>\n      </div>\n      <div class=\"form-group\">\n        <label>\n          <span class=\"label-content required\">{{\n            'addressForm.firstName.label' | cxTranslate\n          }}</span>\n          <input\n            aria-required=\"true\"\n            class=\"form-control\"\n            type=\"text\"\n            placeholder=\"{{\n              'addressForm.firstName.placeholder' | cxTranslate\n            }}\"\n            formControlName=\"firstName\"\n          />\n          <cx-form-errors\n            aria-live=\"assertive\"\n            aria-atomic=\"true\"\n            [control]=\"addressForm.get('firstName')\"\n          ></cx-form-errors>\n        </label>\n      </div>\n      <div class=\"form-group\">\n        <label>\n          <span class=\"label-content required\">{{\n            'addressForm.lastName.label' | cxTranslate\n          }}</span>\n          <input\n            aria-required=\"true\"\n            type=\"text\"\n            class=\"form-control\"\n            placeholder=\"{{ 'addressForm.lastName.placeholder' | cxTranslate }}\"\n            formControlName=\"lastName\"\n          />\n          <cx-form-errors\n            aria-live=\"assertive\"\n            aria-atomic=\"true\"\n            [control]=\"addressForm.get('lastName')\"\n          ></cx-form-errors>\n        </label>\n      </div>\n      <div class=\"form-group\">\n        <label>\n          <span class=\"label-content required\">{{\n            'addressForm.address1' | cxTranslate\n          }}</span>\n          <input\n            aria-required=\"true\"\n            type=\"text\"\n            class=\"form-control\"\n            placeholder=\"{{ 'addressForm.streetAddress' | cxTranslate }}\"\n            formControlName=\"line1\"\n          />\n          <cx-form-errors\n            aria-live=\"assertive\"\n            aria-atomic=\"true\"\n            [control]=\"addressForm.get('line1')\"\n          ></cx-form-errors>\n        </label>\n      </div>\n      <div class=\"form-group\">\n        <label>\n          <span class=\"label-content\">{{\n            'addressForm.address2' | cxTranslate\n          }}</span>\n          <input\n            type=\"text\"\n            class=\"form-control\"\n            placeholder=\"{{ 'addressForm.aptSuite' | cxTranslate }}\"\n            formControlName=\"line2\"\n          />\n        </label>\n      </div>\n      <div class=\"row\">\n        <div class=\"form-group col-md-6\">\n          <label>\n            <span class=\"label-content required\">{{\n              'addressForm.city.label' | cxTranslate\n            }}</span>\n            <input\n              aria-required=\"true\"\n              type=\"text\"\n              class=\"form-control\"\n              placeholder=\"{{ 'addressForm.city.placeholder' | cxTranslate }}\"\n              formControlName=\"town\"\n            />\n            <cx-form-errors\n              aria-live=\"assertive\"\n              aria-atomic=\"true\"\n              [control]=\"addressForm.get('town')\"\n            ></cx-form-errors>\n          </label>\n        </div>\n        <div class=\"form-group col-md-6\">\n          <label>\n            <span class=\"label-content required\">{{\n              'addressForm.zipCode.label' | cxTranslate\n            }}</span>\n            <input\n              aria-required=\"true\"\n              type=\"text\"\n              class=\"form-control\"\n              placeholder=\"{{\n                'addressForm.zipCode.placeholder' | cxTranslate\n              }}\"\n              formControlName=\"postalCode\"\n            />\n            <cx-form-errors\n              aria-live=\"assertive\"\n              aria-atomic=\"true\"\n              [control]=\"addressForm.get('postalCode')\"\n            ></cx-form-errors>\n          </label>\n        </div>\n        <ng-container\n          *ngIf=\"regions$ | async as regions\"\n          formGroupName=\"region\"\n        >\n          <ng-container *ngIf=\"regions.length !== 0\">\n            <div class=\"form-group col-md-6\">\n              <label>\n                <span class=\"label-content required\">{{\n                  'addressForm.state' | cxTranslate\n                }}</span>\n                <ng-select\n                  aria-required=\"true\"\n                  class=\"region-select\"\n                  formControlName=\"isocode\"\n                  [searchable]=\"true\"\n                  [clearable]=\"false\"\n                  [items]=\"regions\"\n                  bindLabel=\"{{ regions[0].name ? 'name' : 'isocode' }}\"\n                  bindValue=\"{{ regions[0].name ? 'isocode' : 'region' }}\"\n                  placeholder=\"{{ 'addressForm.selectOne' | cxTranslate }}\"\n                >\n                </ng-select>\n                <cx-form-errors\n                  aria-live=\"assertive\"\n                  aria-atomic=\"true\"\n                  [control]=\"addressForm.get('region.isocode')\"\n                ></cx-form-errors>\n              </label>\n            </div>\n          </ng-container>\n        </ng-container>\n      </div>\n      <div class=\"form-group\">\n        <label>\n          <span class=\"label-content\">{{\n            'addressForm.phoneNumber.label' | cxTranslate\n          }}</span>\n          <input\n            type=\"tel\"\n            class=\"form-control\"\n            placeholder=\"{{\n              'addressForm.phoneNumber.placeholder' | cxTranslate\n            }}\"\n            formControlName=\"phone\"\n          />\n        </label>\n      </div>\n      <div\n        class=\"form-group\"\n        *ngIf=\"(addresses$ | async).length && setAsDefaultField\"\n      >\n        <div class=\"form-check\">\n          <label>\n            <input\n              type=\"checkbox\"\n              class=\"form-check-input\"\n              formControlName=\"defaultAddress\"\n              (change)=\"toggleDefaultAddress()\"\n            />\n            <span class=\"form-check-label\">{{\n              'addressForm.setAsDefault' | cxTranslate\n            }}</span>\n          </label>\n        </div>\n      </div>\n    </div>\n  </div>\n  <div class=\"cx-address-form-btns row\">\n    <div class=\"col-md-12 col-lg-6\" *ngIf=\"showCancelBtn\">\n      <button class=\"btn btn-block btn-action\" (click)=\"back()\">\n        {{ cancelBtnLabel || ('addressForm.chooseAddress' | cxTranslate) }}\n      </button>\n    </div>\n    <div class=\"col-md-12 col-lg-6\">\n      <button class=\"btn btn-block btn-primary\" type=\"submit\">\n        {{ actionBtnLabel || ('common.continue' | cxTranslate) }}\n      </button>\n    </div>\n  </div>\n</form>\n", components: [{ type: i1$4.NgSelectComponent, selector: "ng-select", inputs: ["markFirst", "dropdownPosition", "loading", "closeOnSelect", "hideSelected", "selectOnTab", "bufferAmount", "selectableGroup", "selectableGroupAsModel", "searchFn", "trackByFn", "clearOnBackspace", "labelForId", "inputAttrs", "readonly", "searchWhileComposing", "minTermLength", "editableSearchTerm", "keyDownFn", "multiple", "addTag", "searchable", "clearable", "isOpen", "items", "compareWith", "clearSearchOnAdd", "bindLabel", "placeholder", "notFoundText", "typeToSearchText", "addTagText", "loadingText", "clearAllText", "virtualScroll", "openOnEnter", "appendTo", "bindValue", "appearance", "maxSelectedItems", "groupBy", "groupValue", "tabIndex", "typeahead"], outputs: ["blur", "focus", "change", "open", "close", "search", "clear", "add", "remove", "scroll", "scrollToEnd"] }, { type: FormErrorsComponent, selector: "cx-form-errors", inputs: ["prefix", "translationParams", "control"] }], directives: [{ type: i3$1.ɵNgNoValidate, selector: "form:not([ngNoForm]):not([ngNativeValidate])" }, { type: i3$1.NgControlStatusGroup, selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { type: i3$1.FormGroupDirective, selector: "[formGroup]", inputs: ["formGroup"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }, { type: i3$1.FormGroupName, selector: "[formGroupName]", inputs: ["formGroupName"] }, { type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3$1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i3$1.FormControlName, selector: "[formControlName]", inputs: ["disabled", "formControlName", "ngModel"], outputs: ["ngModelChange"] }, { type: i3$1.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { type: i3$1.CheckboxControlValueAccessor, selector: "input[type=checkbox][formControlName],input[type=checkbox][formControl],input[type=checkbox][ngModel]" }], pipes: { "async": i3.AsyncPipe, "cxTranslate": i1.TranslatePipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AddressFormComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-address-form',
                    templateUrl: './address-form.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: i3$1.FormBuilder }, { type: i1.UserService }, { type: i1.UserAddressService }, { type: i1.GlobalMessageService }, { type: ModalService }, { type: i1.TranslationService }]; }, propDecorators: { addressData: [{
                type: Input
            }], actionBtnLabel: [{
                type: Input
            }], cancelBtnLabel: [{
                type: Input
            }], setAsDefaultField: [{
                type: Input
            }], showTitleCode: [{
                type: Input
            }], showCancelBtn: [{
                type: Input
            }], submitAddress: [{
                type: Output
            }], backToAddress: [{
                type: Output
            }] } });

class AddressBookComponent {
    constructor(service, translation) {
        this.service = service;
        this.translation = translation;
        this.showAddAddressForm = false;
        this.showEditAddressForm = false;
    }
    ngOnInit() {
        this.addresses$ = this.service.getAddresses();
        this.addressesStateLoading$ = this.service.getAddressesStateLoading();
        this.service.loadAddresses();
    }
    addAddressButtonHandle() {
        this.showEditAddressForm = false;
        this.showAddAddressForm = true;
    }
    editAddressButtonHandle(address) {
        this.showAddAddressForm = false;
        this.showEditAddressForm = true;
        this.currentAddress = address;
    }
    addAddressSubmit(address) {
        this.showAddAddressForm = false;
        this.service.addUserAddress(address);
    }
    addAddressCancel() {
        this.showAddAddressForm = false;
    }
    editAddressSubmit(address) {
        this.showEditAddressForm = false;
        this.service.updateUserAddress(this.currentAddress['id'], address);
    }
    editAddressCancel() {
        this.showEditAddressForm = false;
    }
    getCardContent(address) {
        return combineLatest([
            this.translation.translate('addressCard.default'),
            this.translation.translate('addressCard.setAsDefault'),
            this.translation.translate('common.delete'),
            this.translation.translate('common.edit'),
            this.translation.translate('addressBook.areYouSureToDeleteAddress'),
        ]).pipe(map(([defaultText, setAsDefaultText, textDelete, textEdit, textVerifyDeleteMsg,]) => {
            let region = '';
            if (address.region && address.region.isocode) {
                region = address.region.isocode + ', ';
            }
            const actions = [];
            if (!address.defaultAddress) {
                actions.push({ name: setAsDefaultText, event: 'default' });
            }
            actions.push({ name: textEdit, event: 'edit' });
            actions.push({ name: textDelete, event: 'delete' });
            return {
                textBold: address.firstName + ' ' + address.lastName,
                text: [
                    address.line1,
                    address.line2,
                    address.town + ', ' + region + address.country.isocode,
                    address.postalCode,
                    address.phone,
                ],
                actions: actions,
                header: address.defaultAddress ? `✓ ${defaultText}` : '',
                deleteMsg: textVerifyDeleteMsg,
            };
        }));
    }
    setAddressAsDefault(addressId) {
        this.service.setAddressAsDefault(addressId);
    }
    deleteAddress(addressId) {
        this.service.deleteUserAddress(addressId);
    }
    setEdit(addressId) {
        if (this.editCard !== addressId) {
            this.editCard = addressId;
        }
        else {
            this.deleteAddress(addressId);
        }
    }
    cancelCard() {
        this.editCard = null;
    }
}
AddressBookComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AddressBookComponent, deps: [{ token: AddressBookComponentService }, { token: i1.TranslationService }], target: i0.ɵɵFactoryTarget.Component });
AddressBookComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: AddressBookComponent, selector: "cx-address-book", ngImport: i0, template: "<div class=\"cx-section\">\n  <ng-container\n    *ngIf=\"\n      (addresses$ | async).length &&\n      !(showAddAddressForm || showEditAddressForm)\n    \"\n  >\n    <div class=\"row\">\n      <div class=\"col-md-6\">\n        <button\n          class=\"btn btn-block btn-action\"\n          (click)=\"addAddressButtonHandle()\"\n        >\n          {{ 'addressBook.addNewAddress' | cxTranslate }}\n        </button>\n      </div>\n    </div>\n\n    <div\n      class=\"row cx-address-deck\"\n      *ngIf=\"!(addressesStateLoading$ | async); else loading\"\n    >\n      <div\n        *ngFor=\"let address of addresses$ | async\"\n        class=\"col-md-6 cx-address-card\"\n      >\n        <cx-card\n          [border]=\"true\"\n          [fitToContainer]=\"true\"\n          [content]=\"getCardContent(address) | async\"\n          (editCard)=\"editAddressButtonHandle(address)\"\n          (setDefaultCard)=\"setAddressAsDefault(address.id)\"\n          (deleteCard)=\"setEdit(address.id)\"\n          [editMode]=\"address.id === editCard\"\n          (cancelCard)=\"cancelCard()\"\n        ></cx-card>\n      </div>\n    </div>\n  </ng-container>\n\n  <ng-container *ngIf=\"!(addresses$ | async).length || showAddAddressForm\">\n    <section>\n      <p class=\"cx-section-msg\">\n        {{ 'addressBook.addNewShippingAddress' | cxTranslate }}\n      </p>\n      <cx-address-form\n        class=\"cx-form\"\n        showTitleCode=\"true\"\n        [showCancelBtn]=\"!((addresses$ | async).length === 0)\"\n        actionBtnLabel=\"{{ 'addressBook.addAddress' | cxTranslate }}\"\n        cancelBtnLabel=\"{{ 'addressBook.backToAddressList' | cxTranslate }}\"\n        [setAsDefaultField]=\"!((addresses$ | async).length === 0)\"\n        (submitAddress)=\"addAddressSubmit($event)\"\n        (backToAddress)=\"addAddressCancel()\"\n        (cancelCard)=\"cancelCard()\"\n      ></cx-address-form>\n    </section>\n  </ng-container>\n\n  <ng-container *ngIf=\"showEditAddressForm\">\n    <section>\n      <p class=\"cx-section-msg\">\n        {{ 'addressBook.editShippingAddress' | cxTranslate }}\n      </p>\n      <cx-address-form\n        showTitleCode=\"true\"\n        actionBtnLabel=\"{{ 'addressBook.updateAddress' | cxTranslate }}\"\n        cancelBtnLabel=\"{{ 'addressBook.backToAddressList' | cxTranslate }}\"\n        [addressData]=\"currentAddress\"\n        (submitAddress)=\"editAddressSubmit($event)\"\n        (backToAddress)=\"editAddressCancel()\"\n      ></cx-address-form>\n    </section>\n  </ng-container>\n</div>\n\n<ng-template #loading>\n  <div class=\"col-md-12 cx-address-spinner\">\n    <cx-spinner></cx-spinner>\n  </div>\n</ng-template>\n", components: [{ type: CardComponent, selector: "cx-card", inputs: ["border", "editMode", "isDefault", "content", "fitToContainer", "truncateText", "charactersLimit"], outputs: ["deleteCard", "setDefaultCard", "sendCard", "editCard", "cancelCard"] }, { type: AddressFormComponent, selector: "cx-address-form", inputs: ["addressData", "actionBtnLabel", "cancelBtnLabel", "setAsDefaultField", "showTitleCode", "showCancelBtn"], outputs: ["submitAddress", "backToAddress"] }, { type: SpinnerComponent, selector: "cx-spinner" }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], pipes: { "async": i3.AsyncPipe, "cxTranslate": i1.TranslatePipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AddressBookComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-address-book',
                    templateUrl: './address-book.component.html',
                }]
        }], ctorParameters: function () { return [{ type: AddressBookComponentService }, { type: i1.TranslationService }]; } });

class AddressFormModule {
}
AddressFormModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AddressFormModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
AddressFormModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AddressFormModule, declarations: [AddressFormComponent, SuggestedAddressDialogComponent], imports: [CommonModule,
        ReactiveFormsModule,
        FormsModule,
        RouterModule,
        NgSelectModule,
        IconModule,
        I18nModule,
        FormErrorsModule], exports: [AddressFormComponent, SuggestedAddressDialogComponent] });
AddressFormModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AddressFormModule, imports: [[
            CommonModule,
            ReactiveFormsModule,
            FormsModule,
            RouterModule,
            NgSelectModule,
            IconModule,
            I18nModule,
            FormErrorsModule,
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AddressFormModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        ReactiveFormsModule,
                        FormsModule,
                        RouterModule,
                        NgSelectModule,
                        IconModule,
                        I18nModule,
                        FormErrorsModule,
                    ],
                    declarations: [AddressFormComponent, SuggestedAddressDialogComponent],
                    exports: [AddressFormComponent, SuggestedAddressDialogComponent],
                }]
        }] });

class AddressBookModule {
}
AddressBookModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AddressBookModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
AddressBookModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AddressBookModule, declarations: [AddressBookComponent], imports: [CommonModule,
        CardModule,
        AddressFormModule,
        SpinnerModule,
        I18nModule], exports: [AddressBookComponent] });
AddressBookModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AddressBookModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                AccountAddressBookComponent: {
                    component: AddressBookComponent,
                    guards: [AuthGuard],
                },
            },
        }),
        UserAddressService,
    ], imports: [[
            CommonModule,
            CardModule,
            AddressFormModule,
            SpinnerModule,
            I18nModule,
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AddressBookModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        CardModule,
                        AddressFormModule,
                        SpinnerModule,
                        I18nModule,
                    ],
                    declarations: [AddressBookComponent],
                    exports: [AddressBookComponent],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                AccountAddressBookComponent: {
                                    component: AddressBookComponent,
                                    guards: [AuthGuard],
                                },
                            },
                        }),
                        UserAddressService,
                    ],
                }]
        }] });

class MyCouponsComponentService {
    constructor(routingService, translation) {
        this.routingService = routingService;
        this.translation = translation;
        this.RELEVANCE = ':relevance';
        this.CUSTOMER_COUPON_CODE = ':customerCouponCode:';
    }
    launchSearchPage(coupon) {
        this.routingService.go({
            cxRoute: 'search',
            params: { query: this.buildSearchParam(coupon) },
        }, {
            queryParams: {
                couponcode: coupon.couponId,
            },
        });
    }
    buildSearchParam(coupon) {
        return coupon.allProductsApplicable
            ? this.RELEVANCE
            : this.RELEVANCE + this.CUSTOMER_COUPON_CODE + coupon.couponId;
    }
    getSortLabels() {
        return combineLatest([
            this.translation.translate('myCoupons.startDateAsc'),
            this.translation.translate('myCoupons.startDateDesc'),
            this.translation.translate('myCoupons.endDateAsc'),
            this.translation.translate('myCoupons.endDateDesc'),
        ]).pipe(map(([textByStartDateAsc, textByStartDateDesc, textByEndDateAsc, textByEndDateDesc,]) => {
            return {
                byStartDateAsc: textByStartDateAsc,
                byStartDateDesc: textByStartDateDesc,
                byEndDateAsc: textByEndDateAsc,
                byEndDateDesc: textByEndDateDesc,
            };
        }));
    }
}
MyCouponsComponentService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: MyCouponsComponentService, deps: [{ token: i1.RoutingService }, { token: i1.TranslationService }], target: i0.ɵɵFactoryTarget.Injectable });
MyCouponsComponentService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: MyCouponsComponentService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: MyCouponsComponentService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.RoutingService }, { type: i1.TranslationService }]; } });

class CouponDialogComponent {
    constructor(modalService) {
        this.modalService = modalService;
        this.iconTypes = ICON_TYPE;
    }
    dismissModal(reason) {
        this.modalService.dismissActiveModal(reason);
    }
}
CouponDialogComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CouponDialogComponent, deps: [{ token: ModalService }], target: i0.ɵɵFactoryTarget.Component });
CouponDialogComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: CouponDialogComponent, selector: "cx-coupon-dialog", viewQueries: [{ propertyName: "dialog", first: true, predicate: ["dialog"], descendants: true, read: ElementRef }], ngImport: i0, template: "<div #dialog>\n  <!-- Modal Header -->\n\n  <div class=\"cx-dialog-header modal-header\">\n    <div class=\"cx-dialog-title modal-title\">\n      {{ 'myCoupons.dialogTitle' | cxTranslate }}\n    </div>\n    <button\n      type=\"button\"\n      class=\"close\"\n      [attr.aria-label]=\"'common.close' | cxTranslate\"\n      (click)=\"dismissModal('Cross click')\"\n    >\n      <span aria-hidden=\"true\">\n        <cx-icon [type]=\"iconTypes.CLOSE\"></cx-icon>\n      </span>\n    </button>\n  </div>\n  <!-- Modal Body -->\n  <div class=\"cx-dialog-body modal-body\">\n    <div class=\"cx-dialog-row\">\n      <div class=\"cx-dialog-item col-sm-12 col-md-12\">\n        <div class=\"cx-coupon-card-head\">\n          <span class=\"card-label-bold cx-coupon-card-id\">{{\n            coupon?.couponId\n          }}</span>\n          <span>: {{ coupon?.name }}</span>\n        </div>\n        <div class=\"cx-coupon-description\">{{ coupon?.description }}</div>\n\n        <div class=\"cx-coupon-dialog-date\">\n          <p>{{ 'myCoupons.effectiveTitle' | cxTranslate }}</p>\n          <div class=\"cx-coupon-date\">\n            {{ coupon?.startDate | cxDate: 'medium' }} -\n            {{ coupon?.endDate | cxDate: 'medium' }}\n          </div>\n        </div>\n\n        <div class=\"cx-coupon-dialog-status\">\n          <p>{{ 'myCoupons.status' | cxTranslate }}</p>\n          <div class=\"cx-coupon-status {{ coupon?.status | lowercase }}\">\n            {{ 'myCoupons.' + coupon?.status | cxTranslate }}\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n", components: [{ type: IconComponent, selector: "cx-icon,[cxIcon]", inputs: ["cxIcon", "type"] }], pipes: { "cxTranslate": i1.TranslatePipe, "cxDate": i1.CxDatePipe, "lowercase": i3.LowerCasePipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CouponDialogComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-coupon-dialog',
                    templateUrl: './coupon-dialog.component.html',
                }]
        }], ctorParameters: function () { return [{ type: ModalService }]; }, propDecorators: { dialog: [{
                type: ViewChild,
                args: ['dialog', { read: ElementRef }]
            }] } });

class CouponCardComponent {
    constructor(modalService, myCouponsComponentService) {
        this.modalService = modalService;
        this.myCouponsComponentService = myCouponsComponentService;
        this.notificationChanged = new EventEmitter();
    }
    onSubscriptionChange() {
        this.notificationChanged.emit({
            couponId: this.coupon.couponId,
            notification: !this.coupon.notificationOn,
        });
    }
    readMore() {
        let modalInstance;
        this.modalRef = this.modalService.open(CouponDialogComponent, {
            centered: true,
            size: 'lg',
        });
        modalInstance = this.modalRef.componentInstance;
        modalInstance.coupon = this.coupon;
    }
    findProducts() {
        this.myCouponsComponentService.launchSearchPage(this.coupon);
    }
}
CouponCardComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CouponCardComponent, deps: [{ token: ModalService }, { token: MyCouponsComponentService }], target: i0.ɵɵFactoryTarget.Component });
CouponCardComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: CouponCardComponent, selector: "cx-coupon-card", inputs: { coupon: "coupon", couponSubscriptionLoading$: "couponSubscriptionLoading$" }, outputs: { notificationChanged: "notificationChanged" }, ngImport: i0, template: "<div class=\"card\">\n  <div class=\"card-body cx-card-body\">\n    <div class=\"cx-coupon-data\">\n      <div class=\"cx-coupon-card-row top\">\n        <div class=\"cx-coupon-card-head\">\n          <span class=\"card-label-bold cx-coupon-card-id\">{{\n            coupon?.couponId\n          }}</span>\n          <span>: {{ coupon?.name }}</span>\n        </div>\n\n        <div class=\"cx-coupon-status {{ coupon?.status | lowercase }}\">\n          {{ 'myCoupons.' + coupon?.status | cxTranslate }}\n        </div>\n      </div>\n\n      <div class=\"cx-coupon-card-date\">\n        <p>{{ 'myCoupons.effectiveTitle' | cxTranslate }}</p>\n        <div class=\"cx-coupon-date\">\n          <div class=\"cx-coupon-date-start\">\n            {{ coupon?.startDate | cxDate: 'medium' }} -&nbsp;\n          </div>\n          <div class=\"cx-coupon-date-end\">\n            {{ coupon?.endDate | cxDate: 'medium' }}\n          </div>\n        </div>\n      </div>\n\n      <a (click)=\"readMore()\" class=\"cx-card-read-more\">{{\n        'myCoupons.readMore' | cxTranslate\n      }}</a>\n\n      <div class=\"cx-coupon-card-row bottom\">\n        <div class=\"cx-coupon-notification form-check\">\n          <label>\n            <input\n              type=\"checkbox\"\n              class=\"form-check-input\"\n              [checked]=\"coupon?.notificationOn\"\n              [class.disabled]=\"couponSubscriptionLoading$ | async\"\n              [disabled]=\"couponSubscriptionLoading$ | async\"\n              (change)=\"onSubscriptionChange()\"\n            />\n            <span class=\"form-check-label\">\n              {{ 'myCoupons.notification' | cxTranslate }}\n            </span>\n          </label>\n        </div>\n\n        <div class=\"cx-coupon-find-product col-lg-6 col-md-12 col-sm-6\">\n          <button class=\"btn btn-block btn-action\" (click)=\"findProducts()\">\n            {{ 'myCoupons.findProducts' | cxTranslate }}\n          </button>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n", pipes: { "lowercase": i3.LowerCasePipe, "cxTranslate": i1.TranslatePipe, "cxDate": i1.CxDatePipe, "async": i3.AsyncPipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CouponCardComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-coupon-card',
                    templateUrl: './coupon-card.component.html',
                }]
        }], ctorParameters: function () { return [{ type: ModalService }, { type: MyCouponsComponentService }]; }, propDecorators: { coupon: [{
                type: Input
            }], couponSubscriptionLoading$: [{
                type: Input
            }], notificationChanged: [{
                type: Output
            }] } });

class MyCouponsComponent {
    constructor(couponService, myCouponsComponentService) {
        this.couponService = couponService;
        this.myCouponsComponentService = myCouponsComponentService;
        this.iconTypes = ICON_TYPE;
        this.subscriptions = new Subscription();
        this.PAGE_SIZE = 10;
        this.sortMapping = {
            byStartDateAsc: 'startDate:asc',
            byStartDateDesc: 'startDate:desc',
            byEndDateAsc: 'endDate:asc',
            byEndDateDesc: 'endDate:desc',
        };
        this.sort = 'byStartDateAsc';
        this.sortOptions = [
            {
                code: 'byStartDateAsc',
                selected: false,
            },
            {
                code: 'byStartDateDesc',
                selected: false,
            },
            {
                code: 'byEndDateAsc',
                selected: false,
            },
            {
                code: 'byEndDateDesc',
                selected: false,
            },
        ];
    }
    ngOnInit() {
        this.couponResult$ = this.couponService
            .getCustomerCoupons(this.PAGE_SIZE)
            .pipe(tap((coupons) => (this.pagination = {
            currentPage: coupons.pagination.page,
            pageSize: coupons.pagination.count,
            totalPages: coupons.pagination.totalPages,
            totalResults: coupons.pagination.totalCount,
            sort: this.sort,
        })));
        this.couponsLoading$ = this.couponService.getCustomerCouponsLoading();
        this.couponSubscriptionLoading$ = combineLatest([
            this.couponService.getSubscribeCustomerCouponResultLoading(),
            this.couponService.getUnsubscribeCustomerCouponResultLoading(),
        ]).pipe(map(([subscribing, unsubscribing]) => subscribing || unsubscribing));
        this.sortLabels = this.myCouponsComponentService.getSortLabels();
        this.subscriptions
            .add(this.couponService
            .getSubscribeCustomerCouponResultError()
            .subscribe((error) => {
            this.subscriptionFail(error);
        }))
            .add(this.couponService
            .getUnsubscribeCustomerCouponResultError()
            .subscribe((error) => {
            this.subscriptionFail(error);
        }));
    }
    subscriptionFail(error) {
        if (error) {
            this.couponService.loadCustomerCoupons(this.PAGE_SIZE);
        }
    }
    sortChange(sort) {
        this.sort = sort;
        this.couponService.loadCustomerCoupons(this.PAGE_SIZE, this.pagination.currentPage, this.sortMapping[sort]);
    }
    pageChange(page) {
        this.couponService.loadCustomerCoupons(this.PAGE_SIZE, page, this.sortMapping[this.sort]);
    }
    notificationChange({ couponId, notification, }) {
        if (notification) {
            this.couponService.subscribeCustomerCoupon(couponId);
        }
        else {
            this.couponService.unsubscribeCustomerCoupon(couponId);
        }
    }
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
    }
}
MyCouponsComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: MyCouponsComponent, deps: [{ token: i1.CustomerCouponService }, { token: MyCouponsComponentService }], target: i0.ɵɵFactoryTarget.Component });
MyCouponsComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: MyCouponsComponent, selector: "cx-my-coupons", ngImport: i0, template: "<div class=\"cx-section\">\n  <ng-container *ngIf=\"!(couponsLoading$ | async); else loading\">\n    <ng-container *ngIf=\"couponResult$ | async as couponResult\">\n      <div class=\"cx-my-coupons-header\">\n        <h3>{{ 'myCoupons.myCoupons' | cxTranslate }}</h3>\n      </div>\n\n      <ng-container\n        *ngIf=\"couponResult.pagination.totalCount > 0; else noCoupons\"\n      >\n        <div class=\"cx-my-coupons-sort top row\">\n          <label\n            class=\"\n              cx-my-coupons-form-group\n              form-group\n              col-sm-12 col-md-4 col-lg-4\n            \"\n          >\n            <span>{{ 'myCoupons.sortBy' | cxTranslate }}</span>\n            <cx-sorting\n              [sortOptions]=\"sortOptions\"\n              [sortLabels]=\"sortLabels | async\"\n              (sortListEvent)=\"sortChange($event)\"\n              [selectedOption]=\"sort\"\n            >\n            </cx-sorting>\n          </label>\n          <div class=\"cx-my-coupons-pagination cx-mycoupon-thead-mobile\">\n            <cx-pagination\n              [pagination]=\"pagination\"\n              (viewPageEvent)=\"pageChange($event)\"\n            ></cx-pagination>\n          </div>\n        </div>\n\n        <div class=\"row cx-coupon-deck\">\n          <div\n            *ngFor=\"let coupon of couponResult.coupons\"\n            class=\"col-md-6 cx-coupon-card\"\n          >\n            <cx-coupon-card\n              [coupon]=\"coupon\"\n              [couponSubscriptionLoading$]=\"couponSubscriptionLoading$\"\n              (notificationChanged)=\"notificationChange($event)\"\n            ></cx-coupon-card>\n          </div>\n        </div>\n\n        <div class=\"cx-my-coupons-sort bottom row\">\n          <label\n            class=\"\n              cx-my-coupons-form-group\n              form-group\n              cx-mycoupon-thead-mobile\n              col-sm-12 col-md-4 col-lg-4\n            \"\n          >\n            <span>{{ 'myCoupons.sortBy' | cxTranslate }}</span>\n            <cx-sorting\n              [sortOptions]=\"sortOptions\"\n              [sortLabels]=\"sortLabels | async\"\n              (sortListEvent)=\"sortChange($event)\"\n              [selectedOption]=\"sort\"\n              placeholder=\"{{ 'myCoupons.sortBy' | cxTranslate }}\"\n            >\n            </cx-sorting>\n          </label>\n          <div class=\"cx-my-coupons-pagination\">\n            <cx-pagination\n              [pagination]=\"pagination\"\n              (viewPageEvent)=\"pageChange($event)\"\n            ></cx-pagination>\n          </div>\n        </div>\n        <div class=\"cx-my-coupons-notes\">\n          <span>\n            <cx-icon [type]=\"iconTypes.INFO\"></cx-icon>\n            {{ 'myCoupons.notesPreffix' | cxTranslate\n            }}<a [routerLink]=\"['/my-account/notification-preference']\">{{\n              'myCoupons.notesLink' | cxTranslate\n            }}</a\n            >{{ 'myCoupons.notesSuffix' | cxTranslate }}</span\n          >\n        </div>\n      </ng-container>\n    </ng-container>\n\n    <ng-template #noCoupons>\n      <section>\n        <p class=\"cx-section-msg\">\n          {{ 'myCoupons.noCouponsMessage' | cxTranslate }}\n        </p>\n      </section>\n    </ng-template>\n  </ng-container>\n\n  <ng-template #loading>\n    <div class=\"col-md-12 cx-coupon-spinner\">\n      <cx-spinner></cx-spinner>\n    </div>\n  </ng-template>\n</div>\n", components: [{ type: SortingComponent, selector: "cx-sorting", inputs: ["sortOptions", "selectedOption", "placeholder", "sortLabels"], outputs: ["sortListEvent"] }, { type: PaginationComponent, selector: "cx-pagination", inputs: ["pageRoute", "queryParam", "defaultPage", "pagination"], outputs: ["viewPageEvent"] }, { type: CouponCardComponent, selector: "cx-coupon-card", inputs: ["coupon", "couponSubscriptionLoading$"], outputs: ["notificationChanged"] }, { type: IconComponent, selector: "cx-icon,[cxIcon]", inputs: ["cxIcon", "type"] }, { type: SpinnerComponent, selector: "cx-spinner" }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i1$1.RouterLinkWithHref, selector: "a[routerLink],area[routerLink]", inputs: ["routerLink", "target", "queryParams", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange", "replaceUrl", "state", "relativeTo"] }], pipes: { "async": i3.AsyncPipe, "cxTranslate": i1.TranslatePipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: MyCouponsComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-my-coupons',
                    templateUrl: './my-coupons.component.html',
                }]
        }], ctorParameters: function () { return [{ type: i1.CustomerCouponService }, { type: MyCouponsComponentService }]; } });

class CouponClaimComponent {
    constructor(couponService, routingService, messageService) {
        this.couponService = couponService;
        this.routingService = routingService;
        this.messageService = messageService;
    }
    ngOnInit() {
        this.routingService
            .getRouterState()
            .subscribe((k) => {
            const couponCode = k.state.params.couponCode;
            if (couponCode) {
                this.couponService.claimCustomerCoupon(couponCode);
                this.subscription = this.couponService
                    .getClaimCustomerCouponResultSuccess()
                    .subscribe((success) => {
                    if (success) {
                        this.messageService.add({ key: 'myCoupons.claimCustomerCoupon' }, GlobalMessageType.MSG_TYPE_CONFIRMATION);
                    }
                    this.routingService.go({ cxRoute: 'coupons' });
                });
            }
            else {
                this.routingService.go({ cxRoute: 'notFound' });
            }
        })
            .unsubscribe();
    }
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
    }
}
CouponClaimComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CouponClaimComponent, deps: [{ token: i1.CustomerCouponService }, { token: i1.RoutingService }, { token: i1.GlobalMessageService }], target: i0.ɵɵFactoryTarget.Component });
CouponClaimComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: CouponClaimComponent, selector: "cx-coupon-claim", ngImport: i0, template: '', isInline: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CouponClaimComponent, decorators: [{
            type: Component,
            args: [{
                    template: '',
                    selector: 'cx-coupon-claim',
                }]
        }], ctorParameters: function () { return [{ type: i1.CustomerCouponService }, { type: i1.RoutingService }, { type: i1.GlobalMessageService }]; } });

class MyCouponsModule {
}
MyCouponsModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: MyCouponsModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
MyCouponsModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: MyCouponsModule, declarations: [MyCouponsComponent,
        CouponCardComponent,
        CouponDialogComponent,
        CouponClaimComponent], imports: [CommonModule,
        CardModule,
        SpinnerModule,
        I18nModule,
        RouterModule,
        UrlModule,
        IconModule,
        ListNavigationModule, i1$1.RouterModule], exports: [MyCouponsComponent, CouponClaimComponent] });
MyCouponsModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: MyCouponsModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                MyCouponsComponent: {
                    component: MyCouponsComponent,
                    guards: [AuthGuard],
                },
                CouponClaimComponent: {
                    component: CouponClaimComponent,
                    guards: [AuthGuard],
                },
            },
        }),
    ], imports: [[
            CommonModule,
            CardModule,
            SpinnerModule,
            I18nModule,
            RouterModule,
            UrlModule,
            IconModule,
            ListNavigationModule,
            RouterModule.forChild([
                {
                    path: null,
                    canActivate: [AuthGuard, CmsPageGuard],
                    component: PageLayoutComponent,
                    data: { cxRoute: 'couponClaim' },
                },
            ]),
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: MyCouponsModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        CardModule,
                        SpinnerModule,
                        I18nModule,
                        RouterModule,
                        UrlModule,
                        IconModule,
                        ListNavigationModule,
                        RouterModule.forChild([
                            {
                                path: null,
                                canActivate: [AuthGuard, CmsPageGuard],
                                component: PageLayoutComponent,
                                data: { cxRoute: 'couponClaim' },
                            },
                        ]),
                    ],
                    declarations: [
                        MyCouponsComponent,
                        CouponCardComponent,
                        CouponDialogComponent,
                        CouponClaimComponent,
                    ],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                MyCouponsComponent: {
                                    component: MyCouponsComponent,
                                    guards: [AuthGuard],
                                },
                                CouponClaimComponent: {
                                    component: CouponClaimComponent,
                                    guards: [AuthGuard],
                                },
                            },
                        }),
                    ],
                    exports: [MyCouponsComponent, CouponClaimComponent],
                }]
        }] });

class MyInterestsComponent {
    constructor(productInterestService, translationService, productService) {
        this.productInterestService = productInterestService;
        this.translationService = translationService;
        this.productService = productService;
        this.DEFAULT_PAGE_SIZE = 10;
        this.sortMapping = {
            byNameAsc: 'name:asc',
            byNameDesc: 'name:desc',
        };
        this.sort = 'byNameAsc';
        this.sortOptions = [
            {
                code: 'byNameAsc',
                selected: false,
            },
            {
                code: 'byNameDesc',
                selected: false,
            },
        ];
    }
    ngOnInit() {
        this.interests$ = this.productInterestService
            .getAndLoadProductInterests(this.DEFAULT_PAGE_SIZE)
            .pipe(tap((interests) => (this.pagination = {
            currentPage: interests.pagination.page,
            pageSize: interests.pagination.count,
            totalPages: interests.pagination.totalPages,
            totalResults: interests.pagination.totalCount,
            sort: 'byNameAsc',
        })), map((interest) => (Object.assign(Object.assign({}, interest), { results: interest.results
                ? interest.results.map((result) => (Object.assign(Object.assign({}, result), { product$: this.getProduct(result) })))
                : interest.results }))));
        this.getInterestsloading$ =
            this.productInterestService.getProdutInterestsLoading();
        this.isRemoveDisabled$ = combineLatest([
            this.getInterestsloading$,
            this.productInterestService.getRemoveProdutInterestLoading(),
        ]).pipe(map(([getLoading, removeLoading]) => getLoading || removeLoading));
        this.sortLabels = this.getSortLabels();
    }
    getSortLabels() {
        return combineLatest([
            this.translationService.translate('myInterests.sorting.byNameAsc'),
            this.translationService.translate('myInterests.sorting.byNameDesc'),
        ]).pipe(map(([asc, desc]) => {
            return {
                byNameAsc: asc,
                byNameDesc: desc,
            };
        }));
    }
    getProduct(interest) {
        return this.productService.get(interest.product.code, "details" /* DETAILS */);
    }
    removeInterest(relation) {
        this.productInterestService.removeProdutInterest({
            product: relation.product,
            productInterestEntry: relation.productInterestEntry,
        });
    }
    sortChange(sort) {
        this.sort = sort;
        this.productInterestService.loadProductInterests(this.DEFAULT_PAGE_SIZE, 0, this.sortMapping[sort]);
    }
    pageChange(page) {
        this.productInterestService.loadProductInterests(this.DEFAULT_PAGE_SIZE, page, this.sortMapping[this.sort]);
    }
    ngOnDestroy() {
        this.productInterestService.clearProductInterests();
        this.productInterestService.resetRemoveInterestState();
    }
}
MyInterestsComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: MyInterestsComponent, deps: [{ token: i1.UserInterestsService }, { token: i1.TranslationService }, { token: i1.ProductService }], target: i0.ɵɵFactoryTarget.Component });
MyInterestsComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: MyInterestsComponent, selector: "cx-my-interests", ngImport: i0, template: "<div *ngIf=\"interests$ | async as interests\" class=\"container\">\n  <div class=\"cx-product-interests-title h3\">\n    <h3>{{ 'myInterests.header' | cxTranslate }}</h3>\n  </div>\n  <div\n    class=\"cx-product-interests-body\"\n    *ngIf=\"!(getInterestsloading$ | async); else loading\"\n  >\n    <ng-container *ngIf=\"interests.pagination.totalCount > 0; else noInterest\">\n      <div class=\"cx-product-interests-sort top row\">\n        <label\n          class=\"\n            cx-product-interests-form-group\n            form-group\n            col-sm-12 col-md-4 col-lg-4\n          \"\n          ><span>{{ 'myInterests.sortBy' | cxTranslate }}</span>\n          <cx-sorting\n            [sortOptions]=\"sortOptions\"\n            [sortLabels]=\"sortLabels | async\"\n            (sortListEvent)=\"sortChange($event)\"\n            [selectedOption]=\"sort\"\n            placeholder=\"{{ 'myInterests.sortBy' | cxTranslate }}\"\n          >\n          </cx-sorting>\n        </label>\n        <div\n          class=\"\n            cx-product-interests-pagination cx-product-interests-thead-mobile\n          \"\n        >\n          <cx-pagination\n            [pagination]=\"pagination\"\n            (viewPageEvent)=\"pageChange($event)\"\n          ></cx-pagination>\n        </div>\n      </div>\n      <table class=\"table cx-product-interests-table\">\n        <thead class=\"cx-product-interests-thead-mobile\">\n          <th scope=\"col\">\n            {{ 'myInterests.item' | cxTranslate }}\n          </th>\n          <th scope=\"col\"></th>\n          <th scope=\"col\">\n            {{ 'myInterests.price' | cxTranslate }}\n          </th>\n          <th scope=\"col\">\n            {{ 'myInterests.notifications' | cxTranslate }}\n          </th>\n          <th scope=\"col\"></th>\n        </thead>\n        <tbody>\n          <tr\n            *ngFor=\"let interest of interests.results\"\n            class=\"cx-product-interests-product-item\"\n          >\n            <ng-container *ngIf=\"interest.product$ | async as product\">\n              <td>\n                <div class=\"cx-product-interests-label\">\n                  <a\n                    class=\"cx-product-interests-product-image-link\"\n                    tabindex=\"-1\"\n                    [routerLink]=\"\n                      { cxRoute: 'product', params: product } | cxUrl\n                    \"\n                  >\n                    <cx-media\n                      [container]=\"product.images?.PRIMARY\"\n                      format=\"thumbnail\"\n                    ></cx-media>\n                  </a>\n                </div>\n              </td>\n              <td>\n                <div class=\"cx-info col-10\">\n                  <div class=\"cx-info-container row\">\n                    <div>\n                      <div *ngIf=\"product.name\" class=\"cx-name\">\n                        <a\n                          class=\"cx-link cx-product-interests-product-code-link\"\n                          [routerLink]=\"\n                            { cxRoute: 'product', params: product } | cxUrl\n                          \"\n                        >\n                          {{ product.name }}\n                        </a>\n                      </div>\n                      <div *ngIf=\"product.code\" class=\"cx-code\">\n                        <span>{{\n                          'myInterests.productId'\n                            | cxTranslate: { code: product.code }\n                        }}</span>\n                      </div>\n\n                      <ng-container\n                        *ngFor=\"let baseOptions of product.baseOptions\"\n                      >\n                        <div\n                          *ngFor=\"\n                            let variant of baseOptions.selected\n                              ?.variantOptionQualifiers\n                          \"\n                          class=\"cx-property\"\n                        >\n                          <div\n                            class=\"cx-label cx-product-interests-variant-name\"\n                          >\n                            {{ variant.name }}\n                          </div>\n                          <div\n                            class=\"cx-value cx-product-interests-variant-value\"\n                          >\n                            {{ variant.value }}\n                          </div>\n                        </div>\n                      </ng-container>\n                      <div\n                        class=\"cx-property\"\n                        *ngIf=\"product.stock.stockLevelStatus === 'outOfStock'\"\n                      >\n                        <div\n                          class=\"cx-label cx-product-interests-product-stock\"\n                        >\n                          {{ 'myInterests.outOfStock' | cxTranslate }}\n                        </div>\n                      </div>\n                    </div>\n                  </div>\n                </div>\n              </td>\n              <td>\n                <div class=\"cx-product-interests-product-price\">\n                  <div class=\"d-md-none cx-product-interests-label\">\n                    {{ 'myInterests.price' | cxTranslate }}\n                  </div>\n                  <span>{{ product.price.formattedValue }}</span>\n                </div>\n              </td>\n              <td>\n                <div class=\"cx-product-interests-subscriptions\">\n                  <div class=\"d-md-none cx-product-interests-label\">\n                    {{ 'myInterests.notifications' | cxTranslate }}\n                  </div>\n                  <div\n                    class=\"cx-product-interests-notification\"\n                    *ngFor=\"let interestEntry of interest.productInterestEntry\"\n                  >\n                    <span class=\"cx-product-interests-type\">\n                      {{\n                        'myInterests.' + interestEntry.interestType\n                          | cxTranslate\n                      }}\n                    </span>\n                    <span class=\"cx-product-interests-expiration-date\">\n                      {{\n                        'myInterests.expirationDate'\n                          | cxTranslate\n                            : {\n                                expirationDate:\n                                  interestEntry.expirationDate | date\n                              }\n                      }}\n                    </span>\n                  </div>\n                </div>\n              </td>\n              <td>\n                <div class=\"cx-actions cx-product-interests-remove-button\">\n                  <button\n                    type=\"button\"\n                    class=\"link cx-product-interests-remove-btn\"\n                    [disabled]=\"isRemoveDisabled$ | async\"\n                    (click)=\"removeInterest(interest)\"\n                  >\n                    {{ 'myInterests.remove' | cxTranslate }}\n                  </button>\n                </div>\n              </td>\n            </ng-container>\n          </tr>\n        </tbody>\n      </table>\n      <div class=\"cx-product-interests-sort bottom row\">\n        <label\n          class=\"\n            cx-product-interests-form-group cx-product-interests-thead-mobile\n            form-group\n            col-sm-12 col-md-4 col-lg-4\n          \"\n          ><span>{{ 'myInterests.sortBy' | cxTranslate }}</span>\n          <cx-sorting\n            [sortOptions]=\"sortOptions\"\n            [sortLabels]=\"sortLabels | async\"\n            (sortListEvent)=\"sortChange($event)\"\n            [selectedOption]=\"sort\"\n            placeholder=\"{{ 'myInterests.sortBy' | cxTranslate }}\"\n          >\n          </cx-sorting>\n        </label>\n        <div class=\"cx-product-interests-pagination\">\n          <cx-pagination\n            [pagination]=\"pagination\"\n            (viewPageEvent)=\"pageChange($event)\"\n          ></cx-pagination>\n        </div>\n      </div>\n    </ng-container>\n  </div>\n</div>\n<ng-template #noInterest>\n  <div class=\"cx-product-interests-message\">\n    {{ 'myInterests.noInterests' | cxTranslate }}\n  </div>\n</ng-template>\n<ng-template #loading>\n  <div class=\"cx-spinner\">\n    <cx-spinner></cx-spinner>\n  </div>\n</ng-template>\n", components: [{ type: SortingComponent, selector: "cx-sorting", inputs: ["sortOptions", "selectedOption", "placeholder", "sortLabels"], outputs: ["sortListEvent"] }, { type: PaginationComponent, selector: "cx-pagination", inputs: ["pageRoute", "queryParam", "defaultPage", "pagination"], outputs: ["viewPageEvent"] }, { type: MediaComponent, selector: "cx-media", inputs: ["container", "format", "alt", "role", "loading"], outputs: ["loaded"] }, { type: SpinnerComponent, selector: "cx-spinner" }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i1$1.RouterLinkWithHref, selector: "a[routerLink],area[routerLink]", inputs: ["routerLink", "target", "queryParams", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange", "replaceUrl", "state", "relativeTo"] }], pipes: { "async": i3.AsyncPipe, "cxTranslate": i1.TranslatePipe, "cxUrl": i1.UrlPipe, "date": i3.DatePipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: MyInterestsComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-my-interests',
                    templateUrl: './my-interests.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: i1.UserInterestsService }, { type: i1.TranslationService }, { type: i1.ProductService }]; } });

class MyInterestsModule {
}
MyInterestsModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: MyInterestsModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
MyInterestsModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: MyInterestsModule, declarations: [MyInterestsComponent], imports: [CommonModule,
        I18nModule,
        RouterModule,
        ListNavigationModule,
        I18nModule,
        UrlModule,
        MediaModule,
        SpinnerModule], exports: [MyInterestsComponent] });
MyInterestsModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: MyInterestsModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                MyInterestsComponent: {
                    component: MyInterestsComponent,
                    guards: [AuthGuard],
                },
            },
        }),
    ], imports: [[
            CommonModule,
            I18nModule,
            RouterModule,
            ListNavigationModule,
            I18nModule,
            UrlModule,
            MediaModule,
            SpinnerModule,
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: MyInterestsModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [MyInterestsComponent],
                    imports: [
                        CommonModule,
                        I18nModule,
                        RouterModule,
                        ListNavigationModule,
                        I18nModule,
                        UrlModule,
                        MediaModule,
                        SpinnerModule,
                    ],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                MyInterestsComponent: {
                                    component: MyInterestsComponent,
                                    guards: [AuthGuard],
                                },
                            },
                        }),
                    ],
                    exports: [MyInterestsComponent],
                }]
        }] });

class NotificationPreferenceComponent {
    constructor(notificationPreferenceService) {
        this.notificationPreferenceService = notificationPreferenceService;
        this.preferences = [];
    }
    ngOnInit() {
        this.notificationPreferenceService.resetNotificationPreferences();
        this.preferences$ = this.notificationPreferenceService
            .getPreferences()
            .pipe(tap((preferences) => (this.preferences = preferences)));
        this.notificationPreferenceService.loadPreferences();
        this.isLoading$ = combineLatest([
            this.notificationPreferenceService.getPreferencesLoading(),
            this.notificationPreferenceService.getUpdatePreferencesResultLoading(),
        ]).pipe(map(([prefsLoading, updateLoading]) => prefsLoading || updateLoading));
    }
    updatePreference(preference) {
        const updatedPreferences = [];
        this.preferences.forEach((p) => {
            if (p.channel === preference.channel) {
                updatedPreferences.push(Object.assign(Object.assign({}, p), { enabled: !p.enabled }));
            }
            else {
                updatedPreferences.push(p);
            }
        });
        this.notificationPreferenceService.updatePreferences(updatedPreferences);
    }
}
NotificationPreferenceComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: NotificationPreferenceComponent, deps: [{ token: i1.UserNotificationPreferenceService }], target: i0.ɵɵFactoryTarget.Component });
NotificationPreferenceComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: NotificationPreferenceComponent, selector: "cx-notification-preference", ngImport: i0, template: "<ng-container *ngIf=\"preferences$ | async as preferences\">\n  <div *ngIf=\"preferences.length > 0; else loading\">\n    <div class=\"row d-flex justify-content-center\">\n      <div class=\"col-md-8\">\n        <div class=\"pref-header\">\n          {{ 'notificationPreference.message' | cxTranslate }}\n        </div>\n        <div class=\"form-check cx-notification-channels\">\n          <ng-container *ngFor=\"let preference of preferences\">\n            <label *ngIf=\"preference.visible\" class=\"pref-channel\">\n              <input\n                class=\"form-check-input cx-np-checkbox\"\n                role=\"checkbox\"\n                type=\"checkbox\"\n                [checked]=\"preference.enabled\"\n                (change)=\"updatePreference(preference)\"\n                [disabled]=\"isLoading$ | async\"\n              />\n              <span class=\"form-check-label\">\n                {{\n                  'notificationPreference.' + preference.channel | cxTranslate\n                }}\n                {{ preference.value }}\n              </span>\n            </label>\n          </ng-container>\n        </div>\n        <label class=\"pref-note\"\n          ><strong>{{ 'notificationPreference.note' | cxTranslate }}</strong\n          >{{ 'notificationPreference.noteMessage' | cxTranslate }}\n        </label>\n      </div>\n    </div>\n  </div>\n\n  <ng-template #loading>\n    <div class=\"cx-spinner\">\n      <cx-spinner></cx-spinner>\n    </div>\n  </ng-template>\n</ng-container>\n", components: [{ type: SpinnerComponent, selector: "cx-spinner" }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], pipes: { "async": i3.AsyncPipe, "cxTranslate": i1.TranslatePipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: NotificationPreferenceComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-notification-preference',
                    templateUrl: './notification-preference.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: i1.UserNotificationPreferenceService }]; } });

class NotificationPreferenceModule {
}
NotificationPreferenceModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: NotificationPreferenceModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
NotificationPreferenceModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: NotificationPreferenceModule, declarations: [NotificationPreferenceComponent], imports: [CommonModule, SpinnerModule, I18nModule], exports: [NotificationPreferenceComponent] });
NotificationPreferenceModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: NotificationPreferenceModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                NotificationPreferenceComponent: {
                    component: NotificationPreferenceComponent,
                    guards: [AuthGuard],
                },
            },
        }),
    ], imports: [[CommonModule, SpinnerModule, I18nModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: NotificationPreferenceModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [NotificationPreferenceComponent],
                    imports: [CommonModule, SpinnerModule, I18nModule],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                NotificationPreferenceComponent: {
                                    component: NotificationPreferenceComponent,
                                    guards: [AuthGuard],
                                },
                            },
                        }),
                    ],
                    exports: [NotificationPreferenceComponent],
                }]
        }] });

/**
 * @deprecated since 4.2 - use order lib instead
 */
class AmendOrderActionsComponent {
    constructor(routingService) {
        this.routingService = routingService;
        this.styles = 'row';
    }
    continue(event) {
        if (this.amendOrderForm.valid) {
            this.routingService.go({
                cxRoute: this.forwardRoute,
                params: { code: this.orderCode },
            });
        }
        else {
            this.amendOrderForm.markAllAsTouched();
            event.stopPropagation();
        }
    }
}
AmendOrderActionsComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AmendOrderActionsComponent, deps: [{ token: i1.RoutingService }], target: i0.ɵɵFactoryTarget.Component });
AmendOrderActionsComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: AmendOrderActionsComponent, selector: "cx-amend-order-actions", inputs: { orderCode: "orderCode", amendOrderForm: "amendOrderForm", backRoute: "backRoute", forwardRoute: "forwardRoute" }, host: { properties: { "class": "this.styles" } }, ngImport: i0, template: "<div class=\"col-xs-12 col-md-4 col-lg-3\">\n  <a\n    [routerLink]=\"\n      {\n        cxRoute: backRoute,\n        params: { code: orderCode }\n      } | cxUrl\n    \"\n    class=\"btn btn-block btn-action\"\n  >\n    {{ 'common.back' | cxTranslate }}\n  </a>\n</div>\n<div class=\"col-xs-12 col-md-4 col-lg-3\">\n  <button\n    *ngIf=\"forwardRoute\"\n    class=\"btn btn-block btn-primary\"\n    (click)=\"continue($event)\"\n  >\n    {{ 'common.continue' | cxTranslate }}\n  </button>\n\n  <button *ngIf=\"!forwardRoute\" class=\"btn btn-block btn-primary\" type=\"submit\">\n    {{ 'orderDetails.cancellationAndReturn.submit' | cxTranslate }}\n  </button>\n</div>\n", directives: [{ type: i1$1.RouterLinkWithHref, selector: "a[routerLink],area[routerLink]", inputs: ["routerLink", "target", "queryParams", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange", "replaceUrl", "state", "relativeTo"] }, { type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "cxUrl": i1.UrlPipe, "cxTranslate": i1.TranslatePipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AmendOrderActionsComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-amend-order-actions',
                    templateUrl: './amend-order-actions.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: i1.RoutingService }]; }, propDecorators: { orderCode: [{
                type: Input
            }], amendOrderForm: [{
                type: Input
            }], backRoute: [{
                type: Input
            }], forwardRoute: [{
                type: Input
            }], styles: [{
                type: HostBinding,
                args: ['class']
            }] } });

/**
 * @deprecated since 4.2 - use order lib instead
 */
class AmendOrderActionsModule {
}
AmendOrderActionsModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AmendOrderActionsModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
AmendOrderActionsModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AmendOrderActionsModule, declarations: [AmendOrderActionsComponent], imports: [CommonModule, RouterModule, UrlModule, I18nModule], exports: [AmendOrderActionsComponent] });
AmendOrderActionsModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AmendOrderActionsModule, imports: [[CommonModule, RouterModule, UrlModule, I18nModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AmendOrderActionsModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, RouterModule, UrlModule, I18nModule],
                    declarations: [AmendOrderActionsComponent],
                    exports: [AmendOrderActionsComponent],
                }]
        }] });

/**
 * @deprecated since 4.2 - use order lib instead
 */
var AmendOrderType;
(function (AmendOrderType) {
    AmendOrderType[AmendOrderType["CANCEL"] = 0] = "CANCEL";
    AmendOrderType[AmendOrderType["RETURN"] = 1] = "RETURN";
})(AmendOrderType || (AmendOrderType = {}));

// TODO: remove this token in 5.0
class OrderDetailsServiceTransitionalToken {
}

/**
 * @deprecated since 4.2 - use order lib instead
 */
class OrderDetailsService {
    constructor(userOrderService, routingService, unifiedInjector) {
        this.userOrderService = userOrderService;
        this.routingService = routingService;
        this.unifiedInjector = unifiedInjector;
        this.orderCode$ = this.routingService.getRouterState().pipe(map((routingData) => routingData.state.params.orderCode), distinctUntilChanged());
        this.orderLoad$ = this.orderCode$.pipe(tap((orderCode) => {
            if (orderCode) {
                this.userOrderService.loadOrderDetails(orderCode);
            }
            else {
                this.userOrderService.clearOrderDetails();
            }
        }), shareReplay({ bufferSize: 1, refCount: true }));
    }
    getOrderDetails() {
        if (this.unifiedInjector) {
            const serivce = getLastValueSync(this.unifiedInjector.get(OrderDetailsServiceTransitionalToken));
            if (serivce) {
                return serivce.getOrderDetails();
            }
        }
        return this.orderLoad$.pipe(switchMap(() => this.userOrderService.getOrderDetails()));
    }
}
OrderDetailsService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OrderDetailsService, deps: [{ token: i1.UserOrderService }, { token: i1.RoutingService }, { token: i1.UnifiedInjector }], target: i0.ɵɵFactoryTarget.Injectable });
OrderDetailsService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OrderDetailsService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OrderDetailsService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.UserOrderService }, { type: i1.RoutingService }, { type: i1.UnifiedInjector }]; } });

function ValidateQuantityToCancel(control) {
    if (!control.value) {
        return null;
    }
    const quantity = Object.values(control.value).reduce((acc, val) => acc + val, 0);
    return quantity > 0 ? null : { cxNoSelectedItemToCancel: true };
}
/**
 * @deprecated since 4.2 - use order lib instead
 */
class OrderAmendService {
    constructor(orderDetailsService) {
        this.orderDetailsService = orderDetailsService;
    }
    /**
     * Returns entries with an amended quantity.
     */
    getAmendedEntries() {
        return this.getForm().pipe(switchMap((form) => {
            return this.getEntries().pipe(map((entries) => entries.filter((entry) => this.getFormControl(form, entry).value > 0)));
        }));
    }
    getOrder() {
        return this.orderDetailsService.getOrderDetails();
    }
    /**
     * returns the form with form data at runtime
     */
    getForm() {
        return this.getOrder().pipe(tap((order) => {
            if (!this.form || this.form.get('orderCode').value !== order.code) {
                this.buildForm(order);
            }
        }), map(() => this.form));
    }
    buildForm(order) {
        this.form = new FormGroup({});
        this.form.addControl('orderCode', new FormControl(order.code));
        const entryGroup = new FormGroup({}, { validators: [ValidateQuantityToCancel] });
        this.form.addControl('entries', entryGroup);
        (order.entries || []).forEach((entry) => {
            const key = entry.entryNumber.toString();
            entryGroup.addControl(key, new FormControl(0, {
                validators: [
                    Validators.min(0),
                    Validators.max(this.getMaxAmendQuantity(entry)),
                ],
            }));
        });
    }
    getFormControl(form, entry) {
        return form.get('entries').get(entry.entryNumber.toString());
    }
    /**
     * As discussed, this calculation is moved to SPA side.
     * The calculation and validation should be in backend facade layer.
     */
    getAmendedPrice(entry) {
        const amendedQuantity = this.getFormControl(this.form, entry).value;
        const amendedPrice = Object.assign({}, entry.basePrice);
        amendedPrice.value =
            Math.round(entry.basePrice.value * amendedQuantity * 100) / 100;
        amendedPrice.formattedValue = formatCurrency(amendedPrice.value, 
        // TODO: user current language
        'en', getCurrencySymbol(amendedPrice.currencyIso, 'narrow'), amendedPrice.currencyIso);
        return amendedPrice;
    }
    getMaxAmendQuantity(entry) {
        return ((this.isCancellation()
            ? entry.cancellableQuantity
            : entry.returnableQuantity) || entry.quantity);
    }
    isCancellation() {
        return this.amendType === AmendOrderType.CANCEL;
    }
}
OrderAmendService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OrderAmendService, deps: [{ token: OrderDetailsService }], target: i0.ɵɵFactoryTarget.Injectable });
OrderAmendService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OrderAmendService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OrderAmendService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: OrderDetailsService }]; } });

/**
 * @deprecated since 4.2 - use order lib instead
 */
class CancelOrReturnItemsComponent {
    constructor(orderAmendService) {
        this.orderAmendService = orderAmendService;
        this.isConfirmation = false;
        this.form$ = this.orderAmendService.getForm();
    }
    getControl(form, entry) {
        const control = (form.get('entries').get(entry.entryNumber.toString()));
        return control;
    }
    setAll(form) {
        this.entries.forEach((entry) => this.getControl(form, entry).setValue(this.getMaxAmendQuantity(entry)));
    }
    getItemPrice(entry) {
        return this.orderAmendService.getAmendedPrice(entry);
    }
    getMaxAmendQuantity(entry) {
        return this.orderAmendService.getMaxAmendQuantity(entry);
    }
    isCancellation() {
        return this.orderAmendService.isCancellation();
    }
}
CancelOrReturnItemsComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CancelOrReturnItemsComponent, deps: [{ token: OrderAmendService }], target: i0.ɵɵFactoryTarget.Component });
CancelOrReturnItemsComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: CancelOrReturnItemsComponent, selector: "cx-amend-order-items", inputs: { entries: "entries", isConfirmation: "isConfirmation" }, ngImport: i0, template: "<div *ngIf=\"form$ | async as form\">\n  <button\n    *ngIf=\"!isConfirmation\"\n    class=\"btn btn-link cx-action-link\"\n    (click)=\"setAll(form)\"\n  >\n    {{ 'orderDetails.cancellationAndReturn.setAll' | cxTranslate }}\n  </button>\n\n  <div class=\"d-none d-md-block cx-item-list-header\">\n    <div class=\"row\">\n      <div class=\"text-left col-6\">\n        {{ 'orderDetails.cancellationAndReturn.item' | cxTranslate }}\n      </div>\n      <div class=\"text-center col-2\">\n        {{ 'orderDetails.cancellationAndReturn.itemPrice' | cxTranslate }}\n      </div>\n      <div *ngIf=\"!isConfirmation\" class=\"text-center col-2\">\n        {{ 'orderDetails.cancellationAndReturn.quantity' | cxTranslate }}\n      </div>\n      <div class=\"cx-item-list-qty col-2 text-right\">\n        {{\n          (isCancellation()\n            ? 'orderDetails.cancellationAndReturn.cancelQty'\n            : 'orderDetails.cancellationAndReturn.returnQty'\n          ) | cxTranslate\n        }}\n      </div>\n      <div *ngIf=\"isConfirmation\" class=\"cx-item-list-total col-2\">\n        {{ 'orderDetails.cancellationAndReturn.totalPrice' | cxTranslate }}\n      </div>\n    </div>\n  </div>\n\n  <div class=\"cx-item-list-row\" *ngFor=\"let item of entries; let i = index\">\n    <div class=\"row cx-item-list-items\">\n      <!-- Item Image -->\n      <cx-media\n        class=\"col-2\"\n        [container]=\"item.product.images?.PRIMARY\"\n        format=\"thumbnail\"\n      ></cx-media>\n\n      <!-- Item Information -->\n      <div class=\"cx-info col-10\">\n        <div class=\"cx-info-container row\">\n          <!-- Item Description -->\n          <div class=\"col-md-4 col-xl-5 cx-list-item-desc\">\n            <div *ngIf=\"item.product.name\" class=\"cx-name\">\n              {{ item.product.name }}\n            </div>\n            <div *ngIf=\"item.product.code\" class=\"cx-code\">\n              {{ 'cartItems.id' | cxTranslate }} {{ item.product.code }}\n            </div>\n            <!-- Variants -->\n            <ng-container *ngIf=\"item.product.baseOptions?.length\">\n              <div\n                *ngFor=\"\n                  let variant of item.product.baseOptions[0]?.selected\n                    ?.variantOptionQualifiers\n                \"\n                class=\"cx-property\"\n              >\n                <div class=\"cx-label\" *ngIf=\"variant.name\">\n                  {{ variant.name }}:\n                </div>\n                <div class=\"cx-value\" *ngIf=\"variant.value\">\n                  {{ variant.value }}\n                </div>\n              </div>\n            </ng-container>\n          </div>\n          <!-- Price -->\n          <div\n            *ngIf=\"item.basePrice\"\n            class=\"cx-price col-md-3 col-lg-3 col-xl-2\"\n          >\n            <div class=\"cx-label d-block d-md-none d-lg-none d-xl-none\">\n              {{ 'orderDetails.cancellationAndReturn.itemPrice' | cxTranslate }}\n            </div>\n            <div *ngIf=\"item.basePrice\" class=\"cx-value\">\n              {{ item.basePrice?.formattedValue }}\n            </div>\n          </div>\n          <!-- item Quantity -->\n          <div *ngIf=\"!isConfirmation\" class=\"cx-request-qty col-md-3\">\n            <div\n              class=\"cx-label d-block d-md-none d-lg-none d-xl-none\"\n              placement=\"left\"\n              title=\"{{ 'cartItems.quantityTitle' | cxTranslate }}\"\n            >\n              {{ 'orderDetails.cancellationAndReturn.quantity' | cxTranslate }}\n            </div>\n            <div class=\"cx-value\">\n              {{ getMaxAmendQuantity(item) }}\n            </div>\n          </div>\n          <!-- Amended Quantity -->\n          <div class=\"cx-quantity col-xs-12 col-md-2 col-sm-12\">\n            <div class=\"cx-label d-block d-md-none d-lg-none d-xl-none\">\n              {{\n                (isCancellation()\n                  ? 'orderDetails.cancellationAndReturn.cancelQty'\n                  : 'orderDetails.cancellationAndReturn.returnQty'\n                ) | cxTranslate\n              }}\n            </div>\n\n            <div\n              *ngIf=\"isConfirmation\"\n              class=\"w-100 text-center cx-order-quantity-value\"\n            >\n              {{ getControl(form, item).value }}\n            </div>\n            <cx-item-counter\n              *ngIf=\"!isConfirmation\"\n              [min]=\"0\"\n              [max]=\"getMaxAmendQuantity(item)\"\n              [control]=\"getControl(form, item)\"\n            >\n            </cx-item-counter>\n          </div>\n          <!-- Total Price -->\n          <div *ngIf=\"isConfirmation\" class=\"cx-total col-3\">\n            <div class=\"cx-label d-block d-md-none\">\n              {{\n                'orderDetails.cancellationAndReturn.totalPrice' | cxTranslate\n              }}\n            </div>\n            <div class=\"cx-value\">\n              {{ getItemPrice(item)?.formattedValue }}\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n", components: [{ type: MediaComponent, selector: "cx-media", inputs: ["container", "format", "alt", "role", "loading"], outputs: ["loaded"] }, { type: ItemCounterComponent, selector: "cx-item-counter", inputs: ["control", "min", "max", "step", "allowZero", "readonly"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], pipes: { "async": i3.AsyncPipe, "cxTranslate": i1.TranslatePipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CancelOrReturnItemsComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-amend-order-items',
                    templateUrl: './amend-order-items.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: OrderAmendService }]; }, propDecorators: { entries: [{
                type: Input
            }], isConfirmation: [{
                type: Input
            }] } });

/**
 * @deprecated since 4.2 - use order lib instead
 */
class AmendOrderItemsModule {
}
AmendOrderItemsModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AmendOrderItemsModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
AmendOrderItemsModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AmendOrderItemsModule, declarations: [CancelOrReturnItemsComponent], imports: [CommonModule,
        ReactiveFormsModule,
        I18nModule,
        MediaModule,
        ItemCounterModule,
        FeaturesConfigModule,
        FormErrorsModule], exports: [CancelOrReturnItemsComponent] });
AmendOrderItemsModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AmendOrderItemsModule, imports: [[
            CommonModule,
            ReactiveFormsModule,
            I18nModule,
            MediaModule,
            ItemCounterModule,
            FeaturesConfigModule,
            FormErrorsModule,
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AmendOrderItemsModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        ReactiveFormsModule,
                        I18nModule,
                        MediaModule,
                        ItemCounterModule,
                        FeaturesConfigModule,
                        FormErrorsModule,
                    ],
                    declarations: [CancelOrReturnItemsComponent],
                    exports: [CancelOrReturnItemsComponent],
                }]
        }] });

/**
 * @deprecated since 4.2 - use order lib instead
 */
class CancelOrderConfirmationComponent {
    constructor(orderAmendService) {
        this.orderAmendService = orderAmendService;
        this.form$ = this.orderAmendService
            .getForm()
            .pipe(tap((form) => (this.orderCode = form.value.orderCode)));
        this.entries$ = this.orderAmendService.getAmendedEntries();
    }
    submit(form) {
        if (form.valid) {
            this.orderAmendService.save();
        }
        else {
            form.markAllAsTouched();
        }
    }
}
CancelOrderConfirmationComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CancelOrderConfirmationComponent, deps: [{ token: OrderAmendService }], target: i0.ɵɵFactoryTarget.Component });
CancelOrderConfirmationComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: CancelOrderConfirmationComponent, selector: "cx-cancel-order-confirmation", ngImport: i0, template: "<form\n  *ngIf=\"form$ | async as form\"\n  [formGroup]=\"form\"\n  (ngSubmit)=\"submit(form)\"\n>\n  <ng-container *ngTemplateOutlet=\"actions\"></ng-container>\n\n  <cx-amend-order-items\n    *ngIf=\"entries$ | async as entries\"\n    [entries]=\"entries\"\n    [isConfirmation]=\"true\"\n  >\n  </cx-amend-order-items>\n\n  <ng-container *ngTemplateOutlet=\"actions\"></ng-container>\n\n  <ng-template #actions>\n    <cx-amend-order-actions\n      *ngIf=\"orderCode\"\n      [orderCode]=\"orderCode\"\n      [amendOrderForm]=\"form\"\n      backRoute=\"orderCancel\"\n    ></cx-amend-order-actions>\n  </ng-template>\n</form>\n", components: [{ type: CancelOrReturnItemsComponent, selector: "cx-amend-order-items", inputs: ["entries", "isConfirmation"] }, { type: AmendOrderActionsComponent, selector: "cx-amend-order-actions", inputs: ["orderCode", "amendOrderForm", "backRoute", "forwardRoute"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3$1.ɵNgNoValidate, selector: "form:not([ngNoForm]):not([ngNativeValidate])" }, { type: i3$1.NgControlStatusGroup, selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { type: i3$1.FormGroupDirective, selector: "[formGroup]", inputs: ["formGroup"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }, { type: i3.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }], pipes: { "async": i3.AsyncPipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CancelOrderConfirmationComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-cancel-order-confirmation',
                    templateUrl: './cancel-order-confirmation.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: OrderAmendService }]; } });

/**
 * @deprecated since 4.2 - use order lib instead
 */
class OrderCancellationService extends OrderAmendService {
    constructor(orderDetailsService, userOrderService, routing, globalMessageService) {
        super(orderDetailsService);
        this.orderDetailsService = orderDetailsService;
        this.userOrderService = userOrderService;
        this.routing = routing;
        this.globalMessageService = globalMessageService;
        this.amendType = AmendOrderType.CANCEL;
    }
    /**
     * Return cancellable order entries.
     */
    getEntries() {
        return this.getOrder().pipe(filter((order) => !!(order === null || order === void 0 ? void 0 : order.entries)), map((order) => order.entries.filter((entry) => entry.entryNumber !== -1 && entry.cancellableQuantity > 0)));
    }
    save() {
        const orderCode = this.form.value.orderCode;
        const entries = this.form.value.entries;
        const inputs = Object.keys(entries)
            .filter((entryNumber) => entries[entryNumber] > 0)
            .map((entryNumber) => ({
            orderEntryNumber: Number(entryNumber),
            quantity: entries[entryNumber],
        }));
        this.form.reset();
        this.userOrderService.cancelOrder(orderCode, {
            cancellationRequestEntryInputs: inputs,
        });
        this.userOrderService
            .getCancelOrderSuccess()
            .pipe(first(Boolean))
            .subscribe(() => this.afterSave(orderCode));
    }
    afterSave(orderCode) {
        this.userOrderService.resetCancelOrderProcessState();
        this.globalMessageService.add({
            key: 'orderDetails.cancellationAndReturn.cancelSuccess',
            params: { orderCode },
        }, GlobalMessageType.MSG_TYPE_CONFIRMATION);
        this.routing.go({
            cxRoute: 'orders',
        });
    }
}
OrderCancellationService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OrderCancellationService, deps: [{ token: OrderDetailsService }, { token: i1.UserOrderService }, { token: i1.RoutingService }, { token: i1.GlobalMessageService }], target: i0.ɵɵFactoryTarget.Injectable });
OrderCancellationService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OrderCancellationService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OrderCancellationService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: OrderDetailsService }, { type: i1.UserOrderService }, { type: i1.RoutingService }, { type: i1.GlobalMessageService }]; } });

/**
 * @deprecated since 4.2 - use order lib instead
 */
class OrderCancellationGuard {
    constructor(orderAmendService, semanticPathService, router) {
        this.orderAmendService = orderAmendService;
        this.semanticPathService = semanticPathService;
        this.router = router;
    }
    canActivate() {
        return this.orderAmendService.getForm().pipe(map((form) => {
            if (!form.valid) {
                // the order code is not available in the route
                // as long as we're inside a guard, hence we redirect
                // to the common orders page.
                return this.router.parseUrl(this.semanticPathService.get('orders'));
            }
            else {
                return true;
            }
        }));
    }
}
OrderCancellationGuard.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OrderCancellationGuard, deps: [{ token: OrderCancellationService }, { token: i1.SemanticPathService }, { token: i1$1.Router }], target: i0.ɵɵFactoryTarget.Injectable });
OrderCancellationGuard.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OrderCancellationGuard, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OrderCancellationGuard, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: OrderCancellationService }, { type: i1.SemanticPathService }, { type: i1$1.Router }]; } });

/**
 * @deprecated since 4.2 - use order lib instead
 */
class CancelOrderConfirmationModule {
}
CancelOrderConfirmationModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CancelOrderConfirmationModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
CancelOrderConfirmationModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CancelOrderConfirmationModule, declarations: [CancelOrderConfirmationComponent], imports: [CommonModule, i1$1.RouterModule, ReactiveFormsModule,
        AmendOrderItemsModule,
        AmendOrderActionsModule], exports: [CancelOrderConfirmationComponent] });
CancelOrderConfirmationModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CancelOrderConfirmationModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                CancelOrderConfirmationComponent: {
                    component: CancelOrderConfirmationComponent,
                    guards: [AuthGuard, OrderCancellationGuard],
                    providers: [
                        {
                            provide: OrderAmendService,
                            useExisting: OrderCancellationService,
                        },
                    ],
                },
            },
        }),
    ], imports: [[
            CommonModule,
            RouterModule.forChild([
                {
                    path: null,
                    canActivate: [CmsPageGuard],
                    component: PageLayoutComponent,
                    data: {
                        cxRoute: 'orderCancelConfirmation',
                    },
                },
            ]),
            ReactiveFormsModule,
            AmendOrderItemsModule,
            AmendOrderActionsModule,
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CancelOrderConfirmationModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        RouterModule.forChild([
                            {
                                path: null,
                                canActivate: [CmsPageGuard],
                                component: PageLayoutComponent,
                                data: {
                                    cxRoute: 'orderCancelConfirmation',
                                },
                            },
                        ]),
                        ReactiveFormsModule,
                        AmendOrderItemsModule,
                        AmendOrderActionsModule,
                    ],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                CancelOrderConfirmationComponent: {
                                    component: CancelOrderConfirmationComponent,
                                    guards: [AuthGuard, OrderCancellationGuard],
                                    providers: [
                                        {
                                            provide: OrderAmendService,
                                            useExisting: OrderCancellationService,
                                        },
                                    ],
                                },
                            },
                        }),
                    ],
                    declarations: [CancelOrderConfirmationComponent],
                    exports: [CancelOrderConfirmationComponent],
                }]
        }] });

/**
 * @deprecated since 4.2 - use order lib instead
 */
class CancelOrderComponent {
    constructor(orderAmendService) {
        this.orderAmendService = orderAmendService;
        this.form$ = this.orderAmendService
            .getForm()
            .pipe(tap((form) => (this.orderCode = form.value.orderCode)));
        this.entries$ = this.orderAmendService.getEntries();
    }
}
CancelOrderComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CancelOrderComponent, deps: [{ token: OrderAmendService }], target: i0.ɵɵFactoryTarget.Component });
CancelOrderComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: CancelOrderComponent, selector: "cx-cancel-order", ngImport: i0, template: "<ng-container *ngIf=\"form$ | async as form\">\n  <ng-container *ngTemplateOutlet=\"actions\"></ng-container>\n\n  <cx-amend-order-items *ngIf=\"entries$ | async as entries\" [entries]=\"entries\">\n  </cx-amend-order-items>\n\n  <cx-form-errors\n    aria-live=\"assertive\"\n    aria-atomic=\"true\"\n    [control]=\"form.get('entries')\"\n  ></cx-form-errors>\n\n  <ng-container *ngTemplateOutlet=\"actions\"></ng-container>\n\n  <ng-template #actions>\n    <cx-amend-order-actions\n      *ngIf=\"orderCode\"\n      [orderCode]=\"orderCode\"\n      [amendOrderForm]=\"form\"\n      backRoute=\"orderDetails\"\n      forwardRoute=\"orderCancelConfirmation\"\n    ></cx-amend-order-actions>\n  </ng-template>\n</ng-container>\n", components: [{ type: CancelOrReturnItemsComponent, selector: "cx-amend-order-items", inputs: ["entries", "isConfirmation"] }, { type: FormErrorsComponent, selector: "cx-form-errors", inputs: ["prefix", "translationParams", "control"] }, { type: AmendOrderActionsComponent, selector: "cx-amend-order-actions", inputs: ["orderCode", "amendOrderForm", "backRoute", "forwardRoute"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }], pipes: { "async": i3.AsyncPipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CancelOrderComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-cancel-order',
                    templateUrl: './cancel-order.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: OrderAmendService }]; } });

/**
 * @deprecated since 4.2 - use order lib instead
 */
class CancelOrderModule {
}
CancelOrderModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CancelOrderModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
CancelOrderModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CancelOrderModule, declarations: [CancelOrderComponent], imports: [CommonModule, i1$1.RouterModule, AmendOrderItemsModule,
        AmendOrderActionsModule,
        FormErrorsModule], exports: [CancelOrderComponent] });
CancelOrderModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CancelOrderModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                CancelOrderComponent: {
                    component: CancelOrderComponent,
                    guards: [AuthGuard],
                    providers: [
                        {
                            provide: OrderAmendService,
                            useExisting: OrderCancellationService,
                        },
                    ],
                },
            },
        }),
    ], imports: [[
            CommonModule,
            RouterModule.forChild([
                {
                    path: null,
                    canActivate: [CmsPageGuard],
                    component: PageLayoutComponent,
                    data: {
                        cxRoute: 'orderCancel',
                    },
                },
            ]),
            AmendOrderItemsModule,
            AmendOrderActionsModule,
            FormErrorsModule,
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CancelOrderModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        RouterModule.forChild([
                            {
                                path: null,
                                canActivate: [CmsPageGuard],
                                component: PageLayoutComponent,
                                data: {
                                    cxRoute: 'orderCancel',
                                },
                            },
                        ]),
                        AmendOrderItemsModule,
                        AmendOrderActionsModule,
                        FormErrorsModule,
                    ],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                CancelOrderComponent: {
                                    component: CancelOrderComponent,
                                    guards: [AuthGuard],
                                    providers: [
                                        {
                                            provide: OrderAmendService,
                                            useExisting: OrderCancellationService,
                                        },
                                    ],
                                },
                            },
                        }),
                    ],
                    declarations: [CancelOrderComponent],
                    exports: [CancelOrderComponent],
                }]
        }] });

/**
 * @deprecated since 4.2 - use order lib instead
 */
class OrderCancellationModule {
}
OrderCancellationModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OrderCancellationModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
OrderCancellationModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OrderCancellationModule, imports: [CancelOrderModule, CancelOrderConfirmationModule] });
OrderCancellationModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OrderCancellationModule, imports: [[CancelOrderModule, CancelOrderConfirmationModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OrderCancellationModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CancelOrderModule, CancelOrderConfirmationModule],
                }]
        }] });

/**
 * @deprecated since 4.2 - use order lib instead
 */
class OrderReturnService extends OrderAmendService {
    constructor(orderDetailsService, returnRequestService, routing, globalMessageService) {
        super(orderDetailsService);
        this.orderDetailsService = orderDetailsService;
        this.returnRequestService = returnRequestService;
        this.routing = routing;
        this.globalMessageService = globalMessageService;
        this.amendType = AmendOrderType.RETURN;
    }
    getEntries() {
        return this.getOrder().pipe(filter((order) => !!order.entries), map((order) => order.entries.filter((entry) => entry.entryNumber !== -1 && entry.returnableQuantity > 0)));
    }
    save() {
        const orderCode = this.form.value.orderCode;
        const entries = this.form.value.entries;
        const inputs = Object.keys(entries)
            .filter((entryNumber) => entries[entryNumber] > 0)
            .map((entryNumber) => ({
            orderEntryNumber: Number(entryNumber),
            quantity: entries[entryNumber],
        }));
        this.form.reset();
        this.returnRequestService.createOrderReturnRequest({
            orderCode,
            returnRequestEntryInputs: inputs,
        });
        this.returnRequestService
            .getReturnRequestSuccess()
            .pipe(first(Boolean))
            .subscribe(() => this.afterSave());
    }
    afterSave() {
        this.returnRequestService
            .getOrderReturnRequest()
            .pipe(first((r) => !!r))
            .subscribe((returnRequest) => {
            const rma = returnRequest.rma;
            this.globalMessageService.add({
                key: 'orderDetails.cancellationAndReturn.returnSuccess',
                params: { rma },
            }, GlobalMessageType.MSG_TYPE_CONFIRMATION);
            this.routing.go({
                cxRoute: 'returnRequestDetails',
                params: { rma },
            });
        });
    }
}
OrderReturnService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OrderReturnService, deps: [{ token: OrderDetailsService }, { token: i1.OrderReturnRequestService }, { token: i1.RoutingService }, { token: i1.GlobalMessageService }], target: i0.ɵɵFactoryTarget.Injectable });
OrderReturnService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OrderReturnService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OrderReturnService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: OrderDetailsService }, { type: i1.OrderReturnRequestService }, { type: i1.RoutingService }, { type: i1.GlobalMessageService }]; } });

/**
 * @deprecated since 4.2 - use order lib instead
 */
class OrderReturnGuard {
    constructor(orderAmendService, semanticPathService, router) {
        this.orderAmendService = orderAmendService;
        this.semanticPathService = semanticPathService;
        this.router = router;
    }
    canActivate() {
        return this.orderAmendService.getForm().pipe(map((form) => {
            if (!form.valid) {
                // the order code is not available in the route
                // as long as we're inside a guard, hence we redirect
                // to the common orders page.
                return this.router.parseUrl(this.semanticPathService.get('orders'));
            }
            else {
                return true;
            }
        }));
    }
}
OrderReturnGuard.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OrderReturnGuard, deps: [{ token: OrderReturnService }, { token: i1.SemanticPathService }, { token: i1$1.Router }], target: i0.ɵɵFactoryTarget.Injectable });
OrderReturnGuard.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OrderReturnGuard, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OrderReturnGuard, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: OrderReturnService }, { type: i1.SemanticPathService }, { type: i1$1.Router }]; } });

/**
 * @deprecated since 4.2 - use order lib instead
 */
class ReturnOrderConfirmationComponent {
    constructor(orderAmendService) {
        this.orderAmendService = orderAmendService;
        this.form$ = this.orderAmendService
            .getForm()
            .pipe(tap((form) => (this.orderCode = form.value.orderCode)));
        this.entries$ = this.orderAmendService.getAmendedEntries();
    }
    submit(form) {
        form.disable();
        this.orderAmendService.save();
    }
}
ReturnOrderConfirmationComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ReturnOrderConfirmationComponent, deps: [{ token: OrderAmendService }], target: i0.ɵɵFactoryTarget.Component });
ReturnOrderConfirmationComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: ReturnOrderConfirmationComponent, selector: "cx-return-order-confirmation", ngImport: i0, template: "<form\n  *ngIf=\"form$ | async as form\"\n  [formGroup]=\"form\"\n  (ngSubmit)=\"submit(form)\"\n>\n  <ng-container *ngTemplateOutlet=\"actions\"></ng-container>\n\n  <cx-amend-order-items\n    *ngIf=\"entries$ | async as entries\"\n    [entries]=\"entries\"\n    [isConfirmation]=\"true\"\n  >\n  </cx-amend-order-items>\n\n  <ng-container *ngTemplateOutlet=\"actions\"></ng-container>\n\n  <ng-template #actions>\n    <cx-amend-order-actions\n      *ngIf=\"orderCode\"\n      [orderCode]=\"orderCode\"\n      [amendOrderForm]=\"form\"\n      backRoute=\"orderReturn\"\n    ></cx-amend-order-actions>\n  </ng-template>\n</form>\n", components: [{ type: CancelOrReturnItemsComponent, selector: "cx-amend-order-items", inputs: ["entries", "isConfirmation"] }, { type: AmendOrderActionsComponent, selector: "cx-amend-order-actions", inputs: ["orderCode", "amendOrderForm", "backRoute", "forwardRoute"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3$1.ɵNgNoValidate, selector: "form:not([ngNoForm]):not([ngNativeValidate])" }, { type: i3$1.NgControlStatusGroup, selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { type: i3$1.FormGroupDirective, selector: "[formGroup]", inputs: ["formGroup"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }, { type: i3.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }], pipes: { "async": i3.AsyncPipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ReturnOrderConfirmationComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-return-order-confirmation',
                    templateUrl: './return-order-confirmation.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: OrderAmendService }]; } });

/**
 * @deprecated since 4.2 - use order lib instead
 */
class ReturnOrderConfirmationModule {
}
ReturnOrderConfirmationModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ReturnOrderConfirmationModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ReturnOrderConfirmationModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ReturnOrderConfirmationModule, declarations: [ReturnOrderConfirmationComponent], imports: [CommonModule, i1$1.RouterModule, AmendOrderItemsModule,
        I18nModule,
        ReactiveFormsModule,
        AmendOrderActionsModule], exports: [ReturnOrderConfirmationComponent] });
ReturnOrderConfirmationModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ReturnOrderConfirmationModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                ReturnOrderConfirmationComponent: {
                    component: ReturnOrderConfirmationComponent,
                    guards: [AuthGuard, OrderReturnGuard],
                    providers: [
                        {
                            provide: OrderAmendService,
                            useExisting: OrderReturnService,
                        },
                    ],
                },
            },
        }),
    ], imports: [[
            CommonModule,
            RouterModule.forChild([
                {
                    path: null,
                    canActivate: [CmsPageGuard],
                    component: PageLayoutComponent,
                    data: {
                        cxRoute: 'orderReturnConfirmation',
                    },
                },
            ]),
            AmendOrderItemsModule,
            I18nModule,
            ReactiveFormsModule,
            AmendOrderActionsModule,
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ReturnOrderConfirmationModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        RouterModule.forChild([
                            {
                                path: null,
                                canActivate: [CmsPageGuard],
                                component: PageLayoutComponent,
                                data: {
                                    cxRoute: 'orderReturnConfirmation',
                                },
                            },
                        ]),
                        AmendOrderItemsModule,
                        I18nModule,
                        ReactiveFormsModule,
                        AmendOrderActionsModule,
                    ],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                ReturnOrderConfirmationComponent: {
                                    component: ReturnOrderConfirmationComponent,
                                    guards: [AuthGuard, OrderReturnGuard],
                                    providers: [
                                        {
                                            provide: OrderAmendService,
                                            useExisting: OrderReturnService,
                                        },
                                    ],
                                },
                            },
                        }),
                    ],
                    declarations: [ReturnOrderConfirmationComponent],
                    exports: [ReturnOrderConfirmationComponent],
                }]
        }] });

/**
 * @deprecated since 4.2 - use order lib instead
 */
class ReturnOrderComponent {
    constructor(orderAmendService) {
        this.orderAmendService = orderAmendService;
        this.form$ = this.orderAmendService
            .getForm()
            .pipe(tap((form) => (this.orderCode = form.value.orderCode)));
        this.entries$ = this.orderAmendService.getEntries();
    }
}
ReturnOrderComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ReturnOrderComponent, deps: [{ token: OrderAmendService }], target: i0.ɵɵFactoryTarget.Component });
ReturnOrderComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: ReturnOrderComponent, selector: "cx-return-order", ngImport: i0, template: "<ng-container *ngIf=\"form$ | async as form\">\n  <ng-container *ngTemplateOutlet=\"actions\"></ng-container>\n\n  <cx-amend-order-items *ngIf=\"entries$ | async as entries\" [entries]=\"entries\">\n  </cx-amend-order-items>\n\n  <cx-form-errors\n    aria-live=\"assertive\"\n    aria-atomic=\"true\"\n    [control]=\"form.get('entries')\"\n  ></cx-form-errors>\n\n  <ng-container *ngTemplateOutlet=\"actions\"></ng-container>\n\n  <ng-template #actions>\n    <cx-amend-order-actions\n      *ngIf=\"orderCode\"\n      [orderCode]=\"orderCode\"\n      [amendOrderForm]=\"form\"\n      backRoute=\"orderDetails\"\n      forwardRoute=\"orderReturnConfirmation\"\n    ></cx-amend-order-actions>\n  </ng-template>\n</ng-container>\n", components: [{ type: CancelOrReturnItemsComponent, selector: "cx-amend-order-items", inputs: ["entries", "isConfirmation"] }, { type: FormErrorsComponent, selector: "cx-form-errors", inputs: ["prefix", "translationParams", "control"] }, { type: AmendOrderActionsComponent, selector: "cx-amend-order-actions", inputs: ["orderCode", "amendOrderForm", "backRoute", "forwardRoute"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }], pipes: { "async": i3.AsyncPipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ReturnOrderComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-return-order',
                    templateUrl: './return-order.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: OrderAmendService }]; } });

/**
 * @deprecated since 4.2 - use order lib instead
 */
class ReturnOrderModule {
}
ReturnOrderModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ReturnOrderModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ReturnOrderModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ReturnOrderModule, declarations: [ReturnOrderComponent], imports: [CommonModule, i1$1.RouterModule, AmendOrderItemsModule,
        AmendOrderActionsModule,
        FormErrorsModule], exports: [ReturnOrderComponent] });
ReturnOrderModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ReturnOrderModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                ReturnOrderComponent: {
                    component: ReturnOrderComponent,
                    guards: [AuthGuard],
                    providers: [
                        {
                            provide: OrderAmendService,
                            useExisting: OrderReturnService,
                        },
                    ],
                },
            },
        }),
    ], imports: [[
            CommonModule,
            RouterModule.forChild([
                {
                    path: null,
                    canActivate: [CmsPageGuard],
                    component: PageLayoutComponent,
                    data: {
                        cxRoute: 'orderReturn',
                    },
                },
            ]),
            AmendOrderItemsModule,
            AmendOrderActionsModule,
            FormErrorsModule,
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ReturnOrderModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        RouterModule.forChild([
                            {
                                path: null,
                                canActivate: [CmsPageGuard],
                                component: PageLayoutComponent,
                                data: {
                                    cxRoute: 'orderReturn',
                                },
                            },
                        ]),
                        AmendOrderItemsModule,
                        AmendOrderActionsModule,
                        FormErrorsModule,
                    ],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                ReturnOrderComponent: {
                                    component: ReturnOrderComponent,
                                    guards: [AuthGuard],
                                    providers: [
                                        {
                                            provide: OrderAmendService,
                                            useExisting: OrderReturnService,
                                        },
                                    ],
                                },
                            },
                        }),
                    ],
                    declarations: [ReturnOrderComponent],
                    exports: [ReturnOrderComponent],
                }]
        }] });

/**
 * @deprecated since 4.2 - use order lib instead
 */
class OrderReturnModule {
}
OrderReturnModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OrderReturnModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
OrderReturnModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OrderReturnModule, imports: [ReturnOrderModule, ReturnOrderConfirmationModule] });
OrderReturnModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OrderReturnModule, imports: [[ReturnOrderModule, ReturnOrderConfirmationModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OrderReturnModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [ReturnOrderModule, ReturnOrderConfirmationModule],
                }]
        }] });

/**
 * @deprecated since 4.2 - use order lib instead
 */
class OrderDetailActionsComponent {
    constructor(orderDetailsService) {
        this.orderDetailsService = orderDetailsService;
        this.order$ = this.orderDetailsService.getOrderDetails();
    }
}
OrderDetailActionsComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OrderDetailActionsComponent, deps: [{ token: OrderDetailsService }], target: i0.ɵɵFactoryTarget.Component });
OrderDetailActionsComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: OrderDetailActionsComponent, selector: "cx-order-details-actions", ngImport: i0, template: "<ng-container *ngIf=\"order$ | async as order\">\n  <div class=\"cx-nav row\">\n    <div class=\"col-xs-12 col-md-4 col-lg-3\">\n      <button\n        [routerLink]=\"{ cxRoute: 'orders' } | cxUrl\"\n        class=\"btn btn-block btn-action\"\n      >\n        {{ 'common.back' | cxTranslate }}\n      </button>\n    </div>\n\n    <div class=\"col-xs-12 col-md-4 col-lg-3\">\n      <a\n        *ngIf=\"order.cancellable\"\n        [routerLink]=\"\n          {\n            cxRoute: 'orderCancel',\n            params: order\n          } | cxUrl\n        \"\n        class=\"btn btn-block btn-action\"\n      >\n        {{ 'orderDetails.cancellationAndReturn.cancelAction' | cxTranslate }}\n      </a>\n\n      <a\n        *ngIf=\"order.returnable\"\n        [routerLink]=\"\n          {\n            cxRoute: 'orderReturn',\n            params: order\n          } | cxUrl\n        \"\n        class=\"btn btn-block btn-action\"\n      >\n        {{ 'orderDetails.cancellationAndReturn.returnAction' | cxTranslate }}\n      </a>\n    </div>\n  </div>\n</ng-container>\n", directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i1$1.RouterLink, selector: ":not(a):not(area)[routerLink]", inputs: ["routerLink", "queryParams", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange", "replaceUrl", "state", "relativeTo"] }, { type: i1$1.RouterLinkWithHref, selector: "a[routerLink],area[routerLink]", inputs: ["routerLink", "target", "queryParams", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange", "replaceUrl", "state", "relativeTo"] }], pipes: { "async": i3.AsyncPipe, "cxUrl": i1.UrlPipe, "cxTranslate": i1.TranslatePipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OrderDetailActionsComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-order-details-actions',
                    templateUrl: './order-detail-actions.component.html',
                }]
        }], ctorParameters: function () { return [{ type: OrderDetailsService }]; } });

/**
 * @deprecated since 4.2 - use order lib instead
 */
class TrackingEventsComponent {
    constructor(activeModal, userOrderService) {
        this.activeModal = activeModal;
        this.userOrderService = userOrderService;
    }
    ngOnDestroy() {
        this.userOrderService.clearConsignmentTracking();
    }
}
TrackingEventsComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: TrackingEventsComponent, deps: [{ token: i1$3.NgbActiveModal }, { token: i1.UserOrderService }], target: i0.ɵɵFactoryTarget.Component });
TrackingEventsComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: TrackingEventsComponent, selector: "cx-tracking-events", ngImport: i0, template: "<div class=\"cx-consignment-tracking-dialog\">\n  <!-- Modal Header -->\n  <ng-container *ngIf=\"tracking$ | async as consignmentTracking; else loading\">\n    <div class=\"header modal-header\">\n      <div class=\"title modal-title\">\n        {{ 'orderDetails.consignmentTracking.dialog.header' | cxTranslate }}\n      </div>\n      <button\n        type=\"button\"\n        class=\"close\"\n        [attr.aria-label]=\"'common.close' | cxTranslate\"\n        (click)=\"activeModal.dismiss('Cross click')\"\n      >\n        <span aria-hidden=\"true\">&times;</span>\n      </button>\n    </div>\n    <!-- Modal Body -->\n    <!-- shipment header -->\n    <ng-container\n      *ngIf=\"\n        consignmentTracking?.carrierDetails && consignmentTracking?.trackingID;\n        else noTracking\n      \"\n    >\n      <div class=\"shipment-heading\">\n        <div class=\"row\">\n          <div class=\"col-sm-12 col-md-6\">\n            <div class=\"shipment-title\">\n              {{\n                'orderDetails.consignmentTracking.dialog.shipped' | cxTranslate\n              }}\n            </div>\n            <div class=\"shipment-content\">\n              {{ shipDate | cxDate: 'medium' }}\n            </div>\n          </div>\n          <div class=\"col-sm-12 col-md-6\">\n            <div class=\"shipment-title\">\n              {{\n                'orderDetails.consignmentTracking.dialog.estimate' | cxTranslate\n              }}\n            </div>\n            <div class=\"shipment-content\">\n              {{ consignmentTracking?.targetArrivalDate | cxDate: 'medium' }}\n            </div>\n          </div>\n        </div>\n\n        <div class=\"row\">\n          <div class=\"col-sm-12 col-md-6\">\n            <div class=\"shipment-title\">\n              {{\n                'orderDetails.consignmentTracking.dialog.carrier' | cxTranslate\n              }}\n            </div>\n            <div class=\"shipment-content\">\n              {{ consignmentTracking?.carrierDetails?.name }}\n            </div>\n          </div>\n          <div class=\"col-sm-12 col-md-6\">\n            <div class=\"shipment-title\">\n              {{\n                'orderDetails.consignmentTracking.dialog.trackingId'\n                  | cxTranslate\n              }}\n            </div>\n            <div class=\"shipment-content\">\n              <ng-container *ngIf=\"consignmentTracking?.trackingUrl\">\n                <a target=\"_blank\" [href]=\"consignmentTracking.trackingUrl\">{{\n                  consignmentTracking?.trackingID\n                }}</a>\n              </ng-container>\n              <ng-container *ngIf=\"!consignmentTracking?.trackingUrl\">\n                <label>\n                  {{ consignmentTracking?.trackingID }}\n                </label>\n              </ng-container>\n            </div>\n          </div>\n        </div>\n      </div>\n    </ng-container>\n\n    <!-- tracking events -->\n    <div class=\"events modal-body\">\n      <ng-container\n        *ngFor=\"let consignmentEvent of consignmentTracking.trackingEvents\"\n      >\n        <div class=\"event-body\">\n          <div class=\"event-content\">\n            {{ consignmentEvent.eventDate | cxDate: 'medium' }}\n          </div>\n          <div class=\"event-title\">\n            {{ consignmentEvent.referenceCode }}\n          </div>\n          <div class=\"event-content\">{{ consignmentEvent.detail }}</div>\n          <div class=\"event-city\">\n            location: {{ consignmentEvent.location }}\n          </div>\n        </div>\n      </ng-container>\n    </div>\n  </ng-container>\n\n  <ng-template #noTracking>\n    <div class=\"no-tracking-heading\">\n      <div class=\"shipment-content\">\n        {{ 'orderDetails.consignmentTracking.dialog.noTracking' | cxTranslate }}\n      </div>\n    </div>\n  </ng-template>\n\n  <ng-template #loading>\n    <div class=\"tracking-loading\">\n      <div class=\"header modal-header\">\n        <div class=\"title modal-title\">\n          {{\n            'orderDetails.consignmentTracking.dialog.loadingHeader'\n              | cxTranslate\n          }}\n        </div>\n        <button\n          type=\"button\"\n          class=\"close btn-dismiss\"\n          [attr.aria-label]=\"'common.close' | cxTranslate\"\n          (click)=\"activeModal.dismiss('Cross click')\"\n        >\n          <span aria-hidden=\"true\">&times;</span>\n        </button>\n      </div>\n      <!-- Modal Body -->\n      <div class=\"body modal-body\">\n        <div class=\"row\">\n          <div class=\"col-sm-12\">\n            <cx-spinner></cx-spinner>\n          </div>\n        </div>\n      </div>\n    </div>\n  </ng-template>\n</div>\n", components: [{ type: SpinnerComponent, selector: "cx-spinner" }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], pipes: { "async": i3.AsyncPipe, "cxTranslate": i1.TranslatePipe, "cxDate": i1.CxDatePipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: TrackingEventsComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-tracking-events',
                    templateUrl: './tracking-events.component.html',
                }]
        }], ctorParameters: function () { return [{ type: i1$3.NgbActiveModal }, { type: i1.UserOrderService }]; } });

/**
 * @deprecated since 4.2 - use order lib instead
 */
class ConsignmentTrackingComponent {
    constructor(userOrderService, modalService) {
        this.userOrderService = userOrderService;
        this.modalService = modalService;
        this.consignmentStatus = [
            'SHIPPED',
            'IN_TRANSIT',
            'DELIVERY_COMPLETED',
            'DELIVERY_REJECTED',
            'DELIVERING',
        ];
    }
    ngOnInit() {
        this.consignmentTracking$ = this.userOrderService.getConsignmentTracking();
    }
    openTrackingDialog(consignment) {
        this.userOrderService.loadConsignmentTracking(this.orderCode, consignment.code);
        let modalInstance;
        this.modalRef = this.modalService.open(TrackingEventsComponent, {
            centered: true,
            size: 'lg',
        });
        modalInstance = this.modalRef.componentInstance;
        modalInstance.tracking$ = this.consignmentTracking$;
        modalInstance.shipDate = consignment.statusDate;
        modalInstance.consignmentCode = consignment.code;
    }
    ngOnDestroy() {
        this.userOrderService.clearConsignmentTracking();
    }
}
ConsignmentTrackingComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ConsignmentTrackingComponent, deps: [{ token: i1.UserOrderService }, { token: ModalService }], target: i0.ɵɵFactoryTarget.Component });
ConsignmentTrackingComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: ConsignmentTrackingComponent, selector: "cx-consignment-tracking", inputs: { consignment: "consignment", orderCode: "orderCode" }, ngImport: i0, template: "<ng-container *ngIf=\"consignment && consignment.status\">\n  <div *ngIf=\"consignmentStatus.includes(consignment.status)\">\n    <button\n      (click)=\"openTrackingDialog(consignment)\"\n      class=\"btn btn-action btn-track\"\n      type=\"button\"\n    >\n      {{ 'orderDetails.consignmentTracking.action' | cxTranslate }}\n    </button>\n  </div>\n</ng-container>\n", directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "cxTranslate": i1.TranslatePipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ConsignmentTrackingComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-consignment-tracking',
                    templateUrl: './consignment-tracking.component.html',
                }]
        }], ctorParameters: function () { return [{ type: i1.UserOrderService }, { type: ModalService }]; }, propDecorators: { consignment: [{
                type: Input
            }], orderCode: [{
                type: Input
            }] } });

/**
 * @deprecated since 4.2 - use order lib instead
 */
class OrderConsignedEntriesComponent {
    constructor() {
        this.promotionLocation = PromotionLocation.Order;
    }
    getConsignmentProducts(consignment) {
        const products = [];
        consignment.entries.forEach((element) => {
            products.push(element.orderEntry);
        });
        return products;
    }
}
OrderConsignedEntriesComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OrderConsignedEntriesComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
OrderConsignedEntriesComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: OrderConsignedEntriesComponent, selector: "cx-order-consigned-entries", inputs: { consignments: "consignments", order: "order" }, ngImport: i0, template: "<div *ngFor=\"let consignment of consignments\" class=\"cx-list row\">\n  <div class=\"cx-list-header col-12\">\n    <div class=\"cx-list-status\">\n      <span *ngIf=\"consignment\">\n        {{ 'orderDetails.deliveryStatus_' + consignment?.status | cxTranslate }}\n      </span>\n    </div>\n    <div *ngIf=\"consignment?.statusDate\" class=\"cx-list-date\">\n      <div>{{ consignment?.statusDate | cxDate }}</div>\n    </div>\n\n    <cx-consignment-tracking\n      [orderCode]=\"order.code\"\n      [consignment]=\"consignment\"\n      *cxFeature=\"'consignmentTracking'\"\n    >\n    </cx-consignment-tracking>\n  </div>\n  <div class=\"cx-list-item col-12\">\n    <cx-cart-item-list\n      [items]=\"consignment.entries\"\n      [readonly]=\"true\"\n      [promotionLocation]=\"promotionLocation\"\n    ></cx-cart-item-list>\n  </div>\n</div>\n", components: [{ type: ConsignmentTrackingComponent, selector: "cx-consignment-tracking", inputs: ["consignment", "orderCode"] }, { type: CartItemListComponent, selector: "cx-cart-item-list", inputs: ["readonly", "hasHeader", "options", "cartId", "items", "promotionLocation", "cartIsLoading"] }], directives: [{ type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i1.FeatureDirective, selector: "[cxFeature]", inputs: ["cxFeature"] }], pipes: { "cxTranslate": i1.TranslatePipe, "cxDate": i1.CxDatePipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OrderConsignedEntriesComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-order-consigned-entries',
                    templateUrl: './order-consigned-entries.component.html',
                }]
        }], propDecorators: { consignments: [{
                type: Input
            }], order: [{
                type: Input
            }] } });

const completedValues = ['DELIVERY_COMPLETED', 'PICKUP_COMPLETE'];
const cancelledValues = ['CANCELLED'];

/**
 * @deprecated since 4.2 - use order lib instead
 */
class OrderDetailItemsComponent {
    constructor(orderDetailsService) {
        this.orderDetailsService = orderDetailsService;
        this.promotionLocation = PromotionLocation.Order;
        this.order$ = this.orderDetailsService.getOrderDetails();
    }
    ngOnInit() {
        this.others$ = this.getOtherStatus(...completedValues, ...cancelledValues);
        this.completed$ = this.getExactStatus(completedValues);
        this.cancel$ = this.getExactStatus(cancelledValues);
    }
    getExactStatus(consignmentStatus) {
        return this.order$.pipe(map((order) => {
            if (Boolean(order.consignments)) {
                return order.consignments.filter((consignment) => consignmentStatus.includes(consignment.status));
            }
        }));
    }
    getOtherStatus(...consignmentStatus) {
        return this.order$.pipe(map((order) => {
            if (Boolean(order.consignments)) {
                return order.consignments.filter((consignment) => !consignmentStatus.includes(consignment.status));
            }
        }));
    }
}
OrderDetailItemsComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OrderDetailItemsComponent, deps: [{ token: OrderDetailsService }], target: i0.ɵɵFactoryTarget.Component });
OrderDetailItemsComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: OrderDetailItemsComponent, selector: "cx-order-details-items", ngImport: i0, template: "<ng-container *ngIf=\"order$ | async as order\">\n  <ng-container\n    *ngIf=\"\n      order.consignments?.length ||\n      order.unconsignedEntries?.length ||\n      order.replenishmentOrderCode\n    \"\n  >\n    <cx-promotions\n      [promotions]=\"order.appliedOrderPromotions || []\"\n    ></cx-promotions>\n  </ng-container>\n\n  <!-- consigned entries -->\n  <ng-container *ngIf=\"order.consignments?.length\">\n    <cx-order-consigned-entries\n      *ngIf=\"others$ | async as others\"\n      [order]=\"order\"\n      [consignments]=\"others\"\n    ></cx-order-consigned-entries>\n\n    <cx-order-consigned-entries\n      *ngIf=\"completed$ | async as completed\"\n      [order]=\"order\"\n      [consignments]=\"completed\"\n    ></cx-order-consigned-entries>\n\n    <cx-order-consigned-entries\n      *ngIf=\"cancel$ | async as cancel\"\n      [order]=\"order\"\n      [consignments]=\"cancel\"\n    ></cx-order-consigned-entries>\n  </ng-container>\n\n  <!-- unconsigned entries OR any entries -->\n  <ng-container\n    *ngIf=\"\n      order?.unconsignedEntries?.length ||\n      (order?.entries && order?.replenishmentOrderCode)\n    \"\n  >\n    <div class=\"cx-list row\">\n      <div *ngIf=\"order?.statusDisplay\" class=\"cx-list-header col-12\">\n        <div class=\"cx-list-status\">\n          {{\n            'orderDetails.statusDisplay_' + order?.statusDisplay | cxTranslate\n          }}\n        </div>\n      </div>\n      <div class=\"cx-list-item col-12\">\n        <cx-cart-item-list\n          [items]=\"\n            order?.unconsignedEntries ? order.unconsignedEntries : order.entries\n          \"\n          [readonly]=\"true\"\n          [promotionLocation]=\"promotionLocation\"\n        ></cx-cart-item-list>\n      </div>\n    </div>\n  </ng-container>\n</ng-container>\n", components: [{ type: PromotionsComponent, selector: "cx-promotions", inputs: ["promotions"] }, { type: OrderConsignedEntriesComponent, selector: "cx-order-consigned-entries", inputs: ["consignments", "order"] }, { type: CartItemListComponent, selector: "cx-cart-item-list", inputs: ["readonly", "hasHeader", "options", "cartId", "items", "promotionLocation", "cartIsLoading"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "async": i3.AsyncPipe, "cxTranslate": i1.TranslatePipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OrderDetailItemsComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-order-details-items',
                    templateUrl: './order-detail-items.component.html',
                }]
        }], ctorParameters: function () { return [{ type: OrderDetailsService }]; } });

/**
 * @deprecated since 4.2 - use order lib instead
 */
class OrderDetailShippingComponent {
    constructor(orderDetailsService) {
        this.orderDetailsService = orderDetailsService;
    }
    ngOnInit() {
        this.order$ = this.orderDetailsService.getOrderDetails();
    }
}
OrderDetailShippingComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OrderDetailShippingComponent, deps: [{ token: OrderDetailsService }], target: i0.ɵɵFactoryTarget.Component });
OrderDetailShippingComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: OrderDetailShippingComponent, selector: "cx-order-details-shipping", ngImport: i0, template: "<ng-container *ngIf=\"order$ | async as order\">\n  <cx-order-overview [order]=\"order\"></cx-order-overview>\n</ng-container>\n", components: [{ type: OrderOverviewComponent, selector: "cx-order-overview", inputs: ["order"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "async": i3.AsyncPipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OrderDetailShippingComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-order-details-shipping',
                    templateUrl: './order-detail-shipping.component.html',
                }]
        }], ctorParameters: function () { return [{ type: OrderDetailsService }]; } });

/**
 * @deprecated since 4.2 - use order lib instead
 */
class OrderDetailTotalsComponent {
    constructor(orderDetailsService) {
        this.orderDetailsService = orderDetailsService;
    }
    ngOnInit() {
        this.order$ = this.orderDetailsService.getOrderDetails();
    }
}
OrderDetailTotalsComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OrderDetailTotalsComponent, deps: [{ token: OrderDetailsService }], target: i0.ɵɵFactoryTarget.Component });
OrderDetailTotalsComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: OrderDetailTotalsComponent, selector: "cx-order-details-totals", ngImport: i0, template: "<ng-container *ngIf=\"order$ | async as order\">\n  <div class=\"row justify-content-end\">\n    <div class=\"cx-summary col-sm-12 col-md-6 col-lg-5 col-xl-4\">\n      <cx-order-summary [cart]=\"order\"></cx-order-summary>\n    </div>\n  </div>\n</ng-container>\n", components: [{ type: OrderSummaryComponent, selector: "cx-order-summary", inputs: ["cart"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "async": i3.AsyncPipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OrderDetailTotalsComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-order-details-totals',
                    templateUrl: './order-detail-totals.component.html',
                }]
        }], ctorParameters: function () { return [{ type: OrderDetailsService }]; } });

const moduleComponents$1 = [
    OrderDetailActionsComponent,
    OrderDetailItemsComponent,
    OrderDetailTotalsComponent,
    OrderDetailShippingComponent,
    TrackingEventsComponent,
    ConsignmentTrackingComponent,
    OrderConsignedEntriesComponent,
];
/**
 * @deprecated since 4.2 - use order lib instead
 */
class OrderDetailsModule {
}
OrderDetailsModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OrderDetailsModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
OrderDetailsModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OrderDetailsModule, declarations: [OrderDetailActionsComponent,
        OrderDetailItemsComponent,
        OrderDetailTotalsComponent,
        OrderDetailShippingComponent,
        TrackingEventsComponent,
        ConsignmentTrackingComponent,
        OrderConsignedEntriesComponent], imports: [CartSharedModule,
        CardModule,
        CommonModule,
        I18nModule,
        FeaturesConfigModule,
        PromotionsModule,
        OrderOverviewModule,
        UrlModule,
        SpinnerModule, i1$1.RouterModule], exports: [OrderDetailActionsComponent,
        OrderDetailItemsComponent,
        OrderDetailTotalsComponent,
        OrderDetailShippingComponent,
        TrackingEventsComponent,
        ConsignmentTrackingComponent,
        OrderConsignedEntriesComponent] });
OrderDetailsModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OrderDetailsModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                AccountOrderDetailsActionsComponent: {
                    component: OrderDetailActionsComponent,
                },
                AccountOrderDetailsItemsComponent: {
                    component: OrderDetailItemsComponent,
                },
                AccountOrderDetailsTotalsComponent: {
                    component: OrderDetailTotalsComponent,
                },
                AccountOrderDetailsShippingComponent: {
                    component: OrderDetailShippingComponent,
                },
            },
            features: {
                consignmentTracking: '1.2',
            },
        }),
        OrderDetailsService,
    ], imports: [[
            CartSharedModule,
            CardModule,
            CommonModule,
            I18nModule,
            FeaturesConfigModule,
            PromotionsModule,
            OrderOverviewModule,
            UrlModule,
            SpinnerModule,
            RouterModule.forChild([
                {
                    path: null,
                    canActivate: [AuthGuard, CmsPageGuard],
                    component: PageLayoutComponent,
                    data: { pageLabel: 'order', cxRoute: 'orderGuest' },
                },
                {
                    path: null,
                    canActivate: [AuthGuard, CmsPageGuard],
                    component: PageLayoutComponent,
                    data: { cxRoute: 'orderDetails' },
                },
            ]),
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OrderDetailsModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CartSharedModule,
                        CardModule,
                        CommonModule,
                        I18nModule,
                        FeaturesConfigModule,
                        PromotionsModule,
                        OrderOverviewModule,
                        UrlModule,
                        SpinnerModule,
                        RouterModule.forChild([
                            {
                                path: null,
                                canActivate: [AuthGuard, CmsPageGuard],
                                component: PageLayoutComponent,
                                data: { pageLabel: 'order', cxRoute: 'orderGuest' },
                            },
                            {
                                path: null,
                                canActivate: [AuthGuard, CmsPageGuard],
                                component: PageLayoutComponent,
                                data: { cxRoute: 'orderDetails' },
                            },
                        ]),
                    ],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                AccountOrderDetailsActionsComponent: {
                                    component: OrderDetailActionsComponent,
                                },
                                AccountOrderDetailsItemsComponent: {
                                    component: OrderDetailItemsComponent,
                                },
                                AccountOrderDetailsTotalsComponent: {
                                    component: OrderDetailTotalsComponent,
                                },
                                AccountOrderDetailsShippingComponent: {
                                    component: OrderDetailShippingComponent,
                                },
                            },
                            features: {
                                consignmentTracking: '1.2',
                            },
                        }),
                        OrderDetailsService,
                    ],
                    declarations: [...moduleComponents$1],
                    exports: [...moduleComponents$1],
                }]
        }] });

/**
 * @deprecated since 4.2 - use order lib instead
 */
class OrderHistoryComponent {
    constructor(routing, userOrderService, translation, userReplenishmentOrderService) {
        this.routing = routing;
        this.userOrderService = userOrderService;
        this.translation = translation;
        this.userReplenishmentOrderService = userReplenishmentOrderService;
        this.PAGE_SIZE = 5;
        this.orders$ = this.userOrderService
            .getOrderHistoryList(this.PAGE_SIZE)
            .pipe(tap((orders) => {
            if (orders.pagination) {
                this.sortType = orders.pagination.sort;
            }
        }));
        this.hasReplenishmentOrder$ = this.userReplenishmentOrderService
            .getReplenishmentOrderDetails()
            .pipe(map((order) => order && Object.keys(order).length !== 0));
        this.isLoaded$ = this.userOrderService.getOrderHistoryListLoaded();
        /**
         * When "Order Return" feature is enabled, this component becomes one tab in
         * TabParagraphContainerComponent. This can be read from TabParagraphContainer.
         */
        this.tabTitleParam$ = this.orders$.pipe(map((order) => { var _a; return (_a = order.pagination) === null || _a === void 0 ? void 0 : _a.totalResults; }), filter(isNotUndefined), take(1));
    }
    ngOnDestroy() {
        this.userOrderService.clearOrderList();
    }
    changeSortCode(sortCode) {
        const event = {
            sortCode,
            currentPage: 0,
        };
        this.sortType = sortCode;
        this.fetchOrders(event);
    }
    pageChange(page) {
        const event = {
            sortCode: this.sortType,
            currentPage: page,
        };
        this.fetchOrders(event);
    }
    goToOrderDetail(order) {
        this.routing.go({
            cxRoute: 'orderDetails',
            params: order,
        });
    }
    getSortLabels() {
        return combineLatest([
            this.translation.translate('sorting.date'),
            this.translation.translate('sorting.orderNumber'),
        ]).pipe(map(([textByDate, textByOrderNumber]) => {
            return {
                byDate: textByDate,
                byOrderNumber: textByOrderNumber,
            };
        }));
    }
    fetchOrders(event) {
        this.userOrderService.loadOrderList(this.PAGE_SIZE, event.currentPage, event.sortCode);
    }
}
OrderHistoryComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OrderHistoryComponent, deps: [{ token: i1.RoutingService }, { token: i1.UserOrderService }, { token: i1.TranslationService }, { token: i1.UserReplenishmentOrderService }], target: i0.ɵɵFactoryTarget.Component });
OrderHistoryComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: OrderHistoryComponent, selector: "cx-order-history", ngImport: i0, template: "<ng-container\n  *ngIf=\"{\n    orderHistory: orders$ | async,\n    replenishmentOrder: hasReplenishmentOrder$ | async\n  } as type\"\n>\n  <ng-container *ngIf=\"type.orderHistory\">\n    <div [ngClass]=\"type.replenishmentOrder ? '' : 'container'\">\n      <!-- HEADER -->\n      <div\n        [ngClass]=\"\n          type.replenishmentOrder\n            ? 'cx-replenishment-details-order-history-header'\n            : 'cx-order-history-header'\n        \"\n      >\n        <h4 *ngIf=\"type.replenishmentOrder\">\n          {{ 'orderHistory.replenishmentHistory' | cxTranslate }}\n        </h4>\n        <h3 *ngIf=\"!type.replenishmentOrder\">\n          {{ 'orderHistory.orderHistory' | cxTranslate }}\n        </h3>\n      </div>\n\n      <!-- BODY -->\n      <div class=\"cx-order-history-body\">\n        <ng-container\n          *ngIf=\"type.orderHistory.pagination.totalResults > 0; else noOrder\"\n        >\n          <!-- Select Form and Pagination Top -->\n          <div class=\"cx-order-history-sort top row\">\n            <label\n              class=\"\n                cx-order-history-form-group\n                form-group\n                col-sm-12 col-md-4 col-lg-4\n              \"\n              ><span>\n                {{ 'orderHistory.sortBy' | cxTranslate }}\n              </span>\n              <cx-sorting\n                [sortOptions]=\"type.orderHistory.sorts\"\n                [sortLabels]=\"getSortLabels() | async\"\n                (sortListEvent)=\"changeSortCode($event)\"\n                [selectedOption]=\"type.orderHistory.pagination.sort\"\n                placeholder=\"{{ 'orderHistory.sortBy' | cxTranslate }}\"\n              ></cx-sorting>\n            </label>\n            <div\n              *ngIf=\"type.orderHistory.pagination.totalPages > 1\"\n              class=\"cx-order-history-pagination\"\n            >\n              <cx-pagination\n                [pagination]=\"type.orderHistory.pagination\"\n                (viewPageEvent)=\"pageChange($event)\"\n              ></cx-pagination>\n            </div>\n          </div>\n          <!-- TABLE -->\n          <table class=\"table cx-order-history-table\">\n            <thead class=\"cx-order-history-thead-mobile\">\n              <th scope=\"col\">\n                {{ 'orderHistory.orderId' | cxTranslate }}\n              </th>\n              <th scope=\"col\">{{ 'orderHistory.date' | cxTranslate }}</th>\n              <th scope=\"col\">\n                {{ 'orderHistory.status' | cxTranslate }}\n              </th>\n              <th scope=\"col\">{{ 'orderHistory.total' | cxTranslate }}</th>\n            </thead>\n            <tbody>\n              <tr\n                *ngFor=\"let order of type.orderHistory.orders\"\n                (click)=\"goToOrderDetail(order)\"\n              >\n                <td class=\"cx-order-history-code\">\n                  <div class=\"d-md-none cx-order-history-label\">\n                    {{ 'orderHistory.orderId' | cxTranslate }}\n                  </div>\n                  <a\n                    [routerLink]=\"\n                      {\n                        cxRoute: 'orderDetails',\n                        params: order\n                      } | cxUrl\n                    \"\n                    class=\"cx-order-history-value\"\n                  >\n                    {{ order?.code }}</a\n                  >\n                </td>\n                <td class=\"cx-order-history-placed\">\n                  <div class=\"d-md-none cx-order-history-label\">\n                    {{ 'orderHistory.date' | cxTranslate }}\n                  </div>\n                  <a\n                    [routerLink]=\"\n                      {\n                        cxRoute: 'orderDetails',\n                        params: order\n                      } | cxUrl\n                    \"\n                    class=\"cx-order-history-value\"\n                    >{{ order?.placed | cxDate: 'longDate' }}</a\n                  >\n                </td>\n                <td class=\"cx-order-history-status\">\n                  <div class=\"d-md-none cx-order-history-label\">\n                    {{ 'orderHistory.status' | cxTranslate }}\n                  </div>\n                  <a\n                    [routerLink]=\"\n                      {\n                        cxRoute: 'orderDetails',\n                        params: order\n                      } | cxUrl\n                    \"\n                    class=\"cx-order-history-value\"\n                  >\n                    {{\n                      'orderDetails.statusDisplay_' + order?.statusDisplay\n                        | cxTranslate\n                    }}</a\n                  >\n                </td>\n                <td class=\"cx-order-history-total\">\n                  <div class=\"d-md-none cx-order-history-label\">\n                    {{ 'orderHistory.total' | cxTranslate }}\n                  </div>\n                  <a\n                    [routerLink]=\"\n                      {\n                        cxRoute: 'orderDetails',\n                        params: order\n                      } | cxUrl\n                    \"\n                    class=\"cx-order-history-value\"\n                  >\n                    {{ order?.total.formattedValue }}</a\n                  >\n                </td>\n              </tr>\n            </tbody>\n          </table>\n          <!-- Select Form and Pagination Bottom -->\n          <div class=\"cx-order-history-sort bottom row\">\n            <div\n              *ngIf=\"type.orderHistory.pagination.totalPages > 1\"\n              class=\"cx-order-history-pagination\"\n            >\n              <cx-pagination\n                [pagination]=\"type.orderHistory.pagination\"\n                (viewPageEvent)=\"pageChange($event)\"\n              ></cx-pagination>\n            </div>\n          </div>\n        </ng-container>\n\n        <!-- NO ORDER CONTAINER -->\n        <ng-template #noOrder>\n          <div\n            *ngIf=\"isLoaded$ | async\"\n            [ngClass]=\"\n              type.replenishmentOrder\n                ? 'cx-replenishment-details-order-history-no-order row'\n                : 'cx-order-history-no-order row'\n            \"\n          >\n            <div\n              [ngClass]=\"\n                type.replenishmentOrder ? '' : 'col-sm-12 col-md-6 col-lg-4'\n              \"\n            >\n              <ng-container *ngIf=\"type.replenishmentOrder; else otherOrder\">\n                <div>{{ 'orderHistory.notFound' | cxTranslate }}</div>\n              </ng-container>\n\n              <ng-template #otherOrder>\n                <div>{{ 'orderHistory.noOrders' | cxTranslate }}</div>\n                <a\n                  [routerLink]=\"{ cxRoute: 'home' } | cxUrl\"\n                  routerLinkActive=\"active\"\n                  class=\"btn btn-primary btn-block\"\n                  >{{ 'orderHistory.startShopping' | cxTranslate }}</a\n                >\n              </ng-template>\n            </div>\n          </div>\n        </ng-template>\n      </div>\n    </div>\n  </ng-container>\n</ng-container>\n", components: [{ type: SortingComponent, selector: "cx-sorting", inputs: ["sortOptions", "selectedOption", "placeholder", "sortLabels"], outputs: ["sortListEvent"] }, { type: PaginationComponent, selector: "cx-pagination", inputs: ["pageRoute", "queryParam", "defaultPage", "pagination"], outputs: ["viewPageEvent"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i1$1.RouterLinkWithHref, selector: "a[routerLink],area[routerLink]", inputs: ["routerLink", "target", "queryParams", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange", "replaceUrl", "state", "relativeTo"] }, { type: i1$1.RouterLinkActive, selector: "[routerLinkActive]", inputs: ["routerLinkActiveOptions", "routerLinkActive"], exportAs: ["routerLinkActive"] }], pipes: { "async": i3.AsyncPipe, "cxTranslate": i1.TranslatePipe, "cxUrl": i1.UrlPipe, "cxDate": i1.CxDatePipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OrderHistoryComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-order-history',
                    templateUrl: './order-history.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: i1.RoutingService }, { type: i1.UserOrderService }, { type: i1.TranslationService }, { type: i1.UserReplenishmentOrderService }]; } });

/**
 * @deprecated since 4.2 - use order lib instead
 */
class OrderHistoryModule {
}
OrderHistoryModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OrderHistoryModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
OrderHistoryModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OrderHistoryModule, declarations: [OrderHistoryComponent], imports: [CommonModule, i1$1.RouterModule, RouterModule,
        FormsModule,
        NgSelectModule,
        ListNavigationModule,
        UrlModule,
        I18nModule], exports: [OrderHistoryComponent] });
OrderHistoryModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OrderHistoryModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                AccountOrderHistoryComponent: {
                    component: OrderHistoryComponent,
                    guards: [AuthGuard],
                },
            },
        }),
    ], imports: [[
            CommonModule,
            RouterModule.forChild([
                {
                    path: null,
                    canActivate: [AuthGuard, CmsPageGuard],
                    component: PageLayoutComponent,
                    data: { cxRoute: 'orders' },
                },
            ]),
            RouterModule,
            FormsModule,
            NgSelectModule,
            ListNavigationModule,
            UrlModule,
            I18nModule,
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OrderHistoryModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        RouterModule.forChild([
                            {
                                path: null,
                                canActivate: [AuthGuard, CmsPageGuard],
                                component: PageLayoutComponent,
                                data: { cxRoute: 'orders' },
                            },
                        ]),
                        RouterModule,
                        FormsModule,
                        NgSelectModule,
                        ListNavigationModule,
                        UrlModule,
                        I18nModule,
                    ],
                    declarations: [OrderHistoryComponent],
                    exports: [OrderHistoryComponent],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                AccountOrderHistoryComponent: {
                                    component: OrderHistoryComponent,
                                    guards: [AuthGuard],
                                },
                            },
                        }),
                    ],
                }]
        }] });

/**
 * @deprecated since 4.2 - use order lib instead
 */
const defaultReplenishmentOrderCancellationLayoutConfig = {
    launch: {
        REPLENISHMENT_ORDER: {
            inline: true,
            component: ReplenishmentOrderCancellationDialogComponent,
            dialogType: DIALOG_TYPE.DIALOG,
        },
    },
};

/**
 * @deprecated since 4.2 - use order lib instead
 */
class ReplenishmentOrderCancellationComponent {
    constructor(userReplenishmentOrderService, vcr, launchDialogService) {
        this.userReplenishmentOrderService = userReplenishmentOrderService;
        this.vcr = vcr;
        this.launchDialogService = launchDialogService;
        this.subscription = new Subscription();
        this.replenishmentOrder$ = this.userReplenishmentOrderService.getReplenishmentOrderDetails();
    }
    openDialog() {
        const dialog = this.launchDialogService.openDialog("REPLENISHMENT_ORDER" /* REPLENISHMENT_ORDER */, this.element, this.vcr);
        if (dialog) {
            this.subscription.add(dialog.pipe(take(1)).subscribe());
        }
    }
    ngOnDestroy() {
        this.subscription.unsubscribe();
        this.userReplenishmentOrderService.clearReplenishmentOrderDetails();
    }
}
ReplenishmentOrderCancellationComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ReplenishmentOrderCancellationComponent, deps: [{ token: i1.UserReplenishmentOrderService }, { token: i0.ViewContainerRef }, { token: LaunchDialogService }], target: i0.ɵɵFactoryTarget.Component });
ReplenishmentOrderCancellationComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: ReplenishmentOrderCancellationComponent, selector: "cx-replenishment-order-cancellation", viewQueries: [{ propertyName: "element", first: true, predicate: ["element"], descendants: true }], ngImport: i0, template: "<div class=\"cx-cancel-replenishment-btns row\">\n  <div class=\"col-xs-12 col-md-5 col-lg-4\">\n    <a\n      class=\"btn btn-block btn-action\"\n      [routerLink]=\"\n        {\n          cxRoute: 'replenishmentOrders'\n        } | cxUrl\n      \"\n    >\n      {{ 'common.back' | cxTranslate }}\n    </a>\n  </div>\n  <div\n    *ngIf=\"(replenishmentOrder$ | async).active\"\n    class=\"col-xs-12 col-md-5 col-lg-4\"\n  >\n    <button #element class=\"btn btn-block btn-action\" (click)=\"openDialog()\">\n      {{ 'orderDetails.cancelReplenishment.title' | cxTranslate }}\n    </button>\n  </div>\n</div>\n", directives: [{ type: i1$1.RouterLinkWithHref, selector: "a[routerLink],area[routerLink]", inputs: ["routerLink", "target", "queryParams", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange", "replaceUrl", "state", "relativeTo"] }, { type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "cxUrl": i1.UrlPipe, "cxTranslate": i1.TranslatePipe, "async": i3.AsyncPipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ReplenishmentOrderCancellationComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-replenishment-order-cancellation',
                    templateUrl: './replenishment-order-cancellation.component.html',
                }]
        }], ctorParameters: function () { return [{ type: i1.UserReplenishmentOrderService }, { type: i0.ViewContainerRef }, { type: LaunchDialogService }]; }, propDecorators: { element: [{
                type: ViewChild,
                args: ['element']
            }] } });

/**
 * @deprecated since 4.2 - use order lib instead
 */
class ReplenishmentOrderDetailsService {
    constructor(routingService, userReplenishmentOrderService) {
        this.routingService = routingService;
        this.userReplenishmentOrderService = userReplenishmentOrderService;
        this.replenishmentOrderCode$ = this.routingService.getRouterState().pipe(map((routingData) => routingData.state.params.replenishmentOrderCode), distinctUntilChanged());
        this.replenishmentOrderLoad$ = this.replenishmentOrderCode$.pipe(tap((replenishmentOrderCode) => {
            if (Boolean(replenishmentOrderCode)) {
                this.userReplenishmentOrderService.loadReplenishmentOrderDetails(replenishmentOrderCode);
            }
            else {
                this.userReplenishmentOrderService.clearReplenishmentOrderDetails();
            }
        }), shareReplay({ bufferSize: 1, refCount: true }));
    }
    getOrderDetails() {
        return this.replenishmentOrderLoad$.pipe(switchMap((_) => this.userReplenishmentOrderService.getReplenishmentOrderDetails()));
    }
}
ReplenishmentOrderDetailsService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ReplenishmentOrderDetailsService, deps: [{ token: i1.RoutingService }, { token: i1.UserReplenishmentOrderService }], target: i0.ɵɵFactoryTarget.Injectable });
ReplenishmentOrderDetailsService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ReplenishmentOrderDetailsService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ReplenishmentOrderDetailsService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.RoutingService }, { type: i1.UserReplenishmentOrderService }]; } });

const moduleComponents = [ReplenishmentOrderCancellationComponent];
/**
 * @deprecated since 4.2 - use order lib instead
 */
class ReplenishmentOrderDetailsModule {
}
ReplenishmentOrderDetailsModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ReplenishmentOrderDetailsModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ReplenishmentOrderDetailsModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ReplenishmentOrderDetailsModule, declarations: [ReplenishmentOrderCancellationComponent], imports: [CartSharedModule,
        CardModule,
        CommonModule,
        I18nModule,
        PromotionsModule,
        UrlModule,
        ReplenishmentOrderCancellationDialogModule,
        SpinnerModule,
        ListNavigationModule, i1$1.RouterModule], exports: [ReplenishmentOrderCancellationComponent] });
ReplenishmentOrderDetailsModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ReplenishmentOrderDetailsModule, providers: [
        provideConfig(defaultReplenishmentOrderCancellationLayoutConfig),
        provideDefaultConfig({
            cmsComponents: {
                ReplenishmentDetailItemsComponent: {
                    component: OrderDetailItemsComponent,
                    providers: [
                        {
                            provide: OrderDetailsService,
                            useExisting: ReplenishmentOrderDetailsService,
                        },
                    ],
                },
                ReplenishmentDetailTotalsComponent: {
                    component: OrderDetailTotalsComponent,
                    providers: [
                        {
                            provide: OrderDetailsService,
                            useExisting: ReplenishmentOrderDetailsService,
                        },
                    ],
                },
                ReplenishmentDetailShippingComponent: {
                    component: OrderDetailShippingComponent,
                    providers: [
                        {
                            provide: OrderDetailsService,
                            useExisting: ReplenishmentOrderDetailsService,
                        },
                    ],
                },
                ReplenishmentDetailActionsComponent: {
                    component: ReplenishmentOrderCancellationComponent,
                },
                ReplenishmentDetailOrderHistoryComponent: {
                    component: OrderHistoryComponent,
                },
            },
        }),
    ], imports: [[
            CartSharedModule,
            CardModule,
            CommonModule,
            I18nModule,
            PromotionsModule,
            UrlModule,
            ReplenishmentOrderCancellationDialogModule,
            SpinnerModule,
            ListNavigationModule,
            RouterModule.forChild([
                {
                    path: null,
                    canActivate: [AuthGuard, CmsPageGuard],
                    component: PageLayoutComponent,
                    data: { cxRoute: 'replenishmentDetails' },
                },
            ]),
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ReplenishmentOrderDetailsModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CartSharedModule,
                        CardModule,
                        CommonModule,
                        I18nModule,
                        PromotionsModule,
                        UrlModule,
                        ReplenishmentOrderCancellationDialogModule,
                        SpinnerModule,
                        ListNavigationModule,
                        RouterModule.forChild([
                            {
                                path: null,
                                canActivate: [AuthGuard, CmsPageGuard],
                                component: PageLayoutComponent,
                                data: { cxRoute: 'replenishmentDetails' },
                            },
                        ]),
                    ],
                    providers: [
                        provideConfig(defaultReplenishmentOrderCancellationLayoutConfig),
                        provideDefaultConfig({
                            cmsComponents: {
                                ReplenishmentDetailItemsComponent: {
                                    component: OrderDetailItemsComponent,
                                    providers: [
                                        {
                                            provide: OrderDetailsService,
                                            useExisting: ReplenishmentOrderDetailsService,
                                        },
                                    ],
                                },
                                ReplenishmentDetailTotalsComponent: {
                                    component: OrderDetailTotalsComponent,
                                    providers: [
                                        {
                                            provide: OrderDetailsService,
                                            useExisting: ReplenishmentOrderDetailsService,
                                        },
                                    ],
                                },
                                ReplenishmentDetailShippingComponent: {
                                    component: OrderDetailShippingComponent,
                                    providers: [
                                        {
                                            provide: OrderDetailsService,
                                            useExisting: ReplenishmentOrderDetailsService,
                                        },
                                    ],
                                },
                                ReplenishmentDetailActionsComponent: {
                                    component: ReplenishmentOrderCancellationComponent,
                                },
                                ReplenishmentDetailOrderHistoryComponent: {
                                    component: OrderHistoryComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [...moduleComponents],
                    exports: [...moduleComponents],
                }]
        }] });

/**
 * @deprecated since 4.2 - use order lib instead
 */
class ReplenishmentOrderHistoryComponent {
    constructor(routing, userReplenishmentOrderService, translation, vcr, launchDialogService) {
        this.routing = routing;
        this.userReplenishmentOrderService = userReplenishmentOrderService;
        this.translation = translation;
        this.vcr = vcr;
        this.launchDialogService = launchDialogService;
        this.subscription = new Subscription();
        this.PAGE_SIZE = 5;
        this.replenishmentOrders$ = this.userReplenishmentOrderService
            .getReplenishmentOrderHistoryList(this.PAGE_SIZE)
            .pipe(tap((replenishmentOrders) => {
            if (replenishmentOrders.pagination) {
                this.sortType = replenishmentOrders.pagination.sort;
            }
        }));
        this.isLoaded$ = this.userReplenishmentOrderService.getReplenishmentOrderHistoryListSuccess();
    }
    changeSortCode(sortCode) {
        const event = {
            sortCode,
            currentPage: 0,
        };
        this.sortType = sortCode;
        this.fetchReplenishmentOrders(event);
    }
    pageChange(page) {
        const event = {
            sortCode: this.sortType,
            currentPage: page,
        };
        this.fetchReplenishmentOrders(event);
    }
    goToOrderDetail(order) {
        this.routing.go({
            cxRoute: 'replenishmentDetails',
            params: order,
        });
    }
    getSortLabels() {
        return combineLatest([
            this.translation.translate('sorting.date'),
            this.translation.translate('sorting.replenishmentNumber'),
            this.translation.translate('sorting.nextOrderDate'),
        ]).pipe(map(([textByDate, textByOrderNumber, textbyNextOrderDate]) => {
            return {
                byDate: textByDate,
                byReplenishmentNumber: textByOrderNumber,
                byNextOrderDate: textbyNextOrderDate,
            };
        }));
    }
    openDialog(event, replenishmentOrderCode) {
        const dialog = this.launchDialogService.openDialog("REPLENISHMENT_ORDER" /* REPLENISHMENT_ORDER */, this.element, this.vcr, replenishmentOrderCode);
        if (dialog) {
            this.subscription.add(dialog.pipe(take(1)).subscribe());
        }
        event.stopPropagation();
    }
    fetchReplenishmentOrders(event) {
        this.userReplenishmentOrderService.loadReplenishmentOrderList(this.PAGE_SIZE, event.currentPage, event.sortCode);
    }
    ngOnDestroy() {
        this.subscription.unsubscribe();
        this.userReplenishmentOrderService.clearReplenishmentOrderList();
    }
}
ReplenishmentOrderHistoryComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ReplenishmentOrderHistoryComponent, deps: [{ token: i1.RoutingService }, { token: i1.UserReplenishmentOrderService }, { token: i1.TranslationService }, { token: i0.ViewContainerRef }, { token: LaunchDialogService }], target: i0.ɵɵFactoryTarget.Component });
ReplenishmentOrderHistoryComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: ReplenishmentOrderHistoryComponent, selector: "cx-replenishment-order-history", viewQueries: [{ propertyName: "element", first: true, predicate: ["element"], descendants: true }], ngImport: i0, template: "<ng-container *ngIf=\"replenishmentOrders$ | async as replenishmentOrders\">\n  <div class=\"container\">\n    <!-- HEADER -->\n    <div class=\"cx-replenishment-order-history-header\">\n      <h3>\n        {{ 'orderHistory.replenishmentOrderHistory' | cxTranslate }}\n      </h3>\n    </div>\n\n    <!-- BODY -->\n    <div class=\"cx-replenishment-order-history-body\">\n      <ng-container\n        *ngIf=\"replenishmentOrders.pagination.totalResults > 0; else noOrder\"\n      >\n        <!-- Select Form and Pagination Top -->\n        <div class=\"cx-replenishment-order-history-sort top row\">\n          <label\n            class=\"\n              cx-replenishment-order-history-form-group\n              form-group\n              col-sm-12 col-md-4 col-lg-4\n            \"\n          >\n            <span>{{ 'orderHistory.sortBy' | cxTranslate }}</span>\n            <cx-sorting\n              [sortOptions]=\"replenishmentOrders.sorts\"\n              [sortLabels]=\"getSortLabels() | async\"\n              (sortListEvent)=\"changeSortCode($event)\"\n              [selectedOption]=\"replenishmentOrders.pagination.sort\"\n              placeholder=\"{{ 'orderHistory.sortBy' | cxTranslate }}\"\n            ></cx-sorting>\n          </label>\n          <div\n            class=\"cx-replenishment-order-history-pagination\"\n            *ngIf=\"replenishmentOrders.pagination.totalPages > 1\"\n          >\n            <cx-pagination\n              [pagination]=\"replenishmentOrders.pagination\"\n              (viewPageEvent)=\"pageChange($event)\"\n            ></cx-pagination>\n          </div>\n        </div>\n        <!-- TABLE -->\n        <table class=\"table cx-replenishment-order-history-table\">\n          <thead class=\"cx-replenishment-order-history-thead-mobile\">\n            <th scope=\"col\">\n              <span class=\"cx-replenishment-order-history-ellipses\">\n                {{ 'orderHistory.replenishmentOrderId' | cxTranslate }}\n              </span>\n            </th>\n            <th scope=\"col\">\n              <span class=\"cx-replenishment-order-history-ellipses\">\n                {{ 'orderHistory.purchaseOrderNumber' | cxTranslate }}\n              </span>\n            </th>\n            <th scope=\"col\">\n              <span class=\"cx-replenishment-order-history-ellipses\">\n                {{ 'orderHistory.startOn' | cxTranslate }}\n              </span>\n            </th>\n            <th scope=\"col\">\n              <span class=\"cx-replenishment-order-history-ellipses\">\n                {{ 'orderHistory.frequency' | cxTranslate }}\n              </span>\n            </th>\n            <th scope=\"col\">\n              <span class=\"cx-replenishment-order-history-ellipses\">\n                {{ 'orderHistory.nextOrderDate' | cxTranslate }}\n              </span>\n            </th>\n            <th scope=\"col\" class=\"cx-replenishment-order-history-total\">\n              <span class=\"cx-replenishment-order-history-ellipses\">\n                {{ 'orderHistory.total' | cxTranslate }}\n              </span>\n            </th>\n            <th scope=\"col\"></th>\n          </thead>\n          <tbody>\n            <tr\n              *ngFor=\"let order of replenishmentOrders.replenishmentOrders\"\n              (click)=\"goToOrderDetail(order)\"\n            >\n              <td class=\"cx-replenishment-order-history-code\">\n                <div class=\"d-md-none cx-replenishment-order-history-label\">\n                  {{ 'orderHistory.replenishmentOrderId' | cxTranslate }}\n                </div>\n                <a\n                  [routerLink]=\"\n                    {\n                      cxRoute: 'replenishmentDetails',\n                      params: order\n                    } | cxUrl\n                  \"\n                  class=\"cx-replenishment-order-history-value\"\n                >\n                  {{ order?.replenishmentOrderCode }}</a\n                >\n              </td>\n              <td>\n                <div class=\"d-md-none cx-replenishment-order-history-label\">\n                  {{ 'orderHistory.purchaseOrderNumber' | cxTranslate }}\n                </div>\n                <a\n                  [routerLink]=\"\n                    {\n                      cxRoute: 'replenishmentDetails',\n                      params: order\n                    } | cxUrl\n                  \"\n                  class=\"\n                    cx-replenishment-order-history-value\n                    cx-purchase-order-number\n                  \"\n                >\n                  {{\n                    order?.purchaseOrderNumber?.length > 0\n                      ? order?.purchaseOrderNumber\n                      : ('orderHistory.emptyPurchaseOrderId' | cxTranslate)\n                  }}\n                </a>\n              </td>\n              <td>\n                <div class=\"d-md-none cx-replenishment-order-history-label\">\n                  {{ 'orderHistory.startOn' | cxTranslate }}\n                </div>\n                <a\n                  [routerLink]=\"\n                    {\n                      cxRoute: 'replenishmentDetails',\n                      params: order\n                    } | cxUrl\n                  \"\n                  class=\"cx-replenishment-order-history-value\"\n                >\n                  {{ order?.firstDate | cxDate: 'M/d/yyyy' }}</a\n                >\n              </td>\n              <td class=\"cx-replenishment-order-history-frequency\">\n                <div class=\"d-md-none cx-replenishment-order-history-label\">\n                  {{ 'orderHistory.frequency' | cxTranslate }}\n                </div>\n                <a\n                  [routerLink]=\"\n                    {\n                      cxRoute: 'replenishmentDetails',\n                      params: order\n                    } | cxUrl\n                  \"\n                  class=\"cx-replenishment-order-history-value\"\n                >\n                  {{ order?.trigger.displayTimeTable | slice: 0:-12 }}\n                </a>\n              </td>\n              <td>\n                <div class=\"d-md-none cx-replenishment-order-history-label\">\n                  {{ 'orderHistory.nextOrderDate' | cxTranslate }}\n                </div>\n\n                <a\n                  [routerLink]=\"\n                    {\n                      cxRoute: 'replenishmentDetails',\n                      params: order\n                    } | cxUrl\n                  \"\n                  class=\"\n                    cx-replenishment-order-history-value cx-next-order-date\n                  \"\n                >\n                  {{\n                    order?.active\n                      ? (order?.trigger.activationTime | cxDate: 'M/d/yyyy')\n                      : ('orderHistory.cancelled' | cxTranslate)\n                  }}\n                </a>\n              </td>\n              <td class=\"cx-replenishment-order-history-total\">\n                <div class=\"d-md-none cx-replenishment-order-history-label\">\n                  {{ 'orderHistory.total' | cxTranslate }}\n                </div>\n                <a\n                  [routerLink]=\"\n                    {\n                      cxRoute: 'replenishmentDetails',\n                      params: order\n                    } | cxUrl\n                  \"\n                  class=\"cx-replenishment-order-history-value\"\n                >\n                  {{ order?.totalPriceWithTax.formattedValue }}</a\n                >\n              </td>\n              <td class=\"cx-replenishment-order-history-cancel\">\n                <div\n                  class=\"d-md-none cx-replenishment-order-history-label\"\n                ></div>\n                <button\n                  (click)=\"openDialog($event, order?.replenishmentOrderCode)\"\n                  class=\"cx-order-cancel btn btn-link\"\n                  #element\n                  *ngIf=\"order?.active\"\n                >\n                  {{ 'orderHistory.cancel' | cxTranslate }}\n                </button>\n              </td>\n            </tr>\n          </tbody>\n        </table>\n        <!-- Select Form and Pagination Bottom -->\n        <div class=\"cx-replenishment-order-history-sort bottom row\">\n          <div class=\"cx-replenishment-order-history-pagination\">\n            <cx-pagination\n              [pagination]=\"replenishmentOrders.pagination\"\n              (viewPageEvent)=\"pageChange($event)\"\n              *ngIf=\"replenishmentOrders.pagination.totalPages > 1\"\n            ></cx-pagination>\n          </div>\n        </div>\n      </ng-container>\n\n      <!-- NO ORDER CONTAINER -->\n      <ng-template #noOrder>\n        <div\n          class=\"cx-replenishment-order-history-no-order row\"\n          *ngIf=\"isLoaded$ | async\"\n        >\n          <div class=\"col-sm-12 col-md-6 col-lg-4\">\n            <div>{{ 'orderHistory.noReplenishmentOrders' | cxTranslate }}</div>\n            <a\n              [routerLink]=\"{ cxRoute: 'home' } | cxUrl\"\n              routerLinkActive=\"active\"\n              class=\"btn btn-primary btn-block\"\n              >{{ 'orderHistory.startShopping' | cxTranslate }}</a\n            >\n          </div>\n        </div>\n      </ng-template>\n    </div>\n  </div>\n</ng-container>\n", components: [{ type: SortingComponent, selector: "cx-sorting", inputs: ["sortOptions", "selectedOption", "placeholder", "sortLabels"], outputs: ["sortListEvent"] }, { type: PaginationComponent, selector: "cx-pagination", inputs: ["pageRoute", "queryParam", "defaultPage", "pagination"], outputs: ["viewPageEvent"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i1$1.RouterLinkWithHref, selector: "a[routerLink],area[routerLink]", inputs: ["routerLink", "target", "queryParams", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange", "replaceUrl", "state", "relativeTo"] }, { type: i1$1.RouterLinkActive, selector: "[routerLinkActive]", inputs: ["routerLinkActiveOptions", "routerLinkActive"], exportAs: ["routerLinkActive"] }], pipes: { "async": i3.AsyncPipe, "cxTranslate": i1.TranslatePipe, "cxUrl": i1.UrlPipe, "cxDate": i1.CxDatePipe, "slice": i3.SlicePipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ReplenishmentOrderHistoryComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-replenishment-order-history',
                    templateUrl: './replenishment-order-history.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: i1.RoutingService }, { type: i1.UserReplenishmentOrderService }, { type: i1.TranslationService }, { type: i0.ViewContainerRef }, { type: LaunchDialogService }]; }, propDecorators: { element: [{
                type: ViewChild,
                args: ['element']
            }] } });

/**
 * @deprecated since 4.2 - use order lib instead
 */
class ReplenishmentOrderHistoryModule {
}
ReplenishmentOrderHistoryModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ReplenishmentOrderHistoryModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ReplenishmentOrderHistoryModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ReplenishmentOrderHistoryModule, declarations: [ReplenishmentOrderHistoryComponent], imports: [CommonModule, i1$1.RouterModule, RouterModule,
        ListNavigationModule,
        UrlModule,
        I18nModule], exports: [ReplenishmentOrderHistoryComponent] });
ReplenishmentOrderHistoryModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ReplenishmentOrderHistoryModule, providers: [
        provideConfig(defaultReplenishmentOrderCancellationLayoutConfig),
        provideDefaultConfig({
            cmsComponents: {
                AccountReplenishmentHistoryComponent: {
                    component: ReplenishmentOrderHistoryComponent,
                    guards: [AuthGuard],
                },
            },
        }),
    ], imports: [[
            CommonModule,
            RouterModule.forChild([
                {
                    path: null,
                    canActivate: [AuthGuard, CmsPageGuard],
                    component: PageLayoutComponent,
                    data: { cxRoute: 'replenishmentOrders' },
                },
            ]),
            RouterModule,
            ListNavigationModule,
            UrlModule,
            I18nModule,
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ReplenishmentOrderHistoryModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        RouterModule.forChild([
                            {
                                path: null,
                                canActivate: [AuthGuard, CmsPageGuard],
                                component: PageLayoutComponent,
                                data: { cxRoute: 'replenishmentOrders' },
                            },
                        ]),
                        RouterModule,
                        ListNavigationModule,
                        UrlModule,
                        I18nModule,
                    ],
                    providers: [
                        provideConfig(defaultReplenishmentOrderCancellationLayoutConfig),
                        provideDefaultConfig({
                            cmsComponents: {
                                AccountReplenishmentHistoryComponent: {
                                    component: ReplenishmentOrderHistoryComponent,
                                    guards: [AuthGuard],
                                },
                            },
                        }),
                    ],
                    declarations: [ReplenishmentOrderHistoryComponent],
                    exports: [ReplenishmentOrderHistoryComponent],
                }]
        }] });

class ReturnRequestService {
    constructor(routingService, returnRequestService, globalMessageService) {
        this.routingService = routingService;
        this.returnRequestService = returnRequestService;
        this.globalMessageService = globalMessageService;
    }
    get isCancelling$() {
        return this.returnRequestService.getCancelReturnRequestLoading();
    }
    get isCancelSuccess$() {
        return this.returnRequestService.getCancelReturnRequestSuccess();
    }
    getReturnRequest() {
        return combineLatest([
            this.routingService.getRouterState(),
            this.returnRequestService.getOrderReturnRequest(),
            this.returnRequestService.getReturnRequestLoading(),
        ]).pipe(map(([routingState, returnRequest, isLoading]) => [
            routingState.state.params['returnCode'],
            returnRequest,
            isLoading,
        ]), filter(([returnCode]) => Boolean(returnCode)), tap(([returnCode, returnRequest, isLoading]) => {
            if ((returnRequest === undefined || returnRequest.rma !== returnCode) &&
                !isLoading) {
                this.returnRequestService.loadOrderReturnRequestDetail(returnCode);
            }
        }), map(([_, returnRequest]) => returnRequest), filter(Boolean), distinctUntilChanged());
    }
    clearReturnRequest() {
        this.returnRequestService.clearOrderReturnRequestDetail();
    }
    cancelReturnRequest(returnRequestCode) {
        this.returnRequestService.cancelOrderReturnRequest(returnRequestCode, {
            status: 'CANCELLING',
        });
    }
    cancelSuccess(rma) {
        this.returnRequestService.resetCancelReturnRequestProcessState();
        this.globalMessageService.add({
            key: 'returnRequest.cancelSuccess',
            params: { rma },
        }, GlobalMessageType.MSG_TYPE_CONFIRMATION);
        this.routingService.go({
            cxRoute: 'orders',
        });
    }
    backToList() {
        this.routingService.go({ cxRoute: 'orders' }, {
            state: {
                activeTab: 1,
            },
        });
    }
}
ReturnRequestService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ReturnRequestService, deps: [{ token: i1.RoutingService }, { token: i1.OrderReturnRequestService }, { token: i1.GlobalMessageService }], target: i0.ɵɵFactoryTarget.Injectable });
ReturnRequestService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ReturnRequestService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ReturnRequestService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.RoutingService }, { type: i1.OrderReturnRequestService }, { type: i1.GlobalMessageService }]; } });

/**
 * @deprecated since 4.2 - use order lib instead
 */
class ReturnRequestItemsComponent {
    constructor(returnRequestService) {
        this.returnRequestService = returnRequestService;
        this.returnRequest$ = this.returnRequestService.getReturnRequest();
    }
}
ReturnRequestItemsComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ReturnRequestItemsComponent, deps: [{ token: ReturnRequestService }], target: i0.ɵɵFactoryTarget.Component });
ReturnRequestItemsComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: ReturnRequestItemsComponent, selector: "cx-return-request-items", ngImport: i0, template: "<ng-container *ngIf=\"returnRequest$ | async as returnRequest\">\n  <div class=\"d-none d-md-block d-lg-block d-xl-block\">\n    <div class=\"cx-item-list-header row\">\n      <div class=\"cx-item-list-desc col-md-5 col-lg-5 col-xl-6\">\n        {{ 'returnRequest.item' | cxTranslate }}\n      </div>\n      <div class=\"cx-item-list-price col-md-2 col-lg-2 col-xl-2\">\n        {{ 'returnRequest.itemPrice' | cxTranslate }}\n      </div>\n      <div class=\"cx-item-list-qty col-md-3 col-lg-3 col-xl-2\">\n        {{ 'returnRequest.returnQty' | cxTranslate }}\n      </div>\n      <div class=\"cx-item-list-total col-md-2 col-lg-2 col-xl-2\">\n        {{ 'returnRequest.total' | cxTranslate }}\n      </div>\n    </div>\n  </div>\n\n  <div\n    class=\"cx-item-list-row\"\n    *ngFor=\"let returnEntry of returnRequest.returnEntries; let i = index\"\n  >\n    <div class=\"cx-item-list-items\">\n      <div class=\"row\">\n        <!-- Item Image -->\n        <div class=\"col-2 cx-image-container\">\n          <cx-media\n            [container]=\"returnEntry.orderEntry?.product.images?.PRIMARY\"\n            format=\"thumbnail\"\n          ></cx-media>\n        </div>\n        <!-- Item Information -->\n        <div class=\"cx-info col-10\">\n          <div class=\"cx-info-container row\">\n            <!-- Item Description -->\n            <div class=\"col-md-3 col-lg-4 col-xl-5\">\n              <div *ngIf=\"returnEntry.orderEntry?.product.name\" class=\"cx-name\">\n                {{ returnEntry.orderEntry?.product.name }}\n              </div>\n              <div *ngIf=\"returnEntry.orderEntry?.product.code\" class=\"cx-code\">\n                {{ 'cartItems.id' | cxTranslate }}\n                {{ returnEntry.orderEntry?.product.code }}\n              </div>\n              <!-- Variants -->\n              <div\n                *ngFor=\"\n                  let variant of (returnEntry.orderEntry?.product\n                    .baseOptions)[0]?.selected?.variantOptionQualifiers\n                \"\n                class=\"cx-property\"\n              >\n                <div class=\"cx-label\" *ngIf=\"variant.name\">\n                  {{ variant.name }}:\n                </div>\n                <div class=\"cx-value\" *ngIf=\"variant.value\">\n                  {{ variant.value }}\n                </div>\n              </div>\n            </div>\n            <!-- Item Price -->\n            <div\n              *ngIf=\"returnEntry.orderEntry?.basePrice\"\n              class=\"cx-price col-md-3 col-lg-2 col-xl-2\"\n            >\n              <div class=\"cx-label d-block d-md-none d-lg-none d-xl-none\">\n                {{ 'returnRequest.itemPrice' | cxTranslate }}\n              </div>\n              <div class=\"cx-value\">\n                {{ returnEntry.orderEntry?.basePrice?.formattedValue }}\n              </div>\n            </div>\n            <!-- return Quantity -->\n            <div class=\"cx-quantity col-md-3 col-lg-3 col-xl-3\">\n              <div class=\"cx-label d-block d-md-none d-lg-none d-xl-none\">\n                {{ 'returnRequest.returnQty' | cxTranslate }}\n              </div>\n              <div class=\"cx-value\">\n                {{ returnEntry.expectedQuantity }}\n              </div>\n            </div>\n            <!-- Total Price -->\n            <div class=\"cx-total col-md-3 col-lg-3 col-xl-2\">\n              <div class=\"cx-label d-block d-md-none d-lg-none d-xl-none\">\n                {{ 'returnRequest.total' | cxTranslate }}\n              </div>\n              <div class=\"cx-value\">\n                {{ returnEntry.refundAmount?.formattedValue }}\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n</ng-container>\n", components: [{ type: MediaComponent, selector: "cx-media", inputs: ["container", "format", "alt", "role", "loading"], outputs: ["loaded"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], pipes: { "async": i3.AsyncPipe, "cxTranslate": i1.TranslatePipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ReturnRequestItemsComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-return-request-items',
                    templateUrl: './return-request-items.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: ReturnRequestService }]; } });

/**
 * @deprecated since 4.2 - use order lib instead
 */
class ReturnRequestOverviewComponent {
    constructor(returnRequestService) {
        this.returnRequestService = returnRequestService;
        this.returnRequest$ = this.returnRequestService
            .getReturnRequest()
            .pipe(tap((returnRequest) => (this.rma = returnRequest.rma)));
        this.isCancelling$ = this.returnRequestService.isCancelling$;
    }
    ngOnInit() {
        this.subscription = this.returnRequestService.isCancelSuccess$.subscribe((success) => {
            if (success) {
                this.returnRequestService.cancelSuccess(this.rma);
            }
        });
    }
    cancelReturn(returnRequestCode) {
        this.returnRequestService.cancelReturnRequest(returnRequestCode);
    }
    back() {
        this.returnRequestService.backToList();
    }
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
    }
}
ReturnRequestOverviewComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ReturnRequestOverviewComponent, deps: [{ token: ReturnRequestService }], target: i0.ɵɵFactoryTarget.Component });
ReturnRequestOverviewComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: ReturnRequestOverviewComponent, selector: "cx-return-request-overview", ngImport: i0, template: "<ng-container *ngIf=\"returnRequest$ | async as returnRequest\">\n  <div class=\"cx-nav row\">\n    <div class=\"col-xs-12 col-md-4 col-lg-3\">\n      <button (click)=\"back()\" class=\"btn btn-block btn-action\">\n        {{ 'common.back' | cxTranslate }}\n      </button>\n    </div>\n\n    <div class=\"col-xs-12 col-md-4 col-lg-3\">\n      <button\n        *ngIf=\"returnRequest.cancellable\"\n        class=\"btn btn-block btn-primary\"\n        (click)=\"cancelReturn(returnRequest.rma)\"\n        [disabled]=\"isCancelling$ | async\"\n      >\n        {{ 'returnRequest.cancel' | cxTranslate }}\n      </button>\n    </div>\n  </div>\n  <div class=\"cx-header row\">\n    <div class=\"cx-detail col-sm-12 col-md-4\">\n      <div class=\"cx-detail-label\">\n        {{ 'returnRequest.returnRequestId' | cxTranslate }}\n      </div>\n      <div class=\"cx-detail-value\">{{ returnRequest.rma }}</div>\n    </div>\n    <div class=\"cx-detail col-sm-12 col-md-4\">\n      <div class=\"cx-detail-label\">\n        {{ 'returnRequest.orderCode' | cxTranslate }}\n      </div>\n      <div class=\"cx-detail-value\">{{ returnRequest.order?.code }}</div>\n    </div>\n    <div class=\"cx-detail col-sm-12 col-md-4\">\n      <div class=\"cx-detail-label\">\n        {{ 'returnRequest.status' | cxTranslate }}\n      </div>\n      <div class=\"cx-detail-value\">\n        {{\n          'returnRequestList.statusDisplay_' + returnRequest?.status\n            | cxTranslate\n        }}\n      </div>\n    </div>\n  </div>\n</ng-container>\n", directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "async": i3.AsyncPipe, "cxTranslate": i1.TranslatePipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ReturnRequestOverviewComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-return-request-overview',
                    templateUrl: './return-request-overview.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: ReturnRequestService }]; } });

/**
 * @deprecated since 4.2 - use order lib instead
 */
class ReturnRequestTotalsComponent {
    constructor(returnRequestService) {
        this.returnRequestService = returnRequestService;
        this.returnRequest$ = this.returnRequestService.getReturnRequest();
    }
    ngOnDestroy() {
        this.returnRequestService.clearReturnRequest();
    }
}
ReturnRequestTotalsComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ReturnRequestTotalsComponent, deps: [{ token: ReturnRequestService }], target: i0.ɵɵFactoryTarget.Component });
ReturnRequestTotalsComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: ReturnRequestTotalsComponent, selector: "cx-return-request-totals", ngImport: i0, template: "<ng-container *ngIf=\"returnRequest$ | async as returnRequest\">\n  <div class=\"row justify-content-end\">\n    <div class=\"cx-summary col-sm-12 col-md-6 col-lg-5 col-xl-4\">\n      <h4>{{ 'returnRequest.summary' | cxTranslate }}</h4>\n      <div class=\"cx-summary-row\">\n        <div class=\"col-6 cx-summary-label\">\n          {{ 'returnRequest.subtotal' | cxTranslate }}\n        </div>\n        <div class=\"col-6 cx-summary-amount\">\n          {{ returnRequest.subTotal?.formattedValue }}\n        </div>\n      </div>\n      <div class=\"cx-summary-row\">\n        <div class=\"col-6 cx-summary-label\">\n          {{ 'returnRequest.deliveryCode' | cxTranslate }}\n        </div>\n        <div class=\"col-6 cx-summary-amount\">\n          {{ returnRequest.deliveryCost?.formattedValue }}\n        </div>\n      </div>\n      <div class=\"cx-summary-row cx-summary-total\">\n        <div class=\"col-6 cx-summary-label\">\n          {{ 'returnRequest.estimatedRefund' | cxTranslate }}\n        </div>\n        <div class=\"col-6 cx-summary-amount\">\n          {{ returnRequest.totalPrice?.formattedValue }}\n        </div>\n      </div>\n      <div class=\"cx-summary-row cx-footnote\">\n        {{ 'returnRequest.note' | cxTranslate }}\n      </div>\n    </div>\n  </div>\n</ng-container>\n", directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "async": i3.AsyncPipe, "cxTranslate": i1.TranslatePipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ReturnRequestTotalsComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-return-request-totals',
                    templateUrl: './return-request-totals.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: ReturnRequestService }]; } });

const components = [
    ReturnRequestOverviewComponent,
    ReturnRequestItemsComponent,
    ReturnRequestTotalsComponent,
];
/**
 * @deprecated since 4.2 - use order lib instead
 */
class ReturnRequestDetailModule {
}
ReturnRequestDetailModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ReturnRequestDetailModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ReturnRequestDetailModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ReturnRequestDetailModule, declarations: [ReturnRequestOverviewComponent,
        ReturnRequestItemsComponent,
        ReturnRequestTotalsComponent], imports: [CommonModule, i1$1.RouterModule, RouterModule,
        UrlModule,
        I18nModule,
        MediaModule,
        FeaturesConfigModule], exports: [ReturnRequestOverviewComponent,
        ReturnRequestItemsComponent,
        ReturnRequestTotalsComponent] });
ReturnRequestDetailModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ReturnRequestDetailModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                ReturnRequestOverviewComponent: {
                    component: ReturnRequestOverviewComponent,
                },
                ReturnRequestItemsComponent: {
                    component: ReturnRequestItemsComponent,
                },
                ReturnRequestTotalsComponent: {
                    component: ReturnRequestTotalsComponent,
                },
            },
        }),
    ], imports: [[
            CommonModule,
            RouterModule.forChild([
                {
                    path: null,
                    canActivate: [AuthGuard, CmsPageGuard],
                    component: PageLayoutComponent,
                    data: { cxRoute: 'returnRequestDetails' },
                },
            ]),
            RouterModule,
            UrlModule,
            I18nModule,
            MediaModule,
            FeaturesConfigModule,
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ReturnRequestDetailModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        RouterModule.forChild([
                            {
                                path: null,
                                canActivate: [AuthGuard, CmsPageGuard],
                                component: PageLayoutComponent,
                                data: { cxRoute: 'returnRequestDetails' },
                            },
                        ]),
                        RouterModule,
                        UrlModule,
                        I18nModule,
                        MediaModule,
                        FeaturesConfigModule,
                    ],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                ReturnRequestOverviewComponent: {
                                    component: ReturnRequestOverviewComponent,
                                },
                                ReturnRequestItemsComponent: {
                                    component: ReturnRequestItemsComponent,
                                },
                                ReturnRequestTotalsComponent: {
                                    component: ReturnRequestTotalsComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [...components],
                    exports: [...components],
                }]
        }] });

/**
 * @deprecated since 4.2 - use order lib instead
 */
class OrderReturnRequestListComponent {
    constructor(returnRequestService, translation) {
        this.returnRequestService = returnRequestService;
        this.translation = translation;
        this.PAGE_SIZE = 5;
        this.returnRequests$ = this.returnRequestService
            .getOrderReturnRequestList(this.PAGE_SIZE)
            .pipe(tap((requestList) => {
            if (requestList.pagination) {
                this.sortType = requestList.pagination.sort;
            }
        }));
        /**
         * When "Order Return" feature is enabled, this component becomes one tab in
         * TabParagraphContainerComponent. This can be read from TabParagraphContainer.
         */
        this.tabTitleParam$ = this.returnRequests$.pipe(map((returnRequests) => { var _a; return (_a = returnRequests.pagination) === null || _a === void 0 ? void 0 : _a.totalResults; }), filter(isNotUndefined), take(1));
    }
    ngOnDestroy() {
        this.returnRequestService.clearOrderReturnRequestList();
    }
    changeSortCode(sortCode) {
        const event = {
            sortCode,
            currentPage: 0,
        };
        this.sortType = sortCode;
        this.fetchReturnRequests(event);
    }
    pageChange(page) {
        const event = {
            sortCode: this.sortType,
            currentPage: page,
        };
        this.fetchReturnRequests(event);
    }
    getSortLabels() {
        return combineLatest([
            this.translation.translate('sorting.date'),
            this.translation.translate('sorting.rma'),
        ]).pipe(map(([textByDate, textByRma]) => {
            return {
                byDate: textByDate,
                byRMA: textByRma,
            };
        }));
    }
    fetchReturnRequests(event) {
        this.returnRequestService.loadOrderReturnRequestList(this.PAGE_SIZE, event.currentPage, event.sortCode);
    }
}
OrderReturnRequestListComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OrderReturnRequestListComponent, deps: [{ token: i1.OrderReturnRequestService }, { token: i1.TranslationService }], target: i0.ɵɵFactoryTarget.Component });
OrderReturnRequestListComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: OrderReturnRequestListComponent, selector: "cx-order-return-request-list", ngImport: i0, template: "<ng-container *ngIf=\"returnRequests$ | async as returnRequests\">\n  <div class=\"container\">\n    <!-- BODY -->\n    <div class=\"cx-order-history-body\">\n      <ng-container *ngIf=\"returnRequests.pagination.totalResults > 0\">\n        <!-- Select Form and Pagination Top -->\n        <div class=\"cx-order-history-sort top row\">\n          <label\n            class=\"\n              cx-order-history-form-group\n              form-group\n              col-sm-12 col-md-4 col-lg-4\n            \"\n            ><span>{{ 'returnRequestList.sortBy' | cxTranslate }}</span>\n            <cx-sorting\n              [sortOptions]=\"returnRequests.sorts\"\n              [sortLabels]=\"getSortLabels() | async\"\n              (sortListEvent)=\"changeSortCode($event)\"\n              [selectedOption]=\"returnRequests.pagination.sort\"\n            ></cx-sorting>\n          </label>\n          <div class=\"cx-order-history-pagination\">\n            <cx-pagination\n              [pagination]=\"returnRequests.pagination\"\n              (viewPageEvent)=\"pageChange($event)\"\n            ></cx-pagination>\n          </div>\n        </div>\n        <!-- TABLE -->\n        <table class=\"table cx-order-history-table\">\n          <thead class=\"cx-order-history-thead-mobile\">\n            <th scope=\"col\">\n              {{ 'returnRequestList.returnRequestId' | cxTranslate }}\n            </th>\n            <th scope=\"col\">{{ 'returnRequestList.orderId' | cxTranslate }}</th>\n            <th scope=\"col\">\n              {{ 'returnRequestList.date' | cxTranslate }}\n            </th>\n            <th scope=\"col\">{{ 'returnRequestList.status' | cxTranslate }}</th>\n          </thead>\n          <tbody>\n            <tr *ngFor=\"let return of returnRequests.returnRequests\">\n              <td class=\"cx-order-history-code\">\n                <div class=\"d-md-none cx-order-history-label\">\n                  {{ 'returnRequestList.returnRequestId' | cxTranslate }}\n                </div>\n                <a\n                  [routerLink]=\"\n                    {\n                      cxRoute: 'returnRequestDetails',\n                      params: return\n                    } | cxUrl\n                  \"\n                  class=\"cx-order-history-value\"\n                >\n                  {{ return?.rma }}</a\n                >\n              </td>\n              <td class=\"cx-order-history-code\">\n                <div class=\"d-md-none cx-order-history-label\">\n                  {{ 'returnRequestList.orderId' | cxTranslate }}\n                </div>\n                <a\n                  [routerLink]=\"\n                    {\n                      cxRoute: 'orderDetails',\n                      params: return?.order\n                    } | cxUrl\n                  \"\n                  class=\"cx-order-history-value\"\n                >\n                  {{ return?.order?.code }}</a\n                >\n              </td>\n\n              <td class=\"cx-order-history-placed\">\n                <div class=\"d-md-none cx-order-history-label\">\n                  {{ 'returnRequestList.date' | cxTranslate }}\n                </div>\n                {{ return?.creationTime | cxDate: 'longDate' }}\n              </td>\n              <td class=\"cx-order-history-status\">\n                <div class=\"d-md-none cx-order-history-label\">\n                  {{ 'returnRequestList.status' | cxTranslate }}\n                </div>\n                {{\n                  'returnRequestList.statusDisplay_' + return?.status\n                    | cxTranslate\n                }}\n              </td>\n            </tr>\n          </tbody>\n        </table>\n        <!-- Select Form and Pagination Bottom -->\n        <div class=\"cx-order-history-sort bottom row\">\n          <label\n            class=\"\n              cx-order-history-form-group\n              form-group\n              col-sm-12 col-md-4 col-lg-4\n            \"\n            ><span>{{ 'returnRequestList.sortBy' | cxTranslate }}</span>\n            <cx-sorting\n              [sortOptions]=\"returnRequests.sorts\"\n              [sortLabels]=\"getSortLabels() | async\"\n              (sortListEvent)=\"changeSortCode($event)\"\n              [selectedOption]=\"returnRequests.pagination.sort\"\n            ></cx-sorting>\n          </label>\n          <div class=\"cx-order-history-pagination\">\n            <cx-pagination\n              [pagination]=\"returnRequests.pagination\"\n              (viewPageEvent)=\"pageChange($event)\"\n            ></cx-pagination>\n          </div>\n        </div>\n      </ng-container>\n    </div>\n  </div>\n</ng-container>\n", components: [{ type: SortingComponent, selector: "cx-sorting", inputs: ["sortOptions", "selectedOption", "placeholder", "sortLabels"], outputs: ["sortListEvent"] }, { type: PaginationComponent, selector: "cx-pagination", inputs: ["pageRoute", "queryParam", "defaultPage", "pagination"], outputs: ["viewPageEvent"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i1$1.RouterLinkWithHref, selector: "a[routerLink],area[routerLink]", inputs: ["routerLink", "target", "queryParams", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange", "replaceUrl", "state", "relativeTo"] }], pipes: { "async": i3.AsyncPipe, "cxTranslate": i1.TranslatePipe, "cxUrl": i1.UrlPipe, "cxDate": i1.CxDatePipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OrderReturnRequestListComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-order-return-request-list',
                    templateUrl: './order-return-request-list.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: i1.OrderReturnRequestService }, { type: i1.TranslationService }]; } });

/**
 * @deprecated since 4.2 - use order lib instead
 */
class ReturnRequestListModule {
}
ReturnRequestListModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ReturnRequestListModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ReturnRequestListModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ReturnRequestListModule, declarations: [OrderReturnRequestListComponent], imports: [CommonModule,
        RouterModule,
        ListNavigationModule,
        UrlModule,
        I18nModule], exports: [OrderReturnRequestListComponent] });
ReturnRequestListModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ReturnRequestListModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                OrderReturnRequestListComponent: {
                    component: OrderReturnRequestListComponent,
                    guards: [AuthGuard],
                },
            },
        }),
    ], imports: [[
            CommonModule,
            RouterModule,
            ListNavigationModule,
            UrlModule,
            I18nModule,
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ReturnRequestListModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        RouterModule,
                        ListNavigationModule,
                        UrlModule,
                        I18nModule,
                    ],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                OrderReturnRequestListComponent: {
                                    component: OrderReturnRequestListComponent,
                                    guards: [AuthGuard],
                                },
                            },
                        }),
                    ],
                    declarations: [OrderReturnRequestListComponent],
                    exports: [OrderReturnRequestListComponent],
                }]
        }] });

/**
 * @deprecated since 4.2 - use order lib instead
 */
class OrderModule {
}
OrderModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OrderModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
OrderModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OrderModule, imports: [OrderHistoryModule,
        OrderDetailsModule,
        ReplenishmentOrderDetailsModule,
        OrderCancellationModule,
        OrderReturnModule,
        ReplenishmentOrderHistoryModule,
        ReturnRequestListModule,
        ReturnRequestDetailModule] });
OrderModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OrderModule, imports: [[
            OrderHistoryModule,
            OrderDetailsModule,
            ReplenishmentOrderDetailsModule,
            OrderCancellationModule,
            OrderReturnModule,
            ReplenishmentOrderHistoryModule,
            ReturnRequestListModule,
            ReturnRequestDetailModule,
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OrderModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        OrderHistoryModule,
                        OrderDetailsModule,
                        ReplenishmentOrderDetailsModule,
                        OrderCancellationModule,
                        OrderReturnModule,
                        ReplenishmentOrderHistoryModule,
                        ReturnRequestListModule,
                        ReturnRequestDetailModule,
                    ],
                }]
        }] });

class PaymentMethodsComponent {
    constructor(userPaymentService, translation) {
        this.userPaymentService = userPaymentService;
        this.translation = translation;
        this.iconTypes = ICON_TYPE;
    }
    ngOnInit() {
        this.paymentMethods$ = this.userPaymentService.getPaymentMethods().pipe(tap((paymentDetails) => {
            // Set first payment method to DEFAULT if none is set
            if (paymentDetails.length > 0 &&
                !paymentDetails.find((paymentDetail) => paymentDetail.defaultPayment)) {
                this.setDefaultPaymentMethod(paymentDetails[0]);
            }
        }));
        this.editCard = null;
        this.loading$ = this.userPaymentService.getPaymentMethodsLoading();
        this.userPaymentService.loadPaymentMethods();
    }
    getCardContent({ defaultPayment, accountHolderName, expiryMonth, expiryYear, cardNumber, cardType, }) {
        return combineLatest([
            this.translation.translate('paymentCard.setAsDefault'),
            this.translation.translate('common.delete'),
            this.translation.translate('paymentCard.deleteConfirmation'),
            this.translation.translate('paymentCard.expires', {
                month: expiryMonth,
                year: expiryYear,
            }),
            this.translation.translate('paymentCard.defaultPaymentMethod'),
        ]).pipe(map(([textSetAsDefault, textDelete, textDeleteConfirmation, textExpires, textDefaultPaymentMethod,]) => {
            const actions = [];
            if (!defaultPayment) {
                actions.push({ name: textSetAsDefault, event: 'default' });
            }
            actions.push({ name: textDelete, event: 'edit' });
            const card = {
                header: defaultPayment ? textDefaultPaymentMethod : null,
                textBold: accountHolderName,
                text: [cardNumber, textExpires],
                actions,
                deleteMsg: textDeleteConfirmation,
                img: this.getCardIcon(cardType.code),
            };
            return card;
        }));
    }
    deletePaymentMethod(paymentMethod) {
        this.userPaymentService.deletePaymentMethod(paymentMethod.id);
        this.editCard = null;
    }
    setEdit(paymentMethod) {
        this.editCard = paymentMethod.id;
    }
    cancelCard() {
        this.editCard = null;
    }
    setDefaultPaymentMethod(paymentMethod) {
        this.userPaymentService.setPaymentMethodAsDefault(paymentMethod.id);
    }
    getCardIcon(code) {
        let ccIcon;
        if (code === 'visa') {
            ccIcon = this.iconTypes.VISA;
        }
        else if (code === 'master' || code === 'mastercard_eurocard') {
            ccIcon = this.iconTypes.MASTER_CARD;
        }
        else if (code === 'diners') {
            ccIcon = this.iconTypes.DINERS_CLUB;
        }
        else if (code === 'amex') {
            ccIcon = this.iconTypes.AMEX;
        }
        else {
            ccIcon = this.iconTypes.CREDIT_CARD;
        }
        return ccIcon;
    }
}
PaymentMethodsComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PaymentMethodsComponent, deps: [{ token: i1.UserPaymentService }, { token: i1.TranslationService }], target: i0.ɵɵFactoryTarget.Component });
PaymentMethodsComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: PaymentMethodsComponent, selector: "cx-payment-methods", ngImport: i0, template: "<ng-container *ngIf=\"paymentMethods$ | async as paymentMethods\">\n  <div class=\"cx-payment container\">\n    <div class=\"cx-header\">\n      <h3>{{ 'paymentMethods.paymentMethods' | cxTranslate }}</h3>\n    </div>\n\n    <div class=\"cx-body\">\n      <div class=\"cx-msg\">\n        {{\n          'paymentMethods.newPaymentMethodsAreAddedDuringCheckout' | cxTranslate\n        }}\n      </div>\n      <div *ngIf=\"loading$ | async; else cards\"><cx-spinner></cx-spinner></div>\n      <ng-template #cards>\n        <div class=\"cx-existing row\">\n          <div\n            class=\"cx-payment-card col-sm-12 col-md-12 col-lg-6\"\n            *ngFor=\"let paymentMethod of paymentMethods\"\n          >\n            <div class=\"cx-payment-inner\">\n              <cx-card\n                [border]=\"true\"\n                [fitToContainer]=\"true\"\n                [content]=\"getCardContent(paymentMethod) | async\"\n                (deleteCard)=\"deletePaymentMethod(paymentMethod)\"\n                (setDefaultCard)=\"setDefaultPaymentMethod(paymentMethod)\"\n                (editCard)=\"setEdit(paymentMethod)\"\n                [editMode]=\"editCard === paymentMethod.id\"\n                (cancelCard)=\"cancelCard()\"\n              ></cx-card>\n            </div>\n          </div>\n        </div>\n      </ng-template>\n    </div>\n  </div>\n</ng-container>\n", components: [{ type: SpinnerComponent, selector: "cx-spinner" }, { type: CardComponent, selector: "cx-card", inputs: ["border", "editMode", "isDefault", "content", "fitToContainer", "truncateText", "charactersLimit"], outputs: ["deleteCard", "setDefaultCard", "sendCard", "editCard", "cancelCard"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], pipes: { "async": i3.AsyncPipe, "cxTranslate": i1.TranslatePipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PaymentMethodsComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-payment-methods',
                    templateUrl: './payment-methods.component.html',
                }]
        }], ctorParameters: function () { return [{ type: i1.UserPaymentService }, { type: i1.TranslationService }]; } });

class PaymentMethodsModule {
}
PaymentMethodsModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PaymentMethodsModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
PaymentMethodsModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PaymentMethodsModule, declarations: [PaymentMethodsComponent], imports: [CommonModule, CardModule, SpinnerModule, I18nModule], exports: [PaymentMethodsComponent] });
PaymentMethodsModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PaymentMethodsModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                AccountPaymentDetailsComponent: {
                    component: PaymentMethodsComponent,
                    guards: [AuthGuard],
                },
            },
        }),
    ], imports: [[CommonModule, CardModule, SpinnerModule, I18nModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PaymentMethodsModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, CardModule, SpinnerModule, I18nModule],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                AccountPaymentDetailsComponent: {
                                    component: PaymentMethodsComponent,
                                    guards: [AuthGuard],
                                },
                            },
                        }),
                    ],
                    declarations: [PaymentMethodsComponent],
                    exports: [PaymentMethodsComponent],
                }]
        }] });

class PageTitleComponent {
    constructor(component, pageMetaService) {
        this.component = component;
        this.pageMetaService = pageMetaService;
    }
    ngOnInit() {
        this.setTitle();
    }
    setTitle() {
        this.title$ = this.pageMetaService.getMeta().pipe(filter(isNotNullable), map((meta) => { var _a; return (_a = (meta.heading || meta.title)) !== null && _a !== void 0 ? _a : ''; }));
    }
}
PageTitleComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PageTitleComponent, deps: [{ token: CmsComponentData }, { token: i1.PageMetaService }], target: i0.ɵɵFactoryTarget.Component });
PageTitleComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: PageTitleComponent, selector: "cx-page-title", ngImport: i0, template: "<h1 class=\"cx-visually-hidden\">{{ title$ | async }}</h1>\n", pipes: { "async": i3.AsyncPipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PageTitleComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-page-title',
                    templateUrl: './page-title.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: CmsComponentData }, { type: i1.PageMetaService }]; } });

class BreadcrumbComponent extends PageTitleComponent {
    constructor(component, pageMetaService, translation) {
        super(component, pageMetaService);
        this.component = component;
        this.pageMetaService = pageMetaService;
        this.translation = translation;
    }
    ngOnInit() {
        super.ngOnInit();
        this.setCrumbs();
    }
    setCrumbs() {
        this.crumbs$ = combineLatest([
            this.pageMetaService.getMeta(),
            this.translation.translate('common.home'),
        ]).pipe(map(([meta, textHome]) => (meta === null || meta === void 0 ? void 0 : meta.breadcrumbs) ? meta.breadcrumbs : [{ label: textHome, link: '/' }]));
    }
}
BreadcrumbComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: BreadcrumbComponent, deps: [{ token: CmsComponentData }, { token: i1.PageMetaService }, { token: i1.TranslationService }], target: i0.ɵɵFactoryTarget.Component });
BreadcrumbComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: BreadcrumbComponent, selector: "cx-breadcrumb", usesInheritance: true, ngImport: i0, template: "<nav>\n  <span *ngFor=\"let crumb of crumbs$ | async\">\n    <a [routerLink]=\"crumb.link\" [innerHTML]=\"crumb.label\"></a>\n  </span>\n</nav>\n<h1>{{ title$ | async }}</h1>\n", directives: [{ type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i1$1.RouterLinkWithHref, selector: "a[routerLink],area[routerLink]", inputs: ["routerLink", "target", "queryParams", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange", "replaceUrl", "state", "relativeTo"] }], pipes: { "async": i3.AsyncPipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: BreadcrumbComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-breadcrumb',
                    templateUrl: './breadcrumb.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: CmsComponentData }, { type: i1.PageMetaService }, { type: i1.TranslationService }]; } });

class BreadcrumbModule {
}
BreadcrumbModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: BreadcrumbModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
BreadcrumbModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: BreadcrumbModule, declarations: [BreadcrumbComponent], imports: [CommonModule, RouterModule, PageMetaModule], exports: [BreadcrumbComponent] });
BreadcrumbModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: BreadcrumbModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                BreadcrumbComponent: {
                    component: BreadcrumbComponent,
                },
            },
        }),
    ], imports: [[CommonModule, RouterModule, PageMetaModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: BreadcrumbModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, RouterModule, PageMetaModule],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                BreadcrumbComponent: {
                                    component: BreadcrumbComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [BreadcrumbComponent],
                    exports: [BreadcrumbComponent],
                }]
        }] });

class NavigationService {
    constructor(cmsService, semanticPathService) {
        this.cmsService = cmsService;
        this.semanticPathService = semanticPathService;
    }
    createNavigation(data$) {
        return combineLatest([data$, this.getNavigationNode(data$)]).pipe(map(([data, nav]) => {
            return data
                ? {
                    title: data.name,
                    children: [nav],
                }
                : undefined;
        }));
    }
    /**
     * returns an observable with the `NavigationNode` for the given `CmsNavigationComponent`.
     * This function will load the navigation underlying entries and children if they haven't been
     * loaded so far.
     */
    getNavigationNode(data$) {
        if (!data$) {
            return of();
        }
        return data$.pipe(filter((data) => !!data), switchMap((data) => {
            const navigation = data.navigationNode ? data.navigationNode : data;
            return this.cmsService.getNavigationEntryItems(navigation.uid).pipe(tap((items) => {
                if (items === undefined) {
                    this.loadNavigationEntryItems(navigation, true);
                }
                else {
                    // we should check whether the existing node items are what expected
                    const expectedItems = [];
                    this.loadNavigationEntryItems(navigation, false, expectedItems);
                    const existingItems = Object.keys(items).map((key) => items[key].uid);
                    const missingItems = expectedItems.filter((it) => !existingItems.includes(it.id));
                    if (missingItems.length > 0) {
                        this.cmsService.loadNavigationItems(navigation.uid, missingItems);
                    }
                }
            }), filter(Boolean), map((items) => this.populateNavigationNode(navigation, items)));
        }));
    }
    /**
     * Loads all navigation entry items' type and id. Dispatch action to load all these items
     * @param nodeData
     * @param root
     * @param itemsList
     */
    loadNavigationEntryItems(nodeData, root, itemsList = []) {
        if (nodeData.entries && nodeData.entries.length > 0) {
            nodeData.entries.forEach((entry) => {
                itemsList.push({
                    superType: entry.itemSuperType,
                    id: entry.itemId,
                });
            });
        }
        if (nodeData.children && nodeData.children.length > 0) {
            nodeData.children.forEach((child) => this.loadNavigationEntryItems(child, false, itemsList));
        }
        if (root) {
            this.cmsService.loadNavigationItems(nodeData.uid, itemsList);
        }
    }
    /**
     * Create a new node tree for the view
     * @param nodeData
     * @param items
     */
    populateNavigationNode(nodeData, items) {
        var _a;
        const node = {};
        if (nodeData.title) {
            // the node title will be populated by the first entry (if any)
            // if there's no nodeData.title available
            node.title = nodeData.title;
        }
        // populate style classes to apply CMS driven styling
        if (nodeData.styleClasses) {
            node.styleClasses = nodeData.styleClasses;
        }
        // populate style attributes to apply CMS driven styling
        if (nodeData.styleAttributes) {
            node.styleAttributes = nodeData.styleAttributes;
        }
        if (nodeData.entries && nodeData.entries.length > 0) {
            this.populateLink(node, nodeData.entries[0], items);
        }
        if (((_a = nodeData.children) === null || _a === void 0 ? void 0 : _a.length) > 0) {
            const children = nodeData.children
                .map((child) => this.populateNavigationNode(child, items))
                .filter(Boolean);
            if (children.length > 0) {
                node.children = children;
            }
        }
        // return null in case there are no children
        return Object.keys(node).length === 0 ? null : node;
    }
    /**
     * The node link is driven by the first entry.
     */
    populateLink(node, entry, items) {
        const item = items[`${entry.itemId}_${entry.itemSuperType}`];
        // now we only consider CMSLinkComponent
        if (item && entry.itemType === 'CMSLinkComponent') {
            if (!node.title) {
                node.title = item.linkName;
            }
            const url = this.getLink(item);
            // only populate the node link if we have a visible node
            if (node.title && url) {
                node.url = url;
                // the backend provide boolean value for the target
                // in case the link should be opened in a new window
                if (item.target === 'true' || item.target === true) {
                    node.target = '_blank';
                }
            }
            // populate style classes to apply CMS driven styling
            if (item.styleClasses) {
                node.styleClasses = item.styleClasses;
            }
            // populate style attributes to apply CMS driven styling
            if (item.styleAttributes) {
                node.styleAttributes = item.styleAttributes;
            }
        }
    }
    /**
     *
     * Gets the URL or link to a related item (category),
     * also taking into account content pages (contentPageLabelOrId)
     * and product pages (productCode)
     */
    getLink(item) {
        if (item.url) {
            return item.url;
        }
        else if (item.contentPageLabelOrId) {
            return item.contentPageLabelOrId;
        }
        else if (item.categoryCode) {
            return this.semanticPathService.transform({
                cxRoute: 'category',
                params: {
                    code: item.categoryCode,
                    name: item.name,
                },
            });
        }
        else if (item.productCode) {
            return this.semanticPathService.transform({
                cxRoute: 'product',
                params: {
                    code: item.productCode,
                    name: item.name,
                },
            });
        }
    }
}
NavigationService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: NavigationService, deps: [{ token: i1.CmsService }, { token: i1.SemanticPathService }], target: i0.ɵɵFactoryTarget.Injectable });
NavigationService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: NavigationService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: NavigationService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.CmsService }, { type: i1.SemanticPathService }]; } });

class HamburgerMenuService {
    constructor(router) {
        this.isExpanded = new BehaviorSubject(false);
        router.events
            .pipe(filter((event) => event instanceof NavigationStart))
            .subscribe(() => {
            this.toggle(true);
        });
    }
    /**
     * toggles the expand state of the hamburger menu
     */
    toggle(forceCollapse) {
        if (forceCollapse) {
            this.isExpanded.next(false);
        }
        else {
            this.isExpanded.next(!this.isExpanded.value);
        }
    }
}
HamburgerMenuService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: HamburgerMenuService, deps: [{ token: i1$1.Router }], target: i0.ɵɵFactoryTarget.Injectable });
HamburgerMenuService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: HamburgerMenuService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: HamburgerMenuService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1$1.Router }]; } });

class NavigationUIComponent {
    constructor(router, renderer, elemRef, hamburgerMenuService) {
        this.router = router;
        this.renderer = renderer;
        this.elemRef = elemRef;
        this.hamburgerMenuService = hamburgerMenuService;
        /**
         * the icon type that will be used for navigation nodes
         * with children.
         */
        this.iconType = ICON_TYPE;
        /**
         * Indicates whether the navigation should support flyout.
         * If flyout is set to true, the
         * nested child navigation nodes will only appear on hover or focus.
         */
        this.flyout = true;
        this.isOpen = false;
        this.openNodes = [];
        this.subscriptions = new Subscription();
        this.resize = new EventEmitter();
        this.subscriptions.add(this.router.events
            .pipe(filter((event) => event instanceof NavigationEnd))
            .subscribe(() => this.clear()));
        this.subscriptions.add(this.resize.pipe(debounceTime(50)).subscribe(() => {
            this.alignWrappersToRightIfStickOut();
        }));
    }
    onResize() {
        this.resize.next();
    }
    /**
     * During initialization of this component, we will check the resetMenuOnClose flag and attach a menu reset listener if needed.
     */
    ngOnInit() {
        if (this.resetMenuOnClose) {
            this.resetOnMenuCollapse();
        }
    }
    /**
     * This method performs the action of resetting the menu (close all sub menus and return to main options)
     * when the menu is closed.
     */
    resetOnMenuCollapse() {
        var _a;
        this.subscriptions.add((_a = this.hamburgerMenuService) === null || _a === void 0 ? void 0 : _a.isExpanded.pipe(distinctUntilChanged(), filter(Boolean)).subscribe(() => {
            this.reinitalizeMenu();
        }));
    }
    /**
     * This method performs the actions required to reset the state of the menu and reset any visual components.
     */
    reinitalizeMenu() {
        var _a;
        if (((_a = this.openNodes) === null || _a === void 0 ? void 0 : _a.length) > 0) {
            this.clear();
            this.renderer.removeClass(this.elemRef.nativeElement, 'is-open');
        }
    }
    toggleOpen(event) {
        if (event.type === 'keydown') {
            event.preventDefault();
        }
        const node = event.currentTarget;
        if (this.openNodes.includes(node)) {
            if (event.type === 'keydown') {
                this.back();
            }
            else {
                this.openNodes = this.openNodes.filter((n) => n !== node);
                this.renderer.removeClass(node, 'is-open');
            }
        }
        else {
            this.openNodes.push(node);
        }
        this.updateClasses();
        event.stopImmediatePropagation();
        event.stopPropagation();
    }
    back() {
        if (this.openNodes[this.openNodes.length - 1]) {
            this.renderer.removeClass(this.openNodes[this.openNodes.length - 1], 'is-open');
            this.openNodes.pop();
            this.updateClasses();
        }
    }
    clear() {
        this.openNodes = [];
        this.updateClasses();
    }
    onMouseEnter(event) {
        this.alignWrapperToRightIfStickOut(event.currentTarget);
        this.focusAfterPreviousClicked(event);
    }
    getTotalDepth(node, depth = 0) {
        if (node.children && node.children.length > 0) {
            return Math.max(...node.children.map((n) => this.getTotalDepth(n, depth + 1)));
        }
        else {
            return depth;
        }
    }
    getColumnCount(length) {
        return Math.round(length / (this.wrapAfter || length));
    }
    focusAfterPreviousClicked(event) {
        const target = ((event.target || event.relatedTarget));
        if (target.ownerDocument.activeElement.matches('nav[tabindex]') &&
            target.parentElement.matches('.flyout')) {
            target.focus();
        }
        return target.ownerDocument;
    }
    ngOnDestroy() {
        if (this.subscriptions) {
            this.subscriptions.unsubscribe();
        }
    }
    alignWrapperToRightIfStickOut(node) {
        const wrapper = node.querySelector('.wrapper');
        const body = node.closest('body');
        if (wrapper) {
            this.renderer.removeStyle(wrapper, 'margin-left');
            if (wrapper.offsetLeft + wrapper.offsetWidth >
                body.offsetLeft + body.offsetWidth) {
                this.renderer.setStyle(wrapper, 'margin-left', `${node.offsetWidth - wrapper.offsetWidth}px`);
            }
        }
    }
    alignWrappersToRightIfStickOut() {
        const navs = this.elemRef.nativeElement.childNodes;
        Array.from(navs)
            .filter((node) => node.tagName === 'NAV')
            .forEach((nav) => this.alignWrapperToRightIfStickOut(nav));
    }
    updateClasses() {
        this.openNodes.forEach((node, i) => {
            if (i + 1 < this.openNodes.length) {
                this.renderer.addClass(node, 'is-opened');
                this.renderer.removeClass(node, 'is-open');
            }
            else {
                this.renderer.removeClass(node, 'is-opened');
                this.renderer.addClass(node, 'is-open');
            }
        });
        this.isOpen = this.openNodes.length > 0;
    }
}
NavigationUIComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: NavigationUIComponent, deps: [{ token: i1$1.Router }, { token: i0.Renderer2 }, { token: i0.ElementRef }, { token: HamburgerMenuService }], target: i0.ɵɵFactoryTarget.Component });
NavigationUIComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: NavigationUIComponent, selector: "cx-navigation-ui", inputs: { node: "node", wrapAfter: "wrapAfter", resetMenuOnClose: "resetMenuOnClose", flyout: "flyout", isOpen: "isOpen" }, host: { listeners: { "window:resize": "onResize()" }, properties: { "class.flyout": "this.flyout", "class.is-open": "this.isOpen" } }, ngImport: i0, template: "<div\n  *ngIf=\"flyout && node?.children.length > 1\"\n  class=\"back is-open\"\n  (click)=\"back()\"\n>\n  <span>\n    <cx-icon [type]=\"iconType.CARET_LEFT\"></cx-icon>\n    {{ 'common.back' | cxTranslate }}\n  </span>\n</div>\n\n<ng-container *ngFor=\"let child of node?.children\">\n  <ng-container *ngTemplateOutlet=\"nav; context: { node: child, depth: 0 }\">\n  </ng-container>\n</ng-container>\n\n<!-- we generate links in a recursive manner -->\n<ng-template #nav let-node=\"node\" let-depth=\"depth\">\n  <nav\n    (click)=\"toggleOpen($event)\"\n    (mouseenter)=\"onMouseEnter($event)\"\n    (keydown.space)=\"toggleOpen($event)\"\n    (keydown.esc)=\"back()\"\n  >\n    <cx-generic-link\n      *ngIf=\"\n        node.url && (!node.children || node.children?.length === 0);\n        else heading\n      \"\n      [url]=\"node.url\"\n      [target]=\"node.target\"\n      [style]=\"node.styleAttributes\"\n      [class]=\"node.styleClasses\"\n    >\n      {{ node.title }}\n      <cx-icon\n        *ngIf=\"flyout && node.children?.length > 0\"\n        [type]=\"iconType.CARET_DOWN\"\n      ></cx-icon>\n    </cx-generic-link>\n\n    <ng-template #heading>\n      <span [attr.tabindex]=\"flyout && (depth === 0 || node.url) ? 0 : -1\">\n        {{ node.title }}\n        <cx-icon\n          *ngIf=\"flyout && node.children?.length > 0\"\n          [type]=\"iconType.CARET_DOWN\"\n        ></cx-icon>\n      </span>\n    </ng-template>\n\n    <!-- we add a wrapper to allow for better layout handling in CSS -->\n    <div class=\"wrapper\" *ngIf=\"node.children?.length > 0\">\n      <cx-generic-link\n        *ngIf=\"node.url\"\n        [url]=\"node.url\"\n        [target]=\"node.target\"\n        class=\"all\"\n      >\n        {{ 'navigation.shopAll' | cxTranslate: { navNode: node.title } }}\n      </cx-generic-link>\n      <div\n        class=\"childs\"\n        [attr.depth]=\"getTotalDepth(node)\"\n        [attr.wrap-after]=\"node.children?.length > wrapAfter ? wrapAfter : null\"\n        [attr.columns]=\"getColumnCount(node.children?.length)\"\n      >\n        <ng-container *ngFor=\"let child of node.children\">\n          <ng-container\n            *ngTemplateOutlet=\"nav; context: { node: child, depth: depth + 1 }\"\n          >\n          </ng-container>\n        </ng-container>\n      </div>\n    </div>\n  </nav>\n</ng-template>\n", components: [{ type: IconComponent, selector: "cx-icon,[cxIcon]", inputs: ["cxIcon", "type"] }, { type: GenericLinkComponent, selector: "cx-generic-link", inputs: ["url", "target", "id", "class", "style", "title"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i3.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }], pipes: { "cxTranslate": i1.TranslatePipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: NavigationUIComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-navigation-ui',
                    templateUrl: './navigation-ui.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: i1$1.Router }, { type: i0.Renderer2 }, { type: i0.ElementRef }, { type: HamburgerMenuService }]; }, propDecorators: { node: [{
                type: Input
            }], wrapAfter: [{
                type: Input
            }], resetMenuOnClose: [{
                type: Input
            }], flyout: [{
                type: Input
            }, {
                type: HostBinding,
                args: ['class.flyout']
            }], isOpen: [{
                type: Input
            }, {
                type: HostBinding,
                args: ['class.is-open']
            }], onResize: [{
                type: HostListener,
                args: ['window:resize']
            }] } });

class CategoryNavigationComponent {
    constructor(componentData, service) {
        this.componentData = componentData;
        this.service = service;
        this.node$ = this.service.getNavigationNode(this.componentData.data$);
        this.data$ = this.componentData.data$;
    }
}
CategoryNavigationComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CategoryNavigationComponent, deps: [{ token: CmsComponentData }, { token: NavigationService }], target: i0.ɵɵFactoryTarget.Component });
CategoryNavigationComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: CategoryNavigationComponent, selector: "cx-category-navigation", ngImport: i0, template: "<cx-navigation-ui\n  *ngIf=\"data$ | async as data\"\n  [node]=\"node$ | async\"\n  [ngClass]=\"data.styleClass\"\n  [wrapAfter]=\"data.wrapAfter\"\n  [resetMenuOnClose]=\"data.resetMenuOnClose\"\n></cx-navigation-ui>\n", components: [{ type: NavigationUIComponent, selector: "cx-navigation-ui", inputs: ["node", "wrapAfter", "resetMenuOnClose", "flyout", "isOpen"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }], pipes: { "async": i3.AsyncPipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CategoryNavigationComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-category-navigation',
                    templateUrl: './category-navigation.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: CmsComponentData }, { type: NavigationService }]; } });

class NavigationComponent {
    constructor(componentData, service) {
        this.componentData = componentData;
        this.service = service;
        this.node$ = this.service.createNavigation(this.componentData.data$);
        this.styleClass$ = this.componentData.data$.pipe(map((d) => d === null || d === void 0 ? void 0 : d.styleClass));
    }
}
NavigationComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: NavigationComponent, deps: [{ token: CmsComponentData }, { token: NavigationService }], target: i0.ɵɵFactoryTarget.Component });
NavigationComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: NavigationComponent, selector: "cx-navigation", ngImport: i0, template: "<cx-navigation-ui [node]=\"node$ | async\" [ngClass]=\"styleClass$ | async\">\n</cx-navigation-ui>\n", components: [{ type: NavigationUIComponent, selector: "cx-navigation-ui", inputs: ["node", "wrapAfter", "resetMenuOnClose", "flyout", "isOpen"] }], directives: [{ type: i3.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }], pipes: { "async": i3.AsyncPipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: NavigationComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-navigation',
                    templateUrl: './navigation.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: CmsComponentData }, { type: NavigationService }]; } });

class NavigationModule {
}
NavigationModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: NavigationModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
NavigationModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: NavigationModule, declarations: [NavigationComponent, NavigationUIComponent], imports: [CommonModule,
        RouterModule,
        IconModule,
        GenericLinkModule,
        I18nModule], exports: [NavigationComponent, NavigationUIComponent] });
NavigationModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: NavigationModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                NavigationComponent: {
                    component: NavigationComponent,
                },
            },
        }),
    ], imports: [[
            CommonModule,
            RouterModule,
            IconModule,
            GenericLinkModule,
            I18nModule,
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: NavigationModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        RouterModule,
                        IconModule,
                        GenericLinkModule,
                        I18nModule,
                    ],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                NavigationComponent: {
                                    component: NavigationComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [NavigationComponent, NavigationUIComponent],
                    exports: [NavigationComponent, NavigationUIComponent],
                }]
        }] });

class CategoryNavigationModule {
}
CategoryNavigationModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CategoryNavigationModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
CategoryNavigationModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CategoryNavigationModule, declarations: [CategoryNavigationComponent], imports: [CommonModule, NavigationModule], exports: [CategoryNavigationComponent] });
CategoryNavigationModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CategoryNavigationModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                CategoryNavigationComponent: {
                    component: CategoryNavigationComponent,
                    data: {
                        resetMenuOnClose: true,
                    },
                },
            },
        }),
    ], imports: [[CommonModule, NavigationModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CategoryNavigationModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, NavigationModule],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                CategoryNavigationComponent: {
                                    component: CategoryNavigationComponent,
                                    data: {
                                        resetMenuOnClose: true,
                                    },
                                },
                            },
                        }),
                    ],
                    declarations: [CategoryNavigationComponent],
                    exports: [CategoryNavigationComponent],
                }]
        }] });

class FooterNavigationComponent {
    constructor(componentData, service) {
        this.componentData = componentData;
        this.service = service;
        this.node$ = this.service.getNavigationNode(this.componentData.data$);
        this.styleClass$ = this.componentData.data$.pipe(map((d) => d === null || d === void 0 ? void 0 : d.styleClass));
    }
}
FooterNavigationComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: FooterNavigationComponent, deps: [{ token: CmsComponentData }, { token: NavigationService }], target: i0.ɵɵFactoryTarget.Component });
FooterNavigationComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: FooterNavigationComponent, selector: "cx-footer-navigation", ngImport: i0, template: "<cx-navigation-ui\n  [node]=\"node$ | async\"\n  [flyout]=\"false\"\n  [ngClass]=\"styleClass$ | async\"\n></cx-navigation-ui>\n", components: [{ type: NavigationUIComponent, selector: "cx-navigation-ui", inputs: ["node", "wrapAfter", "resetMenuOnClose", "flyout", "isOpen"] }], directives: [{ type: i3.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }], pipes: { "async": i3.AsyncPipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: FooterNavigationComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-footer-navigation',
                    templateUrl: './footer-navigation.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: CmsComponentData }, { type: NavigationService }]; } });

class FooterNavigationModule {
}
FooterNavigationModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: FooterNavigationModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
FooterNavigationModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: FooterNavigationModule, declarations: [FooterNavigationComponent], imports: [CommonModule,
        RouterModule,
        NavigationModule,
        GenericLinkModule,
        I18nModule], exports: [FooterNavigationComponent] });
FooterNavigationModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: FooterNavigationModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                FooterNavigationComponent: {
                    component: FooterNavigationComponent,
                },
            },
        }),
    ], imports: [[
            CommonModule,
            RouterModule,
            NavigationModule,
            GenericLinkModule,
            I18nModule,
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: FooterNavigationModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        RouterModule,
                        NavigationModule,
                        GenericLinkModule,
                        I18nModule,
                    ],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                FooterNavigationComponent: {
                                    component: FooterNavigationComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [FooterNavigationComponent],
                    exports: [FooterNavigationComponent],
                }]
        }] });

class PageTitleModule {
}
PageTitleModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PageTitleModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
PageTitleModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PageTitleModule, declarations: [PageTitleComponent], imports: [CommonModule, RouterModule, PageMetaModule], exports: [PageTitleComponent] });
PageTitleModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PageTitleModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                PageTitleComponent: {
                    component: PageTitleComponent,
                },
            },
        }),
    ], imports: [[CommonModule, RouterModule, PageMetaModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: PageTitleModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, RouterModule, PageMetaModule],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                PageTitleComponent: {
                                    component: PageTitleComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [PageTitleComponent],
                    exports: [PageTitleComponent],
                    entryComponents: [PageTitleComponent],
                }]
        }] });

class HighlightPipe {
    transform(text, match) {
        if (!match) {
            return text;
        }
        return text.replace(match.trim(), `<span class="highlight">${match.trim()}</span>`);
    }
}
HighlightPipe.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: HighlightPipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe });
HighlightPipe.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: HighlightPipe, name: "cxHighlight" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: HighlightPipe, decorators: [{
            type: Pipe,
            args: [{ name: 'cxHighlight' }]
        }] });

/**
 * Indicates that the user chose a suggestion
 */
class SearchBoxSuggestionSelectedEvent extends CxEvent {
}
/**
 * Event's type
 */
SearchBoxSuggestionSelectedEvent.type = 'SearchBoxSuggestionSelectedEvent';
/**
 * Indicates that the user chose a product suggestion
 */
class SearchBoxProductSelectedEvent extends CxEvent {
}
/**
 * Event's type
 */
SearchBoxProductSelectedEvent.type = 'SearchBoxProductSelectedEvent';

const HAS_SEARCH_RESULT_CLASS = 'has-searchbox-results';
class SearchBoxComponentService {
    constructor(searchService, routingService, translationService, winRef, eventService) {
        this.searchService = searchService;
        this.routingService = routingService;
        this.translationService = translationService;
        this.winRef = winRef;
        this.eventService = eventService;
    }
    /**
     * Executes the search for products and suggestions,
     * unless the configuration is setup to not search for
     * products or suggestions.
     */
    search(query, config) {
        if (!query || query === '') {
            this.clearResults();
            return;
        }
        if (config.minCharactersBeforeRequest &&
            query.length < config.minCharactersBeforeRequest) {
            return;
        }
        if (config.displayProducts) {
            this.searchService.search(query, {
                pageSize: config.maxProducts,
            });
        }
        if (config.displaySuggestions) {
            this.searchService.searchSuggestions(query, {
                pageSize: config.maxSuggestions,
            });
        }
    }
    /**
     * Returns an observable with the SearchResults. When there's any
     * result, the body tag will get a classname, so that specific style
     * rules can be applied.
     */
    getResults(config) {
        return combineLatest([
            this.getProductResults(config),
            this.getProductSuggestions(config),
            this.getSearchMessage(config),
        ]).pipe(map(([productResults, suggestions, message]) => {
            return {
                products: productResults ? productResults.products : null,
                suggestions,
                message,
            };
        }), tap((results) => this.toggleBodyClass(HAS_SEARCH_RESULT_CLASS, this.hasResults(results))));
    }
    /**
     * Clears the searchbox results, so that old values are
     * no longer emited upon next search.
     */
    clearResults() {
        this.searchService.clearResults();
        this.toggleBodyClass(HAS_SEARCH_RESULT_CLASS, false);
    }
    hasBodyClass(className) {
        return this.winRef.document.body.classList.contains(className);
    }
    toggleBodyClass(className, add) {
        if (add === undefined) {
            this.winRef.document.body.classList.toggle(className);
        }
        else {
            add
                ? this.winRef.document.body.classList.add(className)
                : this.winRef.document.body.classList.remove(className);
        }
    }
    /**
     * Dispatches a searchbox event for product selected
     *
     * @param eventData data for the "SearchBoxProductSelectedEvent"
     */
    dispatchProductSelectedEvent(eventData) {
        this.eventService.dispatch({
            freeText: eventData.freeText,
            productCode: eventData.productCode,
        }, SearchBoxProductSelectedEvent);
    }
    /**
     * Dispatches a searchbox event for suggestion selected
     *
     * @param eventData data for the "SearchBoxSuggestionSelectedEvent"
     */
    dispatchSuggestionSelectedEvent(eventData) {
        this.eventService.dispatch({
            freeText: eventData.freeText,
            selectedSuggestion: eventData.selectedSuggestion,
            searchSuggestions: eventData.searchSuggestions,
        }, SearchBoxSuggestionSelectedEvent);
    }
    /**
     * For search results model, it returns true when:
     * * there is any product OR
     * * the is any search suggestion OR
     * * there is a message.
     *
     * Otherwise it returns false.
     */
    hasResults(results) {
        return ((!!results.products && results.products.length > 0) ||
            (!!results.suggestions && results.suggestions.length > 0) ||
            !!results.message);
    }
    /**
     * Emits product search results in case when the config property `displayProducts` is true.
     * Otherwise it emits an empty object.
     */
    getProductResults(config) {
        if (config.displayProducts) {
            return this.searchService.getResults();
        }
        else {
            return of({});
        }
    }
    /**
     * Loads suggestions from the backend. In case there's no suggestion
     * available, we try to get an exact match suggestion.
     */
    getProductSuggestions(config) {
        if (!config.displaySuggestions) {
            return of([]);
        }
        else {
            return this.searchService.getSuggestionResults().pipe(map((res) => res.map((suggestion) => suggestion.value)), switchMap((suggestions) => {
                if (suggestions.length === 0) {
                    return this.getExactSuggestion(config).pipe(map((match) => (match ? [match] : [])));
                }
                else {
                    return of(suggestions);
                }
            }));
        }
    }
    /**
     * Whenever there is at least 1 product, we simulate
     * a suggestion to provide easy access to the search result page
     */
    getExactSuggestion(config) {
        return this.getProductResults(config).pipe(switchMap((productResult) => {
            return productResult.products && productResult.products.length > 0
                ? this.fetchTranslation('searchBox.help.exactMatch', {
                    term: productResult.freeTextSearch,
                })
                : of(null);
        }));
    }
    /**
     * Emits a 'no match' message, in case the product search results and search suggestions are empty.
     * Otherwise it emits null.
     */
    getSearchMessage(config) {
        return combineLatest([
            this.getProductResults(config),
            this.getProductSuggestions(config),
        ]).pipe(switchMap(([productResult, suggestions]) => {
            if (productResult &&
                productResult.products &&
                productResult.products.length === 0 &&
                suggestions &&
                suggestions.length === 0) {
                return this.fetchTranslation('searchBox.help.noMatch');
            }
            else {
                return of(null);
            }
        }));
    }
    /**
     * Navigates to the search result page with a given query
     */
    launchSearchPage(query) {
        this.routingService.go({
            cxRoute: 'search',
            params: { query },
        });
    }
    fetchTranslation(translationKey, options) {
        return this.translationService.translate(translationKey, options);
    }
}
SearchBoxComponentService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SearchBoxComponentService, deps: [{ token: i1.SearchboxService }, { token: i1.RoutingService }, { token: i1.TranslationService }, { token: i1.WindowRef }, { token: i1.EventService }], target: i0.ɵɵFactoryTarget.Injectable });
SearchBoxComponentService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SearchBoxComponentService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SearchBoxComponentService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.SearchboxService }, { type: i1.RoutingService }, { type: i1.TranslationService }, { type: i1.WindowRef }, { type: i1.EventService }]; } });

const DEFAULT_SEARCH_BOX_CONFIG = {
    minCharactersBeforeRequest: 1,
    displayProducts: true,
    displaySuggestions: true,
    maxProducts: 5,
    maxSuggestions: 5,
    displayProductImages: true,
};
class SearchBoxComponent {
    constructor(searchBoxComponentService, componentData, winRef, routingService) {
        var _a;
        this.searchBoxComponentService = searchBoxComponentService;
        this.componentData = componentData;
        this.winRef = winRef;
        this.routingService = routingService;
        this.iconTypes = ICON_TYPE;
        /**
         * In some occasions we need to ignore the close event,
         * for example when we click inside the search result section.
         */
        this.ignoreCloseEvent = false;
        this.chosenWord = '';
        /**
         * Returns the SearchBox configuration. The configuration is driven by multiple
         * layers: default configuration, (optional) backend configuration and (optional)
         * input configuration.
         */
        this.config$ = (((_a = this.componentData) === null || _a === void 0 ? void 0 : _a.data$) || of({})).pipe(map((config) => {
            const isBool = (obj, prop) => (obj === null || obj === void 0 ? void 0 : obj[prop]) !== 'false' && (obj === null || obj === void 0 ? void 0 : obj[prop]) !== false;
            return Object.assign(Object.assign(Object.assign(Object.assign({}, DEFAULT_SEARCH_BOX_CONFIG), config), { displayProducts: isBool(config, 'displayProducts'), displayProductImages: isBool(config, 'displayProductImages'), displaySuggestions: isBool(config, 'displaySuggestions') }), this.config);
        }), tap((config) => (this.config = config)));
        this.results$ = this.config$.pipe(switchMap((config) => this.searchBoxComponentService.getResults(config)));
    }
    /**
     * Sets the search box input field
     */
    set queryText(value) {
        if (value) {
            this.search(value);
        }
    }
    ngOnInit() {
        this.subscription = this.routingService
            .getRouterState()
            .pipe(filter((data) => !data.nextState))
            .subscribe((data) => {
            var _a, _b;
            if (!(((_a = data.state.context) === null || _a === void 0 ? void 0 : _a.id) === 'search' &&
                ((_b = data.state.context) === null || _b === void 0 ? void 0 : _b.type) === PageType.CONTENT_PAGE))
                this.chosenWord = '';
        });
    }
    /**
     * Closes the searchBox and opens the search result page.
     */
    search(query) {
        this.searchBoxComponentService.search(query, this.config);
        // force the searchBox to open
        this.open();
    }
    /**
     * Opens the type-ahead searchBox
     */
    open() {
        this.searchBoxComponentService.toggleBodyClass('searchbox-is-active', true);
    }
    /**
     * Dispatch UI events for Suggestion selected
     *
     * @param eventData the data for the event
     */
    dispatchSuggestionEvent(eventData) {
        this.searchBoxComponentService.dispatchSuggestionSelectedEvent(eventData);
    }
    /**
     * Dispatch UI events for Product selected
     *
     * @param eventData the data for the event
     */
    dispatchProductEvent(eventData) {
        this.searchBoxComponentService.dispatchProductSelectedEvent(eventData);
    }
    /**
     * Closes the type-ahead searchBox.
     */
    close(event, force) {
        // Use timeout to detect changes
        setTimeout(() => {
            if ((!this.ignoreCloseEvent && !this.isSearchBoxFocused()) || force) {
                this.blurSearchBox(event);
            }
        });
    }
    blurSearchBox(event) {
        this.searchBoxComponentService.toggleBodyClass('searchbox-is-active', false);
        if (event && event.target) {
            event.target.blur();
        }
    }
    // Check if focus is on searchbox or result list elements
    isSearchBoxFocused() {
        return (this.getResultElements().includes(this.getFocusedElement()) ||
            this.winRef.document.querySelector('input[aria-label="Search"]') ===
                this.getFocusedElement());
    }
    /**
     * Especially in mobile we do not want the search icon
     * to focus the input again when it's already open.
     * */
    avoidReopen(event) {
        if (this.searchBoxComponentService.hasBodyClass('searchbox-is-active')) {
            this.close(event);
            event.preventDefault();
        }
    }
    // Return result list as HTMLElement array
    getResultElements() {
        return Array.from(this.winRef.document.querySelectorAll('.products > li a, .suggestions > li a'));
    }
    // Return focused element as HTMLElement
    getFocusedElement() {
        return this.winRef.document.activeElement;
    }
    updateChosenWord(chosenWord) {
        this.chosenWord = chosenWord;
    }
    getFocusedIndex() {
        return this.getResultElements().indexOf(this.getFocusedElement());
    }
    // Focus on previous item in results list
    focusPreviousChild(event) {
        event.preventDefault(); // Negate normal keyscroll
        const [results, focusedIndex] = [
            this.getResultElements(),
            this.getFocusedIndex(),
        ];
        // Focus on last index moving to first
        if (results.length) {
            if (focusedIndex < 1) {
                results[results.length - 1].focus();
            }
            else {
                results[focusedIndex - 1].focus();
            }
        }
    }
    // Focus on next item in results list
    focusNextChild(event) {
        this.open();
        event.preventDefault(); // Negate normal keyscroll
        const [results, focusedIndex] = [
            this.getResultElements(),
            this.getFocusedIndex(),
        ];
        // Focus on first index moving to last
        if (results.length) {
            if (focusedIndex >= results.length - 1) {
                results[0].focus();
            }
            else {
                results[focusedIndex + 1].focus();
            }
        }
    }
    /**
     * Opens the PLP with the given query.
     *
     * TODO: if there's a single product match, we could open the PDP.
     */
    launchSearchResult(event, query) {
        if (!query || query.trim().length === 0) {
            return;
        }
        this.close(event);
        this.searchBoxComponentService.launchSearchPage(query);
    }
    /**
     * Disables closing the search result list.
     */
    disableClose() {
        this.ignoreCloseEvent = true;
    }
    preventDefault(ev) {
        ev.preventDefault();
    }
    /**
     * Clears the search box input field
     */
    clear(el) {
        this.disableClose();
        el.value = '';
        this.searchBoxComponentService.clearResults();
        // Use Timeout to run after blur event to prevent the searchbox from closing on mobile
        setTimeout(() => {
            // Retain focus on input lost by clicking on icon
            el.focus();
            this.ignoreCloseEvent = false;
        });
    }
    ngOnDestroy() {
        var _a;
        (_a = this.subscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();
    }
}
SearchBoxComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SearchBoxComponent, deps: [{ token: SearchBoxComponentService }, { token: CmsComponentData, optional: true }, { token: i1.WindowRef }, { token: i1.RoutingService }], target: i0.ɵɵFactoryTarget.Component });
SearchBoxComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: SearchBoxComponent, selector: "cx-searchbox", inputs: { config: "config", queryText: "queryText" }, ngImport: i0, template: "<label class=\"searchbox\" [class.dirty]=\"!!searchInput.value\">\n  <input\n    #searchInput\n    [placeholder]=\"'searchBox.placeholder' | cxTranslate\"\n    autocomplete=\"off\"\n    aria-describedby=\"initialDescription\"\n    aria-controls=\"results\"\n    [attr.aria-label]=\"'common.search' | cxTranslate\"\n    (focus)=\"open()\"\n    (click)=\"open()\"\n    (input)=\"search(searchInput.value)\"\n    (blur)=\"close($event)\"\n    (keydown.escape)=\"close($event)\"\n    (keydown.enter)=\"\n      close($event, true);\n      launchSearchResult($event, searchInput.value);\n      updateChosenWord(searchInput.value)\n    \"\n    (keydown.arrowup)=\"focusPreviousChild($event)\"\n    (keydown.arrowdown)=\"focusNextChild($event)\"\n    value=\"{{ chosenWord }}\"\n  />\n\n  <button\n    [attr.aria-label]=\"'common.reset' | cxTranslate\"\n    (mousedown)=\"clear(searchInput)\"\n    (keydown.enter)=\"clear(searchInput)\"\n    class=\"reset\"\n  >\n    <cx-icon [type]=\"iconTypes.RESET\"></cx-icon>\n  </button>\n\n  <div role=\"presentation\" class=\"search-icon\">\n    <cx-icon [type]=\"iconTypes.SEARCH\"></cx-icon>\n  </div>\n\n  <button\n    [attr.aria-label]=\"'common.search' | cxTranslate\"\n    class=\"search\"\n    (click)=\"open()\"\n  >\n    <cx-icon [type]=\"iconTypes.SEARCH\"></cx-icon>\n  </button>\n</label>\n\n<div\n  *ngIf=\"results$ | async as result\"\n  class=\"results\"\n  id=\"results\"\n  (click)=\"close($event, true)\"\n  role=\"listbox\"\n>\n  <div\n    *ngIf=\"result.message\"\n    class=\"message\"\n    [innerHTML]=\"result.message\"\n  ></div>\n\n  <ul\n    class=\"suggestions\"\n    attr.aria-label=\"{{ 'searchBox.ariaLabelSuggestions' | cxTranslate }}\"\n    tabindex=\"0\"\n  >\n    <li *ngFor=\"let suggestion of result.suggestions\">\n      <a\n        [innerHTML]=\"suggestion | cxHighlight: searchInput.value\"\n        [routerLink]=\"\n          {\n            cxRoute: 'search',\n            params: { query: suggestion }\n          } | cxUrl\n        \"\n        (keydown.arrowup)=\"focusPreviousChild($event)\"\n        (keydown.arrowdown)=\"focusNextChild($event)\"\n        (keydown.enter)=\"close($event, true)\"\n        (keydown.escape)=\"close($event, true)\"\n        (blur)=\"close($event)\"\n        (mousedown)=\"preventDefault($event)\"\n        (click)=\"\n          dispatchSuggestionEvent({\n            freeText: searchInput.value,\n            selectedSuggestion: suggestion,\n            searchSuggestions: result.suggestions\n          });\n          updateChosenWord(suggestion)\n        \"\n      >\n      </a>\n    </li>\n  </ul>\n\n  <ul\n    class=\"products\"\n    *ngIf=\"result.products\"\n    attr.aria-label=\"{{ 'searchBox.ariaLabelProducts' | cxTranslate }}\"\n    tabindex=\"0\"\n  >\n    <li *ngFor=\"let product of result.products\">\n      <a\n        [routerLink]=\"\n          {\n            cxRoute: 'product',\n            params: product\n          } | cxUrl\n        \"\n        [class.has-media]=\"config.displayProductImages\"\n        (keydown.arrowup)=\"focusPreviousChild($event)\"\n        (keydown.arrowdown)=\"focusNextChild($event)\"\n        (keydown.enter)=\"close($event, true)\"\n        (keydown.escape)=\"close($event, true)\"\n        (blur)=\"close($event)\"\n        (mousedown)=\"preventDefault($event)\"\n        (click)=\"\n          dispatchProductEvent({\n            freeText: searchInput.value,\n            productCode: product.code\n          })\n        \"\n      >\n        <cx-media\n          *ngIf=\"config.displayProductImages\"\n          [container]=\"product.images?.PRIMARY\"\n          format=\"thumbnail\"\n          role=\"presentation\"\n        ></cx-media>\n        <div class=\"name\" [innerHTML]=\"product.nameHtml\"></div>\n        <span class=\"price\">{{ product.price?.formattedValue }}</span>\n      </a>\n    </li>\n  </ul>\n  <span id=\"initialDescription\" class=\"cx-visually-hidden\">\n    {{ 'searchBox.initialDescription' | cxTranslate }}\n  </span>\n  <div\n    *ngIf=\"result.suggestions?.length || result.products?.length\"\n    aria-live=\"assertive\"\n    class=\"cx-visually-hidden\"\n  >\n    {{\n      'searchBox.suggestionsResult'\n        | cxTranslate: { count: result.suggestions?.length }\n    }}\n    {{\n      'searchBox.productsResult'\n        | cxTranslate: { count: result.products?.length }\n    }}\n    {{ 'searchBox.initialDescription' | cxTranslate }}\n  </div>\n</div>\n", components: [{ type: IconComponent, selector: "cx-icon,[cxIcon]", inputs: ["cxIcon", "type"] }, { type: MediaComponent, selector: "cx-media", inputs: ["container", "format", "alt", "role", "loading"], outputs: ["loaded"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i1$1.RouterLinkWithHref, selector: "a[routerLink],area[routerLink]", inputs: ["routerLink", "target", "queryParams", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange", "replaceUrl", "state", "relativeTo"] }], pipes: { "cxTranslate": i1.TranslatePipe, "async": i3.AsyncPipe, "cxHighlight": HighlightPipe, "cxUrl": i1.UrlPipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SearchBoxComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-searchbox',
                    templateUrl: './search-box.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: SearchBoxComponentService }, { type: CmsComponentData, decorators: [{
                    type: Optional
                }] }, { type: i1.WindowRef }, { type: i1.RoutingService }]; }, propDecorators: { config: [{
                type: Input
            }], queryText: [{
                type: Input,
                args: ['queryText']
            }] } });

class SearchBoxModule {
}
SearchBoxModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SearchBoxModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
SearchBoxModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SearchBoxModule, declarations: [SearchBoxComponent, HighlightPipe], imports: [CommonModule,
        RouterModule,
        MediaModule,
        IconModule,
        UrlModule,
        I18nModule], exports: [SearchBoxComponent, HighlightPipe] });
SearchBoxModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SearchBoxModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                SearchBoxComponent: {
                    component: SearchBoxComponent,
                },
            },
        }),
    ], imports: [[
            CommonModule,
            RouterModule,
            MediaModule,
            IconModule,
            UrlModule,
            I18nModule,
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SearchBoxModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        RouterModule,
                        MediaModule,
                        IconModule,
                        UrlModule,
                        I18nModule,
                    ],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                SearchBoxComponent: {
                                    component: SearchBoxComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [SearchBoxComponent, HighlightPipe],
                    exports: [SearchBoxComponent, HighlightPipe],
                }]
        }] });

class ProductCarouselService {
    constructor(productService, semanticPathService) {
        this.productService = productService;
        this.semanticPathService = semanticPathService;
    }
    /**
     * Loads the product data and converts it `CarouselItem`.
     */
    loadProduct(code) {
        return this.productService.get(code).pipe(filter(Boolean), map((product) => this.convertProduct(product)));
    }
    /**
     * Converts the product to a generic CarouselItem
     */
    convertProduct(source, displayTitle = true, displayProductPrices = true) {
        const item = {};
        if (displayTitle) {
            item.title = source.name;
        }
        if (displayProductPrices && source.price && source.price.formattedValue) {
            item.price = source.price.formattedValue;
        }
        if (source.images && source.images.PRIMARY) {
            item.media = {
                container: source.images.PRIMARY,
                format: 'product',
            };
        }
        item.route = this.semanticPathService.transform({
            cxRoute: 'product',
            params: source,
        });
        return item;
    }
}
ProductCarouselService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductCarouselService, deps: [{ token: i1.ProductService }, { token: i1.SemanticPathService }], target: i0.ɵɵFactoryTarget.Injectable });
ProductCarouselService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductCarouselService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductCarouselService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.ProductService }, { type: i1.SemanticPathService }]; } });

class ProductCarouselComponent {
    constructor(componentData, productService) {
        this.componentData = componentData;
        this.productService = productService;
        this.PRODUCT_SCOPE = "list" /* LIST */;
        this.componentData$ = this.componentData.data$.pipe(filter(Boolean));
        /**
         * returns an Observable string for the title.
         */
        this.title$ = this.componentData$.pipe(map((data) => data.title));
        /**
         * Observable that holds an Array of Observables. This is done, so that
         * the component UI could consider to lazy load the UI components when they're
         * in the viewpoint.
         */
        this.items$ = this.componentData$.pipe(map((data) => { var _a, _b; return (_b = (_a = data.productCodes) === null || _a === void 0 ? void 0 : _a.trim().split(' ')) !== null && _b !== void 0 ? _b : []; }), map((codes) => codes.map((code) => this.productService.get(code, [this.PRODUCT_SCOPE, "price" /* PRICE */]))));
    }
}
ProductCarouselComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductCarouselComponent, deps: [{ token: CmsComponentData }, { token: i1.ProductService }], target: i0.ɵɵFactoryTarget.Component });
ProductCarouselComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: ProductCarouselComponent, selector: "cx-product-carousel", ngImport: i0, template: "<cx-carousel\n  [items]=\"items$ | async\"\n  [title]=\"title$ | async\"\n  [template]=\"carouselItem\"\n  itemWidth=\"285px\"\n>\n</cx-carousel>\n\n<ng-template #carouselItem let-item=\"item\">\n  <a tabindex=\"0\" [routerLink]=\"{ cxRoute: 'product', params: item } | cxUrl\">\n    <cx-media\n      [container]=\"item.images?.PRIMARY\"\n      format=\"product\"\n      [alt]=\"item.name\"\n    ></cx-media>\n    <h3>\n      {{ item.name }}\n    </h3>\n    <div class=\"price\">\n      {{ item.price?.formattedValue }}\n    </div>\n  </a>\n</ng-template>\n", components: [{ type: CarouselComponent, selector: "cx-carousel", inputs: ["title", "items", "template", "itemWidth", "hideIndicators", "indicatorIcon", "previousIcon", "nextIcon"] }, { type: MediaComponent, selector: "cx-media", inputs: ["container", "format", "alt", "role", "loading"], outputs: ["loaded"] }], directives: [{ type: i1$1.RouterLinkWithHref, selector: "a[routerLink],area[routerLink]", inputs: ["routerLink", "target", "queryParams", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange", "replaceUrl", "state", "relativeTo"] }], pipes: { "async": i3.AsyncPipe, "cxUrl": i1.UrlPipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductCarouselComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-product-carousel',
                    templateUrl: './product-carousel.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: CmsComponentData }, { type: i1.ProductService }]; } });

class ProductCarouselModule {
}
ProductCarouselModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductCarouselModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ProductCarouselModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductCarouselModule, declarations: [ProductCarouselComponent], imports: [CommonModule, CarouselModule, MediaModule, RouterModule, UrlModule], exports: [ProductCarouselComponent] });
ProductCarouselModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductCarouselModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                ProductCarouselComponent: {
                    component: ProductCarouselComponent,
                },
            },
        }),
    ], imports: [[CommonModule, CarouselModule, MediaModule, RouterModule, UrlModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductCarouselModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, CarouselModule, MediaModule, RouterModule, UrlModule],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                ProductCarouselComponent: {
                                    component: ProductCarouselComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [ProductCarouselComponent],
                    exports: [ProductCarouselComponent],
                }]
        }] });

class ProductReferencesComponent {
    constructor(cmsComponentData, currentProductService, productReferenceService) {
        this.cmsComponentData = cmsComponentData;
        this.currentProductService = currentProductService;
        this.productReferenceService = productReferenceService;
        /**
         * Observable with an Array of Observables. This is done so that
         * the component UI could consider to lazy load the UI components when they're
         * in the viewpoint.
         */
        this.items$ = this.productCode$.pipe(withLatestFrom(this.componentData$), tap(([productCode, data]) => this.productReferenceService.loadProductReferences(productCode, data === null || data === void 0 ? void 0 : data.productReferenceTypes)), switchMap(([productCode, data]) => this.getProductReferences(productCode, data === null || data === void 0 ? void 0 : data.productReferenceTypes)));
    }
    get componentData$() {
        return this.cmsComponentData.data$.pipe(filter(Boolean));
    }
    /**
     * Returns an Observable String for the product code
     */
    get productCode$() {
        return this.currentProductService.getProduct().pipe(filter(isNotNullable), map((product) => product.code), tap((_) => this.productReferenceService.cleanReferences()));
    }
    /**
     * Returns an Observable String for the title
     */
    get title$() {
        return this.componentData$.pipe(map((data) => data === null || data === void 0 ? void 0 : data.title));
    }
    /**
     * Returns an observable for product references
     */
    getProductReferences(code, referenceType) {
        return this.productReferenceService
            .getProductReferences(code, referenceType)
            .pipe(filter(Boolean), map((references) => references.map((reference) => of(reference.target))));
    }
}
ProductReferencesComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductReferencesComponent, deps: [{ token: CmsComponentData }, { token: CurrentProductService }, { token: i1.ProductReferenceService }], target: i0.ɵɵFactoryTarget.Component });
ProductReferencesComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: ProductReferencesComponent, selector: "cx-product-references", ngImport: i0, template: "<cx-carousel\n  [title]=\"title$ | async\"\n  [items]=\"items$ | async\"\n  [template]=\"carouselItem\"\n>\n</cx-carousel>\n\n<ng-template #carouselItem let-item=\"item\">\n  <a tabindex=\"0\" [routerLink]=\"{ cxRoute: 'product', params: item } | cxUrl\">\n    <cx-media [container]=\"item.images?.PRIMARY\" format=\"product\"></cx-media>\n    <h4>{{ item.name }}</h4>\n    <div class=\"price\">{{ item.price?.formattedValue }}</div>\n  </a>\n</ng-template>\n", components: [{ type: CarouselComponent, selector: "cx-carousel", inputs: ["title", "items", "template", "itemWidth", "hideIndicators", "indicatorIcon", "previousIcon", "nextIcon"] }, { type: MediaComponent, selector: "cx-media", inputs: ["container", "format", "alt", "role", "loading"], outputs: ["loaded"] }], directives: [{ type: i1$1.RouterLinkWithHref, selector: "a[routerLink],area[routerLink]", inputs: ["routerLink", "target", "queryParams", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange", "replaceUrl", "state", "relativeTo"] }], pipes: { "async": i3.AsyncPipe, "cxUrl": i1.UrlPipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductReferencesComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-product-references',
                    templateUrl: './product-references.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: CmsComponentData }, { type: CurrentProductService }, { type: i1.ProductReferenceService }]; } });

class ProductReferencesModule {
}
ProductReferencesModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductReferencesModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ProductReferencesModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductReferencesModule, declarations: [ProductReferencesComponent], imports: [CommonModule, CarouselModule, MediaModule, RouterModule, UrlModule], exports: [ProductReferencesComponent] });
ProductReferencesModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductReferencesModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                ProductReferencesComponent: {
                    component: ProductReferencesComponent,
                },
            },
        }),
    ], imports: [[CommonModule, CarouselModule, MediaModule, RouterModule, UrlModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductReferencesModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, CarouselModule, MediaModule, RouterModule, UrlModule],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                ProductReferencesComponent: {
                                    component: ProductReferencesComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [ProductReferencesComponent],
                    exports: [ProductReferencesComponent],
                }]
        }] });

const defaultViewConfig = {
    view: {
        defaultPageSize: 12,
        infiniteScroll: {
            active: false,
            productLimit: 0,
            showMoreButton: false,
        },
    },
};

class ProductImagesComponent {
    constructor(currentProductService) {
        this.currentProductService = currentProductService;
        this.mainMediaContainer = new BehaviorSubject(null);
        this.product$ = this.currentProductService
            .getProduct()
            .pipe(filter(isNotNullable), distinctUntilChanged(), tap((p) => {
            var _a;
            this.mainMediaContainer.next(((_a = p.images) === null || _a === void 0 ? void 0 : _a.PRIMARY) ? p.images.PRIMARY : {});
        }));
        this.thumbs$ = this.product$.pipe(map((p) => this.createThumbs(p)));
        this.mainImage$ = combineLatest([this.product$, this.mainMediaContainer]).pipe(map(([, container]) => container));
    }
    openImage(item) {
        this.mainMediaContainer.next(item);
    }
    isActive(thumbnail) {
        return this.mainMediaContainer.pipe(filter(Boolean), map((container) => {
            return (container.zoom &&
                container.zoom.url &&
                thumbnail.zoom &&
                thumbnail.zoom.url &&
                container.zoom.url === thumbnail.zoom.url);
        }));
    }
    /** find the index of the main media in the list of media */
    getActive(thumbs) {
        return this.mainMediaContainer.pipe(filter(Boolean), map((container) => {
            const current = thumbs.find((t) => t.media &&
                container.zoom &&
                t.media.container &&
                t.media.container.zoom &&
                t.media.container.zoom.url === container.zoom.url);
            return thumbs.indexOf(current);
        }));
    }
    /**
     * Return an array of CarouselItems for the product thumbnails.
     * In case there are less then 2 thumbs, we return null.
     */
    createThumbs(product) {
        if (!product.images ||
            !product.images.GALLERY ||
            product.images.GALLERY.length < 2) {
            return [];
        }
        return product.images.GALLERY.map((c) => of({ container: c }));
    }
}
ProductImagesComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductImagesComponent, deps: [{ token: CurrentProductService }], target: i0.ɵɵFactoryTarget.Component });
ProductImagesComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: ProductImagesComponent, selector: "cx-product-images", ngImport: i0, template: "<ng-container *ngIf=\"mainImage$ | async as main\">\n  <cx-media [container]=\"main\"></cx-media>\n</ng-container>\n\n<ng-container *ngIf=\"thumbs$ | async as thumbs\">\n  <cx-carousel\n    *ngIf=\"thumbs.length\"\n    class=\"thumbs\"\n    [items]=\"thumbs\"\n    itemWidth=\"120px\"\n    [hideIndicators]=\"false\"\n    [template]=\"thumb\"\n  ></cx-carousel>\n</ng-container>\n\n<ng-template #thumb let-item=\"item\">\n  <cx-media\n    [container]=\"item.container\"\n    tabindex=\"0\"\n    (focus)=\"openImage(item.container)\"\n    [class.is-active]=\"isActive(item.container) | async\"\n    format=\"product\"\n  >\n  </cx-media>\n</ng-template>\n", components: [{ type: MediaComponent, selector: "cx-media", inputs: ["container", "format", "alt", "role", "loading"], outputs: ["loaded"] }, { type: CarouselComponent, selector: "cx-carousel", inputs: ["title", "items", "template", "itemWidth", "hideIndicators", "indicatorIcon", "previousIcon", "nextIcon"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "async": i3.AsyncPipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductImagesComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-product-images',
                    templateUrl: './product-images.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: CurrentProductService }]; } });

class ProductImagesModule {
}
ProductImagesModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductImagesModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ProductImagesModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductImagesModule, declarations: [ProductImagesComponent], imports: [CommonModule,
        RouterModule,
        MediaModule,
        OutletModule,
        CarouselModule], exports: [ProductImagesComponent] });
ProductImagesModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductImagesModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                ProductImagesComponent: {
                    component: ProductImagesComponent,
                },
            },
        }),
    ], imports: [[
            CommonModule,
            RouterModule,
            MediaModule,
            OutletModule,
            CarouselModule,
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductImagesModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        RouterModule,
                        MediaModule,
                        OutletModule,
                        CarouselModule,
                    ],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                ProductImagesComponent: {
                                    component: ProductImagesComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [ProductImagesComponent],
                    exports: [ProductImagesComponent],
                }]
        }] });

class ProductIntroComponent {
    constructor(currentProductService, translationService, winRef) {
        this.currentProductService = currentProductService;
        this.translationService = translationService;
        this.winRef = winRef;
        this.reviewsTabAvailable = new BehaviorSubject(false);
        this.product$ = this.currentProductService.getProduct();
    }
    ngAfterContentChecked() {
        this.reviewsTabAvailable.next(!!this.getReviewsComponent());
    }
    // Scroll to views component on page and click "Reviews" tab
    showReviews() {
        // Use translated label for Reviews tab reference
        this.translationService
            .translate('TabPanelContainer.tabs.ProductReviewsTabComponent')
            .subscribe((reviewsTabLabel) => {
            const tabsComponent = this.getTabsComponent();
            const reviewsTab = this.getTabByLabel(reviewsTabLabel, tabsComponent);
            const reviewsComponent = this.getReviewsComponent();
            if (reviewsTab && reviewsComponent) {
                this.clickTabIfInactive(reviewsTab);
                setTimeout(() => reviewsComponent.scrollIntoView({ behavior: 'smooth' }), 0);
            }
        })
            .unsubscribe();
    }
    // NOTE: Does not currently exists as its own component
    // but part of tabs component. This is likely to change in refactor.
    getReviewsComponent() {
        return this.winRef.document.querySelector('cx-product-reviews');
    }
    // Get Tabs Component if exists on page
    getTabsComponent() {
        return this.winRef.document.querySelector('cx-tab-paragraph-container');
    }
    // Click to activate tab if not already active
    clickTabIfInactive(tab) {
        if (!tab.classList.contains('active') ||
            tab.classList.contains('toggled')) {
            tab.click();
        }
    }
    // Get Tab by label if exists on page
    getTabByLabel(label, tabsComponent) {
        if (tabsComponent) {
            // NOTE: Reads through button tags to click on correct tab
            // There may be a better way of doing this now/after refactor
            const tabElements = tabsComponent.getElementsByTagName('button');
            // Look through button tab elements until finding tab with label
            for (const buttonElement of Array.from(tabElements)) {
                if (buttonElement.innerHTML.includes(label)) {
                    return buttonElement;
                }
            }
        }
    }
}
ProductIntroComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductIntroComponent, deps: [{ token: CurrentProductService }, { token: i1.TranslationService }, { token: i1.WindowRef }], target: i0.ɵɵFactoryTarget.Component });
ProductIntroComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: ProductIntroComponent, selector: "cx-product-intro", ngImport: i0, template: "<ng-container *ngIf=\"product$ | async as product\">\n  <div class=\"rating\" *ngIf=\"product.averageRating\">\n    <cx-star-rating [rating]=\"product?.averageRating\"></cx-star-rating>\n\n    <div class=\"count\">({{ product?.numberOfReviews }})</div>\n\n    <button\n      *ngIf=\"reviewsTabAvailable | async\"\n      class=\"btn btn-link cx-action-link\"\n      (click)=\"showReviews()\"\n      [attr.aria-label]=\"\n        'productSummary.showReviewsDetailed'\n          | cxTranslate\n            : {\n                rating: product.averageRating | number: '1.0-1',\n                count: product?.numberOfReviews\n              }\n      \"\n    >\n      {{ 'productSummary.showReviews' | cxTranslate }}\n    </button>\n  </div>\n  <div class=\"rating\" *ngIf=\"!product.averageRating\">\n    {{ 'productDetails.noReviews' | cxTranslate }}\n  </div>\n  <div class=\"code\">\n    {{ 'productSummary.id' | cxTranslate }} {{ product?.code }}\n  </div>\n</ng-container>\n", components: [{ type: StarRatingComponent, selector: "cx-star-rating", inputs: ["disabled", "rating"], outputs: ["change"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "async": i3.AsyncPipe, "cxTranslate": i1.TranslatePipe, "number": i3.DecimalPipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductIntroComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-product-intro',
                    templateUrl: './product-intro.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: CurrentProductService }, { type: i1.TranslationService }, { type: i1.WindowRef }]; } });

class ProductIntroModule {
}
ProductIntroModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductIntroModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ProductIntroModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductIntroModule, declarations: [ProductIntroComponent], imports: [CommonModule, I18nModule, StarRatingModule], exports: [ProductIntroComponent] });
ProductIntroModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductIntroModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                ProductIntroComponent: {
                    component: ProductIntroComponent,
                },
            },
        }),
    ], imports: [[CommonModule, I18nModule, StarRatingModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductIntroModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, I18nModule, StarRatingModule],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                ProductIntroComponent: {
                                    component: ProductIntroComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [ProductIntroComponent],
                    exports: [ProductIntroComponent],
                }]
        }] });

/**
 * The `ProductListComponentService` is used to search products. The service is used
 * on the Product Listing Page, for listing products and the facet navigation.
 *
 * The service exposes the product search results based on the category and search
 * route parameters. The route parameters are used to query products by the help of
 * the `ProductSearchService`.
 */
class ProductListComponentService {
    constructor(productSearchService, routing, activatedRoute, currencyService, languageService, router, config) {
        this.productSearchService = productSearchService;
        this.routing = routing;
        this.activatedRoute = activatedRoute;
        this.currencyService = currencyService;
        this.languageService = languageService;
        this.router = router;
        this.config = config;
        this.RELEVANCE_ALLCATEGORIES = ':relevance:allCategories:';
        /**
         * Emits the search results for the current search query.
         *
         * The `searchResults$` is _not_ concerned with querying, it only observes the
         * `productSearchService.getResults()`
         */
        this.searchResults$ = this.productSearchService
            .getResults()
            .pipe(filter((searchResult) => Object.keys(searchResult).length > 0));
        /**
         * Observes the route and performs a search on each route change.
         *
         * Context changes, such as language and currencies are also taken
         * into account, so that the search is performed again.
         */
        this.searchByRouting$ = combineLatest([
            this.routing.getRouterState().pipe(distinctUntilChanged((x, y) => {
                // router emits new value also when the anticipated `nextState` changes
                // but we want to perform search only when current url changes
                return x.state.url === y.state.url;
            })),
            ...this.siteContext,
        ]).pipe(debounceTime(0), map(([routerState, ..._context]) => routerState.state), tap((state) => {
            const criteria = this.getCriteriaFromRoute(state.params, state.queryParams);
            this.search(criteria);
        }));
        /**
         * This stream is used for the Product Listing and Product Facets.
         *
         * It not only emits search results, but also performs a search on every change
         * of the route (i.e. route params or query params).
         *
         * When a user leaves the PLP route, the PLP component unsubscribes from this stream
         * so no longer the search is performed on route change.
         */
        this.model$ = using(() => this.searchByRouting$.subscribe(), () => this.searchResults$).pipe(shareReplay({ bufferSize: 1, refCount: true }));
    }
    /**
     * Expose the `SearchCriteria`. The search criteria are driven by the route parameters.
     *
     * This search route configuration is not yet configurable
     * (see https://github.com/SAP/spartacus/issues/7191).
     */
    getCriteriaFromRoute(routeParams, queryParams) {
        var _a;
        return {
            query: queryParams.query || this.getQueryFromRouteParams(routeParams),
            pageSize: queryParams.pageSize || ((_a = this.config.view) === null || _a === void 0 ? void 0 : _a.defaultPageSize),
            currentPage: queryParams.currentPage,
            sortCode: queryParams.sortCode,
        };
    }
    /**
     * Resolves the search query from the given `ProductListRouteParams`.
     */
    getQueryFromRouteParams({ query, categoryCode, brandCode, }) {
        if (query) {
            return query;
        }
        if (categoryCode) {
            return this.RELEVANCE_ALLCATEGORIES + categoryCode;
        }
        // TODO: drop support for brands as they should be treated
        // similarly as any category.
        if (brandCode) {
            return this.RELEVANCE_ALLCATEGORIES + brandCode;
        }
    }
    /**
     * Performs a search based on the given search criteria.
     *
     * The search is delegated to the `ProductSearchService`.
     */
    search(criteria) {
        const currentPage = criteria.currentPage;
        const pageSize = criteria.pageSize;
        const sort = criteria.sortCode;
        this.productSearchService.search(criteria.query, 
        // TODO: consider dropping this complex passing of cleaned object
        Object.assign({}, currentPage && { currentPage }, pageSize && { pageSize }, sort && { sort }));
    }
    /**
     * Get items from a given page without using navigation
     */
    getPageItems(pageNumber) {
        this.routing
            .getRouterState()
            .subscribe((route) => {
            const routeCriteria = this.getCriteriaFromRoute(route.state.params, route.state.queryParams);
            const criteria = Object.assign(Object.assign({}, routeCriteria), { currentPage: pageNumber });
            this.search(criteria);
        })
            .unsubscribe();
    }
    /**
     * Sort the search results by the given sort code.
     */
    sort(sortCode) {
        this.route({ sortCode });
    }
    /**
     * Routes to the next product listing page, using the given `queryParams`. The
     * `queryParams` support sorting, pagination and querying.
     *
     * The `queryParams` are delegated to the Angular router `NavigationExtras`.
     */
    route(queryParams) {
        this.router.navigate([], {
            queryParams,
            queryParamsHandling: 'merge',
            relativeTo: this.activatedRoute,
        });
    }
    /**
     * The site context is used to update the search query in case of a
     * changing context. The context will typically influence the search data.
     *
     * We keep this private for now, as we're likely refactoring this in the next
     * major version.
     */
    get siteContext() {
        // TODO: we should refactor this so that custom context will be taken
        // into account automatically. Ideally, we drop the specific context
        // from the constructor, and query a ContextService for all contexts.
        return [this.languageService.getActive(), this.currencyService.getActive()];
    }
}
ProductListComponentService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductListComponentService, deps: [{ token: i1.ProductSearchService }, { token: i1.RoutingService }, { token: i1$1.ActivatedRoute }, { token: i1.CurrencyService }, { token: i1.LanguageService }, { token: i1$1.Router }, { token: ViewConfig }], target: i0.ɵɵFactoryTarget.Injectable });
ProductListComponentService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductListComponentService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductListComponentService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: function () { return [{ type: i1.ProductSearchService }, { type: i1.RoutingService }, { type: i1$1.ActivatedRoute }, { type: i1.CurrencyService }, { type: i1.LanguageService }, { type: i1$1.Router }, { type: ViewConfig }]; } });

var ViewModes;
(function (ViewModes) {
    ViewModes["Grid"] = "grid";
    ViewModes["List"] = "list";
})(ViewModes || (ViewModes = {}));
class ProductViewComponent {
    constructor() {
        this.iconTypes = ICON_TYPE;
        this.modeChange = new EventEmitter();
    }
    get buttonClass() {
        const viewName = this.viewMode.toLowerCase();
        return `cx-product-${viewName}`;
    }
    /**
     *   Display icons inversely to allow users
     *   to see the view they will navigate to
     */
    get viewMode() {
        if (this.mode === 'list') {
            return this.iconTypes.GRID;
        }
        else if (this.mode === 'grid') {
            return this.iconTypes.LIST;
        }
    }
    changeMode() {
        const newMode = this.mode === ViewModes.Grid ? ViewModes.List : ViewModes.Grid;
        this.modeChange.emit(newMode);
    }
}
ProductViewComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductViewComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
ProductViewComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: ProductViewComponent, selector: "cx-product-view", inputs: { mode: "mode" }, outputs: { modeChange: "modeChange" }, ngImport: i0, template: "<button\n  class=\"btn cx-product-layout\"\n  [ngClass]=\"buttonClass\"\n  (click)=\"changeMode()\"\n  tabindex=\"0\"\n  attr.aria-label=\"{{\n    viewMode === iconTypes.GRID\n      ? ('productView.gridView' | cxTranslate)\n      : viewMode === iconTypes.LIST\n      ? ('productView.listView' | cxTranslate)\n      : null\n  }}\"\n>\n  <cx-icon\n    *ngIf=\"viewMode === iconTypes.GRID\"\n    [type]=\"iconTypes.GRID\"\n  ></cx-icon>\n  <cx-icon\n    *ngIf=\"viewMode === iconTypes.LIST\"\n    [type]=\"iconTypes.LIST\"\n  ></cx-icon>\n</button>\n", components: [{ type: IconComponent, selector: "cx-icon,[cxIcon]", inputs: ["cxIcon", "type"] }], directives: [{ type: i3.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "cxTranslate": i1.TranslatePipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductViewComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-product-view',
                    templateUrl: './product-view.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], propDecorators: { mode: [{
                type: Input
            }], modeChange: [{
                type: Output
            }] } });

var ProductDetailOutlets;
(function (ProductDetailOutlets) {
    ProductDetailOutlets["INTRO"] = "PDP.INTRO";
    ProductDetailOutlets["PRICE"] = "PDP.PRICE";
    ProductDetailOutlets["SHARE"] = "PDP.SHARE";
    ProductDetailOutlets["SUMMARY"] = "PDP.SUMMARY";
})(ProductDetailOutlets || (ProductDetailOutlets = {}));
var ProductListOutlets;
(function (ProductListOutlets) {
    ProductListOutlets["ITEM_ACTIONS"] = "cx-product-list-item.actions";
    ProductListOutlets["ITEM_DETAILS"] = "cx-product-list-item.details";
})(ProductListOutlets || (ProductListOutlets = {}));

/**
 * Context for `ProductListItemComponent`.
 */
class ProductListItemContext {
}
ProductListItemContext.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductListItemContext, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
ProductListItemContext.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductListItemContext });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductListItemContext, decorators: [{
            type: Injectable
        }] });

/**
 * Context source for `ProductListItemComponent`.
 *
 * `ProductListItemContext` should be injected instead in child components.
 */
class ProductListItemContextSource extends ProductListItemContext {
    constructor() {
        super(...arguments);
        this.product$ = new ReplaySubject(1);
    }
}
ProductListItemContextSource.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductListItemContextSource, deps: null, target: i0.ɵɵFactoryTarget.Injectable });
ProductListItemContextSource.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductListItemContextSource });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductListItemContextSource, decorators: [{
            type: Injectable
        }] });

class ProductGridItemComponent {
    constructor(productListItemContextSource) {
        this.productListItemContextSource = productListItemContextSource;
        this.ProductListOutlets = ProductListOutlets;
    }
    ngOnChanges(changes) {
        if (changes === null || changes === void 0 ? void 0 : changes.product) {
            this.productListItemContextSource.product$.next(this.product);
        }
    }
}
ProductGridItemComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductGridItemComponent, deps: [{ token: ProductListItemContextSource }], target: i0.ɵɵFactoryTarget.Component });
ProductGridItemComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: ProductGridItemComponent, selector: "cx-product-grid-item", inputs: { product: "product" }, providers: [
        ProductListItemContextSource,
        {
            provide: ProductListItemContext,
            useExisting: ProductListItemContextSource,
        },
    ], usesOnChanges: true, ngImport: i0, template: "<a\n  [routerLink]=\"{ cxRoute: 'product', params: product } | cxUrl\"\n  class=\"cx-product-image-container\"\n  tabindex=\"-1\"\n>\n  <cx-media\n    class=\"cx-product-image\"\n    [container]=\"product.images?.PRIMARY\"\n    format=\"product\"\n    [alt]=\"product.summary\"\n  ></cx-media>\n</a>\n<a\n  [routerLink]=\"{ cxRoute: 'product', params: product } | cxUrl\"\n  class=\"cx-product-name\"\n  [innerHTML]=\"product.nameHtml\"\n></a>\n\n<ng-template [cxOutlet]=\"ProductListOutlets.ITEM_DETAILS\">\n  <div class=\"cx-product-rating\">\n    <cx-star-rating\n      *ngIf=\"product.averageRating\"\n      [rating]=\"product?.averageRating\"\n    ></cx-star-rating>\n    <div *ngIf=\"!product.averageRating\">\n      {{ 'productDetails.noReviews' | cxTranslate }}\n    </div>\n  </div>\n  <div class=\"cx-product-price-container\">\n    <div\n      class=\"cx-product-price\"\n      [attr.aria-label]=\"'productDetails.productPrice' | cxTranslate\"\n    >\n      {{ product.price?.formattedValue }}\n    </div>\n  </div>\n</ng-template>\n\n<ng-template [cxOutlet]=\"ProductListOutlets.ITEM_ACTIONS\">\n  <cx-add-to-cart\n    *ngIf=\"product.stock?.stockLevelStatus !== 'outOfStock'\"\n    [showQuantity]=\"false\"\n    [product]=\"product\"\n  ></cx-add-to-cart>\n</ng-template>\n", components: [{ type: MediaComponent, selector: "cx-media", inputs: ["container", "format", "alt", "role", "loading"], outputs: ["loaded"] }, { type: StarRatingComponent, selector: "cx-star-rating", inputs: ["disabled", "rating"], outputs: ["change"] }, { type: AddToCartComponent, selector: "cx-add-to-cart", inputs: ["productCode", "showQuantity", "product"] }], directives: [{ type: i1$1.RouterLinkWithHref, selector: "a[routerLink],area[routerLink]", inputs: ["routerLink", "target", "queryParams", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange", "replaceUrl", "state", "relativeTo"] }, { type: OutletDirective, selector: "[cxOutlet]", inputs: ["cxOutlet", "cxOutletContext", "cxOutletDefer"], outputs: ["loaded"] }, { type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "cxUrl": i1.UrlPipe, "cxTranslate": i1.TranslatePipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductGridItemComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-product-grid-item',
                    templateUrl: './product-grid-item.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [
                        ProductListItemContextSource,
                        {
                            provide: ProductListItemContext,
                            useExisting: ProductListItemContextSource,
                        },
                    ],
                }]
        }], ctorParameters: function () { return [{ type: ProductListItemContextSource }]; }, propDecorators: { product: [{
                type: Input
            }] } });

class ProductListItemComponent {
    constructor(productListItemContextSource) {
        this.productListItemContextSource = productListItemContextSource;
        this.ProductListOutlets = ProductListOutlets;
    }
    ngOnChanges(changes) {
        if (changes === null || changes === void 0 ? void 0 : changes.product) {
            this.productListItemContextSource.product$.next(this.product);
        }
    }
}
ProductListItemComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductListItemComponent, deps: [{ token: ProductListItemContextSource }], target: i0.ɵɵFactoryTarget.Component });
ProductListItemComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: ProductListItemComponent, selector: "cx-product-list-item", inputs: { product: "product" }, providers: [
        ProductListItemContextSource,
        {
            provide: ProductListItemContext,
            useExisting: ProductListItemContextSource,
        },
    ], usesOnChanges: true, ngImport: i0, template: "<div class=\"row\">\n  <div class=\"col-12 col-md-4\">\n    <a\n      [routerLink]=\"{ cxRoute: 'product', params: product } | cxUrl\"\n      class=\"cx-product-image-container\"\n      tabindex=\"-1\"\n    >\n      <cx-media\n        class=\"cx-product-image\"\n        [container]=\"product.images?.PRIMARY\"\n        format=\"product\"\n        [alt]=\"product.summary\"\n      ></cx-media>\n    </a>\n  </div>\n  <div class=\"col-12 col-md-8\">\n    <a\n      [routerLink]=\"{ cxRoute: 'product', params: product } | cxUrl\"\n      class=\"cx-product-name\"\n    >\n      <h2 [innerHtml]=\"product.nameHtml\"></h2>\n    </a>\n\n    <ng-template [cxOutlet]=\"ProductListOutlets.ITEM_DETAILS\">\n      <cx-star-rating\n        *ngIf=\"product.averageRating\"\n        [rating]=\"product?.averageRating\"\n      ></cx-star-rating>\n      <div *ngIf=\"!product.averageRating\" class=\"cx-product-no-review\">\n        {{ 'productDetails.noReviews' | cxTranslate }}\n      </div>\n      <div\n        class=\"cx-product-price\"\n        [attr.aria-label]=\"'productDetails.productPrice' | cxTranslate\"\n      >\n        {{ product.price?.formattedValue }}\n      </div>\n    </ng-template>\n\n    <div class=\"row\">\n      <div class=\"col-12 col-md-8\">\n        <p class=\"cx-product-summary\" [innerHtml]=\"product.summary\">\n          {{ product.summary }}\n        </p>\n      </div>\n      <div class=\"col-12 col-md-4\">\n        <ng-template [cxOutlet]=\"ProductListOutlets.ITEM_ACTIONS\">\n          <cx-add-to-cart\n            *ngIf=\"product.stock?.stockLevelStatus !== 'outOfStock'\"\n            [showQuantity]=\"false\"\n            [product]=\"product\"\n          ></cx-add-to-cart>\n        </ng-template>\n      </div>\n    </div>\n  </div>\n</div>\n", components: [{ type: MediaComponent, selector: "cx-media", inputs: ["container", "format", "alt", "role", "loading"], outputs: ["loaded"] }, { type: StarRatingComponent, selector: "cx-star-rating", inputs: ["disabled", "rating"], outputs: ["change"] }, { type: AddToCartComponent, selector: "cx-add-to-cart", inputs: ["productCode", "showQuantity", "product"] }], directives: [{ type: i1$1.RouterLinkWithHref, selector: "a[routerLink],area[routerLink]", inputs: ["routerLink", "target", "queryParams", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange", "replaceUrl", "state", "relativeTo"] }, { type: OutletDirective, selector: "[cxOutlet]", inputs: ["cxOutlet", "cxOutletContext", "cxOutletDefer"], outputs: ["loaded"] }, { type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "cxUrl": i1.UrlPipe, "cxTranslate": i1.TranslatePipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductListItemComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-product-list-item',
                    templateUrl: './product-list-item.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [
                        ProductListItemContextSource,
                        {
                            provide: ProductListItemContext,
                            useExisting: ProductListItemContextSource,
                        },
                    ],
                }]
        }], ctorParameters: function () { return [{ type: ProductListItemContextSource }]; }, propDecorators: { product: [{
                type: Input
            }] } });

class ProductScrollComponent {
    constructor(productListComponentService, ref) {
        this.productListComponentService = productListComponentService;
        this.ref = ref;
        this.subscription = new Subscription();
        this.ViewModes = ViewModes;
        this.appendProducts = false;
        this.resetList = false;
        this.isMaxProducts = false;
        this.isLastPage = false;
        this.isEmpty = false;
    }
    set setConfig(inputConfig) {
        this.setComponentConfigurations(inputConfig);
    }
    set setModel(inputModel) {
        this.infiniteScrollOperations(inputModel);
    }
    set setViewMode(inputViewMode) {
        this.inputViewMode = inputViewMode;
        //If viewMode is already set (meaning it is not the first load)
        //Reset the product list
        if (this.viewMode) {
            this.resetListOnViewModeChange();
        }
        else {
            //If viewMode is not set (meaning it is the first load)
            //Set the viewMode
            this.viewMode = inputViewMode;
        }
    }
    scrollPage(pageNumber) {
        this.appendProducts = true;
        this.ref.markForCheck();
        this.productListComponentService.getPageItems(pageNumber);
    }
    loadNextPage(pageNumber) {
        this.isMaxProducts = false;
        this.scrollPage(pageNumber);
    }
    scrollToTop() {
        window.scroll(0, 0);
    }
    setComponentConfigurations(scrollConfig) {
        var _a, _b, _c, _d;
        const isButton = (_b = (_a = scrollConfig.view) === null || _a === void 0 ? void 0 : _a.infiniteScroll) === null || _b === void 0 ? void 0 : _b.showMoreButton;
        const configProductLimit = (_d = (_c = scrollConfig.view) === null || _c === void 0 ? void 0 : _c.infiniteScroll) === null || _d === void 0 ? void 0 : _d.productLimit;
        //Display "show more" button every time when button configuration is true
        //Otherwise, only display "show more" when the configuration product limit is reached
        this.productLimit = isButton ? 1 : configProductLimit;
    }
    infiniteScrollOperations(inputModel) {
        if (this.appendProducts) {
            this.model = Object.assign(Object.assign({}, inputModel), { products: this.model.products.concat(inputModel.products) });
        }
        else {
            this.model = inputModel;
            this.maxProducts = this.productLimit;
        }
        this.setConditions();
        this.ref.markForCheck();
    }
    resetListOnViewModeChange() {
        this.scrollToTop();
        this.resetList = true;
        this.productListComponentService.getPageItems(0);
    }
    //Set booleans after model has been retrieved
    setConditions() {
        this.isEmpty = !this.model.products || this.model.products.length === 0;
        this.isLastPage =
            this.model.pagination.currentPage ===
                this.model.pagination.totalPages - 1;
        this.isMaxProducts =
            this.productLimit &&
                this.productLimit !== 0 &&
                this.model.products.length >= this.maxProducts;
        //Add the productLimit to the current number of products to determine the next max number of products
        if (this.isMaxProducts) {
            this.maxProducts = this.model.products.length + this.productLimit;
        }
        //Only change viewMode once the new model is set
        //This prevents flickering issues
        if (this.viewMode !== this.inputViewMode) {
            this.viewMode = this.inputViewMode;
        }
        this.resetList = false;
        this.appendProducts = false;
    }
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
}
ProductScrollComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductScrollComponent, deps: [{ token: ProductListComponentService }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
ProductScrollComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: ProductScrollComponent, selector: "cx-product-scroll", inputs: { setConfig: ["scrollConfig", "setConfig"], setModel: ["model", "setModel"], setViewMode: ["inputViewMode", "setViewMode"] }, ngImport: i0, template: "<ng-container *ngIf=\"viewMode === ViewModes.Grid\">\n  <div\n    infiniteScroll\n    [infiniteScrollDistance]=\"5\"\n    [infiniteScrollThrottle]=\"50\"\n    [infiniteScrollDisabled]=\"isMaxProducts || isLastPage || isEmpty\"\n    (scrolled)=\"scrollPage(model?.pagination?.currentPage + 1)\"\n  >\n    <div class=\"row\">\n      <cx-product-grid-item\n        *ngFor=\"let product of model?.products\"\n        [product]=\"product\"\n        class=\"col-12 col-sm-6 col-md-4\"\n      ></cx-product-grid-item>\n    </div>\n    <div\n      [className]=\"\n        !isLastPage && model?.pagination?.currentPage > 0\n          ? 'cx-double-btn-container grid-btn-padding'\n          : 'cx-single-btn-container grid-btn-padding'\n      \"\n    >\n      <div\n        *ngIf=\"\n          (isMaxProducts || isLastPage) && model?.pagination?.currentPage > 0\n        \"\n        (click)=\"scrollToTop()\"\n        class=\"btn btn-block btn-action\"\n      >\n        {{ 'productList.backToTopBtn' | cxTranslate }}\n      </div>\n      <div\n        *ngIf=\"isMaxProducts && !isLastPage\"\n        (click)=\"loadNextPage(model?.pagination?.currentPage + 1)\"\n        class=\"btn btn-block btn-action align-btn\"\n      >\n        {{ 'productList.showMoreBtn' | cxTranslate }}\n      </div>\n    </div>\n    <div *ngIf=\"appendProducts\" class=\"cx-spinner\">\n      <cx-spinner></cx-spinner>\n    </div>\n  </div>\n</ng-container>\n\n<ng-container *ngIf=\"viewMode === ViewModes.List\">\n  <div\n    infiniteScroll\n    [infiniteScrollDistance]=\"3\"\n    [infiniteScrollThrottle]=\"50\"\n    [infiniteScrollDisabled]=\"isMaxProducts || isLastPage || isEmpty\"\n    (scrolled)=\"scrollPage(model?.pagination?.currentPage + 1)\"\n  >\n    <cx-product-list-item\n      *ngFor=\"let product of model?.products\"\n      [product]=\"product\"\n      class=\"cx-product-search-list\"\n    ></cx-product-list-item>\n    <div\n      [className]=\"\n        !isLastPage && model?.pagination?.currentPage > 0\n          ? 'cx-double-btn-container'\n          : 'cx-single-btn-container'\n      \"\n    >\n      <div\n        *ngIf=\"\n          (isMaxProducts || isLastPage) && model?.pagination?.currentPage > 0\n        \"\n        (click)=\"scrollToTop()\"\n        class=\"btn btn-block btn-action\"\n      >\n        {{ 'productList.backToTopBtn' | cxTranslate }}\n      </div>\n      <div\n        *ngIf=\"isMaxProducts && !isLastPage\"\n        (click)=\"loadNextPage(model?.pagination?.currentPage + 1)\"\n        class=\"btn btn-block btn-action align-btn\"\n      >\n        {{ 'productList.showMoreBtn' | cxTranslate }}\n      </div>\n    </div>\n    <div *ngIf=\"appendProducts\" class=\"cx-spinner\">\n      <cx-spinner></cx-spinner>\n    </div>\n  </div>\n</ng-container>\n", components: [{ type: ProductGridItemComponent, selector: "cx-product-grid-item", inputs: ["product"] }, { type: SpinnerComponent, selector: "cx-spinner" }, { type: ProductListItemComponent, selector: "cx-product-list-item", inputs: ["product"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i6.InfiniteScrollDirective, selector: "[infiniteScroll], [infinite-scroll], [data-infinite-scroll]", inputs: ["infiniteScrollDistance", "infiniteScrollUpDistance", "infiniteScrollThrottle", "infiniteScrollDisabled", "infiniteScrollContainer", "scrollWindow", "immediateCheck", "horizontal", "alwaysCallback", "fromRoot"], outputs: ["scrolled", "scrolledUp"] }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], pipes: { "cxTranslate": i1.TranslatePipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductScrollComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-product-scroll',
                    templateUrl: './product-scroll.component.html',
                }]
        }], ctorParameters: function () { return [{ type: ProductListComponentService }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { setConfig: [{
                type: Input,
                args: ['scrollConfig']
            }], setModel: [{
                type: Input,
                args: ['model']
            }], setViewMode: [{
                type: Input,
                args: ['inputViewMode']
            }] } });

class ProductListComponent {
    constructor(pageLayoutService, productListComponentService, scrollConfig) {
        this.pageLayoutService = pageLayoutService;
        this.productListComponentService = productListComponentService;
        this.scrollConfig = scrollConfig;
        this.subscription = new Subscription();
        this.model$ = this.productListComponentService.model$;
        this.viewMode$ = new BehaviorSubject(ViewModes.Grid);
        this.ViewModes = ViewModes;
    }
    ngOnInit() {
        var _a, _b;
        this.isInfiniteScroll = (_b = (_a = this.scrollConfig.view) === null || _a === void 0 ? void 0 : _a.infiniteScroll) === null || _b === void 0 ? void 0 : _b.active;
        this.subscription.add(this.pageLayoutService.templateName$
            .pipe(take(1))
            .subscribe((template) => {
            this.viewMode$.next(template === 'ProductGridPageTemplate'
                ? ViewModes.Grid
                : ViewModes.List);
        }));
    }
    sortList(sortCode) {
        this.productListComponentService.sort(sortCode);
    }
    setViewMode(mode) {
        this.viewMode$.next(mode);
    }
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
}
ProductListComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductListComponent, deps: [{ token: PageLayoutService }, { token: ProductListComponentService }, { token: ViewConfig }], target: i0.ɵɵFactoryTarget.Component });
ProductListComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: ProductListComponent, selector: "cx-product-list", ngImport: i0, template: "<div class=\"cx-page\" *ngIf=\"model$ | async as model\">\n  <section class=\"cx-page-section\">\n    <div class=\"container\">\n      <div class=\"row\">\n        <div class=\"col-12 col-lg-12\" *ngIf=\"viewMode$ | async as viewMode\">\n          <div class=\"cx-sorting top\">\n            <div class=\"row\">\n              <label\n                class=\"form-group cx-sort-dropdown col-12 col-lg-4 mr-auto\"\n              >\n                <span>{{ 'productList.sortBy' | cxTranslate }}</span>\n                <cx-sorting\n                  [sortOptions]=\"model.sorts\"\n                  (sortListEvent)=\"sortList($event)\"\n                  [selectedOption]=\"model.pagination.sort\"\n                  placeholder=\"{{ 'productList.sortBy' | cxTranslate }}\"\n                ></cx-sorting>\n              </label>\n              <div *ngIf=\"!isInfiniteScroll\" class=\"col-auto\">\n                <div\n                  class=\"cx-pagination\"\n                  [attr.aria-label]=\"\n                    'productList.productSearchPagination' | cxTranslate\n                  \"\n                >\n                  <cx-pagination\n                    [pagination]=\"model.pagination\"\n                    queryParam=\"currentPage\"\n                    [defaultPage]=\"0\"\n                  ></cx-pagination>\n                </div>\n              </div>\n              <div class=\"col-auto ml-auto ml-lg-0\">\n                <cx-product-view\n                  (modeChange)=\"setViewMode($event)\"\n                  [mode]=\"viewMode\"\n                ></cx-product-view>\n              </div>\n            </div>\n          </div>\n          <div class=\"cx-product-container\">\n            <!-- Product list when using pagination -->\n            <ng-container *ngIf=\"!isInfiniteScroll; else infiniteScroll\">\n              <ng-container *ngIf=\"viewMode === ViewModes.Grid\">\n                <div class=\"row\">\n                  <cx-product-grid-item\n                    *ngFor=\"let product of model?.products\"\n                    [product]=\"product\"\n                    class=\"col-12 col-sm-6 col-md-4\"\n                  ></cx-product-grid-item>\n                </div>\n              </ng-container>\n\n              <ng-container *ngIf=\"viewMode === ViewModes.List\">\n                <cx-product-list-item\n                  *ngFor=\"let product of model?.products\"\n                  [product]=\"product\"\n                  class=\"cx-product-search-list\"\n                ></cx-product-list-item>\n              </ng-container>\n            </ng-container>\n\n            <!-- Product list when using infinite scroll -->\n            <ng-template #infiniteScroll>\n              <cx-product-scroll\n                [scrollConfig]=\"scrollConfig\"\n                [model]=\"model\"\n                [inputViewMode]=\"viewMode\"\n              ></cx-product-scroll>\n            </ng-template>\n          </div>\n          <div class=\"cx-sorting bottom\">\n            <div class=\"row\">\n              <label\n                class=\"form-group cx-sort-dropdown col-12 col-lg-4 mr-auto\"\n              >\n                <span>{{ 'productList.sortBy' | cxTranslate }}</span>\n                <cx-sorting\n                  [sortOptions]=\"model.sorts\"\n                  (sortListEvent)=\"sortList($event)\"\n                  [selectedOption]=\"model.pagination.sort\"\n                  placeholder=\"{{ 'productList.sortBy' | cxTranslate }}\"\n                ></cx-sorting>\n              </label>\n              <div\n                *ngIf=\"!isInfiniteScroll\"\n                class=\"col-auto\"\n                [attr.aria-label]=\"\n                  'productList.productSearchPagination' | cxTranslate\n                \"\n              >\n                <div class=\"cx-pagination\">\n                  <cx-pagination\n                    [pagination]=\"model.pagination\"\n                    queryParam=\"currentPage\"\n                    [defaultPage]=\"0\"\n                  ></cx-pagination>\n                </div>\n              </div>\n              <div class=\"col-auto ml-auto ml-lg-0\">\n                <cx-product-view\n                  (modeChange)=\"setViewMode($event)\"\n                  [mode]=\"viewMode\"\n                ></cx-product-view>\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n  </section>\n</div>\n", components: [{ type: SortingComponent, selector: "cx-sorting", inputs: ["sortOptions", "selectedOption", "placeholder", "sortLabels"], outputs: ["sortListEvent"] }, { type: PaginationComponent, selector: "cx-pagination", inputs: ["pageRoute", "queryParam", "defaultPage", "pagination"], outputs: ["viewPageEvent"] }, { type: ProductViewComponent, selector: "cx-product-view", inputs: ["mode"], outputs: ["modeChange"] }, { type: ProductGridItemComponent, selector: "cx-product-grid-item", inputs: ["product"] }, { type: ProductListItemComponent, selector: "cx-product-list-item", inputs: ["product"] }, { type: ProductScrollComponent, selector: "cx-product-scroll", inputs: ["scrollConfig", "model", "inputViewMode"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], pipes: { "async": i3.AsyncPipe, "cxTranslate": i1.TranslatePipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductListComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-product-list',
                    templateUrl: './product-list.component.html',
                }]
        }], ctorParameters: function () { return [{ type: PageLayoutService }, { type: ProductListComponentService }, { type: ViewConfig }]; } });

var FacetGroupCollapsedState;
(function (FacetGroupCollapsedState) {
    FacetGroupCollapsedState["EXPANDED"] = "EXPANDED";
    FacetGroupCollapsedState["COLLAPSED"] = "COLLAPSED";
})(FacetGroupCollapsedState || (FacetGroupCollapsedState = {}));

/**
 * Provides access to all the facets and active facets for the Product Listing Page.
 */
class ProductFacetService {
    constructor(routing, productListComponentService) {
        this.routing = routing;
        this.productListComponentService = productListComponentService;
        this.routeState$ = this.routing
            .getRouterState()
            .pipe(pluck('state'));
        /**
         * Returns the search results for the current page.
         */
        this.searchResult$ = this.routeState$.pipe(switchMap((state) => this.productListComponentService.model$.pipe(filter((page) => this.filterForPage(state, page)), map((page) => {
            var _a;
            return (Object.assign(Object.assign({}, page), { breadcrumbs: this.filterBreadcrumbs((_a = page === null || page === void 0 ? void 0 : page.breadcrumbs) !== null && _a !== void 0 ? _a : [], state.params) }));
        }))));
        /**
         * Observes the facets and active facets for the given page. The facet data
         * is provided in a `FacetList`.
         */
        this.facetList$ = this.searchResult$.pipe(map((result) => ({
            facets: result.facets,
            activeFacets: result.breadcrumbs,
        })));
    }
    /**
     * Filters the current result by verifying if the result is related to the page.
     * This is done to avoid a combination of the next page and the current search results.
     */
    filterForPage(state, page) {
        var _a, _b;
        if (!((_b = (_a = page.currentQuery) === null || _a === void 0 ? void 0 : _a.query) === null || _b === void 0 ? void 0 : _b.value)) {
            return false;
        }
        if (state.context.type === PageType.CATEGORY_PAGE) {
            return (page.currentQuery.query.value.indexOf(`allCategories:${state.context.id}`) > -1);
        }
        if (state.context.type === PageType.CONTENT_PAGE &&
            state.context.id === 'search') {
            return page.currentQuery.query.value.startsWith(`${state.params.query}:`);
        }
        return false;
    }
    /**
     * Filter breadcrumbs which are not actively selected but coming from
     * the route navigation.
     *
     * The breadcrumbs might include the active category page code, which is not actively
     * selected by the user.
     */
    filterBreadcrumbs(breadcrumbs, params) {
        return breadcrumbs
            ? breadcrumbs.filter((breadcrumb) => !(breadcrumb.facetCode === 'allCategories' &&
                (breadcrumb.facetValueCode === params.categoryCode ||
                    breadcrumb.facetValueCode === params.brandCode)))
            : [];
    }
}
ProductFacetService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductFacetService, deps: [{ token: i1.RoutingService }, { token: ProductListComponentService }], target: i0.ɵɵFactoryTarget.Injectable });
ProductFacetService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductFacetService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductFacetService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.RoutingService }, { type: ProductListComponentService }]; } });

/**
 * Provides access to the facets as well as their UI state. The UI state
 * represents user related changes on the facets, such as expanding or
 * collapsing a facet group or expanding the number of _visible_ facet values.
 */
class FacetService {
    constructor(productFacetService) {
        this.productFacetService = productFacetService;
        /**
         * An internal map where we keep the UI state of the facets.
         */
        this.facetState = new Map();
        /**
         * Observes the facets for the given page and configures the initial UI state.
         *
         * Facets are configured on each emission so that we keep the facet UI state.
         * This is mainly done to keep the state during usage of the facet, but also
         * benefitial when the facets are rebuild while using them.
         */
        this.facetList$ = this.productFacetService.facetList$.pipe(tap((facetList) => {
            facetList.facets.forEach((facet) => this.initialize(facet));
        }));
    }
    /**
     * Returns the observed UI state for the facet.
     *
     * The state is initialized using the `initialize` method.
     */
    getState(facet) {
        this.initialize(facet);
        return this.facetState.get(facet.name);
    }
    /**
     * Returns the UI state for the facet.
     *
     * The state is initialized using the `initialize` method.
     */
    getStateSnapshot(facet) {
        return this.getState(facet).value;
    }
    /**
     * Toggles the facet expanded state. If the expanded state becomes false,
     * the visible values will decrease to the top values only.
     *
     * If the optional value argument is provided the expanded state will be set
     * to this value, regardless of the current `expanded` state.
     */
    toggle(facet, isExpanded) {
        const state = this.getStateSnapshot(facet);
        const toggledState = {
            toggled: isExpanded
                ? FacetGroupCollapsedState.COLLAPSED
                : FacetGroupCollapsedState.EXPANDED,
        };
        if (toggledState.toggled === FacetGroupCollapsedState.COLLAPSED) {
            toggledState.maxVisible = state.topVisible;
        }
        this.updateState(facet, toggledState);
    }
    /**
     * Increases the visible values to the maximum values of the facet.
     */
    increaseVisibleValues(facet) {
        this.updateState(facet, { maxVisible: facet.values.length });
    }
    /**
     * Decreases the visible values to the topValueCount.
     *
     * The topValueCount defaults to 6, but can be controlled in
     * the backend as well.
     */
    decreaseVisibleValues(facet) {
        this.updateState(facet, { maxVisible: facet.topValueCount });
    }
    /**
     * Persists the facet state and initializes the default values for the top
     * and max visible values.
     */
    initialize(facet) {
        var _a;
        const topFacets = facet.topValueCount > 0 ? facet.topValueCount : ((_a = facet.values) === null || _a === void 0 ? void 0 : _a.length) || 0;
        if (!this.hasState(facet)) {
            this.facetState.set(facet.name, new BehaviorSubject({
                topVisible: topFacets,
                maxVisible: topFacets,
            }));
        }
    }
    /**
     * Updates the state of the facet in the local facet map.
     */
    updateState(facet, property) {
        const state = Object.assign(Object.assign({}, this.getStateSnapshot(facet)), property);
        this.facetState.get(facet.name).next(state);
    }
    hasState(facet) {
        return this.facetState.has(facet.name);
    }
    getLinkParams(query) {
        return {
            // to avoid encoding issues with facets that have space (' ') in their name,
            // we replace the decoded '+' back to empty space ' '.
            // For more, see https://github.com/SAP/spartacus/issues/7348
            query: new HttpUrlEncodingCodec().decodeValue(query).replace(/\+/g, ' '),
        };
    }
}
FacetService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: FacetService, deps: [{ token: ProductFacetService }], target: i0.ɵɵFactoryTarget.Injectable });
FacetService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: FacetService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: FacetService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: ProductFacetService }]; } });

/**
 * Active facets render the applied facet values as a list of focusable buttons
 * which can be used to remove the applied facet value.
 */
class ActiveFacetsComponent {
    constructor(facetService) {
        this.facetService = facetService;
        /** Active facets which are applied to the product results. */
        this.facetList$ = this.facetService.facetList$;
        /** Configurable icon which is used for the active facet close button */
        this.closeIcon = ICON_TYPE.CLOSE;
    }
    getLinkParams(facet) {
        var _a, _b;
        return this.facetService.getLinkParams((_b = (_a = facet.removeQuery) === null || _a === void 0 ? void 0 : _a.query) === null || _b === void 0 ? void 0 : _b.value);
    }
    /**
     * The focus key is used to persist the focus on the facet when the DOM is being
     * recreated. We only apply the focus key for the given _active_ facet when there
     * the original facets is not available. This happens for non multi-valued facets.
     *
     * With this approach, the we keep the focus, either at the facet list or on the
     * active facets.
     */
    getFocusKey(facetList, facet) {
        var _a;
        return ((_a = facetList.facets) === null || _a === void 0 ? void 0 : _a.find((f) => { var _a; return (_a = f.values) === null || _a === void 0 ? void 0 : _a.find((val) => val.name === facet.facetValueName); }))
            ? ''
            : facet.facetValueName;
    }
}
ActiveFacetsComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ActiveFacetsComponent, deps: [{ token: FacetService }], target: i0.ɵɵFactoryTarget.Component });
ActiveFacetsComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: ActiveFacetsComponent, selector: "cx-active-facets", inputs: { closeIcon: "closeIcon" }, ngImport: i0, template: "<ng-container *ngIf=\"facetList$ | async as facetList\">\n  <h4 *ngIf=\"facetList?.activeFacets?.length > 0\">\n    {{ 'productList.appliedFilter' | cxTranslate }}\n  </h4>\n\n  <a\n    *ngFor=\"let facet of facetList?.activeFacets\"\n    routerLink=\"./\"\n    [queryParams]=\"getLinkParams(facet)\"\n    [cxFocus]=\"getFocusKey(facetList, facet)\"\n  >\n    <span>{{ facet.facetValueName }}</span>\n    <cx-icon aria-hidden=\"true\" [type]=\"closeIcon\"></cx-icon>\n  </a>\n</ng-container>\n", components: [{ type: IconComponent, selector: "cx-icon,[cxIcon]", inputs: ["cxIcon", "type"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i1$1.RouterLinkWithHref, selector: "a[routerLink],area[routerLink]", inputs: ["routerLink", "target", "queryParams", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange", "replaceUrl", "state", "relativeTo"] }, { type: FocusDirective, selector: "[cxFocus]", inputs: ["cxFocus"] }], pipes: { "async": i3.AsyncPipe, "cxTranslate": i1.TranslatePipe }, changeDetection: i0.ChangeDetectionStrategy.Default });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ActiveFacetsComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-active-facets',
                    templateUrl: './active-facets.component.html',
                    changeDetection: ChangeDetectionStrategy.Default,
                }]
        }], ctorParameters: function () { return [{ type: FacetService }]; }, propDecorators: { closeIcon: [{
                type: Input
            }] } });

class ActiveFacetsModule {
}
ActiveFacetsModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ActiveFacetsModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ActiveFacetsModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ActiveFacetsModule, declarations: [ActiveFacetsComponent], imports: [CommonModule,
        RouterModule,
        I18nModule,
        IconModule,
        KeyboardFocusModule], exports: [ActiveFacetsComponent] });
ActiveFacetsModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ActiveFacetsModule, imports: [[
            CommonModule,
            RouterModule,
            I18nModule,
            IconModule,
            KeyboardFocusModule,
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ActiveFacetsModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        RouterModule,
                        I18nModule,
                        IconModule,
                        KeyboardFocusModule,
                    ],
                    declarations: [ActiveFacetsComponent],
                    exports: [ActiveFacetsComponent],
                }]
        }] });

class FacetComponent {
    constructor(facetService, elementRef, cd) {
        this.facetService = facetService;
        this.elementRef = elementRef;
        this.cd = cd;
        /** configurable icon that is used to collapse the facet group  */
        this.expandIcon = ICON_TYPE.EXPAND;
        this.collapseIcon = ICON_TYPE.COLLAPSE;
    }
    set facet(value) {
        this._facet = value;
        this.isMultiSelect = !!value.multiSelect;
        this.state$ = this.facetService.getState(value);
    }
    get facet() {
        return this._facet;
    }
    /**
     * Handles clicking the heading of the facet group, which means toggling
     * the visibility of the group (collapse / expand) and optionally focusing
     * the group.
     */
    toggleGroup(event) {
        var _a;
        const host = this.elementRef.nativeElement;
        const isLocked = (_a = this.keyboardFocus) === null || _a === void 0 ? void 0 : _a.isLocked;
        this.facetService.toggle(this.facet, this.isExpanded);
        if (!isLocked || this.isExpanded) {
            host.focus();
            // we stop propagating the event as otherwise the focus on the host will trigger
            // an unlock event from the LockFocus directive.
            event.stopPropagation();
        }
    }
    get isExpanded() {
        return this.values.first.nativeElement.offsetParent !== null;
    }
    openLink(event) {
        event.target.click();
        event.preventDefault();
    }
    /**
     * Increases the number of visible values for the facet. This is delegated
     * to `facetService.increaseVisibleValues`.
     */
    increaseVisibleValues() {
        this.facetService.increaseVisibleValues(this.facet);
    }
    /**
     * Decreases the number of visible values for the facet. This is delegated
     * to `facetService.decreaseVisibleValues`.
     */
    decreaseVisibleValues() {
        this.facetService.decreaseVisibleValues(this.facet);
    }
    getLinkParams(value) {
        var _a;
        return this.facetService.getLinkParams((_a = value.query) === null || _a === void 0 ? void 0 : _a.query.value);
    }
}
FacetComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: FacetComponent, deps: [{ token: FacetService }, { token: i0.ElementRef }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
FacetComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: FacetComponent, selector: "cx-facet", inputs: { expandIcon: "expandIcon", collapseIcon: "collapseIcon", facet: "facet" }, host: { properties: { "class.multi-select": "this.isMultiSelect" } }, viewQueries: [{ propertyName: "keyboardFocus", first: true, predicate: FocusDirective, descendants: true }, { propertyName: "values", predicate: ["facetValue"], descendants: true }], ngImport: i0, template: "<ng-container *ngIf=\"state$ | async as state\">\n  <button class=\"heading\" (click)=\"toggleGroup($event)\">\n    {{ facet.name }}\n    <cx-icon class=\"collapse-icon\" [type]=\"collapseIcon\"></cx-icon>\n    <cx-icon class=\"expand-icon\" [type]=\"expandIcon\"></cx-icon>\n  </button>\n\n  <a\n    *ngFor=\"let value of facet.values | slice: 0:state.topVisible\"\n    #facetValue\n    routerLink=\"./\"\n    [queryParams]=\"getLinkParams(value)\"\n    class=\"value\"\n    [class.selected]=\"value.selected\"\n    [cxFocus]=\"value.name\"\n    (keydown.space)=\"openLink($event)\"\n  >\n    <span>\n      <span class=\"label\">{{ value.name }}</span>\n      <span class=\"count\">{{ value.count }}</span>\n    </span>\n  </a>\n\n  <div class=\"more\">\n    <a\n      *ngFor=\"\n        let value of facet.values | slice: state.topVisible:state.maxVisible\n      \"\n      #facetValue\n      routerLink=\"./\"\n      [queryParams]=\"getLinkParams(value)\"\n      class=\"value\"\n      [class.selected]=\"value.selected\"\n      [cxFocus]=\"value.name\"\n      (keydown.space)=\"openLink($event)\"\n    >\n      <span\n        >{{ value.name }}<span class=\"count\">{{ value.count }}</span></span\n      >\n    </a>\n\n    <button\n      *ngIf=\"state.maxVisible > state.topVisible\"\n      (click)=\"decreaseVisibleValues()\"\n      class=\"cx-action-link\"\n      cxFocus=\"moreorless\"\n    >\n      {{ 'productList.showLess' | cxTranslate }}\n    </button>\n\n    <button\n      *ngIf=\"state.maxVisible > 0 && state.maxVisible < facet.values.length\"\n      (click)=\"increaseVisibleValues()\"\n      class=\"cx-action-link\"\n      cxFocus=\"moreorless\"\n    >\n      {{ 'productList.showMore' | cxTranslate }}\n    </button>\n  </div>\n</ng-container>\n", components: [{ type: IconComponent, selector: "cx-icon,[cxIcon]", inputs: ["cxIcon", "type"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i1$1.RouterLinkWithHref, selector: "a[routerLink],area[routerLink]", inputs: ["routerLink", "target", "queryParams", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange", "replaceUrl", "state", "relativeTo"] }, { type: FocusDirective, selector: "[cxFocus]", inputs: ["cxFocus"] }], pipes: { "async": i3.AsyncPipe, "slice": i3.SlicePipe, "cxTranslate": i1.TranslatePipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: FacetComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-facet',
                    templateUrl: './facet.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: FacetService }, { type: i0.ElementRef }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { expandIcon: [{
                type: Input
            }], collapseIcon: [{
                type: Input
            }], isMultiSelect: [{
                type: HostBinding,
                args: ['class.multi-select']
            }], values: [{
                type: ViewChildren,
                args: ['facetValue']
            }], keyboardFocus: [{
                type: ViewChild,
                args: [FocusDirective]
            }], facet: [{
                type: Input
            }] } });

class FacetListComponent {
    constructor(facetService, elementRef, renderer) {
        this.facetService = facetService;
        this.elementRef = elementRef;
        this.renderer = renderer;
        /** Emits when the list must close */
        this.closeList = new EventEmitter();
        /** The list of all facet and values related to the products in the list */
        this.facetList$ = this.facetService.facetList$;
        this.iconTypes = ICON_TYPE;
        this.dialogFocusConfig = {
            trap: true,
            block: true,
            focusOnEscape: true,
            autofocus: 'cx-facet',
        };
    }
    /**
     * Indicates that the facet navigation is rendered in dialog.
     */
    set isDialog(value) {
        this._isDialog = value;
        if (value) {
            this.renderer.addClass(document.body, 'modal-open');
        }
    }
    get isDialog() {
        return this._isDialog;
    }
    handleClick() {
        this.close();
    }
    /**
     * Toggles the facet group in case it is not expanded.
     */
    expandFacetGroup(facet, ref) {
        if (!ref.isExpanded) {
            this.facetService.toggle(facet, ref.isExpanded);
        }
    }
    /**
     * Indicates that the facet group has been expanded.
     */
    isExpanded(facet) {
        return this.facetService
            .getState(facet)
            .pipe(map((value) => value.toggled === FacetGroupCollapsedState.EXPANDED));
    }
    /**
     * Indicates that the facet group has been collapsed.
     */
    isCollapsed(facet) {
        return this.facetService
            .getState(facet)
            .pipe(map((value) => value.toggled === FacetGroupCollapsedState.COLLAPSED));
    }
    close(event) {
        this.renderer.removeClass(document.body, 'modal-open');
        this.closeList.emit(event);
    }
    block(event) {
        event.stopPropagation();
    }
}
FacetListComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: FacetListComponent, deps: [{ token: FacetService }, { token: i0.ElementRef }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component });
FacetListComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: FacetListComponent, selector: "cx-facet-list", inputs: { isDialog: "isDialog" }, outputs: { closeList: "closeList" }, host: { listeners: { "click": "handleClick()" } }, ngImport: i0, template: "<div\n  class=\"inner\"\n  *ngIf=\"(facetList$ | async)?.facets as facets\"\n  [cxFocus]=\"isDialog ? dialogFocusConfig : {}\"\n  (esc)=\"close($event)\"\n  (click)=\"block($event)\"\n>\n  <h4>\n    {{ 'productList.filterBy.label' | cxTranslate }}\n    <button\n      type=\"button\"\n      class=\"close\"\n      [attr.aria-label]=\"'common.close' | cxTranslate\"\n      (click)=\"close()\"\n    >\n      <cx-icon aria-hidden=\"true\" [type]=\"iconTypes.CLOSE\"></cx-icon>\n    </button>\n  </h4>\n\n  <!-- \n      Here we'd like to introduce configurable facet components, \n      either by using specific configuration or generic sproutlets \n  -->\n  <cx-facet\n    *ngFor=\"let facet of facets\"\n    #facetRef\n    [facet]=\"facet\"\n    [cxFocus]=\"{ lock: true, trap: true, autofocus: 'a' }\"\n    (unlock)=\"expandFacetGroup(facet, facetRef)\"\n    [class.expanded]=\"isExpanded(facet) | async\"\n    [class.collapsed]=\"isCollapsed(facet) | async\"\n  ></cx-facet>\n</div>\n", components: [{ type: IconComponent, selector: "cx-icon,[cxIcon]", inputs: ["cxIcon", "type"] }, { type: FacetComponent, selector: "cx-facet", inputs: ["expandIcon", "collapseIcon", "facet"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: FocusDirective, selector: "[cxFocus]", inputs: ["cxFocus"] }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], pipes: { "async": i3.AsyncPipe, "cxTranslate": i1.TranslatePipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: FacetListComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-facet-list',
                    templateUrl: './facet-list.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: FacetService }, { type: i0.ElementRef }, { type: i0.Renderer2 }]; }, propDecorators: { isDialog: [{
                type: Input
            }], closeList: [{
                type: Output
            }], handleClick: [{
                type: HostListener,
                args: ['click']
            }] } });

class FacetModule {
}
FacetModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: FacetModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
FacetModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: FacetModule, declarations: [FacetComponent], imports: [CommonModule,
        RouterModule,
        UrlModule,
        I18nModule,
        IconModule,
        KeyboardFocusModule], exports: [FacetComponent] });
FacetModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: FacetModule, imports: [[
            CommonModule,
            RouterModule,
            UrlModule,
            I18nModule,
            IconModule,
            KeyboardFocusModule,
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: FacetModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        RouterModule,
                        UrlModule,
                        I18nModule,
                        IconModule,
                        KeyboardFocusModule,
                    ],
                    declarations: [FacetComponent],
                    exports: [FacetComponent],
                }]
        }] });

class FacetListModule {
}
FacetListModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: FacetListModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
FacetListModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: FacetListModule, declarations: [FacetListComponent], imports: [CommonModule,
        I18nModule,
        IconModule,
        FacetModule,
        KeyboardFocusModule], exports: [FacetListComponent] });
FacetListModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: FacetListModule, imports: [[
            CommonModule,
            I18nModule,
            IconModule,
            FacetModule,
            KeyboardFocusModule,
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: FacetListModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        I18nModule,
                        IconModule,
                        FacetModule,
                        KeyboardFocusModule,
                    ],
                    declarations: [FacetListComponent],
                    exports: [FacetListComponent],
                }]
        }] });

class ProductFacetNavigationComponent {
    constructor(breakpointService) {
        this.breakpointService = breakpointService;
        this.iconTypes = ICON_TYPE;
        /**
         * We delay the removal of DOM so that animations can finish playing before the
         * DOM is removed. Removing the DOM, as hidding is not enough to stop elements
         * to be focused.
         */
        this.CLOSE_DELAY = 300;
        this.open$ = new BehaviorSubject(false);
        /**
         * Emits the open state that indicates whether the facet list should be rendered.
         * This is either done instantly, or after the user triggers this by using the trigger
         * button. This driven by the visiibility of the trigger, so that the CSS drives
         * the behaviour. This can differ per breakpoint.
         *
         * There's a configurable delay for the closed state, so that the DOM is not removed
         * before some CSS animations are done.
         */
        this.isOpen$ = this.breakpointService.breakpoint$.pipe(
        // deffer emitting a new value to the next micro-task to ensure that the `hasTrigger`
        // method represents the actual UI state.
        observeOn(asapScheduler), switchMap(() => (this.hasTrigger ? this.open$ : of(true))), delayWhen((launched) => interval(launched ? 0 : this.CLOSE_DELAY)));
        /**
         * Emits the active state that indicates whether the facet list is activated. Activation
         * is related to the css, so that a animation or transition can visualize opening/closing
         * the list (i.e. dialog).
         */
        this.isActive$ = this.open$.pipe(
        // deffer emitting a new value to the next micro-task to ensure the active class is
        //  applied after the DOM is created
        observeOn(asapScheduler));
    }
    launch() {
        this.open$.next(true);
    }
    close() {
        this.open$.next(false);
        this.trigger.nativeElement.focus();
    }
    /**
     * Indicates that the facet navigation should be open explicitely by a trigger.
     * This is fully controlled by CSS, where the trigger button can be hidden
     * (display:none) for certain screen sizes.
     */
    get hasTrigger() {
        return this.trigger.nativeElement.offsetParent !== null;
    }
}
ProductFacetNavigationComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductFacetNavigationComponent, deps: [{ token: BreakpointService }], target: i0.ɵɵFactoryTarget.Component });
ProductFacetNavigationComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: ProductFacetNavigationComponent, selector: "cx-product-facet-navigation", viewQueries: [{ propertyName: "trigger", first: true, predicate: ["trigger"], descendants: true }], ngImport: i0, template: "<button\n  #trigger\n  class=\"btn btn-action btn-block dialog-trigger\"\n  (click)=\"launch()\"\n>\n  <cx-icon [type]=\"iconTypes.FILTER\"></cx-icon>\n  {{ 'productList.filterBy.label' | cxTranslate }}\n</button>\n\n<cx-active-facets></cx-active-facets>\n\n<cx-facet-list\n  *ngIf=\"isOpen$ | async\"\n  [isDialog]=\"hasTrigger\"\n  (closeList)=\"close()\"\n  [class.active]=\"isActive$ | async\"\n  [class.dialog]=\"hasTrigger\"\n></cx-facet-list>\n", components: [{ type: IconComponent, selector: "cx-icon,[cxIcon]", inputs: ["cxIcon", "type"] }, { type: ActiveFacetsComponent, selector: "cx-active-facets", inputs: ["closeIcon"] }, { type: FacetListComponent, selector: "cx-facet-list", inputs: ["isDialog"], outputs: ["closeList"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "cxTranslate": i1.TranslatePipe, "async": i3.AsyncPipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductFacetNavigationComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-product-facet-navigation',
                    templateUrl: './product-facet-navigation.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: BreakpointService }]; }, propDecorators: { trigger: [{
                type: ViewChild,
                args: ['trigger']
            }] } });

class ProductFacetNavigationModule {
}
ProductFacetNavigationModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductFacetNavigationModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ProductFacetNavigationModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductFacetNavigationModule, declarations: [ProductFacetNavigationComponent], imports: [CommonModule,
        FacetListModule,
        ActiveFacetsModule,
        IconModule,
        I18nModule, i1.ConfigModule], exports: [ProductFacetNavigationComponent] });
ProductFacetNavigationModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductFacetNavigationModule, imports: [[
            CommonModule,
            FacetListModule,
            ActiveFacetsModule,
            IconModule,
            I18nModule,
            ConfigModule.withConfig({
                cmsComponents: {
                    ProductRefinementComponent: {
                        component: ProductFacetNavigationComponent,
                    },
                },
            }),
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductFacetNavigationModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        FacetListModule,
                        ActiveFacetsModule,
                        IconModule,
                        I18nModule,
                        ConfigModule.withConfig({
                            cmsComponents: {
                                ProductRefinementComponent: {
                                    component: ProductFacetNavigationComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [ProductFacetNavigationComponent],
                    exports: [ProductFacetNavigationComponent],
                }]
        }] });

class ProductListModule {
}
ProductListModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductListModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ProductListModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductListModule, declarations: [ProductListComponent,
        ProductListItemComponent,
        ProductGridItemComponent,
        ProductViewComponent,
        ProductScrollComponent], imports: [CommonModule,
        RouterModule,
        MediaModule,
        AddToCartModule,
        ItemCounterModule,
        ListNavigationModule,
        UrlModule,
        I18nModule,
        StarRatingModule,
        IconModule,
        SpinnerModule,
        InfiniteScrollModule,
        FeaturesConfigModule,
        OutletModule], exports: [ProductListComponent,
        ProductListItemComponent,
        ProductGridItemComponent,
        ProductViewComponent,
        ProductScrollComponent] });
ProductListModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductListModule, providers: [
        provideDefaultConfig(defaultViewConfig),
        provideDefaultConfig({
            cmsComponents: {
                CMSProductListComponent: {
                    component: ProductListComponent,
                },
                ProductGridComponent: {
                    component: ProductListComponent,
                },
                SearchResultsListComponent: {
                    component: ProductListComponent,
                },
            },
        }),
    ], imports: [[
            CommonModule,
            RouterModule,
            MediaModule,
            AddToCartModule,
            ItemCounterModule,
            ListNavigationModule,
            UrlModule,
            I18nModule,
            StarRatingModule,
            IconModule,
            SpinnerModule,
            InfiniteScrollModule,
            FeaturesConfigModule,
            OutletModule,
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductListModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        RouterModule,
                        MediaModule,
                        AddToCartModule,
                        ItemCounterModule,
                        ListNavigationModule,
                        UrlModule,
                        I18nModule,
                        StarRatingModule,
                        IconModule,
                        SpinnerModule,
                        InfiniteScrollModule,
                        FeaturesConfigModule,
                        OutletModule,
                    ],
                    providers: [
                        provideDefaultConfig(defaultViewConfig),
                        provideDefaultConfig({
                            cmsComponents: {
                                CMSProductListComponent: {
                                    component: ProductListComponent,
                                },
                                ProductGridComponent: {
                                    component: ProductListComponent,
                                },
                                SearchResultsListComponent: {
                                    component: ProductListComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [
                        ProductListComponent,
                        ProductListItemComponent,
                        ProductGridItemComponent,
                        ProductViewComponent,
                        ProductScrollComponent,
                    ],
                    exports: [
                        ProductListComponent,
                        ProductListItemComponent,
                        ProductGridItemComponent,
                        ProductViewComponent,
                        ProductScrollComponent,
                    ],
                }]
        }] });

class ProductSummaryComponent {
    constructor(currentProductService) {
        this.currentProductService = currentProductService;
        this.outlets = ProductDetailOutlets;
        this.product$ = this.currentProductService.getProduct([
            "details" /* DETAILS */,
            "price" /* PRICE */,
        ]);
    }
}
ProductSummaryComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductSummaryComponent, deps: [{ token: CurrentProductService }], target: i0.ɵɵFactoryTarget.Component });
ProductSummaryComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: ProductSummaryComponent, selector: "cx-product-summary", ngImport: i0, template: "<ng-container *ngIf=\"product$ | async as product\">\n  <ng-template\n    [cxOutlet]=\"outlets.PRICE\"\n    [cxOutletContext]=\"{ product: product }\"\n  >\n    <div\n      [attr.aria-label]=\"'productSummary.newItemPrice' | cxTranslate\"\n      class=\"price\"\n    >\n      {{ product?.price?.formattedValue }}\n    </div>\n  </ng-template>\n\n  <ng-template\n    [cxOutlet]=\"outlets.SUMMARY\"\n    [cxOutletContext]=\"{ product: product }\"\n  >\n    <p [innerHTML]=\"product?.summary\" class=\"summary\"></p>\n  </ng-template>\n\n  <!-- @TODO: Temp. Comment out share link while not in use by CMS -->\n  <!-- <ng-container *cxOutlet=\"outlets.SHARE\">\n        <div>\n          <a href=\"#\" class=\"share btn-link\">\n            {{ 'productSummary.share' | cxTranslate }}\n          </a>\n        </div>\n      </ng-container> -->\n</ng-container>\n", directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: OutletDirective, selector: "[cxOutlet]", inputs: ["cxOutlet", "cxOutletContext", "cxOutletDefer"], outputs: ["loaded"] }], pipes: { "async": i3.AsyncPipe, "cxTranslate": i1.TranslatePipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductSummaryComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-product-summary',
                    templateUrl: './product-summary.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: CurrentProductService }]; } });

class ProductSummaryModule {
}
ProductSummaryModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductSummaryModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ProductSummaryModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductSummaryModule, declarations: [ProductSummaryComponent], imports: [CommonModule, OutletModule, I18nModule], exports: [ProductSummaryComponent] });
ProductSummaryModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductSummaryModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                ProductSummaryComponent: {
                    component: ProductSummaryComponent,
                },
            },
        }),
    ], imports: [[CommonModule, OutletModule, I18nModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductSummaryModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, OutletModule, I18nModule],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                ProductSummaryComponent: {
                                    component: ProductSummaryComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [ProductSummaryComponent],
                    exports: [ProductSummaryComponent],
                }]
        }] });

class ProductAttributesComponent {
    constructor(currentProductService) {
        this.currentProductService = currentProductService;
        this.product$ = this.currentProductService.getProduct("attributes" /* ATTRIBUTES */);
    }
}
ProductAttributesComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductAttributesComponent, deps: [{ token: CurrentProductService }], target: i0.ɵɵFactoryTarget.Component });
ProductAttributesComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: ProductAttributesComponent, selector: "cx-product-attributes", ngImport: i0, template: "<ng-container *ngIf=\"product$ | async as product\">\n  <div class=\"container\">\n    <h2>{{ 'productDetails.specification' | cxTranslate }}</h2>\n    <table *ngFor=\"let class of product?.classifications\">\n      <th>\n        <h3>{{ class.name }}</h3>\n      </th>\n      <tr *ngFor=\"let feature of class.features\">\n        <td>{{ feature.name }}</td>\n        <td>\n          <ul>\n            <li *ngFor=\"let featureValue of feature?.featureValues\">\n              {{ featureValue?.value }}\n              <span\n                *ngIf=\"\n                  feature.featureUnit?.symbol?.length > 0 &&\n                  feature.featureUnit.unitType != '300'\n                \"\n              >\n                {{ feature.featureUnit.symbol }}\n              </span>\n            </li>\n          </ul>\n        </td>\n      </tr>\n    </table>\n  </div>\n</ng-container>\n", directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], pipes: { "async": i3.AsyncPipe, "cxTranslate": i1.TranslatePipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductAttributesComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-product-attributes',
                    templateUrl: './product-attributes.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: CurrentProductService }]; } });

class ProductAttributesModule {
}
ProductAttributesModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductAttributesModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ProductAttributesModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductAttributesModule, declarations: [ProductAttributesComponent], imports: [CommonModule, I18nModule], exports: [ProductAttributesComponent] });
ProductAttributesModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductAttributesModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                ProductSpecsTabComponent: {
                    component: ProductAttributesComponent,
                },
            },
        }),
    ], imports: [[CommonModule, I18nModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductAttributesModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, I18nModule],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                ProductSpecsTabComponent: {
                                    component: ProductAttributesComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [ProductAttributesComponent],
                    exports: [ProductAttributesComponent],
                }]
        }] });

class ProductDetailsTabComponent {
    constructor(currentProductService) {
        this.currentProductService = currentProductService;
    }
    ngOnInit() {
        this.product$ = this.currentProductService.getProduct();
    }
}
ProductDetailsTabComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductDetailsTabComponent, deps: [{ token: CurrentProductService }], target: i0.ɵɵFactoryTarget.Component });
ProductDetailsTabComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: ProductDetailsTabComponent, selector: "cx-product-details-tab", ngImport: i0, template: "<ng-container *ngIf=\"product$ | async as product\">\n  <div class=\"container\" [innerHTML]=\"product?.description\"></div>\n</ng-container>\n", directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "async": i3.AsyncPipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductDetailsTabComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-product-details-tab',
                    templateUrl: './product-details-tab.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: CurrentProductService }]; } });

class ProductDetailsTabModule {
}
ProductDetailsTabModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductDetailsTabModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ProductDetailsTabModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductDetailsTabModule, declarations: [ProductDetailsTabComponent], imports: [CommonModule], exports: [ProductDetailsTabComponent] });
ProductDetailsTabModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductDetailsTabModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                ProductDetailsTabComponent: {
                    component: ProductDetailsTabComponent,
                },
            },
        }),
    ], imports: [[CommonModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductDetailsTabModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                ProductDetailsTabComponent: {
                                    component: ProductDetailsTabComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [ProductDetailsTabComponent],
                    exports: [ProductDetailsTabComponent],
                }]
        }] });

class ProductReviewsComponent {
    constructor(reviewService, currentProductService, fb, cd) {
        this.reviewService = reviewService;
        this.currentProductService = currentProductService;
        this.fb = fb;
        this.cd = cd;
        this.isWritingReview = false;
        // TODO: configurable
        this.initialMaxListItems = 5;
        this.product$ = this.currentProductService.getProduct();
        this.reviews$ = this.product$.pipe(filter((p) => !!p), map((p) => p.code), distinctUntilChanged(), switchMap((productCode) => this.reviewService.getByProductCode(productCode)), tap(() => {
            this.resetReviewForm();
            this.maxListItems = this.initialMaxListItems;
        }));
    }
    initiateWriteReview() {
        this.isWritingReview = true;
        this.cd.detectChanges();
        if (this.titleInput && this.titleInput.nativeElement) {
            this.titleInput.nativeElement.focus();
        }
    }
    cancelWriteReview() {
        this.isWritingReview = false;
        this.resetReviewForm();
        this.cd.detectChanges();
        if (this.writeReviewButton && this.writeReviewButton.nativeElement) {
            this.writeReviewButton.nativeElement.focus();
        }
    }
    setRating(rating) {
        this.reviewForm.controls.rating.setValue(rating);
    }
    submitReview(product) {
        if (this.reviewForm.valid) {
            this.addReview(product);
        }
        else {
            this.reviewForm.markAllAsTouched();
        }
    }
    addReview(product) {
        const reviewFormControls = this.reviewForm.controls;
        const review = {
            headline: reviewFormControls.title.value,
            comment: reviewFormControls.comment.value,
            rating: reviewFormControls.rating.value,
            alias: reviewFormControls.reviewerName.value,
        };
        this.reviewService.add(product.code, review);
        this.isWritingReview = false;
        this.resetReviewForm();
        this.cd.detectChanges();
        if (this.writeReviewButton && this.writeReviewButton.nativeElement) {
            this.writeReviewButton.nativeElement.focus();
        }
    }
    resetReviewForm() {
        this.reviewForm = this.fb.group({
            title: ['', Validators.required],
            comment: ['', Validators.required],
            rating: [null, CustomFormValidators.starRatingEmpty],
            reviewerName: '',
        });
    }
}
ProductReviewsComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductReviewsComponent, deps: [{ token: i1.ProductReviewService }, { token: CurrentProductService }, { token: i3$1.FormBuilder }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
ProductReviewsComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: ProductReviewsComponent, selector: "cx-product-reviews", viewQueries: [{ propertyName: "titleInput", first: true, predicate: ["titleInput"], descendants: true }, { propertyName: "writeReviewButton", first: true, predicate: ["writeReviewButton"], descendants: true }], ngImport: i0, template: "<div class=\"container\" *ngIf=\"product$ | async as product\">\n  <h2>\n    {{ 'productDetails.reviews' | cxTranslate }} ({{ product.numberOfReviews }})\n  </h2>\n  <ng-container *ngIf=\"!isWritingReview; else writeReview\">\n    <div class=\"header\">\n      <h3>{{ 'productReview.overallRating' | cxTranslate }}</h3>\n      <button\n        #writeReviewButton\n        class=\"btn btn-primary\"\n        (click)=\"initiateWriteReview()\"\n      >\n        {{ 'productReview.writeReview' | cxTranslate }}\n      </button>\n      <cx-star-rating\n        *ngIf=\"product.averageRating\"\n        class=\"rating\"\n        [rating]=\"product.averageRating\"\n      ></cx-star-rating>\n      <div class=\"rating\" *ngIf=\"!product.averageRating\">\n        {{ 'productDetails.noReviews' | cxTranslate }}\n      </div>\n    </div>\n\n    <ng-container *ngIf=\"!isWritingReview; else writeReview\">\n      <ng-container *ngIf=\"reviews$ | async as reviews\">\n        <div\n          class=\"review\"\n          tabindex=\"0\"\n          *ngFor=\"let review of reviews | slice: 0:maxListItems\"\n        >\n          <div class=\"title\">{{ review.headline }}</div>\n          <cx-star-rating [rating]=\"review.rating\"></cx-star-rating>\n          <div class=\"name\">\n            {{ review.alias ? review.alias : review.principal?.name }}\n          </div>\n          <div class=\"date\">{{ review.date | cxDate }}</div>\n          <div class=\"text\">{{ review.comment }}</div>\n        </div>\n        <div *ngIf=\"reviews.length > initialMaxListItems\">\n          <button\n            class=\"btn btn-primary\"\n            (click)=\"maxListItems = reviews.length\"\n            *ngIf=\"maxListItems === initialMaxListItems\"\n          >\n            {{ 'productReview.more' | cxTranslate }}\n          </button>\n          <button\n            class=\"btn btn-primary\"\n            (click)=\"maxListItems = initialMaxListItems\"\n            *ngIf=\"maxListItems !== initialMaxListItems\"\n          >\n            {{ 'productReview.less' | cxTranslate }}\n          </button>\n        </div>\n      </ng-container>\n    </ng-container>\n  </ng-container>\n\n  <ng-template #writeReview>\n    <form (ngSubmit)=\"submitReview(product)\" [formGroup]=\"reviewForm\">\n      <div class=\"form-group\">\n        <label>\n          <span class=\"label-content\">{{\n            'productReview.reviewTitle' | cxTranslate\n          }}</span>\n          <input\n            aria-required=\"true\"\n            #titleInput\n            type=\"text\"\n            class=\"form-control\"\n            formControlName=\"title\"\n          />\n          <cx-form-errors\n            aria-live=\"assertive\"\n            aria-atomic=\"true\"\n            [control]=\"reviewForm.get('title')\"\n          ></cx-form-errors>\n        </label>\n      </div>\n      <div class=\"form-group\">\n        <label>\n          <span class=\"label-content\">{{\n            'productReview.writeYourComments' | cxTranslate\n          }}</span>\n          <textarea\n            aria-required=\"true\"\n            class=\"form-control\"\n            rows=\"3\"\n            formControlName=\"comment\"\n          ></textarea>\n          <cx-form-errors\n            aria-live=\"assertive\"\n            aria-atomic=\"true\"\n            [control]=\"reviewForm.get('comment')\"\n          ></cx-form-errors>\n        </label>\n      </div>\n      <div class=\"form-group\">\n        <label>\n          <span class=\"label-content\">{{\n            'productReview.rating' | cxTranslate\n          }}</span>\n          <input\n            aria-required=\"true\"\n            type=\"number\"\n            formControlName=\"rating\"\n            class=\"rating-input\"\n          />\n          <cx-star-rating\n            (change)=\"setRating($event)\"\n            [disabled]=\"false\"\n          ></cx-star-rating>\n          <cx-form-errors\n            aria-live=\"assertive\"\n            aria-atomic=\"true\"\n            [control]=\"reviewForm.get('rating')\"\n          ></cx-form-errors>\n        </label>\n      </div>\n      <div class=\"form-group\">\n        <label>\n          <span class=\"label-content\">{{\n            'productReview.reviewerName' | cxTranslate\n          }}</span>\n          <input\n            type=\"text\"\n            class=\"form-control\"\n            formControlName=\"reviewerName\"\n          />\n        </label>\n      </div>\n      <div class=\"form-group row\">\n        <div class=\"col-12 col-md-4\">\n          <button\n            type=\"button\"\n            class=\"btn btn-block btn-secondary\"\n            (click)=\"cancelWriteReview()\"\n          >\n            {{ 'common.cancel' | cxTranslate }}\n          </button>\n        </div>\n        <div class=\"col-12 col-md-4\">\n          <button type=\"submit\" class=\"btn btn-block btn-primary\">\n            {{ 'common.submit' | cxTranslate }}\n          </button>\n        </div>\n      </div>\n    </form>\n  </ng-template>\n</div>\n", components: [{ type: StarRatingComponent, selector: "cx-star-rating", inputs: ["disabled", "rating"], outputs: ["change"] }, { type: FormErrorsComponent, selector: "cx-form-errors", inputs: ["prefix", "translationParams", "control"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i3$1.ɵNgNoValidate, selector: "form:not([ngNoForm]):not([ngNativeValidate])" }, { type: i3$1.NgControlStatusGroup, selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { type: i3$1.FormGroupDirective, selector: "[formGroup]", inputs: ["formGroup"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }, { type: i3$1.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { type: i3$1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i3$1.FormControlName, selector: "[formControlName]", inputs: ["disabled", "formControlName", "ngModel"], outputs: ["ngModelChange"] }, { type: i3$1.NumberValueAccessor, selector: "input[type=number][formControlName],input[type=number][formControl],input[type=number][ngModel]" }], pipes: { "async": i3.AsyncPipe, "cxTranslate": i1.TranslatePipe, "slice": i3.SlicePipe, "cxDate": i1.CxDatePipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductReviewsComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-product-reviews',
                    templateUrl: './product-reviews.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: i1.ProductReviewService }, { type: CurrentProductService }, { type: i3$1.FormBuilder }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { titleInput: [{
                type: ViewChild,
                args: ['titleInput', { static: false }]
            }], writeReviewButton: [{
                type: ViewChild,
                args: ['writeReviewButton', { static: false }]
            }] } });

class ProductReviewsModule {
}
ProductReviewsModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductReviewsModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ProductReviewsModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductReviewsModule, declarations: [ProductReviewsComponent], imports: [CommonModule,
        ReactiveFormsModule,
        FormsModule,
        I18nModule,
        StarRatingModule,
        FormErrorsModule], exports: [ProductReviewsComponent] });
ProductReviewsModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductReviewsModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                ProductReviewsTabComponent: {
                    component: ProductReviewsComponent,
                },
            },
        }),
    ], imports: [[
            CommonModule,
            ReactiveFormsModule,
            FormsModule,
            I18nModule,
            StarRatingModule,
            FormErrorsModule,
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductReviewsModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        ReactiveFormsModule,
                        FormsModule,
                        I18nModule,
                        StarRatingModule,
                        FormErrorsModule,
                    ],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                ProductReviewsTabComponent: {
                                    component: ProductReviewsComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [ProductReviewsComponent],
                    exports: [ProductReviewsComponent],
                }]
        }] });

class ProductTabsModule {
}
ProductTabsModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductTabsModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ProductTabsModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductTabsModule, imports: [ProductAttributesModule,
        ProductDetailsTabModule,
        ProductReviewsModule] });
ProductTabsModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductTabsModule, imports: [[
            ProductAttributesModule,
            ProductDetailsTabModule,
            ProductReviewsModule,
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductTabsModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        ProductAttributesModule,
                        ProductDetailsTabModule,
                        ProductReviewsModule,
                    ],
                }]
        }] });

class StockNotificationDialogComponent {
    constructor(modalService, interestsService) {
        this.modalService = modalService;
        this.interestsService = interestsService;
        this.enabledPrefs = [];
    }
    close() {
        this.modalService.dismissActiveModal();
    }
    ngOnDestroy() {
        if (this.subscribeSuccess$) {
            this.subscribeSuccess$
                .subscribe((success) => {
                if (success) {
                    this.interestsService.resetAddInterestState();
                }
            })
                .unsubscribe();
        }
    }
}
StockNotificationDialogComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: StockNotificationDialogComponent, deps: [{ token: ModalService }, { token: i1.UserInterestsService }], target: i0.ɵɵFactoryTarget.Component });
StockNotificationDialogComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: StockNotificationDialogComponent, selector: "cx-stock-notification-dialog", ngImport: i0, template: "<div class=\"cx-dialog-header modal-header\">\n  <div class=\"cx-dialog-title modal-title\">\n    {{ 'stockNotification.subscriptionDialog.header' | cxTranslate }}\n  </div>\n  <button\n    type=\"button\"\n    [attr.aria-label]=\"'common.close' | cxTranslate\"\n    class=\"close\"\n    tabindex=\"-1\"\n    (click)=\"close()\"\n  >\n    <span aria-hidden=\"true\">&times;</span>\n  </button>\n</div>\n\n<ng-container *ngIf=\"subscribeSuccess$ | async; else loading\">\n  <div class=\"cx-dialog-body modal-body\">\n    <div class=\"container\">\n      <p>\n        {{\n          'stockNotification.subscriptionDialog.notifiedPrefix' | cxTranslate\n        }}\n      </p>\n      <p *ngFor=\"let preference of enabledPrefs\" class=\"channels\">\n        <span>{{ preference.channel }}</span\n        ><span *ngIf=\"preference.value\">{{ ': ' + preference.value }}</span>\n      </p>\n      <p>\n        {{\n          'stockNotification.subscriptionDialog.notifiedSuffix' | cxTranslate\n        }}\n      </p>\n      <p>\n        {{\n          'stockNotification.subscriptionDialog.manageChannelsPrefix'\n            | cxTranslate\n        }}\n        <a\n          (click)=\"close()\"\n          [routerLink]=\"['/my-account/notification-preference']\"\n          class=\"link-prefs\"\n        >\n          {{\n            'stockNotification.subscriptionDialog.manageChannelsLink'\n              | cxTranslate\n          }}</a\n        >\n        {{\n          'stockNotification.subscriptionDialog.manageChannelsSuffix'\n            | cxTranslate\n        }}\n      </p>\n\n      <p>\n        {{\n          'stockNotification.subscriptionDialog.manageSubscriptionsPrefix'\n            | cxTranslate\n        }}\n        <a\n          (click)=\"close()\"\n          [routerLink]=\"['/my-account/my-interests']\"\n          class=\"link-interests\"\n        >\n          {{\n            'stockNotification.subscriptionDialog.manageSubscriptionsLink'\n              | cxTranslate\n          }}</a\n        >\n        {{\n          'stockNotification.subscriptionDialog.manageSubscriptionsSuffix'\n            | cxTranslate\n        }}\n      </p>\n      <div class=\"row\">\n        <div class=\"cx-dialog-actions col-sm-12 col-md-3 offset-md-9\">\n          <button\n            class=\"btn btn-primary btn-block btn-ok\"\n            type=\"button\"\n            (click)=\"close()\"\n          >\n            {{ 'stockNotification.subscriptionDialog.okBtn' | cxTranslate }}\n          </button>\n        </div>\n      </div>\n    </div>\n  </div>\n</ng-container>\n\n<ng-template #loading>\n  <div class=\"cx-dialog-body modal-body\">\n    <p>\n      {{ 'stockNotification.subscriptionDialog.subscribing' | cxTranslate }}\n    </p>\n    <div class=\"cx-dialog-row\">\n      <div class=\"col-sm-12\">\n        <cx-spinner></cx-spinner>\n      </div>\n    </div>\n  </div>\n</ng-template>\n", components: [{ type: SpinnerComponent, selector: "cx-spinner" }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i1$1.RouterLinkWithHref, selector: "a[routerLink],area[routerLink]", inputs: ["routerLink", "target", "queryParams", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange", "replaceUrl", "state", "relativeTo"] }], pipes: { "cxTranslate": i1.TranslatePipe, "async": i3.AsyncPipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: StockNotificationDialogComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-stock-notification-dialog',
                    templateUrl: './stock-notification-dialog.component.html',
                }]
        }], ctorParameters: function () { return [{ type: ModalService }, { type: i1.UserInterestsService }]; } });

class StockNotificationComponent {
    constructor(currentProductService, globalMessageService, translationService, interestsService, modalService, notificationPrefService, userIdService) {
        this.currentProductService = currentProductService;
        this.globalMessageService = globalMessageService;
        this.translationService = translationService;
        this.interestsService = interestsService;
        this.modalService = modalService;
        this.notificationPrefService = notificationPrefService;
        this.userIdService = userIdService;
        this.anonymous = true;
        this.enabledPrefs = [];
        this.subscriptions = new Subscription();
    }
    ngOnInit() {
        this.outOfStock$ = combineLatest([
            this.currentProductService.getProduct().pipe(filter(isNotNullable)),
            this.userIdService.getUserId(),
        ]).pipe(tap(([product, userId]) => {
            this.productCode = product.code;
            if (userId !== OCC_USER_ID_ANONYMOUS) {
                this.anonymous = false;
                this.notificationPrefService.loadPreferences();
                this.interestsService.loadProductInterests(null, null, null, product.code, NotificationType.BACK_IN_STOCK);
            }
        }), map(([product]) => !!product.stock && product.stock.stockLevelStatus === 'outOfStock'));
        this.hasProductInterests$ = this.interestsService
            .getProductInterests()
            .pipe(map((interests) => !!interests.results && interests.results.length === 1));
        this.subscribeSuccess$ =
            this.interestsService.getAddProductInterestSuccess();
        this.isRemoveInterestLoading$ =
            this.interestsService.getRemoveProdutInterestLoading();
        this.prefsEnabled$ = this.notificationPrefService
            .getEnabledPreferences()
            .pipe(tap((prefs) => (this.enabledPrefs = prefs)), map((prefs) => prefs.length > 0));
        this.subscriptions.add(this.interestsService.getAddProductInterestError().subscribe((error) => {
            if (error) {
                this.onInterestAddingError();
            }
        }));
        this.subscriptions.add(this.interestsService
            .getRemoveProdutInterestSuccess()
            .subscribe((success) => {
            if (success) {
                this.onInterestRemovingSuccess();
            }
        }));
    }
    subscribe() {
        this.openDialog();
        this.interestsService.addProductInterest(this.productCode, NotificationType.BACK_IN_STOCK);
    }
    unsubscribe() {
        this.interestsService.removeProdutInterest({
            product: {
                code: this.productCode,
            },
            productInterestEntry: [
                {
                    interestType: NotificationType.BACK_IN_STOCK,
                },
            ],
        }, true);
    }
    onInterestRemovingSuccess() {
        this.subscriptions.add(this.translationService
            .translate('stockNotification.unsubscribeSuccess')
            .pipe(first())
            .subscribe((text) => this.globalMessageService.add(text, GlobalMessageType.MSG_TYPE_INFO)));
        this.interestsService.resetRemoveInterestState();
    }
    onInterestAddingError() {
        this.modalService.dismissActiveModal();
        this.interestsService.resetAddInterestState();
    }
    openDialog() {
        const modalInstance = this.modalService.open(StockNotificationDialogComponent, {
            centered: true,
            size: 'lg',
        }).componentInstance;
        modalInstance.subscribeSuccess$ = this.subscribeSuccess$;
        modalInstance.enabledPrefs = this.enabledPrefs;
    }
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
        this.interestsService.clearProductInterests();
        this.notificationPrefService.clearPreferences();
    }
}
StockNotificationComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: StockNotificationComponent, deps: [{ token: CurrentProductService }, { token: i1.GlobalMessageService }, { token: i1.TranslationService }, { token: i1.UserInterestsService }, { token: ModalService }, { token: i1.UserNotificationPreferenceService }, { token: i1.UserIdService }], target: i0.ɵɵFactoryTarget.Component });
StockNotificationComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: StockNotificationComponent, selector: "cx-stock-notification", ngImport: i0, template: "<ng-container *ngIf=\"outOfStock$ | async\">\n  <ng-container *ngIf=\"!(hasProductInterests$ | async); else stopNotify\">\n    <ng-container *ngIf=\"prefsEnabled$ | async; else disableNotify\">\n      <div class=\"stock-notification-notes\">\n        <p>{{ 'stockNotification.getNotified' | cxTranslate }}</p>\n      </div>\n      <button\n        class=\"btn btn-primary btn-block btn-notify\"\n        type=\"button\"\n        (click)=\"subscribe()\"\n      >\n        {{ 'stockNotification.notifyMe' | cxTranslate }}\n      </button>\n    </ng-container>\n  </ng-container>\n</ng-container>\n\n<ng-template #disableNotify>\n  <div class=\"stock-notification-notes\" id=\"outOfStockMessage\">\n    <p>\n      <ng-container *ngIf=\"anonymous; else loggedIn\">\n        <a [routerLink]=\"{ cxRoute: 'login' } | cxUrl\">\n          {{ 'miniLogin.signInRegister' | cxTranslate }}</a\n        >\n        {{ 'stockNotification.getNotifySuffix' | cxTranslate }}<br />\n      </ng-container>\n      <ng-template #loggedIn>\n        {{ 'stockNotification.getNotify' | cxTranslate }}<br />\n        {{ 'stockNotification.activateChannelsPrefix' | cxTranslate\n        }}<a [routerLink]=\"['/my-account/notification-preference']\">{{\n          'stockNotification.channelsLink' | cxTranslate\n        }}</a\n        >{{ 'stockNotification.activateChannelsSuffix' | cxTranslate }}\n      </ng-template>\n    </p>\n  </div>\n  <button\n    class=\"btn btn-primary btn-block btn-notify\"\n    type=\"button\"\n    disabled=\"true\"\n    aria-describedby=\"outOfStockMessage\"\n  >\n    {{ 'stockNotification.notifyMe' | cxTranslate }}\n  </button>\n</ng-template>\n\n<ng-template #stopNotify>\n  <ng-container *ngIf=\"!(isRemoveInterestLoading$ | async); else loading\">\n    <div class=\"stock-notification-notes\">\n      <p>{{ 'stockNotification.notified' | cxTranslate }}</p>\n    </div>\n    <button\n      class=\"btn btn-primary btn-block btn-stop-notify\"\n      type=\"button\"\n      (click)=\"unsubscribe()\"\n    >\n      {{ 'stockNotification.stopNotify' | cxTranslate }}\n    </button>\n  </ng-container>\n</ng-template>\n\n<ng-template #loading>\n  <div class=\"cx-dialog-body modal-body\">\n    <div class=\"cx-dialog-row\">\n      <div class=\"col-sm-12\">\n        <cx-spinner></cx-spinner>\n      </div>\n    </div>\n  </div>\n</ng-template>\n", components: [{ type: SpinnerComponent, selector: "cx-spinner" }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i1$1.RouterLinkWithHref, selector: "a[routerLink],area[routerLink]", inputs: ["routerLink", "target", "queryParams", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange", "replaceUrl", "state", "relativeTo"] }], pipes: { "async": i3.AsyncPipe, "cxTranslate": i1.TranslatePipe, "cxUrl": i1.UrlPipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: StockNotificationComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-stock-notification',
                    templateUrl: './stock-notification.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: CurrentProductService }, { type: i1.GlobalMessageService }, { type: i1.TranslationService }, { type: i1.UserInterestsService }, { type: ModalService }, { type: i1.UserNotificationPreferenceService }, { type: i1.UserIdService }]; } });

class StockNotificationModule {
}
StockNotificationModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: StockNotificationModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
StockNotificationModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: StockNotificationModule, declarations: [StockNotificationComponent, StockNotificationDialogComponent], imports: [CommonModule, RouterModule, I18nModule, SpinnerModule, UrlModule], exports: [StockNotificationComponent, StockNotificationDialogComponent] });
StockNotificationModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: StockNotificationModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                StockNotificationComponent: {
                    component: StockNotificationComponent,
                },
            },
        }),
    ], imports: [[CommonModule, RouterModule, I18nModule, SpinnerModule, UrlModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: StockNotificationModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [StockNotificationComponent, StockNotificationDialogComponent],
                    imports: [CommonModule, RouterModule, I18nModule, SpinnerModule, UrlModule],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                StockNotificationComponent: {
                                    component: StockNotificationComponent,
                                },
                            },
                        }),
                    ],
                    exports: [StockNotificationComponent, StockNotificationDialogComponent],
                }]
        }] });

/**
 * Guards the _login_ route.
 *
 * Takes care of routing the user to a auth server login page (if implicit or code flow is used).
 * In case of Resource Owner Password Flow just renders the page as normal CMS page.
 */
class LoginGuard {
    constructor(authService, authRedirectService, authConfigService, cmsPageGuard) {
        this.authService = authService;
        this.authRedirectService = authRedirectService;
        this.authConfigService = authConfigService;
        this.cmsPageGuard = cmsPageGuard;
    }
    canActivate(route, state) {
        return this.authService.isUserLoggedIn().pipe(take(1), switchMap((isUserLoggedIn) => {
            if (this.authConfigService.getOAuthFlow() ===
                OAuthFlow.ResourceOwnerPasswordFlow ||
                isUserLoggedIn) {
                return this.cmsPageGuard.canActivate(route, state);
            }
            else {
                // Remember the previous url, so we can redirect user to that page after OAuth server callback
                this.authRedirectService.reportNotAuthGuard();
                // This method can trigger redirect to OAuth server that's why we don't return anything in this case
                const redirected = this.authService.loginWithRedirect();
                if (!redirected) {
                    return of(false);
                }
                return EMPTY;
            }
        }));
    }
}
LoginGuard.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: LoginGuard, deps: [{ token: i1.AuthService }, { token: i1.AuthRedirectService }, { token: i1.AuthConfigService }, { token: CmsPageGuard }], target: i0.ɵɵFactoryTarget.Injectable });
LoginGuard.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: LoginGuard, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: LoginGuard, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.AuthService }, { type: i1.AuthRedirectService }, { type: i1.AuthConfigService }, { type: CmsPageGuard }]; } });

/**
 * This module enables to quickly switch from Resource Owner Password Flow
 * to Implicit Flow or Authorization Code Flow. The `login` route in this case will be
 * responsible for initalizing the redirect to OAuth server to login.
 *
 * Instead of manually invoking OAuth redirect you only have to redirect to `login` page.
 */
class LoginRouteModule {
}
LoginRouteModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: LoginRouteModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
LoginRouteModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: LoginRouteModule, imports: [PageLayoutModule, i1$1.RouterModule] });
LoginRouteModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: LoginRouteModule, imports: [[
            PageLayoutModule,
            RouterModule.forChild([
                {
                    path: null,
                    canActivate: [LoginGuard],
                    component: PageLayoutComponent,
                    data: { cxRoute: 'login' },
                },
            ]),
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: LoginRouteModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        PageLayoutModule,
                        RouterModule.forChild([
                            {
                                path: null,
                                canActivate: [LoginGuard],
                                component: PageLayoutComponent,
                                data: { cxRoute: 'login' },
                            },
                        ]),
                    ],
                }]
        }] });

/**
 * Guards the _logout_ route.
 *
 * Takes care of routing the user to a logout page (if available) or redirects to
 * the homepage. If the homepage is protected, the user is redirected
 * to the login route instead.
 */
class LogoutGuard {
    constructor(auth, cms, semanticPathService, protectedRoutes, router, authRedirectService) {
        this.auth = auth;
        this.cms = cms;
        this.semanticPathService = semanticPathService;
        this.protectedRoutes = protectedRoutes;
        this.router = router;
        this.authRedirectService = authRedirectService;
    }
    canActivate() {
        // Logout route should never be remembered as a redirect url after login (that would cause logout right after login).
        this.authRedirectService.reportNotAuthGuard();
        /**
         * First we want to complete logout process before redirecting to logout page
         * We want to avoid errors like `token is no longer valid`
         */
        return from(this.logout()).pipe(switchMap(() => {
            return this.cms
                .hasPage({
                id: this.semanticPathService.get('logout'),
                type: PageType.CONTENT_PAGE,
            })
                .pipe(map((hasPage) => {
                if (!hasPage) {
                    return this.getRedirectUrl();
                }
                // TODO(#9385): Use CMS page guard here.
                return hasPage;
            }));
        }));
    }
    logout() {
        return this.auth.coreLogout();
    }
    /**
     * Whenever there is no specific "logout" page configured in the CMS,
     * we redirect after the user is logged out.
     *
     * The user gets redirected to the homepage, unless the homepage is protected
     * (in case of a closed shop). We'll redirect to the login page instead.
     */
    getRedirectUrl() {
        const cxRoute = this.protectedRoutes.shouldProtect ? 'login' : 'home';
        return this.router.parseUrl(this.semanticPathService.get(cxRoute));
    }
}
LogoutGuard.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: LogoutGuard, deps: [{ token: i1.AuthService }, { token: i1.CmsService }, { token: i1.SemanticPathService }, { token: i1.ProtectedRoutesService }, { token: i1$1.Router }, { token: i1.AuthRedirectService }], target: i0.ɵɵFactoryTarget.Injectable });
LogoutGuard.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: LogoutGuard, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: LogoutGuard, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.AuthService }, { type: i1.CmsService }, { type: i1.SemanticPathService }, { type: i1.ProtectedRoutesService }, { type: i1$1.Router }, { type: i1.AuthRedirectService }]; } });

class LogoutModule {
}
LogoutModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: LogoutModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
LogoutModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: LogoutModule, imports: [PageLayoutModule, i1$1.RouterModule] });
LogoutModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: LogoutModule, imports: [[
            PageLayoutModule,
            RouterModule.forChild([
                {
                    path: null,
                    canActivate: [LogoutGuard, CmsPageGuard],
                    component: PageLayoutComponent,
                    data: { cxRoute: 'logout' },
                },
            ]),
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: LogoutModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        PageLayoutModule,
                        RouterModule.forChild([
                            {
                                path: null,
                                canActivate: [LogoutGuard, CmsPageGuard],
                                component: PageLayoutComponent,
                                data: { cxRoute: 'logout' },
                            },
                        ]),
                    ],
                }]
        }] });

class UserComponentModule {
}
UserComponentModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: UserComponentModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
UserComponentModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: UserComponentModule, imports: [LogoutModule,
        LoginRouteModule,
        ReactiveFormsModule,
        RouterModule,
        UrlModule] });
UserComponentModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: UserComponentModule, imports: [[
            LogoutModule,
            LoginRouteModule,
            ReactiveFormsModule,
            RouterModule,
            UrlModule,
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: UserComponentModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        LogoutModule,
                        LoginRouteModule,
                        ReactiveFormsModule,
                        RouterModule,
                        UrlModule,
                    ],
                }]
        }] });

class WishListItemComponent {
    constructor() {
        this.isLoading = false;
        this.remove = new EventEmitter();
    }
    removeEntry(item) {
        this.remove.emit(item);
    }
}
WishListItemComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: WishListItemComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
WishListItemComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: WishListItemComponent, selector: "cx-wish-list-item", inputs: { isLoading: "isLoading", cartEntry: "cartEntry" }, outputs: { remove: "remove" }, ngImport: i0, template: "<div class=\"row\">\n  <!-- Item Image -->\n  <div class=\"cx-image-container col-2\">\n    <a\n      [routerLink]=\"{ cxRoute: 'product', params: cartEntry.product } | cxUrl\"\n      tabindex=\"-1\"\n    >\n      <cx-media\n        [container]=\"cartEntry.product.images?.PRIMARY\"\n        format=\"thumbnail\"\n      ></cx-media>\n    </a>\n  </div>\n  <!-- Item Information -->\n  <div class=\"cx-info col-10\">\n    <div class=\"cx-info-container row\">\n      <!-- Item Description -->\n      <div class=\"col-md-5 col-lg-5 col-xl-5\">\n        <div *ngIf=\"cartEntry.product.name\" class=\"cx-name\">\n          <a\n            class=\"cx-link\"\n            [routerLink]=\"\n              { cxRoute: 'product', params: cartEntry.product } | cxUrl\n            \"\n            ><h2>{{ cartEntry.product.name }}</h2></a\n          >\n        </div>\n        <div *ngIf=\"cartEntry.product.code\" class=\"cx-code\">\n          {{ 'cartItems.id' | cxTranslate }} {{ cartEntry.product.code }}\n        </div>\n        <!-- Variants -->\n        <ng-container *ngIf=\"cartEntry.product.baseOptions?.length\">\n          <div\n            *ngFor=\"\n              let variant of cartEntry.product.baseOptions[0]?.selected\n                ?.variantOptionQualifiers\n            \"\n            class=\"cx-property\"\n          >\n            <div class=\"cx-label\" *ngIf=\"variant.name && variant.value\">\n              {{ variant.name }}: {{ variant.value }}\n            </div>\n          </div>\n        </ng-container>\n      </div>\n      <!-- Item Price -->\n      <div\n        *ngIf=\"cartEntry.basePrice\"\n        class=\"cx-price col-md-3 col-lg-4 col-xl-4\"\n      >\n        <div class=\"cx-label d-block d-md-none d-lg-none d-xl-none\">\n          {{ 'cartItems.itemPrice' | cxTranslate }}\n        </div>\n        <div *ngIf=\"cartEntry.basePrice\" class=\"cx-value\">\n          {{ cartEntry.basePrice?.formattedValue }}\n        </div>\n      </div>\n      <!-- Total -->\n      <div class=\"col-sm-8 col-md-4 col-lg-3 col-xl-3 cx-add-to-cart\">\n        <cx-add-to-cart\n          *ngIf=\"\n            cartEntry.product.stock.stockLevelStatus !== 'outOfStock';\n            else outOfStock\n          \"\n          [showQuantity]=\"false\"\n          [product]=\"cartEntry.product\"\n        ></cx-add-to-cart>\n        <ng-template #outOfStock>\n          <span class=\"cx-out-of-stock\">\n            {{ 'addToCart.outOfStock' | cxTranslate }}\n          </span>\n        </ng-template>\n      </div>\n    </div>\n    <div class=\"cx-return-button col-12\">\n      <button\n        class=\"btn cx-action-link\"\n        (click)=\"removeEntry(cartEntry)\"\n        [disabled]=\"isLoading\"\n      >\n        {{ 'common.remove' | cxTranslate }}\n      </button>\n    </div>\n  </div>\n</div>\n", components: [{ type: MediaComponent, selector: "cx-media", inputs: ["container", "format", "alt", "role", "loading"], outputs: ["loaded"] }, { type: AddToCartComponent, selector: "cx-add-to-cart", inputs: ["productCode", "showQuantity", "product"] }], directives: [{ type: i1$1.RouterLinkWithHref, selector: "a[routerLink],area[routerLink]", inputs: ["routerLink", "target", "queryParams", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange", "replaceUrl", "state", "relativeTo"] }, { type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], pipes: { "cxUrl": i1.UrlPipe, "cxTranslate": i1.TranslatePipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: WishListItemComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-wish-list-item',
                    templateUrl: './wish-list-item.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], propDecorators: { isLoading: [{
                type: Input
            }], cartEntry: [{
                type: Input
            }], remove: [{
                type: Output
            }] } });

class WishListComponent {
    constructor(wishListService) {
        this.wishListService = wishListService;
        this.wishList$ = this.wishListService.getWishList();
        this.loading$ = this.wishListService.getWishListLoading();
    }
    removeEntry(item) {
        this.wishListService.removeEntry(item);
    }
}
WishListComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: WishListComponent, deps: [{ token: i1.WishListService }], target: i0.ɵɵFactoryTarget.Component });
WishListComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: WishListComponent, selector: "cx-wish-list", ngImport: i0, template: "<ng-container *ngIf=\"wishList$ | async as wishList\">\n  <ng-container *ngIf=\"wishList?.entries?.length > 0; else emptyWishList\">\n    <div class=\"d-none d-md-block d-lg-block d-xl-block\">\n      <div class=\"cx-item-list-header row\">\n        <div class=\"cx-item-list-desc col-md-7 col-lg-6 col-xl-6\">\n          {{ 'cartItems.description' | cxTranslate }}\n        </div>\n        <div class=\"cx-item-list-price col-md-3 col-lg-4 col-xl-4\">\n          {{ 'cartItems.itemPrice' | cxTranslate }}\n        </div>\n        <div class=\"cx-item-list-total col-md-2 col-lg-2 col-xl-2\">\n          {{ 'cartItems.total' | cxTranslate }}\n        </div>\n      </div>\n    </div>\n\n    <div class=\"cx-item-list-row\" *ngFor=\"let entry of wishList?.entries\">\n      <cx-wish-list-item\n        [cartEntry]=\"entry\"\n        [isLoading]=\"loading$ | async\"\n        class=\"cx-wish-list-items\"\n        (remove)=\"removeEntry($event)\"\n      ></cx-wish-list-item>\n    </div>\n  </ng-container>\n</ng-container>\n\n<ng-template #emptyWishList>\n  <h2>{{ 'wishlist.empty' | cxTranslate }}</h2>\n</ng-template>\n", components: [{ type: WishListItemComponent, selector: "cx-wish-list-item", inputs: ["isLoading", "cartEntry"], outputs: ["remove"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], pipes: { "async": i3.AsyncPipe, "cxTranslate": i1.TranslatePipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: WishListComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-wish-list',
                    templateUrl: './wish-list.component.html',
                }]
        }], ctorParameters: function () { return [{ type: i1.WishListService }]; } });

class WishListModule {
}
WishListModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: WishListModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
WishListModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: WishListModule, declarations: [WishListComponent, WishListItemComponent], imports: [AddToCartModule,
        CommonModule,
        I18nModule,
        MediaModule,
        RouterModule,
        StarRatingModule,
        UrlModule,
        ItemCounterModule], exports: [WishListComponent, WishListItemComponent] });
WishListModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: WishListModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                WishListComponent: {
                    component: WishListComponent,
                    guards: [AuthGuard],
                },
            },
        }),
    ], imports: [[
            AddToCartModule,
            CommonModule,
            I18nModule,
            MediaModule,
            RouterModule,
            StarRatingModule,
            UrlModule,
            ItemCounterModule,
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: WishListModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        AddToCartModule,
                        CommonModule,
                        I18nModule,
                        MediaModule,
                        RouterModule,
                        StarRatingModule,
                        UrlModule,
                        ItemCounterModule,
                    ],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                WishListComponent: {
                                    component: WishListComponent,
                                    guards: [AuthGuard],
                                },
                            },
                        }),
                    ],
                    declarations: [WishListComponent, WishListItemComponent],
                    exports: [WishListComponent, WishListItemComponent],
                }]
        }] });

function getProductDetailsUrlMatcherFactory(service, defaultMatcherFactory) {
    const factory = (route) => {
        const defaultMatcher = defaultMatcherFactory(route);
        const suffixPDPMatcher = getSuffixUrlMatcher({
            marker: 'p',
            paramName: 'productCode',
        });
        return service.getCombined([defaultMatcher, suffixPDPMatcher]);
    };
    return factory;
}
/**
 * Injection token with url matcher factory for PDP.
 * The provided url matcher matches both:
 * - the configured `paths` from routing config and
 * - custom pattern  `** / p / :productCode`
 *
 * If the this matcher doesn't fit the requirements, it can be replaced with the DEFAULT_URL_MATCHER
 * or additional matchers can be added for a specific route.
 *
 * Note: Matchers will "match" a route, but do not contribute to the creation of the route, nor do they guard routes.
 */
const PRODUCT_DETAILS_URL_MATCHER = new InjectionToken('PRODUCT_DETAILS_URL_MATCHER', {
    providedIn: 'root',
    factory: () => getProductDetailsUrlMatcherFactory(inject(UrlMatcherService), inject(DEFAULT_URL_MATCHER)),
});

class ProductDetailsPageModule {
}
ProductDetailsPageModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductDetailsPageModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ProductDetailsPageModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductDetailsPageModule, imports: [i1$1.RouterModule] });
ProductDetailsPageModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductDetailsPageModule, providers: [
        provideDefaultConfig({
            routing: {
                routes: {
                    product: {
                        matchers: [PRODUCT_DETAILS_URL_MATCHER],
                    },
                },
            },
        }),
    ], imports: [[
            RouterModule.forChild([
                {
                    path: null,
                    canActivate: [CmsPageGuard],
                    component: PageLayoutComponent,
                    data: { cxRoute: 'product' },
                },
            ]),
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductDetailsPageModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        RouterModule.forChild([
                            {
                                path: null,
                                canActivate: [CmsPageGuard],
                                component: PageLayoutComponent,
                                data: { cxRoute: 'product' },
                            },
                        ]),
                    ],
                    providers: [
                        provideDefaultConfig({
                            routing: {
                                routes: {
                                    product: {
                                        matchers: [PRODUCT_DETAILS_URL_MATCHER],
                                    },
                                },
                            },
                        }),
                    ],
                }]
        }] });

function getProductListingUrlMatcherFactory(service, defaultMatcherFactory) {
    const factory = (route) => {
        const defaultMatcher = defaultMatcherFactory(route);
        const suffixPLPMatcher = getSuffixUrlMatcher({
            marker: 'c',
            paramName: 'categoryCode',
        });
        return service.getCombined([defaultMatcher, suffixPLPMatcher]);
    };
    return factory;
}
/**
 * Injection token with url matcher factory for PLP.
 * The provided url matcher matches both:
 * - the configured `paths` from routing config and
 * - custom pattern  `** / c / :categoryCode`
 *
 * If the this matcher doesn't fit the requirements, it can be replaced with the DEFAULT_URL_MATCHER
 * or additional matchers can be added for a specific route.
 *
 * Note: Matchers will "match" a route, but do not contribute to the creation of the route, nor do they guard routes.
 */
const PRODUCT_LISTING_URL_MATCHER = new InjectionToken('PRODUCT_LISTING_URL_MATCHER', {
    providedIn: 'root',
    factory: () => getProductListingUrlMatcherFactory(inject(UrlMatcherService), inject(DEFAULT_URL_MATCHER)),
});

class ProductListingPageModule {
}
ProductListingPageModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductListingPageModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ProductListingPageModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductListingPageModule, imports: [i1$1.RouterModule] });
ProductListingPageModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductListingPageModule, providers: [
        provideDefaultConfig({
            routing: {
                routes: {
                    category: {
                        matchers: [PRODUCT_LISTING_URL_MATCHER],
                    },
                },
            },
        }),
    ], imports: [[
            RouterModule.forChild([
                {
                    path: null,
                    canActivate: [CmsPageGuard],
                    component: PageLayoutComponent,
                    data: { pageLabel: 'search', cxRoute: 'search' },
                },
                {
                    path: null,
                    canActivate: [CmsPageGuard],
                    component: PageLayoutComponent,
                    data: { cxRoute: 'brand' },
                },
                {
                    // The 'category' route  may include a greedy suffix url matcher '**/c/:categoryCode'
                    // So not to shadow the specific 'brand' route, the 'category' is the last route in the sequence.
                    path: null,
                    canActivate: [CmsPageGuard],
                    component: PageLayoutComponent,
                    data: { cxRoute: 'category' },
                },
            ]),
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductListingPageModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        RouterModule.forChild([
                            {
                                path: null,
                                canActivate: [CmsPageGuard],
                                component: PageLayoutComponent,
                                data: { pageLabel: 'search', cxRoute: 'search' },
                            },
                            {
                                path: null,
                                canActivate: [CmsPageGuard],
                                component: PageLayoutComponent,
                                data: { cxRoute: 'brand' },
                            },
                            {
                                // The 'category' route  may include a greedy suffix url matcher '**/c/:categoryCode'
                                // So not to shadow the specific 'brand' route, the 'category' is the last route in the sequence.
                                path: null,
                                canActivate: [CmsPageGuard],
                                component: PageLayoutComponent,
                                data: { cxRoute: 'category' },
                            },
                        ]),
                    ],
                    providers: [
                        provideDefaultConfig({
                            routing: {
                                routes: {
                                    category: {
                                        matchers: [PRODUCT_LISTING_URL_MATCHER],
                                    },
                                },
                            },
                        }),
                    ],
                }]
        }] });

/**
 * Resolves the context for the specific route, based on the property `data.cxContext`
 * defined in the Angular Route.
 */
class RoutingContextService {
    constructor(activatedRoutesService, injector) {
        this.activatedRoutesService = activatedRoutesService;
        this.injector = injector;
        /**
         * Combined context token mapping consisting of all mappings defined in currently
         * Activated Angular Routes.
         *
         * The context token mapping is read from each Route's property `data.cxContext`.
         */
        this.contextTokenMapping$ = this.activatedRoutesService.routes$.pipe(map((routes) => this.getRoutesContextTokenMapping(routes)), shareReplay({ refCount: true, bufferSize: 1 }));
    }
    /**
     * Returns the merged context token mapping, consisting of mappings
     * defined in all Activated Angular Routes.
     */
    getRoutesContextTokenMapping(routes) {
        return Object.assign({}, ...routes.map((route) => { var _a; return (_a = route === null || route === void 0 ? void 0 : route.data) === null || _a === void 0 ? void 0 : _a.cxContext; }));
    }
    /**
     * Resolves the specified `contextToken` from `cxContext` data parameter of the activated Angular Routes.
     * @param contextToken
     *
     * @returns instance from the root injector if defined, otherwise `undefined`.
     */
    get(contextToken) {
        return this.contextTokenMapping$.pipe(map((contextMapping) => {
            const providerToken = contextMapping === null || contextMapping === void 0 ? void 0 : contextMapping[
            // TODO: remove 'as any' after upgrading TypeScript to v4.4
            // See: https://github.com/Microsoft/TypeScript/issues/24587
            contextToken];
            return this.injector.get(providerToken, undefined);
        }));
    }
}
RoutingContextService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: RoutingContextService, deps: [{ token: i1.ActivatedRoutesService }, { token: i0.Injector }], target: i0.ɵɵFactoryTarget.Injectable });
RoutingContextService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: RoutingContextService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: RoutingContextService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: function () { return [{ type: i1.ActivatedRoutesService }, { type: i0.Injector }]; } });

/**
 * Generic service for resolving the context for the UI components.
 */
class ContextService {
    constructor(routingContextService) {
        this.routingContextService = routingContextService;
    }
    /**
     * Returns the context for the given token.
     */
    get(contextToken) {
        return this.resolveContext(contextToken).pipe(distinctUntilChanged(), shareReplay({ refCount: true, bufferSize: 1 }));
    }
    /**
     * Resolves the context for the given token.
     */
    resolveContext(contextToken) {
        return this.routingContextService.get(contextToken);
    }
}
ContextService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ContextService, deps: [{ token: RoutingContextService }], target: i0.ɵɵFactoryTarget.Injectable });
ContextService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ContextService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ContextService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: function () { return [{ type: RoutingContextService }]; } });

/**
 * Indicates that a user navigated to an arbitrary page.
 */
class NavigationEvent extends CxEvent {
}
/**
 * Event's type
 */
NavigationEvent.type = 'NavigationEvent';

/**
 * Indicates that a user visited an arbitrary page.
 */
class PageEvent extends CxEvent {
}

/**
 * Indicates that a user visited a cart page.
 */
class CartPageEvent extends PageEvent {
}
/** event's type */
CartPageEvent.type = 'CartPageEvent';

class CartPageEventBuilder {
    constructor(eventService) {
        this.eventService = eventService;
        this.register();
    }
    register() {
        this.eventService.register(CartPageEvent, this.buildCartPageEvent());
    }
    buildCartPageEvent() {
        return this.eventService.get(NavigationEvent).pipe(filter((navigationEvent) => navigationEvent.semanticRoute === 'cart'), map((navigationEvent) => createFrom(CartPageEvent, {
            navigation: navigationEvent,
        })));
    }
}
CartPageEventBuilder.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CartPageEventBuilder, deps: [{ token: i1.EventService }], target: i0.ɵɵFactoryTarget.Injectable });
CartPageEventBuilder.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CartPageEventBuilder, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CartPageEventBuilder, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.EventService }]; } });

class CartPageEventModule {
    constructor(_cartPageEventBuilder) { }
}
CartPageEventModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CartPageEventModule, deps: [{ token: CartPageEventBuilder }], target: i0.ɵɵFactoryTarget.NgModule });
CartPageEventModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CartPageEventModule });
CartPageEventModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CartPageEventModule });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CartPageEventModule, decorators: [{
            type: NgModule,
            args: [{}]
        }], ctorParameters: function () { return [{ type: CartPageEventBuilder }]; } });

/**
 * Indicates that a user visited a home page.
 */
class HomePageEvent extends PageEvent {
}
/** event's type */
HomePageEvent.type = 'HomePageEvent';

class HomePageEventBuilder {
    constructor(eventService) {
        this.eventService = eventService;
        this.register();
    }
    register() {
        this.eventService.register(HomePageEvent, this.buildHomePageEvent());
    }
    buildHomePageEvent() {
        return this.eventService.get(NavigationEvent).pipe(filter((navigationEvent) => navigationEvent.semanticRoute === 'home'), map((navigationEvent) => createFrom(HomePageEvent, {
            navigation: navigationEvent,
        })));
    }
}
HomePageEventBuilder.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: HomePageEventBuilder, deps: [{ token: i1.EventService }], target: i0.ɵɵFactoryTarget.Injectable });
HomePageEventBuilder.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: HomePageEventBuilder, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: HomePageEventBuilder, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.EventService }]; } });

class HomePageEventModule {
    constructor(_homePageEventBuilder) { }
}
HomePageEventModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: HomePageEventModule, deps: [{ token: HomePageEventBuilder }], target: i0.ɵɵFactoryTarget.NgModule });
HomePageEventModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: HomePageEventModule });
HomePageEventModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: HomePageEventModule });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: HomePageEventModule, decorators: [{
            type: NgModule,
            args: [{}]
        }], ctorParameters: function () { return [{ type: HomePageEventBuilder }]; } });

/**
 * A builder for the NavigationEvent
 */
class NavigationEventBuilder {
    constructor(actions, eventService) {
        this.actions = actions;
        this.eventService = eventService;
        this.register();
    }
    /**
     * Registers events
     */
    register() {
        this.eventService.register(NavigationEvent, this.buildNavigationEvent());
    }
    /**
     * Builds the navigation events
     */
    buildNavigationEvent() {
        return this.getNavigatedEvent().pipe(map((state) => createFrom(NavigationEvent, {
            context: state.context,
            semanticRoute: state.semanticRoute,
            url: state.url,
            params: state.params,
        })));
    }
    getNavigatedEvent() {
        return this.actions.pipe(ofType(ROUTER_NAVIGATED), map((event) => event.payload.routerState));
    }
}
NavigationEventBuilder.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: NavigationEventBuilder, deps: [{ token: i1$5.ActionsSubject }, { token: i1.EventService }], target: i0.ɵɵFactoryTarget.Injectable });
NavigationEventBuilder.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: NavigationEventBuilder, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: NavigationEventBuilder, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1$5.ActionsSubject }, { type: i1.EventService }]; } });

class NavigationEventModule {
    constructor(_navigationEventBuilder) { }
}
NavigationEventModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: NavigationEventModule, deps: [{ token: NavigationEventBuilder }], target: i0.ɵɵFactoryTarget.NgModule });
NavigationEventModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: NavigationEventModule });
NavigationEventModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: NavigationEventModule });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: NavigationEventModule, decorators: [{
            type: NgModule,
            args: [{}]
        }], ctorParameters: function () { return [{ type: NavigationEventBuilder }]; } });

/**
 * Indicates that a user visited a product details page.
 */
class ProductDetailsPageEvent extends PageEvent {
}
/** event's type */
ProductDetailsPageEvent.type = 'ProductDetailsPageEvent';
/**
 * Indicates that a user visited a category page.
 */
class CategoryPageResultsEvent extends PageEvent {
}
/** event's type */
CategoryPageResultsEvent.type = 'CategoryPageResultsEvent';
/**
 * Indicates that the a user visited the search results page,
 * and that the search results have been retrieved.
 */
class SearchPageResultsEvent extends PageEvent {
}
/** event's type */
SearchPageResultsEvent.type = 'SearchPageResultsEvent';

class ProductPageEventBuilder {
    constructor(eventService, productService, productSearchService) {
        this.eventService = eventService;
        this.productService = productService;
        this.productSearchService = productSearchService;
        this.register();
    }
    register() {
        this.eventService.register(SearchPageResultsEvent, this.buildSearchPageResultsEvent());
        this.eventService.register(ProductDetailsPageEvent, this.buildProductDetailsPageEvent());
        this.eventService.register(CategoryPageResultsEvent, this.buildCategoryResultsPageEvent());
    }
    buildProductDetailsPageEvent() {
        return this.eventService.get(NavigationEvent).pipe(filter((navigationEvent) => navigationEvent.semanticRoute === 'product'), switchMap((navigationEvent) => this.productService.get(navigationEvent.context.id).pipe(filter((product) => Boolean(product)), take(1), map((product) => createFrom(ProductDetailsPageEvent, {
            navigation: navigationEvent,
            categories: product.categories,
            code: product.code,
            name: product.name,
            price: product.price,
        })))));
    }
    buildCategoryResultsPageEvent() {
        const searchResults$ = this.productSearchService.getResults().pipe(
        // skipping the initial value, and preventing emission of the previous search state
        skip(1));
        return this.eventService.get(NavigationEvent).pipe(switchMap((navigationEvent) => {
            if ((navigationEvent === null || navigationEvent === void 0 ? void 0 : navigationEvent.semanticRoute) !== 'category') {
                return EMPTY;
            }
            return searchResults$.pipe(map((searchResults) => {
                var _a, _b, _c, _d;
                return createFrom(CategoryPageResultsEvent, Object.assign({ navigation: navigationEvent }, {
                    categoryCode: (_a = navigationEvent === null || navigationEvent === void 0 ? void 0 : navigationEvent.context) === null || _a === void 0 ? void 0 : _a.id,
                    numberOfResults: (_c = (_b = searchResults === null || searchResults === void 0 ? void 0 : searchResults.pagination) === null || _b === void 0 ? void 0 : _b.totalResults) !== null && _c !== void 0 ? _c : 0,
                    categoryName: (_d = searchResults.breadcrumbs) === null || _d === void 0 ? void 0 : _d[0].facetValueName,
                }));
            }));
        }));
    }
    buildSearchPageResultsEvent() {
        const searchResults$ = this.productSearchService.getResults().pipe(
        // skipping the initial value, and preventing emission of the previous search state
        skip(1));
        return this.eventService.get(NavigationEvent).pipe(switchMap((navigationEvent) => {
            if ((navigationEvent === null || navigationEvent === void 0 ? void 0 : navigationEvent.semanticRoute) !== 'search') {
                return EMPTY;
            }
            return searchResults$.pipe(map((searchResults) => {
                var _a, _b, _c;
                return createFrom(SearchPageResultsEvent, Object.assign({ navigation: navigationEvent }, {
                    searchTerm: (_a = searchResults === null || searchResults === void 0 ? void 0 : searchResults.freeTextSearch) !== null && _a !== void 0 ? _a : '',
                    numberOfResults: (_c = (_b = searchResults === null || searchResults === void 0 ? void 0 : searchResults.pagination) === null || _b === void 0 ? void 0 : _b.totalResults) !== null && _c !== void 0 ? _c : 0,
                }));
            }));
        }));
    }
}
ProductPageEventBuilder.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductPageEventBuilder, deps: [{ token: i1.EventService }, { token: i1.ProductService }, { token: i1.ProductSearchService }], target: i0.ɵɵFactoryTarget.Injectable });
ProductPageEventBuilder.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductPageEventBuilder, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductPageEventBuilder, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.EventService }, { type: i1.ProductService }, { type: i1.ProductSearchService }]; } });

class ProductPageEventModule {
    constructor(_productPageEventBuilder) { }
}
ProductPageEventModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductPageEventModule, deps: [{ token: ProductPageEventBuilder }], target: i0.ɵɵFactoryTarget.NgModule });
ProductPageEventModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductPageEventModule });
ProductPageEventModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductPageEventModule });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductPageEventModule, decorators: [{
            type: NgModule,
            args: [{}]
        }], ctorParameters: function () { return [{ type: ProductPageEventBuilder }]; } });

class SkipLinkConfig {
}
SkipLinkConfig.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SkipLinkConfig, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
SkipLinkConfig.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SkipLinkConfig, providedIn: 'root', useExisting: Config });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SkipLinkConfig, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                    useExisting: Config,
                }]
        }] });
class SkipLink {
}
var SkipLinkScrollPosition;
(function (SkipLinkScrollPosition) {
    SkipLinkScrollPosition["BEFORE"] = "BEFORE";
    SkipLinkScrollPosition["AFTER"] = "AFTER";
})(SkipLinkScrollPosition || (SkipLinkScrollPosition = {}));

class SkipLinkService {
    constructor(config, keyboardFocusService) {
        this.config = config;
        this.keyboardFocusService = keyboardFocusService;
        this.skipLinks$ = new BehaviorSubject([]);
    }
    getSkipLinks() {
        return this.skipLinks$;
    }
    add(key, target) {
        const found = this.config.skipLinks.find((skipLink) => skipLink.key === key);
        if (found) {
            const existing = this.skipLinks$.value;
            existing.splice(this.getSkipLinkIndexInArray(key), 0, {
                target,
                i18nKey: found.i18nKey,
                position: found.position,
                key,
            });
            this.skipLinks$.next(existing);
        }
    }
    remove(key) {
        const found = this.config.skipLinks.find((skipLink) => skipLink.key === key);
        if (found) {
            let existing = this.skipLinks$.value;
            existing = existing.filter((skipLink) => skipLink.key !== key);
            this.skipLinks$.next(existing);
        }
    }
    scrollToTarget(skipLink) {
        const target = skipLink.target instanceof HTMLElement
            ? skipLink.target
            : skipLink.target.parentElement;
        // focus first focusable element in the
        const firstFocusable = this.keyboardFocusService.findFirstFocusable(target) || target;
        // we force a tabindex if not available, to ensure we can focus into the element
        const hasTabindex = firstFocusable.hasAttribute('tabindex');
        if (!hasTabindex) {
            firstFocusable.setAttribute('tabindex', '-1');
        }
        firstFocusable.focus();
        // drop the tmp tabindex
        if (!hasTabindex) {
            firstFocusable.removeAttribute('tabindex');
        }
    }
    getSkipLinkIndexInArray(key) {
        let index = this.config.skipLinks.findIndex((skipLink) => skipLink.key === key);
        while (index > 0) {
            index--;
            const previous = this.config.skipLinks[index];
            if (previous) {
                const existing = this.skipLinks$.value;
                const found = existing.findIndex((skipLink) => skipLink.key === previous.key);
                if (found > -1) {
                    return found + 1;
                }
            }
        }
        return 0;
    }
}
SkipLinkService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SkipLinkService, deps: [{ token: SkipLinkConfig }, { token: KeyboardFocusService }], target: i0.ɵɵFactoryTarget.Injectable });
SkipLinkService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SkipLinkService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SkipLinkService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: SkipLinkConfig }, { type: KeyboardFocusService }]; } });

class SkipLinkComponent {
    constructor(skipLinkService) {
        this.skipLinkService = skipLinkService;
        this.skipLinks$ = this.skipLinkService.getSkipLinks();
    }
    scrollToTarget(skipLink) {
        this.skipLinkService.scrollToTarget(skipLink);
    }
}
SkipLinkComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SkipLinkComponent, deps: [{ token: SkipLinkService }], target: i0.ɵɵFactoryTarget.Component });
SkipLinkComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: SkipLinkComponent, selector: "cx-skip-link", ngImport: i0, template: "<div [cxFocus]=\"{ tab: true }\" *ngIf=\"skipLinks$ | async as links\">\n  <button *ngFor=\"let link of links\" (click)=\"scrollToTarget(link)\">\n    {{ 'skipLink.skipTo' | cxTranslate }}\n    {{ link.i18nKey | cxTranslate }}\n  </button>\n</div>\n", directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: FocusDirective, selector: "[cxFocus]", inputs: ["cxFocus"] }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], pipes: { "async": i3.AsyncPipe, "cxTranslate": i1.TranslatePipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SkipLinkComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-skip-link',
                    templateUrl: './skip-link.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: SkipLinkService }]; } });

const defaultSkipLinkConfig = {
    skipLinks: [
        {
            key: 'cx-header',
            i18nKey: 'skipLink.labels.header',
        },
        {
            key: 'cx-main',
            i18nKey: 'skipLink.labels.main',
        },
        { key: 'cx-footer', i18nKey: 'skipLink.labels.footer' },
    ],
};

class SkipLinkDirective {
    constructor(elementRef, skipLinkService) {
        this.elementRef = elementRef;
        this.skipLinkService = skipLinkService;
    }
    ngOnInit() {
        this.skipLinkService.add(this.cxSkipLink, this.elementRef.nativeElement);
    }
    ngOnDestroy() {
        this.skipLinkService.remove(this.cxSkipLink);
    }
}
SkipLinkDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SkipLinkDirective, deps: [{ token: i0.ElementRef }, { token: SkipLinkService }], target: i0.ɵɵFactoryTarget.Directive });
SkipLinkDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.5", type: SkipLinkDirective, selector: "[cxSkipLink]", inputs: { cxSkipLink: "cxSkipLink" }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SkipLinkDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cxSkipLink]',
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: SkipLinkService }]; }, propDecorators: { cxSkipLink: [{
                type: Input
            }] } });

class SkipLinkModule {
}
SkipLinkModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SkipLinkModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
SkipLinkModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SkipLinkModule, declarations: [SkipLinkComponent, SkipLinkDirective], imports: [CommonModule,
        I18nModule, i1.ConfigModule, KeyboardFocusModule], exports: [SkipLinkDirective] });
SkipLinkModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SkipLinkModule, providers: [
        provideDefaultConfig(defaultSkipLinkConfig),
        {
            provide: APP_INITIALIZER,
            useFactory: skipLinkFactory,
            deps: [ComponentFactoryResolver, OutletService],
            multi: true,
        },
    ], imports: [[
            CommonModule,
            I18nModule,
            ConfigModule.withConfig(defaultSkipLinkConfig),
            KeyboardFocusModule,
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SkipLinkModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        I18nModule,
                        ConfigModule.withConfig(defaultSkipLinkConfig),
                        KeyboardFocusModule,
                    ],
                    declarations: [SkipLinkComponent, SkipLinkDirective],
                    exports: [SkipLinkDirective],
                    providers: [
                        provideDefaultConfig(defaultSkipLinkConfig),
                        {
                            provide: APP_INITIALIZER,
                            useFactory: skipLinkFactory,
                            deps: [ComponentFactoryResolver, OutletService],
                            multi: true,
                        },
                    ],
                }]
        }] });
/**
 * Adds the skip link component before the cx-storefront.
 */
function skipLinkFactory(componentFactoryResolver, outletService) {
    const isReady = () => {
        const factory = componentFactoryResolver.resolveComponentFactory(SkipLinkComponent);
        outletService.add('cx-storefront', factory, OutletPosition.BEFORE);
    };
    return isReady;
}

const defaultLayoutConfig = {
    breakpoints: {
        xs: 576,
        sm: 768,
        md: 992,
        lg: 1200,
        xl: {
            min: 1200,
        },
    },
};

/**
 * The direction config provides an easy way to configure "ltr" versus "rtl" direction
 * for the storefront. The direction can be configured to detect the direction by language.
 *
 * The following configuration detects rtl languages by isoCode for Arabic and Hebrew:
 *
 * ```typescript
 * direction: {
 *   detect: true,
 *   default: DirectionMode.LTR,
 *   rtlLanguages: ['ar', 'he']
 * }
 * ```
 */
class DirectionConfig {
}
DirectionConfig.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: DirectionConfig, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
DirectionConfig.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: DirectionConfig, providedIn: 'root', useExisting: Config });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: DirectionConfig, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                    useExisting: Config,
                }]
        }] });

const defaultDirectionConfig = {
    direction: {
        detect: true,
        default: DirectionMode.LTR,
        // we're not polluting the system with all defaults for ltr, but add 2 common used
        // languages (hebrew and arabic) to easily demo directionality
        // see https://meta.wikimedia.org/wiki/Template:List_of_language_names_ordered_by_code
        rtlLanguages: ['he', 'ar'],
    },
};

/**
 * The `DirectionService` can be used to add the direction to the overall storefront or individual elements.
 * By default, the direction is added to the `html` element (i.e. `<html dir="ltr">`). The API of this service
 * does however provide methods to add direction to individual elements if needed.
 *
 * The direction is configurable and allows for language driven direction configuration.
 *
 * To react to the active language, the service subscribes to the active language in the initialize method. This
 * is called from an APP_INITIALIZER method and should only happen once.
 */
class DirectionService {
    constructor(configInit, languageService, winRef) {
        this.configInit = configInit;
        this.languageService = languageService;
        this.winRef = winRef;
        this.startsDetecting = false;
        this.subscription = new Subscription();
    }
    /**
     * Initializes the layout direction for the storefront.
     */
    initialize() {
        return this.configInit
            .getStable('direction')
            .pipe(tap((config) => {
            var _a, _b;
            this.config = config === null || config === void 0 ? void 0 : config.direction;
            if ((_a = this.config) === null || _a === void 0 ? void 0 : _a.detect) {
                this.detect();
            }
            else {
                this.setDirection(this.winRef.document.documentElement, (_b = this.config) === null || _b === void 0 ? void 0 : _b.default);
            }
        }))
            .toPromise();
    }
    /**
     * Observes the _active_ language and set the required direction for the given language.
     * The method is guarded to ensure that the active language is observed only once.
     */
    detect() {
        if (this.startsDetecting) {
            return;
        }
        this.subscription.add(this.languageService
            .getActive()
            .subscribe((isoCode) => this.setDirection(this.winRef.document.documentElement, this.getDirection(isoCode))));
        this.startsDetecting = true;
    }
    /**
     * Sets the direction attribute for the given element. If the direction is undefined, the `dir`
     * attribute is removed.
     */
    setDirection(el, direction) {
        if (direction) {
            el.setAttribute('dir', direction);
        }
        else {
            el.removeAttribute('dir');
        }
    }
    /**
     * Gets the `DirectionMode` for the given language isoCode. The language isoCode is compared
     * to the configured list of languages(`direction.rtlLanguages` vs `direction.ltrLanguages`).
     *
     * If no language is given, or no language mapping could be found, we fallback to the default
     * `direction.mode`.
     */
    getDirection(language) {
        var _a, _b, _c, _d, _e;
        if (language && ((_b = (_a = this.config) === null || _a === void 0 ? void 0 : _a.rtlLanguages) === null || _b === void 0 ? void 0 : _b.includes(language))) {
            return DirectionMode.RTL;
        }
        if (language && ((_d = (_c = this.config) === null || _c === void 0 ? void 0 : _c.ltrLanguages) === null || _d === void 0 ? void 0 : _d.includes(language))) {
            return DirectionMode.LTR;
        }
        return (_e = this.config) === null || _e === void 0 ? void 0 : _e.default;
    }
    ngOnDestroy() {
        // Cleans up the subscription, to avoid memory leaks in SSR.
        this.subscription.unsubscribe();
    }
}
DirectionService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: DirectionService, deps: [{ token: i1.ConfigInitializerService }, { token: i1.LanguageService }, { token: i1.WindowRef }], target: i0.ɵɵFactoryTarget.Injectable });
DirectionService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: DirectionService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: DirectionService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.ConfigInitializerService }, { type: i1.LanguageService }, { type: i1.WindowRef }]; } });

function initHtmlDirAttribute(directionService, featureConfigService) {
    const result = () => {
        if (featureConfigService.isLevel('2.1')) {
            return directionService.initialize();
        }
    };
    return result;
}
/**
 * Provides a configuration and APP_INITIALIZER to add the correct (language drive) html direction.
 */
class DirectionModule {
}
DirectionModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: DirectionModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
DirectionModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: DirectionModule });
DirectionModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: DirectionModule, providers: [
        {
            provide: APP_INITIALIZER,
            multi: true,
            useFactory: initHtmlDirAttribute,
            deps: [DirectionService, FeatureConfigService],
        },
        provideDefaultConfig(defaultDirectionConfig),
    ] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: DirectionModule, decorators: [{
            type: NgModule,
            args: [{
                    providers: [
                        {
                            provide: APP_INITIALIZER,
                            multi: true,
                            useFactory: initHtmlDirAttribute,
                            deps: [DirectionService, FeatureConfigService],
                        },
                        provideDefaultConfig(defaultDirectionConfig),
                    ],
                }]
        }] });

class HamburgerMenuComponent {
    constructor(hamburgerMenuService) {
        this.hamburgerMenuService = hamburgerMenuService;
    }
    toggle() {
        this.hamburgerMenuService.toggle();
    }
    get isExpanded() {
        return this.hamburgerMenuService.isExpanded;
    }
}
HamburgerMenuComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: HamburgerMenuComponent, deps: [{ token: HamburgerMenuService }], target: i0.ɵɵFactoryTarget.Component });
HamburgerMenuComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: HamburgerMenuComponent, selector: "cx-hamburger-menu", ngImport: i0, template: "<button\n  class=\"cx-hamburger\"\n  type=\"button\"\n  (click)=\"toggle()\"\n  [class.is-active]=\"isExpanded | async\"\n  [attr.aria-expanded]=\"isExpanded | async\"\n  [attr.aria-label]=\"'common.menu' | cxTranslate\"\n  aria-controls=\"header-account-container, header-categories-container, header-locale-container\"\n>\n  <span class=\"hamburger-box\">\n    <span class=\"hamburger-inner\"></span>\n  </span>\n</button>\n", pipes: { "async": i3.AsyncPipe, "cxTranslate": i1.TranslatePipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: HamburgerMenuComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-hamburger-menu',
                    templateUrl: './hamburger-menu.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: HamburgerMenuService }]; } });

class HamburgerMenuModule {
}
HamburgerMenuModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: HamburgerMenuModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
HamburgerMenuModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: HamburgerMenuModule, declarations: [HamburgerMenuComponent], imports: [CommonModule, I18nModule], exports: [HamburgerMenuComponent] });
HamburgerMenuModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: HamburgerMenuModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                HamburgerMenuComponent: {
                    component: HamburgerMenuComponent,
                },
            },
        }),
    ], imports: [[CommonModule, I18nModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: HamburgerMenuModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, I18nModule],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                HamburgerMenuComponent: {
                                    component: HamburgerMenuComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [HamburgerMenuComponent],
                    exports: [HamburgerMenuComponent],
                }]
        }] });

class ThemeService {
    constructor(config, rendererFactory) {
        this.config = config;
        this.rendererFactory = rendererFactory;
    }
    /**
     * This function is to be called for the root component that is
     * bootstrapped.
     */
    init(rootComponent) {
        var _a;
        this.renderer = this.rendererFactory.createRenderer(null, null);
        this.rootComponent = rootComponent;
        // Theme value is a string. It is put in the generic multi-value
        // property of the SiteContextConfig. So the array's first item
        // is the theme value.
        this.setTheme((_a = this.config.context[THEME_CONTEXT_ID]) === null || _a === void 0 ? void 0 : _a[0]);
    }
    setTheme(theme) {
        if (theme) {
            const element = this.rootComponent.location.nativeElement;
            // remove the old theme
            this.renderer.removeClass(element, this.existingTheme);
            // add the new theme
            this.renderer.addClass(element, theme);
            this.existingTheme = theme;
        }
    }
}
ThemeService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ThemeService, deps: [{ token: i1.SiteContextConfig }, { token: i0.RendererFactory2 }], target: i0.ɵɵFactoryTarget.Injectable });
ThemeService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ThemeService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ThemeService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: function () { return [{ type: i1.SiteContextConfig }, { type: i0.RendererFactory2 }]; } });

function initTheme(themeService) {
    const result = (component) => themeService.init(component);
    return result;
}
class ThemeModule {
}
ThemeModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ThemeModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ThemeModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ThemeModule });
ThemeModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ThemeModule, providers: [
        {
            provide: APP_BOOTSTRAP_LISTENER,
            multi: true,
            useFactory: initTheme,
            deps: [ThemeService],
        },
    ] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ThemeModule, decorators: [{
            type: NgModule,
            args: [{
                    providers: [
                        {
                            provide: APP_BOOTSTRAP_LISTENER,
                            multi: true,
                            useFactory: initTheme,
                            deps: [ThemeService],
                        },
                    ],
                }]
        }] });

class LayoutModule {
}
LayoutModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: LayoutModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
LayoutModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: LayoutModule, imports: [OutletRefModule, LaunchDialogModule, DirectionModule,
        ThemeModule], exports: [OutletRefModule] });
LayoutModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: LayoutModule, providers: [provideConfig(defaultLayoutConfig)], imports: [[
            OutletRefModule,
            LaunchDialogModule.forRoot(),
            DirectionModule,
            ThemeModule,
        ], OutletRefModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: LayoutModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        OutletRefModule,
                        LaunchDialogModule.forRoot(),
                        DirectionModule,
                        ThemeModule,
                    ],
                    providers: [provideConfig(defaultLayoutConfig)],
                    exports: [OutletRefModule],
                }]
        }] });

var StorefrontOutlets;
(function (StorefrontOutlets) {
    StorefrontOutlets["STOREFRONT"] = "cx-storefront";
})(StorefrontOutlets || (StorefrontOutlets = {}));

class StorefrontComponent {
    constructor(hamburgerMenuService, routingService, elementRef, keyboardFocusService) {
        this.hamburgerMenuService = hamburgerMenuService;
        this.routingService = routingService;
        this.elementRef = elementRef;
        this.keyboardFocusService = keyboardFocusService;
        this.isExpanded$ = this.hamburgerMenuService.isExpanded;
        this.StorefrontOutlets = StorefrontOutlets;
        // required by esc focus
        this.tabindex = '0';
        this.keyboardFocusConfig = {
            focusOnEscape: true,
            focusOnDoubleEscape: true,
        };
    }
    handleEscape(event) {
        this.keyboardFocusService.handleEscape(this.elementRef.nativeElement, this.keyboardFocusConfig, event);
    }
    ngOnInit() {
        this.navigateSubscription = this.routingService
            .isNavigating()
            .subscribe((val) => {
            this.startNavigating = val === true;
            this.stopNavigating = val === false;
        });
    }
    collapseMenuIfClickOutside(event) {
        const element = event.target;
        if (element.nodeName.toLowerCase() === 'header' &&
            element.className.includes('is-expanded')) {
            this.collapseMenu();
        }
    }
    collapseMenu() {
        this.hamburgerMenuService.toggle(true);
    }
    ngOnDestroy() {
        if (this.navigateSubscription) {
            this.navigateSubscription.unsubscribe();
        }
    }
}
StorefrontComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: StorefrontComponent, deps: [{ token: HamburgerMenuService }, { token: i1.RoutingService }, { token: i0.ElementRef }, { token: KeyboardFocusService }], target: i0.ɵɵFactoryTarget.Component });
StorefrontComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: StorefrontComponent, selector: "cx-storefront", host: { listeners: { "keydown.escape": "handleEscape($event)" }, properties: { "class.start-navigating": "this.startNavigating", "class.stop-navigating": "this.stopNavigating", "tabindex": "this.tabindex" } }, viewQueries: [{ propertyName: "child", first: true, predicate: SkipLinkComponent, descendants: true }], ngImport: i0, template: "<ng-template [cxOutlet]=\"StorefrontOutlets.STOREFRONT\" cxPageTemplateStyle>\n  <ng-template cxOutlet=\"cx-header\">\n    <header\n      cxSkipLink=\"cx-header\"\n      [cxFocus]=\"{ disableMouseFocus: true }\"\n      [class.is-expanded]=\"isExpanded$ | async\"\n      (keydown.escape)=\"collapseMenu()\"\n      (click)=\"collapseMenuIfClickOutside($event)\"\n    >\n      <cx-page-layout section=\"header\"></cx-page-layout>\n      <cx-page-layout section=\"navigation\"></cx-page-layout>\n    </header>\n    <cx-page-slot position=\"BottomHeaderSlot\"></cx-page-slot>\n    <cx-global-message\n      aria-atomic=\"true\"\n      aria-live=\"assertive\"\n    ></cx-global-message>\n  </ng-template>\n\n  <main cxSkipLink=\"cx-main\" [cxFocus]=\"{ disableMouseFocus: true }\">\n    <router-outlet></router-outlet>\n  </main>\n\n  <ng-template cxOutlet=\"cx-footer\">\n    <footer cxSkipLink=\"cx-footer\" [cxFocus]=\"{ disableMouseFocus: true }\">\n      <cx-page-layout section=\"footer\"></cx-page-layout>\n    </footer>\n  </ng-template>\n</ng-template>\n", components: [{ type: PageLayoutComponent, selector: "cx-page-layout", inputs: ["section"] }, { type: PageSlotComponent, selector: "cx-page-slot,[cx-page-slot]", inputs: ["position", "class", "isPageFold", "hasComponents"] }, { type: GlobalMessageComponent, selector: "cx-global-message" }], directives: [{ type: PageTemplateDirective, selector: "[cxPageTemplateStyle]", inputs: ["cxPageTemplateStyle"] }, { type: OutletDirective, selector: "[cxOutlet]", inputs: ["cxOutlet", "cxOutletContext", "cxOutletDefer"], outputs: ["loaded"] }, { type: SkipLinkDirective, selector: "[cxSkipLink]", inputs: ["cxSkipLink"] }, { type: FocusDirective, selector: "[cxFocus]", inputs: ["cxFocus"] }, { type: i1$1.RouterOutlet, selector: "router-outlet", outputs: ["activate", "deactivate"], exportAs: ["outlet"] }], pipes: { "async": i3.AsyncPipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: StorefrontComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-storefront',
                    templateUrl: './storefront.component.html',
                }]
        }], ctorParameters: function () { return [{ type: HamburgerMenuService }, { type: i1.RoutingService }, { type: i0.ElementRef }, { type: KeyboardFocusService }]; }, propDecorators: { startNavigating: [{
                type: HostBinding,
                args: ['class.start-navigating']
            }], stopNavigating: [{
                type: HostBinding,
                args: ['class.stop-navigating']
            }], tabindex: [{
                type: HostBinding,
                args: ['tabindex']
            }], child: [{
                type: ViewChild,
                args: [SkipLinkComponent]
            }], handleEscape: [{
                type: HostListener,
                args: ['keydown.escape', ['$event']]
            }] } });

class StorefrontComponentModule {
}
StorefrontComponentModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: StorefrontComponentModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
StorefrontComponentModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: StorefrontComponentModule, declarations: [StorefrontComponent], imports: [CommonModule,
        RouterModule,
        GlobalMessageComponentModule,
        OutletModule,
        OutletRefModule,
        PageLayoutModule,
        PageSlotModule,
        KeyboardFocusModule,
        SkipLinkModule], exports: [StorefrontComponent] });
StorefrontComponentModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: StorefrontComponentModule, imports: [[
            CommonModule,
            RouterModule,
            GlobalMessageComponentModule,
            OutletModule,
            OutletRefModule,
            PageLayoutModule,
            PageSlotModule,
            KeyboardFocusModule,
            SkipLinkModule,
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: StorefrontComponentModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        RouterModule,
                        GlobalMessageComponentModule,
                        OutletModule,
                        OutletRefModule,
                        PageLayoutModule,
                        PageSlotModule,
                        KeyboardFocusModule,
                        SkipLinkModule,
                    ],
                    declarations: [StorefrontComponent],
                    exports: [StorefrontComponent],
                }]
        }] });

const mediaConfig = {
    mediaFormats: {
        mobile: { width: 400 },
        tablet: { width: 770 },
        desktop: { width: 1140 },
        widescreen: { width: 1400 },
        // product media
        cartIcon: { width: 65 },
        thumbnail: { width: 96 },
        product: { width: 284 },
        zoom: { width: 515 },
    },
};

/**
 * The layout configuration is used to define the overall layout of the storefront.
 * The configuration includes the following aspects:
 * - breakpoint layout (AKA screen layout)
 * - Page sections slot configuration (i.e. header vs footer)
 * - page template slot configuration (i.e. landing page template vs PDP page template)
 * - deferred loading configuration
 *
 * The page slot configurations is directly related to the data in the backend. If you use the
 * Spartacus sample-data, you will have an aligned setup. However, if you introduce custom page
 * templates and/or slots, you most likely need to further adjust or replace this configuration.
 */
const layoutConfig = {
    // deferredLoading: {
    //   strategy: DeferLoadingStrategy.DEFER,
    //   intersectionMargin: '50px',
    // },
    layoutSlots: {
        header: {
            lg: {
                slots: [
                    'PreHeader',
                    'SiteContext',
                    'SiteLinks',
                    'SiteLogo',
                    'SearchBox',
                    'SiteLogin',
                    'MiniCart',
                    'NavigationBar',
                ],
            },
            slots: ['PreHeader', 'SiteLogo', 'SearchBox', 'MiniCart'],
        },
        navigation: {
            lg: { slots: [] },
            slots: ['SiteLogin', 'NavigationBar', 'SiteContext', 'SiteLinks'],
        },
        footer: {
            slots: ['Footer'],
        },
        LandingPage2Template: {
            pageFold: 'Section2B',
            slots: [
                'Section1',
                'Section2A',
                'Section2B',
                'Section2C',
                'Section3',
                'Section4',
                'Section5',
            ],
        },
        ContentPage1Template: {
            slots: ['Section2A', 'Section2B'],
        },
        CategoryPageTemplate: {
            pageFold: 'Section2',
            slots: ['Section1', 'Section2', 'Section3'],
        },
        ProductListPageTemplate: {
            slots: ['ProductLeftRefinements', 'ProductListSlot'],
        },
        ProductGridPageTemplate: {
            slots: ['ProductLeftRefinements', 'ProductGridSlot'],
        },
        SearchResultsListPageTemplate: {
            slots: [
                'Section2',
                'ProductLeftRefinements',
                'SearchResultsListSlot',
                'Section4',
            ],
        },
        SearchResultsGridPageTemplate: {
            slots: [
                'Section2',
                'ProductLeftRefinements',
                'SearchResultsGridSlot',
                'Section4',
            ],
        },
        ProductDetailsPageTemplate: {
            lg: {
                pageFold: 'UpSelling',
            },
            pageFold: 'Summary',
            slots: [
                'Summary',
                'UpSelling',
                'CrossSelling',
                'Tabs',
                'PlaceholderContentSlot',
            ],
        },
        CartPageTemplate: {
            slots: ['TopContent', 'CenterRightContentSlot', 'EmptyCartMiddleContent'],
        },
        AccountPageTemplate: {
            slots: ['BodyContent', 'SideContent'],
        },
        LoginPageTemplate: {
            slots: ['LeftContentSlot', 'RightContentSlot'],
        },
        ErrorPageTemplate: {
            slots: ['TopContent', 'MiddleContent', 'BottomContent'],
        },
        OrderConfirmationPageTemplate: {
            slots: ['BodyContent', 'SideContent'],
        },
        MultiStepCheckoutSummaryPageTemplate: {
            slots: ['TopContent', 'BodyContent', 'SideContent', 'BottomContent'],
        },
        CheckoutLoginPageTemplate: {
            slots: ['RightContentSlot'],
        },
    },
};

const defaultCmsContentProviders = [
    provideCmsStructure({
        componentId: 'HamburgerMenuComponent',
        pageSlotPosition: 'PreHeader',
    }),
    provideCmsStructure({
        componentId: 'LoginComponent',
        pageSlotPosition: 'SiteLogin',
    }),
];

const defaultOnNavigateConfig = {
    enableResetViewOnNavigate: {
        active: true,
        ignoreQueryString: false,
        ignoreRoutes: [],
    },
};

class OnNavigateConfig {
}
OnNavigateConfig.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OnNavigateConfig, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
OnNavigateConfig.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OnNavigateConfig, providedIn: 'root', useExisting: Config });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OnNavigateConfig, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                    useExisting: Config,
                }]
        }] });

class OnNavigateService {
    constructor(config, router, viewportScroller, injector) {
        this.config = config;
        this.router = router;
        this.viewportScroller = viewportScroller;
        this.injector = injector;
    }
    get hostComponent() {
        var _a, _b;
        return (_b = (_a = this.injector.get(ApplicationRef)) === null || _a === void 0 ? void 0 : _a.components) === null || _b === void 0 ? void 0 : _b[0];
    }
    /**
     * Reads configuration and enables features based on flags set.
     */
    initializeWithConfig() {
        var _a, _b;
        if ((_b = (_a = this.config) === null || _a === void 0 ? void 0 : _a.enableResetViewOnNavigate) === null || _b === void 0 ? void 0 : _b.active) {
            this.setResetViewOnNavigate(this.config.enableResetViewOnNavigate.active);
        }
    }
    /**
     * Resets view back to the original position when performing a back navigation and to the top when performing a front navigation
     * and sets the focus back to the top of the page before skiplinks for any type of navigation
     * @param enable Enable or disable this feature
     */
    setResetViewOnNavigate(enable) {
        var _a;
        (_a = this.subscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();
        if (enable) {
            this.subscription = this.router.events
                .pipe(filter((event) => event instanceof Scroll), pairwise())
                .subscribe((event) => {
                var _a, _b, _c;
                const previousRoute = event[0];
                const currentRoute = event[1];
                if (currentRoute.position) {
                    // allow the pages to be repainted before scrolling to proper position
                    setTimeout(() => this.viewportScroller.scrollToPosition(currentRoute.position));
                }
                else {
                    if (((_a = this.config.enableResetViewOnNavigate) === null || _a === void 0 ? void 0 : _a.ignoreQueryString) &&
                        this.isPathEqual(previousRoute, currentRoute)) {
                        return;
                    }
                    if (this.isChildRoute(currentRoute)) {
                        return;
                    }
                    setTimeout(() => this.viewportScroller.scrollToPosition([0, 0]), 100);
                }
                (_c = (_b = this.hostComponent) === null || _b === void 0 ? void 0 : _b.location) === null || _c === void 0 ? void 0 : _c.nativeElement.focus();
            });
        }
    }
    /**
     * Verifies if the current route is a child route from the given ignore config route
     *
     * @param route
     * @returns boolean whether the route is a child route
     */
    isChildRoute(route) {
        var _a, _b, _c;
        return ((_c = (_b = (_a = this.config.enableResetViewOnNavigate) === null || _a === void 0 ? void 0 : _a.ignoreRoutes) === null || _b === void 0 ? void 0 : _b.some((configRoute) => route.routerEvent.urlAfterRedirects.split('/').includes(configRoute))) !== null && _c !== void 0 ? _c : false);
    }
    /**
     * Verifies if the previous and current route are the same without the query string
     *
     * @param previousRoute
     * @param currentRoute
     * @returns boolean depending on the previous and current route are equal without the query strings
     */
    isPathEqual(previousRoute, currentRoute) {
        return (previousRoute.routerEvent.urlAfterRedirects.split('?')[0] ===
            currentRoute.routerEvent.urlAfterRedirects.split('?')[0]);
    }
}
OnNavigateService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OnNavigateService, deps: [{ token: OnNavigateConfig }, { token: i1$1.Router }, { token: i3.ViewportScroller }, { token: i0.Injector }], target: i0.ɵɵFactoryTarget.Injectable });
OnNavigateService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OnNavigateService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OnNavigateService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: OnNavigateConfig }, { type: i1$1.Router }, { type: i3.ViewportScroller }, { type: i0.Injector }]; } });

class AppRoutingModule {
}
AppRoutingModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AppRoutingModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
AppRoutingModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AppRoutingModule, imports: [i1$1.RouterModule] });
AppRoutingModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AppRoutingModule, providers: [
        provideDefaultConfig(defaultOnNavigateConfig),
        {
            provide: APP_INITIALIZER,
            useFactory: onNavigateFactory,
            deps: [OnNavigateService],
            multi: true,
        },
    ], imports: [[
            RouterModule.forRoot([], {
                anchorScrolling: 'enabled',
                relativeLinkResolution: 'corrected',
                initialNavigation: 'enabled',
            }),
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AppRoutingModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        RouterModule.forRoot([], {
                            anchorScrolling: 'enabled',
                            relativeLinkResolution: 'corrected',
                            initialNavigation: 'enabled',
                        }),
                    ],
                    providers: [
                        provideDefaultConfig(defaultOnNavigateConfig),
                        {
                            provide: APP_INITIALIZER,
                            useFactory: onNavigateFactory,
                            deps: [OnNavigateService],
                            multi: true,
                        },
                    ],
                }]
        }] });
function onNavigateFactory(onNavigateService) {
    const isReady = () => onNavigateService.initializeWithConfig();
    return isReady;
}

/**
 * Utils for Angular forms
 */
var FormUtils;
(function (FormUtils) {
    /**
     * Calls the native Angular method `#updateValueAndValidity` for the given from control
     * and all its descendants (in case when it's `FormGroup` or `FormArray`).
     *
     * In particular it's useful for triggering re-emission of observables
     * `valueChanges` and `statusChanges` for all descendant form controls.
     *
     * _Note: Dropping this function may be considered, when it's implemented natively
     * by Angular. See https://github.com/angular/angular/issues/6170_
     *
     * @param control form control
     * @param options additional options
     * * `emitEvent`: When true or not given (the default), the `statusChanges` and
     * `valueChanges` observables emit the latest status and value. When false,
     * it doesn't trigger observables emission.
     */
    function deepUpdateValueAndValidity(control, options = {}) {
        if (control instanceof FormGroup || control instanceof FormArray) {
            Object.values(control.controls).forEach((childControl) => {
                deepUpdateValueAndValidity(childControl, options);
            });
        }
        control.updateValueAndValidity({
            onlySelf: true,
            emitEvent: options.emitEvent,
        });
    }
    FormUtils.deepUpdateValueAndValidity = deepUpdateValueAndValidity;
})(FormUtils || (FormUtils = {}));

class BaseStorefrontModule {
}
BaseStorefrontModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: BaseStorefrontModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
BaseStorefrontModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: BaseStorefrontModule, imports: [i1.BaseCoreModule, RouterModule,
        GlobalMessageComponentModule,
        OutletModule,
        OutletRefModule,
        PwaModule,
        PageLayoutModule,
        SeoModule, PageComponentModule, PageSlotModule,
        SkipLinkModule,
        KeyboardFocusModule,
        LayoutModule, RoutingModule, MediaModule, OutletModule, StorefrontComponentModule], exports: [LayoutModule, StorefrontComponentModule] });
BaseStorefrontModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: BaseStorefrontModule, imports: [[
            BaseCoreModule.forRoot(),
            RouterModule,
            GlobalMessageComponentModule,
            OutletModule,
            OutletRefModule,
            PwaModule,
            PageLayoutModule,
            SeoModule,
            PageComponentModule.forRoot(),
            PageSlotModule,
            SkipLinkModule,
            KeyboardFocusModule,
            LayoutModule,
            RoutingModule.forRoot(),
            MediaModule.forRoot(),
            OutletModule.forRoot(),
            StorefrontComponentModule,
        ], LayoutModule, StorefrontComponentModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: BaseStorefrontModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        BaseCoreModule.forRoot(),
                        RouterModule,
                        GlobalMessageComponentModule,
                        OutletModule,
                        OutletRefModule,
                        PwaModule,
                        PageLayoutModule,
                        SeoModule,
                        PageComponentModule.forRoot(),
                        PageSlotModule,
                        SkipLinkModule,
                        KeyboardFocusModule,
                        LayoutModule,
                        RoutingModule.forRoot(),
                        MediaModule.forRoot(),
                        OutletModule.forRoot(),
                        StorefrontComponentModule,
                    ],
                    exports: [LayoutModule, StorefrontComponentModule],
                }]
        }] });

/*
 * Public API Surface of storefrontlib
 */
/** AUGMENTABLE_TYPES_END */

/**
 * Generated bundle index. Do not edit.
 */

export { AVOID_STACKED_OUTLETS, ActiveCartOrderEntriesContext, ActiveFacetsComponent, ActiveFacetsModule, AddToCartComponent, AddToCartModule, AddToHomeScreenBannerComponent, AddToHomeScreenBtnComponent, AddToHomeScreenComponent, AddToHomeScreenService, AddToWishListComponent, AddToWishListModule, AddedToCartDialogComponent, AddressBookComponent, AddressBookComponentService, AddressBookModule, AddressFormComponent, AddressFormModule, AmendOrderActionsComponent, AmendOrderActionsModule, AmendOrderItemsModule, AmendOrderType, AnonymousConsentDialogComponent, AnonymousConsentManagementBannerComponent, AnonymousConsentManagementBannerModule, AnonymousConsentOpenDialogComponent, AnonymousConsentsDialogModule, AppRoutingModule, AppliedCouponsComponent, BREAKPOINT, BannerCarouselComponent, BannerCarouselModule, BannerComponent, BannerModule, BaseStorefrontModule, BreadcrumbComponent, BreadcrumbModule, BreadcrumbSchemaBuilder, BreakpointService, CancelOrReturnItemsComponent, CancelOrderComponent, CancelOrderConfirmationComponent, CancelOrderConfirmationModule, CancelOrderModule, CardComponent, CardModule, CarouselComponent, CarouselModule, CarouselService, CartComponentModule, CartCouponComponent, CartCouponModule, CartDetailsComponent, CartDetailsModule, CartItemComponent, CartItemContext, CartItemContextSource, CartItemListComponent, CartOrderEntriesContext, CartOutlets, CartPageEvent, CartPageEventBuilder, CartPageEventModule, CartPageLayoutHandler, CartSharedModule, CartTotalsComponent, CartTotalsModule, CartValidationComponentsModule, CartValidationGuard, CartValidationStateService, CartValidationWarningsComponent, CartValidationWarningsModule, CategoryNavigationComponent, CategoryNavigationModule, CategoryPageResultsEvent, CmsComponentData, CmsComponentsService, CmsFeaturesService, CmsGuardsService, CmsI18nService, CmsInjectorService, CmsPageGuard, CmsPageGuardService, CmsParagraphModule, CmsRouteModule, CmsRoutesService, ComponentCreateEvent, ComponentDestroyEvent, ComponentEvent, ComponentHandler, ComponentHandlerService, ComponentWrapperDirective, ConsentManagementComponent, ConsentManagementFormComponent, ConsentManagementModule, ConsignmentTrackingComponent, ContextService, CouponCardComponent, CouponClaimComponent, CouponDialogComponent, CurrentProductService, CustomFormValidators, DIALOG_TYPE, DatePickerComponent, DatePickerModule, DatePickerService, DefaultComponentHandler, DeferLoaderService, DirectionConfig, DirectionMode, DirectionModule, DirectionService, ExportCsvFileService, FacetComponent, FacetGroupCollapsedState, FacetListComponent, FacetListModule, FacetModule, FacetService, FileDownloadService, FileReaderService, FileUploadComponent, FileUploadModule, FilesFormValidators, FocusDirective, FooterNavigationComponent, FooterNavigationModule, FormErrorsComponent, FormErrorsModule, FormUtils, GenericLinkComponent, GenericLinkComponentService, GenericLinkModule, GlobalMessageComponent, GlobalMessageComponentModule, HamburgerMenuComponent, HamburgerMenuModule, HamburgerMenuService, HighlightPipe, HomePageEvent, HomePageEventBuilder, HomePageEventModule, ICON_TYPE, IconComponent, IconConfig, IconLoaderService, IconModule, IconResourceType, IconTestingModule, ImageLoadingStrategy, ImportCsvFileService, InlineRenderStrategy, InlineRootRenderStrategy, InnerComponentsHostDirective, IntersectionService, ItemCounterComponent, ItemCounterModule, JSONLD_PRODUCT_BUILDER, JsonLdBaseProductBuilder, JsonLdBuilderModule, JsonLdDirective, JsonLdProductOfferBuilder, JsonLdProductReviewBuilder, JsonLdScriptFactory, KeyboardFocusConfig, KeyboardFocusModule, KeyboardFocusService, KeyboardFocusTestingModule, LanguageCurrencyComponent, LaunchDialogModule, LaunchDialogService, LaunchRenderStrategy, LayoutConfig, LayoutModule, LazyComponentHandler, LinkComponent, LinkModule, ListNavigationModule, LoginGuard, LoginRouteModule, LogoutGuard, LogoutModule, MediaComponent, MediaConfig, MediaModule, MediaService, MessageComponent, MessageComponentModule, MiniCartComponent, MiniCartModule, MockIconComponent, MockIconLoaderService, MockKeyboardFocusDirective, ModalDirective, ModalDirectiveService, ModalModule, ModalRef, ModalService, MyCouponsComponent, MyCouponsModule, MyInterestsComponent, MyInterestsModule, NavigationComponent, NavigationEvent, NavigationEventBuilder, NavigationEventModule, NavigationModule, NavigationService, NavigationUIComponent, NotificationPreferenceComponent, NotificationPreferenceModule, ORDER_ENTRIES_CONTEXT, OnNavigateConfig, OnNavigateService, OrderAmendService, OrderCancellationGuard, OrderCancellationModule, OrderCancellationService, OrderConsignedEntriesComponent, OrderDetailActionsComponent, OrderDetailItemsComponent, OrderDetailShippingComponent, OrderDetailTotalsComponent, OrderDetailsModule, OrderDetailsService, OrderDetailsServiceTransitionalToken, OrderEntriesSource, OrderHistoryComponent, OrderHistoryModule, OrderModule, OrderOverviewComponent, OrderOverviewModule, OrderReturnGuard, OrderReturnModule, OrderReturnRequestListComponent, OrderReturnService, OrderSummaryComponent, OutletContextData, OutletDirective, OutletModule, OutletPosition, OutletRefDirective, OutletRefModule, OutletRenderStrategy, OutletRendererService, OutletService, PAGE_LAYOUT_HANDLER, PRODUCT_DETAILS_URL_MATCHER, PRODUCT_LISTING_URL_MATCHER, PWAModuleConfig, PageComponentModule, PageEvent, PageLayoutComponent, PageLayoutModule, PageLayoutService, PageMetaLinkService, PageSection, PageSlotComponent, PageSlotModule, PageSlotService, PageTemplateDirective, PageTitleComponent, PageTitleModule, PaginationBuilder, PaginationComponent, PaginationConfig, PaginationItemType, PaginationModule, PaginationNavigationPosition, ParagraphComponent, PaymentMethodsComponent, PaymentMethodsModule, PopoverComponent, PopoverDirective, PopoverEvent, PopoverModule, PopoverService, PositioningService, ProductAttributesComponent, ProductAttributesModule, ProductCarouselComponent, ProductCarouselModule, ProductCarouselService, ProductDetailOutlets, ProductDetailsPageEvent, ProductDetailsPageModule, ProductDetailsTabComponent, ProductDetailsTabModule, ProductFacetNavigationComponent, ProductFacetNavigationModule, ProductFacetService, ProductGridItemComponent, ProductImagesComponent, ProductImagesModule, ProductImportStatus, ProductIntroComponent, ProductIntroModule, ProductListComponent, ProductListComponentService, ProductListItemComponent, ProductListItemContext, ProductListItemContextSource, ProductListModule, ProductListOutlets, ProductListingPageModule, ProductPageEventBuilder, ProductPageEventModule, ProductReferencesComponent, ProductReferencesModule, ProductReviewsComponent, ProductReviewsModule, ProductSchemaBuilder, ProductScrollComponent, ProductSummaryComponent, ProductSummaryModule, ProductTabsModule, ProductViewComponent, ProgressButtonComponent, ProgressButtonModule, PromotionsComponent, PromotionsModule, PwaModule, ReplenishmentOrderCancellationComponent, ReplenishmentOrderCancellationDialogComponent, ReplenishmentOrderCancellationDialogModule, ReplenishmentOrderDetailsModule, ReplenishmentOrderDetailsService, ReplenishmentOrderHistoryComponent, ReplenishmentOrderHistoryModule, ReturnOrderComponent, ReturnOrderConfirmationComponent, ReturnOrderConfirmationModule, ReturnOrderModule, ReturnRequestDetailModule, ReturnRequestItemsComponent, ReturnRequestListModule, ReturnRequestOverviewComponent, ReturnRequestTotalsComponent, RoutingContextService, RoutingModule, RoutingRenderStrategy, SCHEMA_BUILDER, SaveForLaterComponent, SaveForLaterModule, SearchBoxComponent, SearchBoxComponentService, SearchBoxModule, SearchBoxProductSelectedEvent, SearchBoxSuggestionSelectedEvent, SearchPageResultsEvent, SelectFocusUtility, SeoMetaService, SeoModule, SiteContextComponentService, SiteContextSelectorComponent, SiteContextSelectorModule, SiteContextType, SkipLink, SkipLinkComponent, SkipLinkConfig, SkipLinkDirective, SkipLinkModule, SkipLinkScrollPosition, SkipLinkService, SortingComponent, SpinnerComponent, SpinnerModule, SplitViewComponent, SplitViewModule, SplitViewService, StarRatingComponent, StarRatingModule, StockNotificationComponent, StockNotificationDialogComponent, StockNotificationModule, StorefrontComponent, StorefrontComponentModule, StorefrontOutlets, StructuredDataModule, SuggestedAddressDialogComponent, SupplementHashAnchorsModule, SupplementHashAnchorsPipe, TabParagraphContainerComponent, TabParagraphContainerModule, TableComponent, TableConfig, TableDataCellComponent, TableDataCellModule, TableHeaderCellComponent, TableHeaderCellModule, TableLayout, TableModule, TableRendererService, TableService, ThemeModule, ThemeService, TrackingEventsComponent, TrapFocus, TruncatePipe, TruncateTextPopoverComponent, TruncateTextPopoverModule, USE_STACKED_OUTLETS, UserComponentModule, ViewComponent, ViewConfig, ViewModes, WishListComponent, WishListItemComponent, WishListModule, controlsMustMatch, defaultCmsContentProviders, defaultKeyboardFocusConfig, defaultLayoutConfig, defaultOnNavigateConfig, defaultPWAModuleConfig, defaultPaginationConfig, defaultReplenishmentOrderCancellationLayoutConfig, defaultSkipLinkConfig, defaultTableConfig, defaultViewConfig, fontawesomeIconConfig, getSuffixUrlMatcher, initSeoService, keyboardFocusFactory, layoutConfig, mediaConfig, onNavigateFactory, provideCmsStructure, provideOutlet, sortTitles, titleScores };
//# sourceMappingURL=spartacus-storefront.js.map
