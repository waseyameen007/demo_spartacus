import { Injectable, } from '@angular/core';
import { THEME_CONTEXT_ID } from '@spartacus/core';
import * as i0 from "@angular/core";
import * as i1 from "@spartacus/core";
export class ThemeService {
    constructor(config, rendererFactory) {
        this.config = config;
        this.rendererFactory = rendererFactory;
    }
    /**
     * This function is to be called for the root component that is
     * bootstrapped.
     */
    init(rootComponent) {
        var _a;
        this.renderer = this.rendererFactory.createRenderer(null, null);
        this.rootComponent = rootComponent;
        // Theme value is a string. It is put in the generic multi-value
        // property of the SiteContextConfig. So the array's first item
        // is the theme value.
        this.setTheme((_a = this.config.context[THEME_CONTEXT_ID]) === null || _a === void 0 ? void 0 : _a[0]);
    }
    setTheme(theme) {
        if (theme) {
            const element = this.rootComponent.location.nativeElement;
            // remove the old theme
            this.renderer.removeClass(element, this.existingTheme);
            // add the new theme
            this.renderer.addClass(element, theme);
            this.existingTheme = theme;
        }
    }
}
ThemeService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ThemeService, deps: [{ token: i1.SiteContextConfig }, { token: i0.RendererFactory2 }], target: i0.ɵɵFactoryTarget.Injectable });
ThemeService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ThemeService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ThemeService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: function () { return [{ type: i1.SiteContextConfig }, { type: i0.RendererFactory2 }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGhlbWUuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL3N0b3JlZnJvbnRsaWIvbGF5b3V0L3RoZW1lL3RoZW1lLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUVMLFVBQVUsR0FHWCxNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQXFCLGdCQUFnQixFQUFFLE1BQU0saUJBQWlCLENBQUM7OztBQUd0RSxNQUFNLE9BQU8sWUFBWTtJQUt2QixZQUNZLE1BQXlCLEVBQ3pCLGVBQWlDO1FBRGpDLFdBQU0sR0FBTixNQUFNLENBQW1CO1FBQ3pCLG9CQUFlLEdBQWYsZUFBZSxDQUFrQjtJQUMxQyxDQUFDO0lBRUo7OztPQUdHO0lBQ0gsSUFBSSxDQUFDLGFBQWdDOztRQUNuQyxJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQyxlQUFlLENBQUMsY0FBYyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztRQUNoRSxJQUFJLENBQUMsYUFBYSxHQUFHLGFBQWEsQ0FBQztRQUNuQyxnRUFBZ0U7UUFDaEUsK0RBQStEO1FBQy9ELHNCQUFzQjtRQUN0QixJQUFJLENBQUMsUUFBUSxDQUFDLE1BQUEsSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsZ0JBQWdCLENBQUMsMENBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUM1RCxDQUFDO0lBRUQsUUFBUSxDQUFDLEtBQWE7UUFDcEIsSUFBSSxLQUFLLEVBQUU7WUFDVCxNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQyxhQUFhLENBQUM7WUFDMUQsdUJBQXVCO1lBQ3ZCLElBQUksQ0FBQyxRQUFRLENBQUMsV0FBVyxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUM7WUFDdkQsb0JBQW9CO1lBQ3BCLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLE9BQU8sRUFBRSxLQUFLLENBQUMsQ0FBQztZQUN2QyxJQUFJLENBQUMsYUFBYSxHQUFHLEtBQUssQ0FBQztTQUM1QjtJQUNILENBQUM7O3lHQWhDVSxZQUFZOzZHQUFaLFlBQVksY0FEQyxNQUFNOzJGQUNuQixZQUFZO2tCQUR4QixVQUFVO21CQUFDLEVBQUUsVUFBVSxFQUFFLE1BQU0sRUFBRSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIENvbXBvbmVudFJlZixcbiAgSW5qZWN0YWJsZSxcbiAgUmVuZGVyZXIyLFxuICBSZW5kZXJlckZhY3RvcnkyLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFNpdGVDb250ZXh0Q29uZmlnLCBUSEVNRV9DT05URVhUX0lEIH0gZnJvbSAnQHNwYXJ0YWN1cy9jb3JlJztcblxuQEluamVjdGFibGUoeyBwcm92aWRlZEluOiAncm9vdCcgfSlcbmV4cG9ydCBjbGFzcyBUaGVtZVNlcnZpY2Uge1xuICBwcm90ZWN0ZWQgcm9vdENvbXBvbmVudDogQ29tcG9uZW50UmVmPGFueT47XG4gIHByb3RlY3RlZCByZW5kZXJlcjogUmVuZGVyZXIyO1xuICBwcm90ZWN0ZWQgZXhpc3RpbmdUaGVtZTogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByb3RlY3RlZCBjb25maWc6IFNpdGVDb250ZXh0Q29uZmlnLFxuICAgIHByb3RlY3RlZCByZW5kZXJlckZhY3Rvcnk6IFJlbmRlcmVyRmFjdG9yeTJcbiAgKSB7fVxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIHRvIGJlIGNhbGxlZCBmb3IgdGhlIHJvb3QgY29tcG9uZW50IHRoYXQgaXNcbiAgICogYm9vdHN0cmFwcGVkLlxuICAgKi9cbiAgaW5pdChyb290Q29tcG9uZW50OiBDb21wb25lbnRSZWY8YW55Pik6IHZvaWQge1xuICAgIHRoaXMucmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyRmFjdG9yeS5jcmVhdGVSZW5kZXJlcihudWxsLCBudWxsKTtcbiAgICB0aGlzLnJvb3RDb21wb25lbnQgPSByb290Q29tcG9uZW50O1xuICAgIC8vIFRoZW1lIHZhbHVlIGlzIGEgc3RyaW5nLiBJdCBpcyBwdXQgaW4gdGhlIGdlbmVyaWMgbXVsdGktdmFsdWVcbiAgICAvLyBwcm9wZXJ0eSBvZiB0aGUgU2l0ZUNvbnRleHRDb25maWcuIFNvIHRoZSBhcnJheSdzIGZpcnN0IGl0ZW1cbiAgICAvLyBpcyB0aGUgdGhlbWUgdmFsdWUuXG4gICAgdGhpcy5zZXRUaGVtZSh0aGlzLmNvbmZpZy5jb250ZXh0W1RIRU1FX0NPTlRFWFRfSURdPy5bMF0pO1xuICB9XG5cbiAgc2V0VGhlbWUodGhlbWU6IHN0cmluZyk6IHZvaWQge1xuICAgIGlmICh0aGVtZSkge1xuICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMucm9vdENvbXBvbmVudC5sb2NhdGlvbi5uYXRpdmVFbGVtZW50O1xuICAgICAgLy8gcmVtb3ZlIHRoZSBvbGQgdGhlbWVcbiAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQ2xhc3MoZWxlbWVudCwgdGhpcy5leGlzdGluZ1RoZW1lKTtcbiAgICAgIC8vIGFkZCB0aGUgbmV3IHRoZW1lXG4gICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKGVsZW1lbnQsIHRoZW1lKTtcbiAgICAgIHRoaXMuZXhpc3RpbmdUaGVtZSA9IHRoZW1lO1xuICAgIH1cbiAgfVxufVxuIl19