import { Component, Input } from '@angular/core';
import { ViewModes } from '../../product-view/product-view.component';
import { Subscription } from 'rxjs';
import * as i0 from "@angular/core";
import * as i1 from "../product-list-component.service";
import * as i2 from "../../product-grid-item/product-grid-item.component";
import * as i3 from "../../../../../shared/components/spinner/spinner.component";
import * as i4 from "../../product-list-item/product-list-item.component";
import * as i5 from "@angular/common";
import * as i6 from "ngx-infinite-scroll";
import * as i7 from "@spartacus/core";
export class ProductScrollComponent {
    constructor(productListComponentService, ref) {
        this.productListComponentService = productListComponentService;
        this.ref = ref;
        this.subscription = new Subscription();
        this.ViewModes = ViewModes;
        this.appendProducts = false;
        this.resetList = false;
        this.isMaxProducts = false;
        this.isLastPage = false;
        this.isEmpty = false;
    }
    set setConfig(inputConfig) {
        this.setComponentConfigurations(inputConfig);
    }
    set setModel(inputModel) {
        this.infiniteScrollOperations(inputModel);
    }
    set setViewMode(inputViewMode) {
        this.inputViewMode = inputViewMode;
        //If viewMode is already set (meaning it is not the first load)
        //Reset the product list
        if (this.viewMode) {
            this.resetListOnViewModeChange();
        }
        else {
            //If viewMode is not set (meaning it is the first load)
            //Set the viewMode
            this.viewMode = inputViewMode;
        }
    }
    scrollPage(pageNumber) {
        this.appendProducts = true;
        this.ref.markForCheck();
        this.productListComponentService.getPageItems(pageNumber);
    }
    loadNextPage(pageNumber) {
        this.isMaxProducts = false;
        this.scrollPage(pageNumber);
    }
    scrollToTop() {
        window.scroll(0, 0);
    }
    setComponentConfigurations(scrollConfig) {
        var _a, _b, _c, _d;
        const isButton = (_b = (_a = scrollConfig.view) === null || _a === void 0 ? void 0 : _a.infiniteScroll) === null || _b === void 0 ? void 0 : _b.showMoreButton;
        const configProductLimit = (_d = (_c = scrollConfig.view) === null || _c === void 0 ? void 0 : _c.infiniteScroll) === null || _d === void 0 ? void 0 : _d.productLimit;
        //Display "show more" button every time when button configuration is true
        //Otherwise, only display "show more" when the configuration product limit is reached
        this.productLimit = isButton ? 1 : configProductLimit;
    }
    infiniteScrollOperations(inputModel) {
        if (this.appendProducts) {
            this.model = Object.assign(Object.assign({}, inputModel), { products: this.model.products.concat(inputModel.products) });
        }
        else {
            this.model = inputModel;
            this.maxProducts = this.productLimit;
        }
        this.setConditions();
        this.ref.markForCheck();
    }
    resetListOnViewModeChange() {
        this.scrollToTop();
        this.resetList = true;
        this.productListComponentService.getPageItems(0);
    }
    //Set booleans after model has been retrieved
    setConditions() {
        this.isEmpty = !this.model.products || this.model.products.length === 0;
        this.isLastPage =
            this.model.pagination.currentPage ===
                this.model.pagination.totalPages - 1;
        this.isMaxProducts =
            this.productLimit &&
                this.productLimit !== 0 &&
                this.model.products.length >= this.maxProducts;
        //Add the productLimit to the current number of products to determine the next max number of products
        if (this.isMaxProducts) {
            this.maxProducts = this.model.products.length + this.productLimit;
        }
        //Only change viewMode once the new model is set
        //This prevents flickering issues
        if (this.viewMode !== this.inputViewMode) {
            this.viewMode = this.inputViewMode;
        }
        this.resetList = false;
        this.appendProducts = false;
    }
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
}
ProductScrollComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductScrollComponent, deps: [{ token: i1.ProductListComponentService }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
ProductScrollComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: ProductScrollComponent, selector: "cx-product-scroll", inputs: { setConfig: ["scrollConfig", "setConfig"], setModel: ["model", "setModel"], setViewMode: ["inputViewMode", "setViewMode"] }, ngImport: i0, template: "<ng-container *ngIf=\"viewMode === ViewModes.Grid\">\n  <div\n    infiniteScroll\n    [infiniteScrollDistance]=\"5\"\n    [infiniteScrollThrottle]=\"50\"\n    [infiniteScrollDisabled]=\"isMaxProducts || isLastPage || isEmpty\"\n    (scrolled)=\"scrollPage(model?.pagination?.currentPage + 1)\"\n  >\n    <div class=\"row\">\n      <cx-product-grid-item\n        *ngFor=\"let product of model?.products\"\n        [product]=\"product\"\n        class=\"col-12 col-sm-6 col-md-4\"\n      ></cx-product-grid-item>\n    </div>\n    <div\n      [className]=\"\n        !isLastPage && model?.pagination?.currentPage > 0\n          ? 'cx-double-btn-container grid-btn-padding'\n          : 'cx-single-btn-container grid-btn-padding'\n      \"\n    >\n      <div\n        *ngIf=\"\n          (isMaxProducts || isLastPage) && model?.pagination?.currentPage > 0\n        \"\n        (click)=\"scrollToTop()\"\n        class=\"btn btn-block btn-action\"\n      >\n        {{ 'productList.backToTopBtn' | cxTranslate }}\n      </div>\n      <div\n        *ngIf=\"isMaxProducts && !isLastPage\"\n        (click)=\"loadNextPage(model?.pagination?.currentPage + 1)\"\n        class=\"btn btn-block btn-action align-btn\"\n      >\n        {{ 'productList.showMoreBtn' | cxTranslate }}\n      </div>\n    </div>\n    <div *ngIf=\"appendProducts\" class=\"cx-spinner\">\n      <cx-spinner></cx-spinner>\n    </div>\n  </div>\n</ng-container>\n\n<ng-container *ngIf=\"viewMode === ViewModes.List\">\n  <div\n    infiniteScroll\n    [infiniteScrollDistance]=\"3\"\n    [infiniteScrollThrottle]=\"50\"\n    [infiniteScrollDisabled]=\"isMaxProducts || isLastPage || isEmpty\"\n    (scrolled)=\"scrollPage(model?.pagination?.currentPage + 1)\"\n  >\n    <cx-product-list-item\n      *ngFor=\"let product of model?.products\"\n      [product]=\"product\"\n      class=\"cx-product-search-list\"\n    ></cx-product-list-item>\n    <div\n      [className]=\"\n        !isLastPage && model?.pagination?.currentPage > 0\n          ? 'cx-double-btn-container'\n          : 'cx-single-btn-container'\n      \"\n    >\n      <div\n        *ngIf=\"\n          (isMaxProducts || isLastPage) && model?.pagination?.currentPage > 0\n        \"\n        (click)=\"scrollToTop()\"\n        class=\"btn btn-block btn-action\"\n      >\n        {{ 'productList.backToTopBtn' | cxTranslate }}\n      </div>\n      <div\n        *ngIf=\"isMaxProducts && !isLastPage\"\n        (click)=\"loadNextPage(model?.pagination?.currentPage + 1)\"\n        class=\"btn btn-block btn-action align-btn\"\n      >\n        {{ 'productList.showMoreBtn' | cxTranslate }}\n      </div>\n    </div>\n    <div *ngIf=\"appendProducts\" class=\"cx-spinner\">\n      <cx-spinner></cx-spinner>\n    </div>\n  </div>\n</ng-container>\n", components: [{ type: i2.ProductGridItemComponent, selector: "cx-product-grid-item", inputs: ["product"] }, { type: i3.SpinnerComponent, selector: "cx-spinner" }, { type: i4.ProductListItemComponent, selector: "cx-product-list-item", inputs: ["product"] }], directives: [{ type: i5.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i6.InfiniteScrollDirective, selector: "[infiniteScroll], [infinite-scroll], [data-infinite-scroll]", inputs: ["infiniteScrollDistance", "infiniteScrollUpDistance", "infiniteScrollThrottle", "infiniteScrollDisabled", "infiniteScrollContainer", "scrollWindow", "immediateCheck", "horizontal", "alwaysCallback", "fromRoot"], outputs: ["scrolled", "scrolledUp"] }, { type: i5.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], pipes: { "cxTranslate": i7.TranslatePipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ProductScrollComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-product-scroll',
                    templateUrl: './product-scroll.component.html',
                }]
        }], ctorParameters: function () { return [{ type: i1.ProductListComponentService }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { setConfig: [{
                type: Input,
                args: ['scrollConfig']
            }], setModel: [{
                type: Input,
                args: ['model']
            }], setViewMode: [{
                type: Input,
                args: ['inputViewMode']
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvZHVjdC1zY3JvbGwuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvc3RvcmVmcm9udGxpYi9jbXMtY29tcG9uZW50cy9wcm9kdWN0L3Byb2R1Y3QtbGlzdC9jb250YWluZXIvcHJvZHVjdC1zY3JvbGwvcHJvZHVjdC1zY3JvbGwuY29tcG9uZW50LnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvc3RvcmVmcm9udGxpYi9jbXMtY29tcG9uZW50cy9wcm9kdWN0L3Byb2R1Y3QtbGlzdC9jb250YWluZXIvcHJvZHVjdC1zY3JvbGwvcHJvZHVjdC1zY3JvbGwuY29tcG9uZW50Lmh0bWwiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQWdDLE1BQU0sZUFBZSxDQUFDO0FBRS9FLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSwyQ0FBMkMsQ0FBQztBQUN0RSxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sTUFBTSxDQUFDOzs7Ozs7Ozs7QUFRcEMsTUFBTSxPQUFPLHNCQUFzQjtJQXdDakMsWUFDVSwyQkFBd0QsRUFDeEQsR0FBc0I7UUFEdEIsZ0NBQTJCLEdBQTNCLDJCQUEyQixDQUE2QjtRQUN4RCxRQUFHLEdBQUgsR0FBRyxDQUFtQjtRQXpDeEIsaUJBQVksR0FBRyxJQUFJLFlBQVksRUFBRSxDQUFDO1FBZ0MxQyxjQUFTLEdBQUcsU0FBUyxDQUFDO1FBQ3RCLG1CQUFjLEdBQUcsS0FBSyxDQUFDO1FBQ3ZCLGNBQVMsR0FBRyxLQUFLLENBQUM7UUFDbEIsa0JBQWEsR0FBRyxLQUFLLENBQUM7UUFDdEIsZUFBVSxHQUFHLEtBQUssQ0FBQztRQUNuQixZQUFPLEdBQUcsS0FBSyxDQUFDO0lBS2IsQ0FBQztJQXhDSixJQUNJLFNBQVMsQ0FBQyxXQUF1QjtRQUNuQyxJQUFJLENBQUMsMEJBQTBCLENBQUMsV0FB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SUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsTUFBTSxJQUFJLElBQUksQ0FBQyxXQUFXLENBQUM7UUFFakQscUdBQXFHO1FBQ3JHLElBQUksSUFBSSxDQUFDLGFBQWEsRUFBRTtZQUN0QixJQUFJLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDO1NBQ25FO1FBRUQsZ0RBQWdEO1FBQ2hELGlDQUFpQztRQUNqQyxJQUFJLElBQUksQ0FBQyxRQUFRLEtBQUssSUFBSSxDQUFDLGFBQWEsRUFBRTtZQUN4QyxJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUM7U0FDcEM7UUFFRCxJQUFJLENBQUMsU0FBUyxHQUFHLEtBQUssQ0FBQztRQUN2QixJQUFJLENBQUMsY0FBYyxHQUFHLEtBQUssQ0FBQztJQUM5QixDQUFDO0lBRUQsV0FBVztRQUNULElBQUksQ0FBQyxZQUFZLENBQUMsV0FBVyxFQUFFLENBQUM7SUFDbEMsQ0FBQzs7bUhBdkhVLHNCQUFzQjt1R0FBdEIsc0JBQXNCLCtMQ1huQyxxdEZBdUZBOzJGRDVFYSxzQkFBc0I7a0JBSmxDLFNBQVM7bUJBQUM7b0JBQ1QsUUFBUSxFQUFFLG1CQUFtQjtvQkFDN0IsV0FBVyxFQUFFLGlDQUFpQztpQkFDL0M7a0pBS0ssU0FBUztzQkFEWixLQUFLO3VCQUFDLGNBQWM7Z0JBT2pCLFFBQVE7c0JBRFgsS0FBSzt1QkFBQyxPQUFPO2dCQU9WLFdBQVc7c0JBRGQsS0FBSzt1QkFBQyxlQUFlIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCwgT25EZXN0cm95LCBDaGFuZ2VEZXRlY3RvclJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgUHJvZHVjdFNlYXJjaFBhZ2UgfSBmcm9tICdAc3BhcnRhY3VzL2NvcmUnO1xuaW1wb3J0IHsgVmlld01vZGVzIH0gZnJvbSAnLi4vLi4vcHJvZHVjdC12aWV3L3Byb2R1Y3Qtdmlldy5jb21wb25lbnQnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBQcm9kdWN0TGlzdENvbXBvbmVudFNlcnZpY2UgfSBmcm9tICcuLi9wcm9kdWN0LWxpc3QtY29tcG9uZW50LnNlcnZpY2UnO1xuaW1wb3J0IHsgVmlld0NvbmZpZyB9IGZyb20gJy4uLy4uLy4uLy4uLy4uL3NoYXJlZC9jb25maWcvdmlldy1jb25maWcnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjeC1wcm9kdWN0LXNjcm9sbCcsXG4gIHRlbXBsYXRlVXJsOiAnLi9wcm9kdWN0LXNjcm9sbC5jb21wb25lbnQuaHRtbCcsXG59KVxuZXhwb3J0IGNsYXNzIFByb2R1Y3RTY3JvbGxDb21wb25lbnQgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuICBwcml2YXRlIHN1YnNjcmlwdGlvbiA9IG5ldyBTdWJzY3JpcHRpb24oKTtcblxuICBASW5wdXQoJ3Njcm9sbENvbmZpZycpXG4gIHNldCBzZXRDb25maWcoaW5wdXRDb25maWc6IFZpZXdDb25maWcpIHtcbiAgICB0aGlzLnNldENvbXBvbmVudENvbmZpZ3VyYXRpb25zKGlucHV0Q29uZmlnKTtcbiAgfVxuXG4gIG1vZGVsOiBQcm9kdWN0U2VhcmNoUGFnZTtcbiAgQElucHV0KCdtb2RlbCcpXG4gIHNldCBzZXRNb2RlbChpbnB1dE1vZGVsOiBQcm9kdWN0U2VhcmNoUGFnZSkge1xuICAgIHRoaXMuaW5maW5pdGVTY3JvbGxPcGVyYXRpb25zKGlucHV0TW9kZWwpO1xuICB9XG5cbiAgaW5wdXRWaWV3TW9kZTogVmlld01vZGVzO1xuICBASW5wdXQoJ2lucHV0Vmlld01vZGUnKVxuICBzZXQgc2V0Vmlld01vZGUoaW5wdXRWaWV3TW9kZTogVmlld01vZGVzKSB7XG4gICAgdGhpcy5pbnB1dFZpZXdNb2RlID0gaW5wdXRWaWV3TW9kZTtcbiAgICAvL0lmIHZpZXdNb2RlIGlzIGFscmVhZHkgc2V0IChtZWFuaW5nIGl0IGlzIG5vdCB0aGUgZmlyc3QgbG9hZClcbiAgICAvL1Jlc2V0IHRoZSBwcm9kdWN0IGxpc3RcbiAgICBpZiAodGhpcy52aWV3TW9kZSkge1xuICAgICAgdGhpcy5yZXNldExpc3RPblZpZXdNb2RlQ2hhbmdlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vSWYgdmlld01vZGUgaXMgbm90IHNldCAobWVhbmluZyBpdCBpcyB0aGUgZmlyc3QgbG9hZClcbiAgICAgIC8vU2V0IHRoZSB2aWV3TW9kZVxuICAgICAgdGhpcy52aWV3TW9kZSA9IGlucHV0Vmlld01vZGU7XG4gICAgfVxuICB9XG5cbiAgdmlld01vZGU6IFZpZXdNb2RlcztcbiAgcHJvZHVjdExpbWl0OiBudW1iZXI7XG4gIG1heFByb2R1Y3RzOiBudW1iZXI7XG5cbiAgVmlld01vZGVzID0gVmlld01vZGVzO1xuICBhcHBlbmRQcm9kdWN0cyA9IGZhbHNlO1xuICByZXNldExpc3QgPSBmYWxzZTtcbiAgaXNNYXhQcm9kdWN0cyA9IGZhbHNlO1xuICBpc0xhc3RQYWdlID0gZmFsc2U7XG4gIGlzRW1wdHkgPSBmYWxzZTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHByb2R1Y3RMaXN0Q29tcG9uZW50U2VydmljZTogUHJvZHVjdExpc3RDb21wb25lbnRTZXJ2aWNlLFxuICAgIHByaXZhdGUgcmVmOiBDaGFuZ2VEZXRlY3RvclJlZlxuICApIHt9XG5cbiAgc2Nyb2xsUGFnZShwYWdlTnVtYmVyOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLmFwcGVuZFByb2R1Y3RzID0gdHJ1ZTtcbiAgICB0aGlzLnJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgICB0aGlzLnByb2R1Y3RMaXN0Q29tcG9uZW50U2VydmljZS5nZXRQYWdlSXRlbXMocGFnZU51bWJlcik7XG4gIH1cblxuICBsb2FkTmV4dFBhZ2UocGFnZU51bWJlcjogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5pc01heFByb2R1Y3RzID0gZmFsc2U7XG4gICAgdGhpcy5zY3JvbGxQYWdlKHBhZ2VOdW1iZXIpO1xuICB9XG5cbiAgc2Nyb2xsVG9Ub3AoKTogdm9pZCB7XG4gICAgd2luZG93LnNjcm9sbCgwLCAwKTtcbiAgfVxuXG4gIHByaXZhdGUgc2V0Q29tcG9uZW50Q29uZmlndXJhdGlvbnMoc2Nyb2xsQ29uZmlnOiBWaWV3Q29uZmlnKTogdm9pZCB7XG4gICAgY29uc3QgaXNCdXR0b24gPSBzY3JvbGxDb25maWcudmlldz8uaW5maW5pdGVTY3JvbGw/LnNob3dNb3JlQnV0dG9uO1xuICAgIGNvbnN0IGNvbmZpZ1Byb2R1Y3RMaW1pdCA9IHNjcm9sbENvbmZpZy52aWV3Py5pbmZpbml0ZVNjcm9sbD8ucHJvZHVjdExpbWl0O1xuXG4gICAgLy9EaXNwbGF5IFwic2hvdyBtb3JlXCIgYnV0dG9uIGV2ZXJ5IHRpbWUgd2hlbiBidXR0b24gY29uZmlndXJhdGlvbiBpcyB0cnVlXG4gICAgLy9PdGhlcndpc2UsIG9ubHkgZGlzcGxheSBcInNob3cgbW9yZVwiIHdoZW4gdGhlIGNvbmZpZ3VyYXRpb24gcHJvZHVjdCBsaW1pdCBpcyByZWFjaGVkXG4gICAgdGhpcy5wcm9kdWN0TGltaXQgPSBpc0J1dHRvbiA/IDEgOiBjb25maWdQcm9kdWN0TGltaXQ7XG4gIH1cblxuICBwcml2YXRlIGluZmluaXRlU2Nyb2xsT3BlcmF0aW9ucyhpbnB1dE1vZGVsOiBQcm9kdWN0U2VhcmNoUGFnZSk6IHZvaWQge1xuICAgIGlmICh0aGlzLmFwcGVuZFByb2R1Y3RzKSB7XG4gICAgICB0aGlzLm1vZGVsID0ge1xuICAgICAgICAuLi5pbnB1dE1vZGVsLFxuICAgICAgICBwcm9kdWN0czogdGhpcy5tb2RlbC5wcm9kdWN0cy5jb25jYXQoaW5wdXRNb2RlbC5wcm9kdWN0cyksXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm1vZGVsID0gaW5wdXRNb2RlbDtcbiAgICAgIHRoaXMubWF4UHJvZHVjdHMgPSB0aGlzLnByb2R1Y3RMaW1pdDtcbiAgICB9XG4gICAgdGhpcy5zZXRDb25kaXRpb25zKCk7XG4gICAgdGhpcy5yZWYubWFya0ZvckNoZWNrKCk7XG4gIH1cblxuICBwcml2YXRlIHJlc2V0TGlzdE9uVmlld01vZGVDaGFuZ2UoKTogdm9pZCB7XG4gICAgdGhpcy5zY3JvbGxUb1RvcCgpO1xuICAgIHRoaXMucmVzZXRMaXN0ID0gdHJ1ZTtcbiAgICB0aGlzLnByb2R1Y3RMaXN0Q29tcG9uZW50U2VydmljZS5nZXRQYWdlSXRlbXMoMCk7XG4gIH1cblxuICAvL1NldCBib29sZWFucyBhZnRlciBtb2RlbCBoYXMgYmVlbiByZXRyaWV2ZWRcbiAgcHJpdmF0ZSBzZXRDb25kaXRpb25zKCk6IHZvaWQge1xuICAgIHRoaXMuaXNFbXB0eSA9ICF0aGlzLm1vZGVsLnByb2R1Y3RzIHx8IHRoaXMubW9kZWwucHJvZHVjdHMubGVuZ3RoID09PSAwO1xuXG4gICAgdGhpcy5pc0xhc3RQYWdlID1cbiAgICAgIHRoaXMubW9kZWwucGFnaW5hdGlvbi5jdXJyZW50UGFnZSA9PT1cbiAgICAgIHRoaXMubW9kZWwucGFnaW5hdGlvbi50b3RhbFBhZ2VzIC0gMTtcblxuICAgIHRoaXMuaXNNYXhQcm9kdWN0cyA9XG4gICAgICB0aGlzLnByb2R1Y3RMaW1pdCAmJlxuICAgICAgdGhpcy5wcm9kdWN0TGltaXQgIT09IDAgJiZcbiAgICAgIHRoaXMubW9kZWwucHJvZHVjdHMubGVuZ3RoID49IHRoaXMubWF4UHJvZHVjdHM7XG5cbiAgICAvL0FkZCB0aGUgcHJvZHVjdExpbWl0IHRvIHRoZSBjdXJyZW50IG51bWJlciBvZiBwcm9kdWN0cyB0byBkZXRlcm1pbmUgdGhlIG5leHQgbWF4IG51bWJlciBvZiBwcm9kdWN0c1xuICAgIGlmICh0aGlzLmlzTWF4UHJvZHVjdHMpIHtcbiAgICAgIHRoaXMubWF4UHJvZHVjdHMgPSB0aGlzLm1vZGVsLnByb2R1Y3RzLmxlbmd0aCArIHRoaXMucHJvZHVjdExpbWl0O1xuICAgIH1cblxuICAgIC8vT25seSBjaGFuZ2Ugdmlld01vZGUgb25jZSB0aGUgbmV3IG1vZGVsIGlzIHNldFxuICAgIC8vVGhpcyBwcmV2ZW50cyBmbGlja2VyaW5nIGlzc3Vlc1xuICAgIGlmICh0aGlzLnZpZXdNb2RlICE9PSB0aGlzLmlucHV0Vmlld01vZGUpIHtcbiAgICAgIHRoaXMudmlld01vZGUgPSB0aGlzLmlucHV0Vmlld01vZGU7XG4gICAgfVxuXG4gICAgdGhpcy5yZXNldExpc3QgPSBmYWxzZTtcbiAgICB0aGlzLmFwcGVuZFByb2R1Y3RzID0gZmFsc2U7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICB9XG59XG4iLCI8bmctY29udGFpbmVyICpuZ0lmPVwidmlld01vZGUgPT09IFZpZXdNb2Rlcy5HcmlkXCI+XG4gIDxkaXZcbiAgICBpbmZpbml0ZVNjcm9sbFxuICAgIFtpbmZpbml0ZVNjcm9sbERpc3RhbmNlXT1cIjVcIlxuICAgIFtpbmZpbml0ZVNjcm9sbFRocm90dGxlXT1cIjUwXCJcbiAgICBbaW5maW5pdGVTY3JvbGxEaXNhYmxlZF09XCJpc01heFByb2R1Y3RzIHx8IGlzTGFzdFBhZ2UgfHwgaXNFbXB0eVwiXG4gICAgKHNjcm9sbGVkKT1cInNjcm9sbFBhZ2UobW9kZWw/LnBhZ2luYXRpb24/LmN1cnJlbnRQYWdlICsgMSlcIlxuICA+XG4gICAgPGRpdiBjbGFzcz1cInJvd1wiPlxuICAgICAgPGN4LXByb2R1Y3QtZ3JpZC1pdGVtXG4gICAgICAgICpuZ0Zvcj1cImxldCBwcm9kdWN0IG9mIG1vZGVsPy5wcm9kdWN0c1wiXG4gICAgICAgIFtwcm9kdWN0XT1cInByb2R1Y3RcIlxuICAgICAgICBjbGFzcz1cImNvbC0xMiBjb2wtc20tNiBjb2wtbWQtNFwiXG4gICAgICA+PC9jeC1wcm9kdWN0LWdyaWQtaXRlbT5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2XG4gICAgICBbY2xhc3NOYW1lXT1cIlxuICAgICAgICAhaXNMYXN0UGFnZSAmJiBtb2RlbD8ucGFnaW5hdGlvbj8uY3VycmVudFBhZ2UgPiAwXG4gICAgICAgICAgPyAnY3gtZG91YmxlLWJ0bi1jb250YWluZXIgZ3JpZC1idG4tcGFkZGluZydcbiAgICAgICAgICA6ICdjeC1zaW5nbGUtYnRuLWNvbnRhaW5lciBncmlkLWJ0bi1wYWRkaW5nJ1xuICAgICAgXCJcbiAgICA+XG4gICAgICA8ZGl2XG4gICAgICAgICpuZ0lmPVwiXG4gICAgICAgICAgKGlzTWF4UHJvZHVjdHMgfHwgaXNMYXN0UGFnZSkgJiYgbW9kZWw/LnBhZ2luYXRpb24/LmN1cnJlbnRQYWdlID4gMFxuICAgICAgICBcIlxuICAgICAgICAoY2xpY2spPVwic2Nyb2xsVG9Ub3AoKVwiXG4gICAgICAgIGNsYXNzPVwiYnRuIGJ0bi1ibG9jayBidG4tYWN0aW9uXCJcbiAgICAgID5cbiAgICAgICAge3sgJ3Byb2R1Y3RMaXN0LmJhY2tUb1RvcEJ0bicgfCBjeFRyYW5zbGF0ZSB9fVxuICAgICAgPC9kaXY+XG4gICAgICA8ZGl2XG4gICAgICAgICpuZ0lmPVwiaXNNYXhQcm9kdWN0cyAmJiAhaXNMYXN0UGFnZVwiXG4gICAgICAgIChjbGljayk9XCJsb2FkTmV4dFBhZ2UobW9kZWw/LnBhZ2luYXRpb24/LmN1cnJlbnRQYWdlICsgMSlcIlxuICAgICAgICBjbGFzcz1cImJ0biBidG4tYmxvY2sgYnRuLWFjdGlvbiBhbGlnbi1idG5cIlxuICAgICAgPlxuICAgICAgICB7eyAncHJvZHVjdExpc3Quc2hvd01vcmVCdG4nIHwgY3hUcmFuc2xhdGUgfX1cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICAgIDxkaXYgKm5nSWY9XCJhcHBlbmRQcm9kdWN0c1wiIGNsYXNzPVwiY3gtc3Bpbm5lclwiPlxuICAgICAgPGN4LXNwaW5uZXI+PC9jeC1zcGlubmVyPlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbjwvbmctY29udGFpbmVyPlxuXG48bmctY29udGFpbmVyICpuZ0lmPVwidmlld01vZGUgPT09IFZpZXdNb2Rlcy5MaXN0XCI+XG4gIDxkaXZcbiAgICBpbmZpbml0ZVNjcm9sbFxuICAgIFtpbmZpbml0ZVNjcm9sbERpc3RhbmNlXT1cIjNcIlxuICAgIFtpbmZpbml0ZVNjcm9sbFRocm90dGxlXT1cIjUwXCJcbiAgICBbaW5maW5pdGVTY3JvbGxEaXNhYmxlZF09XCJpc01heFByb2R1Y3RzIHx8IGlzTGFzdFBhZ2UgfHwgaXNFbXB0eVwiXG4gICAgKHNjcm9sbGVkKT1cInNjcm9sbFBhZ2UobW9kZWw/LnBhZ2luYXRpb24/LmN1cnJlbnRQYWdlICsgMSlcIlxuICA+XG4gICAgPGN4LXByb2R1Y3QtbGlzdC1pdGVtXG4gICAgICAqbmdGb3I9XCJsZXQgcHJvZHVjdCBvZiBtb2RlbD8ucHJvZHVjdHNcIlxuICAgICAgW3Byb2R1Y3RdPVwicHJvZHVjdFwiXG4gICAgICBjbGFzcz1cImN4LXByb2R1Y3Qtc2VhcmNoLWxpc3RcIlxuICAgID48L2N4LXByb2R1Y3QtbGlzdC1pdGVtPlxuICAgIDxkaXZcbiAgICAgIFtjbGFzc05hbWVdPVwiXG4gICAgICAgICFpc0xhc3RQYWdlICYmIG1vZGVsPy5wYWdpbmF0aW9uPy5jdXJyZW50UGFnZSA+IDBcbiAgICAgICAgICA/ICdjeC1kb3VibGUtYnRuLWNvbnRhaW5lcidcbiAgICAgICAgICA6ICdjeC1zaW5nbGUtYnRuLWNvbnRhaW5lcidcbiAgICAgIFwiXG4gICAgPlxuICAgICAgPGRpdlxuICAgICAgICAqbmdJZj1cIlxuICAgICAgICAgIChpc01heFByb2R1Y3RzIHx8IGlzTGFzdFBhZ2UpICYmIG1vZGVsPy5wYWdpbmF0aW9uPy5jdXJyZW50UGFnZSA+IDBcbiAgICAgICAgXCJcbiAgICAgICAgKGNsaWNrKT1cInNjcm9sbFRvVG9wKClcIlxuICAgICAgICBjbGFzcz1cImJ0biBidG4tYmxvY2sgYnRuLWFjdGlvblwiXG4gICAgICA+XG4gICAgICAgIHt7ICdwcm9kdWN0TGlzdC5iYWNrVG9Ub3BCdG4nIHwgY3hUcmFuc2xhdGUgfX1cbiAgICAgIDwvZGl2PlxuICAgICAgPGRpdlxuICAgICAgICAqbmdJZj1cImlzTWF4UHJvZHVjdHMgJiYgIWlzTGFzdFBhZ2VcIlxuICAgICAgICAoY2xpY2spPVwibG9hZE5leHRQYWdlKG1vZGVsPy5wYWdpbmF0aW9uPy5jdXJyZW50UGFnZSArIDEpXCJcbiAgICAgICAgY2xhc3M9XCJidG4gYnRuLWJsb2NrIGJ0bi1hY3Rpb24gYWxpZ24tYnRuXCJcbiAgICAgID5cbiAgICAgICAge3sgJ3Byb2R1Y3RMaXN0LnNob3dNb3JlQnRuJyB8IGN4VHJhbnNsYXRlIH19XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2ICpuZ0lmPVwiYXBwZW5kUHJvZHVjdHNcIiBjbGFzcz1cImN4LXNwaW5uZXJcIj5cbiAgICAgIDxjeC1zcGlubmVyPjwvY3gtc3Bpbm5lcj5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG48L25nLWNvbnRhaW5lcj5cbiJdfQ==