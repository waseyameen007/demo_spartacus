import { ChangeDetectionStrategy, Component, EventEmitter, HostListener, Input, Output, } from '@angular/core';
import { map } from 'rxjs/operators';
import { ICON_TYPE } from '../../../../misc/icon/icon.model';
import { FacetGroupCollapsedState } from '../facet.model';
import * as i0 from "@angular/core";
import * as i1 from "../services/facet.service";
import * as i2 from "../../../../misc/icon/icon.component";
import * as i3 from "../facet/facet.component";
import * as i4 from "@angular/common";
import * as i5 from "../../../../../layout/a11y/keyboard-focus/focus.directive";
import * as i6 from "@spartacus/core";
export class FacetListComponent {
    constructor(facetService, elementRef, renderer) {
        this.facetService = facetService;
        this.elementRef = elementRef;
        this.renderer = renderer;
        /** Emits when the list must close */
        this.closeList = new EventEmitter();
        /** The list of all facet and values related to the products in the list */
        this.facetList$ = this.facetService.facetList$;
        this.iconTypes = ICON_TYPE;
        this.dialogFocusConfig = {
            trap: true,
            block: true,
            focusOnEscape: true,
            autofocus: 'cx-facet',
        };
    }
    /**
     * Indicates that the facet navigation is rendered in dialog.
     */
    set isDialog(value) {
        this._isDialog = value;
        if (value) {
            this.renderer.addClass(document.body, 'modal-open');
        }
    }
    get isDialog() {
        return this._isDialog;
    }
    handleClick() {
        this.close();
    }
    /**
     * Toggles the facet group in case it is not expanded.
     */
    expandFacetGroup(facet, ref) {
        if (!ref.isExpanded) {
            this.facetService.toggle(facet, ref.isExpanded);
        }
    }
    /**
     * Indicates that the facet group has been expanded.
     */
    isExpanded(facet) {
        return this.facetService
            .getState(facet)
            .pipe(map((value) => value.toggled === FacetGroupCollapsedState.EXPANDED));
    }
    /**
     * Indicates that the facet group has been collapsed.
     */
    isCollapsed(facet) {
        return this.facetService
            .getState(facet)
            .pipe(map((value) => value.toggled === FacetGroupCollapsedState.COLLAPSED));
    }
    close(event) {
        this.renderer.removeClass(document.body, 'modal-open');
        this.closeList.emit(event);
    }
    block(event) {
        event.stopPropagation();
    }
}
FacetListComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: FacetListComponent, deps: [{ token: i1.FacetService }, { token: i0.ElementRef }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component });
FacetListComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: FacetListComponent, selector: "cx-facet-list", inputs: { isDialog: "isDialog" }, outputs: { closeList: "closeList" }, host: { listeners: { "click": "handleClick()" } }, ngImport: i0, template: "<div\n  class=\"inner\"\n  *ngIf=\"(facetList$ | async)?.facets as facets\"\n  [cxFocus]=\"isDialog ? dialogFocusConfig : {}\"\n  (esc)=\"close($event)\"\n  (click)=\"block($event)\"\n>\n  <h4>\n    {{ 'productList.filterBy.label' | cxTranslate }}\n    <button\n      type=\"button\"\n      class=\"close\"\n      [attr.aria-label]=\"'common.close' | cxTranslate\"\n      (click)=\"close()\"\n    >\n      <cx-icon aria-hidden=\"true\" [type]=\"iconTypes.CLOSE\"></cx-icon>\n    </button>\n  </h4>\n\n  <!-- \n      Here we'd like to introduce configurable facet components, \n      either by using specific configuration or generic sproutlets \n  -->\n  <cx-facet\n    *ngFor=\"let facet of facets\"\n    #facetRef\n    [facet]=\"facet\"\n    [cxFocus]=\"{ lock: true, trap: true, autofocus: 'a' }\"\n    (unlock)=\"expandFacetGroup(facet, facetRef)\"\n    [class.expanded]=\"isExpanded(facet) | async\"\n    [class.collapsed]=\"isCollapsed(facet) | async\"\n  ></cx-facet>\n</div>\n", components: [{ type: i2.IconComponent, selector: "cx-icon,[cxIcon]", inputs: ["cxIcon", "type"] }, { type: i3.FacetComponent, selector: "cx-facet", inputs: ["expandIcon", "collapseIcon", "facet"] }], directives: [{ type: i4.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i5.FocusDirective, selector: "[cxFocus]", inputs: ["cxFocus"] }, { type: i4.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], pipes: { "async": i4.AsyncPipe, "cxTranslate": i6.TranslatePipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: FacetListComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-facet-list',
                    templateUrl: './facet-list.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: i1.FacetService }, { type: i0.ElementRef }, { type: i0.Renderer2 }]; }, propDecorators: { isDialog: [{
                type: Input
            }], closeList: [{
                type: Output
            }], handleClick: [{
                type: HostListener,
                args: ['click']
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmFjZXQtbGlzdC5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9zdG9yZWZyb250bGliL2Ntcy1jb21wb25lbnRzL3Byb2R1Y3QvcHJvZHVjdC1saXN0L3Byb2R1Y3QtZmFjZXQtbmF2aWdhdGlvbi9mYWNldC1saXN0L2ZhY2V0LWxpc3QuY29tcG9uZW50LnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvc3RvcmVmcm9udGxpYi9jbXMtY29tcG9uZW50cy9wcm9kdWN0L3Byb2R1Y3QtbGlzdC9wcm9kdWN0LWZhY2V0LW5hdmlnYXRpb24vZmFjZXQtbGlzdC9mYWNldC1saXN0LmNvbXBvbmVudC5odG1sIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDTCx1QkFBdUIsRUFDdkIsU0FBUyxFQUVULFlBQVksRUFDWixZQUFZLEVBQ1osS0FBSyxFQUNMLE1BQU0sR0FFUCxNQUFNLGVBQWUsQ0FBQztBQUd2QixPQUFPLEVBQUUsR0FBRyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFFckMsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGtDQUFrQyxDQUFDO0FBQzdELE9BQU8sRUFBRSx3QkFBd0IsRUFBYSxNQUFNLGdCQUFnQixDQUFDOzs7Ozs7OztBQVNyRSxNQUFNLE9BQU8sa0JBQWtCO0lBb0M3QixZQUNZLFlBQTBCLEVBQzFCLFVBQXNCLEVBQ3RCLFFBQW1CO1FBRm5CLGlCQUFZLEdBQVosWUFBWSxDQUFjO1FBQzFCLGVBQVUsR0FBVixVQUFVLENBQVk7UUFDdEIsYUFBUSxHQUFSLFFBQVEsQ0FBVztRQXRCL0IscUNBQXFDO1FBQzNCLGNBQVMsR0FBRyxJQUFJLFlBQVksRUFBRSxDQUFDO1FBRXpDLDJFQUEyRTtRQUMzRSxlQUFVLEdBQTBCLElBQUksQ0FBQyxZQUFZLENBQUMsVUFBVSxDQUFDO1FBRWpFLGNBQVMsR0FBRyxTQUFTLENBQUM7UUFFdEIsc0JBQWlCLEdBQWdCO1lBQy9CLElBQUksRUFBRSxJQUFJO1lBQ1YsS0FBSyxFQUFFLElBQUk7WUFDWCxhQUFhLEVBQUUsSUFBSTtZQUNuQixTQUFTLEVBQUUsVUFBVTtTQUN0QixDQUFDO0lBVUMsQ0FBQztJQXRDSjs7T0FFRztJQUNILElBQ0ksUUFBUSxDQUFDLEtBQWM7UUFDekIsSUFBSSxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUM7UUFDdkIsSUFBSSxLQUFLLEVBQUU7WUFDVCxJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLFlBQVksQ0FBQyxDQUFDO1NBQ3JEO0lBQ0gsQ0FBQztJQUVELElBQUksUUFBUTtRQUNWLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQztJQUN4QixDQUFDO0lBaUJzQixXQUFXO1FBQ2hDLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQztJQUNmLENBQUM7SUFRRDs7T0FFRztJQUNILGdCQUFnQixDQUFDLEtBQVksRUFBRSxHQUFtQjtRQUNoRCxJQUFJLENBQUMsR0FBRyxDQUFDLFVBQVUsRUFBRTtZQUNuQixJQUFJLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQyxLQUFLLEVBQUUsR0FBRyxDQUFDLFVBQVUsQ0FBQyxDQUFDO1NBQ2pEO0lBQ0gsQ0FBQztJQUVEOztPQUVHO0lBQ0gsVUFBVSxDQUFDLEtBQVk7UUFDckIsT0FBTyxJQUFJLENBQUMsWUFBWTthQUNyQixRQUFRLENBQUMsS0FBSyxDQUFDO2FBQ2YsSUFBSSxDQUNILEdBQUcsQ0FBQyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsS0FBSyxDQUFDLE9BQU8sS0FBSyx3QkFBd0IsQ0FBQyxRQUFRLENBQUMsQ0FDcEUsQ0FBQztJQUNOLENBQUM7SUFFRDs7T0FFRztJQUNILFdBQVcsQ0FBQyxLQUFZO1FBQ3RCLE9BQU8sSUFBSSxDQUFDLFlBQVk7YUFDckIsUUFBUSxDQUFDLEtBQUssQ0FBQzthQUNmLElBQUksQ0FDSCxHQUFHLENBQUMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLEtBQUssQ0FBQyxPQUFPLEtBQUssd0JBQXdCLENBQUMsU0FBUyxDQUFDLENBQ3JFLENBQUM7SUFDTixDQUFDO0lBRUQsS0FBSyxDQUFDLEtBQWU7UUFDbkIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxZQUFZLENBQUMsQ0FBQztRQUN2RCxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUM3QixDQUFDO0lBRUQsS0FBSyxDQUFDLEtBQWtCO1FBQ3RCLEtBQUssQ0FBQyxlQUFlLEVBQUUsQ0FBQztJQUMxQixDQUFDOzsrR0FoRlUsa0JBQWtCO21HQUFsQixrQkFBa0IsK0tDeEIvQiwwOUJBaUNBOzJGRFRhLGtCQUFrQjtrQkFMOUIsU0FBUzttQkFBQztvQkFDVCxRQUFRLEVBQUUsZUFBZTtvQkFDekIsV0FBVyxFQUFFLDZCQUE2QjtvQkFDMUMsZUFBZSxFQUFFLHVCQUF1QixDQUFDLE1BQU07aUJBQ2hEO29KQU9LLFFBQVE7c0JBRFgsS0FBSztnQkFhSSxTQUFTO3NCQUFsQixNQUFNO2dCQWNnQixXQUFXO3NCQUFqQyxZQUFZO3VCQUFDLE9BQU8iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgQ29tcG9uZW50LFxuICBFbGVtZW50UmVmLFxuICBFdmVudEVtaXR0ZXIsXG4gIEhvc3RMaXN0ZW5lcixcbiAgSW5wdXQsXG4gIE91dHB1dCxcbiAgUmVuZGVyZXIyLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEZhY2V0IH0gZnJvbSAnQHNwYXJ0YWN1cy9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IG1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IEZvY3VzQ29uZmlnIH0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vbGF5b3V0L2ExMXkva2V5Ym9hcmQtZm9jdXMvaW5kZXgnO1xuaW1wb3J0IHsgSUNPTl9UWVBFIH0gZnJvbSAnLi4vLi4vLi4vLi4vbWlzYy9pY29uL2ljb24ubW9kZWwnO1xuaW1wb3J0IHsgRmFjZXRHcm91cENvbGxhcHNlZFN0YXRlLCBGYWNldExpc3QgfSBmcm9tICcuLi9mYWNldC5tb2RlbCc7XG5pbXBvcnQgeyBGYWNldENvbXBvbmVudCB9IGZyb20gJy4uL2ZhY2V0L2ZhY2V0LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBGYWNldFNlcnZpY2UgfSBmcm9tICcuLi9zZXJ2aWNlcy9mYWNldC5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY3gtZmFjZXQtbGlzdCcsXG4gIHRlbXBsYXRlVXJsOiAnLi9mYWNldC1saXN0LmNvbXBvbmVudC5odG1sJyxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG59KVxuZXhwb3J0IGNsYXNzIEZhY2V0TGlzdENvbXBvbmVudCB7XG4gIHByaXZhdGUgX2lzRGlhbG9nOiBib29sZWFuO1xuICAvKipcbiAgICogSW5kaWNhdGVzIHRoYXQgdGhlIGZhY2V0IG5hdmlnYXRpb24gaXMgcmVuZGVyZWQgaW4gZGlhbG9nLlxuICAgKi9cbiAgQElucHV0KClcbiAgc2V0IGlzRGlhbG9nKHZhbHVlOiBib29sZWFuKSB7XG4gICAgdGhpcy5faXNEaWFsb2cgPSB2YWx1ZTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3MoZG9jdW1lbnQuYm9keSwgJ21vZGFsLW9wZW4nKTtcbiAgICB9XG4gIH1cblxuICBnZXQgaXNEaWFsb2coKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX2lzRGlhbG9nO1xuICB9XG5cbiAgLyoqIEVtaXRzIHdoZW4gdGhlIGxpc3QgbXVzdCBjbG9zZSAqL1xuICBAT3V0cHV0KCkgY2xvc2VMaXN0ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gIC8qKiBUaGUgbGlzdCBvZiBhbGwgZmFjZXQgYW5kIHZhbHVlcyByZWxhdGVkIHRvIHRoZSBwcm9kdWN0cyBpbiB0aGUgbGlzdCAqL1xuICBmYWNldExpc3QkOiBPYnNlcnZhYmxlPEZhY2V0TGlzdD4gPSB0aGlzLmZhY2V0U2VydmljZS5mYWNldExpc3QkO1xuXG4gIGljb25UeXBlcyA9IElDT05fVFlQRTtcblxuICBkaWFsb2dGb2N1c0NvbmZpZzogRm9jdXNDb25maWcgPSB7XG4gICAgdHJhcDogdHJ1ZSxcbiAgICBibG9jazogdHJ1ZSxcbiAgICBmb2N1c09uRXNjYXBlOiB0cnVlLFxuICAgIGF1dG9mb2N1czogJ2N4LWZhY2V0JyxcbiAgfTtcblxuICBASG9zdExpc3RlbmVyKCdjbGljaycpIGhhbmRsZUNsaWNrKCkge1xuICAgIHRoaXMuY2xvc2UoKTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByb3RlY3RlZCBmYWNldFNlcnZpY2U6IEZhY2V0U2VydmljZSxcbiAgICBwcm90ZWN0ZWQgZWxlbWVudFJlZjogRWxlbWVudFJlZixcbiAgICBwcm90ZWN0ZWQgcmVuZGVyZXI6IFJlbmRlcmVyMlxuICApIHt9XG5cbiAgLyoqXG4gICAqIFRvZ2dsZXMgdGhlIGZhY2V0IGdyb3VwIGluIGNhc2UgaXQgaXMgbm90IGV4cGFuZGVkLlxuICAgKi9cbiAgZXhwYW5kRmFjZXRHcm91cChmYWNldDogRmFjZXQsIHJlZjogRmFjZXRDb21wb25lbnQpIHtcbiAgICBpZiAoIXJlZi5pc0V4cGFuZGVkKSB7XG4gICAgICB0aGlzLmZhY2V0U2VydmljZS50b2dnbGUoZmFjZXQsIHJlZi5pc0V4cGFuZGVkKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW5kaWNhdGVzIHRoYXQgdGhlIGZhY2V0IGdyb3VwIGhhcyBiZWVuIGV4cGFuZGVkLlxuICAgKi9cbiAgaXNFeHBhbmRlZChmYWNldDogRmFjZXQpOiBPYnNlcnZhYmxlPGJvb2xlYW4+IHtcbiAgICByZXR1cm4gdGhpcy5mYWNldFNlcnZpY2VcbiAgICAgIC5nZXRTdGF0ZShmYWNldClcbiAgICAgIC5waXBlKFxuICAgICAgICBtYXAoKHZhbHVlKSA9PiB2YWx1ZS50b2dnbGVkID09PSBGYWNldEdyb3VwQ29sbGFwc2VkU3RhdGUuRVhQQU5ERUQpXG4gICAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEluZGljYXRlcyB0aGF0IHRoZSBmYWNldCBncm91cCBoYXMgYmVlbiBjb2xsYXBzZWQuXG4gICAqL1xuICBpc0NvbGxhcHNlZChmYWNldDogRmFjZXQpOiBPYnNlcnZhYmxlPGJvb2xlYW4+IHtcbiAgICByZXR1cm4gdGhpcy5mYWNldFNlcnZpY2VcbiAgICAgIC5nZXRTdGF0ZShmYWNldClcbiAgICAgIC5waXBlKFxuICAgICAgICBtYXAoKHZhbHVlKSA9PiB2YWx1ZS50b2dnbGVkID09PSBGYWNldEdyb3VwQ29sbGFwc2VkU3RhdGUuQ09MTEFQU0VEKVxuICAgICAgKTtcbiAgfVxuXG4gIGNsb3NlKGV2ZW50PzogYm9vbGVhbik6IHZvaWQge1xuICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQ2xhc3MoZG9jdW1lbnQuYm9keSwgJ21vZGFsLW9wZW4nKTtcbiAgICB0aGlzLmNsb3NlTGlzdC5lbWl0KGV2ZW50KTtcbiAgfVxuXG4gIGJsb2NrKGV2ZW50PzogTW91c2VFdmVudCkge1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICB9XG59XG4iLCI8ZGl2XG4gIGNsYXNzPVwiaW5uZXJcIlxuICAqbmdJZj1cIihmYWNldExpc3QkIHwgYXN5bmMpPy5mYWNldHMgYXMgZmFjZXRzXCJcbiAgW2N4Rm9jdXNdPVwiaXNEaWFsb2cgPyBkaWFsb2dGb2N1c0NvbmZpZyA6IHt9XCJcbiAgKGVzYyk9XCJjbG9zZSgkZXZlbnQpXCJcbiAgKGNsaWNrKT1cImJsb2NrKCRldmVudClcIlxuPlxuICA8aDQ+XG4gICAge3sgJ3Byb2R1Y3RMaXN0LmZpbHRlckJ5LmxhYmVsJyB8IGN4VHJhbnNsYXRlIH19XG4gICAgPGJ1dHRvblxuICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICBjbGFzcz1cImNsb3NlXCJcbiAgICAgIFthdHRyLmFyaWEtbGFiZWxdPVwiJ2NvbW1vbi5jbG9zZScgfCBjeFRyYW5zbGF0ZVwiXG4gICAgICAoY2xpY2spPVwiY2xvc2UoKVwiXG4gICAgPlxuICAgICAgPGN4LWljb24gYXJpYS1oaWRkZW49XCJ0cnVlXCIgW3R5cGVdPVwiaWNvblR5cGVzLkNMT1NFXCI+PC9jeC1pY29uPlxuICAgIDwvYnV0dG9uPlxuICA8L2g0PlxuXG4gIDwhLS0gXG4gICAgICBIZXJlIHdlJ2QgbGlrZSB0byBpbnRyb2R1Y2UgY29uZmlndXJhYmxlIGZhY2V0IGNvbXBvbmVudHMsIFxuICAgICAgZWl0aGVyIGJ5IHVzaW5nIHNwZWNpZmljIGNvbmZpZ3VyYXRpb24gb3IgZ2VuZXJpYyBzcHJvdXRsZXRzIFxuICAtLT5cbiAgPGN4LWZhY2V0XG4gICAgKm5nRm9yPVwibGV0IGZhY2V0IG9mIGZhY2V0c1wiXG4gICAgI2ZhY2V0UmVmXG4gICAgW2ZhY2V0XT1cImZhY2V0XCJcbiAgICBbY3hGb2N1c109XCJ7IGxvY2s6IHRydWUsIHRyYXA6IHRydWUsIGF1dG9mb2N1czogJ2EnIH1cIlxuICAgICh1bmxvY2spPVwiZXhwYW5kRmFjZXRHcm91cChmYWNldCwgZmFjZXRSZWYpXCJcbiAgICBbY2xhc3MuZXhwYW5kZWRdPVwiaXNFeHBhbmRlZChmYWNldCkgfCBhc3luY1wiXG4gICAgW2NsYXNzLmNvbGxhcHNlZF09XCJpc0NvbGxhcHNlZChmYWNldCkgfCBhc3luY1wiXG4gID48L2N4LWZhY2V0PlxuPC9kaXY+XG4iXX0=