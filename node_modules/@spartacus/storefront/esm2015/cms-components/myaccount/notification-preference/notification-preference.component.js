import { Component, ChangeDetectionStrategy } from '@angular/core';
import { combineLatest } from 'rxjs';
import { map, tap } from 'rxjs/operators';
import * as i0 from "@angular/core";
import * as i1 from "@spartacus/core";
import * as i2 from "../../../shared/components/spinner/spinner.component";
import * as i3 from "@angular/common";
export class NotificationPreferenceComponent {
    constructor(notificationPreferenceService) {
        this.notificationPreferenceService = notificationPreferenceService;
        this.preferences = [];
    }
    ngOnInit() {
        this.notificationPreferenceService.resetNotificationPreferences();
        this.preferences$ = this.notificationPreferenceService
            .getPreferences()
            .pipe(tap((preferences) => (this.preferences = preferences)));
        this.notificationPreferenceService.loadPreferences();
        this.isLoading$ = combineLatest([
            this.notificationPreferenceService.getPreferencesLoading(),
            this.notificationPreferenceService.getUpdatePreferencesResultLoading(),
        ]).pipe(map(([prefsLoading, updateLoading]) => prefsLoading || updateLoading));
    }
    updatePreference(preference) {
        const updatedPreferences = [];
        this.preferences.forEach((p) => {
            if (p.channel === preference.channel) {
                updatedPreferences.push(Object.assign(Object.assign({}, p), { enabled: !p.enabled }));
            }
            else {
                updatedPreferences.push(p);
            }
        });
        this.notificationPreferenceService.updatePreferences(updatedPreferences);
    }
}
NotificationPreferenceComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: NotificationPreferenceComponent, deps: [{ token: i1.UserNotificationPreferenceService }], target: i0.ɵɵFactoryTarget.Component });
NotificationPreferenceComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: NotificationPreferenceComponent, selector: "cx-notification-preference", ngImport: i0, template: "<ng-container *ngIf=\"preferences$ | async as preferences\">\n  <div *ngIf=\"preferences.length > 0; else loading\">\n    <div class=\"row d-flex justify-content-center\">\n      <div class=\"col-md-8\">\n        <div class=\"pref-header\">\n          {{ 'notificationPreference.message' | cxTranslate }}\n        </div>\n        <div class=\"form-check cx-notification-channels\">\n          <ng-container *ngFor=\"let preference of preferences\">\n            <label *ngIf=\"preference.visible\" class=\"pref-channel\">\n              <input\n                class=\"form-check-input cx-np-checkbox\"\n                role=\"checkbox\"\n                type=\"checkbox\"\n                [checked]=\"preference.enabled\"\n                (change)=\"updatePreference(preference)\"\n                [disabled]=\"isLoading$ | async\"\n              />\n              <span class=\"form-check-label\">\n                {{\n                  'notificationPreference.' + preference.channel | cxTranslate\n                }}\n                {{ preference.value }}\n              </span>\n            </label>\n          </ng-container>\n        </div>\n        <label class=\"pref-note\"\n          ><strong>{{ 'notificationPreference.note' | cxTranslate }}</strong\n          >{{ 'notificationPreference.noteMessage' | cxTranslate }}\n        </label>\n      </div>\n    </div>\n  </div>\n\n  <ng-template #loading>\n    <div class=\"cx-spinner\">\n      <cx-spinner></cx-spinner>\n    </div>\n  </ng-template>\n</ng-container>\n", components: [{ type: i2.SpinnerComponent, selector: "cx-spinner" }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], pipes: { "async": i3.AsyncPipe, "cxTranslate": i1.TranslatePipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: NotificationPreferenceComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-notification-preference',
                    templateUrl: './notification-preference.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: i1.UserNotificationPreferenceService }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm90aWZpY2F0aW9uLXByZWZlcmVuY2UuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvc3RvcmVmcm9udGxpYi9jbXMtY29tcG9uZW50cy9teWFjY291bnQvbm90aWZpY2F0aW9uLXByZWZlcmVuY2Uvbm90aWZpY2F0aW9uLXByZWZlcmVuY2UuY29tcG9uZW50LnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvc3RvcmVmcm9udGxpYi9jbXMtY29tcG9uZW50cy9teWFjY291bnQvbm90aWZpY2F0aW9uLXByZWZlcmVuY2Uvbm90aWZpY2F0aW9uLXByZWZlcmVuY2UuY29tcG9uZW50Lmh0bWwiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFNBQVMsRUFBVSx1QkFBdUIsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUszRSxPQUFPLEVBQWMsYUFBYSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQ2pELE9BQU8sRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7Ozs7O0FBTzFDLE1BQU0sT0FBTywrQkFBK0I7SUFNMUMsWUFDVSw2QkFBZ0U7UUFBaEUsa0NBQTZCLEdBQTdCLDZCQUE2QixDQUFtQztRQUhoRSxnQkFBVyxHQUE2QixFQUFFLENBQUM7SUFJbEQsQ0FBQztJQUVKLFFBQVE7UUFDTixJQUFJLENBQUMsNkJBQTZCLENBQUMsNEJBQTRCLEVBQUUsQ0FBQztRQUNsRSxJQUFJLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQyw2QkFBNkI7YUFDbkQsY0FBYyxFQUFFO2FBQ2hCLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxXQUFXLEVBQUUsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLFdBQVcsR0FBRyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDaEUsSUFBSSxDQUFDLDZCQUE2QixDQUFDLGVBQWUsRUFBRSxDQUFDO1FBRXJELElBQUksQ0FBQyxVQUFVLEdBQUcsYUFBYSxDQUFDO1lBQzlCLElBQUksQ0FBQyw2QkFBNkIsQ0FBQyxxQkFBcUIsRUFBRTtZQUMxRCxJQUFJLENBQUMsNkJBQTZCLENBQUMsaUNBQWlDLEVBQUU7U0FDdkUsQ0FBQyxDQUFDLElBQUksQ0FDTCxHQUFHLENBQUMsQ0FBQyxDQUFDLFlBQVksRUFBRSxhQUFhLENBQUMsRUFBRSxFQUFFLENBQUMsWUFBWSxJQUFJLGFBQWEsQ0FBQyxDQUN0RSxDQUFDO0lBQ0osQ0FBQztJQUVELGdCQUFnQixDQUFDLFVBQWtDO1FBQ2pELE1BQU0sa0JBQWtCLEdBQUcsRUFBRSxDQUFDO1FBQzlCLElBQUksQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUU7WUFDN0IsSUFBSSxDQUFDLENBQUMsT0FBTyxLQUFLLFVBQVUsQ0FBQyxPQUFPLEVBQUU7Z0JBQ3BDLGtCQUFrQixDQUFDLElBQUksaUNBQ2xCLENBQUMsS0FDSixPQUFPLEVBQUUsQ0FBQyxDQUFDLENBQUMsT0FBTyxJQUNuQixDQUFDO2FBQ0o7aUJBQU07Z0JBQ0wsa0JBQWtCLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO2FBQzVCO1FBQ0gsQ0FBQyxDQUFDLENBQUM7UUFDSCxJQUFJLENBQUMsNkJBQTZCLENBQUMsaUJBQWlCLENBQUMsa0JBQWtCLENBQUMsQ0FBQztJQUMzRSxDQUFDOzs0SEF0Q1UsK0JBQStCO2dIQUEvQiwrQkFBK0Isa0VDYjVDLHcvQ0F5Q0E7MkZENUJhLCtCQUErQjtrQkFMM0MsU0FBUzttQkFBQztvQkFDVCxRQUFRLEVBQUUsNEJBQTRCO29CQUN0QyxXQUFXLEVBQUUsMENBQTBDO29CQUN2RCxlQUFlLEVBQUUsdUJBQXVCLENBQUMsTUFBTTtpQkFDaEQiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQsIE9uSW5pdCwgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7XG4gIE5vdGlmaWNhdGlvblByZWZlcmVuY2UsXG4gIFVzZXJOb3RpZmljYXRpb25QcmVmZXJlbmNlU2VydmljZSxcbn0gZnJvbSAnQHNwYXJ0YWN1cy9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUsIGNvbWJpbmVMYXRlc3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IG1hcCwgdGFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjeC1ub3RpZmljYXRpb24tcHJlZmVyZW5jZScsXG4gIHRlbXBsYXRlVXJsOiAnLi9ub3RpZmljYXRpb24tcHJlZmVyZW5jZS5jb21wb25lbnQuaHRtbCcsXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxufSlcbmV4cG9ydCBjbGFzcyBOb3RpZmljYXRpb25QcmVmZXJlbmNlQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0IHtcbiAgcHJlZmVyZW5jZXMkOiBPYnNlcnZhYmxlPE5vdGlmaWNhdGlvblByZWZlcmVuY2VbXT47XG4gIGlzTG9hZGluZyQ6IE9ic2VydmFibGU8Ym9vbGVhbj47XG5cbiAgcHJvdGVjdGVkIHByZWZlcmVuY2VzOiBOb3RpZmljYXRpb25QcmVmZXJlbmNlW10gPSBbXTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIG5vdGlmaWNhdGlvblByZWZlcmVuY2VTZXJ2aWNlOiBVc2VyTm90aWZpY2F0aW9uUHJlZmVyZW5jZVNlcnZpY2VcbiAgKSB7fVxuXG4gIG5nT25Jbml0KCkge1xuICAgIHRoaXMubm90aWZpY2F0aW9uUHJlZmVyZW5jZVNlcnZpY2UucmVzZXROb3RpZmljYXRpb25QcmVmZXJlbmNlcygpO1xuICAgIHRoaXMucHJlZmVyZW5jZXMkID0gdGhpcy5ub3RpZmljYXRpb25QcmVmZXJlbmNlU2VydmljZVxuICAgICAgLmdldFByZWZlcmVuY2VzKClcbiAgICAgIC5waXBlKHRhcCgocHJlZmVyZW5jZXMpID0+ICh0aGlzLnByZWZlcmVuY2VzID0gcHJlZmVyZW5jZXMpKSk7XG4gICAgdGhpcy5ub3RpZmljYXRpb25QcmVmZXJlbmNlU2VydmljZS5sb2FkUHJlZmVyZW5jZXMoKTtcblxuICAgIHRoaXMuaXNMb2FkaW5nJCA9IGNvbWJpbmVMYXRlc3QoW1xuICAgICAgdGhpcy5ub3RpZmljYXRpb25QcmVmZXJlbmNlU2VydmljZS5nZXRQcmVmZXJlbmNlc0xvYWRpbmcoKSxcbiAgICAgIHRoaXMubm90aWZpY2F0aW9uUHJlZmVyZW5jZVNlcnZpY2UuZ2V0VXBkYXRlUHJlZmVyZW5jZXNSZXN1bHRMb2FkaW5nKCksXG4gICAgXSkucGlwZShcbiAgICAgIG1hcCgoW3ByZWZzTG9hZGluZywgdXBkYXRlTG9hZGluZ10pID0+IHByZWZzTG9hZGluZyB8fCB1cGRhdGVMb2FkaW5nKVxuICAgICk7XG4gIH1cblxuICB1cGRhdGVQcmVmZXJlbmNlKHByZWZlcmVuY2U6IE5vdGlmaWNhdGlvblByZWZlcmVuY2UpIHtcbiAgICBjb25zdCB1cGRhdGVkUHJlZmVyZW5jZXMgPSBbXTtcbiAgICB0aGlzLnByZWZlcmVuY2VzLmZvckVhY2goKHApID0+IHtcbiAgICAgIGlmIChwLmNoYW5uZWwgPT09IHByZWZlcmVuY2UuY2hhbm5lbCkge1xuICAgICAgICB1cGRhdGVkUHJlZmVyZW5jZXMucHVzaCh7XG4gICAgICAgICAgLi4ucCxcbiAgICAgICAgICBlbmFibGVkOiAhcC5lbmFibGVkLFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVwZGF0ZWRQcmVmZXJlbmNlcy5wdXNoKHApO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMubm90aWZpY2F0aW9uUHJlZmVyZW5jZVNlcnZpY2UudXBkYXRlUHJlZmVyZW5jZXModXBkYXRlZFByZWZlcmVuY2VzKTtcbiAgfVxufVxuIiwiPG5nLWNvbnRhaW5lciAqbmdJZj1cInByZWZlcmVuY2VzJCB8IGFzeW5jIGFzIHByZWZlcmVuY2VzXCI+XG4gIDxkaXYgKm5nSWY9XCJwcmVmZXJlbmNlcy5sZW5ndGggPiAwOyBlbHNlIGxvYWRpbmdcIj5cbiAgICA8ZGl2IGNsYXNzPVwicm93IGQtZmxleCBqdXN0aWZ5LWNvbnRlbnQtY2VudGVyXCI+XG4gICAgICA8ZGl2IGNsYXNzPVwiY29sLW1kLThcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInByZWYtaGVhZGVyXCI+XG4gICAgICAgICAge3sgJ25vdGlmaWNhdGlvblByZWZlcmVuY2UubWVzc2FnZScgfCBjeFRyYW5zbGF0ZSB9fVxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImZvcm0tY2hlY2sgY3gtbm90aWZpY2F0aW9uLWNoYW5uZWxzXCI+XG4gICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdGb3I9XCJsZXQgcHJlZmVyZW5jZSBvZiBwcmVmZXJlbmNlc1wiPlxuICAgICAgICAgICAgPGxhYmVsICpuZ0lmPVwicHJlZmVyZW5jZS52aXNpYmxlXCIgY2xhc3M9XCJwcmVmLWNoYW5uZWxcIj5cbiAgICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgY2xhc3M9XCJmb3JtLWNoZWNrLWlucHV0IGN4LW5wLWNoZWNrYm94XCJcbiAgICAgICAgICAgICAgICByb2xlPVwiY2hlY2tib3hcIlxuICAgICAgICAgICAgICAgIHR5cGU9XCJjaGVja2JveFwiXG4gICAgICAgICAgICAgICAgW2NoZWNrZWRdPVwicHJlZmVyZW5jZS5lbmFibGVkXCJcbiAgICAgICAgICAgICAgICAoY2hhbmdlKT1cInVwZGF0ZVByZWZlcmVuY2UocHJlZmVyZW5jZSlcIlxuICAgICAgICAgICAgICAgIFtkaXNhYmxlZF09XCJpc0xvYWRpbmckIHwgYXN5bmNcIlxuICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImZvcm0tY2hlY2stbGFiZWxcIj5cbiAgICAgICAgICAgICAgICB7e1xuICAgICAgICAgICAgICAgICAgJ25vdGlmaWNhdGlvblByZWZlcmVuY2UuJyArIHByZWZlcmVuY2UuY2hhbm5lbCB8IGN4VHJhbnNsYXRlXG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICB7eyBwcmVmZXJlbmNlLnZhbHVlIH19XG4gICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgIDwvbGFiZWw+XG4gICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8bGFiZWwgY2xhc3M9XCJwcmVmLW5vdGVcIlxuICAgICAgICAgID48c3Ryb25nPnt7ICdub3RpZmljYXRpb25QcmVmZXJlbmNlLm5vdGUnIHwgY3hUcmFuc2xhdGUgfX08L3N0cm9uZ1xuICAgICAgICAgID57eyAnbm90aWZpY2F0aW9uUHJlZmVyZW5jZS5ub3RlTWVzc2FnZScgfCBjeFRyYW5zbGF0ZSB9fVxuICAgICAgICA8L2xhYmVsPlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gIDwvZGl2PlxuXG4gIDxuZy10ZW1wbGF0ZSAjbG9hZGluZz5cbiAgICA8ZGl2IGNsYXNzPVwiY3gtc3Bpbm5lclwiPlxuICAgICAgPGN4LXNwaW5uZXI+PC9jeC1zcGlubmVyPlxuICAgIDwvZGl2PlxuICA8L25nLXRlbXBsYXRlPlxuPC9uZy1jb250YWluZXI+XG4iXX0=