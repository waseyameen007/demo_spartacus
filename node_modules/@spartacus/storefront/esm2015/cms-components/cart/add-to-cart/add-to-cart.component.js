import { ChangeDetectionStrategy, Component, Input, Optional, } from '@angular/core';
import { FormControl, FormGroup } from '@angular/forms';
import { isNotNullable, } from '@spartacus/core';
import { filter, map, take } from 'rxjs/operators';
import { AddedToCartDialogComponent } from './added-to-cart-dialog/added-to-cart-dialog.component';
import * as i0 from "@angular/core";
import * as i1 from "../../../shared/components/modal/modal.service";
import * as i2 from "../../product/current-product.service";
import * as i3 from "@spartacus/core";
import * as i4 from "../../../cms-structure/page/model/cms-component-data";
import * as i5 from "../../../shared/components/item-counter/item-counter.component";
import * as i6 from "@angular/common";
import * as i7 from "@angular/forms";
export class AddToCartComponent {
    constructor(modalService, currentProductService, cd, activeCartService, component) {
        var _a;
        this.modalService = modalService;
        this.currentProductService = currentProductService;
        this.cd = cd;
        this.activeCartService = activeCartService;
        this.component = component;
        this.showQuantity = true;
        this.hasStock = false;
        this.inventoryThreshold = false;
        this.showInventory$ = (_a = this.component) === null || _a === void 0 ? void 0 : _a.data$.pipe(map((data) => data.inventoryDisplay));
        this.quantity = 1;
        this.numberOfEntriesBeforeAdd = 0;
        this.addToCartForm = new FormGroup({
            quantity: new FormControl(1, { updateOn: 'blur' }),
        });
    }
    ngOnInit() {
        var _a;
        if (this.product) {
            this.productCode = (_a = this.product.code) !== null && _a !== void 0 ? _a : '';
            this.setStockInfo(this.product);
            this.cd.markForCheck();
        }
        else if (this.productCode) {
            // force hasStock and quantity for the time being, as we do not have more info:
            this.quantity = 1;
            this.hasStock = true;
            this.cd.markForCheck();
        }
        else {
            this.subscription = this.currentProductService
                .getProduct()
                .pipe(filter(isNotNullable))
                .subscribe((product) => {
                var _a;
                this.productCode = (_a = product.code) !== null && _a !== void 0 ? _a : '';
                this.setStockInfo(product);
                this.cd.markForCheck();
            });
        }
    }
    setStockInfo(product) {
        var _a, _b, _c, _d;
        this.quantity = 1;
        this.hasStock = Boolean(((_a = product.stock) === null || _a === void 0 ? void 0 : _a.stockLevelStatus) !== 'outOfStock');
        this.inventoryThreshold = (_c = (_b = product.stock) === null || _b === void 0 ? void 0 : _b.isValueRounded) !== null && _c !== void 0 ? _c : false;
        if (this.hasStock && ((_d = product.stock) === null || _d === void 0 ? void 0 : _d.stockLevel)) {
            this.maxQuantity = product.stock.stockLevel;
        }
    }
    /**
     * In specific scenarios, we need to omit displaying the stock level or append a plus to the value.
     * When backoffice forces a product to be in stock, omit showing the stock level.
     * When product stock level is limited by a threshold value, append '+' at the end.
     * When out of stock, display no numerical value.
     */
    getInventory() {
        if (this.hasStock) {
            const quantityDisplay = this.maxQuantity
                ? this.maxQuantity.toString()
                : '';
            return this.inventoryThreshold ? quantityDisplay + '+' : quantityDisplay;
        }
        else {
            return '';
        }
    }
    updateCount(value) {
        this.quantity = value;
    }
    addToCart() {
        const quantity = this.addToCartForm.get('quantity').value;
        if (!this.productCode || quantity <= 0) {
            return;
        }
        this.activeCartService
            .getEntries()
            .pipe(take(1))
            .subscribe((entries) => {
            this.numberOfEntriesBeforeAdd = entries.length;
            this.openModal();
            this.activeCartService.addEntry(this.productCode, quantity);
        });
    }
    /**
     * Provides required data and opens AddedToCartDialogComponent modal
     */
    openModal() {
        let modalInstance;
        this.modalRef = this.modalService.open(AddedToCartDialogComponent, {
            centered: true,
            size: 'lg',
        });
        modalInstance = this.modalRef.componentInstance;
        // Display last entry for new product code. This always corresponds to
        // our new item, independently of whether merging occured or not
        modalInstance.entry$ = this.activeCartService.getLastEntry(this.productCode);
        modalInstance.cart$ = this.activeCartService.getActive();
        modalInstance.loaded$ = this.activeCartService.isStable();
        modalInstance.quantity = this.quantity;
        modalInstance.numberOfEntriesBeforeAdd = this.numberOfEntriesBeforeAdd;
    }
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
    }
}
AddToCartComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AddToCartComponent, deps: [{ token: i1.ModalService }, { token: i2.CurrentProductService }, { token: i0.ChangeDetectorRef }, { token: i3.ActiveCartService }, { token: i4.CmsComponentData, optional: true }], target: i0.ɵɵFactoryTarget.Component });
AddToCartComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: AddToCartComponent, selector: "cx-add-to-cart", inputs: { productCode: "productCode", showQuantity: "showQuantity", product: "product" }, ngImport: i0, template: "<form *ngIf=\"productCode\" [formGroup]=\"addToCartForm\" (submit)=\"addToCart()\">\n  <div class=\"quantity\" *ngIf=\"showQuantity\">\n    <label>{{ 'addToCart.quantity' | cxTranslate }}</label>\n    <cx-item-counter\n      *ngIf=\"hasStock\"\n      [max]=\"maxQuantity\"\n      [control]=\"addToCartForm.get('quantity')\"\n    ></cx-item-counter>\n\n    <span class=\"info\">\n      <span *ngIf=\"showInventory$ | async\">{{ getInventory() }}</span>\n      {{\n        hasStock\n          ? ('addToCart.inStock' | cxTranslate)\n          : ('addToCart.outOfStock' | cxTranslate)\n      }}</span\n    >\n  </div>\n\n  <button\n    *ngIf=\"hasStock\"\n    class=\"btn btn-primary btn-block\"\n    type=\"submit\"\n    [disabled]=\"quantity <= 0 || quantity > maxQuantity\"\n  >\n    {{ 'addToCart.addToCart' | cxTranslate }}\n  </button>\n</form>\n", components: [{ type: i5.ItemCounterComponent, selector: "cx-item-counter", inputs: ["control", "min", "max", "step", "allowZero", "readonly"] }], directives: [{ type: i6.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i7.ɵNgNoValidate, selector: "form:not([ngNoForm]):not([ngNativeValidate])" }, { type: i7.NgControlStatusGroup, selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { type: i7.FormGroupDirective, selector: "[formGroup]", inputs: ["formGroup"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }], pipes: { "cxTranslate": i3.TranslatePipe, "async": i6.AsyncPipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AddToCartComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-add-to-cart',
                    templateUrl: './add-to-cart.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: i1.ModalService }, { type: i2.CurrentProductService }, { type: i0.ChangeDetectorRef }, { type: i3.ActiveCartService }, { type: i4.CmsComponentData, decorators: [{
                    type: Optional
                }] }]; }, propDecorators: { productCode: [{
                type: Input
            }], showQuantity: [{
                type: Input
            }], product: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWRkLXRvLWNhcnQuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvc3RvcmVmcm9udGxpYi9jbXMtY29tcG9uZW50cy9jYXJ0L2FkZC10by1jYXJ0L2FkZC10by1jYXJ0LmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL3N0b3JlZnJvbnRsaWIvY21zLWNvbXBvbmVudHMvY2FydC9hZGQtdG8tY2FydC9hZGQtdG8tY2FydC5jb21wb25lbnQuaHRtbCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ0wsdUJBQXVCLEVBRXZCLFNBQVMsRUFDVCxLQUFLLEVBR0wsUUFBUSxHQUNULE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxXQUFXLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDeEQsT0FBTyxFQUdMLGFBQWEsR0FFZCxNQUFNLGlCQUFpQixDQUFDO0FBRXpCLE9BQU8sRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLElBQUksRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBS25ELE9BQU8sRUFBRSwwQkFBMEIsRUFBRSxNQUFNLHVEQUF1RCxDQUFDOzs7Ozs7Ozs7QUFPbkcsTUFBTSxPQUFPLGtCQUFrQjtJQWdEN0IsWUFDWSxZQUEwQixFQUMxQixxQkFBNEMsRUFDNUMsRUFBcUIsRUFDckIsaUJBQW9DLEVBQ3hCLFNBQW1EOztRQUovRCxpQkFBWSxHQUFaLFlBQVksQ0FBYztRQUMxQiwwQkFBcUIsR0FBckIscUJBQXFCLENBQXVCO1FBQzVDLE9BQUUsR0FBRixFQUFFLENBQW1CO1FBQ3JCLHNCQUFpQixHQUFqQixpQkFBaUIsQ0FBbUI7UUFDeEIsY0FBUyxHQUFULFNBQVMsQ0FBMEM7UUFuRGxFLGlCQUFZLEdBQUcsSUFBSSxDQUFDO1FBVzdCLGFBQVEsR0FBWSxLQUFLLENBQUM7UUFDMUIsdUJBQWtCLEdBQVksS0FBSyxD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UUFDdkMsYUFBYSxDQUFDLHdCQUF3QixHQUFHLElBQUksQ0FBQyx3QkFBd0IsQ0FBQztJQUN6RSxDQUFDO0lBRUQsV0FBVztRQUNULElBQUksSUFBSSxDQUFDLFlBQVksRUFBRTtZQUNyQixJQUFJLENBQUMsWUFBWSxDQUFDLFdBQVcsRUFBRSxDQUFDO1NBQ2pDO0lBQ0gsQ0FBQzs7K0dBdkpVLGtCQUFrQjttR0FBbEIsa0JBQWtCLGdKQzdCL0IsazFCQTRCQTsyRkRDYSxrQkFBa0I7a0JBTDlCLFNBQVM7bUJBQUM7b0JBQ1QsUUFBUSxFQUFFLGdCQUFnQjtvQkFDMUIsV0FBVyxFQUFFLDhCQUE4QjtvQkFDM0MsZUFBZSxFQUFFLHVCQUF1QixDQUFDLE1BQU07aUJBQ2hEOzswQkFzREksUUFBUTs0Q0FwREYsV0FBVztzQkFBbkIsS0FBSztnQkFDRyxZQUFZO3NCQUFwQixLQUFLO2dCQU1HLE9BQU87c0JBQWYsS0FBSyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxuICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgQ29tcG9uZW50LFxuICBJbnB1dCxcbiAgT25EZXN0cm95LFxuICBPbkluaXQsXG4gIE9wdGlvbmFsLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEZvcm1Db250cm9sLCBGb3JtR3JvdXAgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQge1xuICBBY3RpdmVDYXJ0U2VydmljZSxcbiAgQ21zQWRkVG9DYXJ0Q29tcG9uZW50LFxuICBpc05vdE51bGxhYmxlLFxuICBQcm9kdWN0LFxufSBmcm9tICdAc3BhcnRhY3VzL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBmaWx0ZXIsIG1hcCwgdGFrZSB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IENtc0NvbXBvbmVudERhdGEgfSBmcm9tICcuLi8uLi8uLi9jbXMtc3RydWN0dXJlL3BhZ2UvbW9kZWwvY21zLWNvbXBvbmVudC1kYXRhJztcbmltcG9ydCB7IE1vZGFsUmVmIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2NvbXBvbmVudHMvbW9kYWwvbW9kYWwtcmVmJztcbmltcG9ydCB7IE1vZGFsU2VydmljZSB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb21wb25lbnRzL21vZGFsL21vZGFsLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ3VycmVudFByb2R1Y3RTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vcHJvZHVjdC9jdXJyZW50LXByb2R1Y3Quc2VydmljZSc7XG5pbXBvcnQgeyBBZGRlZFRvQ2FydERpYWxvZ0NvbXBvbmVudCB9IGZyb20gJy4vYWRkZWQtdG8tY2FydC1kaWFsb2cvYWRkZWQtdG8tY2FydC1kaWFsb2cuY29tcG9uZW50JztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY3gtYWRkLXRvLWNhcnQnLFxuICB0ZW1wbGF0ZVVybDogJy4vYWRkLXRvLWNhcnQuY29tcG9uZW50Lmh0bWwnLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbn0pXG5leHBvcnQgY2xhc3MgQWRkVG9DYXJ0Q29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3kge1xuICBASW5wdXQoKSBwcm9kdWN0Q29kZTogc3RyaW5nO1xuICBASW5wdXQoKSBzaG93UXVhbnRpdHkgPSB0cnVlO1xuXG4gIC8qKlxuICAgKiBBcyBsb25nIGFzIHdlIGRvIG5vdCBzdXBwb3J0ICM1MDI2LCB3ZSByZXF1aXJlIHByb2R1Y3QgaW5wdXQsIGFzIHdlIG5lZWRcbiAgICogIGEgcmVmZXJlbmNlIHRvIHRoZSBwcm9kdWN0IG1vZGVsIHRvIGZldGNoIHRoZSBzdG9jayBkYXRhLlxuICAgKi9cbiAgQElucHV0KCkgcHJvZHVjdDogUHJvZHVjdDtcblxuICBtYXhRdWFudGl0eTogbnVtYmVyO1xuICBtb2RhbFJlZjogTW9kYWxSZWY7XG5cbiAgaGFzU3RvY2s6IGJvb2xlYW4gPSBmYWxzZTtcbiAgaW52ZW50b3J5VGhyZXNob2xkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgc2hvd0ludmVudG9yeSQ6IE9ic2VydmFibGU8Ym9vbGVhbiB8IHVuZGVmaW5lZD4gfCB1bmRlZmluZWQgPVxuICAgIHRoaXMuY29tcG9uZW50Py5kYXRhJC5waXBlKG1hcCgoZGF0YSkgPT4gZGF0YS5pbnZlbnRvcnlEaXNwbGF5KSk7XG5cbiAgcXVhbnRpdHkgPSAxO1xuICBwcm90ZWN0ZWQgbnVtYmVyT2ZFbnRyaWVzQmVmb3JlQWRkID0gMDtcblxuICBzdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICBhZGRUb0NhcnRGb3JtID0gbmV3IEZvcm1Hcm91cCh7XG4gICAgcXVhbnRpdHk6IG5ldyBGb3JtQ29udHJvbCgxLCB7IHVwZGF0ZU9uOiAnYmx1cicgfSksXG4gIH0pO1xuXG4gIC8vIFRPRE8oIzEzMDQxKTogUmVtb3ZlIGRlcHJlY2F0ZWQgY29uc3RydWN0b3JzXG4gIGNvbnN0cnVjdG9yKFxuICAgIG1vZGFsU2VydmljZTogTW9kYWxTZXJ2aWNlLFxuICAgIGN1cnJlbnRQcm9kdWN0U2VydmljZTogQ3VycmVudFByb2R1Y3RTZXJ2aWNlLFxuICAgIGNkOiBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICBhY3RpdmVDYXJ0U2VydmljZTogQWN0aXZlQ2FydFNlcnZpY2UsXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC91bmlmaWVkLXNpZ25hdHVyZXNcbiAgICBjb21wb25lbnQ/OiBDbXNDb21wb25lbnREYXRhPENtc0FkZFRvQ2FydENvbXBvbmVudD5cbiAgKTtcblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgNC4xXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBtb2RhbFNlcnZpY2U6IE1vZGFsU2VydmljZSxcbiAgICBjdXJyZW50UHJvZHVjdFNlcnZpY2U6IEN1cnJlbnRQcm9kdWN0U2VydmljZSxcbiAgICBjZDogQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgYWN0aXZlQ2FydFNlcnZpY2U6IEFjdGl2ZUNhcnRTZXJ2aWNlXG4gICk7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJvdGVjdGVkIG1vZGFsU2VydmljZTogTW9kYWxTZXJ2aWNlLFxuICAgIHByb3RlY3RlZCBjdXJyZW50UHJvZHVjdFNlcnZpY2U6IEN1cnJlbnRQcm9kdWN0U2VydmljZSxcbiAgICBwcm90ZWN0ZWQgY2Q6IENoYW5nZURldGVjdG9yUmVmLFxuICAgIHByb3RlY3RlZCBhY3RpdmVDYXJ0U2VydmljZTogQWN0aXZlQ2FydFNlcnZpY2UsXG4gICAgQE9wdGlvbmFsKCkgcHJvdGVjdGVkIGNvbXBvbmVudD86IENtc0NvbXBvbmVudERhdGE8Q21zQWRkVG9DYXJ0Q29tcG9uZW50PlxuICApIHt9XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgaWYgKHRoaXMucHJvZHVjdCkge1xuICAgICAgdGhpcy5wcm9kdWN0Q29kZSA9IHRoaXMucHJvZHVjdC5jb2RlID8/ICcnO1xuICAgICAgdGhpcy5zZXRTdG9ja0luZm8odGhpcy5wcm9kdWN0KTtcbiAgICAgIHRoaXMuY2QubWFya0ZvckNoZWNrKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnByb2R1Y3RDb2RlKSB7XG4gICAgICAvLyBmb3JjZSBoYXNTdG9jayBhbmQgcXVhbnRpdHkgZm9yIHRoZSB0aW1lIGJlaW5nLCBhcyB3ZSBkbyBub3QgaGF2ZSBtb3JlIGluZm86XG4gICAgICB0aGlzLnF1YW50aXR5ID0gMTtcbiAgICAgIHRoaXMuaGFzU3RvY2sgPSB0cnVlO1xuICAgICAgdGhpcy5jZC5tYXJrRm9yQ2hlY2soKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdWJzY3JpcHRpb24gPSB0aGlzLmN1cnJlbnRQcm9kdWN0U2VydmljZVxuICAgICAgICAuZ2V0UHJvZHVjdCgpXG4gICAgICAgIC5waXBlKGZpbHRlcihpc05vdE51bGxhYmxlKSlcbiAgICAgICAgLnN1YnNjcmliZSgocHJvZHVjdCkgPT4ge1xuICAgICAgICAgIHRoaXMucHJvZHVjdENvZGUgPSBwcm9kdWN0LmNvZGUgPz8gJyc7XG4gICAgICAgICAgdGhpcy5zZXRTdG9ja0luZm8ocHJvZHVjdCk7XG4gICAgICAgICAgdGhpcy5jZC5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIHNldFN0b2NrSW5mbyhwcm9kdWN0OiBQcm9kdWN0KTogdm9pZCB7XG4gICAgdGhpcy5xdWFudGl0eSA9IDE7XG4gICAgdGhpcy5oYXNTdG9jayA9IEJvb2xlYW4ocHJvZHVjdC5zdG9jaz8uc3RvY2tMZXZlbFN0YXR1cyAhPT0gJ291dE9mU3RvY2snKTtcblxuICAgIHRoaXMuaW52ZW50b3J5VGhyZXNob2xkID0gcHJvZHVjdC5zdG9jaz8uaXNWYWx1ZVJvdW5kZWQgPz8gZmFsc2U7XG5cbiAgICBpZiAodGhpcy5oYXNTdG9jayAmJiBwcm9kdWN0LnN0b2NrPy5zdG9ja0xldmVsKSB7XG4gICAgICB0aGlzLm1heFF1YW50aXR5ID0gcHJvZHVjdC5zdG9jay5zdG9ja0xldmVsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbiBzcGVjaWZpYyBzY2VuYXJpb3MsIHdlIG5lZWQgdG8gb21pdCBkaXNwbGF5aW5nIHRoZSBzdG9jayBsZXZlbCBvciBhcHBlbmQgYSBwbHVzIHRvIHRoZSB2YWx1ZS5cbiAgICogV2hlbiBiYWNrb2ZmaWNlIGZvcmNlcyBhIHByb2R1Y3QgdG8gYmUgaW4gc3RvY2ssIG9taXQgc2hvd2luZyB0aGUgc3RvY2sgbGV2ZWwuXG4gICAqIFdoZW4gcHJvZHVjdCBzdG9jayBsZXZlbCBpcyBsaW1pdGVkIGJ5IGEgdGhyZXNob2xkIHZhbHVlLCBhcHBlbmQgJysnIGF0IHRoZSBlbmQuXG4gICAqIFdoZW4gb3V0IG9mIHN0b2NrLCBkaXNwbGF5IG5vIG51bWVyaWNhbCB2YWx1ZS5cbiAgICovXG4gIGdldEludmVudG9yeSgpOiBzdHJpbmcge1xuICAgIGlmICh0aGlzLmhhc1N0b2NrKSB7XG4gICAgICBjb25zdCBxdWFudGl0eURpc3BsYXkgPSB0aGlzLm1heFF1YW50aXR5XG4gICAgICAgID8gdGhpcy5tYXhRdWFudGl0eS50b1N0cmluZygpXG4gICAgICAgIDogJyc7XG4gICAgICByZXR1cm4gdGhpcy5pbnZlbnRvcnlUaHJlc2hvbGQgPyBxdWFudGl0eURpc3BsYXkgKyAnKycgOiBxdWFudGl0eURpc3BsYXk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gIH1cblxuICB1cGRhdGVDb3VudCh2YWx1ZTogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5xdWFudGl0eSA9IHZhbHVlO1xuICB9XG5cbiAgYWRkVG9DYXJ0KCkge1xuICAgIGNvbnN0IHF1YW50aXR5ID0gdGhpcy5hZGRUb0NhcnRGb3JtLmdldCgncXVhbnRpdHknKS52YWx1ZTtcbiAgICBpZiAoIXRoaXMucHJvZHVjdENvZGUgfHwgcXVhbnRpdHkgPD0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmFjdGl2ZUNhcnRTZXJ2aWNlXG4gICAgICAuZ2V0RW50cmllcygpXG4gICAgICAucGlwZSh0YWtlKDEpKVxuICAgICAgLnN1YnNjcmliZSgoZW50cmllcykgPT4ge1xuICAgICAgICB0aGlzLm51bWJlck9mRW50cmllc0JlZm9yZUFkZCA9IGVudHJpZXMubGVuZ3RoO1xuICAgICAgICB0aGlzLm9wZW5Nb2RhbCgpO1xuICAgICAgICB0aGlzLmFjdGl2ZUNhcnRTZXJ2aWNlLmFkZEVudHJ5KHRoaXMucHJvZHVjdENvZGUsIHF1YW50aXR5KTtcbiAgICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFByb3ZpZGVzIHJlcXVpcmVkIGRhdGEgYW5kIG9wZW5zIEFkZGVkVG9DYXJ0RGlhbG9nQ29tcG9uZW50IG1vZGFsXG4gICAqL1xuICBwcm90ZWN0ZWQgb3Blbk1vZGFsKCkge1xuICAgIGxldCBtb2RhbEluc3RhbmNlOiBhbnk7XG4gICAgdGhpcy5tb2RhbFJlZiA9IHRoaXMubW9kYWxTZXJ2aWNlLm9wZW4oQWRkZWRUb0NhcnREaWFsb2dDb21wb25lbnQsIHtcbiAgICAgIGNlbnRlcmVkOiB0cnVlLFxuICAgICAgc2l6ZTogJ2xnJyxcbiAgICB9KTtcblxuICAgIG1vZGFsSW5zdGFuY2UgPSB0aGlzLm1vZGFsUmVmLmNvbXBvbmVudEluc3RhbmNlO1xuICAgIC8vIERpc3BsYXkgbGFzdCBlbnRyeSBmb3IgbmV3IHByb2R1Y3QgY29kZS4gVGhpcyBhbHdheXMgY29ycmVzcG9uZHMgdG9cbiAgICAvLyBvdXIgbmV3IGl0ZW0sIGluZGVwZW5kZW50bHkgb2Ygd2hldGhlciBtZXJnaW5nIG9jY3VyZWQgb3Igbm90XG4gICAgbW9kYWxJbnN0YW5jZS5lbnRyeSQgPSB0aGlzLmFjdGl2ZUNhcnRTZXJ2aWNlLmdldExhc3RFbnRyeShcbiAgICAgIHRoaXMucHJvZHVjdENvZGVcbiAgICApO1xuICAgIG1vZGFsSW5zdGFuY2UuY2FydCQgPSB0aGlzLmFjdGl2ZUNhcnRTZXJ2aWNlLmdldEFjdGl2ZSgpO1xuICAgIG1vZGFsSW5zdGFuY2UubG9hZGVkJCA9IHRoaXMuYWN0aXZlQ2FydFNlcnZpY2UuaXNTdGFibGUoKTtcbiAgICBtb2RhbEluc3RhbmNlLnF1YW50aXR5ID0gdGhpcy5xdWFudGl0eTtcbiAgICBtb2RhbEluc3RhbmNlLm51bWJlck9mRW50cmllc0JlZm9yZUFkZCA9IHRoaXMubnVtYmVyT2ZFbnRyaWVzQmVmb3JlQWRkO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuc3Vic2NyaXB0aW9uKSB7XG4gICAgICB0aGlzLnN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgfVxufVxuIiwiPGZvcm0gKm5nSWY9XCJwcm9kdWN0Q29kZVwiIFtmb3JtR3JvdXBdPVwiYWRkVG9DYXJ0Rm9ybVwiIChzdWJtaXQpPVwiYWRkVG9DYXJ0KClcIj5cbiAgPGRpdiBjbGFzcz1cInF1YW50aXR5XCIgKm5nSWY9XCJzaG93UXVhbnRpdHlcIj5cbiAgICA8bGFiZWw+e3sgJ2FkZFRvQ2FydC5xdWFudGl0eScgfCBjeFRyYW5zbGF0ZSB9fTwvbGFiZWw+XG4gICAgPGN4LWl0ZW0tY291bnRlclxuICAgICAgKm5nSWY9XCJoYXNTdG9ja1wiXG4gICAgICBbbWF4XT1cIm1heFF1YW50aXR5XCJcbiAgICAgIFtjb250cm9sXT1cImFkZFRvQ2FydEZvcm0uZ2V0KCdxdWFudGl0eScpXCJcbiAgICA+PC9jeC1pdGVtLWNvdW50ZXI+XG5cbiAgICA8c3BhbiBjbGFzcz1cImluZm9cIj5cbiAgICAgIDxzcGFuICpuZ0lmPVwic2hvd0ludmVudG9yeSQgfCBhc3luY1wiPnt7IGdldEludmVudG9yeSgpIH19PC9zcGFuPlxuICAgICAge3tcbiAgICAgICAgaGFzU3RvY2tcbiAgICAgICAgICA/ICgnYWRkVG9DYXJ0LmluU3RvY2snIHwgY3hUcmFuc2xhdGUpXG4gICAgICAgICAgOiAoJ2FkZFRvQ2FydC5vdXRPZlN0b2NrJyB8IGN4VHJhbnNsYXRlKVxuICAgICAgfX08L3NwYW5cbiAgICA+XG4gIDwvZGl2PlxuXG4gIDxidXR0b25cbiAgICAqbmdJZj1cImhhc1N0b2NrXCJcbiAgICBjbGFzcz1cImJ0biBidG4tcHJpbWFyeSBidG4tYmxvY2tcIlxuICAgIHR5cGU9XCJzdWJtaXRcIlxuICAgIFtkaXNhYmxlZF09XCJxdWFudGl0eSA8PSAwIHx8IHF1YW50aXR5ID4gbWF4UXVhbnRpdHlcIlxuICA+XG4gICAge3sgJ2FkZFRvQ2FydC5hZGRUb0NhcnQnIHwgY3hUcmFuc2xhdGUgfX1cbiAgPC9idXR0b24+XG48L2Zvcm0+XG4iXX0=