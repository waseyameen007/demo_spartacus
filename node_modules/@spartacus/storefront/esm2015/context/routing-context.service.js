import { Injectable } from '@angular/core';
import { map, shareReplay } from 'rxjs/operators';
import * as i0 from "@angular/core";
import * as i1 from "@spartacus/core";
/**
 * Resolves the context for the specific route, based on the property `data.cxContext`
 * defined in the Angular Route.
 */
export class RoutingContextService {
    constructor(activatedRoutesService, injector) {
        this.activatedRoutesService = activatedRoutesService;
        this.injector = injector;
        /**
         * Combined context token mapping consisting of all mappings defined in currently
         * Activated Angular Routes.
         *
         * The context token mapping is read from each Route's property `data.cxContext`.
         */
        this.contextTokenMapping$ = this.activatedRoutesService.routes$.pipe(map((routes) => this.getRoutesContextTokenMapping(routes)), shareReplay({ refCount: true, bufferSize: 1 }));
    }
    /**
     * Returns the merged context token mapping, consisting of mappings
     * defined in all Activated Angular Routes.
     */
    getRoutesContextTokenMapping(routes) {
        return Object.assign({}, ...routes.map((route) => { var _a; return (_a = route === null || route === void 0 ? void 0 : route.data) === null || _a === void 0 ? void 0 : _a.cxContext; }));
    }
    /**
     * Resolves the specified `contextToken` from `cxContext` data parameter of the activated Angular Routes.
     * @param contextToken
     *
     * @returns instance from the root injector if defined, otherwise `undefined`.
     */
    get(contextToken) {
        return this.contextTokenMapping$.pipe(map((contextMapping) => {
            const providerToken = contextMapping === null || contextMapping === void 0 ? void 0 : contextMapping[
            // TODO: remove 'as any' after upgrading TypeScript to v4.4
            // See: https://github.com/Microsoft/TypeScript/issues/24587
            contextToken];
            return this.injector.get(providerToken, undefined);
        }));
    }
}
RoutingContextService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: RoutingContextService, deps: [{ token: i1.ActivatedRoutesService }, { token: i0.Injector }], target: i0.ɵɵFactoryTarget.Injectable });
RoutingContextService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: RoutingContextService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: RoutingContextService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: function () { return [{ type: i1.ActivatedRoutesService }, { type: i0.Injector }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicm91dGluZy1jb250ZXh0LnNlcnZpY2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9wcm9qZWN0cy9zdG9yZWZyb250bGliL2NvbnRleHQvcm91dGluZy1jb250ZXh0LnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFVBQVUsRUFBWSxNQUFNLGVBQWUsQ0FBQztBQUlyRCxPQUFPLEVBQUUsR0FBRyxFQUFFLFdBQVcsRUFBRSxNQUFNLGdCQUFnQixDQUFDOzs7QUFHbEQ7OztHQUdHO0FBRUgsTUFBTSxPQUFPLHFCQUFxQjtJQUNoQyxZQUNZLHNCQUE4QyxFQUM5QyxRQUFrQjtRQURsQiwyQkFBc0IsR0FBdEIsc0JBQXNCLENBQXdCO1FBQzlDLGFBQVEsR0FBUixRQUFRLENBQVU7UUFHOUI7Ozs7O1dBS0c7UUFDZ0IseUJBQW9CLEdBRW5DLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUMxQyxHQUFHLENBQUMsQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyw0QkFBNEIsQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUMxRCxXQUFXLENBQUMsRUFBRSxRQUFRLEVBQUUsSUFBSSxFQUFFLFVBQVUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUMvQyxDQUFDO0lBYkMsQ0FBQztJQWVKOzs7T0FHRztJQUNPLDRCQUE0QixDQUNwQyxNQUFnQztRQUVoQyxPQUFPLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLEdBQUcsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssRUFBRSxFQUFFLFdBQUMsT0FBQSxNQUFBLEtBQUssYUFBTCxLQUFLLHVCQUFMLEtBQUssQ0FBRSxJQUFJLDBDQUFFLFNBQVMsQ0FBQSxFQUFBLENBQUMsQ0FBQyxDQUFDO0lBQzdFLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILEdBQUcsQ0FBSSxZQUEwQjtRQUMvQixPQUFPLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxJQUFJLENBQ25DLEdBQUcsQ0FBQyxDQUFDLGNBQWMsRUFBRSxFQUFFO1lBQ3JCLE1BQU0sYUFBYSxHQUNqQixjQUFjLGFBQWQsY0FBYyx1QkFBZCxjQUFjO1lBQ1osMkRBQTJEO1lBQzNELDREQUE0RDtZQUM1RCxZQUFtQixDQUNwQixDQUFDO1lBQ0osT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxhQUFhLEVBQUUsU0FBUyxDQUFDLENBQUM7UUFDckQsQ0FBQyxDQUFDLENBQ0gsQ0FBQztJQUNKLENBQUM7O2tIQS9DVSxxQkFBcUI7c0hBQXJCLHFCQUFxQixjQURSLE1BQU07MkZBQ25CLHFCQUFxQjtrQkFEakMsVUFBVTttQkFBQyxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUUiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlLCBJbmplY3RvciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQWN0aXZhdGVkUm91dGVTbmFwc2hvdCB9IGZyb20gJ0Bhbmd1bGFyL3JvdXRlcic7XG5pbXBvcnQgeyBBY3RpdmF0ZWRSb3V0ZXNTZXJ2aWNlIH0gZnJvbSAnQHNwYXJ0YWN1cy9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IG1hcCwgc2hhcmVSZXBsYXkgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBDb250ZXh0VG9rZW4gfSBmcm9tICcuL2NvbnRleHQubW9kZWwnO1xuXG4vKipcbiAqIFJlc29sdmVzIHRoZSBjb250ZXh0IGZvciB0aGUgc3BlY2lmaWMgcm91dGUsIGJhc2VkIG9uIHRoZSBwcm9wZXJ0eSBgZGF0YS5jeENvbnRleHRgXG4gKiBkZWZpbmVkIGluIHRoZSBBbmd1bGFyIFJvdXRlLlxuICovXG5ASW5qZWN0YWJsZSh7IHByb3ZpZGVkSW46ICdyb290JyB9KVxuZXhwb3J0IGNsYXNzIFJvdXRpbmdDb250ZXh0U2VydmljZSB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHByb3RlY3RlZCBhY3RpdmF0ZWRSb3V0ZXNTZXJ2aWNlOiBBY3RpdmF0ZWRSb3V0ZXNTZXJ2aWNlLFxuICAgIHByb3RlY3RlZCBpbmplY3RvcjogSW5qZWN0b3JcbiAgKSB7fVxuXG4gIC8qKlxuICAgKiBDb21iaW5lZCBjb250ZXh0IHRva2VuIG1hcHBpbmcgY29uc2lzdGluZyBvZiBhbGwgbWFwcGluZ3MgZGVmaW5lZCBpbiBjdXJyZW50bHlcbiAgICogQWN0aXZhdGVkIEFuZ3VsYXIgUm91dGVzLlxuICAgKlxuICAgKiBUaGUgY29udGV4dCB0b2tlbiBtYXBwaW5nIGlzIHJlYWQgZnJvbSBlYWNoIFJvdXRlJ3MgcHJvcGVydHkgYGRhdGEuY3hDb250ZXh0YC5cbiAgICovXG4gIHByb3RlY3RlZCByZWFkb25seSBjb250ZXh0VG9rZW5NYXBwaW5nJDogT2JzZXJ2YWJsZTxcbiAgICBSZWNvcmQ8Q29udGV4dFRva2VuLCBhbnk+XG4gID4gPSB0aGlzLmFjdGl2YXRlZFJvdXRlc1NlcnZpY2Uucm91dGVzJC5waXBlKFxuICAgIG1hcCgocm91dGVzKSA9PiB0aGlzLmdldFJvdXRlc0NvbnRleHRUb2tlbk1hcHBpbmcocm91dGVzKSksXG4gICAgc2hhcmVSZXBsYXkoeyByZWZDb3VudDogdHJ1ZSwgYnVmZmVyU2l6ZTogMSB9KVxuICApO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBtZXJnZWQgY29udGV4dCB0b2tlbiBtYXBwaW5nLCBjb25zaXN0aW5nIG9mIG1hcHBpbmdzXG4gICAqIGRlZmluZWQgaW4gYWxsIEFjdGl2YXRlZCBBbmd1bGFyIFJvdXRlcy5cbiAgICovXG4gIHByb3RlY3RlZCBnZXRSb3V0ZXNDb250ZXh0VG9rZW5NYXBwaW5nKFxuICAgIHJvdXRlczogQWN0aXZhdGVkUm91dGVTbmFwc2hvdFtdXG4gICk6IFJlY29yZDxDb250ZXh0VG9rZW4sIGFueT4ge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCAuLi5yb3V0ZXMubWFwKChyb3V0ZSkgPT4gcm91dGU/LmRhdGE/LmN4Q29udGV4dCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc29sdmVzIHRoZSBzcGVjaWZpZWQgYGNvbnRleHRUb2tlbmAgZnJvbSBgY3hDb250ZXh0YCBkYXRhIHBhcmFtZXRlciBvZiB0aGUgYWN0aXZhdGVkIEFuZ3VsYXIgUm91dGVzLlxuICAgKiBAcGFyYW0gY29udGV4dFRva2VuXG4gICAqXG4gICAqIEByZXR1cm5zIGluc3RhbmNlIGZyb20gdGhlIHJvb3QgaW5qZWN0b3IgaWYgZGVmaW5lZCwgb3RoZXJ3aXNlIGB1bmRlZmluZWRgLlxuICAgKi9cbiAgZ2V0PFQ+KGNvbnRleHRUb2tlbjogQ29udGV4dFRva2VuKTogT2JzZXJ2YWJsZTxUIHwgdW5kZWZpbmVkPiB7XG4gICAgcmV0dXJuIHRoaXMuY29udGV4dFRva2VuTWFwcGluZyQucGlwZShcbiAgICAgIG1hcCgoY29udGV4dE1hcHBpbmcpID0+IHtcbiAgICAgICAgY29uc3QgcHJvdmlkZXJUb2tlbiA9XG4gICAgICAgICAgY29udGV4dE1hcHBpbmc/LltcbiAgICAgICAgICAgIC8vIFRPRE86IHJlbW92ZSAnYXMgYW55JyBhZnRlciB1cGdyYWRpbmcgVHlwZVNjcmlwdCB0byB2NC40XG4gICAgICAgICAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9NaWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMjQ1ODdcbiAgICAgICAgICAgIGNvbnRleHRUb2tlbiBhcyBhbnlcbiAgICAgICAgICBdO1xuICAgICAgICByZXR1cm4gdGhpcy5pbmplY3Rvci5nZXQocHJvdmlkZXJUb2tlbiwgdW5kZWZpbmVkKTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxufVxuIl19