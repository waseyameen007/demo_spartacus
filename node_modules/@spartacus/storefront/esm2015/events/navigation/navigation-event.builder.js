import { Injectable } from '@angular/core';
import { ofType } from '@ngrx/effects';
import { ROUTER_NAVIGATED } from '@ngrx/router-store';
import { createFrom, } from '@spartacus/core';
import { map } from 'rxjs/operators';
import { NavigationEvent } from './navigation.event';
import * as i0 from "@angular/core";
import * as i1 from "@ngrx/store";
import * as i2 from "@spartacus/core";
/**
 * A builder for the NavigationEvent
 */
export class NavigationEventBuilder {
    constructor(actions, eventService) {
        this.actions = actions;
        this.eventService = eventService;
        this.register();
    }
    /**
     * Registers events
     */
    register() {
        this.eventService.register(NavigationEvent, this.buildNavigationEvent());
    }
    /**
     * Builds the navigation events
     */
    buildNavigationEvent() {
        return this.getNavigatedEvent().pipe(map((state) => createFrom(NavigationEvent, {
            context: state.context,
            semanticRoute: state.semanticRoute,
            url: state.url,
            params: state.params,
        })));
    }
    getNavigatedEvent() {
        return this.actions.pipe(ofType(ROUTER_NAVIGATED), map((event) => event.payload.routerState));
    }
}
NavigationEventBuilder.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: NavigationEventBuilder, deps: [{ token: i1.ActionsSubject }, { token: i2.EventService }], target: i0.ɵɵFactoryTarget.Injectable });
NavigationEventBuilder.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: NavigationEventBuilder, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: NavigationEventBuilder, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.ActionsSubject }, { type: i2.EventService }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmF2aWdhdGlvbi1ldmVudC5idWlsZGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvc3RvcmVmcm9udGxpYi9ldmVudHMvbmF2aWdhdGlvbi9uYXZpZ2F0aW9uLWV2ZW50LmJ1aWxkZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUMzQyxPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ3ZDLE9BQU8sRUFBeUIsZ0JBQWdCLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQztBQUU3RSxPQUFPLEVBRUwsVUFBVSxHQUVYLE1BQU0saUJBQWlCLENBQUM7QUFFekIsT0FBTyxFQUFFLEdBQUcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3JDLE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQzs7OztBQUVyRDs7R0FFRztBQUlILE1BQU0sT0FBTyxzQkFBc0I7SUFDakMsWUFDWSxPQUF1QixFQUN2QixZQUEwQjtRQUQxQixZQUFPLEdBQVAsT0FBTyxDQUFnQjtRQUN2QixpQkFBWSxHQUFaLFlBQVksQ0FBYztRQUVwQyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7SUFDbEIsQ0FBQztJQUVEOztPQUVHO0lBQ08sUUFBUTtRQUNoQixJQUFJLENBQUMsWUFBWSxDQUFDLFFBQVEsQ0FBQyxlQUFlLEVBQUUsSUFBSSxDQUFDLG9CQUFvQixFQUFFLENBQUMsQ0FBQztJQUMzRSxDQUFDO0lBRUQ7O09BRUc7SUFDTyxvQkFBb0I7UUFDNUIsT0FBTyxJQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQyxJQUFJLENBQ2xDLEdBQUcsQ0FBQyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQ1osVUFBVSxDQUFDLGVBQWUsRUFBRTtZQUMxQixPQUFPLEVBQUUsS0FBSyxDQUFDLE9BQU87WUFDdEIsYUFBYSxFQUFFLEtBQUssQ0FBQyxhQUFhO1lBQ2xDLEdBQUcsRUFBRSxLQUFLLENBQUMsR0FBRztZQUNkLE1BQU0sRUFBRSxLQUFLLENBQUMsTUFBTTtTQUNyQixDQUFDLENBQ0gsQ0FDRixDQUFDO0lBQ0osQ0FBQztJQUVPLGlCQUFpQjtRQUN2QixPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUN0QixNQUFNLENBQ0osZ0JBQWdCLENBQ2pCLEVBQ0QsR0FBRyxDQUFDLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLFdBQVcsQ0FBQyxDQUMxQyxDQUFDO0lBQ0osQ0FBQzs7bUhBdENVLHNCQUFzQjt1SEFBdEIsc0JBQXNCLGNBRnJCLE1BQU07MkZBRVAsc0JBQXNCO2tCQUhsQyxVQUFVO21CQUFDO29CQUNWLFVBQVUsRUFBRSxNQUFNO2lCQUNuQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IG9mVHlwZSB9IGZyb20gJ0BuZ3J4L2VmZmVjdHMnO1xuaW1wb3J0IHsgUm91dGVyTmF2aWdhdGVkQWN0aW9uLCBST1VURVJfTkFWSUdBVEVEIH0gZnJvbSAnQG5ncngvcm91dGVyLXN0b3JlJztcbmltcG9ydCB7IEFjdGlvbnNTdWJqZWN0IH0gZnJvbSAnQG5ncngvc3RvcmUnO1xuaW1wb3J0IHtcbiAgQWN0aXZhdGVkUm91dGVyU3RhdGVTbmFwc2hvdCxcbiAgY3JlYXRlRnJvbSxcbiAgRXZlbnRTZXJ2aWNlLFxufSBmcm9tICdAc3BhcnRhY3VzL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgbWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgTmF2aWdhdGlvbkV2ZW50IH0gZnJvbSAnLi9uYXZpZ2F0aW9uLmV2ZW50JztcblxuLyoqXG4gKiBBIGJ1aWxkZXIgZm9yIHRoZSBOYXZpZ2F0aW9uRXZlbnRcbiAqL1xuQEluamVjdGFibGUoe1xuICBwcm92aWRlZEluOiAncm9vdCcsXG59KVxuZXhwb3J0IGNsYXNzIE5hdmlnYXRpb25FdmVudEJ1aWxkZXIge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcm90ZWN0ZWQgYWN0aW9uczogQWN0aW9uc1N1YmplY3QsXG4gICAgcHJvdGVjdGVkIGV2ZW50U2VydmljZTogRXZlbnRTZXJ2aWNlXG4gICkge1xuICAgIHRoaXMucmVnaXN0ZXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgZXZlbnRzXG4gICAqL1xuICBwcm90ZWN0ZWQgcmVnaXN0ZXIoKTogdm9pZCB7XG4gICAgdGhpcy5ldmVudFNlcnZpY2UucmVnaXN0ZXIoTmF2aWdhdGlvbkV2ZW50LCB0aGlzLmJ1aWxkTmF2aWdhdGlvbkV2ZW50KCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyB0aGUgbmF2aWdhdGlvbiBldmVudHNcbiAgICovXG4gIHByb3RlY3RlZCBidWlsZE5hdmlnYXRpb25FdmVudCgpOiBPYnNlcnZhYmxlPE5hdmlnYXRpb25FdmVudD4ge1xuICAgIHJldHVybiB0aGlzLmdldE5hdmlnYXRlZEV2ZW50KCkucGlwZShcbiAgICAgIG1hcCgoc3RhdGUpID0+XG4gICAgICAgIGNyZWF0ZUZyb20oTmF2aWdhdGlvbkV2ZW50LCB7XG4gICAgICAgICAgY29udGV4dDogc3RhdGUuY29udGV4dCxcbiAgICAgICAgICBzZW1hbnRpY1JvdXRlOiBzdGF0ZS5zZW1hbnRpY1JvdXRlLFxuICAgICAgICAgIHVybDogc3RhdGUudXJsLFxuICAgICAgICAgIHBhcmFtczogc3RhdGUucGFyYW1zLFxuICAgICAgICB9KVxuICAgICAgKVxuICAgICk7XG4gIH1cblxuICBwcml2YXRlIGdldE5hdmlnYXRlZEV2ZW50KCk6IE9ic2VydmFibGU8QWN0aXZhdGVkUm91dGVyU3RhdGVTbmFwc2hvdD4ge1xuICAgIHJldHVybiB0aGlzLmFjdGlvbnMucGlwZShcbiAgICAgIG9mVHlwZTxSb3V0ZXJOYXZpZ2F0ZWRBY3Rpb248QWN0aXZhdGVkUm91dGVyU3RhdGVTbmFwc2hvdD4+KFxuICAgICAgICBST1VURVJfTkFWSUdBVEVEXG4gICAgICApLFxuICAgICAgbWFwKChldmVudCkgPT4gZXZlbnQucGF5bG9hZC5yb3V0ZXJTdGF0ZSlcbiAgICApO1xuICB9XG59XG4iXX0=