import { Injectable, isDevMode } from '@angular/core';
import { of } from 'rxjs';
import { map } from 'rxjs/operators';
import * as i0 from "@angular/core";
import * as i1 from "../../../layout/breakpoint/breakpoint.service";
import * as i2 from "./config/table.config";
/**
 * Responsive table service.
 *
 * The `TableService` is used to build a `TableStructure` by configuration. The configuration
 * allows for breakpoint specific configuration, so that the table can differentiate for
 * various screen sizes.
 *
 * While there are some global options, the configuration is mainly driven by the table _type_.
 *
 * If there is no table configuration for the given type found, a table header structure
 * is generated based on the actual data (if available) or randomly by generating 5 random headers.
 */
export class TableService {
    constructor(breakpointService, config) {
        this.breakpointService = breakpointService;
        this.config = config;
    }
    /**
     * Builds the table structure.
     *
     * @param tableType The table type is used  to find the specific table configuration.
     * @param defaultStructure (optional) Default table structure that contains fallback options. More specific options are merged with the default structure.
     * @param data$ (optional) The actual data can be passed in to generate the table structure based on actual data.
     */
    buildStructure(tableType, defaultStructure) {
        if (this.hasTableConfig(tableType)) {
            return this.buildStructureFromConfig(tableType, defaultStructure);
        }
        else {
            return this.buildRandomStructure(tableType);
        }
    }
    /**
     * Returns the table structure by configuration. The configuration can be
     * breakpoint-driven, which means that an alternative header structure can
     * be created per screen size.
     *
     * The breakpoint is resolved by teh `BreakpointService`.
     */
    buildStructureFromConfig(type, defaultStructure) {
        return this.breakpointService.breakpoint$.pipe(map((breakpoint) => (Object.assign(Object.assign({}, this.getTableConfig(type, breakpoint, defaultStructure)), { type }))));
    }
    /**
     * Finds all applicable table configuration for the given type and breakpoint.
     * The default table configuration is merged with all relevant breakpoint
     * configurations.
     *
     * This allows to have some default configurations that apply to all screens, and
     * add configuration options for some screens.
     */
    getTableConfig(type, breakpoint, defaultStructure) {
        var _a, _b;
        if (!((_a = this.config.table) === null || _a === void 0 ? void 0 : _a[type])) {
            return null;
        }
        const relevant = this.findRelevantBreakpoints(breakpoint);
        const closestBreakpoint = [...relevant]
            .reverse()
            .find((br) => { var _a; return !!((_a = this.config.table[type][br]) === null || _a === void 0 ? void 0 : _a.cells); });
        const cells = ((_b = this.config.table[type][closestBreakpoint]) === null || _b === void 0 ? void 0 : _b.cells) ||
            this.config.table[type].cells ||
            (defaultStructure === null || defaultStructure === void 0 ? void 0 : defaultStructure.cells);
        // add all default table configurations
        let options = Object.assign(Object.assign({}, defaultStructure === null || defaultStructure === void 0 ? void 0 : defaultStructure.options), this.config.table[type].options);
        // We merge all table options for smaller breakpoints into the global
        // options, so we inherit options.
        relevant.forEach((br) => {
            var _a, _b, _c;
            options = Object.assign(Object.assign(Object.assign({}, options), (_a = defaultStructure === null || defaultStructure === void 0 ? void 0 : defaultStructure[br]) === null || _a === void 0 ? void 0 : _a.options), (_c = (_b = this.config.table[type]) === null || _b === void 0 ? void 0 : _b[br]) === null || _c === void 0 ? void 0 : _c.options);
        });
        return { cells, options };
    }
    /**
     * Generates the table structure by the help of the first data row.
     */
    buildStructureFromData(type, data$) {
        this.logWarning(`No table configuration found to render table with type "${type}". The table header for "${type}" is generated by the help of the first data item`);
        return data$.pipe(map((data) => {
            const cells = Object.keys(data === null || data === void 0 ? void 0 : data[0]).map((key) => key);
            return { type, cells };
        }));
    }
    /**
     * As a last resort, the table structure is randomly created. The random structure
     * contains 5 headers, so that some of the unknown data is visualized.
     */
    buildRandomStructure(type) {
        this.logWarning(`No data available for "${type}", a random structure is generated (with hidden table headers).`);
        return of({
            type,
            cells: ['unknown', 'unknown', 'unknown', 'unknown', 'unknown'],
        });
    }
    /**
     * Finds all the breakpoints can contribute to the table configuration, from small
     * to current.
     *
     * For example, if the current breakpoint is `MD`, this returns `[XS, SM, MD]`.
     */
    findRelevantBreakpoints(breakpoint) {
        const current = this.breakpointService.breakpoints.indexOf(breakpoint);
        return this.breakpointService.breakpoints.slice(0, current + 1);
    }
    /**
     * Indicates if the there is a configuration for the table available.
     */
    hasTableConfig(tableType) {
        var _a;
        return !!((_a = this.config.table) === null || _a === void 0 ? void 0 : _a[tableType]);
    }
    /**
     * Logs a message in the console to increase developer experience.
     *
     * The message is only logged in dev mode.
     */
    logWarning(message) {
        if (isDevMode()) {
            console.warn(message);
        }
    }
}
TableService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: TableService, deps: [{ token: i1.BreakpointService }, { token: i2.TableConfig }], target: i0.ɵɵFactoryTarget.Injectable });
TableService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: TableService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: TableService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.BreakpointService }, { type: i2.TableConfig }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFibGUuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL3N0b3JlZnJvbnRsaWIvc2hhcmVkL2NvbXBvbmVudHMvdGFibGUvdGFibGUuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLFNBQVMsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUN0RCxPQUFPLEVBQWMsRUFBRSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQ3RDLE9BQU8sRUFBRSxHQUFHLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQzs7OztBQVNyQzs7Ozs7Ozs7Ozs7R0FXRztBQUlILE1BQU0sT0FBTyxZQUFZO0lBQ3ZCLFlBQ1ksaUJBQW9DLEVBQ3BDLE1BQW1CO1FBRG5CLHNCQUFpQixHQUFqQixpQkFBaUIsQ0FBbUI7UUFDcEMsV0FBTSxHQUFOLE1BQU0sQ0FBYTtJQUM1QixDQUFDO0lBRUo7Ozs7OztPQU1HO0lBQ0gsY0FBYyxDQUNaLFNBQWlCLEVBQ2pCLGdCQUErQztRQUUvQyxJQUFJLElBQUksQ0FBQyxjQUFjLENBQUMsU0FBUyxDQUFDLEVBQUU7WUFDbEMsT0FBTyxJQUFJLENBQUMsd0JBQXdCLENBQUMsU0FBUyxFQUFFLGdCQUFnQixDQUFDLENBQUM7U0FDbkU7YUFBTTtZQUNMLE9BQU8sSUFBSSxDQUFDLG9CQUFvQixDQUFDLFNBQVMsQ0FBQyxDQUFDO1NBQzdDO0lBQ0gsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNPLHdCQUF3QixDQUNoQyxJQUFZLEVBQ1osZ0JBQStDO1FBRS9DLE9BQU8sSUFBSSxDQUFDLGlCQUFpQixDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQzVDLEdBQUcsQ0FBQyxDQUFDLFVBQVUsRUFBRSxFQUFFLENBQUMsaUNBQ2YsSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLEVBQUUsVUFBVSxFQUFFLGdCQUFnQixDQUFDLEtBQzFELElBQUksSUFDSixDQUFDLENB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TSxPQUFPLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLENBQUM7UUFDdkUsT0FBTyxJQUFJLENBQUMsaUJBQWlCLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsT0FBTyxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQ2xFLENBQUM7SUFFRDs7T0FFRztJQUNPLGNBQWMsQ0FBQyxTQUFpQjs7UUFDeEMsT0FBTyxDQUFDLENBQUMsQ0FBQSxNQUFBLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSywwQ0FBRyxTQUFTLENBQUMsQ0FBQSxDQUFDO0lBQzFDLENBQUM7SUFFRDs7OztPQUlHO0lBQ0ssVUFBVSxDQUFDLE9BQU87UUFDeEIsSUFBSSxTQUFTLEVBQUUsRUFBRTtZQUNmLE9BQU8sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7U0FDdkI7SUFDSCxDQUFDOzt5R0FwSlUsWUFBWTs2R0FBWixZQUFZLGNBRlgsTUFBTTsyRkFFUCxZQUFZO2tCQUh4QixVQUFVO21CQUFDO29CQUNWLFVBQVUsRUFBRSxNQUFNO2lCQUNuQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUsIGlzRGV2TW9kZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgb2YgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IG1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IEJyZWFrcG9pbnRTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vLi4vbGF5b3V0L2JyZWFrcG9pbnQvYnJlYWtwb2ludC5zZXJ2aWNlJztcbmltcG9ydCB7IEJSRUFLUE9JTlQgfSBmcm9tICcuLi8uLi8uLi9sYXlvdXQvY29uZmlnL2xheW91dC1jb25maWcnO1xuaW1wb3J0IHtcbiAgUmVzcG9uc2l2ZVRhYmxlQ29uZmlndXJhdGlvbixcbiAgVGFibGVDb25maWcsXG59IGZyb20gJy4vY29uZmlnL3RhYmxlLmNvbmZpZyc7XG5pbXBvcnQgeyBUYWJsZVN0cnVjdHVyZSwgVGFibGVTdHJ1Y3R1cmVDb25maWd1cmF0aW9uIH0gZnJvbSAnLi90YWJsZS5tb2RlbCc7XG5cbi8qKlxuICogUmVzcG9uc2l2ZSB0YWJsZSBzZXJ2aWNlLlxuICpcbiAqIFRoZSBgVGFibGVTZXJ2aWNlYCBpcyB1c2VkIHRvIGJ1aWxkIGEgYFRhYmxlU3RydWN0dXJlYCBieSBjb25maWd1cmF0aW9uLiBUaGUgY29uZmlndXJhdGlvblxuICogYWxsb3dzIGZvciBicmVha3BvaW50IHNwZWNpZmljIGNvbmZpZ3VyYXRpb24sIHNvIHRoYXQgdGhlIHRhYmxlIGNhbiBkaWZmZXJlbnRpYXRlIGZvclxuICogdmFyaW91cyBzY3JlZW4gc2l6ZXMuXG4gKlxuICogV2hpbGUgdGhlcmUgYXJlIHNvbWUgZ2xvYmFsIG9wdGlvbnMsIHRoZSBjb25maWd1cmF0aW9uIGlzIG1haW5seSBkcml2ZW4gYnkgdGhlIHRhYmxlIF90eXBlXy5cbiAqXG4gKiBJZiB0aGVyZSBpcyBubyB0YWJsZSBjb25maWd1cmF0aW9uIGZvciB0aGUgZ2l2ZW4gdHlwZSBmb3VuZCwgYSB0YWJsZSBoZWFkZXIgc3RydWN0dXJlXG4gKiBpcyBnZW5lcmF0ZWQgYmFzZWQgb24gdGhlIGFjdHVhbCBkYXRhIChpZiBhdmFpbGFibGUpIG9yIHJhbmRvbWx5IGJ5IGdlbmVyYXRpbmcgNSByYW5kb20gaGVhZGVycy5cbiAqL1xuQEluamVjdGFibGUoe1xuICBwcm92aWRlZEluOiAncm9vdCcsXG59KVxuZXhwb3J0IGNsYXNzIFRhYmxlU2VydmljZSB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHByb3RlY3RlZCBicmVha3BvaW50U2VydmljZTogQnJlYWtwb2ludFNlcnZpY2UsXG4gICAgcHJvdGVjdGVkIGNvbmZpZzogVGFibGVDb25maWdcbiAgKSB7fVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgdGhlIHRhYmxlIHN0cnVjdHVyZS5cbiAgICpcbiAgICogQHBhcmFtIHRhYmxlVHlwZSBUaGUgdGFibGUgdHlwZSBpcyB1c2VkICB0byBmaW5kIHRoZSBzcGVjaWZpYyB0YWJsZSBjb25maWd1cmF0aW9uLlxuICAgKiBAcGFyYW0gZGVmYXVsdFN0cnVjdHVyZSAob3B0aW9uYWwpIERlZmF1bHQgdGFibGUgc3RydWN0dXJlIHRoYXQgY29udGFpbnMgZmFsbGJhY2sgb3B0aW9ucy4gTW9yZSBzcGVjaWZpYyBvcHRpb25zIGFyZSBtZXJnZWQgd2l0aCB0aGUgZGVmYXVsdCBzdHJ1Y3R1cmUuXG4gICAqIEBwYXJhbSBkYXRhJCAob3B0aW9uYWwpIFRoZSBhY3R1YWwgZGF0YSBjYW4gYmUgcGFzc2VkIGluIHRvIGdlbmVyYXRlIHRoZSB0YWJsZSBzdHJ1Y3R1cmUgYmFzZWQgb24gYWN0dWFsIGRhdGEuXG4gICAqL1xuICBidWlsZFN0cnVjdHVyZShcbiAgICB0YWJsZVR5cGU6IHN0cmluZyxcbiAgICBkZWZhdWx0U3RydWN0dXJlPzogUmVzcG9uc2l2ZVRhYmxlQ29uZmlndXJhdGlvblxuICApOiBPYnNlcnZhYmxlPFRhYmxlU3RydWN0dXJlPiB7XG4gICAgaWYgKHRoaXMuaGFzVGFibGVDb25maWcodGFibGVUeXBlKSkge1xuICAgICAgcmV0dXJuIHRoaXMuYnVpbGRTdHJ1Y3R1cmVGcm9tQ29uZmlnKHRhYmxlVHlwZSwgZGVmYXVsdFN0cnVjdHVyZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmJ1aWxkUmFuZG9tU3RydWN0dXJlKHRhYmxlVHlwZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHRhYmxlIHN0cnVjdHVyZSBieSBjb25maWd1cmF0aW9uLiBUaGUgY29uZmlndXJhdGlvbiBjYW4gYmVcbiAgICogYnJlYWtwb2ludC1kcml2ZW4sIHdoaWNoIG1lYW5zIHRoYXQgYW4gYWx0ZXJuYXRpdmUgaGVhZGVyIHN0cnVjdHVyZSBjYW5cbiAgICogYmUgY3JlYXRlZCBwZXIgc2NyZWVuIHNpemUuXG4gICAqXG4gICAqIFRoZSBicmVha3BvaW50IGlzIHJlc29sdmVkIGJ5IHRlaCBgQnJlYWtwb2ludFNlcnZpY2VgLlxuICAgKi9cbiAgcHJvdGVjdGVkIGJ1aWxkU3RydWN0dXJlRnJvbUNvbmZpZyhcbiAgICB0eXBlOiBzdHJpbmcsXG4gICAgZGVmYXVsdFN0cnVjdHVyZT86IFJlc3BvbnNpdmVUYWJsZUNvbmZpZ3VyYXRpb25cbiAgKTogT2JzZXJ2YWJsZTxUYWJsZVN0cnVjdHVyZT4ge1xuICAgIHJldHVybiB0aGlzLmJyZWFrcG9pbnRTZXJ2aWNlLmJyZWFrcG9pbnQkLnBpcGUoXG4gICAgICBtYXAoKGJyZWFrcG9pbnQpID0+ICh7XG4gICAgICAgIC4uLnRoaXMuZ2V0VGFibGVDb25maWcodHlwZSwgYnJlYWtwb2ludCwgZGVmYXVsdFN0cnVjdHVyZSksXG4gICAgICAgIHR5cGUsXG4gICAgICB9KSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmRzIGFsbCBhcHBsaWNhYmxlIHRhYmxlIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBnaXZlbiB0eXBlIGFuZCBicmVha3BvaW50LlxuICAgKiBUaGUgZGVmYXVsdCB0YWJsZSBjb25maWd1cmF0aW9uIGlzIG1lcmdlZCB3aXRoIGFsbCByZWxldmFudCBicmVha3BvaW50XG4gICAqIGNvbmZpZ3VyYXRpb25zLlxuICAgKlxuICAgKiBUaGlzIGFsbG93cyB0byBoYXZlIHNvbWUgZGVmYXVsdCBjb25maWd1cmF0aW9ucyB0aGF0IGFwcGx5IHRvIGFsbCBzY3JlZW5zLCBhbmRcbiAgICogYWRkIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3Igc29tZSBzY3JlZW5zLlxuICAgKi9cbiAgcHJvdGVjdGVkIGdldFRhYmxlQ29uZmlnKFxuICAgIHR5cGU6IHN0cmluZyxcbiAgICBicmVha3BvaW50OiBCUkVBS1BPSU5ULFxuICAgIGRlZmF1bHRTdHJ1Y3R1cmU/OiBSZXNwb25zaXZlVGFibGVDb25maWd1cmF0aW9uXG4gICk6IFRhYmxlU3RydWN0dXJlQ29uZmlndXJhdGlvbiB7XG4gICAgaWYgKCF0aGlzLmNvbmZpZy50YWJsZT8uW3R5cGVdKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCByZWxldmFudCA9IHRoaXMuZmluZFJlbGV2YW50QnJlYWtwb2ludHMoYnJlYWtwb2ludCk7XG5cbiAgICBjb25zdCBjbG9zZXN0QnJlYWtwb2ludCA9IFsuLi5yZWxldmFudF1cbiAgICAgIC5yZXZlcnNlKClcbiAgICAgIC5maW5kKChicikgPT4gISF0aGlzLmNvbmZpZy50YWJsZVt0eXBlXVticl0/LmNlbGxzKTtcbiAgICBjb25zdCBjZWxscyA9XG4gICAgICB0aGlzLmNvbmZpZy50YWJsZVt0eXBlXVtjbG9zZXN0QnJlYWtwb2ludF0/LmNlbGxzIHx8XG4gICAgICB0aGlzLmNvbmZpZy50YWJsZVt0eXBlXS5jZWxscyB8fFxuICAgICAgZGVmYXVsdFN0cnVjdHVyZT8uY2VsbHM7XG5cbiAgICAvLyBhZGQgYWxsIGRlZmF1bHQgdGFibGUgY29uZmlndXJhdGlvbnNcbiAgICBsZXQgb3B0aW9ucyA9IHtcbiAgICAgIC4uLmRlZmF1bHRTdHJ1Y3R1cmU/Lm9wdGlvbnMsXG4gICAgICAuLi50aGlzLmNvbmZpZy50YWJsZVt0eXBlXS5vcHRpb25zLFxuICAgIH07XG5cbiAgICAvLyBXZSBtZXJnZSBhbGwgdGFibGUgb3B0aW9ucyBmb3Igc21hbGxlciBicmVha3BvaW50cyBpbnRvIHRoZSBnbG9iYWxcbiAgICAvLyBvcHRpb25zLCBzbyB3ZSBpbmhlcml0IG9wdGlvbnMuXG4gICAgcmVsZXZhbnQuZm9yRWFjaCgoYnIpID0+IHtcbiAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIC4uLmRlZmF1bHRTdHJ1Y3R1cmU/Llticl0/Lm9wdGlvbnMsXG4gICAgICAgIC4uLnRoaXMuY29uZmlnLnRhYmxlW3R5cGVdPy5bYnJdPy5vcHRpb25zLFxuICAgICAgfTtcbiAgICB9KTtcblxuICAgIHJldHVybiB7IGNlbGxzLCBvcHRpb25zIH07XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIHRoZSB0YWJsZSBzdHJ1Y3R1cmUgYnkgdGhlIGhlbHAgb2YgdGhlIGZpcnN0IGRhdGEgcm93LlxuICAgKi9cbiAgcHJvdGVjdGVkIGJ1aWxkU3RydWN0dXJlRnJvbURhdGEoXG4gICAgdHlwZTogc3RyaW5nLFxuICAgIGRhdGEkOiBPYnNlcnZhYmxlPGFueT5cbiAgKTogT2JzZXJ2YWJsZTxUYWJsZVN0cnVjdHVyZT4ge1xuICAgIHRoaXMubG9nV2FybmluZyhcbiAgICAgIGBObyB0YWJsZSBjb25maWd1cmF0aW9uIGZvdW5kIHRvIHJlbmRlciB0YWJsZSB3aXRoIHR5cGUgXCIke3R5cGV9XCIuIFRoZSB0YWJsZSBoZWFkZXIgZm9yIFwiJHt0eXBlfVwiIGlzIGdlbmVyYXRlZCBieSB0aGUgaGVscCBvZiB0aGUgZmlyc3QgZGF0YSBpdGVtYFxuICAgICk7XG4gICAgcmV0dXJuIGRhdGEkLnBpcGUoXG4gICAgICBtYXAoKGRhdGE6IGFueVtdKSA9PiB7XG4gICAgICAgIGNvbnN0IGNlbGxzID0gT2JqZWN0LmtleXMoZGF0YT8uWzBdKS5tYXAoKGtleSkgPT4ga2V5KTtcbiAgICAgICAgcmV0dXJuIHsgdHlwZSwgY2VsbHMgfSBhcyBUYWJsZVN0cnVjdHVyZTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBcyBhIGxhc3QgcmVzb3J0LCB0aGUgdGFibGUgc3RydWN0dXJlIGlzIHJhbmRvbWx5IGNyZWF0ZWQuIFRoZSByYW5kb20gc3RydWN0dXJlXG4gICAqIGNvbnRhaW5zIDUgaGVhZGVycywgc28gdGhhdCBzb21lIG9mIHRoZSB1bmtub3duIGRhdGEgaXMgdmlzdWFsaXplZC5cbiAgICovXG4gIHByb3RlY3RlZCBidWlsZFJhbmRvbVN0cnVjdHVyZSh0eXBlOiBzdHJpbmcpOiBPYnNlcnZhYmxlPFRhYmxlU3RydWN0dXJlPiB7XG4gICAgdGhpcy5sb2dXYXJuaW5nKFxuICAgICAgYE5vIGRhdGEgYXZhaWxhYmxlIGZvciBcIiR7dHlwZX1cIiwgYSByYW5kb20gc3RydWN0dXJlIGlzIGdlbmVyYXRlZCAod2l0aCBoaWRkZW4gdGFibGUgaGVhZGVycykuYFxuICAgICk7XG4gICAgcmV0dXJuIG9mKHtcbiAgICAgIHR5cGUsXG4gICAgICBjZWxsczogWyd1bmtub3duJywgJ3Vua25vd24nLCAndW5rbm93bicsICd1bmtub3duJywgJ3Vua25vd24nXSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kcyBhbGwgdGhlIGJyZWFrcG9pbnRzIGNhbiBjb250cmlidXRlIHRvIHRoZSB0YWJsZSBjb25maWd1cmF0aW9uLCBmcm9tIHNtYWxsXG4gICAqIHRvIGN1cnJlbnQuXG4gICAqXG4gICAqIEZvciBleGFtcGxlLCBpZiB0aGUgY3VycmVudCBicmVha3BvaW50IGlzIGBNRGAsIHRoaXMgcmV0dXJucyBgW1hTLCBTTSwgTURdYC5cbiAgICovXG4gIHByb3RlY3RlZCBmaW5kUmVsZXZhbnRCcmVha3BvaW50cyhicmVha3BvaW50OiBCUkVBS1BPSU5UKTogQlJFQUtQT0lOVFtdIHtcbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5icmVha3BvaW50U2VydmljZS5icmVha3BvaW50cy5pbmRleE9mKGJyZWFrcG9pbnQpO1xuICAgIHJldHVybiB0aGlzLmJyZWFrcG9pbnRTZXJ2aWNlLmJyZWFrcG9pbnRzLnNsaWNlKDAsIGN1cnJlbnQgKyAxKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgaWYgdGhlIHRoZXJlIGlzIGEgY29uZmlndXJhdGlvbiBmb3IgdGhlIHRhYmxlIGF2YWlsYWJsZS5cbiAgICovXG4gIHByb3RlY3RlZCBoYXNUYWJsZUNvbmZpZyh0YWJsZVR5cGU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAhIXRoaXMuY29uZmlnLnRhYmxlPy5bdGFibGVUeXBlXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2dzIGEgbWVzc2FnZSBpbiB0aGUgY29uc29sZSB0byBpbmNyZWFzZSBkZXZlbG9wZXIgZXhwZXJpZW5jZS5cbiAgICpcbiAgICogVGhlIG1lc3NhZ2UgaXMgb25seSBsb2dnZWQgaW4gZGV2IG1vZGUuXG4gICAqL1xuICBwcml2YXRlIGxvZ1dhcm5pbmcobWVzc2FnZSkge1xuICAgIGlmIChpc0Rldk1vZGUoKSkge1xuICAgICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICAgIH1cbiAgfVxufVxuIl19