import { ChangeDetectionStrategy, Component, EventEmitter, HostBinding, Input, isDevMode, Output, } from '@angular/core';
import { TableLayout, } from './table.model';
import * as i0 from "@angular/core";
import * as i1 from "./table-renderer.service";
import * as i2 from "@angular/common";
import * as i3 from "../../../cms-structure/outlet/outlet.directive";
/**
 * The table component provides a generic table DOM structure, with 3 layout types:
 * horizontal, vertical and _stacked vertical_ layout. The layout is driven by the
 * table structure.
 *
 * The implementation is fairly "dumb" and only renders string based content for TH
 * and TD elements. The actual cell rendering is delegated to a (configurable) cell
 * component. Additionally, each cell is registered as an outlet, so that customizations
 * can be done by both outlet templates and components.
 *
 * The outlet references are concatenated from the table `type` and header `key`. The
 * following snippet shows an outlet generated for a table header, for the table type
 * "cost-center" with a header key "name":
 *
 * ```
 * <th>
 *   <template cxOutlet="table.cost-center.header.name">
 *   </template>
 * </th>
 * ```
 *
 * Similarly, the data cells (`<td>`) are generated with the outlet template reference
 * `table.cost-center.data.name`.
 */
export class TableComponent {
    constructor(rendererService) {
        this.rendererService = rendererService;
        this.launch = new EventEmitter();
    }
    set structure(structure) {
        this._structure = structure;
        this.init();
    }
    get structure() {
        return this._structure;
    }
    init() {
        this.verticalLayout = !this.layout || this.layout === TableLayout.VERTICAL;
        this.verticalStackedLayout = this.layout === TableLayout.VERTICAL_STACKED;
        this.horizontalLayout = this.layout === TableLayout.HORIZONTAL;
        this.rendererService.add(this.structure);
        this.addTableDebugInfo();
    }
    launchItem(item) {
        this.launch.emit(item);
    }
    /**
     * Indicates whether the given item is the current item.
     *
     * The current item is driven by the `currentItem`, that holds a
     * property and value to compare.
     */
    isCurrentItem(item) {
        var _a, _b;
        if (!this.currentItem || !this.currentItem.value) {
            return false;
        }
        return ((_a = this.currentItem) === null || _a === void 0 ? void 0 : _a.value) === (item === null || item === void 0 ? void 0 : item[(_b = this.currentItem) === null || _b === void 0 ? void 0 : _b.property]);
    }
    /**
     * Returns the header (th) outlet reference for the given field.
     */
    getHeaderOutletRef(field) {
        return this.rendererService.getHeaderOutletRef(this.type, field);
    }
    /**
     * Returns the header (th) outlet context for the given field.
     */
    getHeaderOutletContext(field) {
        return this.rendererService.getHeaderOutletContext(this.type, this.options, this.i18nRoot, field);
    }
    /**
     * Returns the data (td) outlet reference for the given field.
     */
    getDataOutletRef(field) {
        return this.rendererService.getDataOutletRef(this.type, field);
    }
    /**
     * Returns the data (td) outlet context for the given field.
     */
    getDataOutletContext(field, data) {
        return this.rendererService.getDataOutletContext(this.type, this.options, this.i18nRoot, field, data);
    }
    trackData(_i, item) {
        return JSON.stringify(item);
    }
    /**
     * Generates the table type into the UI in devMode, so that developers
     * can easily get the notion of the table type.
     */
    addTableDebugInfo() {
        if (isDevMode() && this.type) {
            this.tableType = this.type;
        }
    }
    /**
     * Helper method to return the deeply nested orientation configuration.
     */
    get layout() {
        var _a, _b;
        return (_b = (_a = this.structure) === null || _a === void 0 ? void 0 : _a.options) === null || _b === void 0 ? void 0 : _b.layout;
    }
    /**
     * Helper method to return the deeply nested type.
     */
    get type() {
        var _a;
        return (_a = this.structure) === null || _a === void 0 ? void 0 : _a.type;
    }
    get options() {
        var _a;
        return (_a = this.structure) === null || _a === void 0 ? void 0 : _a.options;
    }
}
TableComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: TableComponent, deps: [{ token: i1.TableRendererService }], target: i0.ɵɵFactoryTarget.Component });
TableComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: TableComponent, selector: "cx-table", inputs: { structure: "structure", data: "data", i18nRoot: "i18nRoot", currentItem: "currentItem" }, outputs: { launch: "launch" }, host: { properties: { "attr.__cx-table-type": "this.tableType", "class.horizontal": "this.horizontalLayout", "class.vertical": "this.verticalLayout", "class.vertical-stacked": "this.verticalStackedLayout" } }, ngImport: i0, template: "<table *ngIf=\"structure\">\n  <ng-container *ngIf=\"verticalStackedLayout\">\n    <tbody\n      *ngFor=\"let item of data; trackBy: trackData\"\n      (click)=\"launchItem(item)\"\n      [class.is-current]=\"isCurrentItem(item)\"\n    >\n      <tr *ngFor=\"let cell of structure.cells\" [class]=\"cell\">\n        <th>\n          <ng-template\n            [cxOutlet]=\"getHeaderOutletRef(cell)\"\n            [cxOutletContext]=\"getHeaderOutletContext(cell)\"\n          >\n            {{ cell }}\n          </ng-template>\n        </th>\n        <td>\n          <ng-template\n            [cxOutlet]=\"getDataOutletRef(cell)\"\n            [cxOutletContext]=\"getDataOutletContext(cell, item)\"\n          >\n            {{ item[cell] }}\n          </ng-template>\n        </td>\n      </tr>\n    </tbody>\n  </ng-container>\n\n  <!-- vertical tables render the item  -->\n  <ng-container *ngIf=\"verticalLayout\">\n    <thead>\n      <tr>\n        <th scope=\"col\" *ngFor=\"let cell of structure.cells\" [class]=\"cell\">\n          <ng-template\n            [cxOutlet]=\"getHeaderOutletRef(cell)\"\n            [cxOutletContext]=\"getHeaderOutletContext(cell)\"\n          >\n            {{ cell }}\n          </ng-template>\n        </th>\n      </tr>\n    </thead>\n\n    <tr\n      *ngFor=\"let item of data; trackBy: trackData\"\n      [class.is-current]=\"isCurrentItem(item)\"\n      (click)=\"launchItem(item)\"\n    >\n      <td *ngFor=\"let cell of structure.cells; let i = index\" [class]=\"cell\">\n        <ng-template\n          [cxOutlet]=\"getDataOutletRef(cell)\"\n          [cxOutletContext]=\"getDataOutletContext(cell, item)\"\n        >\n          {{ item[cell] }}\n        </ng-template>\n      </td>\n    </tr>\n  </ng-container>\n\n  <ng-container *ngIf=\"horizontalLayout\">\n    <tr *ngFor=\"let cell of structure.cells\" [class]=\"cell\">\n      <th scope=\"col\">\n        <ng-template\n          [cxOutlet]=\"getHeaderOutletRef(cell)\"\n          [cxOutletContext]=\"getHeaderOutletContext(cell)\"\n        >\n          {{ cell }}\n        </ng-template>\n      </th>\n      <td\n        *ngFor=\"let item of data; trackBy: trackData\"\n        [class.is-current]=\"isCurrentItem(item)\"\n        (click)=\"launchItem(item)\"\n      >\n        <ng-template\n          [cxOutlet]=\"getDataOutletRef(cell)\"\n          [cxOutletContext]=\"getDataOutletContext(cell, item)\"\n        >\n          {{ item[cell] }}\n        </ng-template>\n      </td>\n    </tr>\n  </ng-container>\n</table>\n", directives: [{ type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i3.OutletDirective, selector: "[cxOutlet]", inputs: ["cxOutlet", "cxOutletContext", "cxOutletDefer"], outputs: ["loaded"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: TableComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-table',
                    templateUrl: './table.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: i1.TableRendererService }]; }, propDecorators: { tableType: [{
                type: HostBinding,
                args: ['attr.__cx-table-type']
            }], horizontalLayout: [{
                type: HostBinding,
                args: ['class.horizontal']
            }], verticalLayout: [{
                type: HostBinding,
                args: ['class.vertical']
            }], verticalStackedLayout: [{
                type: HostBinding,
                args: ['class.vertical-stacked']
            }], structure: [{
                type: Input
            }], data: [{
                type: Input
            }], i18nRoot: [{
                type: Input
            }], currentItem: [{
                type: Input
            }], launch: [{
                type: Output
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFibGUuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvc3RvcmVmcm9udGxpYi9zaGFyZWQvY29tcG9uZW50cy90YWJsZS90YWJsZS5jb21wb25lbnQudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9zdG9yZWZyb250bGliL3NoYXJlZC9jb21wb25lbnRzL3RhYmxlL3RhYmxlLmNvbXBvbmVudC5odG1sIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDTCx1QkFBdUIsRUFDdkIsU0FBUyxFQUNULFlBQVksRUFDWixXQUFXLEVBQ1gsS0FBSyxFQUNMLFNBQVMsRUFDVCxNQUFNLEdBQ1AsTUFBTSxlQUFlLENBQUM7QUFFdkIsT0FBTyxFQUdMLFdBQVcsR0FFWixNQUFNLGVBQWUsQ0FBQzs7Ozs7QUFFdkI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBdUJHO0FBTUgsTUFBTSxPQUFPLGNBQWM7SUFpQ3pCLFlBQXNCLGVBQXFDO1FBQXJDLG9CQUFlLEdBQWYsZUFBZSxDQUFzQjtRQUZqRCxXQUFNLEdBQUcsSUFBSSxZQUFZLEVBQUUsQ0FBQztJQUV3QixDQUFDO0lBMUIvRCxJQUFhLFNBQVMsQ0FBQyxTQUF5QjtRQUM5QyxJQUFJLENBQUMsVUFBVSxHQUFHLFNBQVMsQ0FBQztRQUM1QixJQUFJLENBQUMsSUFBSSxFQUFFLENBQUM7SUFDZCxDQUFDO0lBQ0QsSUFBSSxTQUFTO1FBQ1gsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDO0lBQ3pCLENBQUM7SUFzQkQsSUFBSTtRQUNGLElBQUksQ0FBQyxjQUFjLEdBQUcsQ0FBQyxJQUFJLENBQUMsTUFBTSxJQUFJLElBQUksQ0FBQyxNQUFNLEtBQUssV0FBVyxDQUFDLFFBQVEsQ0FBQztRQUMzRSxJQUFJLENBQUMscUJBQXFCLEdBQUcsSUFBSSxDQUFDLE1BQU0sS0FBSyxXQUFXLENBQUMsZ0JBQWdCLENBQUM7UUFDMUUs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QUFXO3VCQUFDLGtCQUFrQjtnQkFDQSxjQUFjO3NCQUE1QyxXQUFXO3VCQUFDLGdCQUFnQjtnQkFDVSxxQkFBcUI7c0JBQTNELFdBQVc7dUJBQUMsd0JBQXdCO2dCQUd4QixTQUFTO3NCQUFyQixLQUFLO2dCQVFHLElBQUk7c0JBQVosS0FBSztnQkFNRyxRQUFRO3NCQUFoQixLQUFLO2dCQVFHLFdBQVc7c0JBQW5CLEtBQUs7Z0JBRUksTUFBTTtzQkFBZixNQUFNIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gIENvbXBvbmVudCxcbiAgRXZlbnRFbWl0dGVyLFxuICBIb3N0QmluZGluZyxcbiAgSW5wdXQsXG4gIGlzRGV2TW9kZSxcbiAgT3V0cHV0LFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFRhYmxlUmVuZGVyZXJTZXJ2aWNlIH0gZnJvbSAnLi90YWJsZS1yZW5kZXJlci5zZXJ2aWNlJztcbmltcG9ydCB7XG4gIFRhYmxlRGF0YU91dGxldENvbnRleHQsXG4gIFRhYmxlSGVhZGVyT3V0bGV0Q29udGV4dCxcbiAgVGFibGVMYXlvdXQsXG4gIFRhYmxlU3RydWN0dXJlLFxufSBmcm9tICcuL3RhYmxlLm1vZGVsJztcblxuLyoqXG4gKiBUaGUgdGFibGUgY29tcG9uZW50IHByb3ZpZGVzIGEgZ2VuZXJpYyB0YWJsZSBET00gc3RydWN0dXJlLCB3aXRoIDMgbGF5b3V0IHR5cGVzOlxuICogaG9yaXpvbnRhbCwgdmVydGljYWwgYW5kIF9zdGFja2VkIHZlcnRpY2FsXyBsYXlvdXQuIFRoZSBsYXlvdXQgaXMgZHJpdmVuIGJ5IHRoZVxuICogdGFibGUgc3RydWN0dXJlLlxuICpcbiAqIFRoZSBpbXBsZW1lbnRhdGlvbiBpcyBmYWlybHkgXCJkdW1iXCIgYW5kIG9ubHkgcmVuZGVycyBzdHJpbmcgYmFzZWQgY29udGVudCBmb3IgVEhcbiAqIGFuZCBURCBlbGVtZW50cy4gVGhlIGFjdHVhbCBjZWxsIHJlbmRlcmluZyBpcyBkZWxlZ2F0ZWQgdG8gYSAoY29uZmlndXJhYmxlKSBjZWxsXG4gKiBjb21wb25lbnQuIEFkZGl0aW9uYWxseSwgZWFjaCBjZWxsIGlzIHJlZ2lzdGVyZWQgYXMgYW4gb3V0bGV0LCBzbyB0aGF0IGN1c3RvbWl6YXRpb25zXG4gKiBjYW4gYmUgZG9uZSBieSBib3RoIG91dGxldCB0ZW1wbGF0ZXMgYW5kIGNvbXBvbmVudHMuXG4gKlxuICogVGhlIG91dGxldCByZWZlcmVuY2VzIGFyZSBjb25jYXRlbmF0ZWQgZnJvbSB0aGUgdGFibGUgYHR5cGVgIGFuZCBoZWFkZXIgYGtleWAuIFRoZVxuICogZm9sbG93aW5nIHNuaXBwZXQgc2hvd3MgYW4gb3V0bGV0IGdlbmVyYXRlZCBmb3IgYSB0YWJsZSBoZWFkZXIsIGZvciB0aGUgdGFibGUgdHlwZVxuICogXCJjb3N0LWNlbnRlclwiIHdpdGggYSBoZWFkZXIga2V5IFwibmFtZVwiOlxuICpcbiAqIGBgYFxuICogPHRoPlxuICogICA8dGVtcGxhdGUgY3hPdXRsZXQ9XCJ0YWJsZS5jb3N0LWNlbnRlci5oZWFkZXIubmFtZVwiPlxuICogICA8L3RlbXBsYXRlPlxuICogPC90aD5cbiAqIGBgYFxuICpcbiAqIFNpbWlsYXJseSwgdGhlIGRhdGEgY2VsbHMgKGA8dGQ+YCkgYXJlIGdlbmVyYXRlZCB3aXRoIHRoZSBvdXRsZXQgdGVtcGxhdGUgcmVmZXJlbmNlXG4gKiBgdGFibGUuY29zdC1jZW50ZXIuZGF0YS5uYW1lYC5cbiAqL1xuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY3gtdGFibGUnLFxuICB0ZW1wbGF0ZVVybDogJy4vdGFibGUuY29tcG9uZW50Lmh0bWwnLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbn0pXG5leHBvcnQgY2xhc3MgVGFibGVDb21wb25lbnQ8VD4ge1xuICBASG9zdEJpbmRpbmcoJ2F0dHIuX19jeC10YWJsZS10eXBlJykgdGFibGVUeXBlOiBzdHJpbmc7XG4gIEBIb3N0QmluZGluZygnY2xhc3MuaG9yaXpvbnRhbCcpIGhvcml6b250YWxMYXlvdXQ6IGJvb2xlYW47XG4gIEBIb3N0QmluZGluZygnY2xhc3MudmVydGljYWwnKSB2ZXJ0aWNhbExheW91dDogYm9vbGVhbjtcbiAgQEhvc3RCaW5kaW5nKCdjbGFzcy52ZXJ0aWNhbC1zdGFja2VkJykgdmVydGljYWxTdGFja2VkTGF5b3V0OiBib29sZWFuO1xuXG4gIHByaXZhdGUgX3N0cnVjdHVyZTogVGFibGVTdHJ1Y3R1cmU7XG4gIEBJbnB1dCgpIHNldCBzdHJ1Y3R1cmUoc3RydWN0dXJlOiBUYWJsZVN0cnVjdHVyZSkge1xuICAgIHRoaXMuX3N0cnVjdHVyZSA9IHN0cnVjdHVyZTtcbiAgICB0aGlzLmluaXQoKTtcbiAgfVxuICBnZXQgc3RydWN0dXJlKCk6IFRhYmxlU3RydWN0dXJlIHtcbiAgICByZXR1cm4gdGhpcy5fc3RydWN0dXJlO1xuICB9XG5cbiAgQElucHV0KCkgZGF0YTogVFtdO1xuXG4gIC8qKlxuICAgKiBUaGUgaTE4blJvb3QgaXMgcGFzc2VkIGludG8gdGhlIHRhYmxlIGNlbGwgY29udGV4dCwgc28gdGhhdFxuICAgKiBjZWxsIGNvbXBvbmVudHMgY2FuIGNvbmNhdGVuYXRlIHRoZSBpMThuIHJvb3QgYW5kIGxhYmVsLlxuICAgKi9cbiAgQElucHV0KCkgaTE4blJvb3Q6IHN0cmluZztcblxuICAvKipcbiAgICogUHJvdmlkZXMgYSBtZWNoYW5pc20gdG8gY29tcGFyZSBhIG1hdGNoaW5nIHZhbHVlIGZvciBlYWNoIGl0ZW0uXG4gICAqXG4gICAqIFRoZSBgcHJvcGVydHlgIHJlZmVycyB0byB0aGUgZGF0YXNldC52YWx1ZSBwcm9wZXJ0eSwgYW5kIHRoZSB2YWx1ZSB0b3QgdGhlXG4gICAqIG1hdGNoaW5nIHByb3BlcnR5IHZhbHVlLlxuICAgKi9cbiAgQElucHV0KCkgY3VycmVudEl0ZW06IHsgdmFsdWU6IGFueTsgcHJvcGVydHk6IHN0cmluZyB9O1xuXG4gIEBPdXRwdXQoKSBsYXVuY2ggPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgY29uc3RydWN0b3IocHJvdGVjdGVkIHJlbmRlcmVyU2VydmljZTogVGFibGVSZW5kZXJlclNlcnZpY2UpIHt9XG5cbiAgaW5pdCgpIHtcbiAgICB0aGlzLnZlcnRpY2FsTGF5b3V0ID0gIXRoaXMubGF5b3V0IHx8IHRoaXMubGF5b3V0ID09PSBUYWJsZUxheW91dC5WRVJUSUNBTDtcbiAgICB0aGlzLnZlcnRpY2FsU3RhY2tlZExheW91dCA9IHRoaXMubGF5b3V0ID09PSBUYWJsZUxheW91dC5WRVJUSUNBTF9TVEFDS0VEO1xuICAgIHRoaXMuaG9yaXpvbnRhbExheW91dCA9IHRoaXMubGF5b3V0ID09PSBUYWJsZUxheW91dC5IT1JJWk9OVEFMO1xuXG4gICAgdGhpcy5yZW5kZXJlclNlcnZpY2UuYWRkKHRoaXMuc3RydWN0dXJlKTtcblxuICAgIHRoaXMuYWRkVGFibGVEZWJ1Z0luZm8oKTtcbiAgfVxuXG4gIGxhdW5jaEl0ZW0oaXRlbTogYW55KTogdm9pZCB7XG4gICAgdGhpcy5sYXVuY2guZW1pdChpdGVtKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZ2l2ZW4gaXRlbSBpcyB0aGUgY3VycmVudCBpdGVtLlxuICAgKlxuICAgKiBUaGUgY3VycmVudCBpdGVtIGlzIGRyaXZlbiBieSB0aGUgYGN1cnJlbnRJdGVtYCwgdGhhdCBob2xkcyBhXG4gICAqIHByb3BlcnR5IGFuZCB2YWx1ZSB0byBjb21wYXJlLlxuICAgKi9cbiAgaXNDdXJyZW50SXRlbShpdGVtOiBhbnkpOiBib29sZWFuIHtcbiAgICBpZiAoIXRoaXMuY3VycmVudEl0ZW0gfHwgIXRoaXMuY3VycmVudEl0ZW0udmFsdWUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudEl0ZW0/LnZhbHVlID09PSBpdGVtPy5bdGhpcy5jdXJyZW50SXRlbT8ucHJvcGVydHldO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGhlYWRlciAodGgpIG91dGxldCByZWZlcmVuY2UgZm9yIHRoZSBnaXZlbiBmaWVsZC5cbiAgICovXG4gIGdldEhlYWRlck91dGxldFJlZihmaWVsZDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJlclNlcnZpY2UuZ2V0SGVhZGVyT3V0bGV0UmVmKHRoaXMudHlwZSwgZmllbGQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGhlYWRlciAodGgpIG91dGxldCBjb250ZXh0IGZvciB0aGUgZ2l2ZW4gZmllbGQuXG4gICAqL1xuICBnZXRIZWFkZXJPdXRsZXRDb250ZXh0KGZpZWxkOiBzdHJpbmcpOiBUYWJsZUhlYWRlck91dGxldENvbnRleHQge1xuICAgIHJldHVybiB0aGlzLnJlbmRlcmVyU2VydmljZS5nZXRIZWFkZXJPdXRsZXRDb250ZXh0KFxuICAgICAgdGhpcy50eXBlLFxuICAgICAgdGhpcy5vcHRpb25zLFxuICAgICAgdGhpcy5pMThuUm9vdCxcbiAgICAgIGZpZWxkXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkYXRhICh0ZCkgb3V0bGV0IHJlZmVyZW5jZSBmb3IgdGhlIGdpdmVuIGZpZWxkLlxuICAgKi9cbiAgZ2V0RGF0YU91dGxldFJlZihmaWVsZDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJlclNlcnZpY2UuZ2V0RGF0YU91dGxldFJlZih0aGlzLnR5cGUsIGZpZWxkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkYXRhICh0ZCkgb3V0bGV0IGNvbnRleHQgZm9yIHRoZSBnaXZlbiBmaWVsZC5cbiAgICovXG4gIGdldERhdGFPdXRsZXRDb250ZXh0KGZpZWxkOiBzdHJpbmcsIGRhdGE6IGFueSk6IFRhYmxlRGF0YU91dGxldENvbnRleHQge1xuICAgIHJldHVybiB0aGlzLnJlbmRlcmVyU2VydmljZS5nZXREYXRhT3V0bGV0Q29udGV4dChcbiAgICAgIHRoaXMudHlwZSxcbiAgICAgIHRoaXMub3B0aW9ucyxcbiAgICAgIHRoaXMuaTE4blJvb3QsXG4gICAgICBmaWVsZCxcbiAgICAgIGRhdGFcbiAgICApO1xuICB9XG5cbiAgdHJhY2tEYXRhKF9pOiBudW1iZXIsIGl0ZW06IGFueSk6IGFueSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGl0ZW0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyB0aGUgdGFibGUgdHlwZSBpbnRvIHRoZSBVSSBpbiBkZXZNb2RlLCBzbyB0aGF0IGRldmVsb3BlcnNcbiAgICogY2FuIGVhc2lseSBnZXQgdGhlIG5vdGlvbiBvZiB0aGUgdGFibGUgdHlwZS5cbiAgICovXG4gIHByb3RlY3RlZCBhZGRUYWJsZURlYnVnSW5mbygpIHtcbiAgICBpZiAoaXNEZXZNb2RlKCkgJiYgdGhpcy50eXBlKSB7XG4gICAgICB0aGlzLnRhYmxlVHlwZSA9IHRoaXMudHlwZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGVscGVyIG1ldGhvZCB0byByZXR1cm4gdGhlIGRlZXBseSBuZXN0ZWQgb3JpZW50YXRpb24gY29uZmlndXJhdGlvbi5cbiAgICovXG4gIHByaXZhdGUgZ2V0IGxheW91dCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJ1Y3R1cmU/Lm9wdGlvbnM/LmxheW91dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBIZWxwZXIgbWV0aG9kIHRvIHJldHVybiB0aGUgZGVlcGx5IG5lc3RlZCB0eXBlLlxuICAgKi9cbiAgcHJpdmF0ZSBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJ1Y3R1cmU/LnR5cGU7XG4gIH1cblxuICBwcml2YXRlIGdldCBvcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLnN0cnVjdHVyZT8ub3B0aW9ucztcbiAgfVxufVxuIiwiPHRhYmxlICpuZ0lmPVwic3RydWN0dXJlXCI+XG4gIDxuZy1jb250YWluZXIgKm5nSWY9XCJ2ZXJ0aWNhbFN0YWNrZWRMYXlvdXRcIj5cbiAgICA8dGJvZHlcbiAgICAgICpuZ0Zvcj1cImxldCBpdGVtIG9mIGRhdGE7IHRyYWNrQnk6IHRyYWNrRGF0YVwiXG4gICAgICAoY2xpY2spPVwibGF1bmNoSXRlbShpdGVtKVwiXG4gICAgICBbY2xhc3MuaXMtY3VycmVudF09XCJpc0N1cnJlbnRJdGVtKGl0ZW0pXCJcbiAgICA+XG4gICAgICA8dHIgKm5nRm9yPVwibGV0IGNlbGwgb2Ygc3RydWN0dXJlLmNlbGxzXCIgW2NsYXNzXT1cImNlbGxcIj5cbiAgICAgICAgPHRoPlxuICAgICAgICAgIDxuZy10ZW1wbGF0ZVxuICAgICAgICAgICAgW2N4T3V0bGV0XT1cImdldEhlYWRlck91dGxldFJlZihjZWxsKVwiXG4gICAgICAgICAgICBbY3hPdXRsZXRDb250ZXh0XT1cImdldEhlYWRlck91dGxldENvbnRleHQoY2VsbClcIlxuICAgICAgICAgID5cbiAgICAgICAgICAgIHt7IGNlbGwgfX1cbiAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAgICA8L3RoPlxuICAgICAgICA8dGQ+XG4gICAgICAgICAgPG5nLXRlbXBsYXRlXG4gICAgICAgICAgICBbY3hPdXRsZXRdPVwiZ2V0RGF0YU91dGxldFJlZihjZWxsKVwiXG4gICAgICAgICAgICBbY3hPdXRsZXRDb250ZXh0XT1cImdldERhdGFPdXRsZXRDb250ZXh0KGNlbGwsIGl0ZW0pXCJcbiAgICAgICAgICA+XG4gICAgICAgICAgICB7eyBpdGVtW2NlbGxdIH19XG4gICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgPC90ZD5cbiAgICAgIDwvdHI+XG4gICAgPC90Ym9keT5cbiAgPC9uZy1jb250YWluZXI+XG5cbiAgPCEtLSB2ZXJ0aWNhbCB0YWJsZXMgcmVuZGVyIHRoZSBpdGVtICAtLT5cbiAgPG5nLWNvbnRhaW5lciAqbmdJZj1cInZlcnRpY2FsTGF5b3V0XCI+XG4gICAgPHRoZWFkPlxuICAgICAgPHRyPlxuICAgICAgICA8dGggc2NvcGU9XCJjb2xcIiAqbmdGb3I9XCJsZXQgY2VsbCBvZiBzdHJ1Y3R1cmUuY2VsbHNcIiBbY2xhc3NdPVwiY2VsbFwiPlxuICAgICAgICAgIDxuZy10ZW1wbGF0ZVxuICAgICAgICAgICAgW2N4T3V0bGV0XT1cImdldEhlYWRlck91dGxldFJlZihjZWxsKVwiXG4gICAgICAgICAgICBbY3hPdXRsZXRDb250ZXh0XT1cImdldEhlYWRlck91dGxldENvbnRleHQoY2VsbClcIlxuICAgICAgICAgID5cbiAgICAgICAgICAgIHt7IGNlbGwgfX1cbiAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAgICA8L3RoPlxuICAgICAgPC90cj5cbiAgICA8L3RoZWFkPlxuXG4gICAgPHRyXG4gICAgICAqbmdGb3I9XCJsZXQgaXRlbSBvZiBkYXRhOyB0cmFja0J5OiB0cmFja0RhdGFcIlxuICAgICAgW2NsYXNzLmlzLWN1cnJlbnRdPVwiaXNDdXJyZW50SXRlbShpdGVtKVwiXG4gICAgICAoY2xpY2spPVwibGF1bmNoSXRlbShpdGVtKVwiXG4gICAgPlxuICAgICAgPHRkICpuZ0Zvcj1cImxldCBjZWxsIG9mIHN0cnVjdHVyZS5jZWxsczsgbGV0IGkgPSBpbmRleFwiIFtjbGFzc109XCJjZWxsXCI+XG4gICAgICAgIDxuZy10ZW1wbGF0ZVxuICAgICAgICAgIFtjeE91dGxldF09XCJnZXREYXRhT3V0bGV0UmVmKGNlbGwpXCJcbiAgICAgICAgICBbY3hPdXRsZXRDb250ZXh0XT1cImdldERhdGFPdXRsZXRDb250ZXh0KGNlbGwsIGl0ZW0pXCJcbiAgICAgICAgPlxuICAgICAgICAgIHt7IGl0ZW1bY2VsbF0gfX1cbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgIDwvdGQ+XG4gICAgPC90cj5cbiAgPC9uZy1jb250YWluZXI+XG5cbiAgPG5nLWNvbnRhaW5lciAqbmdJZj1cImhvcml6b250YWxMYXlvdXRcIj5cbiAgICA8dHIgKm5nRm9yPVwibGV0IGNlbGwgb2Ygc3RydWN0dXJlLmNlbGxzXCIgW2NsYXNzXT1cImNlbGxcIj5cbiAgICAgIDx0aCBzY29wZT1cImNvbFwiPlxuICAgICAgICA8bmctdGVtcGxhdGVcbiAgICAgICAgICBbY3hPdXRsZXRdPVwiZ2V0SGVhZGVyT3V0bGV0UmVmKGNlbGwpXCJcbiAgICAgICAgICBbY3hPdXRsZXRDb250ZXh0XT1cImdldEhlYWRlck91dGxldENvbnRleHQoY2VsbClcIlxuICAgICAgICA+XG4gICAgICAgICAge3sgY2VsbCB9fVxuICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAgPC90aD5cbiAgICAgIDx0ZFxuICAgICAgICAqbmdGb3I9XCJsZXQgaXRlbSBvZiBkYXRhOyB0cmFja0J5OiB0cmFja0RhdGFcIlxuICAgICAgICBbY2xhc3MuaXMtY3VycmVudF09XCJpc0N1cnJlbnRJdGVtKGl0ZW0pXCJcbiAgICAgICAgKGNsaWNrKT1cImxhdW5jaEl0ZW0oaXRlbSlcIlxuICAgICAgPlxuICAgICAgICA8bmctdGVtcGxhdGVcbiAgICAgICAgICBbY3hPdXRsZXRdPVwiZ2V0RGF0YU91dGxldFJlZihjZWxsKVwiXG4gICAgICAgICAgW2N4T3V0bGV0Q29udGV4dF09XCJnZXREYXRhT3V0bGV0Q29udGV4dChjZWxsLCBpdGVtKVwiXG4gICAgICAgID5cbiAgICAgICAgICB7eyBpdGVtW2NlbGxdIH19XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICA8L3RkPlxuICAgIDwvdHI+XG4gIDwvbmctY29udGFpbmVyPlxuPC90YWJsZT5cbiJdfQ==