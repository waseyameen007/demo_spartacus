import { Injectable } from '@angular/core';
import { BehaviorSubject } from 'rxjs';
import { distinctUntilChanged, filter, map } from 'rxjs/operators';
import * as i0 from "@angular/core";
/**
 * Supposed to be injected in the split view component, so that the split view state
 * is maintained for a single split view.
 */
export class SplitViewService {
    constructor() {
        /**
         * Newly added views are hidden by default, unless it is the first view of the split view.
         * The default hide mode can be overridden.
         */
        this.defaultHideMode = true;
        this.splitViewCount = 1;
        this._views$ = new BehaviorSubject([]);
    }
    /**
     * Adds a view to the list of views. The view is initialized with the `SplitViewState`
     * state. If no state is provided, the state is created with the hidden property. The hidden
     * property is provided by the `defaultHideMode`, unless it's the first view (position: 0).
     */
    add(position, initialState) {
        const state = Object.assign({ hidden: position === 0 ? false : this.defaultHideMode }, initialState);
        if (!this.views[position]) {
            this.views[position] = state;
            this.updateState(position, state.hidden);
            this._views$.next(this.views);
        }
    }
    /**
     * The split view is based on a number of views that can be used next to each other.
     * When the number changes (i.e. if the screen goes from wide to small), the visibility state
     * of the views should be updated.
     */
    updateSplitView(splitViewCount) {
        if (splitViewCount !== this.splitViewCount) {
            this.splitViewCount = splitViewCount;
            this.updateState();
        }
    }
    /**
     * Returns an observable with the active view number. The active view number
     * represents the last visible view.
     */
    getActiveView() {
        return this._views$.pipe(map((views) => this.getActive(views)), distinctUntilChanged());
    }
    /**
     * Returns an observable with the SplitViewState for the given view position.
     */
    getViewState(position) {
        return this._views$.pipe(map((views) => views[position]), 
        // we must filter here, since outlet driven views will destroyed the view
        filter((view) => Boolean(view)));
    }
    /**
     * Removes a view from the list of views.
     *
     * Removing a view is different from hiding a view. Removing a view is typically done
     * when a component is destroyed.
     *
     * When the view is removed, the SplitViewState is updated to reflect that new organization
     * of views.
     */
    remove(position) {
        const activePosition = this.getActive(this.views);
        this._views$.next(this.views.splice(0, position));
        if (activePosition >= position) {
            this.updateState(position);
        }
    }
    /**
     * Returns the next view position. This is useful for views that do not want to be bothered
     * with controlling view numbers.
     */
    get nextPosition() {
        return this.views.length || 0;
    }
    /**
     * Toggles the visibility of the views based on the given view position. If the view
     * is already visible, we close the view and active the former view. Unless the hide flag
     * is used, to force the view.
     *
     * The view state of other views in the split view are updated as well.
     *
     * @param position The zero-based position number of the view.
     * @param forceHide The (optional) hide state for the view position.
     */
    toggle(position, forceHide) {
        // add the view if it hasn't been added before.
        if (!this.views[position]) {
            this.add(position, { hidden: forceHide !== null && forceHide !== void 0 ? forceHide : false });
        }
        // If the position is already visible, we move to a previous position. Only if the hide
        // state is forced, we keep the current position.
        if (this.views[position] &&
            forceHide === undefined &&
            !this.views[position].hidden) {
            position--;
        }
        this.updateState(position, forceHide === true);
    }
    /**
     * Updates the hidden state of all the views.
     */
    updateState(position, hide) {
        const views = [...this.views];
        if (hide !== undefined && views[position]) {
            views[position].hidden = hide;
        }
        let lastVisible = views.length - [...views].reverse().findIndex((view) => !view.hidden) - 1;
        if (lastVisible === views.length) {
            if (position) {
                // When there's only 1 view (mobile), we might not find any active
                // if the user navigates back.
                lastVisible = position - 1;
            }
            else {
                lastVisible = views.length - 1;
            }
        }
        views.forEach((view, pos) => {
            if (view && pos !== position) {
                // hide other views that are outside the split view
                view.hidden =
                    pos > lastVisible || pos < lastVisible - (this.splitViewCount - 1);
            }
        });
        this._views$.next(views);
    }
    /**
     * Returns the active view count for the list of views.
     */
    getActive(views) {
        // we reverse the list to find the last visible view
        const l = [...views]
            .reverse()
            .findIndex((view) => !view.hidden);
        const last = l === -1 ? 0 : views.length - l - 1;
        return last;
    }
    /**
     * Utility method that resolves all views from the subject.
     */
    get views() {
        return this._views$.value;
    }
}
SplitViewService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SplitViewService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
SplitViewService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SplitViewService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SplitViewService, decorators: [{
            type: Injectable
        }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3BsaXQtdmlldy5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvc3RvcmVmcm9udGxpYi9zaGFyZWQvY29tcG9uZW50cy9zcGxpdC12aWV3L3NwbGl0LXZpZXcuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzNDLE9BQU8sRUFBRSxlQUFlLEVBQWMsTUFBTSxNQUFNLENBQUM7QUFDbkQsT0FBTyxFQUFFLG9CQUFvQixFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQzs7QUFHbkU7OztHQUdHO0FBRUgsTUFBTSxPQUFPLGdCQUFnQjtJQUQ3QjtRQUVFOzs7V0FHRztRQUNILG9CQUFlLEdBQUcsSUFBSSxDQUFDO1FBRWIsbUJBQWMsR0FBRyxDQUFDLENBQUM7UUFFbkIsWUFBTyxHQUEyQixJQUFJLGVBQWUsQ0FBQyxFQUFFLENBQUMsQ0FBQztLQTZKckU7SUEzSkM7Ozs7T0FJRztJQUNILEdBQUcsQ0FBQyxRQUFnQixFQUFFLFlBQTZCO1FBQ2pELE1BQU0sS0FBSyxpQkFDTixFQUFFLE1BQU0sRUFBRSxRQUFRLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxlQUFlLEVBQUUsRUFDekQsWUFBWSxDQUNoQixDQUFDO1FBQ0YsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLEVBQUU7WUFDekIsSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsR0FBRyxLQUFLLENBQUM7WUFDN0IsSUFBSSxDQUFDLFdBQVcsQ0FBQyxRQUFRLEVBQUUsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQ3pDLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztTQUMvQjtJ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Z0I7MkZBQWhCLGdCQUFnQjtrQkFENUIsVUFBVSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCwgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgZGlzdGluY3RVbnRpbENoYW5nZWQsIGZpbHRlciwgbWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgU3BsaXRWaWV3U3RhdGUgfSBmcm9tICcuL3NwbGl0L3NwbGl0LXZpZXcubW9kZWwnO1xuXG4vKipcbiAqIFN1cHBvc2VkIHRvIGJlIGluamVjdGVkIGluIHRoZSBzcGxpdCB2aWV3IGNvbXBvbmVudCwgc28gdGhhdCB0aGUgc3BsaXQgdmlldyBzdGF0ZVxuICogaXMgbWFpbnRhaW5lZCBmb3IgYSBzaW5nbGUgc3BsaXQgdmlldy5cbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFNwbGl0Vmlld1NlcnZpY2Uge1xuICAvKipcbiAgICogTmV3bHkgYWRkZWQgdmlld3MgYXJlIGhpZGRlbiBieSBkZWZhdWx0LCB1bmxlc3MgaXQgaXMgdGhlIGZpcnN0IHZpZXcgb2YgdGhlIHNwbGl0IHZpZXcuXG4gICAqIFRoZSBkZWZhdWx0IGhpZGUgbW9kZSBjYW4gYmUgb3ZlcnJpZGRlbi5cbiAgICovXG4gIGRlZmF1bHRIaWRlTW9kZSA9IHRydWU7XG5cbiAgcHJvdGVjdGVkIHNwbGl0Vmlld0NvdW50ID0gMTtcblxuICBwcm90ZWN0ZWQgX3ZpZXdzJDogQmVoYXZpb3JTdWJqZWN0PGFueVtdPiA9IG5ldyBCZWhhdmlvclN1YmplY3QoW10pO1xuXG4gIC8qKlxuICAgKiBBZGRzIGEgdmlldyB0byB0aGUgbGlzdCBvZiB2aWV3cy4gVGhlIHZpZXcgaXMgaW5pdGlhbGl6ZWQgd2l0aCB0aGUgYFNwbGl0Vmlld1N0YXRlYFxuICAgKiBzdGF0ZS4gSWYgbm8gc3RhdGUgaXMgcHJvdmlkZWQsIHRoZSBzdGF0ZSBpcyBjcmVhdGVkIHdpdGggdGhlIGhpZGRlbiBwcm9wZXJ0eS4gVGhlIGhpZGRlblxuICAgKiBwcm9wZXJ0eSBpcyBwcm92aWRlZCBieSB0aGUgYGRlZmF1bHRIaWRlTW9kZWAsIHVubGVzcyBpdCdzIHRoZSBmaXJzdCB2aWV3IChwb3NpdGlvbjogMCkuXG4gICAqL1xuICBhZGQocG9zaXRpb246IG51bWJlciwgaW5pdGlhbFN0YXRlPzogU3BsaXRWaWV3U3RhdGUpIHtcbiAgICBjb25zdCBzdGF0ZTogU3BsaXRWaWV3U3RhdGUgPSB7XG4gICAgICAuLi57IGhpZGRlbjogcG9zaXRpb24gPT09IDAgPyBmYWxzZSA6IHRoaXMuZGVmYXVsdEhpZGVNb2RlIH0sXG4gICAgICAuLi5pbml0aWFsU3RhdGUsXG4gICAgfTtcbiAgICBpZiAoIXRoaXMudmlld3NbcG9zaXRpb25dKSB7XG4gICAgICB0aGlzLnZpZXdzW3Bvc2l0aW9uXSA9IHN0YXRlO1xuICAgICAgdGhpcy51cGRhdGVTdGF0ZShwb3NpdGlvbiwgc3RhdGUuaGlkZGVuKTtcbiAgICAgIHRoaXMuX3ZpZXdzJC5uZXh0KHRoaXMudmlld3MpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgc3BsaXQgdmlldyBpcyBiYXNlZCBvbiBhIG51bWJlciBvZiB2aWV3cyB0aGF0IGNhbiBiZSB1c2VkIG5leHQgdG8gZWFjaCBvdGhlci5cbiAgICogV2hlbiB0aGUgbnVtYmVyIGNoYW5nZXMgKGkuZS4gaWYgdGhlIHNjcmVlbiBnb2VzIGZyb20gd2lkZSB0byBzbWFsbCksIHRoZSB2aXNpYmlsaXR5IHN0YXRlXG4gICAqIG9mIHRoZSB2aWV3cyBzaG91bGQgYmUgdXBkYXRlZC5cbiAgICovXG4gIHVwZGF0ZVNwbGl0VmlldyhzcGxpdFZpZXdDb3VudDogbnVtYmVyKSB7XG4gICAgaWYgKHNwbGl0Vmlld0NvdW50ICE9PSB0aGlzLnNwbGl0Vmlld0NvdW50KSB7XG4gICAgICB0aGlzLnNwbGl0Vmlld0NvdW50ID0gc3BsaXRWaWV3Q291bnQ7XG4gICAgICB0aGlzLnVwZGF0ZVN0YXRlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gb2JzZXJ2YWJsZSB3aXRoIHRoZSBhY3RpdmUgdmlldyBudW1iZXIuIFRoZSBhY3RpdmUgdmlldyBudW1iZXJcbiAgICogcmVwcmVzZW50cyB0aGUgbGFzdCB2aXNpYmxlIHZpZXcuXG4gICAqL1xuICBnZXRBY3RpdmVWaWV3KCk6IE9ic2VydmFibGU8bnVtYmVyPiB7XG4gICAgcmV0dXJuIHRoaXMuX3ZpZXdzJC5waXBlKFxuICAgICAgbWFwKCh2aWV3cykgPT4gdGhpcy5nZXRBY3RpdmUodmlld3MpKSxcbiAgICAgIGRpc3RpbmN0VW50aWxDaGFuZ2VkKClcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gb2JzZXJ2YWJsZSB3aXRoIHRoZSBTcGxpdFZpZXdTdGF0ZSBmb3IgdGhlIGdpdmVuIHZpZXcgcG9zaXRpb24uXG4gICAqL1xuICBnZXRWaWV3U3RhdGUocG9zaXRpb246IG51bWJlcik6IE9ic2VydmFibGU8U3BsaXRWaWV3U3RhdGU+IHtcbiAgICByZXR1cm4gdGhpcy5fdmlld3MkLnBpcGUoXG4gICAgICBtYXAoKHZpZXdzKSA9PiB2aWV3c1twb3NpdGlvbl0pLFxuICAgICAgLy8gd2UgbXVzdCBmaWx0ZXIgaGVyZSwgc2luY2Ugb3V0bGV0IGRyaXZlbiB2aWV3cyB3aWxsIGRlc3Ryb3llZCB0aGUgdmlld1xuICAgICAgZmlsdGVyKCh2aWV3KSA9PiBCb29sZWFuKHZpZXcpKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhIHZpZXcgZnJvbSB0aGUgbGlzdCBvZiB2aWV3cy5cbiAgICpcbiAgICogUmVtb3ZpbmcgYSB2aWV3IGlzIGRpZmZlcmVudCBmcm9tIGhpZGluZyBhIHZpZXcuIFJlbW92aW5nIGEgdmlldyBpcyB0eXBpY2FsbHkgZG9uZVxuICAgKiB3aGVuIGEgY29tcG9uZW50IGlzIGRlc3Ryb3llZC5cbiAgICpcbiAgICogV2hlbiB0aGUgdmlldyBpcyByZW1vdmVkLCB0aGUgU3BsaXRWaWV3U3RhdGUgaXMgdXBkYXRlZCB0byByZWZsZWN0IHRoYXQgbmV3IG9yZ2FuaXphdGlvblxuICAgKiBvZiB2aWV3cy5cbiAgICovXG4gIHJlbW92ZShwb3NpdGlvbjogbnVtYmVyKSB7XG4gICAgY29uc3QgYWN0aXZlUG9zaXRpb24gPSB0aGlzLmdldEFjdGl2ZSh0aGlzLnZpZXdzKTtcbiAgICB0aGlzLl92aWV3cyQubmV4dCh0aGlzLnZpZXdzLnNwbGljZSgwLCBwb3NpdGlvbikpO1xuICAgIGlmIChhY3RpdmVQb3NpdGlvbiA+PSBwb3NpdGlvbikge1xuICAgICAgdGhpcy51cGRhdGVTdGF0ZShwb3NpdGlvbik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG5leHQgdmlldyBwb3NpdGlvbi4gVGhpcyBpcyB1c2VmdWwgZm9yIHZpZXdzIHRoYXQgZG8gbm90IHdhbnQgdG8gYmUgYm90aGVyZWRcbiAgICogd2l0aCBjb250cm9sbGluZyB2aWV3IG51bWJlcnMuXG4gICAqL1xuICBnZXQgbmV4dFBvc2l0aW9uKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMudmlld3MubGVuZ3RoIHx8IDA7XG4gIH1cblxuICAvKipcbiAgICogVG9nZ2xlcyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgdmlld3MgYmFzZWQgb24gdGhlIGdpdmVuIHZpZXcgcG9zaXRpb24uIElmIHRoZSB2aWV3XG4gICAqIGlzIGFscmVhZHkgdmlzaWJsZSwgd2UgY2xvc2UgdGhlIHZpZXcgYW5kIGFjdGl2ZSB0aGUgZm9ybWVyIHZpZXcuIFVubGVzcyB0aGUgaGlkZSBmbGFnXG4gICAqIGlzIHVzZWQsIHRvIGZvcmNlIHRoZSB2aWV3LlxuICAgKlxuICAgKiBUaGUgdmlldyBzdGF0ZSBvZiBvdGhlciB2aWV3cyBpbiB0aGUgc3BsaXQgdmlldyBhcmUgdXBkYXRlZCBhcyB3ZWxsLlxuICAgKlxuICAgKiBAcGFyYW0gcG9zaXRpb24gVGhlIHplcm8tYmFzZWQgcG9zaXRpb24gbnVtYmVyIG9mIHRoZSB2aWV3LlxuICAgKiBAcGFyYW0gZm9yY2VIaWRlIFRoZSAob3B0aW9uYWwpIGhpZGUgc3RhdGUgZm9yIHRoZSB2aWV3IHBvc2l0aW9uLlxuICAgKi9cbiAgdG9nZ2xlKHBvc2l0aW9uOiBudW1iZXIsIGZvcmNlSGlkZT86IGJvb2xlYW4pIHtcbiAgICAvLyBhZGQgdGhlIHZpZXcgaWYgaXQgaGFzbid0IGJlZW4gYWRkZWQgYmVmb3JlLlxuICAgIGlmICghdGhpcy52aWV3c1twb3NpdGlvbl0pIHtcbiAgICAgIHRoaXMuYWRkKHBvc2l0aW9uLCB7IGhpZGRlbjogZm9yY2VIaWRlID8/IGZhbHNlIH0pO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSBwb3NpdGlvbiBpcyBhbHJlYWR5IHZpc2libGUsIHdlIG1vdmUgdG8gYSBwcmV2aW91cyBwb3NpdGlvbi4gT25seSBpZiB0aGUgaGlkZVxuICAgIC8vIHN0YXRlIGlzIGZvcmNlZCwgd2Uga2VlcCB0aGUgY3VycmVudCBwb3NpdGlvbi5cbiAgICBpZiAoXG4gICAgICB0aGlzLnZpZXdzW3Bvc2l0aW9uXSAmJlxuICAgICAgZm9yY2VIaWRlID09PSB1bmRlZmluZWQgJiZcbiAgICAgICF0aGlzLnZpZXdzW3Bvc2l0aW9uXS5oaWRkZW5cbiAgICApIHtcbiAgICAgIHBvc2l0aW9uLS07XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVTdGF0ZShwb3NpdGlvbiwgZm9yY2VIaWRlID09PSB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBoaWRkZW4gc3RhdGUgb2YgYWxsIHRoZSB2aWV3cy5cbiAgICovXG4gIHByb3RlY3RlZCB1cGRhdGVTdGF0ZShwb3NpdGlvbj86IG51bWJlciwgaGlkZT86IGJvb2xlYW4pIHtcbiAgICBjb25zdCB2aWV3cyA9IFsuLi50aGlzLnZpZXdzXTtcbiAgICBpZiAoaGlkZSAhPT0gdW5kZWZpbmVkICYmIHZpZXdzW3Bvc2l0aW9uXSkge1xuICAgICAgdmlld3NbcG9zaXRpb25dLmhpZGRlbiA9IGhpZGU7XG4gICAgfVxuICAgIGxldCBsYXN0VmlzaWJsZSA9XG4gICAgICB2aWV3cy5sZW5ndGggLSBbLi4udmlld3NdLnJldmVyc2UoKS5maW5kSW5kZXgoKHZpZXcpID0+ICF2aWV3LmhpZGRlbikgLSAxO1xuXG4gICAgaWYgKGxhc3RWaXNpYmxlID09PSB2aWV3cy5sZW5ndGgpIHtcbiAgICAgIGlmIChwb3NpdGlvbikge1xuICAgICAgICAvLyBXaGVuIHRoZXJlJ3Mgb25seSAxIHZpZXcgKG1vYmlsZSksIHdlIG1pZ2h0IG5vdCBmaW5kIGFueSBhY3RpdmVcbiAgICAgICAgLy8gaWYgdGhlIHVzZXIgbmF2aWdhdGVzIGJhY2suXG4gICAgICAgIGxhc3RWaXNpYmxlID0gcG9zaXRpb24gLSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGFzdFZpc2libGUgPSB2aWV3cy5sZW5ndGggLSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZpZXdzLmZvckVhY2goKHZpZXcsIHBvcykgPT4ge1xuICAgICAgaWYgKHZpZXcgJiYgcG9zICE9PSBwb3NpdGlvbikge1xuICAgICAgICAvLyBoaWRlIG90aGVyIHZpZXdzIHRoYXQgYXJlIG91dHNpZGUgdGhlIHNwbGl0IHZpZXdcbiAgICAgICAgdmlldy5oaWRkZW4gPVxuICAgICAgICAgIHBvcyA+IGxhc3RWaXNpYmxlIHx8IHBvcyA8IGxhc3RWaXNpYmxlIC0gKHRoaXMuc3BsaXRWaWV3Q291bnQgLSAxKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMuX3ZpZXdzJC5uZXh0KHZpZXdzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhY3RpdmUgdmlldyBjb3VudCBmb3IgdGhlIGxpc3Qgb2Ygdmlld3MuXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0QWN0aXZlKHZpZXdzOiBTcGxpdFZpZXdTdGF0ZVtdKTogbnVtYmVyIHtcbiAgICAvLyB3ZSByZXZlcnNlIHRoZSBsaXN0IHRvIGZpbmQgdGhlIGxhc3QgdmlzaWJsZSB2aWV3XG4gICAgY29uc3QgbCA9IFsuLi52aWV3c11cbiAgICAgIC5yZXZlcnNlKClcbiAgICAgIC5maW5kSW5kZXgoKHZpZXc6IFNwbGl0Vmlld1N0YXRlKSA9PiAhdmlldy5oaWRkZW4pO1xuICAgIGNvbnN0IGxhc3QgPSBsID09PSAtMSA/IDAgOiB2aWV3cy5sZW5ndGggLSBsIC0gMTtcbiAgICByZXR1cm4gbGFzdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVdGlsaXR5IG1ldGhvZCB0aGF0IHJlc29sdmVzIGFsbCB2aWV3cyBmcm9tIHRoZSBzdWJqZWN0LlxuICAgKi9cbiAgcHJvdGVjdGVkIGdldCB2aWV3cygpOiBTcGxpdFZpZXdTdGF0ZVtdIHtcbiAgICByZXR1cm4gdGhpcy5fdmlld3MkLnZhbHVlO1xuICB9XG59XG4iXX0=