import { ChangeDetectionStrategy, Component, EventEmitter, Input, Output, } from '@angular/core';
import * as i0 from "@angular/core";
import * as i1 from "@ng-select/ng-select";
import * as i2 from "@angular/forms";
import * as i3 from "@angular/common";
export class SortingComponent {
    constructor() {
        this.sortListEvent = new EventEmitter();
    }
    sortList(sortCode) {
        this.sortListEvent.emit(sortCode);
    }
    get selectedLabel() {
        var _a, _b, _c, _d;
        return ((_c = (_b = (_a = this.sortOptions) === null || _a === void 0 ? void 0 : _a.find((sort) => sort.code === this.selectedOption)) === null || _b === void 0 ? void 0 : _b.name) !== null && _c !== void 0 ? _c : (_d = this.sortLabels) === null || _d === void 0 ? void 0 : _d[this.selectedOption]);
    }
}
SortingComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SortingComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
SortingComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: SortingComponent, selector: "cx-sorting", inputs: { sortOptions: "sortOptions", selectedOption: "selectedOption", placeholder: "placeholder", sortLabels: "sortLabels" }, outputs: { sortListEvent: "sortListEvent" }, ngImport: i0, template: "<ng-select\n  [searchable]=\"false\"\n  [clearable]=\"false\"\n  placeholder=\"{{ placeholder }}\"\n  (change)=\"sortList($event)\"\n  [ngModel]=\"selectedOption\"\n  [attr.aria-label]=\"selectedLabel || placeholder\"\n>\n  <ng-option *ngFor=\"let sort of sortOptions\" [value]=\"sort.code\">{{\n    sort.name ? sort.name : sortLabels ? sortLabels[sort.code] : ''\n  }}</ng-option>\n</ng-select>\n", components: [{ type: i1.NgSelectComponent, selector: "ng-select", inputs: ["markFirst", "dropdownPosition", "loading", "closeOnSelect", "hideSelected", "selectOnTab", "bufferAmount", "selectableGroup", "selectableGroupAsModel", "searchFn", "trackByFn", "clearOnBackspace", "labelForId", "inputAttrs", "readonly", "searchWhileComposing", "minTermLength", "editableSearchTerm", "keyDownFn", "multiple", "addTag", "searchable", "clearable", "isOpen", "items", "compareWith", "clearSearchOnAdd", "bindLabel", "placeholder", "notFoundText", "typeToSearchText", "addTagText", "loadingText", "clearAllText", "virtualScroll", "openOnEnter", "appendTo", "bindValue", "appearance", "maxSelectedItems", "groupBy", "groupValue", "tabIndex", "typeahead"], outputs: ["blur", "focus", "change", "open", "close", "search", "clear", "add", "remove", "scroll", "scrollToEnd"] }, { type: i1.ɵr, selector: "ng-option", inputs: ["disabled", "value"] }], directives: [{ type: i2.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i2.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SortingComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-sorting',
                    templateUrl: './sorting.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return []; }, propDecorators: { sortOptions: [{
                type: Input
            }], selectedOption: [{
                type: Input
            }], placeholder: [{
                type: Input
            }], sortLabels: [{
                type: Input
            }], sortListEvent: [{
                type: Output
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic29ydGluZy5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9zdG9yZWZyb250bGliL3NoYXJlZC9jb21wb25lbnRzL2xpc3QtbmF2aWdhdGlvbi9zb3J0aW5nL3NvcnRpbmcuY29tcG9uZW50LnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvc3RvcmVmcm9udGxpYi9zaGFyZWQvY29tcG9uZW50cy9saXN0LW5hdmlnYXRpb24vc29ydGluZy9zb3J0aW5nLmNvbXBvbmVudC5odG1sIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDTCx1QkFBdUIsRUFDdkIsU0FBUyxFQUNULFlBQVksRUFDWixLQUFLLEVBQ0wsTUFBTSxHQUNQLE1BQU0sZUFBZSxDQUFDOzs7OztBQVF2QixNQUFNLE9BQU8sZ0JBQWdCO0lBYTNCO1FBQ0UsSUFBSSxDQUFDLGFBQWEsR0FBRyxJQUFJLFlBQVksRUFBVSxDQUFDO0lBQ2xELENBQUM7SUFFRCxRQUFRLENBQUMsUUFBZ0I7UUFDdkIsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDcEMsQ0FBQztJQUVELElBQUksYUFBYTs7UUFDZixPQUFPLENBQ0wsTUFBQSxNQUFBLE1BQUEsSUFBSSxDQUFDLFdBQVcsMENBQUUsSUFBSSxDQUFDLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxLQUFLLElBQUksQ0FBQyxjQUFjLENBQUMsMENBQy9ELElBQUksbUNBQUksTUFBQSxJQUFJLENBQUMsVUFBVSwwQ0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQ25ELENBQUM7SUFDSixDQUFDOzs2R0ExQlUsZ0JBQWdCO2lHQUFoQixnQkFBZ0IsK05DZDdCLCtZQVlBOzJGREVhLGdCQUFnQjtrQkFMNUIsU0FBUzttQkFBQztvQkFDVCxRQUFRLEVBQUUsWUFBWTtvQkFDdEIsV0FBVyxFQUFFLDBCQUEwQjtvQkFDdkMsZUFBZSxFQUFFLHVCQUF1QixDQUFDLE1BQU07aUJBQ2hEOzBFQUdDLFdBQVc7c0JBRFYsS0FBSztnQkFHTixjQUFjO3NCQURiLEtBQUs7Z0JBR04sV0FBVztzQkFEVixLQUFLO2dCQUdOLFVBQVU7c0JBRFQsS0FBSztnQkFJTixhQUFhO3NCQURaLE1BQU0iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgQ29tcG9uZW50LFxuICBFdmVudEVtaXR0ZXIsXG4gIElucHV0LFxuICBPdXRwdXQsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU29ydE1vZGVsIH0gZnJvbSAnQHNwYXJ0YWN1cy9jb3JlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY3gtc29ydGluZycsXG4gIHRlbXBsYXRlVXJsOiAnLi9zb3J0aW5nLmNvbXBvbmVudC5odG1sJyxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG59KVxuZXhwb3J0IGNsYXNzIFNvcnRpbmdDb21wb25lbnQge1xuICBASW5wdXQoKVxuICBzb3J0T3B0aW9uczogU29ydE1vZGVsW107XG4gIEBJbnB1dCgpXG4gIHNlbGVjdGVkT3B0aW9uOiBzdHJpbmc7XG4gIEBJbnB1dCgpXG4gIHBsYWNlaG9sZGVyOiBzdHJpbmc7XG4gIEBJbnB1dCgpXG4gIHNvcnRMYWJlbHM6IHsgW2NvZGU6IHN0cmluZ106IHN0cmluZyB9O1xuXG4gIEBPdXRwdXQoKVxuICBzb3J0TGlzdEV2ZW50OiBFdmVudEVtaXR0ZXI8c3RyaW5nPjtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnNvcnRMaXN0RXZlbnQgPSBuZXcgRXZlbnRFbWl0dGVyPHN0cmluZz4oKTtcbiAgfVxuXG4gIHNvcnRMaXN0KHNvcnRDb2RlOiBzdHJpbmcpOiB2b2lkIHtcbiAgICB0aGlzLnNvcnRMaXN0RXZlbnQuZW1pdChzb3J0Q29kZSk7XG4gIH1cblxuICBnZXQgc2VsZWN0ZWRMYWJlbCgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5zb3J0T3B0aW9ucz8uZmluZCgoc29ydCkgPT4gc29ydC5jb2RlID09PSB0aGlzLnNlbGVjdGVkT3B0aW9uKVxuICAgICAgICA/Lm5hbWUgPz8gdGhpcy5zb3J0TGFiZWxzPy5bdGhpcy5zZWxlY3RlZE9wdGlvbl1cbiAgICApO1xuICB9XG59XG4iLCI8bmctc2VsZWN0XG4gIFtzZWFyY2hhYmxlXT1cImZhbHNlXCJcbiAgW2NsZWFyYWJsZV09XCJmYWxzZVwiXG4gIHBsYWNlaG9sZGVyPVwie3sgcGxhY2Vob2xkZXIgfX1cIlxuICAoY2hhbmdlKT1cInNvcnRMaXN0KCRldmVudClcIlxuICBbbmdNb2RlbF09XCJzZWxlY3RlZE9wdGlvblwiXG4gIFthdHRyLmFyaWEtbGFiZWxdPVwic2VsZWN0ZWRMYWJlbCB8fCBwbGFjZWhvbGRlclwiXG4+XG4gIDxuZy1vcHRpb24gKm5nRm9yPVwibGV0IHNvcnQgb2Ygc29ydE9wdGlvbnNcIiBbdmFsdWVdPVwic29ydC5jb2RlXCI+e3tcbiAgICBzb3J0Lm5hbWUgPyBzb3J0Lm5hbWUgOiBzb3J0TGFiZWxzID8gc29ydExhYmVsc1tzb3J0LmNvZGVdIDogJydcbiAgfX08L25nLW9wdGlvbj5cbjwvbmctc2VsZWN0PlxuIl19