import { Component, Input } from '@angular/core';
import * as i0 from "@angular/core";
import * as i1 from "@angular/router";
import * as i2 from "./generic-link-component.service";
import * as i3 from "@angular/common";
/**
 * This component navigates using [routerLink] attribute when input 'url' is a relative url. Otherwise (when it's absolute), [href] is used.
 */
export class GenericLinkComponent {
    constructor(router, service) {
        this.router = router;
        this.service = service;
        /**
         * Pattern matching string starting with `http://` or `https://`.
         */
        this.PROTOCOL_REGEX = /^https?:\/\//i;
        /**
         * Pattern matching string starting with `mailto:`.
         */
        this.MAILTO_PROTOCOL_REGEX = /^mailto:/i;
        /**
         * Pattern matching string starting with `tel:`.
         */
        this.TEL_PROTOCOL_REGEX = /^tel:/i;
        /**
         * Used to split url into 2 parts:
         * 1. the path
         * 2. query params + hash fragment
         */
        this.URL_SPLIT = /(^[^#?]*)(.*)/;
        /**
         * Parsed parts of the @Input `url`, when it's a local URL.
         * It should not be used when the `url` is external.
         * @see `url`
         */
        this.routeParts = {};
    }
    isExternalUrl() {
        var _a;
        return (((_a = this.service) === null || _a === void 0 ? void 0 : _a.isExternalUrl(this.url)) ||
            (typeof this.url === 'string' &&
                (this.PROTOCOL_REGEX.test(this.url) ||
                    this.MAILTO_PROTOCOL_REGEX.test(this.url) ||
                    this.TEL_PROTOCOL_REGEX.test(this.url))));
    }
    get rel() {
        return this.target === '_blank' ? 'noopener' : null;
    }
    ngOnChanges(changes) {
        if (changes['url']) {
            this.setUrlParts(changes['url'].currentValue);
        }
    }
    /**
     * The part with the path of the local url.
     */
    get routerUrl() {
        return this.routeParts.path;
    }
    /**
     * The part with the query params of the local url.
     */
    get queryParams() {
        return this.routeParts.queryParams;
    }
    /**
     * The part with the hash fragment of the local url.
     */
    get fragment() {
        return this.routeParts.fragment;
    }
    /**
     * Parses the given url and sets the property `urlParts` accordingly.
     */
    setUrlParts(url) {
        if (typeof url === 'string') {
            url = this.getAbsoluteUrl(url); // string links in CMS sometimes don't have the leading slash, so fix it here
            this.routeParts = this.splitUrl(url);
        }
        else {
            this.routeParts = { path: url };
        }
    }
    /**
     * Parses the given string into 3 parts:
     * - string path (wrapped in an array to be compatible with Angular syntax for the `routerLink`)
     * - query params (as an object)
     * - hash fragment (string)
     */
    splitUrl(url = '') {
        const { queryParams, fragment } = this.router.parseUrl(url);
        const [, path] = url.match(this.URL_SPLIT);
        // wrap path in an array, to have the Angular-like path format
        return { path: [path], queryParams, fragment };
    }
    /**
     * Prepends a leading slash to the given URL string, in case it doesn't have it.
     */
    getAbsoluteUrl(url) {
        return url.startsWith('/') ? url : '/' + url;
    }
}
GenericLinkComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: GenericLinkComponent, deps: [{ token: i1.Router }, { token: i2.GenericLinkComponentService }], target: i0.ɵɵFactoryTarget.Component });
GenericLinkComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: GenericLinkComponent, selector: "cx-generic-link", inputs: { url: "url", target: "target", id: "id", class: "class", style: "style", title: "title" }, usesOnChanges: true, ngImport: i0, template: "<!-- https://github.com/angular/angular/issues/24567 -->\n\n<ng-container *ngIf=\"isExternalUrl(); else isLocalUrl\">\n  <a\n    [href]=\"url\"\n    [attr.target]=\"target\"\n    [attr.rel]=\"rel\"\n    [attr.id]=\"id\"\n    [attr.class]=\"class\"\n    [attr.style]=\"style\"\n    [attr.title]=\"title\"\n  >\n    <ng-container *ngTemplateOutlet=\"content\"></ng-container>\n  </a>\n</ng-container>\n\n<ng-template #isLocalUrl>\n  <a\n    [routerLink]=\"routerUrl\"\n    [queryParams]=\"queryParams\"\n    [fragment]=\"fragment\"\n    [target]=\"target\"\n    [attr.id]=\"id\"\n    [attr.class]=\"class\"\n    [attr.style]=\"style\"\n    [attr.title]=\"title\"\n  >\n    <ng-container *ngTemplateOutlet=\"content\"></ng-container>\n  </a>\n</ng-template>\n\n<ng-template #content>\n  <ng-content></ng-content>\n</ng-template>\n", directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }, { type: i1.RouterLinkWithHref, selector: "a[routerLink],area[routerLink]", inputs: ["routerLink", "target", "queryParams", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange", "replaceUrl", "state", "relativeTo"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: GenericLinkComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-generic-link',
                    templateUrl: './generic-link.component.html',
                }]
        }], ctorParameters: function () { return [{ type: i1.Router }, { type: i2.GenericLinkComponentService }]; }, propDecorators: { url: [{
                type: Input
            }], target: [{
                type: Input
            }], id: [{
                type: Input
            }], class: [{
                type: Input
            }], style: [{
                type: Input
            }], title: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VuZXJpYy1saW5rLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL3N0b3JlZnJvbnRsaWIvc2hhcmVkL2NvbXBvbmVudHMvZ2VuZXJpYy1saW5rL2dlbmVyaWMtbGluay5jb21wb25lbnQudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9zdG9yZWZyb250bGliL3NoYXJlZC9jb21wb25lbnRzL2dlbmVyaWMtbGluay9nZW5lcmljLWxpbmsuY29tcG9uZW50Lmh0bWwiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQTRCLE1BQU0sZUFBZSxDQUFDOzs7OztBQWdCM0U7O0dBRUc7QUFLSCxNQUFNLE9BQU8sb0JBQW9CO0lBMkIvQixZQUNZLE1BQWMsRUFDZCxPQUFxQztRQURyQyxXQUFNLEdBQU4sTUFBTSxDQUFRO1FBQ2QsWUFBTyxHQUFQLE9BQU8sQ0FBOEI7UUE1QmpEOztXQUVHO1FBQ2MsbUJBQWMsR0FBVyxlQUFlLENBQUM7UUFFMUQ7O1dBRUc7UUFDTywwQkFBcUIsR0FBVyxXQUFXLENBQUM7UUFFdEQ7O1dBRUc7UUFDTyx1QkFBa0IsR0FBVyxRQUFRLENBQUM7UUFrQmhEOzs7O1dBSUc7UUFDYyxjQUFTLEdBQUcsZUFBZSxDQUFDO1FBRTdDOzs7O1dBSUc7UUFDSyxlQUFVLEdBQWUsRUFBRSxDQUFDO0lBZGpDLENBQUM7SUF1QkosYUFBYTs7UUFDWCxPQUFPLENBQ0wsQ0FBQSxNQUFBLElBQUksQ0FBQyxPQUFPLDBDQUFFLGFBQWEsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDO1lBQ3JDLENBQUMsT0FBTyxJQUFJLENBQUMsR0FBRyxLQUFLLFFBQVE7Z0JBQzNCLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQztvQkFDakMsSUFBSSxDQUFDLHFCQUFxQixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDO29CQUN6QyxJQUFJLENBQUMsa0JBQWtCLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQzdDLENBQUM7SUFDSixDQUFDO0lBRUQsSUFBSSxHQUFHO1FBQ0wsT0FBTyxJQUFJLENBQUMsTUFBTSxLQUFLLFFBQVEsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUM7SUFDdEQsQ0FBQztJQUVELFdBQVcsQ0FBQyxPQUFzQjtRQUNoQyxJQUFJLE9BQU8sQ0FBQyxLQUFLLENBQUMsRUFBRTtZQUNsQixJQUFJLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxZQUFZLENBQUMsQ0FBQztTQUMvQztJQUNILENBQUM7SUFFRDs7T0FFRztJQUNILElBQUksU0FBUztRQUNYLE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUM7SUFDOUIsQ0FBQztJQUVEOztPQUVHO0lBQ0gsSUFBSSxXQUFXO1FBQ2IsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQztJQUNyQyxDQUFDO0lBRUQ7O09BRUc7SUFDSCxJQUFJLFFBQVE7UUFDVixPQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDO0lBQ2xDLENBQUM7SUFFRDs7T0FFRztJQUNLLFdBQVcsQ0FBQyxHQUFtQjtRQUNyQyxJQUFJLE9BQU8sR0FBRyxLQUFLLFFBQVEsRUFBRTtZQUMzQixHQUFHLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLDZFQUE2RTtZQUM3RyxJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBYSxDQUFDLENBQUM7U0FDaEQ7YUFBTTtZQUNMLElBQUksQ0FBQyxVQUFVLEdBQUcsRUFBRSxJQUFJLEVBQUUsR0FBRyxFQUFFLENBQUM7U0FDakM7SUFDSCxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSyxRQUFRLENBQUMsTUFBYyxFQUFFO1FBQy9CLE1BQU0sRUFBRSxXQUFXLEVBQUUsUUFBUSxFQUFFLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDNUQsTUFBTSxDQUFDLEVBQUUsSUFBSSxDQUFDLEdBQUcsR0FBRyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7UUFFM0MsOERBQThEO1FBQzlELE9BQU8sRUFBRSxJQUFJLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRSxXQUFXLEVBQUUsUUFBUSxFQUFFLENBQUM7SUFDakQsQ0FBQztJQUVEOztPQUVHO0lBQ0ssY0FBYyxDQUFDLEdBQVc7UUFDaEMsT0FBTyxHQUFHLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUM7SUFDL0MsQ0FBQzs7aUhBN0hVLG9CQUFvQjtxR0FBcEIsb0JBQW9CLGdMQ3ZCakMsNnpCQWtDQTsyRkRYYSxvQkFBb0I7a0JBSmhDLFNBQVM7bUJBQUM7b0JBQ1QsUUFBUSxFQUFFLGlCQUFpQjtvQkFDM0IsV0FBVyxFQUFFLCtCQUErQjtpQkFDN0M7dUlBK0NVLEdBQUc7c0JBQVgsS0FBSztnQkFDRyxNQUFNO3NCQUFkLEtBQUs7Z0JBQ0csRUFBRTtzQkFBVixLQUFLO2dCQUNHLEtBQUs7c0JBQWIsS0FBSztnQkFDRyxLQUFLO3NCQUFiLEtBQUs7Z0JBQ0csS0FBSztzQkFBYixLQUFLIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCwgT25DaGFuZ2VzLCBTaW1wbGVDaGFuZ2VzIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBQYXJhbXMsIFJvdXRlciB9IGZyb20gJ0Bhbmd1bGFyL3JvdXRlcic7XG5pbXBvcnQgeyBHZW5lcmljTGlua0NvbXBvbmVudFNlcnZpY2UgfSBmcm9tICcuL2dlbmVyaWMtbGluay1jb21wb25lbnQuc2VydmljZSc7XG5cbi8vIHByaXZhdGVcbmludGVyZmFjZSBSb3V0ZVBhcnRzIHtcbiAgLyoqIFBhdGggaW4gdGhlIEFuZ3VsYXItbGlrZSBhcnJheSBmb3JtYXQgKi9cbiAgcGF0aD86IHN0cmluZ1tdO1xuXG4gIC8qKiBRdWVyeSBwYXJhbXMgKi9cbiAgcXVlcnlQYXJhbXM/OiBQYXJhbXM7XG5cbiAgLyoqIEhhc2ggZnJhZ21lbnQgKi9cbiAgZnJhZ21lbnQ/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogVGhpcyBjb21wb25lbnQgbmF2aWdhdGVzIHVzaW5nIFtyb3V0ZXJMaW5rXSBhdHRyaWJ1dGUgd2hlbiBpbnB1dCAndXJsJyBpcyBhIHJlbGF0aXZlIHVybC4gT3RoZXJ3aXNlICh3aGVuIGl0J3MgYWJzb2x1dGUpLCBbaHJlZl0gaXMgdXNlZC5cbiAqL1xuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY3gtZ2VuZXJpYy1saW5rJyxcbiAgdGVtcGxhdGVVcmw6ICcuL2dlbmVyaWMtbGluay5jb21wb25lbnQuaHRtbCcsXG59KVxuZXhwb3J0IGNsYXNzIEdlbmVyaWNMaW5rQ29tcG9uZW50IGltcGxlbWVudHMgT25DaGFuZ2VzIHtcbiAgLyoqXG4gICAqIFBhdHRlcm4gbWF0Y2hpbmcgc3RyaW5nIHN0YXJ0aW5nIHdpdGggYGh0dHA6Ly9gIG9yIGBodHRwczovL2AuXG4gICAqL1xuICBwcml2YXRlIHJlYWRvbmx5IFBST1RPQ09MX1JFR0VYOiBSZWdFeHAgPSAvXmh0dHBzPzpcXC9cXC8vaTtcblxuICAvKipcbiAgICogUGF0dGVybiBtYXRjaGluZyBzdHJpbmcgc3RhcnRpbmcgd2l0aCBgbWFpbHRvOmAuXG4gICAqL1xuICBwcm90ZWN0ZWQgTUFJTFRPX1BST1RPQ09MX1JFR0VYOiBSZWdFeHAgPSAvXm1haWx0bzovaTtcblxuICAvKipcbiAgICogUGF0dGVybiBtYXRjaGluZyBzdHJpbmcgc3RhcnRpbmcgd2l0aCBgdGVsOmAuXG4gICAqL1xuICBwcm90ZWN0ZWQgVEVMX1BST1RPQ09MX1JFR0VYOiBSZWdFeHAgPSAvXnRlbDovaTtcblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiA1LjBcbiAgICogVXNlIHRoZSBmb2xsb3dpbmcgY29uc3RydWN0b3IgaW5zdGVhZDpcbiAgICogYGBgXG4gICAqIGNvbnN0cnVjdG9yKFxuICAgKiAgIHByb3RlY3RlZCByb3V0ZXI6IFJvdXRlcixcbiAgICogICBwcm90ZWN0ZWQgc2VydmljZT86IEdlbmVyaWNMaW5rQ29tcG9uZW50U2VydmljZVxuICAgKiApXG4gICAqIGBgYFxuICAgKi9cbiAgY29uc3RydWN0b3Iocm91dGVyOiBSb3V0ZXIpO1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcm90ZWN0ZWQgcm91dGVyOiBSb3V0ZXIsXG4gICAgcHJvdGVjdGVkIHNlcnZpY2U/OiBHZW5lcmljTGlua0NvbXBvbmVudFNlcnZpY2VcbiAgKSB7fVxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIHNwbGl0IHVybCBpbnRvIDIgcGFydHM6XG4gICAqIDEuIHRoZSBwYXRoXG4gICAqIDIuIHF1ZXJ5IHBhcmFtcyArIGhhc2ggZnJhZ21lbnRcbiAgICovXG4gIHByaXZhdGUgcmVhZG9ubHkgVVJMX1NQTElUID0gLyheW14jP10qKSguKikvO1xuXG4gIC8qKlxuICAgKiBQYXJzZWQgcGFydHMgb2YgdGhlIEBJbnB1dCBgdXJsYCwgd2hlbiBpdCdzIGEgbG9jYWwgVVJMLlxuICAgKiBJdCBzaG91bGQgbm90IGJlIHVzZWQgd2hlbiB0aGUgYHVybGAgaXMgZXh0ZXJuYWwuXG4gICAqIEBzZWUgYHVybGBcbiAgICovXG4gIHByaXZhdGUgcm91dGVQYXJ0czogUm91dGVQYXJ0cyA9IHt9O1xuXG4gIEBJbnB1dCgpIHVybDogc3RyaW5nIHwgYW55W107XG4gIEBJbnB1dCgpIHRhcmdldDogc3RyaW5nIHwgbnVsbDtcbiAgQElucHV0KCkgaWQ6IHN0cmluZztcbiAgQElucHV0KCkgY2xhc3M6IHN0cmluZztcbiAgQElucHV0KCkgc3R5bGU6IHN0cmluZztcbiAgQElucHV0KCkgdGl0bGU6IHN0cmluZztcblxuICBpc0V4dGVybmFsVXJsKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLnNlcnZpY2U/LmlzRXh0ZXJuYWxVcmwodGhpcy51cmwpIHx8XG4gICAgICAodHlwZW9mIHRoaXMudXJsID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAodGhpcy5QUk9UT0NPTF9SRUdFWC50ZXN0KHRoaXMudXJsKSB8fFxuICAgICAgICAgIHRoaXMuTUFJTFRPX1BST1RPQ09MX1JFR0VYLnRlc3QodGhpcy51cmwpIHx8XG4gICAgICAgICAgdGhpcy5URUxfUFJPVE9DT0xfUkVHRVgudGVzdCh0aGlzLnVybCkpKVxuICAgICk7XG4gIH1cblxuICBnZXQgcmVsKCkge1xuICAgIHJldHVybiB0aGlzLnRhcmdldCA9PT0gJ19ibGFuaycgPyAnbm9vcGVuZXInIDogbnVsbDtcbiAgfVxuXG4gIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpIHtcbiAgICBpZiAoY2hhbmdlc1sndXJsJ10pIHtcbiAgICAgIHRoaXMuc2V0VXJsUGFydHMoY2hhbmdlc1sndXJsJ10uY3VycmVudFZhbHVlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGhlIHBhcnQgd2l0aCB0aGUgcGF0aCBvZiB0aGUgbG9jYWwgdXJsLlxuICAgKi9cbiAgZ2V0IHJvdXRlclVybCgpOiBhbnlbXSB7XG4gICAgcmV0dXJuIHRoaXMucm91dGVQYXJ0cy5wYXRoO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBwYXJ0IHdpdGggdGhlIHF1ZXJ5IHBhcmFtcyBvZiB0aGUgbG9jYWwgdXJsLlxuICAgKi9cbiAgZ2V0IHF1ZXJ5UGFyYW1zKCk6IFBhcmFtcyB7XG4gICAgcmV0dXJuIHRoaXMucm91dGVQYXJ0cy5xdWVyeVBhcmFtcztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgcGFydCB3aXRoIHRoZSBoYXNoIGZyYWdtZW50IG9mIHRoZSBsb2NhbCB1cmwuXG4gICAqL1xuICBnZXQgZnJhZ21lbnQoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5yb3V0ZVBhcnRzLmZyYWdtZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlcyB0aGUgZ2l2ZW4gdXJsIGFuZCBzZXRzIHRoZSBwcm9wZXJ0eSBgdXJsUGFydHNgIGFjY29yZGluZ2x5LlxuICAgKi9cbiAgcHJpdmF0ZSBzZXRVcmxQYXJ0cyh1cmw6IHN0cmluZyB8IGFueVtdKSB7XG4gICAgaWYgKHR5cGVvZiB1cmwgPT09ICdzdHJpbmcnKSB7XG4gICAgICB1cmwgPSB0aGlzLmdldEFic29sdXRlVXJsKHVybCk7IC8vIHN0cmluZyBsaW5rcyBpbiBDTVMgc29tZXRpbWVzIGRvbid0IGhhdmUgdGhlIGxlYWRpbmcgc2xhc2gsIHNvIGZpeCBpdCBoZXJlXG4gICAgICB0aGlzLnJvdXRlUGFydHMgPSB0aGlzLnNwbGl0VXJsKHVybCBhcyBzdHJpbmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJvdXRlUGFydHMgPSB7IHBhdGg6IHVybCB9O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZXMgdGhlIGdpdmVuIHN0cmluZyBpbnRvIDMgcGFydHM6XG4gICAqIC0gc3RyaW5nIHBhdGggKHdyYXBwZWQgaW4gYW4gYXJyYXkgdG8gYmUgY29tcGF0aWJsZSB3aXRoIEFuZ3VsYXIgc3ludGF4IGZvciB0aGUgYHJvdXRlckxpbmtgKVxuICAgKiAtIHF1ZXJ5IHBhcmFtcyAoYXMgYW4gb2JqZWN0KVxuICAgKiAtIGhhc2ggZnJhZ21lbnQgKHN0cmluZylcbiAgICovXG4gIHByaXZhdGUgc3BsaXRVcmwodXJsOiBzdHJpbmcgPSAnJyk6IFJvdXRlUGFydHMge1xuICAgIGNvbnN0IHsgcXVlcnlQYXJhbXMsIGZyYWdtZW50IH0gPSB0aGlzLnJvdXRlci5wYXJzZVVybCh1cmwpO1xuICAgIGNvbnN0IFssIHBhdGhdID0gdXJsLm1hdGNoKHRoaXMuVVJMX1NQTElUKTtcblxuICAgIC8vIHdyYXAgcGF0aCBpbiBhbiBhcnJheSwgdG8gaGF2ZSB0aGUgQW5ndWxhci1saWtlIHBhdGggZm9ybWF0XG4gICAgcmV0dXJuIHsgcGF0aDogW3BhdGhdLCBxdWVyeVBhcmFtcywgZnJhZ21lbnQgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcmVwZW5kcyBhIGxlYWRpbmcgc2xhc2ggdG8gdGhlIGdpdmVuIFVSTCBzdHJpbmcsIGluIGNhc2UgaXQgZG9lc24ndCBoYXZlIGl0LlxuICAgKi9cbiAgcHJpdmF0ZSBnZXRBYnNvbHV0ZVVybCh1cmw6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHVybC5zdGFydHNXaXRoKCcvJykgPyB1cmwgOiAnLycgKyB1cmw7XG4gIH1cbn1cbiIsIjwhLS0gaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvMjQ1NjcgLS0+XG5cbjxuZy1jb250YWluZXIgKm5nSWY9XCJpc0V4dGVybmFsVXJsKCk7IGVsc2UgaXNMb2NhbFVybFwiPlxuICA8YVxuICAgIFtocmVmXT1cInVybFwiXG4gICAgW2F0dHIudGFyZ2V0XT1cInRhcmdldFwiXG4gICAgW2F0dHIucmVsXT1cInJlbFwiXG4gICAgW2F0dHIuaWRdPVwiaWRcIlxuICAgIFthdHRyLmNsYXNzXT1cImNsYXNzXCJcbiAgICBbYXR0ci5zdHlsZV09XCJzdHlsZVwiXG4gICAgW2F0dHIudGl0bGVdPVwidGl0bGVcIlxuICA+XG4gICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cImNvbnRlbnRcIj48L25nLWNvbnRhaW5lcj5cbiAgPC9hPlxuPC9uZy1jb250YWluZXI+XG5cbjxuZy10ZW1wbGF0ZSAjaXNMb2NhbFVybD5cbiAgPGFcbiAgICBbcm91dGVyTGlua109XCJyb3V0ZXJVcmxcIlxuICAgIFtxdWVyeVBhcmFtc109XCJxdWVyeVBhcmFtc1wiXG4gICAgW2ZyYWdtZW50XT1cImZyYWdtZW50XCJcbiAgICBbdGFyZ2V0XT1cInRhcmdldFwiXG4gICAgW2F0dHIuaWRdPVwiaWRcIlxuICAgIFthdHRyLmNsYXNzXT1cImNsYXNzXCJcbiAgICBbYXR0ci5zdHlsZV09XCJzdHlsZVwiXG4gICAgW2F0dHIudGl0bGVdPVwidGl0bGVcIlxuICA+XG4gICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cImNvbnRlbnRcIj48L25nLWNvbnRhaW5lcj5cbiAgPC9hPlxuPC9uZy10ZW1wbGF0ZT5cblxuPG5nLXRlbXBsYXRlICNjb250ZW50PlxuICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG48L25nLXRlbXBsYXRlPlxuIl19