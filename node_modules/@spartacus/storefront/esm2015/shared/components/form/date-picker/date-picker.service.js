import { Injectable } from '@angular/core';
import * as i0 from "@angular/core";
/**
 * Service that provides the placeholder and input pattern for date pickers. This is
 * used in Spartacus to support browser that won't support the native html5 date picker
 * using `<input type="date">`.
 *
 * While the placeholder is configurable, you should be aware that the placeholder format
 * defaults to `yyyy-mm-dd` to align with Safaris limited support of ISO 8601.
 * Another consideration is the support of date formats in the backend. In case you change
 * this format, you might need to serialize the date to the supported date format in the
 * backend.
 *
 */
export class DatePickerService {
    get placeholder() {
        return 'yyyy-mm-dd';
    }
    /**
     * The default date pattern is based on the placeholder string;
     */
    get pattern() {
        return this.placeholder
            .replace('yyyy', '\\d{4}')
            .replace('mm', '\\d{1,2}')
            .replace('dd', '\\d{1,2}');
    }
    /**
     * Validates if the string based date value is a valid date.
     */
    isValidFormat(date, pattern) {
        const patternRegex = new RegExp(`^${pattern !== null && pattern !== void 0 ? pattern : this.pattern}$`);
        return patternRegex.test(date);
    }
    /**
     * Since Safari doesn't support proper date formats (ISO 8601), we need to do this
     * ourselves. We cannot rely on `new Date('2020-1-1')`. This will fail, only
     * `new Date('2020-01-01')` works.
     */
    getDate(value) {
        if (!value) {
            return;
        }
        const delimiter = this.placeholder
            .replace('yyyy', '')
            .replace('mm', '')
            .replace('dd', '')
            .substr(0, 1);
        const dateParts = value.split(delimiter);
        const placeholderParts = this.placeholder.split(delimiter);
        const y = placeholderParts.indexOf('yyyy');
        const m = placeholderParts.indexOf('mm');
        const d = placeholderParts.indexOf('dd');
        return new Date(Number(dateParts[y]), Number(dateParts[m]) - 1, Number(dateParts[d]));
    }
}
DatePickerService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: DatePickerService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
DatePickerService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: DatePickerService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: DatePickerService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZS1waWNrZXIuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL3N0b3JlZnJvbnRsaWIvc2hhcmVkL2NvbXBvbmVudHMvZm9ybS9kYXRlLXBpY2tlci9kYXRlLXBpY2tlci5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7O0FBRTNDOzs7Ozs7Ozs7OztHQVdHO0FBSUgsTUFBTSxPQUFPLGlCQUFpQjtJQUM1QixJQUFJLFdBQVc7UUFDYixPQUFPLFlBQVksQ0FBQztJQUN0QixDQUFDO0lBRUQ7O09BRUc7SUFDSCxJQUFJLE9BQU87UUFDVCxPQUFPLElBQUksQ0FBQyxXQUFXO2FBQ3BCLE9BQU8sQ0FBQyxNQUFNLEVBQUUsUUFBUSxDQUFDO2FBQ3pCLE9BQU8sQ0FBQyxJQUFJLEVBQUUsVUFBVSxDQUFDO2FBQ3pCLE9BQU8sQ0FBQyxJQUFJLEVBQUUsVUFBVSxDQUFDLENBQUM7SUFDL0IsQ0FBQztJQUVEOztPQUVHO0lBQ0gsYUFBYSxDQUFDLElBQVksRUFBRSxPQUFnQjtRQUMxQyxNQUFNLFlBQVksR0FBRyxJQUFJLE1BQU0sQ0FBQyxJQUFJLE9BQU8sYUFBUCxPQUFPLGNBQVAsT0FBTyxHQUFJLElBQUksQ0FBQyxPQUFPLEdBQUcsQ0FBQyxDQUFDO1FBQ2hFLE9BQU8sWUFBWSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNqQyxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILE9BQU8sQ0FBQyxLQUFhO1FBQ25CLElBQUksQ0FBQyxLQUFLLEVBQUU7WUFDVixPQUFPO1NBQ1I7UUFFRCxNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsV0FBVzthQUMvQixPQUFPLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQzthQUNuQixPQUFPLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQzthQUNqQixPQUFPLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQzthQUNqQixNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBRWhCLE1BQU0sU0FBUyxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUM7UUFFekMsTUFBTSxnQkFBZ0IsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUUzRCxNQUFNLENBQUMsR0FBRyxnQkFBZ0IsQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDM0MsTUFBTSxDQUFDLEdBQUcsZ0JBQWdCLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3pDLE1BQU0sQ0FBQyxHQUFHLGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUV6QyxPQUFPLElBQUksSUFBSSxDQUNiLE1BQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFDcEIsTUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFDeEIsTUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUNyQixDQUFDO0lBQ0osQ0FBQzs7OEdBcERVLGlCQUFpQjtrSEFBakIsaUJBQWlCLGNBRmhCLE1BQU07MkZBRVAsaUJBQWlCO2tCQUg3QixVQUFVO21CQUFDO29CQUNWLFVBQVUsRUFBRSxNQUFNO2lCQUNuQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuLyoqXG4gKiBTZXJ2aWNlIHRoYXQgcHJvdmlkZXMgdGhlIHBsYWNlaG9sZGVyIGFuZCBpbnB1dCBwYXR0ZXJuIGZvciBkYXRlIHBpY2tlcnMuIFRoaXMgaXNcbiAqIHVzZWQgaW4gU3BhcnRhY3VzIHRvIHN1cHBvcnQgYnJvd3NlciB0aGF0IHdvbid0IHN1cHBvcnQgdGhlIG5hdGl2ZSBodG1sNSBkYXRlIHBpY2tlclxuICogdXNpbmcgYDxpbnB1dCB0eXBlPVwiZGF0ZVwiPmAuXG4gKlxuICogV2hpbGUgdGhlIHBsYWNlaG9sZGVyIGlzIGNvbmZpZ3VyYWJsZSwgeW91IHNob3VsZCBiZSBhd2FyZSB0aGF0IHRoZSBwbGFjZWhvbGRlciBmb3JtYXRcbiAqIGRlZmF1bHRzIHRvIGB5eXl5LW1tLWRkYCB0byBhbGlnbiB3aXRoIFNhZmFyaXMgbGltaXRlZCBzdXBwb3J0IG9mIElTTyA4NjAxLlxuICogQW5vdGhlciBjb25zaWRlcmF0aW9uIGlzIHRoZSBzdXBwb3J0IG9mIGRhdGUgZm9ybWF0cyBpbiB0aGUgYmFja2VuZC4gSW4gY2FzZSB5b3UgY2hhbmdlXG4gKiB0aGlzIGZvcm1hdCwgeW91IG1pZ2h0IG5lZWQgdG8gc2VyaWFsaXplIHRoZSBkYXRlIHRvIHRoZSBzdXBwb3J0ZWQgZGF0ZSBmb3JtYXQgaW4gdGhlXG4gKiBiYWNrZW5kLlxuICpcbiAqL1xuQEluamVjdGFibGUoe1xuICBwcm92aWRlZEluOiAncm9vdCcsXG59KVxuZXhwb3J0IGNsYXNzIERhdGVQaWNrZXJTZXJ2aWNlIHtcbiAgZ2V0IHBsYWNlaG9sZGVyKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuICd5eXl5LW1tLWRkJztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCBkYXRlIHBhdHRlcm4gaXMgYmFzZWQgb24gdGhlIHBsYWNlaG9sZGVyIHN0cmluZztcbiAgICovXG4gIGdldCBwYXR0ZXJuKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMucGxhY2Vob2xkZXJcbiAgICAgIC5yZXBsYWNlKCd5eXl5JywgJ1xcXFxkezR9JylcbiAgICAgIC5yZXBsYWNlKCdtbScsICdcXFxcZHsxLDJ9JylcbiAgICAgIC5yZXBsYWNlKCdkZCcsICdcXFxcZHsxLDJ9Jyk7XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGVzIGlmIHRoZSBzdHJpbmcgYmFzZWQgZGF0ZSB2YWx1ZSBpcyBhIHZhbGlkIGRhdGUuXG4gICAqL1xuICBpc1ZhbGlkRm9ybWF0KGRhdGU6IHN0cmluZywgcGF0dGVybj86IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IHBhdHRlcm5SZWdleCA9IG5ldyBSZWdFeHAoYF4ke3BhdHRlcm4gPz8gdGhpcy5wYXR0ZXJufSRgKTtcbiAgICByZXR1cm4gcGF0dGVyblJlZ2V4LnRlc3QoZGF0ZSk7XG4gIH1cblxuICAvKipcbiAgICogU2luY2UgU2FmYXJpIGRvZXNuJ3Qgc3VwcG9ydCBwcm9wZXIgZGF0ZSBmb3JtYXRzIChJU08gODYwMSksIHdlIG5lZWQgdG8gZG8gdGhpc1xuICAgKiBvdXJzZWx2ZXMuIFdlIGNhbm5vdCByZWx5IG9uIGBuZXcgRGF0ZSgnMjAyMC0xLTEnKWAuIFRoaXMgd2lsbCBmYWlsLCBvbmx5XG4gICAqIGBuZXcgRGF0ZSgnMjAyMC0wMS0wMScpYCB3b3Jrcy5cbiAgICovXG4gIGdldERhdGUodmFsdWU6IHN0cmluZyk6IERhdGUge1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBkZWxpbWl0ZXIgPSB0aGlzLnBsYWNlaG9sZGVyXG4gICAgICAucmVwbGFjZSgneXl5eScsICcnKVxuICAgICAgLnJlcGxhY2UoJ21tJywgJycpXG4gICAgICAucmVwbGFjZSgnZGQnLCAnJylcbiAgICAgIC5zdWJzdHIoMCwgMSk7XG5cbiAgICBjb25zdCBkYXRlUGFydHMgPSB2YWx1ZS5zcGxpdChkZWxpbWl0ZXIpO1xuXG4gICAgY29uc3QgcGxhY2Vob2xkZXJQYXJ0cyA9IHRoaXMucGxhY2Vob2xkZXIuc3BsaXQoZGVsaW1pdGVyKTtcblxuICAgIGNvbnN0IHkgPSBwbGFjZWhvbGRlclBhcnRzLmluZGV4T2YoJ3l5eXknKTtcbiAgICBjb25zdCBtID0gcGxhY2Vob2xkZXJQYXJ0cy5pbmRleE9mKCdtbScpO1xuICAgIGNvbnN0IGQgPSBwbGFjZWhvbGRlclBhcnRzLmluZGV4T2YoJ2RkJyk7XG5cbiAgICByZXR1cm4gbmV3IERhdGUoXG4gICAgICBOdW1iZXIoZGF0ZVBhcnRzW3ldKSxcbiAgICAgIE51bWJlcihkYXRlUGFydHNbbV0pIC0gMSxcbiAgICAgIE51bWJlcihkYXRlUGFydHNbZF0pXG4gICAgKTtcbiAgfVxufVxuIl19