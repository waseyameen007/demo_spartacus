import { EMAIL_PATTERN, PASSWORD_PATTERN } from '@spartacus/core';
export class CustomFormValidators {
    /**
     * Checks control's value with predefined email regexp
     *
     * NOTE: Use it as a control validator
     *
     * @static
     * @param {AbstractControl} control
     * @returns {(ValidationErrors | null)} Uses 'cxInvalidEmail' validator error
     * @memberof CustomFormValidators
     */
    static emailValidator(control) {
        const email = control.value;
        return email && (!email.length || email.match(EMAIL_PATTERN))
            ? null
            : { cxInvalidEmail: true };
    }
    /**
     * Checks control's value with predefined password regexp
     *
     * NOTE: Use it as a control validator
     *
     * @static
     * @param {AbstractControl} control
     * @returns {(ValidationErrors | null)} Uses 'cxInvalidPassword' validator error
     * @memberof CustomFormValidators
     */
    static passwordValidator(control) {
        const password = control.value;
        return password && (!password.length || password.match(PASSWORD_PATTERN))
            ? null
            : { cxInvalidPassword: true };
    }
    /**
     * Checks if control's value is between 1 and 5
     *
     * NOTE: Use it as a control validator
     *
     * @static
     * @param {AbstractControl} control
     * @returns {(ValidationErrors | null)} Uses 'cxStarRatingEmpty' validator error
     * @memberof CustomFormValidators
     */
    static starRatingEmpty(control) {
        const rating = control.value;
        return rating >= 1 && rating <= 5 ? null : { cxStarRatingEmpty: true };
    }
    /**
     * Checks if two password controls match
     *
     * NOTE: Use it as a form validator and pass password control names as parameters
     *
     * @static
     * @param {string} password First password control name
     * @param {string} passwordConfirmation Second password control name
     * @returns Uses 'cxPasswordsMustMatch' validator error
     * @memberof CustomFormValidators
     */
    static passwordsMustMatch(password, passwordConfirmation) {
        const validator = (formGroup) => controlsMustMatch(formGroup, password, passwordConfirmation, 'cxPasswordsMustMatch');
        return validator;
    }
    /**
     * Checks if two email controls match
     *
     * NOTE: Use it as a form validator and pass email control names as parameters
     *
     * @static
     * @param {string} email First email control name
     * @param {string} emailConfirmation Second email control name
     * @returns Uses 'cxEmailsMustMatch' validator error
     * @memberof CustomFormValidators
     */
    static emailsMustMatch(email, emailConfirmation) {
        const validator = (formGroup) => controlsMustMatch(formGroup, email, emailConfirmation, 'cxEmailsMustMatch');
        return validator;
    }
    /**
     * Checks if control's value is euqal or greater than 0
     *
     * NOTE: Use it as a control validator
     *
     * @static
     * @param {AbstractControl} control
     * @returns {(ValidationErrors | null)} Uses 'cxNegativeAmount' validator error
     * @memberof CustomFormValidators
     */
    static mustBePositive(control) {
        const amount = control.value;
        return amount >= 0 ? null : { cxNegativeAmount: true };
    }
    /**
     * Checks if control's value does not contain any special characters
     *
     * NOTE: Use it as a control validator
     *
     * @static
     * @param {AbstractControl} control
     * @returns {(ValidationErrors | null)} Uses 'cxContainsSpecialCharacters' validator error
     * @memberof CustomFormValidators
     */
    static noSpecialCharacters(control) {
        const forbiddenChars = ['/'];
        const str = String(control.value);
        const containsSpecialChars = forbiddenChars.some((char) => str.includes(char));
        return !containsSpecialChars ? null : { cxContainsSpecialCharacters: true };
    }
    /**
     * Checks if control's value passes pattern
     *
     * NOTE: Use it as a control validator
     *
     * @static
     * @param {(date: string) => boolean} isValidFormat Pattern verification function
     * @returns {(control: AbstractControl): ValidationErrors | null} Uses 'pattern' validator error
     * @memberof CustomFormValidators
     */
    static patternValidation(isValidFormat) {
        const validator = (control) => {
            const errors = {};
            if (control.value &&
                control.value !== '' &&
                !isValidFormat(control.value)) {
                errors.pattern = true;
            }
            return Object.keys(errors).length === 0 ? null : errors;
        };
        return validator;
    }
    /**
     * Checks if two email controls match
     *
     * NOTE: Use it as a form validator and pass dates for range
     *
     * @static
     * @param {string} startDateKey First date control name
     * @param {string} endDateKey Second date control name
     * @param {(value: string) => Date} getDate Converting function
     * @returns Uses 'min' and 'max validator error
     * @memberof CustomFormValidators
     */
    static dateRange(startDateKey, endDateKey, getDate) {
        const validator = (formGroup) => {
            var _a, _b;
            const startDateControl = formGroup.controls[startDateKey];
            const endDateControl = formGroup.controls[endDateKey];
            const startDate = getDate(startDateControl.value);
            const endDate = getDate(endDateControl.value);
            if (!((_a = startDateControl.errors) === null || _a === void 0 ? void 0 : _a.pattern)) {
                if (startDate > endDate) {
                    startDateControl.setErrors({ max: true });
                }
            }
            if (!((_b = endDateControl.errors) === null || _b === void 0 ? void 0 : _b.pattern)) {
                if (endDate < startDate) {
                    endDateControl.setErrors({ min: true });
                }
            }
            return null;
        };
        return validator;
    }
}
/**
 * Generic function for validators, which checks if two passed controls match.
 *
 * @param formGroup
 * @param firstControlName First control to check
 * @param secondControlName Second control to check
 * @param errorName Error which will be returned by validator
 */
export function controlsMustMatch(formGroup, firstControlName, secondControlName, errorName) {
    const firstControl = formGroup.controls[firstControlName];
    const secondControl = formGroup.controls[secondControlName];
    if (secondControl.errors && !secondControl.errors[errorName]) {
        return;
    }
    secondControl.setErrors(firstControl.value !== secondControl.value ? { [errorName]: true } : null);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY3VzdG9tLWZvcm0tdmFsaWRhdG9ycy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL3N0b3JlZnJvbnRsaWIvc2hhcmVkL3V0aWxzL3ZhbGlkYXRvcnMvY3VzdG9tLWZvcm0tdmFsaWRhdG9ycy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFNQSxPQUFPLEVBQUUsYUFBYSxFQUFFLGdCQUFnQixFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFFbEUsTUFBTSxPQUFPLG9CQUFvQjtJQUMvQjs7Ozs7Ozs7O09BU0c7SUFDSCxNQUFNLENBQUMsY0FBYyxDQUFDLE9BQXdCO1FBQzVDLE1BQU0sS0FBSyxHQUFHLE9BQU8sQ0FBQyxLQUFlLENBQUM7UUFFdEMsT0FBTyxLQUFLLElBQUksQ0FBQyxDQUFDLEtBQUssQ0FBQyxNQUFNLElBQUksS0FBSyxDQUFDLEtBQUssQ0FBQyxhQUFhLENBQUMsQ0FBQztZQUMzRCxDQUFDLENBQUMsSUFBSTtZQUNOLENBQUMsQ0FBQyxFQUFFLGNBQWMsRUFBRSxJQUFJLEVBQUUsQ0FBQztJQUMvQixDQUFDO0lBRUQ7Ozs7Ozs7OztPQVNHO0lBQ0gsTUFBTSxDQUFDLGlCQUFpQixDQUFDLE9BQXdCO1FBQy9DLE1BQU0sUUFBUSxHQUFHLE9BQU8sQ0FBQyxLQUFlLENBQUM7UUFFekMsT0FBTyxRQUFRLElBQUksQ0FBQyxDQUFDLFFBQVEsQ0FBQyxNQUFNLElBQUksUUFBUSxDQUFDLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO1lBQ3ZFLENBQUMsQ0FBQyxJQUFJO1lBQ04sQ0FBQyxDQUFDLEVBQUUsaUJBQWlCLEVBQUUsSUFBSSxFQUFFLENBQUM7SUFDbEMsQ0FBQztJQUVEOzs7Ozs7Ozs7T0FTRztJQUNILE1BQU0sQ0FBQyxlQUFlLENBQUMsT0FBd0I7UUFDN0MsTUFBTSxNQUFNLEdBQUcsT0FBTyxDQUFDLEtBQWUsQ0FBQztRQUV2QyxPQUFPLE1BQU0sSUFBSSxDQUFDLElB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bnQiOlsiaW1wb3J0IHtcbiAgQWJzdHJhY3RDb250cm9sLFxuICBGb3JtR3JvdXAsXG4gIFZhbGlkYXRpb25FcnJvcnMsXG4gIFZhbGlkYXRvckZuLFxufSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBFTUFJTF9QQVRURVJOLCBQQVNTV09SRF9QQVRURVJOIH0gZnJvbSAnQHNwYXJ0YWN1cy9jb3JlJztcblxuZXhwb3J0IGNsYXNzIEN1c3RvbUZvcm1WYWxpZGF0b3JzIHtcbiAgLyoqXG4gICAqIENoZWNrcyBjb250cm9sJ3MgdmFsdWUgd2l0aCBwcmVkZWZpbmVkIGVtYWlsIHJlZ2V4cFxuICAgKlxuICAgKiBOT1RFOiBVc2UgaXQgYXMgYSBjb250cm9sIHZhbGlkYXRvclxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7QWJzdHJhY3RDb250cm9sfSBjb250cm9sXG4gICAqIEByZXR1cm5zIHsoVmFsaWRhdGlvbkVycm9ycyB8IG51bGwpfSBVc2VzICdjeEludmFsaWRFbWFpbCcgdmFsaWRhdG9yIGVycm9yXG4gICAqIEBtZW1iZXJvZiBDdXN0b21Gb3JtVmFsaWRhdG9yc1xuICAgKi9cbiAgc3RhdGljIGVtYWlsVmFsaWRhdG9yKGNvbnRyb2w6IEFic3RyYWN0Q29udHJvbCk6IFZhbGlkYXRpb25FcnJvcnMgfCBudWxsIHtcbiAgICBjb25zdCBlbWFpbCA9IGNvbnRyb2wudmFsdWUgYXMgc3RyaW5nO1xuXG4gICAgcmV0dXJuIGVtYWlsICYmICghZW1haWwubGVuZ3RoIHx8IGVtYWlsLm1hdGNoKEVNQUlMX1BBVFRFUk4pKVxuICAgICAgPyBudWxsXG4gICAgICA6IHsgY3hJbnZhbGlkRW1haWw6IHRydWUgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgY29udHJvbCdzIHZhbHVlIHdpdGggcHJlZGVmaW5lZCBwYXNzd29yZCByZWdleHBcbiAgICpcbiAgICogTk9URTogVXNlIGl0IGFzIGEgY29udHJvbCB2YWxpZGF0b3JcbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge0Fic3RyYWN0Q29udHJvbH0gY29udHJvbFxuICAgKiBAcmV0dXJucyB7KFZhbGlkYXRpb25FcnJvcnMgfCBudWxsKX0gVXNlcyAnY3hJbnZhbGlkUGFzc3dvcmQnIHZhbGlkYXRvciBlcnJvclxuICAgKiBAbWVtYmVyb2YgQ3VzdG9tRm9ybVZhbGlkYXRvcnNcbiAgICovXG4gIHN0YXRpYyBwYXNzd29yZFZhbGlkYXRvcihjb250cm9sOiBBYnN0cmFjdENvbnRyb2wpOiBWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbCB7XG4gICAgY29uc3QgcGFzc3dvcmQgPSBjb250cm9sLnZhbHVlIGFzIHN0cmluZztcblxuICAgIHJldHVybiBwYXNzd29yZCAmJiAoIXBhc3N3b3JkLmxlbmd0aCB8fCBwYXNzd29yZC5tYXRjaChQQVNTV09SRF9QQVRURVJOKSlcbiAgICAgID8gbnVsbFxuICAgICAgOiB7IGN4SW52YWxpZFBhc3N3b3JkOiB0cnVlIH07XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGNvbnRyb2wncyB2YWx1ZSBpcyBiZXR3ZWVuIDEgYW5kIDVcbiAgICpcbiAgICogTk9URTogVXNlIGl0IGFzIGEgY29udHJvbCB2YWxpZGF0b3JcbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge0Fic3RyYWN0Q29udHJvbH0gY29udHJvbFxuICAgKiBAcmV0dXJucyB7KFZhbGlkYXRpb25FcnJvcnMgfCBudWxsKX0gVXNlcyAnY3hTdGFyUmF0aW5nRW1wdHknIHZhbGlkYXRvciBlcnJvclxuICAgKiBAbWVtYmVyb2YgQ3VzdG9tRm9ybVZhbGlkYXRvcnNcbiAgICovXG4gIHN0YXRpYyBzdGFyUmF0aW5nRW1wdHkoY29udHJvbDogQWJzdHJhY3RDb250cm9sKTogVmFsaWRhdGlvbkVycm9ycyB8IG51bGwge1xuICAgIGNvbnN0IHJhdGluZyA9IGNvbnRyb2wudmFsdWUgYXMgbnVtYmVyO1xuXG4gICAgcmV0dXJuIHJhdGluZyA+PSAxICYmIHJhdGluZyA8PSA1ID8gbnVsbCA6IHsgY3hTdGFyUmF0aW5nRW1wdHk6IHRydWUgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdHdvIHBhc3N3b3JkIGNvbnRyb2xzIG1hdGNoXG4gICAqXG4gICAqIE5PVEU6IFVzZSBpdCBhcyBhIGZvcm0gdmFsaWRhdG9yIGFuZCBwYXNzIHBhc3N3b3JkIGNvbnRyb2wgbmFtZXMgYXMgcGFyYW1ldGVyc1xuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZCBGaXJzdCBwYXNzd29yZCBjb250cm9sIG5hbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkQ29uZmlybWF0aW9uIFNlY29uZCBwYXNzd29yZCBjb250cm9sIG5hbWVcbiAgICogQHJldHVybnMgVXNlcyAnY3hQYXNzd29yZHNNdXN0TWF0Y2gnIHZhbGlkYXRvciBlcnJvclxuICAgKiBAbWVtYmVyb2YgQ3VzdG9tRm9ybVZhbGlkYXRvcnNcbiAgICovXG4gIHN0YXRpYyBwYXNzd29yZHNNdXN0TWF0Y2goXG4gICAgcGFzc3dvcmQ6IHN0cmluZyxcbiAgICBwYXNzd29yZENvbmZpcm1hdGlvbjogc3RyaW5nXG4gICk6IGFueSB7XG4gICAgY29uc3QgdmFsaWRhdG9yID0gKGZvcm1Hcm91cDogRm9ybUdyb3VwKSA9PlxuICAgICAgY29udHJvbHNNdXN0TWF0Y2goXG4gICAgICAgIGZvcm1Hcm91cCxcbiAgICAgICAgcGFzc3dvcmQsXG4gICAgICAgIHBhc3N3b3JkQ29uZmlybWF0aW9uLFxuICAgICAgICAnY3hQYXNzd29yZHNNdXN0TWF0Y2gnXG4gICAgICApO1xuXG4gICAgcmV0dXJuIHZhbGlkYXRvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdHdvIGVtYWlsIGNvbnRyb2xzIG1hdGNoXG4gICAqXG4gICAqIE5PVEU6IFVzZSBpdCBhcyBhIGZvcm0gdmFsaWRhdG9yIGFuZCBwYXNzIGVtYWlsIGNvbnRyb2wgbmFtZXMgYXMgcGFyYW1ldGVyc1xuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBlbWFpbCBGaXJzdCBlbWFpbCBjb250cm9sIG5hbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGVtYWlsQ29uZmlybWF0aW9uIFNlY29uZCBlbWFpbCBjb250cm9sIG5hbWVcbiAgICogQHJldHVybnMgVXNlcyAnY3hFbWFpbHNNdXN0TWF0Y2gnIHZhbGlkYXRvciBlcnJvclxuICAgKiBAbWVtYmVyb2YgQ3VzdG9tRm9ybVZhbGlkYXRvcnNcbiAgICovXG4gIHN0YXRpYyBlbWFpbHNNdXN0TWF0Y2goZW1haWw6IHN0cmluZywgZW1haWxDb25maXJtYXRpb246IHN0cmluZyk6IGFueSB7XG4gICAgY29uc3QgdmFsaWRhdG9yID0gKGZvcm1Hcm91cDogRm9ybUdyb3VwKSA9PlxuICAgICAgY29udHJvbHNNdXN0TWF0Y2goXG4gICAgICAgIGZvcm1Hcm91cCxcbiAgICAgICAgZW1haWwsXG4gICAgICAgIGVtYWlsQ29uZmlybWF0aW9uLFxuICAgICAgICAnY3hFbWFpbHNNdXN0TWF0Y2gnXG4gICAgICApO1xuXG4gICAgcmV0dXJuIHZhbGlkYXRvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgY29udHJvbCdzIHZhbHVlIGlzIGV1cWFsIG9yIGdyZWF0ZXIgdGhhbiAwXG4gICAqXG4gICAqIE5PVEU6IFVzZSBpdCBhcyBhIGNvbnRyb2wgdmFsaWRhdG9yXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtBYnN0cmFjdENvbnRyb2x9IGNvbnRyb2xcbiAgICogQHJldHVybnMgeyhWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbCl9IFVzZXMgJ2N4TmVnYXRpdmVBbW91bnQnIHZhbGlkYXRvciBlcnJvclxuICAgKiBAbWVtYmVyb2YgQ3VzdG9tRm9ybVZhbGlkYXRvcnNcbiAgICovXG4gIHN0YXRpYyBtdXN0QmVQb3NpdGl2ZShjb250cm9sOiBBYnN0cmFjdENvbnRyb2wpOiBWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbCB7XG4gICAgY29uc3QgYW1vdW50ID0gY29udHJvbC52YWx1ZSBhcyBudW1iZXI7XG5cbiAgICByZXR1cm4gYW1vdW50ID49IDAgPyBudWxsIDogeyBjeE5lZ2F0aXZlQW1vdW50OiB0cnVlIH07XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGNvbnRyb2wncyB2YWx1ZSBkb2VzIG5vdCBjb250YWluIGFueSBzcGVjaWFsIGNoYXJhY3RlcnNcbiAgICpcbiAgICogTk9URTogVXNlIGl0IGFzIGEgY29udHJvbCB2YWxpZGF0b3JcbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge0Fic3RyYWN0Q29udHJvbH0gY29udHJvbFxuICAgKiBAcmV0dXJucyB7KFZhbGlkYXRpb25FcnJvcnMgfCBudWxsKX0gVXNlcyAnY3hDb250YWluc1NwZWNpYWxDaGFyYWN0ZXJzJyB2YWxpZGF0b3IgZXJyb3JcbiAgICogQG1lbWJlcm9mIEN1c3RvbUZvcm1WYWxpZGF0b3JzXG4gICAqL1xuICBzdGF0aWMgbm9TcGVjaWFsQ2hhcmFjdGVycyhcbiAgICBjb250cm9sOiBBYnN0cmFjdENvbnRyb2xcbiAgKTogVmFsaWRhdGlvbkVycm9ycyB8IG51bGwge1xuICAgIGNvbnN0IGZvcmJpZGRlbkNoYXJzID0gWycvJ107XG4gICAgY29uc3Qgc3RyID0gU3RyaW5nKGNvbnRyb2wudmFsdWUpO1xuICAgIGNvbnN0IGNvbnRhaW5zU3BlY2lhbENoYXJzID0gZm9yYmlkZGVuQ2hhcnMuc29tZSgoY2hhcikgPT5cbiAgICAgIHN0ci5pbmNsdWRlcyhjaGFyKVxuICAgICk7XG5cbiAgICByZXR1cm4gIWNvbnRhaW5zU3BlY2lhbENoYXJzID8gbnVsbCA6IHsgY3hDb250YWluc1NwZWNpYWxDaGFyYWN0ZXJzOiB0cnVlIH07XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGNvbnRyb2wncyB2YWx1ZSBwYXNzZXMgcGF0dGVyblxuICAgKlxuICAgKiBOT1RFOiBVc2UgaXQgYXMgYSBjb250cm9sIHZhbGlkYXRvclxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7KGRhdGU6IHN0cmluZykgPT4gYm9vbGVhbn0gaXNWYWxpZEZvcm1hdCBQYXR0ZXJuIHZlcmlmaWNhdGlvbiBmdW5jdGlvblxuICAgKiBAcmV0dXJucyB7KGNvbnRyb2w6IEFic3RyYWN0Q29udHJvbCk6IFZhbGlkYXRpb25FcnJvcnMgfCBudWxsfSBVc2VzICdwYXR0ZXJuJyB2YWxpZGF0b3IgZXJyb3JcbiAgICogQG1lbWJlcm9mIEN1c3RvbUZvcm1WYWxpZGF0b3JzXG4gICAqL1xuICBzdGF0aWMgcGF0dGVyblZhbGlkYXRpb24oXG4gICAgaXNWYWxpZEZvcm1hdDogKGRhdGU6IHN0cmluZykgPT4gYm9vbGVhblxuICApOiBWYWxpZGF0b3JGbiB7XG4gICAgY29uc3QgdmFsaWRhdG9yID0gKGNvbnRyb2w6IEFic3RyYWN0Q29udHJvbCk6IFZhbGlkYXRpb25FcnJvcnMgfCBudWxsID0+IHtcbiAgICAgIGNvbnN0IGVycm9yczogVmFsaWRhdGlvbkVycm9ycyA9IHt9O1xuICAgICAgaWYgKFxuICAgICAgICBjb250cm9sLnZhbHVlICYmXG4gICAgICAgIGNvbnRyb2wudmFsdWUgIT09ICcnICYmXG4gICAgICAgICFpc1ZhbGlkRm9ybWF0KGNvbnRyb2wudmFsdWUpXG4gICAgICApIHtcbiAgICAgICAgZXJyb3JzLnBhdHRlcm4gPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGVycm9ycykubGVuZ3RoID09PSAwID8gbnVsbCA6IGVycm9ycztcbiAgICB9O1xuICAgIHJldHVybiB2YWxpZGF0b3I7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHR3byBlbWFpbCBjb250cm9scyBtYXRjaFxuICAgKlxuICAgKiBOT1RFOiBVc2UgaXQgYXMgYSBmb3JtIHZhbGlkYXRvciBhbmQgcGFzcyBkYXRlcyBmb3IgcmFuZ2VcbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RhcnREYXRlS2V5IEZpcnN0IGRhdGUgY29udHJvbCBuYW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBlbmREYXRlS2V5IFNlY29uZCBkYXRlIGNvbnRyb2wgbmFtZVxuICAgKiBAcGFyYW0geyh2YWx1ZTogc3RyaW5nKSA9PiBEYXRlfSBnZXREYXRlIENvbnZlcnRpbmcgZnVuY3Rpb25cbiAgICogQHJldHVybnMgVXNlcyAnbWluJyBhbmQgJ21heCB2YWxpZGF0b3IgZXJyb3JcbiAgICogQG1lbWJlcm9mIEN1c3RvbUZvcm1WYWxpZGF0b3JzXG4gICAqL1xuICBzdGF0aWMgZGF0ZVJhbmdlKFxuICAgIHN0YXJ0RGF0ZUtleTogc3RyaW5nLFxuICAgIGVuZERhdGVLZXk6IHN0cmluZyxcbiAgICBnZXREYXRlOiAodmFsdWU6IHN0cmluZykgPT4gRGF0ZVxuICApOiAoRm9ybUdyb3VwKSA9PiBhbnkge1xuICAgIGNvbnN0IHZhbGlkYXRvciA9IChmb3JtR3JvdXA6IEZvcm1Hcm91cCk6IFZhbGlkYXRpb25FcnJvcnMgfCBudWxsID0+IHtcbiAgICAgIGNvbnN0IHN0YXJ0RGF0ZUNvbnRyb2wgPSBmb3JtR3JvdXAuY29udHJvbHNbc3RhcnREYXRlS2V5XTtcbiAgICAgIGNvbnN0IGVuZERhdGVDb250cm9sID0gZm9ybUdyb3VwLmNvbnRyb2xzW2VuZERhdGVLZXldO1xuICAgICAgY29uc3Qgc3RhcnREYXRlID0gZ2V0RGF0ZShzdGFydERhdGVDb250cm9sLnZhbHVlKTtcbiAgICAgIGNvbnN0IGVuZERhdGUgPSBnZXREYXRlKGVuZERhdGVDb250cm9sLnZhbHVlKTtcbiAgICAgIGlmICghc3RhcnREYXRlQ29udHJvbC5lcnJvcnM/LnBhdHRlcm4pIHtcbiAgICAgICAgaWYgKHN0YXJ0RGF0ZSA+IGVuZERhdGUpIHtcbiAgICAgICAgICBzdGFydERhdGVDb250cm9sLnNldEVycm9ycyh7IG1heDogdHJ1ZSB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFlbmREYXRlQ29udHJvbC5lcnJvcnM/LnBhdHRlcm4pIHtcbiAgICAgICAgaWYgKGVuZERhdGUgPCBzdGFydERhdGUpIHtcbiAgICAgICAgICBlbmREYXRlQ29udHJvbC5zZXRFcnJvcnMoeyBtaW46IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIHZhbGlkYXRvcjtcbiAgfVxufVxuXG4vKipcbiAqIEdlbmVyaWMgZnVuY3Rpb24gZm9yIHZhbGlkYXRvcnMsIHdoaWNoIGNoZWNrcyBpZiB0d28gcGFzc2VkIGNvbnRyb2xzIG1hdGNoLlxuICpcbiAqIEBwYXJhbSBmb3JtR3JvdXBcbiAqIEBwYXJhbSBmaXJzdENvbnRyb2xOYW1lIEZpcnN0IGNvbnRyb2wgdG8gY2hlY2tcbiAqIEBwYXJhbSBzZWNvbmRDb250cm9sTmFtZSBTZWNvbmQgY29udHJvbCB0byBjaGVja1xuICogQHBhcmFtIGVycm9yTmFtZSBFcnJvciB3aGljaCB3aWxsIGJlIHJldHVybmVkIGJ5IHZhbGlkYXRvclxuICovXG5leHBvcnQgZnVuY3Rpb24gY29udHJvbHNNdXN0TWF0Y2goXG4gIGZvcm1Hcm91cDogRm9ybUdyb3VwLFxuICBmaXJzdENvbnRyb2xOYW1lOiBzdHJpbmcsXG4gIHNlY29uZENvbnRyb2xOYW1lOiBzdHJpbmcsXG4gIGVycm9yTmFtZTogc3RyaW5nXG4pOiB2b2lkIHtcbiAgY29uc3QgZmlyc3RDb250cm9sID0gZm9ybUdyb3VwLmNvbnRyb2xzW2ZpcnN0Q29udHJvbE5hbWVdO1xuICBjb25zdCBzZWNvbmRDb250cm9sID0gZm9ybUdyb3VwLmNvbnRyb2xzW3NlY29uZENvbnRyb2xOYW1lXTtcblxuICBpZiAoc2Vjb25kQ29udHJvbC5lcnJvcnMgJiYgIXNlY29uZENvbnRyb2wuZXJyb3JzW2Vycm9yTmFtZV0pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBzZWNvbmRDb250cm9sLnNldEVycm9ycyhcbiAgICBmaXJzdENvbnRyb2wudmFsdWUgIT09IHNlY29uZENvbnRyb2wudmFsdWUgPyB7IFtlcnJvck5hbWVdOiB0cnVlIH0gOiBudWxsXG4gICk7XG59XG4iXX0=