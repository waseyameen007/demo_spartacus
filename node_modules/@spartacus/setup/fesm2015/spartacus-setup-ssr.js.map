{"version":3,"file":"spartacus-setup-ssr.js","sources":["../../../core-libs/setup/ssr/util/request-origin.ts","../../../core-libs/setup/ssr/util/request-url.ts","../../../core-libs/setup/ssr/optimized-engine/rendering-cache.ts","../../../core-libs/setup/ssr/optimized-engine/ssr-optimization-options.ts","../../../core-libs/setup/ssr/optimized-engine/optimized-ssr-engine.ts","../../../core-libs/setup/ssr/providers/ssr-providers.ts","../../../core-libs/setup/ssr/engine-decorator/ng-express-engine-decorator.ts","../../../core-libs/setup/ssr/spartacus-setup-ssr.ts"],"sourcesContent":["import { Request } from 'express';\n\nexport function getRequestOrigin(req: Request): string {\n  // If express is resolving and trusting X-Forwarded-Host, we want to take it\n  // into an account to properly generate request origin.\n  const trustProxyFn = req.app.get('trust proxy fn');\n  let forwardedHost = req.get('X-Forwarded-Host');\n  if (forwardedHost && trustProxyFn(req.connection.remoteAddress, 0)) {\n    if (forwardedHost.indexOf(',') !== -1) {\n      // Note: X-Forwarded-Host is normally only ever a\n      //       single value, but this is to be safe.\n      forwardedHost = forwardedHost\n        .substring(0, forwardedHost.indexOf(','))\n        .trimRight();\n    }\n    return req.protocol + '://' + forwardedHost;\n  } else {\n    return req.protocol + '://' + req.get('host');\n  }\n}\n","import { Request } from 'express';\nimport { getRequestOrigin } from './request-origin';\n\nexport function getRequestUrl(req: Request): string {\n  return getRequestOrigin(req) + req.originalUrl;\n}\n","import { SsrOptimizationOptions } from './ssr-optimization-options';\n\nexport interface RenderingEntry {\n  html?: any;\n  err?: any;\n  time?: number;\n  rendering?: boolean;\n}\n\nexport class RenderingCache {\n  protected renders = new Map<string, RenderingEntry>();\n\n  constructor(private options?: SsrOptimizationOptions) {}\n\n  setAsRendering(key: string) {\n    this.renders.set(key, { rendering: true });\n  }\n\n  isRendering(key: string): boolean {\n    return !!this.renders.get(key)?.rendering;\n  }\n\n  store(key: string, err?: Error | null, html?: string) {\n    const entry: RenderingEntry = { err, html };\n    if (this.options?.ttl) {\n      entry.time = Date.now();\n    }\n    if (this.options?.cacheSize) {\n      this.renders.delete(key);\n      if (this.renders.size >= this.options.cacheSize) {\n        this.renders.delete(this.renders.keys().next().value);\n      }\n    }\n    this.renders.set(key, entry);\n  }\n\n  get(key: string): RenderingEntry | undefined {\n    return this.renders.get(key);\n  }\n\n  clear(key: string) {\n    this.renders.delete(key);\n  }\n\n  isReady(key: string): boolean {\n    const entry = this.renders.get(key);\n    const isRenderPresent = entry?.html || entry?.err;\n    return isRenderPresent && this.isFresh(key);\n  }\n\n  isFresh(key: string): boolean {\n    if (!this.options?.ttl) {\n      return true;\n    }\n\n    return Date.now() - (this.renders.get(key)?.time ?? 0) < this.options?.ttl;\n  }\n}\n","import { Request } from 'express';\n\nexport interface SsrOptimizationOptions {\n  /**\n   * Time in milliseconds to wait for SSR rendering to happen.\n   */\n  timeout?: number;\n\n  /**\n   * Enable in-memory cache for pre-rendered urls.\n   *\n   * If disabled, the cache will still be used to temporarily store\n   * renders finished after csr fallback in order to serve them with\n   * next request only.\n   */\n  cache?: boolean;\n\n  /**\n   * Limit the cache size\n   *\n   * Specified number of entries that will be kept in cache, allows to keep\n   * memory usage under control.\n   *\n   * Can also be use when `cache` option is set to false. It will then limit the\n   * number of renders that timeouts and are kept in temporary cache, waiting\n   * to be served with next request.\n   */\n  cacheSize?: number;\n\n  /**\n   * Limit number of concurrent rendering\n   */\n  concurrency?: number;\n\n  /**\n   * Time in milliseconds after prerendered page is becoming stale and should\n   * be rendered again.\n   */\n  ttl?: number;\n\n  /**\n   * Allows overriding default key generator for custom differentiating\n   * between rendered pages. By default it uses the full request URL.\n   *\n   * @param req\n   */\n  renderKeyResolver?: (req: Request) => string;\n\n  /**\n   * Allows defining custom rendering strategy per request\n   *\n   * @param req\n   */\n  renderingStrategyResolver?: (req: Request) => RenderingStrategy;\n\n  /**\n   * Time in milliseconds to wait for rendering when SSR_ALWAYS render strategy is set for the request.\n   * Default value is 60000 milliseconds (1 minute).\n   */\n  forcedSsrTimeout?: number;\n\n  /**\n   * The time for how long the render is expected to finish in.\n   * Exceeding this timeout will decrease the concurrency limit\n   * and allow for the new request to be server-side rendered.\n   * However, this may not release the rendering resources for the hanging render,\n   * which may cause additional memory usage on the server.\n   *\n   * It will log which render is exceeding the render time,\n   * which is useful for debugging issues.\n   *\n   * The value should always be higher than `timeout` and `forcedSsrTimeout`.\n   *\n   * Default value is 300000 milliseconds (5 minutes).\n   */\n  maxRenderTime?: number;\n\n  /**\n   * Instead of immediately falling back to CSR\n   * while a render for the same key is in progress, this option will make\n   * the subsequent requests for this key wait for the current render.\n   *\n   * All pending requests that for the same rendering key will\n   * take up only _one_ concurrency slot, because there is only\n   * one actual rendering task being performed.\n   *\n   * Each request independently honors the `timeout` option.\n   * E.g., consider the following setup where `timeout` option\n   * is set to 3s, and the given request takes 4s to render.\n   * The flow is as follows:\n   *\n   * - 1st request arrives and triggers the SSR.\n   * - 2nd request for the same URL arrives 2s after the 1st one.\n   *    Instead of falling back to CSR, it waits (with its own timeout)\n   *    for the render of the first request.\n   * - 1st request times out after 3s, and falls back to CSR.\n   * - one second after the timeout, the current render finishes.\n   * - the 2nd request returns SSR after only 2s of waiting.\n   */\n  reuseCurrentRendering?: boolean;\n\n  /**\n   * Enable detailed logs for troubleshooting problems\n   */\n  debug?: boolean;\n}\n\nexport enum RenderingStrategy {\n  ALWAYS_CSR = -1,\n  DEFAULT = 0,\n  ALWAYS_SSR = 1,\n}\n","/* webpackIgnore: true */\nimport { Request, Response } from 'express';\nimport * as fs from 'fs';\nimport { NgExpressEngineInstance } from '../engine-decorator/ng-express-engine-decorator';\nimport { getRequestUrl } from '../util/request-url';\nimport { RenderingCache } from './rendering-cache';\nimport {\n  RenderingStrategy,\n  SsrOptimizationOptions,\n} from './ssr-optimization-options';\n\n/**\n * Returns the full url for the given SSR Request.\n */\nexport const getDefaultRenderKey = getRequestUrl;\n\nexport type SsrCallbackFn = (\n  /**\n   * Error that might've occurred while rendering.\n   */\n  err?: Error | null | undefined,\n  /**\n   * HTML response.\n   */\n  html?: string | undefined\n) => void;\n\n/**\n * The rendered pages are kept in memory to be served on next request. If the `cache` is set to `false`, the\n * response is evicted as soon as the first successful response is successfully returned.\n */\nexport class OptimizedSsrEngine {\n  protected currentConcurrency = 0;\n  protected renderingCache = new RenderingCache(this.ssrOptions);\n  private templateCache = new Map<string, string>();\n\n  /**\n   * When the config `reuseCurrentRendering` is enabled, we want perform\n   * only one render for one rendering key and reuse the html result\n   * for all the pending requests for the same rendering key.\n   * Therefore we need to store the callbacks for all the pending requests\n   * and invoke them with the html after the render completes.\n   *\n   * This Map should be used only when `reuseCurrentRendering` config is enabled.\n   * It's indexed by the rendering keys.\n   */\n  private renderCallbacks = new Map<string, SsrCallbackFn[]>();\n\n  get engineInstance(): NgExpressEngineInstance {\n    return this.renderResponse.bind(this);\n  }\n\n  constructor(\n    protected expressEngine: NgExpressEngineInstance,\n    protected ssrOptions?: SsrOptimizationOptions\n  ) {}\n\n  /**\n   * When SSR page can not be returned in time, we're returning index.html of\n   * the CSR application.\n   * The CSR application is returned with the \"Cache-Control: no-store\" response-header. This notifies external cache systems to not use the CSR application for the subsequent request.\n   */\n  protected fallbackToCsr(\n    response: Response,\n    filePath: string,\n    callback: SsrCallbackFn\n  ): void {\n    response.set('Cache-Control', 'no-store');\n    callback(undefined, this.getDocument(filePath));\n  }\n\n  protected getRenderingKey(request: Request): string {\n    return this.ssrOptions?.renderKeyResolver\n      ? this.ssrOptions.renderKeyResolver(request)\n      : getDefaultRenderKey(request);\n  }\n\n  protected getRenderingStrategy(request: Request): RenderingStrategy {\n    return this.ssrOptions?.renderingStrategyResolver\n      ? this.ssrOptions.renderingStrategyResolver(request)\n      : RenderingStrategy.DEFAULT;\n  }\n\n  /**\n   * When returns true, the server side rendering should be performed.\n   * When returns false, the CSR fallback should be returned.\n   *\n   * We should not render, when there is already\n   * a pending rendering for the same rendering key\n   * (unless the `reuseCurrentRendering` config option is enabled)\n   * OR when the concurrency limit is exceeded.\n   */\n  protected shouldRender(request: Request): boolean {\n    const renderingKey = this.getRenderingKey(request);\n    const concurrencyLimitExceeded =\n      this.isConcurrencyLimitExceeded(renderingKey);\n    const fallBack =\n      this.renderingCache.isRendering(renderingKey) &&\n      !this.ssrOptions?.reuseCurrentRendering;\n\n    if (fallBack) {\n      this.log(`CSR fallback: rendering in progress (${request?.originalUrl})`);\n    } else if (concurrencyLimitExceeded) {\n      this.log(\n        `CSR fallback: Concurrency limit exceeded (${this.ssrOptions?.concurrency})`\n      );\n    }\n\n    return (\n      (!fallBack &&\n        !concurrencyLimitExceeded &&\n        this.getRenderingStrategy(request) !== RenderingStrategy.ALWAYS_CSR) ||\n      this.getRenderingStrategy(request) === RenderingStrategy.ALWAYS_SSR\n    );\n  }\n\n  /**\n   * Checks for the concurrency limit\n   *\n   * @returns true if rendering this request would exceed the concurrency limit\n   */\n  private isConcurrencyLimitExceeded(renderingKey: string): boolean {\n    // If we can reuse a pending render for this request, we don't take up a new concurrency slot.\n    // In that case we don't exceed the concurrency limit even if the `currentConcurrency`\n    // already reaches the limit.\n    if (\n      this.ssrOptions?.reuseCurrentRendering &&\n      this.renderingCache.isRendering(renderingKey)\n    ) {\n      return false;\n    }\n\n    return this.ssrOptions?.concurrency\n      ? this.currentConcurrency >= this.ssrOptions.concurrency\n      : false;\n  }\n\n  /**\n   * Returns true, when the `timeout` option has been configured to non-zero value OR\n   * when the rendering strategy for the given request is ALWAYS_SSR.\n   * Otherwise, it returns false.\n   */\n  protected shouldTimeout(request: Request): boolean {\n    return (\n      !!this.ssrOptions?.timeout ||\n      this.getRenderingStrategy(request) === RenderingStrategy.ALWAYS_SSR\n    );\n  }\n\n  /**\n   * Returns the timeout value.\n   *\n   * In case of the rendering strategy ALWAYS_SSR, it returns the config `forcedSsrTimeout`.\n   * Otherwise, it returns the config `timeout`.\n   */\n  protected getTimeout(request: Request): number {\n    return this.getRenderingStrategy(request) === RenderingStrategy.ALWAYS_SSR\n      ? this.ssrOptions?.forcedSsrTimeout ?? 60000\n      : this.ssrOptions?.timeout ?? 0;\n  }\n\n  /**\n   * If there is an available cached response for this rendering key,\n   * it invokes the given render callback with the response and returns true.\n   *\n   * Otherwise, it returns false.\n   */\n  protected returnCachedRender(\n    request: Request,\n    callback: SsrCallbackFn\n  ): boolean {\n    const key = this.getRenderingKey(request);\n\n    if (this.renderingCache.isReady(key)) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const cached = this.renderingCache.get(key)!;\n      callback(cached.err, cached.html);\n\n      if (!this.ssrOptions?.cache) {\n        // we drop cached rendering if caching is disabled\n        this.renderingCache.clear(key);\n      }\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Handles the request and invokes the given `callback` with the result html / error.\n   *\n   * The result might be ether:\n   * - a CSR fallback with a basic `index.html` content\n   * - a result rendered by the original Angular Universal express engine\n   * - a result from the in-memory cache (which was previously rendered by Angular Universal express engine).\n   */\n  protected renderResponse(\n    filePath: string,\n    options: any,\n    callback: SsrCallbackFn\n  ): void {\n    const request: Request = options.req;\n    const response: Response = options.res || options.req.res;\n\n    if (this.returnCachedRender(request, callback)) {\n      this.log(`Render from cache (${request?.originalUrl})`);\n      return;\n    }\n    if (!this.shouldRender(request)) {\n      this.fallbackToCsr(response, filePath, callback);\n      return;\n    }\n\n    let requestTimeout: NodeJS.Timeout | undefined;\n    if (this.shouldTimeout(request)) {\n      // establish timeout for rendering\n      const timeout = this.getTimeout(request);\n      requestTimeout = setTimeout(() => {\n        requestTimeout = undefined;\n        this.fallbackToCsr(response, filePath, callback);\n        this.log(\n          `SSR rendering exceeded timeout ${timeout}, fallbacking to CSR for ${request?.originalUrl}`,\n          false\n        );\n      }, timeout);\n    } else {\n      // Here we respond with the fallback to CSR, but we don't `return`.\n      // We let the actual rendering task to happen in the background\n      // to eventually store the rendered result in the cache.\n      this.fallbackToCsr(response, filePath, callback);\n    }\n\n    const renderingKey = this.getRenderingKey(request);\n    const renderCallback: SsrCallbackFn = (err, html): void => {\n      if (requestTimeout) {\n        // if request is still waiting for render, return it\n        clearTimeout(requestTimeout);\n        callback(err, html);\n\n        this.log(\n          `Request is resolved with the SSR rendering result (${request?.originalUrl})`\n        );\n\n        // store the render only if caching is enabled\n        if (this.ssrOptions?.cache) {\n          this.renderingCache.store(renderingKey, err, html);\n        } else {\n          this.renderingCache.clear(renderingKey);\n        }\n      } else {\n        // store the render for future use\n        this.renderingCache.store(renderingKey, err, html);\n      }\n    };\n\n    this.handleRender({\n      filePath,\n      options,\n      renderCallback,\n      request,\n    });\n  }\n\n  protected log(message: string, debug = true): void {\n    if (!debug || this.ssrOptions?.debug) {\n      console.log(message);\n    }\n  }\n\n  /** Retrieve the document from the cache or the filesystem */\n  protected getDocument(filePath: string): string {\n    let doc = this.templateCache.get(filePath);\n\n    if (!doc) {\n      // fs.readFileSync could be missing in a browser, specifically\n      // in a unit tests with { node: { fs: 'empty' } } webpack configuration\n      doc = fs?.readFileSync ? fs.readFileSync(filePath, 'utf-8') : '';\n      this.templateCache.set(filePath, doc);\n    }\n\n    return doc;\n  }\n\n  /**\n   * Delegates the render to the original _Angular Universal express engine_.\n   *\n   * In case when the config `reuseCurrentRendering` is enabled and **if there is already a pending\n   * render task for the same rendering key**, it doesn't delegate a new render to Angular Universal.\n   * Instead, it waits for the current rendering to complete and then reuse the result for all waiting requests.\n   */\n  private handleRender({\n    filePath,\n    options,\n    renderCallback,\n    request,\n  }: {\n    filePath: string;\n    options: any;\n    renderCallback: SsrCallbackFn;\n    request: Request;\n  }): void {\n    if (!this.ssrOptions?.reuseCurrentRendering) {\n      this.startRender({\n        filePath,\n        options,\n        renderCallback,\n        request,\n      });\n      return;\n    }\n\n    const renderingKey = this.getRenderingKey(request);\n    if (!this.renderCallbacks.has(renderingKey)) {\n      this.renderCallbacks.set(renderingKey, []);\n    }\n    this.renderCallbacks.get(renderingKey)?.push(renderCallback);\n\n    if (!this.renderingCache.isRendering(renderingKey)) {\n      this.startRender({\n        filePath,\n        options,\n        request,\n        renderCallback: (err, html) => {\n          // Share the result of the render with all awaiting requests for the same key:\n\n          // Note: we access the Map at the moment of the render finished (don't store value in a local variable),\n          //       because in the meantime something might have deleted the value (i.e. when `maxRenderTime` passed).\n          this.renderCallbacks\n            .get(renderingKey)\n            ?.forEach((cb) => cb(err, html)); // pass the shared result to all waiting rendering callbacks\n          this.renderCallbacks.delete(renderingKey);\n        },\n      });\n    }\n\n    this.log(\n      `Request is waiting for the SSR rendering to complete (${request?.originalUrl})`\n    );\n  }\n\n  /**\n   * Delegates the render to the original _Angular Universal express engine_.\n   *\n   * There is no way to abort the running render of Angular Universal.\n   * So if the render doesn't complete in the configured `maxRenderTime`,\n   * we just consider the render task as hanging (note: it's a potential memory leak!).\n   * Later on, even if the render completes somewhen in the future, we will ignore\n   * its result.\n   */\n  private startRender({\n    filePath,\n    options,\n    renderCallback,\n    request,\n  }: {\n    filePath: string;\n    options: any;\n    renderCallback: SsrCallbackFn;\n    request: Request;\n  }): void {\n    const renderingKey = this.getRenderingKey(request);\n\n    // Setting the timeout for hanging renders that might not ever finish due to various reasons.\n    // After the configured `maxRenderTime` passes, we consider the rendering task as hanging,\n    // and release the concurrency slot and forget all callbacks waiting for the render's result.\n    let maxRenderTimeout: NodeJS.Timeout | undefined = setTimeout(() => {\n      this.renderingCache.clear(renderingKey);\n      maxRenderTimeout = undefined;\n      this.currentConcurrency--;\n      if (this.ssrOptions?.reuseCurrentRendering) {\n        this.renderCallbacks.delete(renderingKey);\n      }\n      this.log(\n        `Rendering of ${request?.originalUrl} was not able to complete. This might cause memory leaks!`,\n        false\n      );\n    }, this.ssrOptions?.maxRenderTime ?? 300000); // 300000ms == 5 minutes\n\n    this.log(`Rendering started (${request?.originalUrl})`);\n    this.renderingCache.setAsRendering(renderingKey);\n    this.currentConcurrency++;\n\n    this.expressEngine(filePath, options, (err, html) => {\n      if (!maxRenderTimeout) {\n        // ignore this render's result because it exceeded maxRenderTimeout\n        this.log(\n          `Rendering of ${request.originalUrl} completed after the specified maxRenderTime, therefore it was ignored.`,\n          false\n        );\n        return;\n      }\n      clearTimeout(maxRenderTimeout);\n\n      this.log(`Rendering completed (${request?.originalUrl})`);\n      this.currentConcurrency--;\n\n      renderCallback(err, html);\n    });\n  }\n}\n","import { StaticProvider } from '@angular/core';\nimport { REQUEST } from '@nguniversal/express-engine/tokens';\nimport { SERVER_REQUEST_ORIGIN, SERVER_REQUEST_URL } from '@spartacus/core';\nimport { getRequestOrigin } from '../util/request-origin';\nimport { getRequestUrl } from '../util/request-url';\n\n/**\n * Returns Spartacus providers to be passed to the Angular express engine (in SSR)\n *\n * @param options\n */\nexport function getServerRequestProviders(): StaticProvider[] {\n  return [\n    {\n      provide: SERVER_REQUEST_URL,\n      useFactory: getRequestUrl,\n      deps: [REQUEST],\n    },\n    {\n      provide: SERVER_REQUEST_ORIGIN,\n      useFactory: getRequestOrigin,\n      deps: [REQUEST],\n    },\n  ];\n}\n","import { NgSetupOptions } from '@nguniversal/express-engine';\nimport {\n  OptimizedSsrEngine,\n  SsrCallbackFn,\n} from '../optimized-engine/optimized-ssr-engine';\nimport { SsrOptimizationOptions } from '../optimized-engine/ssr-optimization-options';\nimport { getServerRequestProviders } from '../providers/ssr-providers';\n\nexport type NgExpressEngineInstance = (\n  filePath: string,\n  options: object,\n  callback: SsrCallbackFn\n) => void;\n\nexport type NgExpressEngine = (\n  setupOptions: Readonly<NgSetupOptions>\n) => NgExpressEngineInstance;\n\n/**\n * The wrapper over the standard ngExpressEngine, that provides tokens for Spartacus\n * @param ngExpressEngine\n */\nexport class NgExpressEngineDecorator {\n  /**\n   * Returns the higher order ngExpressEngine with provided tokens for Spartacus\n   *\n   * @param ngExpressEngine\n   */\n  static get(\n    ngExpressEngine: NgExpressEngine,\n    optimizationOptions?: SsrOptimizationOptions | null\n  ): NgExpressEngine {\n    return decorateExpressEngine(ngExpressEngine, optimizationOptions);\n  }\n}\n\nexport function decorateExpressEngine(\n  ngExpressEngine: NgExpressEngine,\n  optimizationOptions: SsrOptimizationOptions | null = {\n    concurrency: 20,\n    timeout: 3000,\n  }\n): NgExpressEngine {\n  return function (setupOptions: NgSetupOptions) {\n    const engineInstance = ngExpressEngine({\n      ...setupOptions,\n      providers: [\n        // add spartacus related providers\n        ...getServerRequestProviders(),\n        ...(setupOptions.providers ?? []),\n      ],\n    });\n\n    // apply optimization wrapper if optimization options were defined\n    return optimizationOptions\n      ? new OptimizedSsrEngine(engineInstance, optimizationOptions)\n          .engineInstance\n      : engineInstance;\n  };\n}\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public_api';\n"],"names":[],"mappings":"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"}