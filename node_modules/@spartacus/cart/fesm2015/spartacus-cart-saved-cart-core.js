import * as i0 from '@angular/core';
import { Injectable, NgModule } from '@angular/core';
import * as i1$1 from '@ngrx/effects';
import { ofType, Effect, EffectsModule } from '@ngrx/effects';
import { RestoreSavedCartEvent, RestoreSavedCartSuccessEvent, RestoreSavedCartFailEvent, DeleteSavedCartEvent, DeleteSavedCartSuccessEvent, DeleteSavedCartFailEvent, SaveCartSuccessEvent, SaveCartFailEvent, SaveCartEvent, EditSavedCartSuccessEvent, EditSavedCartFailEvent, EditSavedCartEvent, CloneSavedCartEvent, CloneSavedCartSuccessEvent, CloneSavedCartFailEvent, SavedCartFacade } from '@spartacus/cart/saved-cart/root';
import * as i2 from '@spartacus/core';
import { StateUtils, MULTI_CART_DATA, PROCESS_FEATURE, CartActions, createFrom, normalizeHttpError, GlobalMessageType, getWishlistName, isSelectiveCart, ProcessSelectors } from '@spartacus/core';
import { of, queueScheduler, EMPTY, combineLatest } from 'rxjs';
import { switchMap, withLatestFrom, map, filter, catchError, observeOn, startWith, tap, pluck, shareReplay, distinctUntilChanged } from 'rxjs/operators';
import * as i1 from '@ngrx/store';
import { select } from '@ngrx/store';
import { __decorate } from 'tslib';

class SavedCartAdapter {
}

class SavedCartConnector {
    constructor(adapter) {
        this.adapter = adapter;
    }
    get(userId, cartId) {
        return this.adapter.load(userId, cartId);
    }
    getList(userId) {
        return this.adapter.loadList(userId);
    }
    restoreSavedCart(userId, cartId) {
        return this.adapter.restoreSavedCart(userId, cartId);
    }
    saveCart(userId, cartId, saveCartName, saveCartDescription) {
        return this.adapter.saveCart(userId, cartId, saveCartName, saveCartDescription);
    }
    cloneSavedCart(userId, cartId, saveCartName) {
        return this.adapter.cloneSavedCart(userId, cartId, saveCartName);
    }
}
SavedCartConnector.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SavedCartConnector, deps: [{ token: SavedCartAdapter }], target: i0.ɵɵFactoryTarget.Injectable });
SavedCartConnector.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SavedCartConnector });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SavedCartConnector, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: SavedCartAdapter }]; } });

const SAVED_CART_LIST_PROCESS_ID = 'saved-cart-list';
const SAVED_CART_RESTORE_CART_PROCESS_ID = 'saved-cart-restore-cart';
const SAVED_CART_SAVE_CART_PROCESS_ID = 'saved-cart-save-cart';
const SAVED_CART_CLONE_CART_PROCESS_ID = 'saved-cart-clone-cart';

const LOAD_SAVED_CART = '[Saved Cart] Load Saved Cart';
const LOAD_SAVED_CART_SUCCESS = '[Saved Cart] Load Saved Cart Success';
const LOAD_SAVED_CART_FAIL = '[Saved Cart] Load Saved Cart Fail';
const LOAD_SAVED_CARTS = '[Saved Cart] Load Saved Carts';
const LOAD_SAVED_CARTS_SUCCESS = '[Saved Cart] Load Saved Carts Success';
const LOAD_SAVED_CARTS_FAIL = '[Saved Cart] Load Saved Carts Fail';
const CLEAR_SAVED_CARTS = '[Saved Cart] Clear Saved Carts';
const RESTORE_SAVED_CART = '[Saved Cart] Restore Saved Cart';
const RESTORE_SAVED_CART_SUCCESS = '[Saved Cart] Restore Saved Cart Success';
const RESTORE_SAVED_CART_FAIL = '[Saved Cart] Restore Saved Cart Fail';
const CLEAR_RESTORE_SAVED_CART = '[Saved Cart] Clear Restore Saved Cart';
const SAVE_CART = '[Saved Cart] Save Cart';
const SAVE_CART_SUCCESS = '[Saved Cart] Save Cart Success';
const SAVE_CART_FAIL = '[Saved Cart] Save Cart Fail';
const CLEAR_SAVE_CART = '[Saved Cart] Clear Save Cart';
const EDIT_SAVED_CART = '[Saved Cart] Edit Saved Cart';
const EDIT_SAVED_CART_SUCCESS = '[Saved Cart] Edit Saved Cart Success';
const EDIT_SAVED_CART_FAIL = '[Saved Cart] Edit Saved Cart Fail';
const CLONE_SAVED_CART = '[Saved Cart] Clone Saved Cart';
const CLONE_SAVED_CART_SUCCESS = '[Saved Cart] Clone Saved Cart Success';
const CLONE_SAVED_CART_FAIL = '[Saved Cart] Clone Saved Cart Fail';
const CLEAR_CLONE_SAVED_CART = '[Saved Cart] Clear Clone Saved Cart';
class LoadSavedCart extends StateUtils.EntityLoadAction {
    constructor(payload) {
        super(MULTI_CART_DATA, payload.cartId);
        this.payload = payload;
        this.type = LOAD_SAVED_CART;
    }
}
class LoadSavedCartSuccess extends StateUtils.EntitySuccessAction {
    constructor(payload) {
        super(MULTI_CART_DATA, payload.cartId);
        this.payload = payload;
        this.type = LOAD_SAVED_CART_SUCCESS;
    }
}
class LoadSavedCartFail extends StateUtils.EntityFailAction {
    constructor(payload) {
        super(MULTI_CART_DATA, payload.cartId, payload === null || payload === void 0 ? void 0 : payload.error);
        this.payload = payload;
        this.type = LOAD_SAVED_CART_FAIL;
    }
}
class LoadSavedCarts extends StateUtils.EntityLoadAction {
    constructor(payload) {
        super(PROCESS_FEATURE, SAVED_CART_LIST_PROCESS_ID);
        this.payload = payload;
        this.type = LOAD_SAVED_CARTS;
    }
}
class LoadSavedCartsSuccess extends StateUtils.EntitySuccessAction {
    constructor(payload) {
        super(PROCESS_FEATURE, SAVED_CART_LIST_PROCESS_ID);
        this.payload = payload;
        this.type = LOAD_SAVED_CARTS_SUCCESS;
    }
}
class LoadSavedCartsFail extends StateUtils.EntityFailAction {
    constructor(payload) {
        super(PROCESS_FEATURE, SAVED_CART_LIST_PROCESS_ID, payload.error);
        this.payload = payload;
        this.type = LOAD_SAVED_CARTS_FAIL;
    }
}
class ClearSavedCarts extends StateUtils.EntityLoaderResetAction {
    constructor() {
        super(PROCESS_FEATURE, SAVED_CART_LIST_PROCESS_ID);
        this.type = CLEAR_SAVED_CARTS;
    }
}
class RestoreSavedCart extends StateUtils.EntityLoadAction {
    constructor(payload) {
        super(PROCESS_FEATURE, SAVED_CART_RESTORE_CART_PROCESS_ID);
        this.payload = payload;
        this.type = RESTORE_SAVED_CART;
    }
}
class RestoreSavedCartSuccess extends StateUtils.EntitySuccessAction {
    constructor(payload) {
        super(PROCESS_FEATURE, SAVED_CART_RESTORE_CART_PROCESS_ID);
        this.payload = payload;
        this.type = RESTORE_SAVED_CART_SUCCESS;
    }
}
class RestoreSavedCartFail extends StateUtils.EntityFailAction {
    constructor(payload) {
        super(PROCESS_FEATURE, SAVED_CART_RESTORE_CART_PROCESS_ID, payload.error);
        this.payload = payload;
        this.type = RESTORE_SAVED_CART_FAIL;
    }
}
class ClearRestoreSavedCart extends StateUtils.EntityLoaderResetAction {
    constructor() {
        super(PROCESS_FEATURE, SAVED_CART_RESTORE_CART_PROCESS_ID);
        this.type = CLEAR_RESTORE_SAVED_CART;
    }
}
class SaveCart extends StateUtils.EntityLoadAction {
    constructor(payload) {
        super(PROCESS_FEATURE, SAVED_CART_SAVE_CART_PROCESS_ID);
        this.payload = payload;
        this.type = SAVE_CART;
    }
}
class SaveCartSuccess extends StateUtils.EntitySuccessAction {
    constructor(payload) {
        super(PROCESS_FEATURE, SAVED_CART_SAVE_CART_PROCESS_ID);
        this.payload = payload;
        this.type = SAVE_CART_SUCCESS;
    }
}
class SaveCartFail extends StateUtils.EntityFailAction {
    constructor(payload) {
        super(PROCESS_FEATURE, SAVED_CART_SAVE_CART_PROCESS_ID, payload.error);
        this.payload = payload;
        this.type = SAVE_CART_FAIL;
    }
}
class ClearSaveCart extends StateUtils.EntityLoaderResetAction {
    constructor() {
        super(PROCESS_FEATURE, SAVED_CART_SAVE_CART_PROCESS_ID);
        this.type = CLEAR_SAVE_CART;
    }
}
class EditSavedCart extends StateUtils.EntityLoadAction {
    constructor(payload) {
        super(PROCESS_FEATURE, SAVED_CART_SAVE_CART_PROCESS_ID);
        this.payload = payload;
        this.type = EDIT_SAVED_CART;
    }
}
class EditSavedCartSuccess extends StateUtils.EntitySuccessAction {
    constructor(payload) {
        super(PROCESS_FEATURE, SAVED_CART_SAVE_CART_PROCESS_ID);
        this.payload = payload;
        this.type = EDIT_SAVED_CART_SUCCESS;
    }
}
class EditSavedCartFail extends StateUtils.EntityFailAction {
    constructor(payload) {
        super(PROCESS_FEATURE, SAVED_CART_SAVE_CART_PROCESS_ID, payload.error);
        this.payload = payload;
        this.type = EDIT_SAVED_CART_FAIL;
    }
}
class CloneSavedCart extends StateUtils.EntityLoadAction {
    constructor(payload) {
        super(PROCESS_FEATURE, SAVED_CART_CLONE_CART_PROCESS_ID);
        this.payload = payload;
        this.type = CLONE_SAVED_CART;
    }
}
class CloneSavedCartSuccess extends StateUtils.EntitySuccessAction {
    constructor(payload) {
        super(PROCESS_FEATURE, SAVED_CART_CLONE_CART_PROCESS_ID);
        this.payload = payload;
        this.type = CLONE_SAVED_CART_SUCCESS;
    }
}
class CloneSavedCartFail extends StateUtils.EntityFailAction {
    constructor(payload) {
        super(PROCESS_FEATURE, SAVED_CART_CLONE_CART_PROCESS_ID, payload.error);
        this.payload = payload;
        this.type = CLONE_SAVED_CART_FAIL;
    }
}
class ClearCloneSavedCart extends StateUtils.EntityLoaderResetAction {
    constructor() {
        super(PROCESS_FEATURE, SAVED_CART_CLONE_CART_PROCESS_ID);
        this.type = CLEAR_CLONE_SAVED_CART;
    }
}

var savedCart_action = /*#__PURE__*/Object.freeze({
    __proto__: null,
    LOAD_SAVED_CART: LOAD_SAVED_CART,
    LOAD_SAVED_CART_SUCCESS: LOAD_SAVED_CART_SUCCESS,
    LOAD_SAVED_CART_FAIL: LOAD_SAVED_CART_FAIL,
    LOAD_SAVED_CARTS: LOAD_SAVED_CARTS,
    LOAD_SAVED_CARTS_SUCCESS: LOAD_SAVED_CARTS_SUCCESS,
    LOAD_SAVED_CARTS_FAIL: LOAD_SAVED_CARTS_FAIL,
    CLEAR_SAVED_CARTS: CLEAR_SAVED_CARTS,
    RESTORE_SAVED_CART: RESTORE_SAVED_CART,
    RESTORE_SAVED_CART_SUCCESS: RESTORE_SAVED_CART_SUCCESS,
    RESTORE_SAVED_CART_FAIL: RESTORE_SAVED_CART_FAIL,
    CLEAR_RESTORE_SAVED_CART: CLEAR_RESTORE_SAVED_CART,
    SAVE_CART: SAVE_CART,
    SAVE_CART_SUCCESS: SAVE_CART_SUCCESS,
    SAVE_CART_FAIL: SAVE_CART_FAIL,
    CLEAR_SAVE_CART: CLEAR_SAVE_CART,
    EDIT_SAVED_CART: EDIT_SAVED_CART,
    EDIT_SAVED_CART_SUCCESS: EDIT_SAVED_CART_SUCCESS,
    EDIT_SAVED_CART_FAIL: EDIT_SAVED_CART_FAIL,
    CLONE_SAVED_CART: CLONE_SAVED_CART,
    CLONE_SAVED_CART_SUCCESS: CLONE_SAVED_CART_SUCCESS,
    CLONE_SAVED_CART_FAIL: CLONE_SAVED_CART_FAIL,
    CLEAR_CLONE_SAVED_CART: CLEAR_CLONE_SAVED_CART,
    LoadSavedCart: LoadSavedCart,
    LoadSavedCartSuccess: LoadSavedCartSuccess,
    LoadSavedCartFail: LoadSavedCartFail,
    LoadSavedCarts: LoadSavedCarts,
    LoadSavedCartsSuccess: LoadSavedCartsSuccess,
    LoadSavedCartsFail: LoadSavedCartsFail,
    ClearSavedCarts: ClearSavedCarts,
    RestoreSavedCart: RestoreSavedCart,
    RestoreSavedCartSuccess: RestoreSavedCartSuccess,
    RestoreSavedCartFail: RestoreSavedCartFail,
    ClearRestoreSavedCart: ClearRestoreSavedCart,
    SaveCart: SaveCart,
    SaveCartSuccess: SaveCartSuccess,
    SaveCartFail: SaveCartFail,
    ClearSaveCart: ClearSaveCart,
    EditSavedCart: EditSavedCart,
    EditSavedCartSuccess: EditSavedCartSuccess,
    EditSavedCartFail: EditSavedCartFail,
    CloneSavedCart: CloneSavedCart,
    CloneSavedCartSuccess: CloneSavedCartSuccess,
    CloneSavedCartFail: CloneSavedCartFail,
    ClearCloneSavedCart: ClearCloneSavedCart
});

class SavedCartEventBuilder {
    constructor(actionsSubject, eventService, stateEventService, multiCartService) {
        this.actionsSubject = actionsSubject;
        this.eventService = eventService;
        this.stateEventService = stateEventService;
        this.multiCartService = multiCartService;
        this.register();
    }
    /**
     * Registers events for the saved cart
     */
    register() {
        this.registerRestoreSavedCartEvents();
        this.registerDeleteSavedCartEvents();
        this.registerSaveCartEvents();
        this.registerEditSavedCartEvents();
        this.registerCloneSavedCartEvents();
    }
    /**
     * Registers restore saved cart events
     */
    registerRestoreSavedCartEvents() {
        this.buildRestoreSavedCartEvents({
            action: RESTORE_SAVED_CART,
            event: RestoreSavedCartEvent,
        });
        this.buildRestoreSavedCartEvents({
            action: RESTORE_SAVED_CART_SUCCESS,
            event: RestoreSavedCartSuccessEvent,
        });
        this.buildRestoreSavedCartEvents({
            action: RESTORE_SAVED_CART_FAIL,
            event: RestoreSavedCartFailEvent,
        });
    }
    /**
     * Registers delete saved cart events
     */
    registerDeleteSavedCartEvents() {
        this.stateEventService.register({
            action: CartActions.DELETE_CART,
            event: DeleteSavedCartEvent,
            factory: (action) => createFrom(DeleteSavedCartEvent, Object.assign(Object.assign({}, action.payload), { cartCode: action.payload.cartId })),
        });
        this.stateEventService.register({
            action: CartActions.DELETE_CART_SUCCESS,
            event: DeleteSavedCartSuccessEvent,
            factory: (action) => createFrom(DeleteSavedCartSuccessEvent, Object.assign(Object.assign({}, action.payload), { cartCode: action.payload.cartId })),
        });
        this.stateEventService.register({
            action: CartActions.DELETE_CART_FAIL,
            event: DeleteSavedCartFailEvent,
            factory: (action) => createFrom(DeleteSavedCartFailEvent, Object.assign(Object.assign({}, action.payload), { cartCode: action.payload.cartId })),
        });
    }
    /**
     * Registers save cart events
     */
    registerSaveCartEvents() {
        this.buildSaveCartSuccessEvent({
            action: SAVE_CART_SUCCESS,
            event: SaveCartSuccessEvent,
        });
        this.stateEventService.register({
            action: SAVE_CART_FAIL,
            event: SaveCartFailEvent,
            factory: (action) => createFrom(SaveCartFailEvent, Object.assign(Object.assign({}, action.payload), { cartCode: action.payload.cartId })),
        });
        this.stateEventService.register({
            action: SAVE_CART,
            event: SaveCartEvent,
            factory: (action) => {
                return createFrom(SaveCartEvent, Object.assign(Object.assign({}, action.payload), { cartCode: action.payload.cartId }));
            },
        });
    }
    /**
     * Registers edit saved cart events
     */
    registerEditSavedCartEvents() {
        this.buildSaveCartSuccessEvent({
            action: EDIT_SAVED_CART_SUCCESS,
            event: EditSavedCartSuccessEvent,
        });
        this.stateEventService.register({
            action: EDIT_SAVED_CART_FAIL,
            event: EditSavedCartFailEvent,
            factory: (action) => createFrom(EditSavedCartFailEvent, Object.assign(Object.assign({}, action.payload), { cartCode: action.payload.cartId })),
        });
        this.stateEventService.register({
            action: EDIT_SAVED_CART,
            event: EditSavedCartEvent,
            factory: (action) => {
                return createFrom(EditSavedCartEvent, Object.assign(Object.assign({}, action.payload), { cartCode: action.payload.cartId }));
            },
        });
    }
    /**
     * Registers clone saved cart events
     */
    registerCloneSavedCartEvents() {
        this.buildRestoreSavedCartEvents({
            action: CLONE_SAVED_CART,
            event: CloneSavedCartEvent,
        });
        this.buildRestoreSavedCartEvents({
            action: CLONE_SAVED_CART_SUCCESS,
            event: CloneSavedCartSuccessEvent,
        });
        this.buildRestoreSavedCartEvents({
            action: CLONE_SAVED_CART_FAIL,
            event: CloneSavedCartFailEvent,
        });
    }
    /**
     * Builds the restore save cart events from the action and cart
     *
     * @param mapping mapping declaration from `action` string type to `event` class type
     * @param saveTime should the saveTime attribute be added to the event
     * @returns
     */
    buildRestoreSavedCartEvents(mapping) {
        const eventStream$ = this.getAction(mapping.action).pipe(switchMap((action) => of(action).pipe(withLatestFrom(this.multiCartService.getCart(action.payload.cartId)))), map(([action, cart]) => createFrom(mapping.event, Object.assign(Object.assign(Object.assign({}, action.payload), { cartCode: cart.code, saveCartName: cart.name, saveCartDescription: cart.description }), (cart.saveTime && { saveTime: cart.saveTime })))));
        return this.eventService.register(mapping.event, eventStream$);
    }
    /**
     * Builds save cart event by adding the saveTime from the cart
     *
     * @param mapping mapping declaration from `action` string type to `event` class type
     * @returns events register function
     */
    buildSaveCartSuccessEvent(mapping) {
        const eventStream$ = this.getAction(mapping.action).pipe(switchMap((action) => of(action).pipe(withLatestFrom(this.multiCartService.getCart(action.payload.cartId)))), filter(([, cart]) => Boolean(cart)), map(([action, cart]) => createFrom(mapping.event, Object.assign(Object.assign({}, action.payload), { cartCode: cart.code, saveTime: cart.saveTime }))));
        return this.eventService.register(mapping.event, eventStream$);
    }
    /**
     * Returns a stream of actions only of a given type(s)
     *
     * @param actionType type(s) of actions
     */
    getAction(actionType) {
        return this.actionsSubject.pipe(ofType(...[].concat(actionType)));
    }
}
SavedCartEventBuilder.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SavedCartEventBuilder, deps: [{ token: i1.ActionsSubject }, { token: i2.EventService }, { token: i2.StateEventService }, { token: i2.MultiCartService }], target: i0.ɵɵFactoryTarget.Injectable });
SavedCartEventBuilder.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SavedCartEventBuilder, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SavedCartEventBuilder, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: function () { return [{ type: i1.ActionsSubject }, { type: i2.EventService }, { type: i2.StateEventService }, { type: i2.MultiCartService }]; } });

class SavedCartEventsModule {
    constructor(_savedCartEventBuilder) { }
}
SavedCartEventsModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SavedCartEventsModule, deps: [{ token: SavedCartEventBuilder }], target: i0.ɵɵFactoryTarget.NgModule });
SavedCartEventsModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SavedCartEventsModule });
SavedCartEventsModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SavedCartEventsModule });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SavedCartEventsModule, decorators: [{
            type: NgModule,
            args: [{}]
        }], ctorParameters: function () { return [{ type: SavedCartEventBuilder }]; } });

class SavedCartEffects {
    constructor(actions$, savedCartConnector, activeCartService, globalMessageService) {
        this.actions$ = actions$;
        this.savedCartConnector = savedCartConnector;
        this.activeCartService = activeCartService;
        this.globalMessageService = globalMessageService;
        this.loadSavedCart$ = this.actions$.pipe(ofType(LOAD_SAVED_CART), map((action) => action.payload), switchMap(({ userId, cartId }) => this.savedCartConnector.get(userId, cartId).pipe(switchMap((savedCart) => {
            return [
                new CartActions.LoadCartSuccess({
                    userId,
                    cartId,
                    cart: savedCart,
                }),
                new LoadSavedCartSuccess({ userId, cartId }),
            ];
        }), catchError((error) => of(new LoadSavedCartFail({
            userId,
            cartId,
            error: normalizeHttpError(error),
        }))))));
        this.loadSavedCarts$ = this.actions$.pipe(ofType(LOAD_SAVED_CARTS), map((action) => action.payload), switchMap(({ userId }) => this.savedCartConnector.getList(userId).pipe(switchMap((savedCarts) => {
            return [
                new CartActions.LoadCartsSuccess(savedCarts),
                new LoadSavedCartsSuccess({ userId }),
            ];
        }), catchError((error) => of(new LoadSavedCartsFail({
            userId,
            error: normalizeHttpError(error),
        }))))));
        this.restoreSavedCart$ = this.actions$.pipe(ofType(RESTORE_SAVED_CART), map((action) => action.payload), withLatestFrom(this.activeCartService.getActive()), switchMap(([{ userId, cartId }, activeCart]) => {
            var _a;
            const actions = [];
            if (((_a = activeCart === null || activeCart === void 0 ? void 0 : activeCart.entries) !== null && _a !== void 0 ? _a : []).length > 0) {
                if (activeCart.code) {
                    /**
                     * Instead of calling the SaveCartAction, we are calling the edit saved cart
                     * because we do not want to clear the state when we swap carts between active and saved cart
                     */
                    actions.push(new EditSavedCart({
                        userId,
                        cartId: activeCart.code,
                        saveCartName: '',
                        saveCartDescription: '',
                    }));
                }
            }
            return this.savedCartConnector.restoreSavedCart(userId, cartId).pipe(switchMap((savedCart) => {
                var _a;
                this.globalMessageService.add({
                    key: ((_a = activeCart === null || activeCart === void 0 ? void 0 : activeCart.entries) !== null && _a !== void 0 ? _a : []).length > 0
                        ? 'savedCartList.swapCartWithActiveCart'
                        : 'savedCartList.swapCartNoActiveCart',
                    params: {
                        cartName: cartId,
                        previousCartName: activeCart.code,
                    },
                }, GlobalMessageType.MSG_TYPE_CONFIRMATION);
                return [
                    ...actions,
                    new CartActions.SetActiveCartId(cartId),
                    new CartActions.LoadCartSuccess({
                        userId,
                        cartId,
                        cart: savedCart,
                    }),
                    new RestoreSavedCartSuccess({ userId, cartId }),
                ];
            }), catchError((error) => of(new RestoreSavedCartFail({
                userId,
                cartId,
                error: normalizeHttpError(error),
            }))));
        }));
        this.saveCart$ = this.actions$.pipe(ofType(SAVE_CART), map((action) => action.payload), switchMap(({ userId, cartId, saveCartName, saveCartDescription }) => {
            return this.savedCartConnector
                .saveCart(userId, cartId, saveCartName, saveCartDescription)
                .pipe(switchMap((savedCart) => {
                return [
                    new CartActions.ClearCartState(),
                    new CartActions.LoadCartSuccess({
                        userId,
                        cartId,
                        cart: savedCart,
                    }),
                    new SaveCartSuccess({
                        userId,
                        cartId,
                        saveCartName,
                        saveCartDescription,
                    }),
                ];
            }), catchError((error) => of(new SaveCartFail({
                userId,
                cartId,
                saveCartName,
                saveCartDescription,
                error: normalizeHttpError(error),
            }))));
        }));
        this.editSavedCart$ = this.actions$.pipe(ofType(EDIT_SAVED_CART), map((action) => action.payload), switchMap(({ userId, cartId, saveCartName, saveCartDescription }) => {
            return this.savedCartConnector
                .saveCart(userId, cartId, saveCartName, saveCartDescription)
                .pipe(switchMap((savedCart) => {
                return [
                    new CartActions.LoadCartSuccess({
                        userId,
                        cartId,
                        cart: savedCart,
                    }),
                    new EditSavedCartSuccess({
                        userId,
                        cartId,
                        saveCartName,
                        saveCartDescription,
                    }),
                ];
            }), catchError((error) => of(new EditSavedCartFail({
                userId,
                cartId,
                saveCartName,
                saveCartDescription,
                error: normalizeHttpError(error),
            }))));
        }));
        this.cloneSavedCart$ = this.actions$.pipe(ofType(CLONE_SAVED_CART), map((action) => action.payload), switchMap(({ userId, cartId, saveCartName }) => {
            return this.savedCartConnector
                .cloneSavedCart(userId, cartId, saveCartName)
                .pipe(switchMap((_) => {
                return [
                    new CloneSavedCartSuccess({
                        userId,
                        cartId,
                        saveCartName,
                    }),
                    new RestoreSavedCart({
                        userId,
                        cartId,
                    }),
                    new LoadSavedCarts({ userId }),
                ];
            }), catchError((error) => of(new CloneSavedCartFail({
                userId,
                cartId,
                saveCartName,
                error: normalizeHttpError(error),
            }))));
        }));
    }
}
SavedCartEffects.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SavedCartEffects, deps: [{ token: i1$1.Actions }, { token: SavedCartConnector }, { token: i2.ActiveCartService }, { token: i2.GlobalMessageService }], target: i0.ɵɵFactoryTarget.Injectable });
SavedCartEffects.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SavedCartEffects });
__decorate([
    Effect()
], SavedCartEffects.prototype, "loadSavedCart$", void 0);
__decorate([
    Effect()
], SavedCartEffects.prototype, "loadSavedCarts$", void 0);
__decorate([
    Effect()
], SavedCartEffects.prototype, "restoreSavedCart$", void 0);
__decorate([
    Effect()
], SavedCartEffects.prototype, "saveCart$", void 0);
__decorate([
    Effect()
], SavedCartEffects.prototype, "editSavedCart$", void 0);
__decorate([
    Effect()
], SavedCartEffects.prototype, "cloneSavedCart$", void 0);
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SavedCartEffects, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1$1.Actions }, { type: SavedCartConnector }, { type: i2.ActiveCartService }, { type: i2.GlobalMessageService }]; }, propDecorators: { loadSavedCart$: [], loadSavedCarts$: [], restoreSavedCart$: [], saveCart$: [], editSavedCart$: [], cloneSavedCart$: [] } });

const effects = [SavedCartEffects];

class SavedCartStoreModule {
}
SavedCartStoreModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SavedCartStoreModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
SavedCartStoreModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SavedCartStoreModule, imports: [i1$1.EffectsFeatureModule] });
SavedCartStoreModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SavedCartStoreModule, imports: [[EffectsModule.forFeature(effects)]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SavedCartStoreModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [EffectsModule.forFeature(effects)],
                }]
        }] });

class SavedCartService {
    constructor(store, userIdService, userService, multiCartService, eventService) {
        this.store = store;
        this.userIdService = userIdService;
        this.userService = userService;
        this.multiCartService = multiCartService;
        this.eventService = eventService;
    }
    /**
     * Loads a single saved cart
     */
    loadSavedCart(cartId) {
        this.userIdService.takeUserId(true).subscribe((userId) => {
            return this.store.dispatch(new LoadSavedCart({ userId, cartId }));
        }, () => {
            // TODO: for future releases, refactor this part to thrown errors
        });
    }
    /**
     * Gets a single saved cart
     * it won't emit if the delete saved cart event gets triggered to avoid race condition between actions
     *
     * @param cartId
     * @returns observable with cart
     */
    get(cartId) {
        return this.getSavedCart(cartId).pipe(observeOn(queueScheduler), withLatestFrom(this.eventService.get(DeleteSavedCartEvent).pipe(startWith({}))), filter(([state, _event]) => !!state), tap(([state, event]) => {
            if (Object.keys(event).length > 0) {
                return EMPTY;
            }
            if (!(state.loading || state.success || state.error)) {
                this.loadSavedCart(cartId);
            }
        }), filter(([state]) => state.success || !!state.error), map(([state]) => state.value));
    }
    /**
     * Gets the selected cart state
     *
     * @param cartId
     * @returns observable of selected cart with loader state
     */
    getSavedCart(cartId) {
        return this.multiCartService.getCartEntity(cartId);
    }
    /**
     * Returns true when there are no operations on that in progress and it is not currently loading
     *
     * @param cartId
     */
    isStable(cartId) {
        return this.multiCartService.isStable(cartId);
    }
    /**
     * Loads a list of saved carts
     */
    loadSavedCarts() {
        this.userIdService.takeUserId(true).subscribe((userId) => {
            return this.store.dispatch(new LoadSavedCarts({ userId }));
        }, () => {
            // TODO: for future releases, refactor this part to thrown errors
        });
    }
    /**
     * Gets a list of saved carts
     *
     * @returns observable with list of saved carts
     */
    getList() {
        return this.getSavedCartList().pipe(withLatestFrom(this.getSavedCartListProcess()), tap(([_, state]) => {
            if (!(state.loading || state.success || state.error)) {
                this.loadSavedCarts();
            }
        }), pluck(0), shareReplay({ bufferSize: 1, refCount: true }));
    }
    /**
     * Gets a list of saved carts from all carts in the state
     * by filtering through the carts that are not wishlist and not saved cart
     *
     * @returns observable with list of saved carts
     */
    getSavedCartList() {
        return combineLatest([
            this.multiCartService.getCarts(),
            this.userService.get(),
        ]).pipe(distinctUntilChanged(), map(([carts, user]) => carts.filter((cart) => ((user === null || user === void 0 ? void 0 : user.customerId) !== undefined
            ? (cart === null || cart === void 0 ? void 0 : cart.name) !== getWishlistName(user === null || user === void 0 ? void 0 : user.customerId)
            : true) &&
            !isSelectiveCart(cart === null || cart === void 0 ? void 0 : cart.code) &&
            (cart === null || cart === void 0 ? void 0 : cart.saveTime))));
    }
    /**
     * Gets the loading flag of getting a list of saved carts
     *
     * @returns observable with boolean of the loading state
     */
    getSavedCartListProcessLoading() {
        return this.store.pipe(select(ProcessSelectors.getProcessLoadingFactory(SAVED_CART_LIST_PROCESS_ID)));
    }
    /**
     * Gets the loading state of getting a list of saved carts
     *
     * @returns observable with boolean of the loader state
     */
    getSavedCartListProcess() {
        return this.store.pipe(select(ProcessSelectors.getProcessStateFactory(SAVED_CART_LIST_PROCESS_ID)));
    }
    /**
     * Clears the process state of performing a saved cart
     */
    clearSavedCarts() {
        this.store.dispatch(new ClearSavedCarts());
    }
    /**
     * Triggers a restore saved cart
     *
     * @param cartId
     */
    restoreSavedCart(cartId) {
        this.userIdService.takeUserId(true).subscribe((userId) => {
            return this.store.dispatch(new RestoreSavedCart({
                userId,
                cartId,
            }));
        }, () => {
            // TODO: for future releases, refactor this part to thrown errors
        });
    }
    /**
     * Gets the loading state of restoring saved cart
     *
     * @returns observable with boolean of the loading state
     */
    getRestoreSavedCartProcessLoading() {
        return this.store.pipe(select(ProcessSelectors.getProcessLoadingFactory(SAVED_CART_RESTORE_CART_PROCESS_ID)));
    }
    /**
     * Gets the success state of restoring saved cart
     *
     * @returns observable with boolean of the success state
     */
    getRestoreSavedCartProcessSuccess() {
        return this.store.pipe(select(ProcessSelectors.getProcessSuccessFactory(SAVED_CART_RESTORE_CART_PROCESS_ID)));
    }
    /**
     * Gets the error state of restoring saved cart
     *
     * @returns observable with boolean of the error state
     */
    getRestoreSavedCartProcessError() {
        return this.store.pipe(select(ProcessSelectors.getProcessErrorFactory(SAVED_CART_RESTORE_CART_PROCESS_ID)));
    }
    /**
     * Clears the process state of performing a restore saved cart
     */
    clearRestoreSavedCart() {
        this.store.dispatch(new ClearRestoreSavedCart());
    }
    /**
     * Triggers delete saved cart
     * @param cartId
     */
    deleteSavedCart(cartId) {
        this.userIdService.takeUserId(true).subscribe((userId) => {
            return this.multiCartService.deleteCart(cartId, userId);
        }, () => {
            // TODO: for future releases, refactor this part to thrown errors
        });
    }
    /**
     * Triggers a saved cart
     *
     */
    saveCart({ cartId, saveCartName, saveCartDescription, }) {
        this.userIdService.takeUserId(true).subscribe((userId) => {
            return this.store.dispatch(new SaveCart({
                userId,
                cartId,
                saveCartName,
                saveCartDescription,
            }));
        }, () => {
            // TODO: for future releases, refactor this part to thrown errors
        });
    }
    /**
     * Gets the loading state of saving a cart
     *
     * @returns observable with boolean of the loading state
     */
    getSaveCartProcessLoading() {
        return this.store.pipe(select(ProcessSelectors.getProcessLoadingFactory(SAVED_CART_SAVE_CART_PROCESS_ID)));
    }
    /**
     * Gets the success state of saving a cart
     *
     * @returns observable with boolean of the success state
     */
    getSaveCartProcessSuccess() {
        return this.store.pipe(select(ProcessSelectors.getProcessSuccessFactory(SAVED_CART_SAVE_CART_PROCESS_ID)));
    }
    /**
     * Gets the error state of saving a cart
     *
     * @returns observable with boolean of the error state
     */
    getSaveCartProcessError() {
        return this.store.pipe(select(ProcessSelectors.getProcessErrorFactory(SAVED_CART_SAVE_CART_PROCESS_ID)));
    }
    /**
     * Clears the process state of performing a save cart
     */
    clearSaveCart() {
        this.store.dispatch(new ClearSaveCart());
    }
    /**
     * Triggers an edit saved cart
     *
     */
    editSavedCart({ cartId, saveCartName, saveCartDescription, }) {
        this.userIdService.takeUserId(true).subscribe((userId) => {
            return this.store.dispatch(new EditSavedCart({
                userId,
                cartId,
                saveCartName,
                saveCartDescription,
            }));
        }, () => {
            // TODO: for future releases, refactor this part to thrown errors
        });
    }
    /**
     * Triggers a clone saved cart
     *
     * @param cartId
     */
    cloneSavedCart(cartId, saveCartName) {
        this.userIdService.takeUserId(true).subscribe((userId) => {
            return this.store.dispatch(new CloneSavedCart({ userId, cartId, saveCartName }));
        }, () => {
            // TODO: for future releases, refactor this part to thrown errors
        });
    }
    /**
     * Gets the loading state of cloning a saved cart
     *
     * @returns observable with boolean of the loading state
     */
    getCloneSavedCartProcessLoading() {
        return this.store.pipe(select(ProcessSelectors.getProcessLoadingFactory(SAVED_CART_CLONE_CART_PROCESS_ID)));
    }
    /**
     * Gets the success state of cloning a saved cart
     *
     * @returns observable with boolean of the success state
     */
    getCloneSavedCartProcessSuccess() {
        return this.store.pipe(select(ProcessSelectors.getProcessSuccessFactory(SAVED_CART_CLONE_CART_PROCESS_ID)));
    }
    /**
     * Gets the error state of cloning a saved cart
     *
     * @returns observable with boolean of the error state
     */
    getCloneSavedCartProcessError() {
        return this.store.pipe(select(ProcessSelectors.getProcessErrorFactory(SAVED_CART_CLONE_CART_PROCESS_ID)));
    }
    /**
     * Clears the process state of cloning a saved cart
     */
    clearCloneSavedCart() {
        this.store.dispatch(new ClearCloneSavedCart());
    }
}
SavedCartService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SavedCartService, deps: [{ token: i1.Store }, { token: i2.UserIdService }, { token: i2.UserService }, { token: i2.MultiCartService }, { token: i2.EventService }], target: i0.ɵɵFactoryTarget.Injectable });
SavedCartService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SavedCartService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SavedCartService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.Store }, { type: i2.UserIdService }, { type: i2.UserService }, { type: i2.MultiCartService }, { type: i2.EventService }]; } });

const facadeProviders = [
    SavedCartService,
    {
        provide: SavedCartFacade,
        useExisting: SavedCartService,
    },
];

class SavedCartCoreModule {
}
SavedCartCoreModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SavedCartCoreModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
SavedCartCoreModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SavedCartCoreModule, imports: [SavedCartStoreModule, SavedCartEventsModule] });
SavedCartCoreModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SavedCartCoreModule, providers: [SavedCartConnector, ...facadeProviders], imports: [[SavedCartStoreModule, SavedCartEventsModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SavedCartCoreModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [SavedCartStoreModule, SavedCartEventsModule],
                    providers: [SavedCartConnector, ...facadeProviders],
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { SAVED_CART_CLONE_CART_PROCESS_ID, SAVED_CART_LIST_PROCESS_ID, SAVED_CART_RESTORE_CART_PROCESS_ID, SAVED_CART_SAVE_CART_PROCESS_ID, savedCart_action as SavedCartActions, SavedCartAdapter, SavedCartConnector, SavedCartCoreModule, SavedCartEventBuilder, SavedCartEventsModule, SavedCartService };
//# sourceMappingURL=spartacus-cart-saved-cart-core.js.map
