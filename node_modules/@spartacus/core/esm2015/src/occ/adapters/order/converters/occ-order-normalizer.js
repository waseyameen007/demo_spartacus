import { Injectable } from '@angular/core';
import { PRODUCT_NORMALIZER } from '../../../../product/connectors/product/converters';
import * as i0 from "@angular/core";
import * as i1 from "../../../../util/converter.service";
import * as i2 from "../../cart/converters/order-entry-promotions-service";
export class OccOrderNormalizer {
    constructor(converter, entryPromotionService) {
        this.converter = converter;
        this.entryPromotionService = entryPromotionService;
    }
    convert(source, target) {
        if (target === undefined) {
            target = Object.assign({}, source);
        }
        if (source.entries) {
            target.entries = source.entries.map((entry) => this.convertOrderEntry(entry, source.code, source.appliedProductPromotions));
        }
        if (source.consignments) {
            target.consignments = source.consignments.map((consignment) => {
                var _a;
                return (Object.assign(Object.assign({}, consignment), { entries: (_a = consignment.entries) === null || _a === void 0 ? void 0 : _a.map((entry) => (Object.assign(Object.assign({}, entry), { orderEntry: this.convertOrderEntry(entry.orderEntry, source.code, source.appliedProductPromotions) }))) }));
            });
        }
        if (source.unconsignedEntries) {
            target.unconsignedEntries = source.unconsignedEntries.map((entry) => this.convertOrderEntry(entry, source.code, source.appliedProductPromotions));
        }
        return target;
    }
    convertOrderEntry(source, code, promotions) {
        return Object.assign(Object.assign({}, source), { product: this.converter.convert(source === null || source === void 0 ? void 0 : source.product, PRODUCT_NORMALIZER), orderCode: code, promotions: this.entryPromotionService
                ? this.entryPromotionService.getProductPromotion(source, promotions)
                : [] });
    }
}
OccOrderNormalizer.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OccOrderNormalizer, deps: [{ token: i1.ConverterService }, { token: i2.OrderEntryPromotionsService }], target: i0.ɵɵFactoryTarget.Injectable });
OccOrderNormalizer.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OccOrderNormalizer, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OccOrderNormalizer, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: function () { return [{ type: i1.ConverterService }, { type: i2.OrderEntryPromotionsService }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib2NjLW9yZGVyLW5vcm1hbGl6ZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9jb3JlL3NyYy9vY2MvYWRhcHRlcnMvb3JkZXIvY29udmVydGVycy9vY2Mtb3JkZXItbm9ybWFsaXplci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBRzNDLE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLG1EQUFtRCxDQUFDOzs7O0FBU3ZGLE1BQU0sT0FBTyxrQkFBa0I7SUFDN0IsWUFDVSxTQUEyQixFQUMzQixxQkFBbUQ7UUFEbkQsY0FBUyxHQUFULFNBQVMsQ0FBa0I7UUFDM0IsMEJBQXFCLEdBQXJCLHFCQUFxQixDQUE4QjtJQUMxRCxDQUFDO0lBRUosT0FBTyxDQUFDLE1BQWlCLEVBQUUsTUFBYztRQUN2QyxJQUFJLE1BQU0sS0FBSyxTQUFTLEVBQUU7WUFDeEIsTUFBTSxHQUFHLGtCQUFNLE1BQWMsQ0FBVyxDQUFDO1NBQzFDO1FBRUQsSUFBSSxNQUFNLENBQUMsT0FBTyxFQUFFO1lBQ2xCLE1BQU0sQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUM1QyxJQUFJLENBQUMsaUJBQWlCLENBQ3BCLEtBQUssRUFDTCxNQUFNLENBQUMsSUFBSSxFQUNYLE1BQU0sQ0FBQyx3QkFBd0IsQ0FDaEMsQ0FDRixDQUFDO1NBQ0g7UUFFRCxJQUFJLE1BQU0sQ0FBQyxZQUFZLEVBQUU7WUFDdkIsTUFBTSxDQUFDLFlBQVksR0FBRyxNQUFNLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxDQUFDLFdBQVcsRUFBRSxFQUFFOztnQkFBQyxPQUFBLGlDQUMxRCxXQUFXLEtBQ2QsT0FBTyxFQUFFLE1BQUEsV0FBVyxDQUFDLE9BQU8sMENBQUUsR0FBRyxDQUFDLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxpQ0FDeEMsS0FBSyxLQUNSLFVBQVUsRUFBRSxJQUFJLENBQUMsaUJBQWlCLENBQ2hDLEtBQUssQ0FBQyxVQUFVLEVBQ2hCLE1BQU0sQ0FBQyxJQUFJLEVBQ1gsTUFBTSxDQUFDLHdCQUF3QixDQUNoQyxJQUNELENBQUMsSUFDSCxDQUFBO2FBQUEsQ0FBQyxDQUFDO1NBQ0w7UUFFRCxJQUFJLE1BQU0sQ0FBQyxrQkFBa0IsRUFBRTtZQUM3QixNQUFNLENBQUMsa0JBQWtCLEdBQUcsTUFBTSxDQUFDLGtCQUFrQixDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQ2xFLElBQUksQ0FBQyxpQkFBaUIsQ0FDcEIsS0FBSyxFQUNMLE1BQU0sQ0FBQyxJQUFJLEVBQ1gsTUFBTSxDQUFDLHdCQUF3QixDQUNoQyxDQUNGLENBQUM7U0FDSDtRQUVELE9BQU8sTUFBTSxDQUFDO0lBQ2hCLENBQUM7SUFFTyxpQkFBaUIsQ0FDdkIsTUFBdUIsRUFDdkIsSUFBYSxFQUNiLFVBQThCO1FBRTlCLHVDQUNLLE1BQU0sS0FDVCxPQUFPLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsTUFBTSxhQUFOLE1BQU0sdUJBQU4sTUFBTSxDQUFFLE9BQU8sRUFBRSxrQkFBa0IsQ0FBQyxFQUNwRSxTQUFTLEVBQUUsSUFBSSxFQUNmLFVBQVUsRUFBRSxJQUFJLENBQUMscUJBQXFCO2dCQUNwQyxDQUFDLENBQUMsSUFBSSxDQUFDLHFCQUFxQixDQUFDLG1CQUFtQixDQUFDLE1BQU0sRUFBRSxVQUFVLENBQUM7Z0JBQ3BFLENBQUMsQ0FBQyxFQUFFLElBQ047SUFDSixDQUFDOzsrR0E3RFUsa0JBQWtCO21IQUFsQixrQkFBa0IsY0FETCxNQUFNOzJGQUNuQixrQkFBa0I7a0JBRDlCLFVBQVU7bUJBQUMsRUFBRSxVQUFVLEVBQUUsTUFBTSxFQUFFIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgUHJvbW90aW9uUmVzdWx0IH0gZnJvbSAnLi4vLi4vLi4vLi4vbW9kZWwvY2FydC5tb2RlbCc7XG5pbXBvcnQgeyBPcmRlciwgT3JkZXJFbnRyeSB9IGZyb20gJy4uLy4uLy4uLy4uL21vZGVsL29yZGVyLm1vZGVsJztcbmltcG9ydCB7IFBST0RVQ1RfTk9STUFMSVpFUiB9IGZyb20gJy4uLy4uLy4uLy4uL3Byb2R1Y3QvY29ubmVjdG9ycy9wcm9kdWN0L2NvbnZlcnRlcnMnO1xuaW1wb3J0IHtcbiAgQ29udmVydGVyLFxuICBDb252ZXJ0ZXJTZXJ2aWNlLFxufSBmcm9tICcuLi8uLi8uLi8uLi91dGlsL2NvbnZlcnRlci5zZXJ2aWNlJztcbmltcG9ydCB7IE9jYyB9IGZyb20gJy4uLy4uLy4uL29jYy1tb2RlbHMvb2NjLm1vZGVscyc7XG5pbXBvcnQgeyBPcmRlckVudHJ5UHJvbW90aW9uc1NlcnZpY2UgfSBmcm9tICcuLi8uLi9jYXJ0L2NvbnZlcnRlcnMvb3JkZXItZW50cnktcHJvbW90aW9ucy1zZXJ2aWNlJztcblxuQEluamVjdGFibGUoeyBwcm92aWRlZEluOiAncm9vdCcgfSlcbmV4cG9ydCBjbGFzcyBPY2NPcmRlck5vcm1hbGl6ZXIgaW1wbGVtZW50cyBDb252ZXJ0ZXI8T2NjLk9yZGVyLCBPcmRlcj4ge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIGNvbnZlcnRlcjogQ29udmVydGVyU2VydmljZSxcbiAgICBwcml2YXRlIGVudHJ5UHJvbW90aW9uU2VydmljZT86IE9yZGVyRW50cnlQcm9tb3Rpb25zU2VydmljZVxuICApIHt9XG5cbiAgY29udmVydChzb3VyY2U6IE9jYy5PcmRlciwgdGFyZ2V0PzogT3JkZXIpOiBPcmRlciB7XG4gICAgaWYgKHRhcmdldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0YXJnZXQgPSB7IC4uLihzb3VyY2UgYXMgYW55KSB9IGFzIE9yZGVyO1xuICAgIH1cblxuICAgIGlmIChzb3VyY2UuZW50cmllcykge1xuICAgICAgdGFyZ2V0LmVudHJpZXMgPSBzb3VyY2UuZW50cmllcy5tYXAoKGVudHJ5KSA9PlxuICAgICAgICB0aGlzLmNvbnZlcnRPcmRlckVudHJ5KFxuICAgICAgICAgIGVudHJ5LFxuICAgICAgICAgIHNvdXJjZS5jb2RlLFxuICAgICAgICAgIHNvdXJjZS5hcHBsaWVkUHJvZHVjdFByb21vdGlvbnNcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoc291cmNlLmNvbnNpZ25tZW50cykge1xuICAgICAgdGFyZ2V0LmNvbnNpZ25tZW50cyA9IHNvdXJjZS5jb25zaWdubWVudHMubWFwKChjb25zaWdubWVudCkgPT4gKHtcbiAgICAgICAgLi4uY29uc2lnbm1lbnQsXG4gICAgICAgIGVudHJpZXM6IGNvbnNpZ25tZW50LmVudHJpZXM/Lm1hcCgoZW50cnkpID0+ICh7XG4gICAgICAgICAgLi4uZW50cnksXG4gICAgICAgICAgb3JkZXJFbnRyeTogdGhpcy5jb252ZXJ0T3JkZXJFbnRyeShcbiAgICAgICAgICAgIGVudHJ5Lm9yZGVyRW50cnksXG4gICAgICAgICAgICBzb3VyY2UuY29kZSxcbiAgICAgICAgICAgIHNvdXJjZS5hcHBsaWVkUHJvZHVjdFByb21vdGlvbnNcbiAgICAgICAgICApLFxuICAgICAgICB9KSksXG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgaWYgKHNvdXJjZS51bmNvbnNpZ25lZEVudHJpZXMpIHtcbiAgICAgIHRhcmdldC51bmNvbnNpZ25lZEVudHJpZXMgPSBzb3VyY2UudW5jb25zaWduZWRFbnRyaWVzLm1hcCgoZW50cnkpID0+XG4gICAgICAgIHRoaXMuY29udmVydE9yZGVyRW50cnkoXG4gICAgICAgICAgZW50cnksXG4gICAgICAgICAgc291cmNlLmNvZGUsXG4gICAgICAgICAgc291cmNlLmFwcGxpZWRQcm9kdWN0UHJvbW90aW9uc1xuICAgICAgICApXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cblxuICBwcml2YXRlIGNvbnZlcnRPcmRlckVudHJ5KFxuICAgIHNvdXJjZT86IE9jYy5PcmRlckVudHJ5LFxuICAgIGNvZGU/OiBzdHJpbmcsXG4gICAgcHJvbW90aW9ucz86IFByb21vdGlvblJlc3VsdFtdXG4gICk6IE9yZGVyRW50cnkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zb3VyY2UsXG4gICAgICBwcm9kdWN0OiB0aGlzLmNvbnZlcnRlci5jb252ZXJ0KHNvdXJjZT8ucHJvZHVjdCwgUFJPRFVDVF9OT1JNQUxJWkVSKSxcbiAgICAgIG9yZGVyQ29kZTogY29kZSxcbiAgICAgIHByb21vdGlvbnM6IHRoaXMuZW50cnlQcm9tb3Rpb25TZXJ2aWNlXG4gICAgICAgID8gdGhpcy5lbnRyeVByb21vdGlvblNlcnZpY2UuZ2V0UHJvZHVjdFByb21vdGlvbihzb3VyY2UsIHByb21vdGlvbnMpXG4gICAgICAgIDogW10sXG4gICAgfTtcbiAgfVxufVxuIl19