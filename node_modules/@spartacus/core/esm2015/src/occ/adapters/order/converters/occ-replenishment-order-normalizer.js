import { Injectable } from '@angular/core';
import { PRODUCT_NORMALIZER } from '../../../../product/connectors/product/converters';
import * as i0 from "@angular/core";
import * as i1 from "../../../../util/converter.service";
import * as i2 from "../../cart/converters/order-entry-promotions-service";
export class OccReplenishmentOrderNormalizer {
    constructor(converter, entryPromotionService) {
        this.converter = converter;
        this.entryPromotionService = entryPromotionService;
    }
    convert(source, target) {
        if (target === undefined) {
            target = Object.assign({}, source);
        }
        if (source.entries) {
            target.entries = source.entries.map((entry) => (Object.assign(Object.assign({}, entry), { product: this.converter.convert(entry.product, PRODUCT_NORMALIZER), promotions: this.entryPromotionService
                    ? this.entryPromotionService.getProductPromotion(entry, source.appliedProductPromotions)
                    : [] })));
        }
        return target;
    }
}
OccReplenishmentOrderNormalizer.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OccReplenishmentOrderNormalizer, deps: [{ token: i1.ConverterService }, { token: i2.OrderEntryPromotionsService }], target: i0.ɵɵFactoryTarget.Injectable });
OccReplenishmentOrderNormalizer.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OccReplenishmentOrderNormalizer, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OccReplenishmentOrderNormalizer, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: function () { return [{ type: i1.ConverterService }, { type: i2.OrderEntryPromotionsService }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib2NjLXJlcGxlbmlzaG1lbnQtb3JkZXItbm9ybWFsaXplci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2NvcmUvc3JjL29jYy9hZGFwdGVycy9vcmRlci9jb252ZXJ0ZXJzL29jYy1yZXBsZW5pc2htZW50LW9yZGVyLW5vcm1hbGl6ZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUUzQyxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSxtREFBbUQsQ0FBQzs7OztBQVN2RixNQUFNLE9BQU8sK0JBQStCO0lBRzFDLFlBQ1UsU0FBMkIsRUFDM0IscUJBQW1EO1FBRG5ELGNBQVMsR0FBVCxTQUFTLENBQWtCO1FBQzNCLDBCQUFxQixHQUFyQixxQkFBcUIsQ0FBOEI7SUFDMUQsQ0FBQztJQUVKLE9BQU8sQ0FDTCxNQUE4QixFQUM5QixNQUEyQjtRQUUzQixJQUFJLE1BQU0sS0FBSyxTQUFTLEVBQUU7WUFDeEIsTUFBTSxHQUFHLGtCQUFNLE1BQWMsQ0FBd0IsQ0FBQztTQUN2RDtRQUVELElBQUksTUFBTSxDQUFDLE9BQU8sRUFBRTtZQUNsQixNQUFNLENBQUMsT0FBTyxHQUFHLE1BQU0sQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxpQ0FDMUMsS0FBSyxLQUNSLE9BQU8sRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsT0FBTyxFQUFFLGtCQUFrQixDQUFDLEVBQ2xFLFVBQVUsRUFBRSxJQUFJLENBQUMscUJBQXFCO29CQUNwQyxDQUFDLENBQUMsSUFBSSxDQUFDLHFCQUFxQixDQUFDLG1CQUFtQixDQUM1QyxLQUFLLEVBQ0wsTUFBTSxDQUFDLHdCQUF3QixDQUNoQztvQkFDSCxDQUFDLENBQUMsRUFBRSxJQUNOLENBQUMsQ0FBQztTQUNMO1FBRUQsT0FBTyxNQUFNLENBQUM7SUFDaEIsQ0FBQzs7NEhBOUJVLCtCQUErQjtnSUFBL0IsK0JBQStCLGNBRGxCLE1BQU07MkZBQ25CLCtCQUErQjtrQkFEM0MsVUFBVTttQkFBQyxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUUiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBSZXBsZW5pc2htZW50T3JkZXIgfSBmcm9tICcuLi8uLi8uLi8uLi9tb2RlbC9yZXBsZW5pc2htZW50LW9yZGVyLm1vZGVsJztcbmltcG9ydCB7IFBST0RVQ1RfTk9STUFMSVpFUiB9IGZyb20gJy4uLy4uLy4uLy4uL3Byb2R1Y3QvY29ubmVjdG9ycy9wcm9kdWN0L2NvbnZlcnRlcnMnO1xuaW1wb3J0IHtcbiAgQ29udmVydGVyLFxuICBDb252ZXJ0ZXJTZXJ2aWNlLFxufSBmcm9tICcuLi8uLi8uLi8uLi91dGlsL2NvbnZlcnRlci5zZXJ2aWNlJztcbmltcG9ydCB7IE9jYyB9IGZyb20gJy4uLy4uLy4uL29jYy1tb2RlbHMvb2NjLm1vZGVscyc7XG5pbXBvcnQgeyBPcmRlckVudHJ5UHJvbW90aW9uc1NlcnZpY2UgfSBmcm9tICcuLi8uLi9jYXJ0L2NvbnZlcnRlcnMvb3JkZXItZW50cnktcHJvbW90aW9ucy1zZXJ2aWNlJztcblxuQEluamVjdGFibGUoeyBwcm92aWRlZEluOiAncm9vdCcgfSlcbmV4cG9ydCBjbGFzcyBPY2NSZXBsZW5pc2htZW50T3JkZXJOb3JtYWxpemVyXG4gIGltcGxlbWVudHMgQ29udmVydGVyPE9jYy5SZXBsZW5pc2htZW50T3JkZXIsIFJlcGxlbmlzaG1lbnRPcmRlcj5cbntcbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBjb252ZXJ0ZXI6IENvbnZlcnRlclNlcnZpY2UsXG4gICAgcHJpdmF0ZSBlbnRyeVByb21vdGlvblNlcnZpY2U/OiBPcmRlckVudHJ5UHJvbW90aW9uc1NlcnZpY2VcbiAgKSB7fVxuXG4gIGNvbnZlcnQoXG4gICAgc291cmNlOiBPY2MuUmVwbGVuaXNobWVudE9yZGVyLFxuICAgIHRhcmdldD86IFJlcGxlbmlzaG1lbnRPcmRlclxuICApOiBSZXBsZW5pc2htZW50T3JkZXIge1xuICAgIGlmICh0YXJnZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGFyZ2V0ID0geyAuLi4oc291cmNlIGFzIGFueSkgfSBhcyBSZXBsZW5pc2htZW50T3JkZXI7XG4gICAgfVxuXG4gICAgaWYgKHNvdXJjZS5lbnRyaWVzKSB7XG4gICAgICB0YXJnZXQuZW50cmllcyA9IHNvdXJjZS5lbnRyaWVzLm1hcCgoZW50cnkpID0+ICh7XG4gICAgICAgIC4uLmVudHJ5LFxuICAgICAgICBwcm9kdWN0OiB0aGlzLmNvbnZlcnRlci5jb252ZXJ0KGVudHJ5LnByb2R1Y3QsIFBST0RVQ1RfTk9STUFMSVpFUiksXG4gICAgICAgIHByb21vdGlvbnM6IHRoaXMuZW50cnlQcm9tb3Rpb25TZXJ2aWNlXG4gICAgICAgICAgPyB0aGlzLmVudHJ5UHJvbW90aW9uU2VydmljZS5nZXRQcm9kdWN0UHJvbW90aW9uKFxuICAgICAgICAgICAgICBlbnRyeSxcbiAgICAgICAgICAgICAgc291cmNlLmFwcGxpZWRQcm9kdWN0UHJvbW90aW9uc1xuICAgICAgICAgICAgKVxuICAgICAgICAgIDogW10sXG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxufVxuIl19