import { Injectable } from '@angular/core';
import * as i0 from "@angular/core";
import * as i1 from "../config/occ-config";
export class LoadingScopesService {
    constructor(config) {
        this.config = config;
    }
    /**
     * Aims to expand scopes based on loading scopes config.
     *
     * I.e. if 'details' scope includes 'list' scope by configuration, it'll return ['details', 'list']
     *
     * If scope data overlaps with each other, the data should be merged in the order of scopes provided,
     * i.e. the last scope is merged last, overwriting parts of the data already provided by preceding scope.
     * It should apply also to implicit scopes (that are included by configuration).
     *
     * @param model
     * @param scopes
     */
    expand(model, scopes) {
        var _a, _b, _c, _d;
        const scopesConfig = (_c = (_b = (_a = this.config) === null || _a === void 0 ? void 0 : _a.backend) === null || _b === void 0 ? void 0 : _b.loadingScopes) === null || _c === void 0 ? void 0 : _c[model];
        if (scopesConfig) {
            const expandedScopes = [...scopes];
            let i = expandedScopes.length;
            while (i > 0) {
                i--;
                const includedScopes = (_d = scopesConfig[expandedScopes[i]]) === null || _d === void 0 ? void 0 : _d.include;
                if (includedScopes) {
                    for (const includedScope of includedScopes) {
                        if (!expandedScopes.includes(includedScope)) {
                            expandedScopes.splice(i, 0, includedScope);
                            i++;
                        }
                    }
                }
            }
            return expandedScopes;
        }
        return scopes;
    }
    /**
     * Return maxAge for product scope in milliseconds
     *
     * @param model
     * @param scope
     */
    getMaxAge(model, scope) {
        var _a, _b, _c, _d, _e;
        const configuredMaxAge = (_e = (_d = (_c = (_b = (_a = this.config.backend) === null || _a === void 0 ? void 0 : _a.loadingScopes) === null || _b === void 0 ? void 0 : _b[model]) === null || _c === void 0 ? void 0 : _c[scope]) === null || _d === void 0 ? void 0 : _d.maxAge) !== null && _e !== void 0 ? _e : 0;
        return configuredMaxAge * 1000;
    }
    /**
     *
     * Returns the configured triggers for which to reload the product.
     *
     * @param model for which to look up the scopes (usually a 'product')
     * @param scope for which to look up the config
     * @returns the configured triggers, or an empty array if not configured
     */
    getReloadTriggers(model, scope) {
        var _a, _b, _c, _d, _e;
        return (_e = (_d = (_c = (_b = (_a = this.config.backend) === null || _a === void 0 ? void 0 : _a.loadingScopes) === null || _b === void 0 ? void 0 : _b[model]) === null || _c === void 0 ? void 0 : _c[scope]) === null || _d === void 0 ? void 0 : _d.reloadOn) !== null && _e !== void 0 ? _e : [];
    }
}
LoadingScopesService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: LoadingScopesService, deps: [{ token: i1.OccConfig }], target: i0.ɵɵFactoryTarget.Injectable });
LoadingScopesService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: LoadingScopesService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: LoadingScopesService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.OccConfig }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibG9hZGluZy1zY29wZXMuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2NvcmUvc3JjL29jYy9zZXJ2aWNlcy9sb2FkaW5nLXNjb3Blcy5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQVEsTUFBTSxlQUFlLENBQUM7OztBQU9qRCxNQUFNLE9BQU8sb0JBQW9CO0lBQy9CLFlBQXNCLE1BQWlCO1FBQWpCLFdBQU0sR0FBTixNQUFNLENBQVc7SUFBRyxDQUFDO0lBRTNDOzs7Ozs7Ozs7OztPQVdHO0lBQ0gsTUFBTSxDQUFDLEtBQWEsRUFBRSxNQUFnQjs7UUFDcEMsTUFBTSxZQUFZLEdBQUcsTUFBQSxNQUFBLE1BQUEsSUFBSSxDQUFDLE1BQU0sMENBQUUsT0FBTywwQ0FBRSxhQUFhLDBDQUFHLEtBQUssQ0FBQyxDQUFDO1FBRWxFLElBQUksWUFBWSxFQUFFO1lBQ2hCLE1BQU0sY0FBYyxHQUFHLENBQUMsR0FBRyxNQUFNLENBQUMsQ0FBQztZQUNuQyxJQUFJLENBQUMsR0FBRyxjQUFjLENBQUMsTUFBTSxDQUFDO1lBRTlCLE9BQU8sQ0FBQyxHQUFHLENBQUMsRUFBRTtnQkFDWixDQUFDLEVBQUUsQ0FBQztnQkFDSixNQUFNLGNBQWMsR0FBRyxNQUFBLFlBQVksQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLENBQUMsMENBQUUsT0FBTyxDQUFDO2dCQUNoRSxJQUFJLGNBQWMsRUFBRTtvQkFDbEIsS0FBSyxNQUFNLGFBQWEsSUFBSSxjQUFjLEVBQUU7d0JBQzFDLElBQUksQ0FBQyxjQUFjLENBQUMsUUFBUSxDQUFDLGFBQWEsQ0FBQyxFQUFFOzRCQUMzQyxjQUFjLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsYUFBYSxDQUFDLENBQUM7NEJBQzNDLENBQUMsRUFBRSxDQUFDO3lCQUNMO3FCQUNGO2lCQUNGO2FBQ0Y7WUFFRCxPQUFPLGNBQWMsQ0FBQztTQUN2QjtRQUVELE9BQU8sTUFBTSxDQUFDO0lBQ2hCLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILFNBQVMsQ0FBQyxLQUFhLEVBQUUsS0FBYTs7UUFDcEMsTUFBTSxnQkFBZ0IsR0FDcEIsTUFBQSxNQUFBLE1BQUEsTUFBQSxNQUFBLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTywwQ0FBRSxhQUFhLDBDQUFHLEtBQUssQ0FBQywwQ0FBRyxLQUFLLENBQUMsMENBQUUsTUFBTSxtQ0FBSSxDQUFDLENBQUM7UUFDcEUsT0FBTyxnQkFBZ0IsR0FBRyxJQUFJLENBQUM7SUFDakMsQ0FBQztJQUVEOzs7Ozs7O09BT0c7SUFDSCxpQkFBaUIsQ0FBQyxLQUFhLEVBQUUsS0FBYTs7UUFDNUMsT0FBTyxNQUFBLE1BQUEsTUFBQSxNQUFBLE1BQUEsSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLDBDQUFFLGFBQWEsMENBQUcsS0FBSyxDQUFDLDBDQUFHLEtBQUssQ0FBQywwQ0FBRSxRQUFRLG1DQUFJLEVBQUUsQ0FBQztJQUM5RSxDQUFDOztpSEEvRFUsb0JBQW9CO3FIQUFwQixvQkFBb0IsY0FGbkIsTUFBTTsyRkFFUCxvQkFBb0I7a0JBSGhDLFVBQVU7bUJBQUM7b0JBQ1YsVUFBVSxFQUFFLE1BQU07aUJBQ25CIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSwgVHlwZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ3hFdmVudCB9IGZyb20gJy4uLy4uL2V2ZW50L2N4LWV2ZW50JztcbmltcG9ydCB7IE9jY0NvbmZpZyB9IGZyb20gJy4uL2NvbmZpZy9vY2MtY29uZmlnJztcblxuQEluamVjdGFibGUoe1xuICBwcm92aWRlZEluOiAncm9vdCcsXG59KVxuZXhwb3J0IGNsYXNzIExvYWRpbmdTY29wZXNTZXJ2aWNlIHtcbiAgY29uc3RydWN0b3IocHJvdGVjdGVkIGNvbmZpZzogT2NjQ29uZmlnKSB7fVxuXG4gIC8qKlxuICAgKiBBaW1zIHRvIGV4cGFuZCBzY29wZXMgYmFzZWQgb24gbG9hZGluZyBzY29wZXMgY29uZmlnLlxuICAgKlxuICAgKiBJLmUuIGlmICdkZXRhaWxzJyBzY29wZSBpbmNsdWRlcyAnbGlzdCcgc2NvcGUgYnkgY29uZmlndXJhdGlvbiwgaXQnbGwgcmV0dXJuIFsnZGV0YWlscycsICdsaXN0J11cbiAgICpcbiAgICogSWYgc2NvcGUgZGF0YSBvdmVybGFwcyB3aXRoIGVhY2ggb3RoZXIsIHRoZSBkYXRhIHNob3VsZCBiZSBtZXJnZWQgaW4gdGhlIG9yZGVyIG9mIHNjb3BlcyBwcm92aWRlZCxcbiAgICogaS5lLiB0aGUgbGFzdCBzY29wZSBpcyBtZXJnZWQgbGFzdCwgb3ZlcndyaXRpbmcgcGFydHMgb2YgdGhlIGRhdGEgYWxyZWFkeSBwcm92aWRlZCBieSBwcmVjZWRpbmcgc2NvcGUuXG4gICAqIEl0IHNob3VsZCBhcHBseSBhbHNvIHRvIGltcGxpY2l0IHNjb3BlcyAodGhhdCBhcmUgaW5jbHVkZWQgYnkgY29uZmlndXJhdGlvbikuXG4gICAqXG4gICAqIEBwYXJhbSBtb2RlbFxuICAgKiBAcGFyYW0gc2NvcGVzXG4gICAqL1xuICBleHBhbmQobW9kZWw6IHN0cmluZywgc2NvcGVzOiBzdHJpbmdbXSk6IHN0cmluZ1tdIHtcbiAgICBjb25zdCBzY29wZXNDb25maWcgPSB0aGlzLmNvbmZpZz8uYmFja2VuZD8ubG9hZGluZ1Njb3Blcz8uW21vZGVsXTtcblxuICAgIGlmIChzY29wZXNDb25maWcpIHtcbiAgICAgIGNvbnN0IGV4cGFuZGVkU2NvcGVzID0gWy4uLnNjb3Blc107XG4gICAgICBsZXQgaSA9IGV4cGFuZGVkU2NvcGVzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGkgPiAwKSB7XG4gICAgICAgIGktLTtcbiAgICAgICAgY29uc3QgaW5jbHVkZWRTY29wZXMgPSBzY29wZXNDb25maWdbZXhwYW5kZWRTY29wZXNbaV1dPy5pbmNsdWRlO1xuICAgICAgICBpZiAoaW5jbHVkZWRTY29wZXMpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGluY2x1ZGVkU2NvcGUgb2YgaW5jbHVkZWRTY29wZXMpIHtcbiAgICAgICAgICAgIGlmICghZXhwYW5kZWRTY29wZXMuaW5jbHVkZXMoaW5jbHVkZWRTY29wZSkpIHtcbiAgICAgICAgICAgICAgZXhwYW5kZWRTY29wZXMuc3BsaWNlKGksIDAsIGluY2x1ZGVkU2NvcGUpO1xuICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBleHBhbmRlZFNjb3BlcztcbiAgICB9XG5cbiAgICByZXR1cm4gc2NvcGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBtYXhBZ2UgZm9yIHByb2R1Y3Qgc2NvcGUgaW4gbWlsbGlzZWNvbmRzXG4gICAqXG4gICAqIEBwYXJhbSBtb2RlbFxuICAgKiBAcGFyYW0gc2NvcGVcbiAgICovXG4gIGdldE1heEFnZShtb2RlbDogc3RyaW5nLCBzY29wZTogc3RyaW5nKTogbnVtYmVyIHtcbiAgICBjb25zdCBjb25maWd1cmVkTWF4QWdlID1cbiAgICAgIHRoaXMuY29uZmlnLmJhY2tlbmQ/LmxvYWRpbmdTY29wZXM/Llttb2RlbF0/LltzY29wZV0/Lm1heEFnZSA/PyAwO1xuICAgIHJldHVybiBjb25maWd1cmVkTWF4QWdlICogMTAwMDtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBSZXR1cm5zIHRoZSBjb25maWd1cmVkIHRyaWdnZXJzIGZvciB3aGljaCB0byByZWxvYWQgdGhlIHByb2R1Y3QuXG4gICAqXG4gICAqIEBwYXJhbSBtb2RlbCBmb3Igd2hpY2ggdG8gbG9vayB1cCB0aGUgc2NvcGVzICh1c3VhbGx5IGEgJ3Byb2R1Y3QnKVxuICAgKiBAcGFyYW0gc2NvcGUgZm9yIHdoaWNoIHRvIGxvb2sgdXAgdGhlIGNvbmZpZ1xuICAgKiBAcmV0dXJucyB0aGUgY29uZmlndXJlZCB0cmlnZ2Vycywgb3IgYW4gZW1wdHkgYXJyYXkgaWYgbm90IGNvbmZpZ3VyZWRcbiAgICovXG4gIGdldFJlbG9hZFRyaWdnZXJzKG1vZGVsOiBzdHJpbmcsIHNjb3BlOiBzdHJpbmcpOiBUeXBlPEN4RXZlbnQ+W10ge1xuICAgIHJldHVybiB0aGlzLmNvbmZpZy5iYWNrZW5kPy5sb2FkaW5nU2NvcGVzPy5bbW9kZWxdPy5bc2NvcGVdPy5yZWxvYWRPbiA/PyBbXTtcbiAgfVxufVxuIl19