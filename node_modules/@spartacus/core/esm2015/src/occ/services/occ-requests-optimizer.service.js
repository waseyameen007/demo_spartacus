import { Injectable } from '@angular/core';
import { map, shareReplay } from 'rxjs/operators';
import { extractFields } from '../utils/occ-fields';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common/http";
import * as i2 from "./occ-fields.service";
export class OccRequestsOptimizerService {
    constructor(http, occFields) {
        this.http = http;
        this.occFields = occFields;
    }
    /**
     * Optimize occ endpoint calls merging requests to the same url by merging field parameters
     *
     * @param scopedDataWithUrls
     * @param dataFactory
     */
    scopedDataLoad(scopedDataWithUrls, dataFactory) {
        const result = [];
        if (!dataFactory) {
            dataFactory = (url) => this.http.get(url);
        }
        const mergedUrls = this.occFields.getOptimalUrlGroups(scopedDataWithUrls);
        Object.entries(mergedUrls).forEach(([url, groupedModelsSet]) => {
            const groupedModels = Object.values(groupedModelsSet);
            if (groupedModels.length === 1) {
                // only one scope for url, we can pass the data straightaway
                result.push(Object.assign(Object.assign({}, groupedModels[0].scopedData), { data$: dataFactory(url) }));
            }
            else {
                // multiple scopes per url
                // we have to split the model per each scope
                const data$ = dataFactory(url).pipe(shareReplay(1));
                groupedModels.forEach((modelData) => {
                    result.push(Object.assign(Object.assign({}, modelData.scopedData), { data$: data$.pipe(map((data) => extractFields(data, modelData.fields))) }));
                });
            }
        });
        return result;
    }
}
OccRequestsOptimizerService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OccRequestsOptimizerService, deps: [{ token: i1.HttpClient }, { token: i2.OccFieldsService }], target: i0.ɵɵFactoryTarget.Injectable });
OccRequestsOptimizerService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OccRequestsOptimizerService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: OccRequestsOptimizerService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.HttpClient }, { type: i2.OccFieldsService }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib2NjLXJlcXVlc3RzLW9wdGltaXplci5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvY29yZS9zcmMvb2NjL3NlcnZpY2VzL29jYy1yZXF1ZXN0cy1vcHRpbWl6ZXIuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBRzNDLE9BQU8sRUFBRSxHQUFHLEVBQUUsV0FBVyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDbEQsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLHFCQUFxQixDQUFDOzs7O0FBV3BELE1BQU0sT0FBTywyQkFBMkI7SUFDdEMsWUFDWSxJQUFnQixFQUNoQixTQUEyQjtRQUQzQixTQUFJLEdBQUosSUFBSSxDQUFZO1FBQ2hCLGNBQVMsR0FBVCxTQUFTLENBQWtCO0lBQ3BDLENBQUM7SUFFSjs7Ozs7T0FLRztJQUNILGNBQWMsQ0FDWixrQkFBdUMsRUFDdkMsV0FBNEM7UUFFNUMsTUFBTSxNQUFNLEdBQUcsRUFBRSxDQUFDO1FBRWxCLElBQUksQ0FBQyxXQUFXLEVBQUU7WUFDaEIsV0FBVyxHQUFHLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBTSxHQUFHLENBQUMsQ0FBQztTQUNoRDtRQUVELE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsbUJBQW1CLENBQUMsa0JBQWtCLENBQUMsQ0FBQztRQUUxRSxNQUFNLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxDQUFDLE9BQU8sQ0FDaEMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxnQkFBZ0IsQ0FLdEIsRUFBRSxFQUFFO1lBQ0gsTUFBTSxhQUFhLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO1lBRXRELElBQUksYUFBYSxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7Z0JBQzlCLDREQUE0RDtnQkFDNUQsTUFBTSxDQUFDLElBQUksaUNBQ04sYUFBYSxDQUFDLENBQUMsQ0FBQyxDQUFDLFVBQVUsS0FDOUIsS0FBSyxFQUFFLFdBQVcsQ0FBQyxHQUFHLENBQUMsSUFDdkIsQ0FBQzthQUNKO2lCQUFNO2dCQUNMLDBCQUEwQjtnQkFDMUIsNENBQTRDO2dCQUM1QyxNQUFNLEtBQUssR0FBRyxXQUFXLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUVwRCxhQUFhLENBQUMsT0FBTyxDQUFDLENBQUMsU0FBUyxFQUFFLEVBQUU7b0JBQ2xDLE1BQU0sQ0FBQyxJQUFJLGlDQUNOLFNBQVMsQ0FBQyxVQUFVLEtBQ3ZCLEtBQUssRUFBRSxLQUFLLENBQUMsSUFBSSxDQUNmLEdBQUcsQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsYUFBYSxDQUFJLElBQUksRUFBRSxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FDeEQsSUFDRCxDQUFDO2dCQUNMLENBQUMsQ0FBQyxDQUFDO2FBQ0o7UUFDSCxDQUFDLENBQ0YsQ0FBQztRQUVGLE9BQU8sTUFBTSxDQUFDO0lBQ2hCLENBQUM7O3dIQXpEVSwyQkFBMkI7NEhBQTNCLDJCQUEyQixjQUYxQixNQUFNOzJGQUVQLDJCQUEyQjtrQkFIdkMsVUFBVTttQkFBQztvQkFDVixVQUFVLEVBQUUsTUFBTTtpQkFDbkIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBTY29wZWREYXRhIH0gZnJvbSAnLi4vLi4vbW9kZWwvc2NvcGVkLWRhdGEnO1xuaW1wb3J0IHsgbWFwLCBzaGFyZVJlcGxheSB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IGV4dHJhY3RGaWVsZHMgfSBmcm9tICcuLi91dGlscy9vY2MtZmllbGRzJztcbmltcG9ydCB7XG4gIE9jY0ZpZWxkc01vZGVsLFxuICBPY2NGaWVsZHNTZXJ2aWNlLFxuICBTY29wZWREYXRhV2l0aFVybCxcbn0gZnJvbSAnLi9vY2MtZmllbGRzLnNlcnZpY2UnO1xuaW1wb3J0IHsgSHR0cENsaWVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbi9odHRwJztcblxuQEluamVjdGFibGUoe1xuICBwcm92aWRlZEluOiAncm9vdCcsXG59KVxuZXhwb3J0IGNsYXNzIE9jY1JlcXVlc3RzT3B0aW1pemVyU2VydmljZSB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHByb3RlY3RlZCBodHRwOiBIdHRwQ2xpZW50LFxuICAgIHByb3RlY3RlZCBvY2NGaWVsZHM6IE9jY0ZpZWxkc1NlcnZpY2VcbiAgKSB7fVxuXG4gIC8qKlxuICAgKiBPcHRpbWl6ZSBvY2MgZW5kcG9pbnQgY2FsbHMgbWVyZ2luZyByZXF1ZXN0cyB0byB0aGUgc2FtZSB1cmwgYnkgbWVyZ2luZyBmaWVsZCBwYXJhbWV0ZXJzXG4gICAqXG4gICAqIEBwYXJhbSBzY29wZWREYXRhV2l0aFVybHNcbiAgICogQHBhcmFtIGRhdGFGYWN0b3J5XG4gICAqL1xuICBzY29wZWREYXRhTG9hZDxUPihcbiAgICBzY29wZWREYXRhV2l0aFVybHM6IFNjb3BlZERhdGFXaXRoVXJsW10sXG4gICAgZGF0YUZhY3Rvcnk/OiAodXJsOiBzdHJpbmcpID0+IE9ic2VydmFibGU8VD5cbiAgKTogU2NvcGVkRGF0YTxUPltdIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcblxuICAgIGlmICghZGF0YUZhY3RvcnkpIHtcbiAgICAgIGRhdGFGYWN0b3J5ID0gKHVybCkgPT4gdGhpcy5odHRwLmdldDxhbnk+KHVybCk7XG4gICAgfVxuXG4gICAgY29uc3QgbWVyZ2VkVXJscyA9IHRoaXMub2NjRmllbGRzLmdldE9wdGltYWxVcmxHcm91cHMoc2NvcGVkRGF0YVdpdGhVcmxzKTtcblxuICAgIE9iamVjdC5lbnRyaWVzKG1lcmdlZFVybHMpLmZvckVhY2goXG4gICAgICAoW3VybCwgZ3JvdXBlZE1vZGVsc1NldF06IFtcbiAgICAgICAgc3RyaW5nLFxuICAgICAgICB7XG4gICAgICAgICAgW3Njb3BlOiBzdHJpbmddOiBPY2NGaWVsZHNNb2RlbDtcbiAgICAgICAgfVxuICAgICAgXSkgPT4ge1xuICAgICAgICBjb25zdCBncm91cGVkTW9kZWxzID0gT2JqZWN0LnZhbHVlcyhncm91cGVkTW9kZWxzU2V0KTtcblxuICAgICAgICBpZiAoZ3JvdXBlZE1vZGVscy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAvLyBvbmx5IG9uZSBzY29wZSBmb3IgdXJsLCB3ZSBjYW4gcGFzcyB0aGUgZGF0YSBzdHJhaWdodGF3YXlcbiAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAuLi5ncm91cGVkTW9kZWxzWzBdLnNjb3BlZERhdGEsXG4gICAgICAgICAgICBkYXRhJDogZGF0YUZhY3RvcnkodXJsKSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBtdWx0aXBsZSBzY29wZXMgcGVyIHVybFxuICAgICAgICAgIC8vIHdlIGhhdmUgdG8gc3BsaXQgdGhlIG1vZGVsIHBlciBlYWNoIHNjb3BlXG4gICAgICAgICAgY29uc3QgZGF0YSQgPSBkYXRhRmFjdG9yeSh1cmwpLnBpcGUoc2hhcmVSZXBsYXkoMSkpO1xuXG4gICAgICAgICAgZ3JvdXBlZE1vZGVscy5mb3JFYWNoKChtb2RlbERhdGEpID0+IHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgLi4ubW9kZWxEYXRhLnNjb3BlZERhdGEsXG4gICAgICAgICAgICAgIGRhdGEkOiBkYXRhJC5waXBlKFxuICAgICAgICAgICAgICAgIG1hcCgoZGF0YSkgPT4gZXh0cmFjdEZpZWxkczxUPihkYXRhLCBtb2RlbERhdGEuZmllbGRzKSlcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cbiJdfQ==