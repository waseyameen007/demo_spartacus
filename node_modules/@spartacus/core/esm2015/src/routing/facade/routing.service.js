import { Injectable } from '@angular/core';
import { select } from '@ngrx/store';
import { RoutingActions } from '../store/actions/index';
import { RoutingSelector } from '../store/selectors/index';
import * as i0 from "@angular/core";
import * as i1 from "@ngrx/store";
import * as i2 from "../../window/window-ref";
import * as i3 from "../configurable-routes/url-translation/semantic-path.service";
import * as i4 from "./routing-params.service";
import * as i5 from "@angular/router";
import * as i6 from "@angular/common";
export class RoutingService {
    constructor(store, winRef, semanticPathService, routingParamsService, router, location) {
        this.store = store;
        this.winRef = winRef;
        this.semanticPathService = semanticPathService;
        this.routingParamsService = routingParamsService;
        this.router = router;
        this.location = location;
    }
    /**
     * Get the list of all parameters of the full route. This includes
     * active child routes.
     */
    getParams() {
        var _a;
        return (_a = this.routingParamsService) === null || _a === void 0 ? void 0 : _a.getParams();
    }
    /**
     * Get the current router state
     */
    getRouterState() {
        return this.store.pipe(select(RoutingSelector.getRouterState));
    }
    /**
     * Get the `PageContext` from the state
     */
    getPageContext() {
        return this.store.pipe(select(RoutingSelector.getPageContext));
    }
    /**
     * Get the next `PageContext` from the state
     */
    getNextPageContext() {
        return this.store.pipe(select(RoutingSelector.getNextPageContext));
    }
    /**
     * Allow to change next page context for the ongoing navigation
     *
     * @param pageContext
     */
    changeNextPageContext(pageContext) {
        this.store.dispatch(new RoutingActions.ChangeNextPageContext(pageContext));
    }
    /**
     * Get the `isNavigating` info from the state
     */
    isNavigating() {
        return this.store.pipe(select(RoutingSelector.isNavigating));
    }
    /**
     * Navigation with a new state into history
     * @param commands: url commands
     * @param extras: Represents the extra options used during navigation.
     *
     * @returns Promise that resolves to `true` when navigation succeeds,
     *          to `false` when navigation fails, or is rejected on error.
     */
    go(commands, extras) {
        const path = this.semanticPathService.transform(commands);
        return this.navigate(path, extras);
    }
    /**
     * Resolves the relative url for the given `UrlCommands` and `NavigationExtras`.
     *
     * The absolute url can be resolved using `getFullUrl()`.
     */
    getUrl(commands, extras) {
        let url = this.router.serializeUrl(this.router.createUrlTree(this.semanticPathService.transform(commands), extras));
        if (!url.startsWith('/')) {
            url = `/${url}`;
        }
        return url;
    }
    /**
     * Returns the absolute url for the given `UrlCommands` and `NavigationExtras`.
     *
     * The absolute url uses the origin of the current location.
     */
    getFullUrl(commands, extras) {
        return `${this.winRef.document.location.origin}${this.getUrl(commands, extras)}`;
    }
    /**
     * Navigation using absolute route path
     * @param url
     * @param extras: Represents the extra options used during navigation.
     *
     * @returns Promise that resolves to `true` when navigation succeeds,
     *          to `false` when navigation fails, or is rejected on error.
     */
    goByUrl(url, extras) {
        return this.router.navigateByUrl(url, extras);
    }
    /**
     * Navigating back
     */
    back() {
        const isLastPageInApp = this.winRef.document.referrer.includes(this.winRef.nativeWindow.location.origin);
        if (isLastPageInApp) {
            this.location.back();
            return;
        }
        this.go(['/']);
        return;
    }
    /**
     * Navigating forward
     */
    forward() {
        this.location.forward();
    }
    /**
     * Navigation with a new state into history
     * @param path
     * @param extras: Represents the extra options used during navigation.
     *
     * @returns Promise that resolves to `true` when navigation succeeds,
     *          to `false` when navigation fails, or is rejected on error.
     */
    navigate(path, extras) {
        return this.router.navigate(path, extras);
    }
}
RoutingService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: RoutingService, deps: [{ token: i1.Store }, { token: i2.WindowRef }, { token: i3.SemanticPathService }, { token: i4.RoutingParamsService }, { token: i5.Router }, { token: i6.Location }], target: i0.ɵɵFactoryTarget.Injectable });
RoutingService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: RoutingService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: RoutingService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.Store }, { type: i2.WindowRef }, { type: i3.SemanticPathService }, { type: i4.RoutingParamsService }, { type: i5.Router }, { type: i6.Location }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicm91dGluZy5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvY29yZS9zcmMvcm91dGluZy9mYWNhZGUvcm91dGluZy5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUNBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFNM0MsT0FBTyxFQUFFLE1BQU0sRUFBUyxNQUFNLGFBQWEsQ0FBQztBQU01QyxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sd0JBQXdCLENBQUM7QUFFeEQsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLDBCQUEwQixDQUFDOzs7Ozs7OztBQU0zRCxNQUFNLE9BQU8sY0FBYztJQUN6QixZQUNZLEtBQXlCLEVBQ3pCLE1BQWlCLEVBQ2pCLG1CQUF3QyxFQUN4QyxvQkFBMEMsRUFDMUMsTUFBYyxFQUNkLFFBQWtCO1FBTGxCLFVBQUssR0FBTCxLQUFLLENBQW9CO1FBQ3pCLFdBQU0sR0FBTixNQUFNLENBQVc7UUFDakIsd0JBQW1CLEdBQW5CLG1CQUFtQixDQUFxQjtRQUN4Qyx5QkFBb0IsR0FBcEIsb0JBQW9CLENBQXNCO1FBQzFDLFdBQU0sR0FBTixNQUFNLENBQVE7UUFDZCxhQUFRLEdBQVIsUUFBUSxDQUFVO0lBQzNCLENBQUM7SUFFSjs7O09BR0c7SUFDSCxTQUFTOztRQUNQLE9BQU8sTUFBQSxJQUFJLENBQUMsb0JBQW9CLDBDQUFFLFNBQVMsRUFBRSxDQUFDO0lBQ2hELENBQUM7SUFFRDs7T0FFRztJQUNILGNBQWM7UUFDWixPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxlQUFlLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQztJQUNqRSxDQUFDO0lBRUQ7O09BRUc7SUFDSCxjQUFjO1FBQ1osT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsZUFBZSxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUM7SUFDakUsQ0FBQztJQUVEOztPQUVHO0lBQ0gsa0JBQWtCO1FBQ2hCLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLGVBQWUsQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDLENBQUM7SUFDckUsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxxQkFBcUIsQ0FBQyxXQUF3QjtRQUM1QyxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxJQUFJLGNBQWMsQ0FBQyxxQkFBcUIsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDO0lBQzdFLENBQUM7SUFFRDs7T0FFRztJQUNILFlBQVk7UUFDVixPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxlQUFlLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQztJQUMvRCxDQUFDO0lBRUQ7Ozs7Ozs7T0FPRztJQUNILEVBQUUsQ0FBQyxRQUFxQixFQUFFLE1BQXlCO1FBQ2pELE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDMUQsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxNQUFNLENBQUMsQ0FBQztJQUNyQyxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILE1BQU0sQ0FBQyxRQUFxQixFQUFFLE1BQXlCO1FBQ3JELElBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUNoQyxJQUFJLENBQUMsTUFBTSxDQUFDLGFBQWEsQ0FDdkIsSUFBSSxDQUFDLG1CQUFtQixDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsRUFDNUMsTUFBTSxDQUNQLENBQ0YsQ0FBQztRQUNGLElBQUksQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxFQUFFO1lBQ3hCLEdBQUcsR0FBRyxJQUFJLEdBQUcsRUFBRSxDQUFDO1NBQ2pCO1FBQ0QsT0FBTyxHQUFHLENBQUM7SUFDYixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILFVBQVUsQ0FBQyxRQUFxQixFQUFFLE1BQXlCO1FBQ3pELE9BQU8sR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQzFELFFBQVEsRUFDUixNQUFNLENBQ1AsRUFBRSxDQUFDO0lBQ04sQ0FBQztJQUVEOzs7Ozs7O09BT0c7SUFDSCxPQUFPLENBQUMsR0FBVyxFQUFFLE1BQWtDO1FBQ3JELE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMsR0FBRyxFQUFFLE1BQU0sQ0FBQyxDQUFDO0lBQ2hELENBQUM7SUFFRDs7T0FFRztJQUNILElBQUk7UUFDRixNQUFNLGVBQWUsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUM1RCxJQUFJLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUN6QyxDQUFDO1FBQ0YsSUFBSSxlQUFlLEVBQUU7WUFDbkIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsQ0FBQztZQUNyQixPQUFPO1NBQ1I7UUFDRCxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztRQUNmLE9BQU87SUFDVCxDQUFDO0lBRUQ7O09BRUc7SUFDSCxPQUFPO1FBQ0wsSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLEVBQUUsQ0FBQztJQUMxQixDQUFDO0lBRUQ7Ozs7Ozs7T0FPRztJQUNPLFFBQVEsQ0FBQyxJQUFXLEVBQUUsTUFBeUI7UUFDdkQsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsTUFBTSxDQUFDLENBQUM7SUFDNUMsQ0FBQzs7MkdBOUlVLGNBQWM7K0dBQWQsY0FBYyxjQUZiLE1BQU07MkZBRVAsY0FBYztrQkFIMUIsVUFBVTttQkFBQztvQkFDVixVQUFVLEVBQUUsTUFBTTtpQkFDbkIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBMb2NhdGlvbiB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1xuICBOYXZpZ2F0aW9uQmVoYXZpb3JPcHRpb25zLFxuICBOYXZpZ2F0aW9uRXh0cmFzLFxuICBSb3V0ZXIsXG59IGZyb20gJ0Bhbmd1bGFyL3JvdXRlcic7XG5pbXBvcnQgeyBzZWxlY3QsIFN0b3JlIH0gZnJvbSAnQG5ncngvc3RvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgV2luZG93UmVmIH0gZnJvbSAnLi4vLi4vd2luZG93L3dpbmRvdy1yZWYnO1xuaW1wb3J0IHsgU2VtYW50aWNQYXRoU2VydmljZSB9IGZyb20gJy4uL2NvbmZpZ3VyYWJsZS1yb3V0ZXMvdXJsLXRyYW5zbGF0aW9uL3NlbWFudGljLXBhdGguc2VydmljZSc7XG5pbXBvcnQgeyBVcmxDb21tYW5kcyB9IGZyb20gJy4uL2NvbmZpZ3VyYWJsZS1yb3V0ZXMvdXJsLXRyYW5zbGF0aW9uL3VybC1jb21tYW5kJztcbmltcG9ydCB7IFBhZ2VDb250ZXh0IH0gZnJvbSAnLi4vbW9kZWxzL3BhZ2UtY29udGV4dC5tb2RlbCc7XG5pbXBvcnQgeyBSb3V0aW5nQWN0aW9ucyB9IGZyb20gJy4uL3N0b3JlL2FjdGlvbnMvaW5kZXgnO1xuaW1wb3J0IHsgUm91dGVyU3RhdGUgfSBmcm9tICcuLi9zdG9yZS9yb3V0aW5nLXN0YXRlJztcbmltcG9ydCB7IFJvdXRpbmdTZWxlY3RvciB9IGZyb20gJy4uL3N0b3JlL3NlbGVjdG9ycy9pbmRleCc7XG5pbXBvcnQgeyBSb3V0aW5nUGFyYW1zU2VydmljZSB9IGZyb20gJy4vcm91dGluZy1wYXJhbXMuc2VydmljZSc7XG5cbkBJbmplY3RhYmxlKHtcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnLFxufSlcbmV4cG9ydCBjbGFzcyBSb3V0aW5nU2VydmljZSB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHByb3RlY3RlZCBzdG9yZTogU3RvcmU8Um91dGVyU3RhdGU+LFxuICAgIHByb3RlY3RlZCB3aW5SZWY6IFdpbmRvd1JlZixcbiAgICBwcm90ZWN0ZWQgc2VtYW50aWNQYXRoU2VydmljZTogU2VtYW50aWNQYXRoU2VydmljZSxcbiAgICBwcm90ZWN0ZWQgcm91dGluZ1BhcmFtc1NlcnZpY2U6IFJvdXRpbmdQYXJhbXNTZXJ2aWNlLFxuICAgIHByb3RlY3RlZCByb3V0ZXI6IFJvdXRlcixcbiAgICBwcm90ZWN0ZWQgbG9jYXRpb246IExvY2F0aW9uXG4gICkge31cblxuICAvKipcbiAgICogR2V0IHRoZSBsaXN0IG9mIGFsbCBwYXJhbWV0ZXJzIG9mIHRoZSBmdWxsIHJvdXRlLiBUaGlzIGluY2x1ZGVzXG4gICAqIGFjdGl2ZSBjaGlsZCByb3V0ZXMuXG4gICAqL1xuICBnZXRQYXJhbXMoKTogT2JzZXJ2YWJsZTx7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9PiB7XG4gICAgcmV0dXJuIHRoaXMucm91dGluZ1BhcmFtc1NlcnZpY2U/LmdldFBhcmFtcygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCByb3V0ZXIgc3RhdGVcbiAgICovXG4gIGdldFJvdXRlclN0YXRlKCk6IE9ic2VydmFibGU8Um91dGVyU3RhdGU+IHtcbiAgICByZXR1cm4gdGhpcy5zdG9yZS5waXBlKHNlbGVjdChSb3V0aW5nU2VsZWN0b3IuZ2V0Um91dGVyU3RhdGUpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGBQYWdlQ29udGV4dGAgZnJvbSB0aGUgc3RhdGVcbiAgICovXG4gIGdldFBhZ2VDb250ZXh0KCk6IE9ic2VydmFibGU8UGFnZUNvbnRleHQ+IHtcbiAgICByZXR1cm4gdGhpcy5zdG9yZS5waXBlKHNlbGVjdChSb3V0aW5nU2VsZWN0b3IuZ2V0UGFnZUNvbnRleHQpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG5leHQgYFBhZ2VDb250ZXh0YCBmcm9tIHRoZSBzdGF0ZVxuICAgKi9cbiAgZ2V0TmV4dFBhZ2VDb250ZXh0KCk6IE9ic2VydmFibGU8UGFnZUNvbnRleHQ+IHtcbiAgICByZXR1cm4gdGhpcy5zdG9yZS5waXBlKHNlbGVjdChSb3V0aW5nU2VsZWN0b3IuZ2V0TmV4dFBhZ2VDb250ZXh0KSk7XG4gIH1cblxuICAvKipcbiAgICogQWxsb3cgdG8gY2hhbmdlIG5leHQgcGFnZSBjb250ZXh0IGZvciB0aGUgb25nb2luZyBuYXZpZ2F0aW9uXG4gICAqXG4gICAqIEBwYXJhbSBwYWdlQ29udGV4dFxuICAgKi9cbiAgY2hhbmdlTmV4dFBhZ2VDb250ZXh0KHBhZ2VDb250ZXh0OiBQYWdlQ29udGV4dCkge1xuICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2gobmV3IFJvdXRpbmdBY3Rpb25zLkNoYW5nZU5leHRQYWdlQ29udGV4dChwYWdlQ29udGV4dCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgYGlzTmF2aWdhdGluZ2AgaW5mbyBmcm9tIHRoZSBzdGF0ZVxuICAgKi9cbiAgaXNOYXZpZ2F0aW5nKCk6IE9ic2VydmFibGU8Ym9vbGVhbj4ge1xuICAgIHJldHVybiB0aGlzLnN0b3JlLnBpcGUoc2VsZWN0KFJvdXRpbmdTZWxlY3Rvci5pc05hdmlnYXRpbmcpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBOYXZpZ2F0aW9uIHdpdGggYSBuZXcgc3RhdGUgaW50byBoaXN0b3J5XG4gICAqIEBwYXJhbSBjb21tYW5kczogdXJsIGNvbW1hbmRzXG4gICAqIEBwYXJhbSBleHRyYXM6IFJlcHJlc2VudHMgdGhlIGV4dHJhIG9wdGlvbnMgdXNlZCBkdXJpbmcgbmF2aWdhdGlvbi5cbiAgICpcbiAgICogQHJldHVybnMgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGB0cnVlYCB3aGVuIG5hdmlnYXRpb24gc3VjY2VlZHMsXG4gICAqICAgICAgICAgIHRvIGBmYWxzZWAgd2hlbiBuYXZpZ2F0aW9uIGZhaWxzLCBvciBpcyByZWplY3RlZCBvbiBlcnJvci5cbiAgICovXG4gIGdvKGNvbW1hbmRzOiBVcmxDb21tYW5kcywgZXh0cmFzPzogTmF2aWdhdGlvbkV4dHJhcyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGNvbnN0IHBhdGggPSB0aGlzLnNlbWFudGljUGF0aFNlcnZpY2UudHJhbnNmb3JtKGNvbW1hbmRzKTtcbiAgICByZXR1cm4gdGhpcy5uYXZpZ2F0ZShwYXRoLCBleHRyYXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc29sdmVzIHRoZSByZWxhdGl2ZSB1cmwgZm9yIHRoZSBnaXZlbiBgVXJsQ29tbWFuZHNgIGFuZCBgTmF2aWdhdGlvbkV4dHJhc2AuXG4gICAqXG4gICAqIFRoZSBhYnNvbHV0ZSB1cmwgY2FuIGJlIHJlc29sdmVkIHVzaW5nIGBnZXRGdWxsVXJsKClgLlxuICAgKi9cbiAgZ2V0VXJsKGNvbW1hbmRzOiBVcmxDb21tYW5kcywgZXh0cmFzPzogTmF2aWdhdGlvbkV4dHJhcyk6IHN0cmluZyB7XG4gICAgbGV0IHVybCA9IHRoaXMucm91dGVyLnNlcmlhbGl6ZVVybChcbiAgICAgIHRoaXMucm91dGVyLmNyZWF0ZVVybFRyZWUoXG4gICAgICAgIHRoaXMuc2VtYW50aWNQYXRoU2VydmljZS50cmFuc2Zvcm0oY29tbWFuZHMpLFxuICAgICAgICBleHRyYXNcbiAgICAgIClcbiAgICApO1xuICAgIGlmICghdXJsLnN0YXJ0c1dpdGgoJy8nKSkge1xuICAgICAgdXJsID0gYC8ke3VybH1gO1xuICAgIH1cbiAgICByZXR1cm4gdXJsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFic29sdXRlIHVybCBmb3IgdGhlIGdpdmVuIGBVcmxDb21tYW5kc2AgYW5kIGBOYXZpZ2F0aW9uRXh0cmFzYC5cbiAgICpcbiAgICogVGhlIGFic29sdXRlIHVybCB1c2VzIHRoZSBvcmlnaW4gb2YgdGhlIGN1cnJlbnQgbG9jYXRpb24uXG4gICAqL1xuICBnZXRGdWxsVXJsKGNvbW1hbmRzOiBVcmxDb21tYW5kcywgZXh0cmFzPzogTmF2aWdhdGlvbkV4dHJhcykge1xuICAgIHJldHVybiBgJHt0aGlzLndpblJlZi5kb2N1bWVudC5sb2NhdGlvbi5vcmlnaW59JHt0aGlzLmdldFVybChcbiAgICAgIGNvbW1hbmRzLFxuICAgICAgZXh0cmFzXG4gICAgKX1gO1xuICB9XG5cbiAgLyoqXG4gICAqIE5hdmlnYXRpb24gdXNpbmcgYWJzb2x1dGUgcm91dGUgcGF0aFxuICAgKiBAcGFyYW0gdXJsXG4gICAqIEBwYXJhbSBleHRyYXM6IFJlcHJlc2VudHMgdGhlIGV4dHJhIG9wdGlvbnMgdXNlZCBkdXJpbmcgbmF2aWdhdGlvbi5cbiAgICpcbiAgICogQHJldHVybnMgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGB0cnVlYCB3aGVuIG5hdmlnYXRpb24gc3VjY2VlZHMsXG4gICAqICAgICAgICAgIHRvIGBmYWxzZWAgd2hlbiBuYXZpZ2F0aW9uIGZhaWxzLCBvciBpcyByZWplY3RlZCBvbiBlcnJvci5cbiAgICovXG4gIGdvQnlVcmwodXJsOiBzdHJpbmcsIGV4dHJhcz86IE5hdmlnYXRpb25CZWhhdmlvck9wdGlvbnMpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICByZXR1cm4gdGhpcy5yb3V0ZXIubmF2aWdhdGVCeVVybCh1cmwsIGV4dHJhcyk7XG4gIH1cblxuICAvKipcbiAgICogTmF2aWdhdGluZyBiYWNrXG4gICAqL1xuICBiYWNrKCk6IHZvaWQge1xuICAgIGNvbnN0IGlzTGFzdFBhZ2VJbkFwcCA9IHRoaXMud2luUmVmLmRvY3VtZW50LnJlZmVycmVyLmluY2x1ZGVzKFxuICAgICAgdGhpcy53aW5SZWYubmF0aXZlV2luZG93LmxvY2F0aW9uLm9yaWdpblxuICAgICk7XG4gICAgaWYgKGlzTGFzdFBhZ2VJbkFwcCkge1xuICAgICAgdGhpcy5sb2NhdGlvbi5iYWNrKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZ28oWycvJ10pO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKlxuICAgKiBOYXZpZ2F0aW5nIGZvcndhcmRcbiAgICovXG4gIGZvcndhcmQoKTogdm9pZCB7XG4gICAgdGhpcy5sb2NhdGlvbi5mb3J3YXJkKCk7XG4gIH1cblxuICAvKipcbiAgICogTmF2aWdhdGlvbiB3aXRoIGEgbmV3IHN0YXRlIGludG8gaGlzdG9yeVxuICAgKiBAcGFyYW0gcGF0aFxuICAgKiBAcGFyYW0gZXh0cmFzOiBSZXByZXNlbnRzIHRoZSBleHRyYSBvcHRpb25zIHVzZWQgZHVyaW5nIG5hdmlnYXRpb24uXG4gICAqXG4gICAqIEByZXR1cm5zIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byBgdHJ1ZWAgd2hlbiBuYXZpZ2F0aW9uIHN1Y2NlZWRzLFxuICAgKiAgICAgICAgICB0byBgZmFsc2VgIHdoZW4gbmF2aWdhdGlvbiBmYWlscywgb3IgaXMgcmVqZWN0ZWQgb24gZXJyb3IuXG4gICAqL1xuICBwcm90ZWN0ZWQgbmF2aWdhdGUocGF0aDogYW55W10sIGV4dHJhcz86IE5hdmlnYXRpb25FeHRyYXMpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICByZXR1cm4gdGhpcy5yb3V0ZXIubmF2aWdhdGUocGF0aCwgZXh0cmFzKTtcbiAgfVxufVxuIl19