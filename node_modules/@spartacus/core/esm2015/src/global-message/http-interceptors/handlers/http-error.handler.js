import { isPlatformBrowser } from '@angular/common';
import { Inject, Injectable, PLATFORM_ID } from '@angular/core';
import * as i0 from "@angular/core";
import * as i1 from "../../facade/global-message.service";
export class HttpErrorHandler {
    constructor(globalMessageService, platformId) {
        this.globalMessageService = globalMessageService;
        this.platformId = platformId;
    }
    /**
     * Error handlers are matched by the error `responseStatus` (i.e. 404). On top of the matching status
     * a priority can be added to distinguish multiple handles for the same response status.
     */
    hasMatch(errorResponse) {
        return errorResponse.status === this.responseStatus;
    }
    /**
     * Returns true when invoked on the server (SSR).
     *
     * Added in 3.2, depends on the injected `platformId`.
     */
    isSsr() {
        if (this.platformId) {
            return !isPlatformBrowser(this.platformId);
        }
        return false;
    }
}
HttpErrorHandler.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: HttpErrorHandler, deps: [{ token: i1.GlobalMessageService }, { token: PLATFORM_ID }], target: i0.ɵɵFactoryTarget.Injectable });
HttpErrorHandler.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: HttpErrorHandler, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: HttpErrorHandler, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.GlobalMessageService }, { type: Object, decorators: [{
                    type: Inject,
                    args: [PLATFORM_ID]
                }] }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaHR0cC1lcnJvci5oYW5kbGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvY29yZS9zcmMvZ2xvYmFsLW1lc3NhZ2UvaHR0cC1pbnRlcmNlcHRvcnMvaGFuZGxlcnMvaHR0cC1lcnJvci5oYW5kbGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBRXBELE9BQU8sRUFBRSxNQUFNLEVBQUUsVUFBVSxFQUFFLFdBQVcsRUFBRSxNQUFNLGVBQWUsQ0FBQzs7O0FBT2hFLE1BQU0sT0FBZ0IsZ0JBQWdCO0lBQ3BDLFlBQ1ksb0JBQTBDLEVBQ3JCLFVBQW1CO1FBRHhDLHlCQUFvQixHQUFwQixvQkFBb0IsQ0FBc0I7UUFDckIsZUFBVSxHQUFWLFVBQVUsQ0FBUztJQUNqRCxDQUFDO0lBbUJKOzs7T0FHRztJQUNILFFBQVEsQ0FBQyxhQUFnQztRQUN2QyxPQUFPLGFBQWEsQ0FBQyxNQUFNLEtBQUssSUFBSSxDQUFDLGNBQWMsQ0FBQztJQUN0RCxDQUFDO0lBSUQ7Ozs7T0FJRztJQUNPLEtBQUs7UUFDYixJQUFJLElBQUksQ0FBQyxVQUFVLEVBQUU7WUFDbkIsT0FBTyxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztTQUM1QztRQUNELE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQzs7NkdBM0NtQixnQkFBZ0Isc0RBRzFCLFdBQVc7aUhBSEQsZ0JBQWdCLGNBRnhCLE1BQU07MkZBRUUsZ0JBQWdCO2tCQUhyQyxVQUFVO21CQUFDO29CQUNWLFVBQVUsRUFBRSxNQUFNO2lCQUNuQjs2RkFJK0MsTUFBTTswQkFBakQsTUFBTTsyQkFBQyxXQUFXIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNQbGF0Zm9ybUJyb3dzZXIgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgSHR0cEVycm9yUmVzcG9uc2UsIEh0dHBSZXF1ZXN0IH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uL2h0dHAnO1xuaW1wb3J0IHsgSW5qZWN0LCBJbmplY3RhYmxlLCBQTEFURk9STV9JRCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQXBwbGljYWJsZSwgUHJpb3JpdHkgfSBmcm9tICcuLi8uLi8uLi91dGlsL2FwcGxpY2FibGUnO1xuaW1wb3J0IHsgR2xvYmFsTWVzc2FnZVNlcnZpY2UgfSBmcm9tICcuLi8uLi9mYWNhZGUvZ2xvYmFsLW1lc3NhZ2Uuc2VydmljZSc7XG5cbkBJbmplY3RhYmxlKHtcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnLFxufSlcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBIdHRwRXJyb3JIYW5kbGVyIGltcGxlbWVudHMgQXBwbGljYWJsZSB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHByb3RlY3RlZCBnbG9iYWxNZXNzYWdlU2VydmljZTogR2xvYmFsTWVzc2FnZVNlcnZpY2UsXG4gICAgQEluamVjdChQTEFURk9STV9JRCkgcHJvdGVjdGVkIHBsYXRmb3JtSWQ/OiBPYmplY3RcbiAgKSB7fVxuXG4gIC8qKlxuICAgKiBUaGUgaHR0cCByZXNwb25zZSBzdGF0dXMgbnVtYmVyIHdoaWNoIGlzIGhhbmRsZWQgYnkgdGhpcyBoYW5kbGVyLlxuICAgKiBJbXBsZW1lbnRhdGlvbnMgY2FuIHNldCB0aGUgcmVzcG9uc2Ugc3RhdHVzIG51bWJlciwgaS5lLiA0MDQsIHNvIHRoYXRcbiAgICogdGhlIGhhbmRsZXIgY2FuIGJlIGZvdW5kIGJ5IHRoZSBlcnJvciBpbnRlcmNlcHRvci5cbiAgICovXG4gIHJlc3BvbnNlU3RhdHVzPzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBIYW5kbGVzIHRoZSBlcnJvciByZXNwb25zZSBmb3IgdGhlIHJlc3BvbnNlIHN0YXR1cyB0aGF0IGlzIHJlZ2lzdGVyIGZvciB0aGUgaGFuZGxlclxuICAgKiBAcGFyYW0geyBIdHRwUmVxdWVzdDxhbnk+IH0gcmVxdWVzdCA6IGh0dHAgcmVxdWVzdFxuICAgKiBAcGFyYW0geyBIdHRwRXJyb3JSZXNwb25zZSB9IGVycm9yUmVzcG9uc2UgOiBIdHRwIGVycm9yIHJlc3BvbnNlXG4gICAqL1xuICBhYnN0cmFjdCBoYW5kbGVFcnJvcihcbiAgICByZXF1ZXN0OiBIdHRwUmVxdWVzdDxhbnk+LFxuICAgIGVycm9yUmVzcG9uc2U6IEh0dHBFcnJvclJlc3BvbnNlXG4gICk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIEVycm9yIGhhbmRsZXJzIGFyZSBtYXRjaGVkIGJ5IHRoZSBlcnJvciBgcmVzcG9uc2VTdGF0dXNgIChpLmUuIDQwNCkuIE9uIHRvcCBvZiB0aGUgbWF0Y2hpbmcgc3RhdHVzXG4gICAqIGEgcHJpb3JpdHkgY2FuIGJlIGFkZGVkIHRvIGRpc3Rpbmd1aXNoIG11bHRpcGxlIGhhbmRsZXMgZm9yIHRoZSBzYW1lIHJlc3BvbnNlIHN0YXR1cy5cbiAgICovXG4gIGhhc01hdGNoKGVycm9yUmVzcG9uc2U6IEh0dHBFcnJvclJlc3BvbnNlKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGVycm9yUmVzcG9uc2Uuc3RhdHVzID09PSB0aGlzLnJlc3BvbnNlU3RhdHVzO1xuICB9XG5cbiAgYWJzdHJhY3QgZ2V0UHJpb3JpdHk/KCk6IFByaW9yaXR5O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgd2hlbiBpbnZva2VkIG9uIHRoZSBzZXJ2ZXIgKFNTUikuXG4gICAqXG4gICAqIEFkZGVkIGluIDMuMiwgZGVwZW5kcyBvbiB0aGUgaW5qZWN0ZWQgYHBsYXRmb3JtSWRgLlxuICAgKi9cbiAgcHJvdGVjdGVkIGlzU3NyKCk6IGJvb2xlYW4ge1xuICAgIGlmICh0aGlzLnBsYXRmb3JtSWQpIHtcbiAgICAgIHJldHVybiAhaXNQbGF0Zm9ybUJyb3dzZXIodGhpcy5wbGF0Zm9ybUlkKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG4iXX0=