import { Injectable } from '@angular/core';
import { ReplaySubject } from 'rxjs';
import { map, take } from 'rxjs/operators';
import { OCC_USER_ID_ANONYMOUS, OCC_USER_ID_CURRENT, } from '../../../occ/utils/occ-constants';
import * as i0 from "@angular/core";
/**
 * This implementation is OCC specific.
 * Different backend might have completely different need regarding user id.
 * It might not need user id at all and work based on access_token.
 * To implement custom solution provide your own implementation and customize services that use UserIdService
 */
export class UserIdService {
    constructor() {
        this._userId = new ReplaySubject(1);
    }
    /**
     * Sets current user id.
     *
     * @param userId
     */
    setUserId(userId) {
        this._userId.next(userId);
    }
    /**
     * This function provides the userId the OCC calls should use, depending
     * on whether there is an active storefront session or not.
     *
     * It returns the userId of the current storefront user or 'anonymous'
     * in the case there are no signed in user in the storefront.
     *
     * The user id of a regular customer session is 'current'. In the case of an
     * asm customer emulation session, the userId will be the customerId.
     */
    getUserId() {
        return this._userId;
    }
    /**
     * Utility method if you need userId to perform single action (eg. dispatch call to API).
     *
     * @param loggedIn Set to true if you want the observable to emit id only for logged in user. Throws in case of anonymous user.
     *
     * @returns Observable that emits once and completes with the last userId value.
     */
    takeUserId(loggedIn = false) {
        return this.getUserId().pipe(take(1), map((userId) => {
            if (loggedIn && userId === OCC_USER_ID_ANONYMOUS) {
                throw new Error('Requested user id for logged user while user is not logged in.');
            }
            return userId;
        }));
    }
    /**
     * Sets user id to the default value for logged out user.
     */
    clearUserId() {
        this.setUserId(OCC_USER_ID_ANONYMOUS);
    }
    /**
     * Checks if the userId is of emulated user type.
     */
    isEmulated() {
        return this.getUserId().pipe(map((userId) => userId !== OCC_USER_ID_ANONYMOUS && userId !== OCC_USER_ID_CURRENT));
    }
}
UserIdService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: UserIdService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
UserIdService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: UserIdService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: UserIdService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXNlci1pZC5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvY29yZS9zcmMvYXV0aC91c2VyLWF1dGgvZmFjYWRlL3VzZXItaWQuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzNDLE9BQU8sRUFBYyxhQUFhLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDakQsT0FBTyxFQUFFLEdBQUcsRUFBRSxJQUFJLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUMzQyxPQUFPLEVBQ0wscUJBQXFCLEVBQ3JCLG1CQUFtQixHQUNwQixNQUFNLGtDQUFrQyxDQUFDOztBQUUxQzs7Ozs7R0FLRztBQUlILE1BQU0sT0FBTyxhQUFhO0lBSDFCO1FBSVUsWUFBTyxHQUF1QixJQUFJLGFBQWEsQ0FBUyxDQUFDLENBQUMsQ0FBQztLQWdFcEU7SUE5REM7Ozs7T0FJRztJQUNJLFNBQVMsQ0FBQyxNQUFjO1FBQzVCLElBQUksQ0FBQyxPQUFpQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUN2RCxDQUFDO0lBRUQ7Ozs7Ozs7OztPQVNHO0lBQ0ksU0FBUztRQUNkLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQztJQUN0QixDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0ksVUFBVSxDQUFDLFFBQVEsR0FBRyxLQUFLO1FBQ2hDLE9BQU8sSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFDLElBQUksQ0FDMUIsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUNQLEdBQUcsQ0FBQyxDQUFDLE1BQU0sRUFBRSxFQUFFO1lBQ2IsSUFBSSxRQUFRLElBQUksTUFBTSxLQUFLLHFCQUFxQixFQUFFO2dCQUNoRCxNQUFNLElBQUksS0FBSyxDQUNiLGdFQUFnRSxDQUNqRSxDQUFDO2FBQ0g7WUFDRCxPQUFPLE1BQU0sQ0FBQztRQUNoQixDQUFDLENBQUMsQ0FDSCxDQUFDO0lBQ0osQ0FBQztJQUVEOztPQUVHO0lBQ0ksV0FBVztRQUNoQixJQUFJLENBQUMsU0FBUyxDQUFDLHFCQUFxQixDQUFDLENBQUM7SUFDeEMsQ0FBQztJQUVEOztPQUVHO0lBQ0ksVUFBVTtRQUNmLE9BQU8sSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFDLElBQUksQ0FDMUIsR0FBRyxDQUNELENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FDVCxNQUFNLEtBQUsscUJBQXFCLElBQUksTUFBTSxLQUFLLG1CQUFtQixDQUNyRSxDQUNGLENBQUM7SUFDSixDQUFDOzswR0FoRVUsYUFBYTs4R0FBYixhQUFhLGNBRlosTUFBTTsyRkFFUCxhQUFhO2tCQUh6QixVQUFVO21CQUFDO29CQUNWLFVBQVUsRUFBRSxNQUFNO2lCQUNuQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUsIFJlcGxheVN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IG1hcCwgdGFrZSB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7XG4gIE9DQ19VU0VSX0lEX0FOT05ZTU9VUyxcbiAgT0NDX1VTRVJfSURfQ1VSUkVOVCxcbn0gZnJvbSAnLi4vLi4vLi4vb2NjL3V0aWxzL29jYy1jb25zdGFudHMnO1xuXG4vKipcbiAqIFRoaXMgaW1wbGVtZW50YXRpb24gaXMgT0NDIHNwZWNpZmljLlxuICogRGlmZmVyZW50IGJhY2tlbmQgbWlnaHQgaGF2ZSBjb21wbGV0ZWx5IGRpZmZlcmVudCBuZWVkIHJlZ2FyZGluZyB1c2VyIGlkLlxuICogSXQgbWlnaHQgbm90IG5lZWQgdXNlciBpZCBhdCBhbGwgYW5kIHdvcmsgYmFzZWQgb24gYWNjZXNzX3Rva2VuLlxuICogVG8gaW1wbGVtZW50IGN1c3RvbSBzb2x1dGlvbiBwcm92aWRlIHlvdXIgb3duIGltcGxlbWVudGF0aW9uIGFuZCBjdXN0b21pemUgc2VydmljZXMgdGhhdCB1c2UgVXNlcklkU2VydmljZVxuICovXG5ASW5qZWN0YWJsZSh7XG4gIHByb3ZpZGVkSW46ICdyb290Jyxcbn0pXG5leHBvcnQgY2xhc3MgVXNlcklkU2VydmljZSB7XG4gIHByaXZhdGUgX3VzZXJJZDogT2JzZXJ2YWJsZTxzdHJpbmc+ID0gbmV3IFJlcGxheVN1YmplY3Q8c3RyaW5nPigxKTtcblxuICAvKipcbiAgICogU2V0cyBjdXJyZW50IHVzZXIgaWQuXG4gICAqXG4gICAqIEBwYXJhbSB1c2VySWRcbiAgICovXG4gIHB1YmxpYyBzZXRVc2VySWQodXNlcklkOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAodGhpcy5fdXNlcklkIGFzIFJlcGxheVN1YmplY3Q8c3RyaW5nPikubmV4dCh1c2VySWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gcHJvdmlkZXMgdGhlIHVzZXJJZCB0aGUgT0NDIGNhbGxzIHNob3VsZCB1c2UsIGRlcGVuZGluZ1xuICAgKiBvbiB3aGV0aGVyIHRoZXJlIGlzIGFuIGFjdGl2ZSBzdG9yZWZyb250IHNlc3Npb24gb3Igbm90LlxuICAgKlxuICAgKiBJdCByZXR1cm5zIHRoZSB1c2VySWQgb2YgdGhlIGN1cnJlbnQgc3RvcmVmcm9udCB1c2VyIG9yICdhbm9ueW1vdXMnXG4gICAqIGluIHRoZSBjYXNlIHRoZXJlIGFyZSBubyBzaWduZWQgaW4gdXNlciBpbiB0aGUgc3RvcmVmcm9udC5cbiAgICpcbiAgICogVGhlIHVzZXIgaWQgb2YgYSByZWd1bGFyIGN1c3RvbWVyIHNlc3Npb24gaXMgJ2N1cnJlbnQnLiBJbiB0aGUgY2FzZSBvZiBhblxuICAgKiBhc20gY3VzdG9tZXIgZW11bGF0aW9uIHNlc3Npb24sIHRoZSB1c2VySWQgd2lsbCBiZSB0aGUgY3VzdG9tZXJJZC5cbiAgICovXG4gIHB1YmxpYyBnZXRVc2VySWQoKTogT2JzZXJ2YWJsZTxzdHJpbmc+IHtcbiAgICByZXR1cm4gdGhpcy5fdXNlcklkO1xuICB9XG5cbiAgLyoqXG4gICAqIFV0aWxpdHkgbWV0aG9kIGlmIHlvdSBuZWVkIHVzZXJJZCB0byBwZXJmb3JtIHNpbmdsZSBhY3Rpb24gKGVnLiBkaXNwYXRjaCBjYWxsIHRvIEFQSSkuXG4gICAqXG4gICAqIEBwYXJhbSBsb2dnZWRJbiBTZXQgdG8gdHJ1ZSBpZiB5b3Ugd2FudCB0aGUgb2JzZXJ2YWJsZSB0byBlbWl0IGlkIG9ubHkgZm9yIGxvZ2dlZCBpbiB1c2VyLiBUaHJvd3MgaW4gY2FzZSBvZiBhbm9ueW1vdXMgdXNlci5cbiAgICpcbiAgICogQHJldHVybnMgT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIG9uY2UgYW5kIGNvbXBsZXRlcyB3aXRoIHRoZSBsYXN0IHVzZXJJZCB2YWx1ZS5cbiAgICovXG4gIHB1YmxpYyB0YWtlVXNlcklkKGxvZ2dlZEluID0gZmFsc2UpOiBPYnNlcnZhYmxlPHN0cmluZz4ge1xuICAgIHJldHVybiB0aGlzLmdldFVzZXJJZCgpLnBpcGUoXG4gICAgICB0YWtlKDEpLFxuICAgICAgbWFwKCh1c2VySWQpID0+IHtcbiAgICAgICAgaWYgKGxvZ2dlZEluICYmIHVzZXJJZCA9PT0gT0NDX1VTRVJfSURfQU5PTllNT1VTKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ1JlcXVlc3RlZCB1c2VyIGlkIGZvciBsb2dnZWQgdXNlciB3aGlsZSB1c2VyIGlzIG5vdCBsb2dnZWQgaW4uJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVzZXJJZDtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHVzZXIgaWQgdG8gdGhlIGRlZmF1bHQgdmFsdWUgZm9yIGxvZ2dlZCBvdXQgdXNlci5cbiAgICovXG4gIHB1YmxpYyBjbGVhclVzZXJJZCgpOiB2b2lkIHtcbiAgICB0aGlzLnNldFVzZXJJZChPQ0NfVVNFUl9JRF9BTk9OWU1PVVMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgdXNlcklkIGlzIG9mIGVtdWxhdGVkIHVzZXIgdHlwZS5cbiAgICovXG4gIHB1YmxpYyBpc0VtdWxhdGVkKCk6IE9ic2VydmFibGU8Ym9vbGVhbj4ge1xuICAgIHJldHVybiB0aGlzLmdldFVzZXJJZCgpLnBpcGUoXG4gICAgICBtYXAoXG4gICAgICAgICh1c2VySWQpID0+XG4gICAgICAgICAgdXNlcklkICE9PSBPQ0NfVVNFUl9JRF9BTk9OWU1PVVMgJiYgdXNlcklkICE9PSBPQ0NfVVNFUl9JRF9DVVJSRU5UXG4gICAgICApXG4gICAgKTtcbiAgfVxufVxuIl19