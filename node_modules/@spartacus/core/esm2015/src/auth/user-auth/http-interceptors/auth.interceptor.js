import { HttpErrorResponse, } from '@angular/common/http';
import { Injectable } from '@angular/core';
import { of, throwError } from 'rxjs';
import { catchError, map, switchMap, take } from 'rxjs/operators';
import * as i0 from "@angular/core";
import * as i1 from "../services/auth-http-header.service";
import * as i2 from "../services/auth-config.service";
/**
 * Responsible for catching auth errors and providing `Authorization` header for API calls.
 * Uses AuthHttpHeaderService for request manipulation and error handling. Interceptor only hooks into request send/received events.
 */
export class AuthInterceptor {
    constructor(authHttpHeaderService, authConfigService) {
        this.authHttpHeaderService = authHttpHeaderService;
        this.authConfigService = authConfigService;
    }
    intercept(request, next) {
        const shouldCatchError = this.authHttpHeaderService.shouldCatchError(request);
        const shouldAddAuthorizationHeader = this.authHttpHeaderService.shouldAddAuthorizationHeader(request);
        const token$ = shouldAddAuthorizationHeader
            ? // emits sync, unless there is refresh or logout in progress, in which case it emits async
                this.authHttpHeaderService.getStableToken().pipe(take(1))
            : of(undefined);
        const requestAndToken$ = token$.pipe(map((token) => ({
            token,
            request: this.authHttpHeaderService.alterRequest(request, token),
        })));
        return requestAndToken$.pipe(switchMap(({ request, token }) => next.handle(request).pipe(catchError((errResponse) => {
            var _a, _b;
            if (errResponse instanceof HttpErrorResponse) {
                switch (errResponse.status) {
                    case 401: // Unauthorized
                        if (this.isExpiredToken(errResponse) && shouldCatchError) {
                            // request failed because of the expired access token
                            // we should get refresh the token and retry the request, or logout if the refresh is missing / expired
                            return this.authHttpHeaderService.handleExpiredAccessToken(request, next, token);
                        }
                        else if (
                        // Refresh the expired token
                        // Check if the OAuth endpoint was called and the error is because the refresh token expired
                        ((_a = errResponse.url) === null || _a === void 0 ? void 0 : _a.includes(this.authConfigService.getTokenEndpoint())) &&
                            errResponse.error.error === 'invalid_token') {
                            this.authHttpHeaderService.handleExpiredRefreshToken();
                            return of();
                        }
                        break;
                    case 400: // Bad Request
                        if (((_b = errResponse.url) === null || _b === void 0 ? void 0 : _b.includes(this.authConfigService.getTokenEndpoint())) &&
                            errResponse.error.error === 'invalid_grant') {
                            if (request.body.get('grant_type') === 'refresh_token') {
                                this.authHttpHeaderService.handleExpiredRefreshToken();
                            }
                        }
                        break;
                }
            }
            return throwError(errResponse);
        }))));
    }
    isExpiredToken(resp) {
        var _a, _b, _c;
        return ((_c = (_b = (_a = resp.error) === null || _a === void 0 ? void 0 : _a.errors) === null || _b === void 0 ? void 0 : _b[0]) === null || _c === void 0 ? void 0 : _c.type) === 'InvalidTokenError';
    }
}
AuthInterceptor.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AuthInterceptor, deps: [{ token: i1.AuthHttpHeaderService }, { token: i2.AuthConfigService }], target: i0.ɵɵFactoryTarget.Injectable });
AuthInterceptor.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AuthInterceptor, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AuthInterceptor, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: function () { return [{ type: i1.AuthHttpHeaderService }, { type: i2.AuthConfigService }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXV0aC5pbnRlcmNlcHRvci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2NvcmUvc3JjL2F1dGgvdXNlci1hdXRoL2h0dHAtaW50ZXJjZXB0b3JzL2F1dGguaW50ZXJjZXB0b3IudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUNMLGlCQUFpQixHQUtsQixNQUFNLHNCQUFzQixDQUFDO0FBQzlCLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDM0MsT0FBTyxFQUFjLEVBQUUsRUFBRSxVQUFVLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDbEQsT0FBTyxFQUFFLFVBQVUsRUFBRSxHQUFHLEVBQUUsU0FBUyxFQUFFLElBQUksRUFBRSxNQUFNLGdCQUFnQixDQUFDOzs7O0FBSWxFOzs7R0FHRztBQUVILE1BQU0sT0FBTyxlQUFlO0lBQzFCLFlBQ1kscUJBQTRDLEVBQzVDLGlCQUFvQztRQURwQywwQkFBcUIsR0FBckIscUJBQXFCLENBQXVCO1FBQzVDLHNCQUFpQixHQUFqQixpQkFBaUIsQ0FBbUI7SUFDN0MsQ0FBQztJQUVKLFNBQVMsQ0FDUCxPQUF5QixFQUN6QixJQUFpQjtRQUVqQixNQUFNLGdCQUFnQixHQUNwQixJQUFJLENBQUMscUJBQXFCLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDdkQsTUFBTSw0QkFBNEIsR0FDaEMsSUFBSSxDQUFDLHFCQUFxQixDQUFDLDRCQUE0QixDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBRW5FLE1BQU0sTUFBTSxHQUFHLDRCQUE0QjtZQUN6QyxDQUFDLENBQUMsMEZBQTBGO2dCQUMxRixJQUFJLENBQUMscUJBQXFCLENBQUMsY0FBYyxFQUFFLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUMzRCxDQUFDLENBQUMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQ2xCLE1BQU0sZ0JBQWdCLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FDbEMsR0FBRyxDQUFDLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1lBQ2QsS0FBSztZQUNMLE9BQU8sRUFBRSxJQUFJLENBQUMscUJBQXFCLENBQUMsWUFBWSxDQUFDLE9BQU8sRUFBRSxLQUFLLENBQUM7U0FDakUsQ0FBQyxDQUFDLENBQ0osQ0FBQztRQUVGLE9BQU8sZ0JBQWdCLENBQUMsSUFBSSxDQUMxQixTQUFTLENBQUMsQ0FBQyxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsRUFBRSxFQUFFLENBQy9CLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUN2QixVQUFVLENBQUMsQ0FBQyxXQUFnQixFQUFFLEVBQUU7O1lBQzlCLElBQUksV0FBVyxZQUFZLGlCQUFpQixFQUFFO2dCQUM1QyxRQUFRLFdBQVcsQ0FBQyxNQUFNLEVBQUU7b0JBQzFCLEtBQUssR0FBRyxFQUFFLGVBQWU7d0JBQ3ZCLElBQUksSUFBSSxDQUFDLGNBQWMsQ0FBQyxXQUFXLENBQUMsSUFBSSxnQkFBZ0IsRUFBRTs0QkFDeEQscURBQXFEOzRCQUNyRCx1R0FBdUc7NEJBQ3ZHLE9BQU8sSUFBSSxDQUFDLHFCQUFxQixDQUFDLHdCQUF3QixDQUN4RCxPQUFPLEVBQ1AsSUFBSSxFQUNKLEtBQUssQ0FDTixDQUFDO3lCQUNIOzZCQUFNO3dCQUNMLDRCQUE0Qjt3QkFDNUIsNEZBQTRGO3dCQUM1RixDQUFBLE1BQUEsV0FBVyxDQUFDLEdBQUcsMENBQUUsUUFBUSxDQUN2QixJQUFJLENBQUMsaUJBQWlCLENBQUMsZ0JBQWdCLEVBQUUsQ0FDMUM7NEJBQ0QsV0FBVyxDQUFDLEtBQUssQ0FBQyxLQUFLLEtBQUssZUFBZSxFQUMzQzs0QkFDQSxJQUFJLENBQUMscUJBQXFCLENBQUMseUJBQXlCLEVBQUUsQ0FBQzs0QkFDdkQsT0FBTyxFQUFFLEVBQWtCLENBQUM7eUJBQzdCO3dCQUVELE1BQU07b0JBQ1IsS0FBSyxHQUFHLEVBQUUsY0FBYzt3QkFDdEIsSUFDRSxDQUFBLE1BQUEsV0FBVyxDQUFDLEdBQUcsMENBQUUsUUFBUSxDQUN2QixJQUFJLENBQUMsaUJBQWlCLENBQUMsZ0JBQWdCLEVBQUUsQ0FDMUM7NEJBQ0QsV0FBVyxDQUFDLEtBQUssQ0FBQyxLQUFLLEtBQUssZUFBZSxFQUMzQzs0QkFDQSxJQUFJLE9BQU8sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLFlBQVksQ0FBQyxLQUFLLGVBQWUsRUFBRTtnQ0FDdEQsSUFBSSxDQUFDLHFCQUFxQixDQUFDLHlCQUF5QixFQUFFLENBQUM7NkJBQ3hEO3lCQUNGO3dCQUNELE1BQU07aUJBQ1Q7YUFDRjtZQUNELE9BQU8sVUFBVSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBQ2pDLENBQUMsQ0FBQyxDQUNILENBQ0YsQ0FDRixDQUFDO0lBQ0osQ0FBQztJQUVTLGNBQWMsQ0FBQyxJQUF1Qjs7UUFDOUMsT0FBTyxDQUFBLE1BQUEsTUFBQSxNQUFBLElBQUksQ0FBQyxLQUFLLDBDQUFFLE1BQU0sMENBQUcsQ0FBQyxDQUFDLDBDQUFFLElBQUksTUFBSyxtQkFBbUIsQ0FBQztJQUMvRCxDQUFDOzs0R0E3RVUsZUFBZTtnSEFBZixlQUFlLGNBREYsTUFBTTsyRkFDbkIsZUFBZTtrQkFEM0IsVUFBVTttQkFBQyxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUUiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBIdHRwRXJyb3JSZXNwb25zZSxcbiAgSHR0cEV2ZW50LFxuICBIdHRwSGFuZGxlcixcbiAgSHR0cEludGVyY2VwdG9yLFxuICBIdHRwUmVxdWVzdCxcbn0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uL2h0dHAnO1xuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgb2YsIHRocm93RXJyb3IgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGNhdGNoRXJyb3IsIG1hcCwgc3dpdGNoTWFwLCB0YWtlIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgQXV0aENvbmZpZ1NlcnZpY2UgfSBmcm9tICcuLi9zZXJ2aWNlcy9hdXRoLWNvbmZpZy5zZXJ2aWNlJztcbmltcG9ydCB7IEF1dGhIdHRwSGVhZGVyU2VydmljZSB9IGZyb20gJy4uL3NlcnZpY2VzL2F1dGgtaHR0cC1oZWFkZXIuc2VydmljZSc7XG5cbi8qKlxuICogUmVzcG9uc2libGUgZm9yIGNhdGNoaW5nIGF1dGggZXJyb3JzIGFuZCBwcm92aWRpbmcgYEF1dGhvcml6YXRpb25gIGhlYWRlciBmb3IgQVBJIGNhbGxzLlxuICogVXNlcyBBdXRoSHR0cEhlYWRlclNlcnZpY2UgZm9yIHJlcXVlc3QgbWFuaXB1bGF0aW9uIGFuZCBlcnJvciBoYW5kbGluZy4gSW50ZXJjZXB0b3Igb25seSBob29rcyBpbnRvIHJlcXVlc3Qgc2VuZC9yZWNlaXZlZCBldmVudHMuXG4gKi9cbkBJbmplY3RhYmxlKHsgcHJvdmlkZWRJbjogJ3Jvb3QnIH0pXG5leHBvcnQgY2xhc3MgQXV0aEludGVyY2VwdG9yIGltcGxlbWVudHMgSHR0cEludGVyY2VwdG9yIHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHJvdGVjdGVkIGF1dGhIdHRwSGVhZGVyU2VydmljZTogQXV0aEh0dHBIZWFkZXJTZXJ2aWNlLFxuICAgIHByb3RlY3RlZCBhdXRoQ29uZmlnU2VydmljZTogQXV0aENvbmZpZ1NlcnZpY2VcbiAgKSB7fVxuXG4gIGludGVyY2VwdChcbiAgICByZXF1ZXN0OiBIdHRwUmVxdWVzdDxhbnk+LFxuICAgIG5leHQ6IEh0dHBIYW5kbGVyXG4gICk6IE9ic2VydmFibGU8SHR0cEV2ZW50PGFueT4+IHtcbiAgICBjb25zdCBzaG91bGRDYXRjaEVycm9yID1cbiAgICAgIHRoaXMuYXV0aEh0dHBIZWFkZXJTZXJ2aWNlLnNob3VsZENhdGNoRXJyb3IocmVxdWVzdCk7XG4gICAgY29uc3Qgc2hvdWxkQWRkQXV0aG9yaXphdGlvbkhlYWRlciA9XG4gICAgICB0aGlzLmF1dGhIdHRwSGVhZGVyU2VydmljZS5zaG91bGRBZGRBdXRob3JpemF0aW9uSGVhZGVyKHJlcXVlc3QpO1xuXG4gICAgY29uc3QgdG9rZW4kID0gc2hvdWxkQWRkQXV0aG9yaXphdGlvbkhlYWRlclxuICAgICAgPyAvLyBlbWl0cyBzeW5jLCB1bmxlc3MgdGhlcmUgaXMgcmVmcmVzaCBvciBsb2dvdXQgaW4gcHJvZ3Jlc3MsIGluIHdoaWNoIGNhc2UgaXQgZW1pdHMgYXN5bmNcbiAgICAgICAgdGhpcy5hdXRoSHR0cEhlYWRlclNlcnZpY2UuZ2V0U3RhYmxlVG9rZW4oKS5waXBlKHRha2UoMSkpXG4gICAgICA6IG9mKHVuZGVmaW5lZCk7XG4gICAgY29uc3QgcmVxdWVzdEFuZFRva2VuJCA9IHRva2VuJC5waXBlKFxuICAgICAgbWFwKCh0b2tlbikgPT4gKHtcbiAgICAgICAgdG9rZW4sXG4gICAgICAgIHJlcXVlc3Q6IHRoaXMuYXV0aEh0dHBIZWFkZXJTZXJ2aWNlLmFsdGVyUmVxdWVzdChyZXF1ZXN0LCB0b2tlbiksXG4gICAgICB9KSlcbiAgICApO1xuXG4gICAgcmV0dXJuIHJlcXVlc3RBbmRUb2tlbiQucGlwZShcbiAgICAgIHN3aXRjaE1hcCgoeyByZXF1ZXN0LCB0b2tlbiB9KSA9PlxuICAgICAgICBuZXh0LmhhbmRsZShyZXF1ZXN0KS5waXBlKFxuICAgICAgICAgIGNhdGNoRXJyb3IoKGVyclJlc3BvbnNlOiBhbnkpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnJSZXNwb25zZSBpbnN0YW5jZW9mIEh0dHBFcnJvclJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgIHN3aXRjaCAoZXJyUmVzcG9uc2Uuc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSA0MDE6IC8vIFVuYXV0aG9yaXplZFxuICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNFeHBpcmVkVG9rZW4oZXJyUmVzcG9uc2UpICYmIHNob3VsZENhdGNoRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVxdWVzdCBmYWlsZWQgYmVjYXVzZSBvZiB0aGUgZXhwaXJlZCBhY2Nlc3MgdG9rZW5cbiAgICAgICAgICAgICAgICAgICAgLy8gd2Ugc2hvdWxkIGdldCByZWZyZXNoIHRoZSB0b2tlbiBhbmQgcmV0cnkgdGhlIHJlcXVlc3QsIG9yIGxvZ291dCBpZiB0aGUgcmVmcmVzaCBpcyBtaXNzaW5nIC8gZXhwaXJlZFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hdXRoSHR0cEhlYWRlclNlcnZpY2UuaGFuZGxlRXhwaXJlZEFjY2Vzc1Rva2VuKFxuICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgICAgbmV4dCxcbiAgICAgICAgICAgICAgICAgICAgICB0b2tlblxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVmcmVzaCB0aGUgZXhwaXJlZCB0b2tlblxuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgT0F1dGggZW5kcG9pbnQgd2FzIGNhbGxlZCBhbmQgdGhlIGVycm9yIGlzIGJlY2F1c2UgdGhlIHJlZnJlc2ggdG9rZW4gZXhwaXJlZFxuICAgICAgICAgICAgICAgICAgICBlcnJSZXNwb25zZS51cmw/LmluY2x1ZGVzKFxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXV0aENvbmZpZ1NlcnZpY2UuZ2V0VG9rZW5FbmRwb2ludCgpXG4gICAgICAgICAgICAgICAgICAgICkgJiZcbiAgICAgICAgICAgICAgICAgICAgZXJyUmVzcG9uc2UuZXJyb3IuZXJyb3IgPT09ICdpbnZhbGlkX3Rva2VuJ1xuICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXV0aEh0dHBIZWFkZXJTZXJ2aWNlLmhhbmRsZUV4cGlyZWRSZWZyZXNoVG9rZW4oKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9mPEh0dHBFdmVudDxhbnk+PigpO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQwMDogLy8gQmFkIFJlcXVlc3RcbiAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgZXJyUmVzcG9uc2UudXJsPy5pbmNsdWRlcyhcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF1dGhDb25maWdTZXJ2aWNlLmdldFRva2VuRW5kcG9pbnQoKVxuICAgICAgICAgICAgICAgICAgICApICYmXG4gICAgICAgICAgICAgICAgICAgIGVyclJlc3BvbnNlLmVycm9yLmVycm9yID09PSAnaW52YWxpZF9ncmFudCdcbiAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVxdWVzdC5ib2R5LmdldCgnZ3JhbnRfdHlwZScpID09PSAncmVmcmVzaF90b2tlbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF1dGhIdHRwSGVhZGVyU2VydmljZS5oYW5kbGVFeHBpcmVkUmVmcmVzaFRva2VuKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhyb3dFcnJvcihlcnJSZXNwb25zZSk7XG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgKVxuICAgICk7XG4gIH1cblxuICBwcm90ZWN0ZWQgaXNFeHBpcmVkVG9rZW4ocmVzcDogSHR0cEVycm9yUmVzcG9uc2UpOiBib29sZWFuIHtcbiAgICByZXR1cm4gcmVzcC5lcnJvcj8uZXJyb3JzPy5bMF0/LnR5cGUgPT09ICdJbnZhbGlkVG9rZW5FcnJvcic7XG4gIH1cbn1cbiJdfQ==