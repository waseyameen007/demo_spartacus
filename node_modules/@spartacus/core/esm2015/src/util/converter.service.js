import { Injectable } from '@angular/core';
import { Subscription } from 'rxjs';
import { map, tap } from 'rxjs/operators';
import { getLastValueSync } from './rxjs/get-last-value-sync';
import * as i0 from "@angular/core";
import * as i1 from "../lazy-loading/unified-injector";
export class ConverterService {
    constructor(unifiedInjector) {
        this.unifiedInjector = unifiedInjector;
        this.subscriptions = new Subscription();
        this.converters = new Map();
        // Clear cached converters when new injectors appear
        const cacheResetLogic = this.unifiedInjector.injectors$.pipe(tap(() => this.converters.clear()));
        this.subscriptions.add(cacheResetLogic.subscribe());
    }
    getConverters(injectionToken) {
        if (!this.converters.has(injectionToken)) {
            const converters = getLastValueSync(this.unifiedInjector.getMulti(injectionToken));
            this.converters.set(injectionToken, converters);
        }
        return this.converters.get(injectionToken);
    }
    /**
     * Will return true if converters for specified token were provided
     */
    hasConverters(injectionToken) {
        const converters = this.getConverters(injectionToken);
        return Array.isArray(converters) && converters.length > 0;
    }
    /**
     * Pipeable operator to apply converter logic in a observable stream
     */
    pipeable(injectionToken) {
        if (this.hasConverters(injectionToken)) {
            return map((model) => this.convertSource(model, injectionToken));
        }
        else {
            return (observable) => observable;
        }
    }
    /**
     * Pipeable operator to apply converter logic in a observable stream to collection of items
     */
    pipeableMany(injectionToken) {
        if (this.hasConverters(injectionToken)) {
            return map((model) => this.convertMany(model, injectionToken));
        }
        else {
            return (observable) => observable;
        }
    }
    /**
     * Apply converter logic specified by injection token to source data
     */
    convert(source, injectionToken) {
        if (this.hasConverters(injectionToken)) {
            return this.convertSource(source, injectionToken);
        }
        else {
            return source;
        }
    }
    /**
     * Apply converter logic specified by injection token to a collection
     */
    convertMany(sources, injectionToken) {
        if (this.hasConverters(injectionToken) && Array.isArray(sources)) {
            return sources.map((source) => this.convertSource(source, injectionToken));
        }
        else {
            return sources;
        }
    }
    convertSource(source, injectionToken) {
        return this.getConverters(injectionToken).reduce((target, converter) => {
            return converter.convert(source, target);
        }, undefined);
    }
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
    }
}
ConverterService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ConverterService, deps: [{ token: i1.UnifiedInjector }], target: i0.ɵɵFactoryTarget.Injectable });
ConverterService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ConverterService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: ConverterService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.UnifiedInjector }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udmVydGVyLnNlcnZpY2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9jb3JlL3NyYy91dGlsL2NvbnZlcnRlci5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQTZCLE1BQU0sZUFBZSxDQUFDO0FBQ3RFLE9BQU8sRUFBZ0MsWUFBWSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQ2xFLE9BQU8sRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFFMUMsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sNEJBQTRCLENBQUM7OztBQXdCOUQsTUFBTSxPQUFPLGdCQUFnQjtJQUczQixZQUFzQixlQUFnQztRQUFoQyxvQkFBZSxHQUFmLGVBQWUsQ0FBaUI7UUFGNUMsa0JBQWEsR0FBRyxJQUFJLFlBQVksRUFBRSxDQUFDO1FBV3JDLGVBQVUsR0FHZCxJQUFJLEdBQUcsRUFBRSxDQUFDO1FBWFosb0RBQW9EO1FBQ3BELE1BQU0sZUFBZSxHQUFHLElBQUksQ0FBQyxlQUFlLENBQUMsVUFBVSxDQUFDLElBQUksQ0FDMUQsR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FDbkMsQ0FBQztRQUVGLElBQUksQ0FBQyxhQUFhLENBQUMsR0FBRyxDQUFDLGVBQWUsQ0FBQyxTQUFTLEVBQUUsQ0FBQyxDQUFDO0lBQ3RELENBQUM7SUFPTyxhQUFhLENBQ25CLGNBQStDO1FBRS9DLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxjQUFjLENBQUMsRUFBRTtZQUN4QyxNQUFNLFVBQVUsR0FBRyxnQkFBZ0IsQ0FDakMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxRQUFRLENBQUMsY0FBYyxDQUFDLENBQzlDLENBQUM7WUFDRixJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxjQUFjLEVBQUUsVUFBVSxDQUFDLENBQUM7U0FDakQ7UUFFRCxPQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLGNBQWMsQ0FBQyxDQUFDO0lBQzdDLENBQUM7SUFFRDs7T0FFRztJQUNILGFBQWEsQ0FDWCxjQUErQztRQUUvQyxNQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLGNBQWMsQ0FBQyxDQUFDO1FBQ3RELE9BQU8sS0FBSyxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsSUFBSSxVQUFVLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQztJQUM1RCxDQUFDO0lBRUQ7O09BRUc7SUFDSCxRQUFRLENBQ04sY0FBK0M7UUFFL0MsSUFBSSxJQUFJLENBQUMsYUFBYSxDQUFDLGNBQWMsQ0FBQyxFQUFFO1lBQ3RDLE9BQU8sR0FBRyxDQUFDLENBQUMsS0FBUSxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLEtBQUssRUFBRSxjQUFjLENBQUMsQ0FBQyxDQUFDO1NBQ3JFO2FBQU07WUFDTCxPQUFPLENBQUMsVUFBMkIsRUFBRSxFQUFFLENBQUMsVUFBMkIsQ0FBQztTQUNyRTtJQUNILENBQUM7SUFFRDs7T0FFRztJQUNILFlBQVksQ0FDVixjQUErQztRQUUvQyxJQUFJLElBQUksQ0FBQyxhQUFhLENBQUMsY0FBYyxDQUFDLEVBQUU7WUFDdEMsT0FBTyxHQUFHLENBQUMsQ0FBQyxLQUFVLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsS0FBSyxFQUFFLGNBQWMsQ0FBQyxDQUFDLENBQUM7U0FDckU7YUFBTTtZQUNMLE9BQU8sQ0FBQyxVQUE2QixFQUFFLEVBQUUsQ0FBQyxVQUE2QixDQUFDO1NBQ3pFO0lBQ0gsQ0FBQztJQUVEOztPQUVHO0lBQ0gsT0FBTyxDQUFPLE1BQVMsRUFBRSxjQUErQztRQUN0RSxJQUFJLElBQUksQ0FBQyxhQUFhLENBQUMsY0FBYyxDQUFDLEVBQUU7WUFDdEMsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDLE1BQU0sRUFBRSxjQUFjLENBQUMsQ0FBQztTQUNuRDthQUFNO1lBQ0wsT0FBTyxNQUFhLENBQUM7U0FDdEI7SUFDSCxDQUFDO0lBRUQ7O09BRUc7SUFDSCxXQUFXLENBQ1QsT0FBWSxFQUNaLGNBQStDO1FBRS9DLElBQUksSUFBSSxDQUFDLGFBQWEsQ0FBQyxjQUFjLENBQUMsSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQ2hFLE9BQU8sT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQzVCLElBQUksQ0FBQyxhQUFhLENBQUMsTUFBTSxFQUFFLGNBQWMsQ0FBQyxDQUMzQyxDQUFDO1NBQ0g7YUFBTTtZQUNMLE9BQU8sT0FBZ0IsQ0FBQztTQUN6QjtJQUNILENBQUM7SUFFTyxhQUFhLENBQ25CLE1BQVMsRUFDVCxjQUErQztRQUUvQyxPQUFPLElBQUksQ0FBQyxhQUFhLENBQUMsY0FBYyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsTUFBTSxFQUFFLFNBQVMsRUFBRSxFQUFFO1lBQ3JFLE9BQU8sU0FBUyxDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFDM0MsQ0FBQyxFQUFFLFNBQWMsQ0FBQyxDQUFDO0lBQ3JCLENBQUM7SUFFRCxXQUFXO1FBQ1QsSUFBSSxDQUFDLGFBQWEsQ0FBQyxXQUFXLEVBQUUsQ0FBQztJQUNuQyxDQUFDOzs2R0F4R1UsZ0JBQWdCO2lIQUFoQixnQkFBZ0IsY0FGZixNQUFNOzJGQUVQLGdCQUFnQjtrQkFINUIsVUFBVTttQkFBQztvQkFDVixVQUFVLEVBQUUsTUFBTTtpQkFDbkIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlLCBJbmplY3Rpb25Ub2tlbiwgT25EZXN0cm95IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBPcGVyYXRvckZ1bmN0aW9uLCBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IG1hcCwgdGFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgVW5pZmllZEluamVjdG9yIH0gZnJvbSAnLi4vbGF6eS1sb2FkaW5nL3VuaWZpZWQtaW5qZWN0b3InO1xuaW1wb3J0IHsgZ2V0TGFzdFZhbHVlU3luYyB9IGZyb20gJy4vcnhqcy9nZXQtbGFzdC12YWx1ZS1zeW5jJztcblxuLyoqXG4gKiBDb252ZXJ0ZXIgaXMgdXNlZCB0byBjb252ZXJ0IHNvdXJjZSBkYXRhIG1vZGVsIHRvIHRhcmdldCBkYXRhIG1vZGVsLlxuICogQnkgY29udmVudGlvbiwgd2UgZGlzdGluZ3Vpc2ggdHdvIGZsb3dzOlxuICogICAtICpOb3JtYWxpemUqIGlzIHRoZSBjb252ZXJzaW9uIGZyb20gYmFja2VuZCBtb2RlbHMgdG8gVUkgbW9kZWxzXG4gKiAgIC0gKlNlcmlhbGl6ZSogaXMgdGhlIGNvbnZlcnNpb24gb2YgVUkgbW9kZWxzIHRvIGJhY2tlbmQgbW9kZWxzIChpbiBjYXNlIG9mIHN1Ym1pdHRpbmcgZGF0YSB0byB0aGUgYmFja2VuZCkuXG4gKlxuICogQ29udmVydGVycyBjYW4gYmUgc3RhY2tlZCB0b2dldGhlciB0byB0byBhcHBseSBkZWNvdXBsZWQgY3VzdG9taXphdGlvbnNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDb252ZXJ0ZXI8UywgVD4ge1xuICAvKipcbiAgICogQ29udmVydCBjb252ZXJ0cyBzb3VyY2UgbW9kZWwgdG8gdGFyZ2V0IG1vZGVsLiBDYW4gdXNlIG9wdGlvbmFsIHRhcmdldCBwYXJhbWV0ZXIsXG4gICAqIHVzZWQgaW4gY2FzZSBvZiBzdGFja2luZyBtdWx0aXBsZSBjb252ZXJ0ZXJzIChmb3IgZXhhbXBsZSwgdG8gaW1wbGVtZW50IHBvcHVsYXRvciBwYXR0ZXJuKS5cbiAgICpcbiAgICogQHBhcmFtIHNvdXJjZSBTb3VyY2UgZGF0YSBtb2RlbFxuICAgKiBAcGFyYW0gdGFyZ2V0IE9wdGlvbmFsLCBwYXJ0aWFsbHkgY29udmVydGVkIHRhcmdldCBtb2RlbFxuICAgKi9cbiAgY29udmVydChzb3VyY2U6IFMsIHRhcmdldD86IFQpOiBUO1xufVxuXG5ASW5qZWN0YWJsZSh7XG4gIHByb3ZpZGVkSW46ICdyb290Jyxcbn0pXG5leHBvcnQgY2xhc3MgQ29udmVydGVyU2VydmljZSBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG4gIHByb3RlY3RlZCBzdWJzY3JpcHRpb25zID0gbmV3IFN1YnNjcmlwdGlvbigpO1xuXG4gIGNvbnN0cnVjdG9yKHByb3RlY3RlZCB1bmlmaWVkSW5qZWN0b3I6IFVuaWZpZWRJbmplY3Rvcikge1xuICAgIC8vIENsZWFyIGNhY2hlZCBjb252ZXJ0ZXJzIHdoZW4gbmV3IGluamVjdG9ycyBhcHBlYXJcbiAgICBjb25zdCBjYWNoZVJlc2V0TG9naWMgPSB0aGlzLnVuaWZpZWRJbmplY3Rvci5pbmplY3RvcnMkLnBpcGUoXG4gICAgICB0YXAoKCkgPT4gdGhpcy5jb252ZXJ0ZXJzLmNsZWFyKCkpXG4gICAgKTtcblxuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQoY2FjaGVSZXNldExvZ2ljLnN1YnNjcmliZSgpKTtcbiAgfVxuXG4gIHByaXZhdGUgY29udmVydGVyczogTWFwPFxuICAgIEluamVjdGlvblRva2VuPENvbnZlcnRlcjxhbnksIGFueT4+LFxuICAgIENvbnZlcnRlcjxhbnksIGFueT5bXVxuICA+ID0gbmV3IE1hcCgpO1xuXG4gIHByaXZhdGUgZ2V0Q29udmVydGVyczxTLCBUPihcbiAgICBpbmplY3Rpb25Ub2tlbjogSW5qZWN0aW9uVG9rZW48Q29udmVydGVyPFMsIFQ+PlxuICApOiBDb252ZXJ0ZXI8UywgVD5bXSB7XG4gICAgaWYgKCF0aGlzLmNvbnZlcnRlcnMuaGFzKGluamVjdGlvblRva2VuKSkge1xuICAgICAgY29uc3QgY29udmVydGVycyA9IGdldExhc3RWYWx1ZVN5bmMoXG4gICAgICAgIHRoaXMudW5pZmllZEluamVjdG9yLmdldE11bHRpKGluamVjdGlvblRva2VuKVxuICAgICAgKTtcbiAgICAgIHRoaXMuY29udmVydGVycy5zZXQoaW5qZWN0aW9uVG9rZW4sIGNvbnZlcnRlcnMpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNvbnZlcnRlcnMuZ2V0KGluamVjdGlvblRva2VuKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaWxsIHJldHVybiB0cnVlIGlmIGNvbnZlcnRlcnMgZm9yIHNwZWNpZmllZCB0b2tlbiB3ZXJlIHByb3ZpZGVkXG4gICAqL1xuICBoYXNDb252ZXJ0ZXJzPFMsIFQ+KFxuICAgIGluamVjdGlvblRva2VuOiBJbmplY3Rpb25Ub2tlbjxDb252ZXJ0ZXI8UywgVD4+XG4gICk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGNvbnZlcnRlcnMgPSB0aGlzLmdldENvbnZlcnRlcnMoaW5qZWN0aW9uVG9rZW4pO1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGNvbnZlcnRlcnMpICYmIGNvbnZlcnRlcnMubGVuZ3RoID4gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQaXBlYWJsZSBvcGVyYXRvciB0byBhcHBseSBjb252ZXJ0ZXIgbG9naWMgaW4gYSBvYnNlcnZhYmxlIHN0cmVhbVxuICAgKi9cbiAgcGlwZWFibGU8UywgVD4oXG4gICAgaW5qZWN0aW9uVG9rZW46IEluamVjdGlvblRva2VuPENvbnZlcnRlcjxTLCBUPj5cbiAgKTogT3BlcmF0b3JGdW5jdGlvbjxTLCBUPiB7XG4gICAgaWYgKHRoaXMuaGFzQ29udmVydGVycyhpbmplY3Rpb25Ub2tlbikpIHtcbiAgICAgIHJldHVybiBtYXAoKG1vZGVsOiBTKSA9PiB0aGlzLmNvbnZlcnRTb3VyY2UobW9kZWwsIGluamVjdGlvblRva2VuKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAob2JzZXJ2YWJsZTogT2JzZXJ2YWJsZTxhbnk+KSA9PiBvYnNlcnZhYmxlIGFzIE9ic2VydmFibGU8VD47XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFBpcGVhYmxlIG9wZXJhdG9yIHRvIGFwcGx5IGNvbnZlcnRlciBsb2dpYyBpbiBhIG9ic2VydmFibGUgc3RyZWFtIHRvIGNvbGxlY3Rpb24gb2YgaXRlbXNcbiAgICovXG4gIHBpcGVhYmxlTWFueTxTLCBUPihcbiAgICBpbmplY3Rpb25Ub2tlbjogSW5qZWN0aW9uVG9rZW48Q29udmVydGVyPFMsIFQ+PlxuICApOiBPcGVyYXRvckZ1bmN0aW9uPFNbXSwgVFtdPiB7XG4gICAgaWYgKHRoaXMuaGFzQ29udmVydGVycyhpbmplY3Rpb25Ub2tlbikpIHtcbiAgICAgIHJldHVybiBtYXAoKG1vZGVsOiBTW10pID0+IHRoaXMuY29udmVydE1hbnkobW9kZWwsIGluamVjdGlvblRva2VuKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAob2JzZXJ2YWJsZTogT2JzZXJ2YWJsZTxhbnlbXT4pID0+IG9ic2VydmFibGUgYXMgT2JzZXJ2YWJsZTxUW10+O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBseSBjb252ZXJ0ZXIgbG9naWMgc3BlY2lmaWVkIGJ5IGluamVjdGlvbiB0b2tlbiB0byBzb3VyY2UgZGF0YVxuICAgKi9cbiAgY29udmVydDxTLCBUPihzb3VyY2U6IFMsIGluamVjdGlvblRva2VuOiBJbmplY3Rpb25Ub2tlbjxDb252ZXJ0ZXI8UywgVD4+KTogVCB7XG4gICAgaWYgKHRoaXMuaGFzQ29udmVydGVycyhpbmplY3Rpb25Ub2tlbikpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRTb3VyY2Uoc291cmNlLCBpbmplY3Rpb25Ub2tlbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzb3VyY2UgYXMgYW55O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBseSBjb252ZXJ0ZXIgbG9naWMgc3BlY2lmaWVkIGJ5IGluamVjdGlvbiB0b2tlbiB0byBhIGNvbGxlY3Rpb25cbiAgICovXG4gIGNvbnZlcnRNYW55PFMsIFQ+KFxuICAgIHNvdXJjZXM6IFNbXSxcbiAgICBpbmplY3Rpb25Ub2tlbjogSW5qZWN0aW9uVG9rZW48Q29udmVydGVyPFMsIFQ+PlxuICApOiBUW10ge1xuICAgIGlmICh0aGlzLmhhc0NvbnZlcnRlcnMoaW5qZWN0aW9uVG9rZW4pICYmIEFycmF5LmlzQXJyYXkoc291cmNlcykpIHtcbiAgICAgIHJldHVybiBzb3VyY2VzLm1hcCgoc291cmNlKSA9PlxuICAgICAgICB0aGlzLmNvbnZlcnRTb3VyY2Uoc291cmNlLCBpbmplY3Rpb25Ub2tlbilcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzb3VyY2VzIGFzIGFueVtdO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgY29udmVydFNvdXJjZTxTLCBUPihcbiAgICBzb3VyY2U6IFMsXG4gICAgaW5qZWN0aW9uVG9rZW46IEluamVjdGlvblRva2VuPENvbnZlcnRlcjxTLCBUPj5cbiAgKTogVCB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q29udmVydGVycyhpbmplY3Rpb25Ub2tlbikucmVkdWNlKCh0YXJnZXQsIGNvbnZlcnRlcikgPT4ge1xuICAgICAgcmV0dXJuIGNvbnZlcnRlci5jb252ZXJ0KHNvdXJjZSwgdGFyZ2V0KTtcbiAgICB9LCB1bmRlZmluZWQgYXMgVCk7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMudW5zdWJzY3JpYmUoKTtcbiAgfVxufVxuIl19