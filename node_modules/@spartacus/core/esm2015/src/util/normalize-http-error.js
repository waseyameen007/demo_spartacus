import { HttpErrorResponse } from '@angular/common/http';
import { HttpErrorModel } from '../model/misc.model';
import { isDevMode } from '@angular/core';
/**
 * Normalizes HttpErrorResponse to HttpErrorModel.
 *
 * Can be used as a safe and generic way for embodying http errors into
 * NgRx Action payload, as it will strip potentially unserializable parts from
 * it and warn in debug mode if passed error is not instance of HttpErrorModel
 * (which usually happens when logic in NgRx Effect is not sealed correctly)
 */
export function normalizeHttpError(error) {
    if (error instanceof HttpErrorResponse) {
        const normalizedError = new HttpErrorModel();
        normalizedError.message = error.message;
        normalizedError.status = error.status;
        normalizedError.statusText = error.statusText;
        normalizedError.url = error.url;
        // include backend's error details
        if (Array.isArray(error.error.errors)) {
            normalizedError.details = error.error.errors;
        }
        else if (typeof error.error.error === 'string') {
            normalizedError.details = [
                {
                    type: error.error.error,
                    message: error.error.error_description,
                },
            ];
        }
        return normalizedError;
    }
    if (isDevMode()) {
        console.error('Error passed to normalizeHttpError is not HttpErrorResponse instance', error);
    }
    return undefined;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9ybWFsaXplLWh0dHAtZXJyb3IuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9jb3JlL3NyYy91dGlsL25vcm1hbGl6ZS1odHRwLWVycm9yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBQ3pELE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUNyRCxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBRTFDOzs7Ozs7O0dBT0c7QUFDSCxNQUFNLFVBQVUsa0JBQWtCLENBQ2hDLEtBQThCO0lBRTlCLElBQUksS0FBSyxZQUFZLGlCQUFpQixFQUFFO1FBQ3RDLE1BQU0sZUFBZSxHQUFHLElBQUksY0FBYyxFQUFFLENBQUM7UUFDN0MsZUFBZSxDQUFDLE9BQU8sR0FBRyxLQUFLLENBQUMsT0FBTyxDQUFDO1FBQ3hDLGVBQWUsQ0FBQyxNQUFNLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQztRQUN0QyxlQUFlLENBQUMsVUFBVSxHQUFHLEtBQUssQ0FBQyxVQUFVLENBQUM7UUFDOUMsZUFBZSxDQUFDLEdBQUcsR0FBRyxLQUFLLENBQUMsR0FBRyxDQUFDO1FBRWhDLGtDQUFrQztRQUNsQyxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsRUFBRTtZQUNyQyxlQUFlLENBQUMsT0FBTyxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDO1NBQzlDO2FBQU0sSUFBSSxPQUFPLEtBQUssQ0FBQyxLQUFLLENBQUMsS0FBSyxLQUFLLFFBQVEsRUFBRTtZQUNoRCxlQUFlLENBQUMsT0FBTyxHQUFHO2dCQUN4QjtvQkFDRSxJQUFJLEVBQUUsS0FBSyxDQUFDLEtBQUssQ0FBQyxLQUFLO29CQUN2QixPQUFPLEVBQUUsS0FBSyxDQUFDLEtBQUssQ0FBQyxpQkFBaUI7aUJBQ3ZDO2FBQ0YsQ0FBQztTQUNIO1FBRUQsT0FBTyxlQUFlLENBQUM7S0FDeEI7SUFFRCxJQUFJLFNBQVMsRUFBRSxFQUFFO1FBQ2YsT0FBTyxDQUFDLEtBQUssQ0FDWCxzRUFBc0UsRUFDdEUsS0FBSyxDQUNOLENBQUM7S0FDSDtJQUVELE9BQU8sU0FBUyxDQUFDO0FBQ25CLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBIdHRwRXJyb3JSZXNwb25zZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbi9odHRwJztcbmltcG9ydCB7IEh0dHBFcnJvck1vZGVsIH0gZnJvbSAnLi4vbW9kZWwvbWlzYy5tb2RlbCc7XG5pbXBvcnQgeyBpc0Rldk1vZGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuLyoqXG4gKiBOb3JtYWxpemVzIEh0dHBFcnJvclJlc3BvbnNlIHRvIEh0dHBFcnJvck1vZGVsLlxuICpcbiAqIENhbiBiZSB1c2VkIGFzIGEgc2FmZSBhbmQgZ2VuZXJpYyB3YXkgZm9yIGVtYm9keWluZyBodHRwIGVycm9ycyBpbnRvXG4gKiBOZ1J4IEFjdGlvbiBwYXlsb2FkLCBhcyBpdCB3aWxsIHN0cmlwIHBvdGVudGlhbGx5IHVuc2VyaWFsaXphYmxlIHBhcnRzIGZyb21cbiAqIGl0IGFuZCB3YXJuIGluIGRlYnVnIG1vZGUgaWYgcGFzc2VkIGVycm9yIGlzIG5vdCBpbnN0YW5jZSBvZiBIdHRwRXJyb3JNb2RlbFxuICogKHdoaWNoIHVzdWFsbHkgaGFwcGVucyB3aGVuIGxvZ2ljIGluIE5nUnggRWZmZWN0IGlzIG5vdCBzZWFsZWQgY29ycmVjdGx5KVxuICovXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplSHR0cEVycm9yKFxuICBlcnJvcjogSHR0cEVycm9yUmVzcG9uc2UgfCBhbnlcbik6IEh0dHBFcnJvck1vZGVsIHwgdW5kZWZpbmVkIHtcbiAgaWYgKGVycm9yIGluc3RhbmNlb2YgSHR0cEVycm9yUmVzcG9uc2UpIHtcbiAgICBjb25zdCBub3JtYWxpemVkRXJyb3IgPSBuZXcgSHR0cEVycm9yTW9kZWwoKTtcbiAgICBub3JtYWxpemVkRXJyb3IubWVzc2FnZSA9IGVycm9yLm1lc3NhZ2U7XG4gICAgbm9ybWFsaXplZEVycm9yLnN0YXR1cyA9IGVycm9yLnN0YXR1cztcbiAgICBub3JtYWxpemVkRXJyb3Iuc3RhdHVzVGV4dCA9IGVycm9yLnN0YXR1c1RleHQ7XG4gICAgbm9ybWFsaXplZEVycm9yLnVybCA9IGVycm9yLnVybDtcblxuICAgIC8vIGluY2x1ZGUgYmFja2VuZCdzIGVycm9yIGRldGFpbHNcbiAgICBpZiAoQXJyYXkuaXNBcnJheShlcnJvci5lcnJvci5lcnJvcnMpKSB7XG4gICAgICBub3JtYWxpemVkRXJyb3IuZGV0YWlscyA9IGVycm9yLmVycm9yLmVycm9ycztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlcnJvci5lcnJvci5lcnJvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG5vcm1hbGl6ZWRFcnJvci5kZXRhaWxzID0gW1xuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogZXJyb3IuZXJyb3IuZXJyb3IsXG4gICAgICAgICAgbWVzc2FnZTogZXJyb3IuZXJyb3IuZXJyb3JfZGVzY3JpcHRpb24sXG4gICAgICAgIH0sXG4gICAgICBdO1xuICAgIH1cblxuICAgIHJldHVybiBub3JtYWxpemVkRXJyb3I7XG4gIH1cblxuICBpZiAoaXNEZXZNb2RlKCkpIHtcbiAgICBjb25zb2xlLmVycm9yKFxuICAgICAgJ0Vycm9yIHBhc3NlZCB0byBub3JtYWxpemVIdHRwRXJyb3IgaXMgbm90IEh0dHBFcnJvclJlc3BvbnNlIGluc3RhbmNlJyxcbiAgICAgIGVycm9yXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG4iXX0=