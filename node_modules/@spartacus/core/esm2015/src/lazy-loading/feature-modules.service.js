import { Injectable } from '@angular/core';
import { defer, forkJoin, of, throwError } from 'rxjs';
import { shareReplay, switchMap } from 'rxjs/operators';
import * as i0 from "@angular/core";
import * as i1 from "../cms/config/cms-config";
import * as i2 from "./lazy-modules.service";
export class FeatureModulesService {
    constructor(cmsConfig, lazyModules) {
        this.cmsConfig = cmsConfig;
        this.lazyModules = lazyModules;
        /*
         * Contains resolvers for features.
         * Each resolver runs only once and caches the result.
         */
        this.features = new Map();
    }
    /**
     * Check if feature is configured properly by providing module the shell app
     *
     * @param featureName
     */
    isConfigured(featureName) {
        var _a;
        return !!((_a = this.getFeatureConfig(featureName)) === null || _a === void 0 ? void 0 : _a.module);
    }
    /**
     * Resolve feature based on feature name, if feature was not yet resolved
     *
     * It will first resolve all module dependencies if defined
     */
    resolveFeature(featureName) {
        featureName = this.resolveFeatureAlias(featureName);
        return defer(() => {
            if (!this.features.has(featureName)) {
                if (!this.isConfigured(featureName)) {
                    return throwError(new Error('No module defined for Feature Module ' + featureName));
                }
                const featureConfig = this.getFeatureConfig(featureName);
                this.features.set(featureName, this.resolveDependencies(featureConfig.dependencies).pipe(switchMap((deps) => this.lazyModules.resolveModuleInstance(featureConfig.module, featureName, deps)), shareReplay()));
            }
            return this.features.get(featureName);
        });
    }
    /**
     * Resolve
     * @param featureName
     * @protected
     */
    getFeatureConfig(featureName) {
        var _a;
        return (_a = this.cmsConfig.featureModules) === null || _a === void 0 ? void 0 : _a[this.resolveFeatureAlias(featureName)];
    }
    /**
     * Will return target feature name, resolving optional feature to feature
     * string mapping
     *
     * @param featureName
     * @protected
     */
    resolveFeatureAlias(featureName) {
        var _a, _b;
        while (typeof ((_a = this.cmsConfig.featureModules) === null || _a === void 0 ? void 0 : _a[featureName]) === 'string') {
            featureName = (_b = this.cmsConfig.featureModules) === null || _b === void 0 ? void 0 : _b[featureName];
        }
        return featureName;
    }
    /**
     * Resolve dependency modules for the feature
     *
     * @param dependencies
     * @protected
     */
    resolveDependencies(dependencies = []) {
        return (dependencies === null || dependencies === void 0 ? void 0 : dependencies.length)
            ? forkJoin(dependencies.map((dependency) => {
                if (typeof dependency === 'string') {
                    // dependency is a feature, referenced by a feature name
                    return this.resolveFeature(dependency);
                }
                // resolve dependency from a module function
                return this.lazyModules.resolveDependencyModuleInstance(dependency);
            }))
            : of(undefined);
    }
}
FeatureModulesService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: FeatureModulesService, deps: [{ token: i1.CmsConfig }, { token: i2.LazyModulesService }], target: i0.ɵɵFactoryTarget.Injectable });
FeatureModulesService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: FeatureModulesService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: FeatureModulesService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.CmsConfig }, { type: i2.LazyModulesService }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmVhdHVyZS1tb2R1bGVzLnNlcnZpY2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9jb3JlL3NyYy9sYXp5LWxvYWRpbmcvZmVhdHVyZS1tb2R1bGVzLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFVBQVUsRUFBZSxNQUFNLGVBQWUsQ0FBQztBQUV4RCxPQUFPLEVBQUUsS0FBSyxFQUFFLFFBQVEsRUFBYyxFQUFFLEVBQUUsVUFBVSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQ25FLE9BQU8sRUFBRSxXQUFXLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7Ozs7QUFNeEQsTUFBTSxPQUFPLHFCQUFxQjtJQU9oQyxZQUNZLFNBQW9CLEVBQ3BCLFdBQStCO1FBRC9CLGNBQVMsR0FBVCxTQUFTLENBQVc7UUFDcEIsZ0JBQVcsR0FBWCxXQUFXLENBQW9CO1FBUjNDOzs7V0FHRztRQUNLLGFBQVEsR0FBOEMsSUFBSSxHQUFHLEVBQUUsQ0FBQztJQUtyRSxDQUFDO0lBRUo7Ozs7T0FJRztJQUNILFlBQVksQ0FBQyxXQUFtQjs7UUFDOUIsT0FBTyxDQUFDLENBQUMsQ0FBQSxNQUFBLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxXQUFXLENBQUMsMENBQUUsTUFBTSxDQUFBLENBQUM7SUFDdEQsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxjQUFjLENBQUMsV0FBbUI7UUFDaEMsV0FBVyxHQUFHLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUVwRCxPQUFPLEtBQUssQ0FBQyxHQUFHLEVBQUU7WUFDaEIsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxFQUFFO2dCQUNuQyxJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxXQUFXLENBQUMsRUFBRTtvQkFDbkMsT0FBTyxVQUFVLENBQ2YsSUFBSSxLQUFLLENBQUMsdUNBQXVDLEdBQUcsV0FBVyxDQUFDLENBQ2pFLENBQUM7aUJBQ0g7Z0JBRUQsTUFBTSxhQUFhLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixDQUFDLFdBQVcsQ0FBQyxDQUFDO2dCQUV6RCxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FDZixXQUFXLEVBQ1gsSUFBSSxDQUFDLG1CQUFtQixDQUFDLGFBQWEsQ0FBQyxZQUFZLENBQUMsQ0FBQyxJQUFJLENBQ3ZELFNBQVMsQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFLENBQ2pCLElBQUksQ0FBQyxXQUFXLENBQUMscUJBQXFCLENBQ3BDLGFBQWEsQ0FBQyxNQUFNLEVBQ3BCLFdBQVcsRUFDWCxJQUFJLENBQ0wsQ0FDRixFQUNELFdBQVcsRUFBRSxDQUNkLENBQ0YsQ0FBQzthQUNIO1lBRUQsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUN4QyxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFRDs7OztPQUlHO0lBQ08sZ0JBQWdCLENBQ3hCLFdBQW1COztRQUVuQixPQUFPLE1BQUEsSUFBSSxDQUFDLFNBQVMsQ0FBQyxjQUFjLDBDQUNsQyxJQUFJLENBQUMsbUJBQW1CLENBQUMsV0FBVyxDQUFDLENBQ0gsQ0FBQztJQUN2QyxDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ08sbUJBQW1CLENBQUMsV0FBbUI7O1FBQy9DLE9BQU8sT0FBTyxDQUFBLE1BQUEsSUFBSSxDQUFDLFNBQVMsQ0FBQyxjQUFjLDBDQUFHLFdBQVcsQ0FBQyxDQUFBLEtBQUssUUFBUSxFQUFFO1lBQ3ZFLFdBQVcsR0FBRyxNQUFBLElBQUksQ0FBQyxTQUFTLENBQUMsY0FBYywwQ0FBRyxXQUFXLENBQVcsQ0FBQztTQUN0RTtRQUNELE9BQU8sV0FBVyxDQUFDO0lBQ3JCLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNPLG1CQUFtQixDQUMzQixlQUFzQixFQUFFO1FBRXhCLE9BQU8sQ0FBQSxZQUFZLGFBQVosWUFBWSx1QkFBWixZQUFZLENBQUUsTUFBTTtZQUN6QixDQUFDLENBQUMsUUFBUSxDQUNOLFlBQVksQ0FBQyxHQUFHLENBQUMsQ0FBQyxVQUFVLEVBQUUsRUFBRTtnQkFDOUIsSUFBSSxPQUFPLFVBQVUsS0FBSyxRQUFRLEVBQUU7b0JBQ2xDLHdEQUF3RDtvQkFDeEQsT0FBTyxJQUFJLENBQUMsY0FBYyxDQUFDLFVBQVUsQ0FBQyxDQUFDO2lCQUN4QztnQkFDRCw0Q0FBNEM7Z0JBQzVDLE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQywrQkFBK0IsQ0FBQyxVQUFVLENBQUMsQ0FBQztZQUN0RSxDQUFDLENBQUMsQ0FDSDtZQUNILENBQUMsQ0FBQyxFQUFFLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDcEIsQ0FBQzs7a0hBMUdVLHFCQUFxQjtzSEFBckIscUJBQXFCLGNBRnBCLE1BQU07MkZBRVAscUJBQXFCO2tCQUhqQyxVQUFVO21CQUFDO29CQUNWLFVBQVUsRUFBRSxNQUFNO2lCQUNuQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUsIE5nTW9kdWxlUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBMYXp5TW9kdWxlc1NlcnZpY2UgfSBmcm9tICcuL2xhenktbW9kdWxlcy5zZXJ2aWNlJztcbmltcG9ydCB7IGRlZmVyLCBmb3JrSm9pbiwgT2JzZXJ2YWJsZSwgb2YsIHRocm93RXJyb3IgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IHNoYXJlUmVwbGF5LCBzd2l0Y2hNYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBDbXNDb25maWcsIEZlYXR1cmVNb2R1bGVDb25maWcgfSBmcm9tICcuLi9jbXMvY29uZmlnL2Ntcy1jb25maWcnO1xuXG5ASW5qZWN0YWJsZSh7XG4gIHByb3ZpZGVkSW46ICdyb290Jyxcbn0pXG5leHBvcnQgY2xhc3MgRmVhdHVyZU1vZHVsZXNTZXJ2aWNlIHtcbiAgLypcbiAgICogQ29udGFpbnMgcmVzb2x2ZXJzIGZvciBmZWF0dXJlcy5cbiAgICogRWFjaCByZXNvbHZlciBydW5zIG9ubHkgb25jZSBhbmQgY2FjaGVzIHRoZSByZXN1bHQuXG4gICAqL1xuICBwcml2YXRlIGZlYXR1cmVzOiBNYXA8c3RyaW5nLCBPYnNlcnZhYmxlPE5nTW9kdWxlUmVmPGFueT4+PiA9IG5ldyBNYXAoKTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcm90ZWN0ZWQgY21zQ29uZmlnOiBDbXNDb25maWcsXG4gICAgcHJvdGVjdGVkIGxhenlNb2R1bGVzOiBMYXp5TW9kdWxlc1NlcnZpY2VcbiAgKSB7fVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBmZWF0dXJlIGlzIGNvbmZpZ3VyZWQgcHJvcGVybHkgYnkgcHJvdmlkaW5nIG1vZHVsZSB0aGUgc2hlbGwgYXBwXG4gICAqXG4gICAqIEBwYXJhbSBmZWF0dXJlTmFtZVxuICAgKi9cbiAgaXNDb25maWd1cmVkKGZlYXR1cmVOYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gISF0aGlzLmdldEZlYXR1cmVDb25maWcoZmVhdHVyZU5hbWUpPy5tb2R1bGU7XG4gIH1cblxuICAvKipcbiAgICogUmVzb2x2ZSBmZWF0dXJlIGJhc2VkIG9uIGZlYXR1cmUgbmFtZSwgaWYgZmVhdHVyZSB3YXMgbm90IHlldCByZXNvbHZlZFxuICAgKlxuICAgKiBJdCB3aWxsIGZpcnN0IHJlc29sdmUgYWxsIG1vZHVsZSBkZXBlbmRlbmNpZXMgaWYgZGVmaW5lZFxuICAgKi9cbiAgcmVzb2x2ZUZlYXR1cmUoZmVhdHVyZU5hbWU6IHN0cmluZyk6IE9ic2VydmFibGU8TmdNb2R1bGVSZWY8YW55Pj4ge1xuICAgIGZlYXR1cmVOYW1lID0gdGhpcy5yZXNvbHZlRmVhdHVyZUFsaWFzKGZlYXR1cmVOYW1lKTtcblxuICAgIHJldHVybiBkZWZlcigoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuZmVhdHVyZXMuaGFzKGZlYXR1cmVOYW1lKSkge1xuICAgICAgICBpZiAoIXRoaXMuaXNDb25maWd1cmVkKGZlYXR1cmVOYW1lKSkge1xuICAgICAgICAgIHJldHVybiB0aHJvd0Vycm9yKFxuICAgICAgICAgICAgbmV3IEVycm9yKCdObyBtb2R1bGUgZGVmaW5lZCBmb3IgRmVhdHVyZSBNb2R1bGUgJyArIGZlYXR1cmVOYW1lKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBmZWF0dXJlQ29uZmlnID0gdGhpcy5nZXRGZWF0dXJlQ29uZmlnKGZlYXR1cmVOYW1lKTtcblxuICAgICAgICB0aGlzLmZlYXR1cmVzLnNldChcbiAgICAgICAgICBmZWF0dXJlTmFtZSxcbiAgICAgICAgICB0aGlzLnJlc29sdmVEZXBlbmRlbmNpZXMoZmVhdHVyZUNvbmZpZy5kZXBlbmRlbmNpZXMpLnBpcGUoXG4gICAgICAgICAgICBzd2l0Y2hNYXAoKGRlcHMpID0+XG4gICAgICAgICAgICAgIHRoaXMubGF6eU1vZHVsZXMucmVzb2x2ZU1vZHVsZUluc3RhbmNlKFxuICAgICAgICAgICAgICAgIGZlYXR1cmVDb25maWcubW9kdWxlLFxuICAgICAgICAgICAgICAgIGZlYXR1cmVOYW1lLFxuICAgICAgICAgICAgICAgIGRlcHNcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIHNoYXJlUmVwbGF5KClcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmZlYXR1cmVzLmdldChmZWF0dXJlTmFtZSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVzb2x2ZVxuICAgKiBAcGFyYW0gZmVhdHVyZU5hbWVcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgcHJvdGVjdGVkIGdldEZlYXR1cmVDb25maWcoXG4gICAgZmVhdHVyZU5hbWU6IHN0cmluZ1xuICApOiBGZWF0dXJlTW9kdWxlQ29uZmlnIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5jbXNDb25maWcuZmVhdHVyZU1vZHVsZXM/LltcbiAgICAgIHRoaXMucmVzb2x2ZUZlYXR1cmVBbGlhcyhmZWF0dXJlTmFtZSlcbiAgICBdIGFzIEZlYXR1cmVNb2R1bGVDb25maWcgfCB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogV2lsbCByZXR1cm4gdGFyZ2V0IGZlYXR1cmUgbmFtZSwgcmVzb2x2aW5nIG9wdGlvbmFsIGZlYXR1cmUgdG8gZmVhdHVyZVxuICAgKiBzdHJpbmcgbWFwcGluZ1xuICAgKlxuICAgKiBAcGFyYW0gZmVhdHVyZU5hbWVcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgcHJvdGVjdGVkIHJlc29sdmVGZWF0dXJlQWxpYXMoZmVhdHVyZU5hbWU6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgd2hpbGUgKHR5cGVvZiB0aGlzLmNtc0NvbmZpZy5mZWF0dXJlTW9kdWxlcz8uW2ZlYXR1cmVOYW1lXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGZlYXR1cmVOYW1lID0gdGhpcy5jbXNDb25maWcuZmVhdHVyZU1vZHVsZXM/LltmZWF0dXJlTmFtZV0gYXMgc3RyaW5nO1xuICAgIH1cbiAgICByZXR1cm4gZmVhdHVyZU5hbWU7XG4gIH1cblxuICAvKipcbiAgICogUmVzb2x2ZSBkZXBlbmRlbmN5IG1vZHVsZXMgZm9yIHRoZSBmZWF0dXJlXG4gICAqXG4gICAqIEBwYXJhbSBkZXBlbmRlbmNpZXNcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgcHJvdGVjdGVkIHJlc29sdmVEZXBlbmRlbmNpZXMoXG4gICAgZGVwZW5kZW5jaWVzOiBhbnlbXSA9IFtdXG4gICk6IE9ic2VydmFibGU8TmdNb2R1bGVSZWY8YW55PltdIHwgdW5kZWZpbmVkPiB7XG4gICAgcmV0dXJuIGRlcGVuZGVuY2llcz8ubGVuZ3RoXG4gICAgICA/IGZvcmtKb2luKFxuICAgICAgICAgIGRlcGVuZGVuY2llcy5tYXAoKGRlcGVuZGVuY3kpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGVwZW5kZW5jeSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgLy8gZGVwZW5kZW5jeSBpcyBhIGZlYXR1cmUsIHJlZmVyZW5jZWQgYnkgYSBmZWF0dXJlIG5hbWVcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZUZlYXR1cmUoZGVwZW5kZW5jeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByZXNvbHZlIGRlcGVuZGVuY3kgZnJvbSBhIG1vZHVsZSBmdW5jdGlvblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGF6eU1vZHVsZXMucmVzb2x2ZURlcGVuZGVuY3lNb2R1bGVJbnN0YW5jZShkZXBlbmRlbmN5KTtcbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICA6IG9mKHVuZGVmaW5lZCk7XG4gIH1cbn1cbiJdfQ==