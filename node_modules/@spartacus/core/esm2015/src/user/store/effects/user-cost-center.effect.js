import { __decorate } from "tslib";
import { Injectable } from '@angular/core';
import { Effect, ofType } from '@ngrx/effects';
import { of } from 'rxjs';
import { catchError, map, switchMap } from 'rxjs/operators';
import { normalizeHttpError } from '../../../util/normalize-http-error';
import { UserActions } from '../actions/index';
import * as i0 from "@angular/core";
import * as i1 from "@ngrx/effects";
import * as i2 from "../../connectors/cost-center/user-cost-center.connector";
export class UserCostCenterEffects {
    constructor(actions$, userCostCenterConnector) {
        this.actions$ = actions$;
        this.userCostCenterConnector = userCostCenterConnector;
        this.loadActiveCostCenters$ = this.actions$.pipe(ofType(UserActions.LOAD_ACTIVE_COST_CENTERS), map((action) => action.payload), switchMap((payload) => this.userCostCenterConnector.getActiveList(payload).pipe(
        // TODO(#8875): Should we use here serialize utils?
        map((data) => new UserActions.LoadActiveCostCentersSuccess(data.values)), catchError((error) => of(new UserActions.LoadActiveCostCentersFail(normalizeHttpError(error)))))));
    }
}
UserCostCenterEffects.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: UserCostCenterEffects, deps: [{ token: i1.Actions }, { token: i2.UserCostCenterConnector }], target: i0.ɵɵFactoryTarget.Injectable });
UserCostCenterEffects.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: UserCostCenterEffects });
__decorate([
    Effect()
], UserCostCenterEffects.prototype, "loadActiveCostCenters$", void 0);
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: UserCostCenterEffects, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.Actions }, { type: i2.UserCostCenterConnector }]; }, propDecorators: { loadActiveCostCenters$: [] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXNlci1jb3N0LWNlbnRlci5lZmZlY3QuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9jb3JlL3NyYy91c2VyL3N0b3JlL2VmZmVjdHMvdXNlci1jb3N0LWNlbnRlci5lZmZlY3QudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDM0MsT0FBTyxFQUFXLE1BQU0sRUFBRSxNQUFNLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDeEQsT0FBTyxFQUFjLEVBQUUsRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUN0QyxPQUFPLEVBQUUsVUFBVSxFQUFFLEdBQUcsRUFBRSxTQUFTLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUc1RCxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSxvQ0FBb0MsQ0FBQztBQUV4RSxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sa0JBQWtCLENBQUM7Ozs7QUFHL0MsTUFBTSxPQUFPLHFCQUFxQjtJQXFCaEMsWUFDVSxRQUFpQixFQUNqQix1QkFBZ0Q7UUFEaEQsYUFBUSxHQUFSLFFBQVEsQ0FBUztRQUNqQiw0QkFBdUIsR0FBdkIsdUJBQXVCLENBQXlCO1FBckIxRCwyQkFBc0IsR0FBaUQsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQ3ZGLE1BQU0sQ0FBQyxXQUFXLENBQUMsd0JBQXdCLENBQUMsRUFDNUMsR0FBRyxDQUFDLENBQUMsTUFBeUMsRUFBRSxFQUFFLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxFQUNsRSxTQUFTLENBQUMsQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUNwQixJQUFJLENBQUMsdUJBQXVCLENBQUMsYUFBYSxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUk7UUFDdEQsbURBQW1EO1FBQ25ELEdBQUcsQ0FDRCxDQUFDLElBQStCLEVBQUUsRUFBRSxDQUNsQyxJQUFJLFdBQVcsQ0FBQyw0QkFBNEIsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQzVELEVBQ0QsVUFBVSxDQUFDLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FDbkIsRUFBRSxDQUNBLElBQUksV0FBVyxDQUFDLHlCQUF5QixDQUFDLGtCQUFrQixDQUFDLEtBQUssQ0FBQyxDQUFDLENBQ3JFLENBQ0YsQ0FDRixDQUNGLENBQ0YsQ0FBQztJQUtDLENBQUM7O2tIQXhCTyxxQkFBcUI7c0hBQXJCLHFCQUFxQjtBQUVoQztJQURDLE1BQU0sRUFBRTtxRUFrQlA7MkZBbkJTLHFCQUFxQjtrQkFEakMsVUFBVTtvSUFHVCxzQkFBc0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBBY3Rpb25zLCBFZmZlY3QsIG9mVHlwZSB9IGZyb20gJ0BuZ3J4L2VmZmVjdHMnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgb2YgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGNhdGNoRXJyb3IsIG1hcCwgc3dpdGNoTWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgRW50aXRpZXNNb2RlbCB9IGZyb20gJy4uLy4uLy4uL21vZGVsL21pc2MubW9kZWwnO1xuaW1wb3J0IHsgQ29zdENlbnRlciB9IGZyb20gJy4uLy4uLy4uL21vZGVsL29yZy11bml0Lm1vZGVsJztcbmltcG9ydCB7IG5vcm1hbGl6ZUh0dHBFcnJvciB9IGZyb20gJy4uLy4uLy4uL3V0aWwvbm9ybWFsaXplLWh0dHAtZXJyb3InO1xuaW1wb3J0IHsgVXNlckNvc3RDZW50ZXJDb25uZWN0b3IgfSBmcm9tICcuLi8uLi9jb25uZWN0b3JzL2Nvc3QtY2VudGVyL3VzZXItY29zdC1jZW50ZXIuY29ubmVjdG9yJztcbmltcG9ydCB7IFVzZXJBY3Rpb25zIH0gZnJvbSAnLi4vYWN0aW9ucy9pbmRleCc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBVc2VyQ29zdENlbnRlckVmZmVjdHMge1xuICBARWZmZWN0KClcbiAgbG9hZEFjdGl2ZUNvc3RDZW50ZXJzJDogT2JzZXJ2YWJsZTxVc2VyQWN0aW9ucy5Vc2VyQ29zdENlbnRlckFjdGlvbj4gPSB0aGlzLmFjdGlvbnMkLnBpcGUoXG4gICAgb2ZUeXBlKFVzZXJBY3Rpb25zLkxPQURfQUNUSVZFX0NPU1RfQ0VOVEVSUyksXG4gICAgbWFwKChhY3Rpb246IFVzZXJBY3Rpb25zLkxvYWRBY3RpdmVDb3N0Q2VudGVycykgPT4gYWN0aW9uLnBheWxvYWQpLFxuICAgIHN3aXRjaE1hcCgocGF5bG9hZCkgPT5cbiAgICAgIHRoaXMudXNlckNvc3RDZW50ZXJDb25uZWN0b3IuZ2V0QWN0aXZlTGlzdChwYXlsb2FkKS5waXBlKFxuICAgICAgICAvLyBUT0RPKCM4ODc1KTogU2hvdWxkIHdlIHVzZSBoZXJlIHNlcmlhbGl6ZSB1dGlscz9cbiAgICAgICAgbWFwKFxuICAgICAgICAgIChkYXRhOiBFbnRpdGllc01vZGVsPENvc3RDZW50ZXI+KSA9PlxuICAgICAgICAgICAgbmV3IFVzZXJBY3Rpb25zLkxvYWRBY3RpdmVDb3N0Q2VudGVyc1N1Y2Nlc3MoZGF0YS52YWx1ZXMpXG4gICAgICAgICksXG4gICAgICAgIGNhdGNoRXJyb3IoKGVycm9yKSA9PlxuICAgICAgICAgIG9mKFxuICAgICAgICAgICAgbmV3IFVzZXJBY3Rpb25zLkxvYWRBY3RpdmVDb3N0Q2VudGVyc0ZhaWwobm9ybWFsaXplSHR0cEVycm9yKGVycm9yKSlcbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgIClcbiAgICApXG4gICk7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBhY3Rpb25zJDogQWN0aW9ucyxcbiAgICBwcml2YXRlIHVzZXJDb3N0Q2VudGVyQ29ubmVjdG9yOiBVc2VyQ29zdENlbnRlckNvbm5lY3RvclxuICApIHt9XG59XG4iXX0=