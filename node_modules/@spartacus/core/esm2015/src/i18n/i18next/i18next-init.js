import { Injectable } from '@angular/core';
import i18nextHttpBackend from 'i18next-http-backend';
import { tap } from 'rxjs/operators';
import * as i0 from "@angular/core";
export function i18nextInit(i18next, configInit, languageService, httpClient, serverRequestOrigin, siteContextI18nextSynchronizer) {
    return () => configInit
        .getStable('i18n')
        .pipe(tap((config) => {
        var _a, _b, _c, _d;
        let i18nextConfig = {
            ns: [],
            fallbackLng: (_a = config.i18n) === null || _a === void 0 ? void 0 : _a.fallbackLang,
            debug: (_b = config.i18n) === null || _b === void 0 ? void 0 : _b.debug,
            interpolation: {
                escapeValue: false,
            },
        };
        if ((_d = (_c = config.i18n) === null || _c === void 0 ? void 0 : _c.backend) === null || _d === void 0 ? void 0 : _d.loadPath) {
            i18next = i18next.use(i18nextHttpBackend);
            const loadPath = getLoadPath(config.i18n.backend.loadPath, serverRequestOrigin);
            const backend = {
                loadPath,
                request: i18nextGetHttpClient(httpClient),
                // Disable the periodical reloading. Otherwise SSR would not finish due to the pending task `setInterval()`
                // See source code of `i18next-http-backend` : https://github.com/i18next/i18next-http-backend/blob/00b7e8f67abf8372af17529b51190a7e8b17e3d8/lib/index.js#L40-L41
                reloadInterval: false,
            };
            i18nextConfig = Object.assign(Object.assign({}, i18nextConfig), { backend });
        }
        return i18next.init(i18nextConfig, () => {
            var _a;
            // Don't use i18next's 'resources' config key for adding static translations,
            // because it will disable loading chunks from backend. We add resources here, in the init's callback.
            i18nextAddTranslations(i18next, (_a = config.i18n) === null || _a === void 0 ? void 0 : _a.resources);
            siteContextI18nextSynchronizer.init(i18next, languageService);
        });
    }))
        .toPromise();
}
export function i18nextAddTranslations(i18next, resources = {}) {
    Object.keys(resources).forEach((lang) => {
        Object.keys(resources[lang]).forEach((chunkName) => {
            i18next.addResourceBundle(lang, chunkName, resources[lang][chunkName], true, true);
        });
    });
}
export class SiteContextI18nextSynchronizer {
    init(i18next, language) {
        var _a;
        // always update language of i18next on site context (language) change
        this.sub =
            (_a = this.sub) !== null && _a !== void 0 ? _a : language.getActive().subscribe((lang) => i18next.changeLanguage(lang));
    }
    ngOnDestroy() {
        var _a;
        (_a = this.sub) === null || _a === void 0 ? void 0 : _a.unsubscribe();
    }
}
SiteContextI18nextSynchronizer.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SiteContextI18nextSynchronizer, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
SiteContextI18nextSynchronizer.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SiteContextI18nextSynchronizer, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: SiteContextI18nextSynchronizer, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }] });
/**
 * Returns a function appropriate for i18next to make http calls for JSON files.
 * See docs for `i18next-http-backend`: https://github.com/i18next/i18next-http-backend#backend-options
 *
 * It uses Angular HttpClient under the hood, so it works in SSR.
 * @param httpClient Angular http client
 */
export function i18nextGetHttpClient(httpClient) {
    return (_options, url, _payload, callback) => {
        httpClient.get(url, { responseType: 'text' }).subscribe((data) => callback(null, { status: 200, data }), (error) => callback(error, {
            // a workaround for https://github.com/i18next/i18next-http-backend/issues/82
            data: null,
            status: error.status,
        }));
    };
}
/**
 * Resolves the relative path to the absolute one in SSR, using the server request's origin.
 * It's needed, because Angular Universal doesn't support relative URLs in HttpClient. See Angular issues:
 * - https://github.com/angular/angular/issues/19224
 * - https://github.com/angular/universal/issues/858
 */
export function getLoadPath(path, serverRequestOrigin) {
    if (serverRequestOrigin && !path.match(/^http(s)?:\/\//)) {
        if (path.startsWith('/')) {
            path = path.slice(1);
        }
        if (path.startsWith('./')) {
            path = path.slice(2);
        }
        const result = `${serverRequestOrigin}/${path}`;
        return result;
    }
    return path;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaTE4bmV4dC1pbml0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvY29yZS9zcmMvaTE4bi9pMThuZXh0L2kxOG5leHQtaW5pdC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFDQSxPQUFPLEVBQUUsVUFBVSxFQUFhLE1BQU0sZUFBZSxDQUFDO0FBRXRELE9BQU8sa0JBR04sTUFBTSxzQkFBc0IsQ0FBQztBQUU5QixPQUFPLEVBQUUsR0FBRyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7O0FBS3JDLE1BQU0sVUFBVSxXQUFXLENBQ3pCLE9BQWEsRUFDYixVQUFvQyxFQUNwQyxlQUFnQyxFQUNoQyxVQUFzQixFQUN0QixtQkFBa0MsRUFDbEMsOEJBQThEO0lBRTlELE9BQU8sR0FBRyxFQUFFLENBQ1YsVUFBVTtTQUNQLFNBQVMsQ0FBQyxNQUFNLENBQUM7U0FDakIsSUFBSSxDQUNILEdBQUcsQ0FBQyxDQUFDLE1BQU0sRUFBRSxFQUFFOztRQUNiLElBQUksYUFBYSxHQUFnQjtZQUMvQixFQUFFLEVBQUUsRUFBRTtZQUNOLFdBQVcsRUFBRSxNQUFBLE1BQU0sQ0FBQyxJQUFJLDBDQUFFLFlBQVk7WUFDdEMsS0FBSyxFQUFFLE1BQUEsTUFBTSxDQUFDLElBQUksMENBQUUsS0FBSztZQUN6QixhQUFhLEVBQUU7Z0JBQ2IsV0FBVyxFQUFFLEtBQUs7YUFDbkI7U0FDRixDQUFDO1FBRUYsSUFBSSxNQUFBLE1BQUEsTUFBTSxDQUFDLElBQUksMENBQUUsT0FBTywwQ0FBRSxRQUFRLEVBQUU7WUFDbEMsT0FBTyxHQUFHLE9BQU8sQ0FBQyxHQUFHLENBQUMsa0JBQWtCLENBQUMsQ0FBQztZQUMxQyxNQUFNLFFBQVEsR0FBRyxXQUFXLENBQzFCLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLFFBQVEsRUFDNUIsbUJBQW1CLENBQ3BCLENBQUM7WUFDRixNQUFNLE9BQU8sR0FBbUI7Z0JBQzlCLFFBQVE7Z0JB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SUFBSSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDdEI7UUFDRCxJQUFJLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDekIsSUFBSSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDdEI7UUFDRCxNQUFNLE1BQU0sR0FBRyxHQUFHLG1CQUFtQixJQUFJLElBQUksRUFBRSxDQUFDO1FBQ2hELE9BQU8sTUFBTSxDQUFDO0tBQ2Y7SUFDRCxPQUFPLElBQUksQ0FBQztBQUNkLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBIdHRwQ2xpZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uL2h0dHAnO1xuaW1wb3J0IHsgSW5qZWN0YWJsZSwgT25EZXN0cm95IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBpMThuLCBJbml0T3B0aW9ucyB9IGZyb20gJ2kxOG5leHQnO1xuaW1wb3J0IGkxOG5leHRIdHRwQmFja2VuZCwge1xuICBCYWNrZW5kT3B0aW9ucyxcbiAgUmVxdWVzdENhbGxiYWNrLFxufSBmcm9tICdpMThuZXh0LWh0dHAtYmFja2VuZCc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IHRhcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IENvbmZpZ0luaXRpYWxpemVyU2VydmljZSB9IGZyb20gJy4uLy4uL2NvbmZpZy9jb25maWctaW5pdGlhbGl6ZXIvY29uZmlnLWluaXRpYWxpemVyLnNlcnZpY2UnO1xuaW1wb3J0IHsgTGFuZ3VhZ2VTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2l0ZS1jb250ZXh0L2ZhY2FkZS9sYW5ndWFnZS5zZXJ2aWNlJztcbmltcG9ydCB7IFRyYW5zbGF0aW9uUmVzb3VyY2VzIH0gZnJvbSAnLi4vdHJhbnNsYXRpb24tcmVzb3VyY2VzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGkxOG5leHRJbml0KFxuICBpMThuZXh0OiBpMThuLFxuICBjb25maWdJbml0OiBDb25maWdJbml0aWFsaXplclNlcnZpY2UsXG4gIGxhbmd1YWdlU2VydmljZTogTGFuZ3VhZ2VTZXJ2aWNlLFxuICBodHRwQ2xpZW50OiBIdHRwQ2xpZW50LFxuICBzZXJ2ZXJSZXF1ZXN0T3JpZ2luOiBzdHJpbmcgfCBudWxsLFxuICBzaXRlQ29udGV4dEkxOG5leHRTeW5jaHJvbml6ZXI6IFNpdGVDb250ZXh0STE4bmV4dFN5bmNocm9uaXplclxuKTogKCkgPT4gUHJvbWlzZTxhbnk+IHtcbiAgcmV0dXJuICgpID0+XG4gICAgY29uZmlnSW5pdFxuICAgICAgLmdldFN0YWJsZSgnaTE4bicpXG4gICAgICAucGlwZShcbiAgICAgICAgdGFwKChjb25maWcpID0+IHtcbiAgICAgICAgICBsZXQgaTE4bmV4dENvbmZpZzogSW5pdE9wdGlvbnMgPSB7XG4gICAgICAgICAgICBuczogW10sIC8vIGRvbid0IHByZWxvYWQgYW55IG5hbWVzcGFjZXNcbiAgICAgICAgICAgIGZhbGxiYWNrTG5nOiBjb25maWcuaTE4bj8uZmFsbGJhY2tMYW5nLFxuICAgICAgICAgICAgZGVidWc6IGNvbmZpZy5pMThuPy5kZWJ1ZyxcbiAgICAgICAgICAgIGludGVycG9sYXRpb246IHtcbiAgICAgICAgICAgICAgZXNjYXBlVmFsdWU6IGZhbHNlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKGNvbmZpZy5pMThuPy5iYWNrZW5kPy5sb2FkUGF0aCkge1xuICAgICAgICAgICAgaTE4bmV4dCA9IGkxOG5leHQudXNlKGkxOG5leHRIdHRwQmFja2VuZCk7XG4gICAgICAgICAgICBjb25zdCBsb2FkUGF0aCA9IGdldExvYWRQYXRoKFxuICAgICAgICAgICAgICBjb25maWcuaTE4bi5iYWNrZW5kLmxvYWRQYXRoLFxuICAgICAgICAgICAgICBzZXJ2ZXJSZXF1ZXN0T3JpZ2luXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29uc3QgYmFja2VuZDogQmFja2VuZE9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgIGxvYWRQYXRoLFxuICAgICAgICAgICAgICByZXF1ZXN0OiBpMThuZXh0R2V0SHR0cENsaWVudChodHRwQ2xpZW50KSxcblxuICAgICAgICAgICAgICAvLyBEaXNhYmxlIHRoZSBwZXJpb2RpY2FsIHJlbG9hZGluZy4gT3RoZXJ3aXNlIFNTUiB3b3VsZCBub3QgZmluaXNoIGR1ZSB0byB0aGUgcGVuZGluZyB0YXNrIGBzZXRJbnRlcnZhbCgpYFxuICAgICAgICAgICAgICAvLyBTZWUgc291cmNlIGNvZGUgb2YgYGkxOG5leHQtaHR0cC1iYWNrZW5kYCA6IGh0dHBzOi8vZ2l0aHViLmNvbS9pMThuZXh0L2kxOG5leHQtaHR0cC1iYWNrZW5kL2Jsb2IvMDBiN2U4ZjY3YWJmODM3MmFmMTc1MjliNTExOTBhN2U4YjE3ZTNkOC9saWIvaW5kZXguanMjTDQwLUw0MVxuICAgICAgICAgICAgICByZWxvYWRJbnRlcnZhbDogZmFsc2UsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaTE4bmV4dENvbmZpZyA9IHsgLi4uaTE4bmV4dENvbmZpZywgYmFja2VuZCB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBpMThuZXh0LmluaXQoaTE4bmV4dENvbmZpZywgKCkgPT4ge1xuICAgICAgICAgICAgLy8gRG9uJ3QgdXNlIGkxOG5leHQncyAncmVzb3VyY2VzJyBjb25maWcga2V5IGZvciBhZGRpbmcgc3RhdGljIHRyYW5zbGF0aW9ucyxcbiAgICAgICAgICAgIC8vIGJlY2F1c2UgaXQgd2lsbCBkaXNhYmxlIGxvYWRpbmcgY2h1bmtzIGZyb20gYmFja2VuZC4gV2UgYWRkIHJlc291cmNlcyBoZXJlLCBpbiB0aGUgaW5pdCdzIGNhbGxiYWNrLlxuICAgICAgICAgICAgaTE4bmV4dEFkZFRyYW5zbGF0aW9ucyhpMThuZXh0LCBjb25maWcuaTE4bj8ucmVzb3VyY2VzKTtcbiAgICAgICAgICAgIHNpdGVDb250ZXh0STE4bmV4dFN5bmNocm9uaXplci5pbml0KGkxOG5leHQsIGxhbmd1YWdlU2VydmljZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pXG4gICAgICApXG4gICAgICAudG9Qcm9taXNlKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpMThuZXh0QWRkVHJhbnNsYXRpb25zKFxuICBpMThuZXh0OiBpMThuLFxuICByZXNvdXJjZXM6IFRyYW5zbGF0aW9uUmVzb3VyY2VzID0ge31cbik6IHZvaWQge1xuICBPYmplY3Qua2V5cyhyZXNvdXJjZXMpLmZvckVhY2goKGxhbmcpID0+IHtcbiAgICBPYmplY3Qua2V5cyhyZXNvdXJjZXNbbGFuZ10pLmZvckVhY2goKGNodW5rTmFtZSkgPT4ge1xuICAgICAgaTE4bmV4dC5hZGRSZXNvdXJjZUJ1bmRsZShcbiAgICAgICAgbGFuZyxcbiAgICAgICAgY2h1bmtOYW1lLFxuICAgICAgICByZXNvdXJjZXNbbGFuZ11bY2h1bmtOYW1lXSxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgdHJ1ZVxuICAgICAgKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbkBJbmplY3RhYmxlKHsgcHJvdmlkZWRJbjogJ3Jvb3QnIH0pXG5leHBvcnQgY2xhc3MgU2l0ZUNvbnRleHRJMThuZXh0U3luY2hyb25pemVyIGltcGxlbWVudHMgT25EZXN0cm95IHtcbiAgc3ViOiBTdWJzY3JpcHRpb247XG5cbiAgaW5pdChpMThuZXh0OiBpMThuLCBsYW5ndWFnZTogTGFuZ3VhZ2VTZXJ2aWNlKSB7XG4gICAgLy8gYWx3YXlzIHVwZGF0ZSBsYW5ndWFnZSBvZiBpMThuZXh0IG9uIHNpdGUgY29udGV4dCAobGFuZ3VhZ2UpIGNoYW5nZVxuICAgIHRoaXMuc3ViID1cbiAgICAgIHRoaXMuc3ViID8/XG4gICAgICBsYW5ndWFnZS5nZXRBY3RpdmUoKS5zdWJzY3JpYmUoKGxhbmcpID0+IGkxOG5leHQuY2hhbmdlTGFuZ3VhZ2UobGFuZykpO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5zdWI/LnVuc3Vic2NyaWJlKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gYXBwcm9wcmlhdGUgZm9yIGkxOG5leHQgdG8gbWFrZSBodHRwIGNhbGxzIGZvciBKU09OIGZpbGVzLlxuICogU2VlIGRvY3MgZm9yIGBpMThuZXh0LWh0dHAtYmFja2VuZGA6IGh0dHBzOi8vZ2l0aHViLmNvbS9pMThuZXh0L2kxOG5leHQtaHR0cC1iYWNrZW5kI2JhY2tlbmQtb3B0aW9uc1xuICpcbiAqIEl0IHVzZXMgQW5ndWxhciBIdHRwQ2xpZW50IHVuZGVyIHRoZSBob29kLCBzbyBpdCB3b3JrcyBpbiBTU1IuXG4gKiBAcGFyYW0gaHR0cENsaWVudCBBbmd1bGFyIGh0dHAgY2xpZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpMThuZXh0R2V0SHR0cENsaWVudChcbiAgaHR0cENsaWVudDogSHR0cENsaWVudFxuKTogKFxuICBvcHRpb25zOiBCYWNrZW5kT3B0aW9ucyxcbiAgdXJsOiBzdHJpbmcsXG4gIHBheWxvYWQ6IG9iamVjdCB8IHN0cmluZyxcbiAgY2FsbGJhY2s6IFJlcXVlc3RDYWxsYmFja1xuKSA9PiB2b2lkIHtcbiAgcmV0dXJuIChcbiAgICBfb3B0aW9uczogQmFja2VuZE9wdGlvbnMsXG4gICAgdXJsOiBzdHJpbmcsXG4gICAgX3BheWxvYWQ6IG9iamVjdCB8IHN0cmluZyxcbiAgICBjYWxsYmFjazogUmVxdWVzdENhbGxiYWNrXG4gICkgPT4ge1xuICAgIGh0dHBDbGllbnQuZ2V0KHVybCwgeyByZXNwb25zZVR5cGU6ICd0ZXh0JyB9KS5zdWJzY3JpYmUoXG4gICAgICAoZGF0YSkgPT4gY2FsbGJhY2sobnVsbCwgeyBzdGF0dXM6IDIwMCwgZGF0YSB9KSxcbiAgICAgIChlcnJvcikgPT5cbiAgICAgICAgY2FsbGJhY2soZXJyb3IsIHtcbiAgICAgICAgICAvLyBhIHdvcmthcm91bmQgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9pMThuZXh0L2kxOG5leHQtaHR0cC1iYWNrZW5kL2lzc3Vlcy84MlxuICAgICAgICAgIGRhdGE6IG51bGwgYXMgYW55LFxuICAgICAgICAgIHN0YXR1czogZXJyb3Iuc3RhdHVzLFxuICAgICAgICB9KVxuICAgICk7XG4gIH07XG59XG5cbi8qKlxuICogUmVzb2x2ZXMgdGhlIHJlbGF0aXZlIHBhdGggdG8gdGhlIGFic29sdXRlIG9uZSBpbiBTU1IsIHVzaW5nIHRoZSBzZXJ2ZXIgcmVxdWVzdCdzIG9yaWdpbi5cbiAqIEl0J3MgbmVlZGVkLCBiZWNhdXNlIEFuZ3VsYXIgVW5pdmVyc2FsIGRvZXNuJ3Qgc3VwcG9ydCByZWxhdGl2ZSBVUkxzIGluIEh0dHBDbGllbnQuIFNlZSBBbmd1bGFyIGlzc3VlczpcbiAqIC0gaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvMTkyMjRcbiAqIC0gaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvdW5pdmVyc2FsL2lzc3Vlcy84NThcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldExvYWRQYXRoKFxuICBwYXRoOiBzdHJpbmcsXG4gIHNlcnZlclJlcXVlc3RPcmlnaW46IHN0cmluZyB8IG51bGxcbik6IHN0cmluZyB7XG4gIGlmIChzZXJ2ZXJSZXF1ZXN0T3JpZ2luICYmICFwYXRoLm1hdGNoKC9eaHR0cChzKT86XFwvXFwvLykpIHtcbiAgICBpZiAocGF0aC5zdGFydHNXaXRoKCcvJykpIHtcbiAgICAgIHBhdGggPSBwYXRoLnNsaWNlKDEpO1xuICAgIH1cbiAgICBpZiAocGF0aC5zdGFydHNXaXRoKCcuLycpKSB7XG4gICAgICBwYXRoID0gcGF0aC5zbGljZSgyKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gYCR7c2VydmVyUmVxdWVzdE9yaWdpbn0vJHtwYXRofWA7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICByZXR1cm4gcGF0aDtcbn1cbiJdfQ==