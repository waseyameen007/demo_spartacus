(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@ngrx/store'), require('rxjs'), require('rxjs/operators'), require('angular-oauth2-oidc'), require('@angular/common'), require('@angular/router'), require('@angular/common/http'), require('@ngrx/effects'), require('@angular/platform-browser'), require('@ngrx/router-store'), require('i18next-http-backend'), require('i18next')) :
    typeof define === 'function' && define.amd ? define('@spartacus/core', ['exports', '@angular/core', '@ngrx/store', 'rxjs', 'rxjs/operators', 'angular-oauth2-oidc', '@angular/common', '@angular/router', '@angular/common/http', '@ngrx/effects', '@angular/platform-browser', '@ngrx/router-store', 'i18next-http-backend', 'i18next'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.spartacus = global.spartacus || {}, global.spartacus.core = {}), global.ng.core, global.store, global.rxjs, global.rxjs.operators, global.angularOAuth2Oidc, global.ng.common, global.ng.router, global.ng.common.http, global.effects, global.ng.platformBrowser, global.fromNgrxRouter, global.i18nextHttpBackend, global.i18next));
}(this, (function (exports, i0, i1, rxjs, operators, i1$1, i6, i1$2, i1$3, i1$4, platformBrowser, fromNgrxRouter, i18nextHttpBackend, i18next) { 'use strict';

    function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

    function _interopNamespace(e) {
        if (e && e.__esModule) return e;
        var n = Object.create(null);
        if (e) {
            Object.keys(e).forEach(function (k) {
                if (k !== 'default') {
                    var d = Object.getOwnPropertyDescriptor(e, k);
                    Object.defineProperty(n, k, d.get ? d : {
                        enumerable: true,
                        get: function () {
                            return e[k];
                        }
                    });
                }
            });
        }
        n['default'] = e;
        return Object.freeze(n);
    }

    var i0__namespace = /*#__PURE__*/_interopNamespace(i0);
    var i1__namespace$2 = /*#__PURE__*/_interopNamespace(i1);
    var i1__namespace = /*#__PURE__*/_interopNamespace(i1$1);
    var i6__namespace = /*#__PURE__*/_interopNamespace(i6);
    var i1__namespace$1 = /*#__PURE__*/_interopNamespace(i1$2);
    var i1__namespace$3 = /*#__PURE__*/_interopNamespace(i1$3);
    var i1__namespace$4 = /*#__PURE__*/_interopNamespace(i1$4);
    var fromNgrxRouter__namespace = /*#__PURE__*/_interopNamespace(fromNgrxRouter);
    var i18nextHttpBackend__default = /*#__PURE__*/_interopDefaultLegacy(i18nextHttpBackend);
    var i18next__default = /*#__PURE__*/_interopDefaultLegacy(i18next);

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (Object.prototype.hasOwnProperty.call(b, p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
        var t = {};
        for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); };
    }
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
    }
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    var __createBinding = Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    });
    function __exportStar(m, o) {
        for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
                __createBinding(o, m, p);
    }
    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
            return m.call(o);
        if (o && typeof o.length === "number")
            return {
                next: function () {
                    if (o && i >= o.length)
                        o = void 0;
                    return { value: o && o[i++], done: !o };
                }
            };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    /** @deprecated */
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }
    /** @deprecated */
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    function __spreadArray(to, from, pack) {
        if (pack || arguments.length === 2)
            for (var i = 0, l = from.length, ar; i < l; i++) {
                if (ar || !(i in from)) {
                    if (!ar)
                        ar = Array.prototype.slice.call(from, 0, i);
                    ar[i] = from[i];
                }
            }
        return to.concat(ar || from);
    }
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n])
            i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try {
            step(g[n](v));
        }
        catch (e) {
            settle(q[0][3], e);
        } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]); }
    }
    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }
    function __asyncValues(o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    }
    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
        }
        else {
            cooked.raw = raw;
        }
        return cooked;
    }
    ;
    var __setModuleDefault = Object.create ? (function (o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function (o, v) {
        o["default"] = v;
    };
    function __importStar(mod) {
        if (mod && mod.__esModule)
            return mod;
        var result = {};
        if (mod != null)
            for (var k in mod)
                if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                    __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    }
    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }
    function __classPrivateFieldGet(receiver, state, kind, f) {
        if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    }
    function __classPrivateFieldSet(receiver, state, value, kind, f) {
        if (kind === "m")
            throw new TypeError("Private method is not writable");
        if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    }

    function isObject(item) {
        return item && typeof item === 'object' && !Array.isArray(item);
    }
    function deepMerge(target) {
        if (target === void 0) { target = {}; }
        var sources = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            sources[_i - 1] = arguments[_i];
        }
        if (!sources.length) {
            return target;
        }
        var source = sources.shift() || {};
        if (isObject(source)) {
            for (var key in source) {
                if (source[key] instanceof Date) {
                    target[key] = source[key];
                }
                else if (isObject(source[key])) {
                    if (!target[key] || !isObject(target[key])) {
                        target[key] = {};
                    }
                    deepMerge(target[key], source[key]);
                }
                else {
                    target[key] = source[key];
                }
            }
        }
        return deepMerge.apply(void 0, __spreadArray([target], __read(sources)));
    }

    function configFactory() {
        return deepMerge({}, i0.inject(DefaultConfig), i0.inject(RootConfig));
    }
    /**
     * Global Configuration, can be used to inject configuration to any part of the app
     */
    var Config = /** @class */ (function () {
        function Config() {
        }
        return Config;
    }());
    Config.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: Config, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    Config.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: Config, providedIn: 'root', useFactory: configFactory });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: Config, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                        useFactory: configFactory,
                    }]
            }] });
    function defaultConfigFactory() {
        var _a;
        return deepMerge.apply(void 0, __spreadArray([{}], __read(((_a = i0.inject(DefaultConfigChunk, i0.InjectFlags.Optional)) !== null && _a !== void 0 ? _a : []))));
    }
    /**
     * Default Configuration token, used to build Global Configuration, built from DefaultConfigChunks
     */
    var DefaultConfig = new i0.InjectionToken('DefaultConfiguration', {
        providedIn: 'root',
        factory: defaultConfigFactory,
    });
    function rootConfigFactory() {
        var _a;
        return deepMerge.apply(void 0, __spreadArray([{}], __read(((_a = i0.inject(ConfigChunk, i0.InjectFlags.Optional)) !== null && _a !== void 0 ? _a : []))));
    }
    /**
     * Root Configuration token, used to build Global Configuration, built from ConfigChunks
     */
    var RootConfig = new i0.InjectionToken('RootConfiguration', {
        providedIn: 'root',
        factory: rootConfigFactory,
    });
    /**
     * Config chunk token, can be used to provide configuration chunk and contribute to the global configuration object.
     * Should not be used directly, use `provideConfig` or import `ConfigModule.withConfig` instead.
     */
    var ConfigChunk = new i0.InjectionToken('ConfigurationChunk');
    /**
     * Config chunk token, can be used to provide configuration chunk and contribute to the default configuration.
     * Should not be used directly, use `provideDefaultConfig` or `provideDefaultConfigFactory` instead.
     *
     * General rule is, that all config provided in libraries should be provided as default config.
     */
    var DefaultConfigChunk = new i0.InjectionToken('DefaultConfigurationChunk');

    /**
     * Helper function to provide configuration chunk using ConfigChunk token
     *
     * To provide default configuration in libraries provideDefaultConfig should be used instead.
     *
     * @param config Config object to merge with the global configuration
     */
    function provideConfig(config, defaultConfig) {
        if (config === void 0) { config = {}; }
        if (defaultConfig === void 0) { defaultConfig = false; }
        return {
            provide: defaultConfig ? DefaultConfigChunk : ConfigChunk,
            useValue: config,
            multi: true,
        };
    }
    /**
     * Helper function to provide configuration with factory function, using ConfigChunk token
     *
     * To provide default configuration in libraries provideDefaultConfigFactory should be used instead.
     *
     * @param configFactory Factory Function that will generate config object
     * @param deps Optional dependencies to a factory function
     */
    function provideConfigFactory(configFactory, deps, defaultConfig) {
        if (defaultConfig === void 0) { defaultConfig = false; }
        return {
            provide: defaultConfig ? DefaultConfigChunk : ConfigChunk,
            useFactory: configFactory,
            multi: true,
            deps: deps,
        };
    }
    /**
     * Helper function to provide default configuration chunk using DefaultConfigChunk token
     *
     * @param config Config object to merge with the default configuration
     */
    function provideDefaultConfig(config) {
        if (config === void 0) { config = {}; }
        return {
            provide: DefaultConfigChunk,
            useValue: config,
            multi: true,
        };
    }
    /**
     * Helper function to provide default configuration with factory function, using DefaultConfigChunk token
     *
     * @param configFactory Factory Function that will generate config object
     * @param deps Optional dependencies to a factory function
     */
    function provideDefaultConfigFactory(configFactory, deps) {
        return {
            provide: DefaultConfigChunk,
            useFactory: configFactory,
            multi: true,
            deps: deps,
        };
    }

    var defaultAnonymousConsentsConfig = {
        anonymousConsents: {
            registerConsent: 'MARKETING_NEWSLETTER',
            showLegalDescriptionInDialog: true,
            requiredConsents: [],
            consentManagementPage: {
                showAnonymousConsents: true,
                hideConsents: [],
            },
        },
    };

    exports.CountryType = void 0;
    (function (CountryType) {
        CountryType["BILLING"] = "BILLING";
        CountryType["SHIPPING"] = "SHIPPING";
    })(exports.CountryType || (exports.CountryType = {}));

    exports.PromotionLocation = void 0;
    (function (PromotionLocation) {
        PromotionLocation["ActiveCart"] = "CART";
        PromotionLocation["Checkout"] = "CHECKOUT";
        PromotionLocation["Order"] = "ORDER";
        PromotionLocation["SaveForLater"] = "SAVE_FOR_LATER";
        PromotionLocation["SavedCart"] = "SAVED_CART";
    })(exports.PromotionLocation || (exports.PromotionLocation = {}));
    exports.B2BPaymentTypeEnum = void 0;
    (function (B2BPaymentTypeEnum) {
        B2BPaymentTypeEnum["ACCOUNT_PAYMENT"] = "ACCOUNT";
        B2BPaymentTypeEnum["CARD_PAYMENT"] = "CARD";
    })(exports.B2BPaymentTypeEnum || (exports.B2BPaymentTypeEnum = {}));
    exports.CartValidationStatusCode = void 0;
    (function (CartValidationStatusCode) {
        CartValidationStatusCode["NO_STOCK"] = "noStock";
        CartValidationStatusCode["LOW_STOCK"] = "lowStock";
        CartValidationStatusCode["REVIEW_CONFIGURATION"] = "reviewConfiguration";
        CartValidationStatusCode["PRICING_ERROR"] = "pricingError";
        CartValidationStatusCode["UNRESOLVABLE_ISSUES"] = "unresolvableIssues";
    })(exports.CartValidationStatusCode || (exports.CartValidationStatusCode = {}));

    exports.PageType = void 0;
    (function (PageType) {
        PageType["CONTENT_PAGE"] = "ContentPage";
        PageType["PRODUCT_PAGE"] = "ProductPage";
        PageType["CATEGORY_PAGE"] = "CategoryPage";
        PageType["CATALOG_PAGE"] = "CatalogPage";
    })(exports.PageType || (exports.PageType = {}));
    exports.CmsBannerCarouselEffect = void 0;
    (function (CmsBannerCarouselEffect) {
        CmsBannerCarouselEffect["FADE"] = "FADE";
        CmsBannerCarouselEffect["ZOOM"] = "ZOOM";
        CmsBannerCarouselEffect["CURTAIN"] = "CURTAINX";
        CmsBannerCarouselEffect["TURNDOWN"] = "TURNDOWN";
    })(exports.CmsBannerCarouselEffect || (exports.CmsBannerCarouselEffect = {}));

    exports.ANONYMOUS_CONSENT_STATUS = void 0;
    (function (ANONYMOUS_CONSENT_STATUS) {
        ANONYMOUS_CONSENT_STATUS["GIVEN"] = "GIVEN";
        ANONYMOUS_CONSENT_STATUS["WITHDRAWN"] = "WITHDRAWN";
    })(exports.ANONYMOUS_CONSENT_STATUS || (exports.ANONYMOUS_CONSENT_STATUS = {}));
    var ANONYMOUS_CONSENTS_HEADER = 'X-Anonymous-Consents';

    exports.ImageType = void 0;
    (function (ImageType) {
        ImageType["PRIMARY"] = "PRIMARY";
        ImageType["GALLERY"] = "GALLERY";
    })(exports.ImageType || (exports.ImageType = {}));

    var HttpErrorModel = /** @class */ (function () {
        function HttpErrorModel() {
        }
        return HttpErrorModel;
    }());

    exports.B2BUserRole = void 0;
    (function (B2BUserRole) {
        B2BUserRole["ADMIN"] = "b2badmingroup";
        B2BUserRole["CUSTOMER"] = "b2bcustomergroup";
        B2BUserRole["MANAGER"] = "b2bmanagergroup";
        B2BUserRole["APPROVER"] = "b2bapprovergroup";
    })(exports.B2BUserRole || (exports.B2BUserRole = {}));

    exports.NotificationType = void 0;
    (function (NotificationType) {
        NotificationType["BACK_IN_STOCK"] = "BACK_IN_STOCK";
    })(exports.NotificationType || (exports.NotificationType = {}));

    exports.VariantType = void 0;
    (function (VariantType) {
        VariantType["SIZE"] = "ApparelSizeVariantProduct";
        VariantType["STYLE"] = "ApparelStyleVariantProduct";
        VariantType["COLOR"] = "ElectronicsColorVariantProduct";
    })(exports.VariantType || (exports.VariantType = {}));
    exports.PriceType = void 0;
    (function (PriceType) {
        PriceType["BUY"] = "BUY";
        PriceType["FROM"] = "FROM";
    })(exports.PriceType || (exports.PriceType = {}));
    exports.VariantQualifier = void 0;
    (function (VariantQualifier) {
        VariantQualifier["SIZE"] = "size";
        VariantQualifier["STYLE"] = "style";
        VariantQualifier["COLOR"] = "color";
        VariantQualifier["THUMBNAIL"] = "thumbnail";
        VariantQualifier["PRODUCT"] = "product";
        VariantQualifier["ROLLUP_PROPERTY"] = "rollupProperty";
    })(exports.VariantQualifier || (exports.VariantQualifier = {}));

    exports.DaysOfWeek = void 0;
    (function (DaysOfWeek) {
        DaysOfWeek["MONDAY"] = "MONDAY";
        DaysOfWeek["TUESDAY"] = "TUESDAY";
        DaysOfWeek["WEDNESDAY"] = "WEDNESDAY";
        DaysOfWeek["THURSDAY"] = "THURSDAY";
        DaysOfWeek["FRIDAY"] = "FRIDAY";
        DaysOfWeek["SATURDAY"] = "SATURDAY";
        DaysOfWeek["SUNDAY"] = "SUNDAY";
    })(exports.DaysOfWeek || (exports.DaysOfWeek = {}));
    var recurrencePeriod = {
        DAILY: 'DAILY',
        WEEKLY: 'WEEKLY',
        MONTHLY: 'MONTHLY',
    };
    exports.ORDER_TYPE = void 0;
    (function (ORDER_TYPE) {
        ORDER_TYPE["PLACE_ORDER"] = "PLACE_ORDER";
        ORDER_TYPE["SCHEDULE_REPLENISHMENT_ORDER"] = "SCHEDULE_REPLENISHMENT_ORDER";
    })(exports.ORDER_TYPE || (exports.ORDER_TYPE = {}));

    var ENTITY_REMOVE_ACTION = '[ENTITY] REMOVE';
    var ENTITY_REMOVE_ALL_ACTION = '[ENTITY] REMOVE ALL';
    function entityMeta(type, id) {
        return {
            entityType: type,
            entityId: id,
        };
    }
    function entityRemoveMeta(type, id) {
        return {
            entityId: id,
            entityType: type,
            entityRemove: true,
        };
    }
    function entityRemoveAllMeta(type) {
        return {
            entityId: null,
            entityType: type,
            entityRemove: true,
        };
    }
    var EntityRemoveAction = /** @class */ (function () {
        function EntityRemoveAction(entityType, id) {
            this.type = ENTITY_REMOVE_ACTION;
            this.meta = entityRemoveMeta(entityType, id);
        }
        return EntityRemoveAction;
    }());
    var EntityRemoveAllAction = /** @class */ (function () {
        function EntityRemoveAllAction(entityType) {
            this.type = ENTITY_REMOVE_ALL_ACTION;
            this.meta = entityRemoveAllMeta(entityType);
        }
        return EntityRemoveAllAction;
    }());

    var LOADER_LOAD_ACTION = '[LOADER] LOAD';
    var LOADER_FAIL_ACTION = '[LOADER] FAIL';
    var LOADER_SUCCESS_ACTION = '[LOADER] SUCCESS';
    var LOADER_RESET_ACTION = '[LOADER] RESET';
    function loadMeta(entityType) {
        return {
            entityType: entityType,
            loader: {
                load: true,
            },
        };
    }
    function failMeta(entityType, error) {
        return {
            entityType: entityType,
            loader: {
                error: error ? error : true,
            },
        };
    }
    function successMeta(entityType) {
        return {
            entityType: entityType,
            loader: {
                success: true,
            },
        };
    }
    function resetMeta(entityType) {
        return {
            entityType: entityType,
            loader: {},
        };
    }
    var LoaderLoadAction = /** @class */ (function () {
        function LoaderLoadAction(entityType) {
            this.type = LOADER_LOAD_ACTION;
            this.meta = loadMeta(entityType);
        }
        return LoaderLoadAction;
    }());
    var LoaderFailAction = /** @class */ (function () {
        function LoaderFailAction(entityType, error) {
            this.type = LOADER_FAIL_ACTION;
            this.meta = failMeta(entityType, error);
        }
        return LoaderFailAction;
    }());
    var LoaderSuccessAction = /** @class */ (function () {
        function LoaderSuccessAction(entityType) {
            this.type = LOADER_SUCCESS_ACTION;
            this.meta = successMeta(entityType);
        }
        return LoaderSuccessAction;
    }());
    var LoaderResetAction = /** @class */ (function () {
        function LoaderResetAction(entityType) {
            this.type = LOADER_RESET_ACTION;
            this.meta = resetMeta(entityType);
        }
        return LoaderResetAction;
    }());

    var ENTITY_LOAD_ACTION = '[ENTITY] LOAD';
    var ENTITY_FAIL_ACTION = '[ENTITY] LOAD FAIL';
    var ENTITY_SUCCESS_ACTION = '[ENTITY] LOAD SUCCESS';
    var ENTITY_RESET_ACTION = '[ENTITY] RESET';
    function entityLoadMeta(entityType, id) {
        return Object.assign(Object.assign({}, loadMeta(entityType)), entityMeta(entityType, id));
    }
    function entityFailMeta(entityType, id, error) {
        return Object.assign(Object.assign({}, failMeta(entityType, error)), entityMeta(entityType, id));
    }
    function entitySuccessMeta(entityType, id) {
        return Object.assign(Object.assign({}, successMeta(entityType)), entityMeta(entityType, id));
    }
    function entityResetMeta(entityType, id) {
        return Object.assign(Object.assign({}, resetMeta(entityType)), entityMeta(entityType, id));
    }
    var EntityLoadAction = /** @class */ (function () {
        function EntityLoadAction(entityType, id) {
            this.type = ENTITY_LOAD_ACTION;
            this.meta = entityLoadMeta(entityType, id);
        }
        return EntityLoadAction;
    }());
    var EntityFailAction = /** @class */ (function () {
        function EntityFailAction(entityType, id, error) {
            this.type = ENTITY_FAIL_ACTION;
            this.meta = entityFailMeta(entityType, id, error);
        }
        return EntityFailAction;
    }());
    var EntitySuccessAction = /** @class */ (function () {
        function EntitySuccessAction(entityType, id, payload) {
            this.payload = payload;
            this.type = ENTITY_SUCCESS_ACTION;
            this.meta = entitySuccessMeta(entityType, id);
        }
        return EntitySuccessAction;
    }());
    var EntityLoaderResetAction = /** @class */ (function () {
        function EntityLoaderResetAction(entityType, id) {
            this.type = ENTITY_RESET_ACTION;
            this.meta = entityResetMeta(entityType, id);
        }
        return EntityLoaderResetAction;
    }());

    var initialLoaderState = {
        loading: false,
        error: false,
        success: false,
        value: undefined,
    };
    /**
     * Higher order reducer that adds generic loading flag to chunk of the state
     *
     * Utilizes "loader" meta field of actions to set specific flags for specific
     * action (LOAD, SUCCESS, FAIL, RESET)
     */
    function loaderReducer(entityType, reducer) {
        return function (state, action) {
            if (state === void 0) { state = initialLoaderState; }
            if (action.meta &&
                action.meta.loader &&
                action.meta.entityType === entityType) {
                var entity = action.meta.loader;
                if (entity.load) {
                    return Object.assign(Object.assign({}, state), { loading: true, value: reducer ? reducer(state.value, action) : state.value });
                }
                else if (entity.error) {
                    return Object.assign(Object.assign({}, state), { loading: false, error: true, success: false, value: reducer ? reducer(state.value, action) : undefined });
                }
                else if (entity.success) {
                    return Object.assign(Object.assign({}, state), { value: reducer ? reducer(state.value, action) : action.payload, loading: false, error: false, success: true });
                }
                else {
                    // reset state action
                    return Object.assign(Object.assign({}, initialLoaderState), { value: reducer
                            ? reducer(initialLoaderState.value, action)
                            : initialLoaderState.value });
                }
            }
            if (reducer) {
                var newValue = reducer(state.value, action);
                if (newValue !== state.value) {
                    return Object.assign(Object.assign({}, state), { value: newValue });
                }
            }
            return state;
        };
    }

    function loaderValueSelector(state) {
        return state.value;
    }
    function loaderLoadingSelector(state) {
        return state.loading;
    }
    function loaderErrorSelector(state) {
        return state.error;
    }
    function loaderSuccessSelector(state) {
        return state.success;
    }

    function entityLoaderStateSelector(state, id) {
        return state.entities[id] || initialLoaderState;
    }
    function entityValueSelector(state, id) {
        var entityState = entityLoaderStateSelector(state, id);
        return loaderValueSelector(entityState);
    }
    function entityLoadingSelector(state, id) {
        var entityState = entityLoaderStateSelector(state, id);
        return loaderLoadingSelector(entityState);
    }
    function entityErrorSelector(state, id) {
        var entityState = entityLoaderStateSelector(state, id);
        return loaderErrorSelector(entityState);
    }
    function entitySuccessSelector(state, id) {
        var entityState = entityLoaderStateSelector(state, id);
        return loaderSuccessSelector(entityState);
    }

    var initialEntityState = { entities: {} };
    /**
     * Higher order reducer for reusing reducer logic for multiple entities
     *
     * Utilizes entityId meta field to target entity by id in actions
     */
    function entityReducer(entityType, reducer) {
        return function (state, action) {
            if (state === void 0) { state = initialEntityState; }
            var ids;
            var partitionPayload = false;
            if (action.meta &&
                action.meta.entityType === entityType &&
                action.meta.entityId !== undefined) {
                ids = [].concat(action.meta.entityId);
                // remove selected entities
                if (action.meta.entityRemove) {
                    if (action.meta.entityId === null) {
                        return initialEntityState;
                    }
                    else {
                        var removed_1 = false;
                        var newEntities = Object.keys(state.entities).reduce(function (acc, cur) {
                            if (ids.includes(cur)) {
                                removed_1 = true;
                            }
                            else {
                                acc[cur] = state.entities[cur];
                            }
                            return acc;
                        }, {});
                        return removed_1 ? { entities: newEntities } : state;
                    }
                }
                partitionPayload =
                    Array.isArray(action.meta.entityId) && Array.isArray(action.payload);
            }
            else {
                ids = Object.keys(state.entities);
            }
            var entityUpdates = {};
            for (var i = 0; i < ids.length; i++) {
                var id = ids[i];
                var subAction = partitionPayload
                    ? Object.assign(Object.assign({}, action), { payload: action.payload[i] }) : action;
                var newState = reducer(state.entities[id], subAction);
                if (newState) {
                    entityUpdates[id] = newState;
                }
            }
            if (Object.keys(entityUpdates).length > 0) {
                return Object.assign(Object.assign({}, state), { entities: Object.assign(Object.assign({}, state.entities), entityUpdates) });
            }
            return state;
        };
    }

    /**
     * Higher order reducer that wraps LoaderReducer and EntityReducer enhancing
     * single state reducer to support multiple entities with generic loading flags
     */
    function entityLoaderReducer(entityType, reducer) {
        return entityReducer(entityType, loaderReducer(entityType, reducer));
    }

    var PROCESSES_INCREMENT_ACTION = '[PROCESSES LOADER] INCREMENT';
    var PROCESSES_DECREMENT_ACTION = '[PROCESSES LOADER] DECREMENT';
    var PROCESSES_LOADER_RESET_ACTION = '[PROCESSES LOADER] RESET';
    function processesIncrementMeta(entityType) {
        return {
            entityType: entityType,
            loader: undefined,
            processesCountDiff: 1,
        };
    }
    function processesDecrementMeta(entityType) {
        return {
            entityType: entityType,
            loader: undefined,
            processesCountDiff: -1,
        };
    }
    function processesLoaderResetMeta(entityType) {
        // processes reset action is a reset action for loader reducer, but not the other way around
        return Object.assign(Object.assign({}, resetMeta(entityType)), { processesCountDiff: null });
    }
    var ProcessesLoaderResetAction = /** @class */ (function () {
        function ProcessesLoaderResetAction(entityType) {
            this.type = PROCESSES_LOADER_RESET_ACTION;
            this.meta = processesLoaderResetMeta(entityType);
        }
        return ProcessesLoaderResetAction;
    }());
    var ProcessesIncrementAction = /** @class */ (function () {
        function ProcessesIncrementAction(entityType) {
            this.type = PROCESSES_INCREMENT_ACTION;
            this.meta = processesIncrementMeta(entityType);
        }
        return ProcessesIncrementAction;
    }());
    var ProcessesDecrementAction = /** @class */ (function () {
        function ProcessesDecrementAction(entityType) {
            this.type = PROCESSES_DECREMENT_ACTION;
            this.meta = processesDecrementMeta(entityType);
        }
        return ProcessesDecrementAction;
    }());

    var ENTITY_PROCESSES_LOADER_RESET_ACTION = '[ENTITY] PROCESSES LOADER RESET';
    var ENTITY_PROCESSES_INCREMENT_ACTION = '[ENTITY] PROCESSES INCREMENT';
    var ENTITY_PROCESSES_DECREMENT_ACTION = '[ENTITY] PROCESSES DECREMENT';
    function entityProcessesLoaderResetMeta(entityType, id) {
        return Object.assign(Object.assign({}, processesLoaderResetMeta(entityType)), entityMeta(entityType, id));
    }
    function entityProcessesIncrementMeta(entityType, id) {
        return Object.assign(Object.assign({}, processesIncrementMeta(entityType)), entityMeta(entityType, id));
    }
    function entityProcessesDecrementMeta(entityType, id) {
        return Object.assign(Object.assign({}, processesDecrementMeta(entityType)), entityMeta(entityType, id));
    }
    var EntityProcessesLoaderResetAction = /** @class */ (function () {
        function EntityProcessesLoaderResetAction(entityType, id) {
            this.type = ENTITY_PROCESSES_LOADER_RESET_ACTION;
            this.meta = entityProcessesLoaderResetMeta(entityType, id);
        }
        return EntityProcessesLoaderResetAction;
    }());
    var EntityProcessesIncrementAction = /** @class */ (function () {
        function EntityProcessesIncrementAction(entityType, id) {
            this.type = ENTITY_PROCESSES_INCREMENT_ACTION;
            this.meta = entityProcessesIncrementMeta(entityType, id);
        }
        return EntityProcessesIncrementAction;
    }());
    var EntityProcessesDecrementAction = /** @class */ (function () {
        function EntityProcessesDecrementAction(entityType, id) {
            this.type = ENTITY_PROCESSES_DECREMENT_ACTION;
            this.meta = entityProcessesDecrementMeta(entityType, id);
        }
        return EntityProcessesDecrementAction;
    }());

    function isStableSelector(state) {
        return state.processesCount === 0 && !state.loading;
    }
    function hasPendingProcessesSelector(state) {
        return state.processesCount > 0;
    }

    var initialProcessesState = {
        processesCount: 0,
    };
    /**
     * Higher order reducer that adds processes count
     */
    function processesLoaderReducer(entityType, reducer) {
        return function (state, action) {
            if (state === void 0) { state = Object.assign(Object.assign({}, initialProcessesState), initialLoaderState); }
            var loaderState = loaderReducer(entityType, reducer)(state, action);
            if (action.meta && action.meta.entityType === entityType) {
                var processesCountDiff = action.meta.processesCountDiff;
                if (i0.isDevMode() && state.processesCount + processesCountDiff < 0) {
                    console.error("Action '" + action.type + "' sets processesCount to value < 0!\n" +
                        'Make sure to keep processesCount in sync.\n' +
                        'There should always be only one decrement action for each increment action.\n' +
                        "Make sure that you don't reset state in between those actions.\n", action);
                }
                if (processesCountDiff) {
                    return Object.assign(Object.assign({}, loaderState), { processesCount: state.processesCount
                            ? state.processesCount + processesCountDiff
                            : processesCountDiff });
                }
                else if (processesCountDiff === null) {
                    // reset action
                    return Object.assign(Object.assign({}, loaderState), initialProcessesState);
                }
            }
            return loaderState;
        };
    }

    var initialProcessesLoaderState = Object.assign(Object.assign({}, initialLoaderState), initialProcessesState);
    function entityHasPendingProcessesSelector(state, id) {
        var entityState = entityLoaderStateSelector(state, id);
        return hasPendingProcessesSelector(entityState);
    }
    function entityIsStableSelector(state, id) {
        var entityState = entityLoaderStateSelector(state, id);
        return isStableSelector(entityState);
    }
    function entityProcessesLoaderStateSelector(state, id) {
        return state.entities[id] || initialProcessesLoaderState;
    }

    /**
     * Higher order reducer that wraps ProcessesLoaderReducer and EntityReducer enhancing
     * single state reducer to support multiple entities with generic processesCount flag
     */
    function entityProcessesLoaderReducer(entityType, reducer) {
        return entityReducer(entityType, processesLoaderReducer(entityType, reducer));
    }

    function entitySelector(state, id) {
        return state.entities[id] || undefined;
    }

    var OBJECT_SEPARATOR = '.';
    function getStateSliceValue(keys, state) {
        return keys
            .split(OBJECT_SEPARATOR)
            .reduce(function (previous, current) { return (previous ? previous[current] : undefined); }, state);
    }
    function createShellObject(key, excludeKeys, value) {
        if (!key || !value || Object.keys(value).length === 0) {
            return {};
        }
        var shell = key.split(OBJECT_SEPARATOR).reduceRight(function (acc, previous) {
            var _a;
            return _a = {}, _a[previous] = acc, _a;
        }, value);
        return handleExclusions(key, excludeKeys, shell);
    }
    function getStateSlice(keys, excludeKeys, state) {
        var e_1, _a;
        if (keys && keys.length === 0) {
            return {};
        }
        var stateSlices = {};
        try {
            for (var keys_1 = __values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {
                var currentKey = keys_1_1.value;
                var stateValue = getStateSliceValue(currentKey, state);
                var shell = createShellObject(currentKey, excludeKeys, stateValue);
                stateSlices = deepMerge(stateSlices, shell);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (keys_1_1 && !keys_1_1.done && (_a = keys_1.return)) _a.call(keys_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return stateSlices;
    }
    function handleExclusions(key, excludeKeys, value) {
        var e_2, _a;
        var exclusionKeys = getExclusionKeys(key, excludeKeys);
        if (exclusionKeys.length === 0) {
            return value;
        }
        var finalValue = deepMerge({}, value);
        try {
            for (var exclusionKeys_1 = __values(exclusionKeys), exclusionKeys_1_1 = exclusionKeys_1.next(); !exclusionKeys_1_1.done; exclusionKeys_1_1 = exclusionKeys_1.next()) {
                var currentExclusionKey = exclusionKeys_1_1.value;
                var exclusionChunksSplit = currentExclusionKey.split(OBJECT_SEPARATOR);
                var nestedTemp = finalValue;
                for (var i = 0; i < exclusionChunksSplit.length; i++) {
                    var currentChunk = exclusionChunksSplit[i];
                    // last iteration
                    if (i === exclusionChunksSplit.length - 1) {
                        if (nestedTemp && nestedTemp[currentChunk]) {
                            delete nestedTemp[currentChunk];
                        }
                    }
                    else {
                        nestedTemp = nestedTemp[currentChunk];
                    }
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (exclusionKeys_1_1 && !exclusionKeys_1_1.done && (_a = exclusionKeys_1.return)) _a.call(exclusionKeys_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return finalValue;
    }
    function getExclusionKeys(key, excludeKeys) {
        var e_3, _a;
        if (!key || !excludeKeys) {
            return [];
        }
        var exclusionKeys = [];
        try {
            for (var excludeKeys_1 = __values(excludeKeys), excludeKeys_1_1 = excludeKeys_1.next(); !excludeKeys_1_1.done; excludeKeys_1_1 = excludeKeys_1.next()) {
                var exclusionKey = excludeKeys_1_1.value;
                if (exclusionKey.includes(key)) {
                    exclusionKeys.push(exclusionKey);
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (excludeKeys_1_1 && !excludeKeys_1_1.done && (_a = excludeKeys_1.return)) _a.call(excludeKeys_1);
            }
            finally { if (e_3) throw e_3.error; }
        }
        return exclusionKeys;
    }
    function filterKeysByType(keys, type) {
        if (!keys) {
            return [];
        }
        return Object.keys(keys).filter(function (key) { return keys[key] === type; });
    }

    var ALL = 'all';
    function serializeSearchConfig(config, id) {
        var _a, _b, _c;
        return (id !== null && id !== void 0 ? id : '') + "?pageSize=" + ((_a = config.pageSize) !== null && _a !== void 0 ? _a : '') + "&currentPage=" + ((_b = config.currentPage) !== null && _b !== void 0 ? _b : '') + "&sort=" + ((_c = config.sort) !== null && _c !== void 0 ? _c : '');
    }
    function denormalizeSearch(state, params) {
        return denormalizeCustomB2BSearch(state.list, state.entities, params);
    }
    function denormalizeCustomB2BSearch(list, entities, params, id) {
        var serializedList = entityLoaderStateSelector(list, params ? serializeSearchConfig(params, id) : id !== null && id !== void 0 ? id : ALL);
        if (!serializedList.value || !serializedList.value.ids) {
            return serializedList;
        }
        var res = Object.assign({}, serializedList, {
            value: {
                values: serializedList.value.ids.map(function (code) { return entityLoaderStateSelector(entities, code).value; }),
            },
        });
        if (params) {
            res.value.pagination = serializedList.value.pagination;
            res.value.sorts = serializedList.value.sorts;
        }
        return res;
    }
    function normalizeListPage(list, id) {
        var values = (list === null || list === void 0 ? void 0 : list.values) || [];
        var page = {
            ids: values.map(function (data) { return data[id]; }),
        };
        if (list.pagination) {
            page.pagination = list.pagination;
        }
        if (list.sorts) {
            page.sorts = list.sorts;
        }
        return { values: values, page: page };
    }
    function serializeParams(params, searchConfig) {
        return [params, serializeSearchConfig(searchConfig)].toString();
    }

    var utilsGroup = /*#__PURE__*/Object.freeze({
        __proto__: null,
        getStateSlice: getStateSlice,
        ENTITY_LOAD_ACTION: ENTITY_LOAD_ACTION,
        ENTITY_FAIL_ACTION: ENTITY_FAIL_ACTION,
        ENTITY_SUCCESS_ACTION: ENTITY_SUCCESS_ACTION,
        ENTITY_RESET_ACTION: ENTITY_RESET_ACTION,
        entityLoadMeta: entityLoadMeta,
        entityFailMeta: entityFailMeta,
        entitySuccessMeta: entitySuccessMeta,
        entityResetMeta: entityResetMeta,
        EntityLoadAction: EntityLoadAction,
        EntityFailAction: EntityFailAction,
        EntitySuccessAction: EntitySuccessAction,
        EntityLoaderResetAction: EntityLoaderResetAction,
        entityLoaderStateSelector: entityLoaderStateSelector,
        entityValueSelector: entityValueSelector,
        entityLoadingSelector: entityLoadingSelector,
        entityErrorSelector: entityErrorSelector,
        entitySuccessSelector: entitySuccessSelector,
        entityLoaderReducer: entityLoaderReducer,
        ENTITY_PROCESSES_LOADER_RESET_ACTION: ENTITY_PROCESSES_LOADER_RESET_ACTION,
        ENTITY_PROCESSES_INCREMENT_ACTION: ENTITY_PROCESSES_INCREMENT_ACTION,
        ENTITY_PROCESSES_DECREMENT_ACTION: ENTITY_PROCESSES_DECREMENT_ACTION,
        entityProcessesLoaderResetMeta: entityProcessesLoaderResetMeta,
        entityProcessesIncrementMeta: entityProcessesIncrementMeta,
        entityProcessesDecrementMeta: entityProcessesDecrementMeta,
        EntityProcessesLoaderResetAction: EntityProcessesLoaderResetAction,
        EntityProcessesIncrementAction: EntityProcessesIncrementAction,
        EntityProcessesDecrementAction: EntityProcessesDecrementAction,
        entityHasPendingProcessesSelector: entityHasPendingProcessesSelector,
        entityIsStableSelector: entityIsStableSelector,
        entityProcessesLoaderStateSelector: entityProcessesLoaderStateSelector,
        entityProcessesLoaderReducer: entityProcessesLoaderReducer,
        ENTITY_REMOVE_ACTION: ENTITY_REMOVE_ACTION,
        ENTITY_REMOVE_ALL_ACTION: ENTITY_REMOVE_ALL_ACTION,
        entityMeta: entityMeta,
        entityRemoveMeta: entityRemoveMeta,
        entityRemoveAllMeta: entityRemoveAllMeta,
        EntityRemoveAction: EntityRemoveAction,
        EntityRemoveAllAction: EntityRemoveAllAction,
        entitySelector: entitySelector,
        initialEntityState: initialEntityState,
        entityReducer: entityReducer,
        LOADER_LOAD_ACTION: LOADER_LOAD_ACTION,
        LOADER_FAIL_ACTION: LOADER_FAIL_ACTION,
        LOADER_SUCCESS_ACTION: LOADER_SUCCESS_ACTION,
        LOADER_RESET_ACTION: LOADER_RESET_ACTION,
        loadMeta: loadMeta,
        failMeta: failMeta,
        successMeta: successMeta,
        resetMeta: resetMeta,
        LoaderLoadAction: LoaderLoadAction,
        LoaderFailAction: LoaderFailAction,
        LoaderSuccessAction: LoaderSuccessAction,
        LoaderResetAction: LoaderResetAction,
        loaderValueSelector: loaderValueSelector,
        loaderLoadingSelector: loaderLoadingSelector,
        loaderErrorSelector: loaderErrorSelector,
        loaderSuccessSelector: loaderSuccessSelector,
        initialLoaderState: initialLoaderState,
        loaderReducer: loaderReducer,
        PROCESSES_INCREMENT_ACTION: PROCESSES_INCREMENT_ACTION,
        PROCESSES_DECREMENT_ACTION: PROCESSES_DECREMENT_ACTION,
        PROCESSES_LOADER_RESET_ACTION: PROCESSES_LOADER_RESET_ACTION,
        processesIncrementMeta: processesIncrementMeta,
        processesDecrementMeta: processesDecrementMeta,
        processesLoaderResetMeta: processesLoaderResetMeta,
        ProcessesLoaderResetAction: ProcessesLoaderResetAction,
        ProcessesIncrementAction: ProcessesIncrementAction,
        ProcessesDecrementAction: ProcessesDecrementAction,
        isStableSelector: isStableSelector,
        hasPendingProcessesSelector: hasPendingProcessesSelector,
        initialProcessesState: initialProcessesState,
        processesLoaderReducer: processesLoaderReducer,
        serializeSearchConfig: serializeSearchConfig,
        denormalizeSearch: denormalizeSearch,
        denormalizeCustomB2BSearch: denormalizeCustomB2BSearch,
        normalizeListPage: normalizeListPage,
        serializeParams: serializeParams
    });

    var ANONYMOUS_CONSENTS_STORE_FEATURE = 'anonymous-consents';
    var ANONYMOUS_CONSENTS = '[Anonymous Consents] Anonymous Consents';

    var LOAD_ANONYMOUS_CONSENT_TEMPLATES = '[Anonymous Consents] Load Anonymous Consent Templates';
    var LOAD_ANONYMOUS_CONSENT_TEMPLATES_SUCCESS = '[Anonymous Consents] Load Anonymous Consent Templates Success';
    var LOAD_ANONYMOUS_CONSENT_TEMPLATES_FAIL = '[Anonymous Consents] Load Anonymous Consent Templates Fail';
    var RESET_LOAD_ANONYMOUS_CONSENT_TEMPLATES = '[Anonymous Consents] Reset Load Anonymous Consent Templates';
    var GET_ALL_ANONYMOUS_CONSENTS = '[Anonymous Consents] Get All Anonymous Consents';
    var GET_ANONYMOUS_CONSENT = '[Anonymous Consents] Get Anonymous Consent';
    var SET_ANONYMOUS_CONSENTS = '[Anonymous Consents] Set Anonymous Consents';
    var GIVE_ANONYMOUS_CONSENT = '[Anonymous Consents] Give Anonymous Consent';
    var WITHDRAW_ANONYMOUS_CONSENT = '[Anonymous Consents] Withdraw Anonymous Consent';
    var TOGGLE_ANONYMOUS_CONSENTS_BANNER_DISMISSED = '[Anonymous Consents] Toggle Anonymous Consents Banner Dismissed';
    var TOGGLE_ANONYMOUS_CONSENT_TEMPLATES_UPDATED = '[Anonymous Consents] Anonymous Consent Templates Updated';
    var ANONYMOUS_CONSENT_CHECK_UPDATED_VERSIONS = '[Anonymous Consents] Check Updated Versions';
    var LoadAnonymousConsentTemplates = /** @class */ (function (_super) {
        __extends(LoadAnonymousConsentTemplates, _super);
        function LoadAnonymousConsentTemplates() {
            var _this = _super.call(this, ANONYMOUS_CONSENTS) || this;
            _this.type = LOAD_ANONYMOUS_CONSENT_TEMPLATES;
            return _this;
        }
        return LoadAnonymousConsentTemplates;
    }(LoaderLoadAction));
    var LoadAnonymousConsentTemplatesSuccess = /** @class */ (function (_super) {
        __extends(LoadAnonymousConsentTemplatesSuccess, _super);
        function LoadAnonymousConsentTemplatesSuccess(payload) {
            var _this = _super.call(this, ANONYMOUS_CONSENTS) || this;
            _this.payload = payload;
            _this.type = LOAD_ANONYMOUS_CONSENT_TEMPLATES_SUCCESS;
            return _this;
        }
        return LoadAnonymousConsentTemplatesSuccess;
    }(LoaderSuccessAction));
    var LoadAnonymousConsentTemplatesFail = /** @class */ (function (_super) {
        __extends(LoadAnonymousConsentTemplatesFail, _super);
        function LoadAnonymousConsentTemplatesFail(payload) {
            var _this = _super.call(this, ANONYMOUS_CONSENTS, payload) || this;
            _this.type = LOAD_ANONYMOUS_CONSENT_TEMPLATES_FAIL;
            return _this;
        }
        return LoadAnonymousConsentTemplatesFail;
    }(LoaderFailAction));
    var ResetLoadAnonymousConsentTemplates = /** @class */ (function (_super) {
        __extends(ResetLoadAnonymousConsentTemplates, _super);
        function ResetLoadAnonymousConsentTemplates() {
            var _this = _super.call(this, ANONYMOUS_CONSENTS) || this;
            _this.type = RESET_LOAD_ANONYMOUS_CONSENT_TEMPLATES;
            return _this;
        }
        return ResetLoadAnonymousConsentTemplates;
    }(LoaderResetAction));
    var GetAllAnonymousConsents = /** @class */ (function () {
        function GetAllAnonymousConsents() {
            this.type = GET_ALL_ANONYMOUS_CONSENTS;
        }
        return GetAllAnonymousConsents;
    }());
    var GetAnonymousConsent = /** @class */ (function () {
        function GetAnonymousConsent(templateCode) {
            this.templateCode = templateCode;
            this.type = GET_ANONYMOUS_CONSENT;
        }
        return GetAnonymousConsent;
    }());
    var SetAnonymousConsents = /** @class */ (function () {
        function SetAnonymousConsents(payload) {
            this.payload = payload;
            this.type = SET_ANONYMOUS_CONSENTS;
        }
        return SetAnonymousConsents;
    }());
    var GiveAnonymousConsent = /** @class */ (function () {
        function GiveAnonymousConsent(templateCode) {
            this.templateCode = templateCode;
            this.type = GIVE_ANONYMOUS_CONSENT;
        }
        return GiveAnonymousConsent;
    }());
    var WithdrawAnonymousConsent = /** @class */ (function () {
        function WithdrawAnonymousConsent(templateCode) {
            this.templateCode = templateCode;
            this.type = WITHDRAW_ANONYMOUS_CONSENT;
        }
        return WithdrawAnonymousConsent;
    }());
    var ToggleAnonymousConsentsBannerDissmissed = /** @class */ (function () {
        function ToggleAnonymousConsentsBannerDissmissed(dismissed) {
            this.dismissed = dismissed;
            this.type = TOGGLE_ANONYMOUS_CONSENTS_BANNER_DISMISSED;
        }
        return ToggleAnonymousConsentsBannerDissmissed;
    }());
    var ToggleAnonymousConsentTemplatesUpdated = /** @class */ (function () {
        function ToggleAnonymousConsentTemplatesUpdated(updated) {
            this.updated = updated;
            this.type = TOGGLE_ANONYMOUS_CONSENT_TEMPLATES_UPDATED;
        }
        return ToggleAnonymousConsentTemplatesUpdated;
    }());
    var AnonymousConsentCheckUpdatedVersions = /** @class */ (function () {
        function AnonymousConsentCheckUpdatedVersions() {
            this.type = ANONYMOUS_CONSENT_CHECK_UPDATED_VERSIONS;
        }
        return AnonymousConsentCheckUpdatedVersions;
    }());

    var anonymousConsentsGroup = /*#__PURE__*/Object.freeze({
        __proto__: null,
        LOAD_ANONYMOUS_CONSENT_TEMPLATES: LOAD_ANONYMOUS_CONSENT_TEMPLATES,
        LOAD_ANONYMOUS_CONSENT_TEMPLATES_SUCCESS: LOAD_ANONYMOUS_CONSENT_TEMPLATES_SUCCESS,
        LOAD_ANONYMOUS_CONSENT_TEMPLATES_FAIL: LOAD_ANONYMOUS_CONSENT_TEMPLATES_FAIL,
        RESET_LOAD_ANONYMOUS_CONSENT_TEMPLATES: RESET_LOAD_ANONYMOUS_CONSENT_TEMPLATES,
        GET_ALL_ANONYMOUS_CONSENTS: GET_ALL_ANONYMOUS_CONSENTS,
        GET_ANONYMOUS_CONSENT: GET_ANONYMOUS_CONSENT,
        SET_ANONYMOUS_CONSENTS: SET_ANONYMOUS_CONSENTS,
        GIVE_ANONYMOUS_CONSENT: GIVE_ANONYMOUS_CONSENT,
        WITHDRAW_ANONYMOUS_CONSENT: WITHDRAW_ANONYMOUS_CONSENT,
        TOGGLE_ANONYMOUS_CONSENTS_BANNER_DISMISSED: TOGGLE_ANONYMOUS_CONSENTS_BANNER_DISMISSED,
        TOGGLE_ANONYMOUS_CONSENT_TEMPLATES_UPDATED: TOGGLE_ANONYMOUS_CONSENT_TEMPLATES_UPDATED,
        ANONYMOUS_CONSENT_CHECK_UPDATED_VERSIONS: ANONYMOUS_CONSENT_CHECK_UPDATED_VERSIONS,
        LoadAnonymousConsentTemplates: LoadAnonymousConsentTemplates,
        LoadAnonymousConsentTemplatesSuccess: LoadAnonymousConsentTemplatesSuccess,
        LoadAnonymousConsentTemplatesFail: LoadAnonymousConsentTemplatesFail,
        ResetLoadAnonymousConsentTemplates: ResetLoadAnonymousConsentTemplates,
        GetAllAnonymousConsents: GetAllAnonymousConsents,
        GetAnonymousConsent: GetAnonymousConsent,
        SetAnonymousConsents: SetAnonymousConsents,
        GiveAnonymousConsent: GiveAnonymousConsent,
        WithdrawAnonymousConsent: WithdrawAnonymousConsent,
        ToggleAnonymousConsentsBannerDissmissed: ToggleAnonymousConsentsBannerDissmissed,
        ToggleAnonymousConsentTemplatesUpdated: ToggleAnonymousConsentTemplatesUpdated,
        AnonymousConsentCheckUpdatedVersions: AnonymousConsentCheckUpdatedVersions
    });

    var getAnonymousConsentState = i1.createFeatureSelector(ANONYMOUS_CONSENTS_STORE_FEATURE);

    var getAnonymousConsentTemplatesState = i1.createSelector(getAnonymousConsentState, function (state) { return state.templates; });
    var getAnonymousConsentTemplatesValue = i1.createSelector(getAnonymousConsentTemplatesState, loaderValueSelector);
    var getAnonymousConsentTemplatesLoading = i1.createSelector(getAnonymousConsentTemplatesState, loaderLoadingSelector);
    var getAnonymousConsentTemplatesSuccess = i1.createSelector(getAnonymousConsentTemplatesState, loaderSuccessSelector);
    var getAnonymousConsentTemplatesError = i1.createSelector(getAnonymousConsentTemplatesState, loaderErrorSelector);
    var getAnonymousConsentTemplate = function (templateCode) {
        return i1.createSelector(getAnonymousConsentTemplatesValue, function (templates) {
            return templates
                ? templates.find(function (template) { return template.id === templateCode; })
                : null;
        });
    };

    var getAnonymousConsentTemplatesUpdate = i1.createSelector(getAnonymousConsentState, function (state) { return state.ui.updated; });
    var getAnonymousConsentsBannerDismissed = i1.createSelector(getAnonymousConsentState, function (state) { return state.ui.bannerDismissed; });

    var getAnonymousConsents = i1.createSelector(getAnonymousConsentState, function (state) { return state.consents; });
    var getAnonymousConsentByTemplateCode = function (templateCode) { return i1.createSelector(getAnonymousConsents, function (consents) { return consents.find(function (consent) { return consent.templateCode === templateCode; }); }); };

    var anonymousConsentsGroup_selectors = /*#__PURE__*/Object.freeze({
        __proto__: null,
        getAnonymousConsentTemplatesState: getAnonymousConsentTemplatesState,
        getAnonymousConsentTemplatesValue: getAnonymousConsentTemplatesValue,
        getAnonymousConsentTemplatesLoading: getAnonymousConsentTemplatesLoading,
        getAnonymousConsentTemplatesSuccess: getAnonymousConsentTemplatesSuccess,
        getAnonymousConsentTemplatesError: getAnonymousConsentTemplatesError,
        getAnonymousConsentTemplate: getAnonymousConsentTemplate,
        getAnonymousConsentTemplatesUpdate: getAnonymousConsentTemplatesUpdate,
        getAnonymousConsentsBannerDismissed: getAnonymousConsentsBannerDismissed,
        getAnonymousConsents: getAnonymousConsents,
        getAnonymousConsentByTemplateCode: getAnonymousConsentByTemplateCode,
        getAnonymousConsentState: getAnonymousConsentState
    });

    var OCC_USER_ID_CURRENT = 'current';
    var OCC_USER_ID_ANONYMOUS = 'anonymous';
    var OCC_USER_ID_GUEST = 'guest';
    var OCC_CART_ID_CURRENT = 'current';

    var LOGIN = '[Auth] Login';
    var LOGOUT = '[Auth] Logout';
    var Login = /** @class */ (function () {
        function Login() {
            this.type = LOGIN;
        }
        return Login;
    }());
    var Logout = /** @class */ (function () {
        function Logout() {
            this.type = LOGOUT;
        }
        return Logout;
    }());

    var authGroup_actions = /*#__PURE__*/Object.freeze({
        __proto__: null,
        LOGIN: LOGIN,
        LOGOUT: LOGOUT,
        Login: Login,
        Logout: Logout
    });

    /**
     * This implementation is OCC specific.
     * Different backend might have completely different need regarding user id.
     * It might not need user id at all and work based on access_token.
     * To implement custom solution provide your own implementation and customize services that use UserIdService
     */
    var UserIdService = /** @class */ (function () {
        function UserIdService() {
            this._userId = new rxjs.ReplaySubject(1);
        }
        /**
         * Sets current user id.
         *
         * @param userId
         */
        UserIdService.prototype.setUserId = function (userId) {
            this._userId.next(userId);
        };
        /**
         * This function provides the userId the OCC calls should use, depending
         * on whether there is an active storefront session or not.
         *
         * It returns the userId of the current storefront user or 'anonymous'
         * in the case there are no signed in user in the storefront.
         *
         * The user id of a regular customer session is 'current'. In the case of an
         * asm customer emulation session, the userId will be the customerId.
         */
        UserIdService.prototype.getUserId = function () {
            return this._userId;
        };
        /**
         * Utility method if you need userId to perform single action (eg. dispatch call to API).
         *
         * @param loggedIn Set to true if you want the observable to emit id only for logged in user. Throws in case of anonymous user.
         *
         * @returns Observable that emits once and completes with the last userId value.
         */
        UserIdService.prototype.takeUserId = function (loggedIn) {
            if (loggedIn === void 0) { loggedIn = false; }
            return this.getUserId().pipe(operators.take(1), operators.map(function (userId) {
                if (loggedIn && userId === OCC_USER_ID_ANONYMOUS) {
                    throw new Error('Requested user id for logged user while user is not logged in.');
                }
                return userId;
            }));
        };
        /**
         * Sets user id to the default value for logged out user.
         */
        UserIdService.prototype.clearUserId = function () {
            this.setUserId(OCC_USER_ID_ANONYMOUS);
        };
        /**
         * Checks if the userId is of emulated user type.
         */
        UserIdService.prototype.isEmulated = function () {
            return this.getUserId().pipe(operators.map(function (userId) { return userId !== OCC_USER_ID_ANONYMOUS && userId !== OCC_USER_ID_CURRENT; }));
        };
        return UserIdService;
    }());
    UserIdService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserIdService, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    UserIdService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserIdService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserIdService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }] });

    /**
     * Supported OAuth flows.
     */
    exports.OAuthFlow = void 0;
    (function (OAuthFlow) {
        /**
         * Flow when username and password is passed to the application and then the application through API fetches tokens from OAuth server.
         */
        OAuthFlow[OAuthFlow["ResourceOwnerPasswordFlow"] = 0] = "ResourceOwnerPasswordFlow";
        /**
         * Flow with redirect to OAuth server where user inputs credentials and the are redirected back with token.
         */
        OAuthFlow[OAuthFlow["ImplicitFlow"] = 1] = "ImplicitFlow";
        /**
         * Similar to Implicit flow, but user is redirected with code that need to later exchange through API for a token.
         */
        OAuthFlow[OAuthFlow["AuthorizationCode"] = 2] = "AuthorizationCode";
    })(exports.OAuthFlow || (exports.OAuthFlow = {}));

    var AuthConfig = /** @class */ (function () {
        function AuthConfig() {
        }
        return AuthConfig;
    }());
    AuthConfig.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AuthConfig, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    AuthConfig.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AuthConfig, providedIn: 'root', useExisting: Config });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AuthConfig, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                        useExisting: Config,
                    }]
            }] });

    var SiteContextConfig = /** @class */ (function () {
        function SiteContextConfig() {
        }
        return SiteContextConfig;
    }());
    SiteContextConfig.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SiteContextConfig, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    SiteContextConfig.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SiteContextConfig, providedIn: 'root', useExisting: Config });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SiteContextConfig, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                        useExisting: Config,
                    }]
            }] });

    var OccConfig = /** @class */ (function (_super) {
        __extends(OccConfig, _super);
        function OccConfig() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return OccConfig;
    }(SiteContextConfig));
    OccConfig.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccConfig, deps: null, target: i0__namespace.ɵɵFactoryTarget.Injectable });
    OccConfig.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccConfig, providedIn: 'root', useExisting: Config });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccConfig, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                        useExisting: Config,
                    }]
            }] });

    /**
     * Utility service on top of the authorization config.
     * Provides handy defaults, when not everything is set in the configuration.
     * Use this service instead of direct configuration.
     */
    var AuthConfigService = /** @class */ (function () {
        function AuthConfigService(authConfig, occConfig) {
            this.authConfig = authConfig;
            this.occConfig = occConfig;
        }
        Object.defineProperty(AuthConfigService.prototype, "config", {
            /**
             * Utility to make access to authentication config easier.
             */
            get: function () {
                var _a, _b;
                return (_b = (_a = this.authConfig) === null || _a === void 0 ? void 0 : _a.authentication) !== null && _b !== void 0 ? _b : {};
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Get client_id
         *
         * @return client_id
         */
        AuthConfigService.prototype.getClientId = function () {
            var _a;
            return (_a = this.config.client_id) !== null && _a !== void 0 ? _a : '';
        };
        /**
         * Get client_secret. OAuth server shouldn't require it from web apps (but Hybris OAuth server requires).
         *
         * @return client_secret
         */
        AuthConfigService.prototype.getClientSecret = function () {
            var _a;
            return (_a = this.config.client_secret) !== null && _a !== void 0 ? _a : '';
        };
        /**
         * Returns base url of the authorization server
         */
        AuthConfigService.prototype.getBaseUrl = function () {
            var _a, _b, _c, _d, _e;
            return ((_a = this.config.baseUrl) !== null && _a !== void 0 ? _a : ((_e = (_d = (_c = (_b = this.occConfig) === null || _b === void 0 ? void 0 : _b.backend) === null || _c === void 0 ? void 0 : _c.occ) === null || _d === void 0 ? void 0 : _d.baseUrl) !== null && _e !== void 0 ? _e : '') + '/authorizationserver');
        };
        /**
         * Returns endpoint for getting the auth token
         */
        AuthConfigService.prototype.getTokenEndpoint = function () {
            var _a;
            var tokenEndpoint = (_a = this.config.tokenEndpoint) !== null && _a !== void 0 ? _a : '';
            return this.prefixEndpoint(tokenEndpoint);
        };
        /**
         * Returns url for redirect to the authorization server to get token/code
         */
        AuthConfigService.prototype.getLoginUrl = function () {
            var _a;
            var loginUrl = (_a = this.config.loginUrl) !== null && _a !== void 0 ? _a : '';
            return this.prefixEndpoint(loginUrl);
        };
        /**
         * Returns endpoint for token revocation (both access and refresh token).
         */
        AuthConfigService.prototype.getRevokeEndpoint = function () {
            var _a;
            var revokeEndpoint = (_a = this.config.revokeEndpoint) !== null && _a !== void 0 ? _a : '';
            return this.prefixEndpoint(revokeEndpoint);
        };
        /**
         * Returns logout url to redirect to on logout.
         */
        AuthConfigService.prototype.getLogoutUrl = function () {
            var _a;
            var logoutUrl = (_a = this.config.logoutUrl) !== null && _a !== void 0 ? _a : '';
            return this.prefixEndpoint(logoutUrl);
        };
        /**
         * Returns userinfo endpoint of the OAuth server.
         */
        AuthConfigService.prototype.getUserinfoEndpoint = function () {
            var _a;
            var userinfoEndpoint = (_a = this.config.userinfoEndpoint) !== null && _a !== void 0 ? _a : '';
            return this.prefixEndpoint(userinfoEndpoint);
        };
        /**
         * Returns configuration specific for the angular-oauth2-oidc library.
         */
        AuthConfigService.prototype.getOAuthLibConfig = function () {
            var _a;
            return (_a = this.config.OAuthLibConfig) !== null && _a !== void 0 ? _a : {};
        };
        AuthConfigService.prototype.prefixEndpoint = function (endpoint) {
            var url = endpoint;
            if (!url.startsWith('/')) {
                url = '/' + url;
            }
            return "" + this.getBaseUrl() + url;
        };
        /**
         * Returns the type of the OAuth flow based on auth config.
         * Use when you have to perform particular action only in some of the OAuth flow scenarios.
         */
        AuthConfigService.prototype.getOAuthFlow = function () {
            var _a;
            var responseType = (_a = this.config.OAuthLibConfig) === null || _a === void 0 ? void 0 : _a.responseType;
            if (responseType) {
                var types = responseType.split(' ');
                if (types.includes('code')) {
                    return exports.OAuthFlow.AuthorizationCode;
                }
                else if (types.includes('token')) {
                    return exports.OAuthFlow.ImplicitFlow;
                }
                else {
                    return exports.OAuthFlow.ResourceOwnerPasswordFlow;
                }
            }
            return exports.OAuthFlow.ResourceOwnerPasswordFlow;
        };
        return AuthConfigService;
    }());
    AuthConfigService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AuthConfigService, deps: [{ token: AuthConfig }, { token: OccConfig }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    AuthConfigService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AuthConfigService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AuthConfigService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: AuthConfig }, { type: OccConfig }]; } });

    /**
     * The url of the server request when running SSR
     * */
    var SERVER_REQUEST_URL = new i0.InjectionToken('SERVER_REQUEST_URL');
    /**
     * The url of the server request host when running SSR
     * */
    var SERVER_REQUEST_ORIGIN = new i0.InjectionToken('SERVER_REQUEST_ORIGIN');

    var WindowRef = /** @class */ (function () {
        function WindowRef(
        // https://github.com/angular/angular/issues/20351
        document, platformId, serverUrl, serverOrigin) {
            this.platformId = platformId;
            this.serverUrl = serverUrl;
            this.serverOrigin = serverOrigin;
            this.document = document;
        }
        /**
         * Returns true when invoked in browser context.
         * Use this method to check if you can access `window` and other browser globals.
         */
        WindowRef.prototype.isBrowser = function () {
            return i6.isPlatformBrowser(this.platformId);
        };
        Object.defineProperty(WindowRef.prototype, "nativeWindow", {
            /**
             * Exposes global `window` object. In SSR when `window` is not available it returns `undefined`.
             * To detect if you can safely use `nativeWindow` use `isBrowser` to check execution platform.
             */
            get: function () {
                // TODO(#11133): Consider throwing in SSR
                return this.isBrowser() ? window : undefined;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(WindowRef.prototype, "sessionStorage", {
            /**
             * Exposes global `sessionStorage` object. In SSR when `sessionStorage` is not available it returns `undefined`.
             * To detect if you can safely use `sessionStorage` use `isBrowser` to check execution platform.
             */
            get: function () {
                return this.nativeWindow ? this.nativeWindow.sessionStorage : undefined;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(WindowRef.prototype, "localStorage", {
            /**
             * Exposes global `localStorage` object. In SSR when `localStorage` is not available it returns `undefined`.
             * To detect if you can safely use `localStorage` use `isBrowser` to check execution platform.
             */
            get: function () {
                return this.nativeWindow ? this.nativeWindow.localStorage : undefined;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(WindowRef.prototype, "location", {
            /**
             * Returns the window/document location, unless it's not available (i.e. SSR).
             *
             * When there's no access to the location object, we mimic the location partially, by resolving
             * the request url (`SERVER_REQUEST_URL`) and origin (`SERVER_REQUEST_ORIGIN`) from the injector.
             * These values are injected in the server implementation so that we can resolve some of the location
             * values when we do server side rendering.
             */
            get: function () {
                if (this.isBrowser()) {
                    return this.document.location;
                }
                else {
                    if (!this.serverUrl) {
                        throw new Error('Cannot resolve the href as the SERVER_REQUEST_URL is undefined');
                    }
                    if (!this.serverOrigin) {
                        throw new Error('Cannot resolve the origin as the SERVER_REQUEST_ORIGIN is undefined');
                    }
                    return {
                        href: this.serverUrl,
                        origin: this.serverOrigin,
                    };
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(WindowRef.prototype, "resize$", {
            /**
             * Returns an observable for the window resize event and emits an event
             * every 300ms in case of resizing. An event is simulated initially.
             *
             * If there's no window object available (i.e. in SSR), a null value is emitted.
             */
            get: function () {
                if (!this.nativeWindow) {
                    return rxjs.of(null);
                }
                else {
                    return rxjs.fromEvent(this.nativeWindow, 'resize').pipe(operators.debounceTime(300), operators.startWith({ target: this.nativeWindow }), operators.distinctUntilChanged());
                }
            },
            enumerable: false,
            configurable: true
        });
        return WindowRef;
    }());
    WindowRef.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: WindowRef, deps: [{ token: i6.DOCUMENT }, { token: i0.PLATFORM_ID }, { token: SERVER_REQUEST_URL, optional: true }, { token: SERVER_REQUEST_ORIGIN, optional: true }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    WindowRef.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: WindowRef, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: WindowRef, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () {
            return [{ type: undefined, decorators: [{
                            type: i0.Inject,
                            args: [i6.DOCUMENT]
                        }] }, { type: Object, decorators: [{
                            type: i0.Inject,
                            args: [i0.PLATFORM_ID]
                        }] }, { type: undefined, decorators: [{
                            type: i0.Optional
                        }, {
                            type: i0.Inject,
                            args: [SERVER_REQUEST_URL]
                        }] }, { type: undefined, decorators: [{
                            type: i0.Optional
                        }, {
                            type: i0.Inject,
                            args: [SERVER_REQUEST_ORIGIN]
                        }] }];
        } });

    /**
     * Wrapper service on the library OAuthService. Normalizes the lib API for services.
     * Use this service when you want to access low level OAuth library methods.
     */
    var OAuthLibWrapperService = /** @class */ (function () {
        // TODO: Remove platformId dependency in 4.0
        function OAuthLibWrapperService(oAuthService, authConfigService, platformId, winRef) {
            this.oAuthService = oAuthService;
            this.authConfigService = authConfigService;
            this.platformId = platformId;
            this.winRef = winRef;
            this.events$ = this.oAuthService.events;
            this.initialize();
        }
        OAuthLibWrapperService.prototype.initialize = function () {
            var _a, _b, _c, _d;
            var isSSR = !this.winRef.isBrowser();
            this.oAuthService.configure(Object.assign({ tokenEndpoint: this.authConfigService.getTokenEndpoint(), loginUrl: this.authConfigService.getLoginUrl(), clientId: this.authConfigService.getClientId(), dummyClientSecret: this.authConfigService.getClientSecret(), revocationEndpoint: this.authConfigService.getRevokeEndpoint(), logoutUrl: this.authConfigService.getLogoutUrl(), userinfoEndpoint: this.authConfigService.getUserinfoEndpoint(), issuer: (_b = (_a = this.authConfigService.getOAuthLibConfig()) === null || _a === void 0 ? void 0 : _a.issuer) !== null && _b !== void 0 ? _b : this.authConfigService.getBaseUrl(), redirectUri: (_d = (_c = this.authConfigService.getOAuthLibConfig()) === null || _c === void 0 ? void 0 : _c.redirectUri) !== null && _d !== void 0 ? _d : (!isSSR
                    ? // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                        this.winRef.nativeWindow.location.origin
                    : '') }, this.authConfigService.getOAuthLibConfig()));
        };
        /**
         * Authorize with ResourceOwnerPasswordFlow.
         *
         * @param userId
         * @param password
         *
         * @return token response from the lib
         */
        OAuthLibWrapperService.prototype.authorizeWithPasswordFlow = function (userId, password) {
            return this.oAuthService.fetchTokenUsingPasswordFlow(userId, password);
        };
        /**
         * Refresh access_token.
         */
        OAuthLibWrapperService.prototype.refreshToken = function () {
            this.oAuthService.refreshToken();
        };
        /**
         * Revoke access tokens and clear tokens in lib state.
         */
        OAuthLibWrapperService.prototype.revokeAndLogout = function () {
            var _this = this;
            return new Promise(function (resolve) {
                _this.oAuthService
                    .revokeTokenAndLogout()
                    .catch(function () {
                    // when there would be some kind of error during revocation we can't do anything else, so at least we logout user.
                    _this.oAuthService.logOut();
                })
                    .finally(function () {
                    resolve();
                });
            });
        };
        /**
         * Clear tokens in library state (no revocation).
         */
        OAuthLibWrapperService.prototype.logout = function () {
            this.oAuthService.logOut();
        };
        /**
         * Returns Open Id token. Might be empty, when it was not requested with the `responseType` config.
         *
         * @return id token
         */
        OAuthLibWrapperService.prototype.getIdToken = function () {
            return this.oAuthService.getIdToken();
        };
        /**
         * Initialize Implicit Flow or Authorization Code flows with the redirect to OAuth login url.
         */
        OAuthLibWrapperService.prototype.initLoginFlow = function () {
            return this.oAuthService.initLoginFlow();
        };
        /**
         * Tries to login user based on `code` or `token` present in the url.
         */
        OAuthLibWrapperService.prototype.tryLogin = function () {
            return this.oAuthService.tryLogin({
                // We don't load discovery document, because it doesn't contain revoke endpoint information
                disableOAuth2StateCheck: true,
            });
        };
        return OAuthLibWrapperService;
    }());
    OAuthLibWrapperService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OAuthLibWrapperService, deps: [{ token: i1__namespace.OAuthService }, { token: AuthConfigService }, { token: i0.PLATFORM_ID }, { token: WindowRef }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    OAuthLibWrapperService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OAuthLibWrapperService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OAuthLibWrapperService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () {
            return [{ type: i1__namespace.OAuthService }, { type: AuthConfigService }, { type: Object, decorators: [{
                            type: i0.Inject,
                            args: [i0.PLATFORM_ID]
                        }] }, { type: WindowRef }];
        } });

    /**
     * Storage service for AuthToken. Used as a storage for angular-oauth2-oidc library.
     */
    var AuthStorageService = /** @class */ (function (_super) {
        __extends(AuthStorageService, _super);
        function AuthStorageService() {
            var _this = _super.apply(this, __spreadArray([], __read(arguments))) || this;
            _this._token$ = new rxjs.BehaviorSubject({});
            return _this;
        }
        AuthStorageService.prototype.decode = function (key, value) {
            if (AuthStorageService.nonStringifiedOAuthLibKeys.includes(key)) {
                return value;
            }
            return JSON.stringify(value);
        };
        AuthStorageService.prototype.encode = function (key, value) {
            if (AuthStorageService.nonStringifiedOAuthLibKeys.includes(key)) {
                return value;
            }
            else {
                try {
                    return JSON.parse(value);
                }
                catch (_a) {
                    return value;
                }
            }
        };
        /* Async API for spartacus use */
        /**
         * Returns complete token (all fields).
         *
         * @return observable emitting AuthToken
         */
        AuthStorageService.prototype.getToken = function () {
            return this._token$;
        };
        /**
         * Set current value of token.
         *
         * @param token
         */
        AuthStorageService.prototype.setToken = function (token) {
            this._token$.next(token);
        };
        /* Sync API for OAuth lib use */
        /**
         * Get parameter from the token (eg. access_token)
         *
         * @param key
         */
        AuthStorageService.prototype.getItem = function (key) {
            var token;
            this.getToken()
                .subscribe(function (currentToken) { return (token = currentToken); })
                .unsubscribe();
            return this.decode(key, token === null || token === void 0 ? void 0 : token[key]);
        };
        /**
         * Removes parameter from the token (eg. access_token)
         *
         * @param key
         */
        AuthStorageService.prototype.removeItem = function (key) {
            var val = Object.assign({}, this._token$.value);
            delete val[key];
            this._token$.next(Object.assign({}, val));
        };
        /**
         * Sets parameter of the token (eg. access_token)
         *
         * @param key
         */
        AuthStorageService.prototype.setItem = function (key, data) {
            var _b;
            if (key) {
                this._token$.next(Object.assign(Object.assign({}, this._token$.value), (_b = {}, _b[key] = this.encode(key, data), _b)));
            }
        };
        return AuthStorageService;
    }(i1$1.OAuthStorage));
    /**
     * Extracted keys that are not `JSON.stringify` from reading the angular-oauth2-oidc source code
     */
    AuthStorageService.nonStringifiedOAuthLibKeys = [
        'PKCE_verifier',
        'access_token',
        'refresh_token',
        'expires_at',
        'access_token_stored_at',
        'id_token',
        'id_token_expires_at',
        'id_token_stored_at',
        'session_state',
        'nonce',
    ];
    AuthStorageService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AuthStorageService, deps: null, target: i0__namespace.ɵɵFactoryTarget.Injectable });
    AuthStorageService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AuthStorageService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AuthStorageService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }] });

    var CHANGE_NEXT_PAGE_CONTEXT = '[Router] Change Next PageContext';
    var ChangeNextPageContext = /** @class */ (function () {
        function ChangeNextPageContext(payload) {
            this.payload = payload;
            this.type = CHANGE_NEXT_PAGE_CONTEXT;
        }
        return ChangeNextPageContext;
    }());

    var routingGroup_actions = /*#__PURE__*/Object.freeze({
        __proto__: null,
        CHANGE_NEXT_PAGE_CONTEXT: CHANGE_NEXT_PAGE_CONTEXT,
        ChangeNextPageContext: ChangeNextPageContext
    });

    var ROUTING_FEATURE = 'router';

    var getRouterFeatureState = i1.createFeatureSelector(ROUTING_FEATURE);
    var getRouterState = i1.createSelector(getRouterFeatureState, function (state) { return state.router; });
    var getSemanticRoute = i1.createSelector(getRouterState, function (routingState) { return (routingState.state && routingState.state.semanticRoute) || ''; });
    var getPageContext = i1.createSelector(getRouterState, function (routingState) { return (routingState.state && routingState.state.context) || { id: '' }; });
    var getNextPageContext = i1.createSelector(getRouterState, function (routingState) { return routingState.nextState && routingState.nextState.context; });
    var isNavigating = i1.createSelector(getNextPageContext, function (context) { return !!context; });

    var routingGroup_selectors = /*#__PURE__*/Object.freeze({
        __proto__: null,
        getRouterFeatureState: getRouterFeatureState,
        getRouterState: getRouterState,
        getSemanticRoute: getSemanticRoute,
        getPageContext: getPageContext,
        getNextPageContext: getNextPageContext,
        isNavigating: isNavigating
    });

    var isParam = function (segment) { return segment.startsWith(':'); };
    var getParamName = function (segment) { return segment.slice(1); }; // it just removes leading ':'
    var ensureLeadingSlash = function (path) { return path.startsWith('/') ? path : '/' + path; };
    var removeLeadingSlash = function (path) { return path.startsWith('/') ? path.slice(1) : path; };

    var RoutingConfig = /** @class */ (function () {
        function RoutingConfig() {
        }
        return RoutingConfig;
    }());
    RoutingConfig.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: RoutingConfig, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    RoutingConfig.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: RoutingConfig, providedIn: 'root', useExisting: Config });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: RoutingConfig, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                        useExisting: Config,
                    }]
            }] });

    var RoutingConfigService = /** @class */ (function () {
        function RoutingConfigService(config) {
            this.config = config;
        }
        /**
         * Returns the route config for the given route name.
         */
        RoutingConfigService.prototype.getRouteConfig = function (routeName) {
            var _a, _b;
            var routeConfig = (_b = (_a = this.config) === null || _a === void 0 ? void 0 : _a.routing) === null || _b === void 0 ? void 0 : _b.routes;
            var result = routeConfig && routeConfig[routeName];
            if (!routeConfig || result === undefined) {
                this.warn("No path was configured for the named route '" + routeName + "'!");
            }
            return result;
        };
        RoutingConfigService.prototype.warn = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            if (i0.isDevMode()) {
                console.warn.apply(console, __spreadArray([], __read(args)));
            }
        };
        /**
         * Returns the configured route loading strategy.
         */
        RoutingConfigService.prototype.getLoadStrategy = function () {
            var _a, _b, _c;
            return (_c = (_b = (_a = this.config) === null || _a === void 0 ? void 0 : _a.routing) === null || _b === void 0 ? void 0 : _b.loadStrategy) !== null && _c !== void 0 ? _c : "always" /* ALWAYS */;
        };
        /**
         * Returns the route name of the configured path.
         *
         * For example, when the config is:
         * ```
         * routing: {
         *   routes: {
         *      addressBook: { paths: ['my-account/address-book'] }
         *   }
         * }
         * ```
         *
         * the `getRouteName('my-account/address-book')` returns `'addressBook'`.
         */
        RoutingConfigService.prototype.getRouteName = function (path) {
            if (!this.routeNamesByPath) {
                this.initRouteNamesByPath();
            }
            return this.routeNamesByPath[path];
        };
        /**
         * Initializes the property `routeNamesByPath`.
         *
         * The original config allows for reading configured path by the route name.
         * But this method builds up a structure with a 'reversed config'
         * to read quickly the route name by the path.
         */
        RoutingConfigService.prototype.initRouteNamesByPath = function () {
            var e_1, _d;
            var _this = this;
            var _a, _b, _c;
            this.routeNamesByPath = {};
            var _loop_1 = function (routeName, routeConfig) {
                (_c = routeConfig === null || routeConfig === void 0 ? void 0 : routeConfig.paths) === null || _c === void 0 ? void 0 : _c.forEach(function (path) {
                    if (i0.isDevMode() && _this.routeNamesByPath[path]) {
                        console.error("The same path '" + path + "' is configured for two different route names: '" + _this.routeNamesByPath[path] + "' and '" + routeName);
                    }
                    _this.routeNamesByPath[path] = routeName;
                });
            };
            try {
                for (var _e = __values(Object.entries((_b = (_a = this.config) === null || _a === void 0 ? void 0 : _a.routing) === null || _b === void 0 ? void 0 : _b.routes)), _f = _e.next(); !_f.done; _f = _e.next()) {
                    var _g = __read(_f.value, 2), routeName = _g[0], routeConfig = _g[1];
                    _loop_1(routeName, routeConfig);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_f && !_f.done && (_d = _e.return)) _d.call(_e);
                }
                finally { if (e_1) throw e_1.error; }
            }
        };
        return RoutingConfigService;
    }());
    RoutingConfigService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: RoutingConfigService, deps: [{ token: RoutingConfig }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    RoutingConfigService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: RoutingConfigService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: RoutingConfigService, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }], ctorParameters: function () { return [{ type: RoutingConfig }]; } });

    var UrlParsingService = /** @class */ (function () {
        function UrlParsingService(router) {
            this.router = router;
        }
        UrlParsingService.prototype.getPrimarySegments = function (url) {
            var urlTree = this.router.parseUrl(url);
            return this._getPrimarySegmentsFromUrlTree(urlTree.root);
        };
        UrlParsingService.prototype._getPrimarySegmentsFromUrlTree = function (tree) {
            var segments = tree.segments.map(function (s) { return s.path; });
            var childrenSegments = tree.children[i1$2.PRIMARY_OUTLET]
                ? this._getPrimarySegmentsFromUrlTree(tree.children[i1$2.PRIMARY_OUTLET])
                : [];
            return segments.concat(childrenSegments);
        };
        /**
         * Tells whether the given url matches the given path.
         *
         * @param urlSegments   string or array of url segments. When it's a string, the preceding
         *                      site-context params are ignored (i.e. '/electronics-spa/en/USD/...')
         *
         * @param pathSegments  string or array of path segments. Dynamic params are allowed in the
         *                      path shape, i.e. `/url/:param1/with/:param2`.
         */
        UrlParsingService.prototype.matchPath = function (urlSegments, pathSegments) {
            urlSegments = Array.isArray(urlSegments)
                ? urlSegments
                : this.getPrimarySegments(urlSegments);
            pathSegments = Array.isArray(pathSegments)
                ? pathSegments
                : this.getPrimarySegments(pathSegments);
            if (urlSegments.length !== pathSegments.length) {
                return false;
            }
            for (var i = 0; i < pathSegments.length; i++) {
                var pathSeg = pathSegments[i];
                var urlSeg = urlSegments[i];
                // compare only static segments:
                if (!isParam(pathSeg) && pathSeg !== urlSeg) {
                    return false;
                }
            }
            return true;
        };
        return UrlParsingService;
    }());
    UrlParsingService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UrlParsingService, deps: [{ token: i1__namespace$1.Router }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    UrlParsingService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UrlParsingService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UrlParsingService, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }], ctorParameters: function () { return [{ type: i1__namespace$1.Router }]; } });

    var SemanticPathService = /** @class */ (function () {
        function SemanticPathService(routingConfigService, urlParser) {
            this.routingConfigService = routingConfigService;
            this.urlParser = urlParser;
            this.ROOT_URL = ['/'];
        }
        /**
         * Returns the first path alias configured for a given route name. It adds `/` at the beginning.
         */
        SemanticPathService.prototype.get = function (routeName) {
            var routeConfig = this.routingConfigService.getRouteConfig(routeName);
            return routeConfig && Array.isArray(routeConfig.paths)
                ? '/' + routeConfig.paths[0]
                : undefined;
        };
        /**
         * Transforms the array of url commands. Each command can be:
         * a) string - will be left untouched
         * b) object { cxRoute: <route name> } - will be replaced with semantic path
         * c) object { cxRoute: <route name>, params: { ... } } - same as above, but with passed params
         *
         * If the first command is the object with the `cxRoute` property, returns an absolute url (with the first element of the array `'/'`)
         */
        SemanticPathService.prototype.transform = function (commands) {
            var e_1, _a;
            if (!Array.isArray(commands)) {
                commands = [commands];
            }
            var result = [];
            try {
                for (var commands_1 = __values(commands), commands_1_1 = commands_1.next(); !commands_1_1.done; commands_1_1 = commands_1.next()) {
                    var command = commands_1_1.value;
                    if (!this.isRouteCommand(command)) {
                        // don't modify segment that is not route command:
                        result.push(command);
                    }
                    else {
                        // generate array with url segments for given route command:
                        var partialResult = this.generateUrlPart(command);
                        if (partialResult === null) {
                            return this.ROOT_URL;
                        }
                        result.push.apply(result, __spreadArray([], __read(partialResult)));
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (commands_1_1 && !commands_1_1.done && (_a = commands_1.return)) _a.call(commands_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            if (this.shouldOutputAbsolute(commands)) {
                result.unshift('/');
            }
            return result;
        };
        SemanticPathService.prototype.isRouteCommand = function (command) {
            return command && Boolean(command.cxRoute);
        };
        SemanticPathService.prototype.shouldOutputAbsolute = function (commands) {
            return this.isRouteCommand(commands[0]);
        };
        SemanticPathService.prototype.generateUrlPart = function (command) {
            this.standarizeRouteCommand(command);
            if (!command.cxRoute) {
                return null;
            }
            var routeConfig = this.routingConfigService.getRouteConfig(command.cxRoute);
            // if no route translation was configured, return null:
            if (!routeConfig || !routeConfig.paths) {
                return null;
            }
            // find first path that can satisfy it's parameters with given parameters
            var path = this.findPathWithFillableParams(routeConfig, command.params);
            // if there is no configured path that can be satisfied with given params, return null
            if (!path) {
                return null;
            }
            var result = this.provideParamsValues(path, command.params, routeConfig.paramsMapping);
            return result;
        };
        SemanticPathService.prototype.standarizeRouteCommand = function (command) {
            command.params = command.params || {};
        };
        SemanticPathService.prototype.provideParamsValues = function (path, params, paramsMapping) {
            var _this = this;
            return this.urlParser.getPrimarySegments(path).map(function (segment) {
                if (isParam(segment)) {
                    var paramName = getParamName(segment);
                    var mappedParamName = _this.getMappedParamName(paramName, paramsMapping);
                    return params[mappedParamName];
                }
                return segment;
            });
        };
        SemanticPathService.prototype.findPathWithFillableParams = function (routeConfig, params) {
            var _this = this;
            var foundPath = routeConfig.paths.find(function (path) { return _this.getParams(path).every(function (paramName) {
                var mappedParamName = _this.getMappedParamName(paramName, routeConfig.paramsMapping);
                return params[mappedParamName] !== undefined;
            }); });
            if (foundPath === undefined || foundPath === null) {
                return null;
            }
            return foundPath;
        };
        SemanticPathService.prototype.getParams = function (path) {
            return this.urlParser
                .getPrimarySegments(path)
                .filter(isParam)
                .map(getParamName);
        };
        SemanticPathService.prototype.getMappedParamName = function (paramName, paramsMapping) {
            if (paramsMapping) {
                return paramsMapping[paramName] || paramName;
            }
            return paramName;
        };
        return SemanticPathService;
    }());
    SemanticPathService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SemanticPathService, deps: [{ token: RoutingConfigService }, { token: UrlParsingService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    SemanticPathService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SemanticPathService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SemanticPathService, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }], ctorParameters: function () { return [{ type: RoutingConfigService }, { type: UrlParsingService }]; } });

    /**
     * Helper service to expose all activated routes
     */
    var ActivatedRoutesService = /** @class */ (function () {
        function ActivatedRoutesService(router) {
            var _this = this;
            this.router = router;
            /**
             * Array of currently activated routes (from the root route to the leaf route).
             */
            this.routes$ = this.router.events.pipe(operators.filter(function (event) { return event instanceof i1$2.NavigationEnd; }), 
            // eslint-disable-next-line import/no-deprecated
            operators.startWith(undefined), // emit value for consumer who subscribed lately after NavigationEnd event
            operators.map(function () {
                var route = _this.router.routerState.snapshot.root;
                var routes = [route];
                // traverse to the leaf route:
                while ((route = route.firstChild)) {
                    routes.push(route);
                }
                return routes;
            }), operators.shareReplay({ bufferSize: 1, refCount: true }));
        }
        return ActivatedRoutesService;
    }());
    ActivatedRoutesService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ActivatedRoutesService, deps: [{ token: i1__namespace$1.Router }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ActivatedRoutesService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ActivatedRoutesService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ActivatedRoutesService, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }], ctorParameters: function () { return [{ type: i1__namespace$1.Router }]; } });

    /**
     * Service to expose all parameters for the router, including child routes.
     * This is convenient in case the parent route (component) requires awareness
     * of child routes parameters.
     */
    var RoutingParamsService = /** @class */ (function () {
        function RoutingParamsService(router, activatedRoutesService) {
            var _this = this;
            this.router = router;
            this.activatedRoutesService = activatedRoutesService;
            this.params$ = this.activatedRoutesService.routes$.pipe(operators.map(function (routes) { return _this.findAllParam(routes); }), operators.shareReplay({ refCount: true, bufferSize: 1 }));
        }
        /**
         * Get the list of all parameters of the full route. This includes
         * active child routes.
         */
        RoutingParamsService.prototype.getParams = function () {
            return this.params$;
        };
        RoutingParamsService.prototype.findAllParam = function (routes) {
            return Object.assign.apply(Object, __spreadArray([{}], __read(routes.map(function (route) { return route.params; }))));
        };
        return RoutingParamsService;
    }());
    RoutingParamsService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: RoutingParamsService, deps: [{ token: i1__namespace$1.Router }, { token: ActivatedRoutesService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    RoutingParamsService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: RoutingParamsService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: RoutingParamsService, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }], ctorParameters: function () { return [{ type: i1__namespace$1.Router }, { type: ActivatedRoutesService }]; } });

    var RoutingService = /** @class */ (function () {
        function RoutingService(store, winRef, semanticPathService, routingParamsService, router, location) {
            this.store = store;
            this.winRef = winRef;
            this.semanticPathService = semanticPathService;
            this.routingParamsService = routingParamsService;
            this.router = router;
            this.location = location;
        }
        /**
         * Get the list of all parameters of the full route. This includes
         * active child routes.
         */
        RoutingService.prototype.getParams = function () {
            var _a;
            return (_a = this.routingParamsService) === null || _a === void 0 ? void 0 : _a.getParams();
        };
        /**
         * Get the current router state
         */
        RoutingService.prototype.getRouterState = function () {
            return this.store.pipe(i1.select(getRouterState));
        };
        /**
         * Get the `PageContext` from the state
         */
        RoutingService.prototype.getPageContext = function () {
            return this.store.pipe(i1.select(getPageContext));
        };
        /**
         * Get the next `PageContext` from the state
         */
        RoutingService.prototype.getNextPageContext = function () {
            return this.store.pipe(i1.select(getNextPageContext));
        };
        /**
         * Allow to change next page context for the ongoing navigation
         *
         * @param pageContext
         */
        RoutingService.prototype.changeNextPageContext = function (pageContext) {
            this.store.dispatch(new ChangeNextPageContext(pageContext));
        };
        /**
         * Get the `isNavigating` info from the state
         */
        RoutingService.prototype.isNavigating = function () {
            return this.store.pipe(i1.select(isNavigating));
        };
        /**
         * Navigation with a new state into history
         * @param commands: url commands
         * @param extras: Represents the extra options used during navigation.
         *
         * @returns Promise that resolves to `true` when navigation succeeds,
         *          to `false` when navigation fails, or is rejected on error.
         */
        RoutingService.prototype.go = function (commands, extras) {
            var path = this.semanticPathService.transform(commands);
            return this.navigate(path, extras);
        };
        /**
         * Resolves the relative url for the given `UrlCommands` and `NavigationExtras`.
         *
         * The absolute url can be resolved using `getFullUrl()`.
         */
        RoutingService.prototype.getUrl = function (commands, extras) {
            var url = this.router.serializeUrl(this.router.createUrlTree(this.semanticPathService.transform(commands), extras));
            if (!url.startsWith('/')) {
                url = "/" + url;
            }
            return url;
        };
        /**
         * Returns the absolute url for the given `UrlCommands` and `NavigationExtras`.
         *
         * The absolute url uses the origin of the current location.
         */
        RoutingService.prototype.getFullUrl = function (commands, extras) {
            return "" + this.winRef.document.location.origin + this.getUrl(commands, extras);
        };
        /**
         * Navigation using absolute route path
         * @param url
         * @param extras: Represents the extra options used during navigation.
         *
         * @returns Promise that resolves to `true` when navigation succeeds,
         *          to `false` when navigation fails, or is rejected on error.
         */
        RoutingService.prototype.goByUrl = function (url, extras) {
            return this.router.navigateByUrl(url, extras);
        };
        /**
         * Navigating back
         */
        RoutingService.prototype.back = function () {
            var isLastPageInApp = this.winRef.document.referrer.includes(this.winRef.nativeWindow.location.origin);
            if (isLastPageInApp) {
                this.location.back();
                return;
            }
            this.go(['/']);
            return;
        };
        /**
         * Navigating forward
         */
        RoutingService.prototype.forward = function () {
            this.location.forward();
        };
        /**
         * Navigation with a new state into history
         * @param path
         * @param extras: Represents the extra options used during navigation.
         *
         * @returns Promise that resolves to `true` when navigation succeeds,
         *          to `false` when navigation fails, or is rejected on error.
         */
        RoutingService.prototype.navigate = function (path, extras) {
            return this.router.navigate(path, extras);
        };
        return RoutingService;
    }());
    RoutingService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: RoutingService, deps: [{ token: i1__namespace$2.Store }, { token: WindowRef }, { token: SemanticPathService }, { token: RoutingParamsService }, { token: i1__namespace$1.Router }, { token: i6__namespace.Location }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    RoutingService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: RoutingService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: RoutingService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace$2.Store }, { type: WindowRef }, { type: SemanticPathService }, { type: RoutingParamsService }, { type: i1__namespace$1.Router }, { type: i6__namespace.Location }]; } });

    /**
     * Service serves storage role for AuthRedirectService.
     * Used by AuthStatePersistenceService to store redirect url for OAuth flows that rely on redirects.
     */
    var AuthRedirectStorageService = /** @class */ (function () {
        function AuthRedirectStorageService() {
            this.redirectUrl$ = new rxjs.BehaviorSubject(undefined);
        }
        /**
         * Get redirect url after logging in.
         *
         * @returns observable with the redirect url as string
         */
        AuthRedirectStorageService.prototype.getRedirectUrl = function () {
            return this.redirectUrl$;
        };
        /**
         * Set url to redirect to after login.
         *
         * @param redirectUrl
         */
        AuthRedirectStorageService.prototype.setRedirectUrl = function (redirectUrl) {
            this.redirectUrl$.next(redirectUrl);
        };
        return AuthRedirectStorageService;
    }());
    AuthRedirectStorageService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AuthRedirectStorageService, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    AuthRedirectStorageService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AuthRedirectStorageService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AuthRedirectStorageService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return []; } });

    var AuthFlowRoutesService = /** @class */ (function () {
        function AuthFlowRoutesService(config, urlParsingService) {
            this.config = config;
            this.urlParsingService = urlParsingService;
        }
        Object.defineProperty(AuthFlowRoutesService.prototype, "authFlowPaths", {
            /**
             * List of paths that are part user auth flow
             */
            get: function () {
                var _a, _b;
                if (!this._authFlowPaths) {
                    // extract from the routing config the paths that are part of the user auth flow
                    this._authFlowPaths = Object.values(((_b = (_a = this.config) === null || _a === void 0 ? void 0 : _a.routing) === null || _b === void 0 ? void 0 : _b.routes) || {}).reduce(function (acc, routeConfig) {
                        var _a;
                        return routeConfig.authFlow === true && ((_a = routeConfig.paths) === null || _a === void 0 ? void 0 : _a.length)
                            ? acc.concat(routeConfig === null || routeConfig === void 0 ? void 0 : routeConfig.paths)
                            : acc;
                    }, []);
                }
                return this._authFlowPaths;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Tells whether the given URL is a part of the user auth flow
         */
        AuthFlowRoutesService.prototype.isAuthFlow = function (url) {
            var _this = this;
            return this.authFlowPaths.some(function (path) { return _this.urlParsingService.matchPath(url, path); });
        };
        return AuthFlowRoutesService;
    }());
    AuthFlowRoutesService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AuthFlowRoutesService, deps: [{ token: RoutingConfig }, { token: UrlParsingService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    AuthFlowRoutesService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AuthFlowRoutesService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AuthFlowRoutesService, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }], ctorParameters: function () { return [{ type: RoutingConfig }, { type: UrlParsingService }]; } });

    /**
     * Responsible for saving last accessed page (or attempted) before login and for redirecting to that page after login.
     */
    var AuthRedirectService = /** @class */ (function () {
        /**
         * This service is responsible for remembering the last page before the authentication. "The last page" can be:
         * 1. Just the previously opened page; or
         * 2. The page that we just tried to open, but AuthGuard cancelled it
         *
         * Then, after successful authentication it allows for redirecting to that remembered page via the `redirect()` method.
         *
         * For example:
         * 1. The user opens the product page, then clicks /login link and signs in
         *    -> Then we should redirect to the product page; or
         * 2. The user opens the product page, then he clicks /my-account link,
         *    but is automatically redirected to the login page by the AuthGuard, and he signs in
         *    -> Then we should redirect to the my-account page, not the product page
         */
        function AuthRedirectService(routing, router, authRedirectStorageService, authFlowRoutesService) {
            this.routing = routing;
            this.router = router;
            this.authRedirectStorageService = authRedirectStorageService;
            this.authFlowRoutesService = authFlowRoutesService;
            this.init();
        }
        AuthRedirectService.prototype.init = function () {
            var _this = this;
            this.subscription = this.router.events.subscribe(function (event) {
                if (event instanceof i1$2.NavigationEnd) {
                    _this.setRedirectUrl(event.urlAfterRedirects);
                }
            });
        };
        AuthRedirectService.prototype.ngOnDestroy = function () {
            var _a;
            (_a = this.subscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();
        };
        /**
         * Redirect to saved url (homepage if nothing is saved).
         */
        AuthRedirectService.prototype.redirect = function () {
            var _this = this;
            this.authRedirectStorageService
                .getRedirectUrl()
                .pipe(operators.take(1))
                .subscribe(function (redirectUrl) {
                if (redirectUrl === undefined) {
                    _this.routing.go('/');
                }
                else {
                    _this.routing.goByUrl(redirectUrl);
                }
                _this.clearRedirectUrl();
            });
        };
        /**
         * Saves url of a page that user wanted to access, but wasn't yet logged in.
         *
         * @deprecated since 4.0 - use `saveCurrentNavigationUrl` method instead
         */
        AuthRedirectService.prototype.reportAuthGuard = function () {
            this.saveCurrentNavigationUrl();
        };
        /**
         * Saves the url of the current navigation as the redirect url, unless
         * the url is a part of the user login flow.
         */
        AuthRedirectService.prototype.saveCurrentNavigationUrl = function () {
            var navigation = this.router.getCurrentNavigation();
            if (!(navigation === null || navigation === void 0 ? void 0 : navigation.finalUrl)) {
                return;
            }
            var url = this.router.serializeUrl(navigation.finalUrl);
            this.setRedirectUrl(url);
        };
        /**
         * @deprecated since 4.0 - method not needed anymore. Every visited URL is now
         *                         remembered automatically as redirect URL on NavigationEnd event.
         */
        AuthRedirectService.prototype.reportNotAuthGuard = function () { };
        /**
         * Save the url as the redirect url, unless it's a part of the user login flow.
         */
        AuthRedirectService.prototype.setRedirectUrl = function (url) {
            if (!this.authFlowRoutesService.isAuthFlow(url)) {
                this.authRedirectStorageService.setRedirectUrl(url);
            }
        };
        /**
         * Sets the redirect URL to undefined.
         */
        AuthRedirectService.prototype.clearRedirectUrl = function () {
            this.authRedirectStorageService.setRedirectUrl(undefined);
        };
        return AuthRedirectService;
    }());
    AuthRedirectService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AuthRedirectService, deps: [{ token: RoutingService }, { token: i1__namespace$1.Router }, { token: AuthRedirectStorageService }, { token: AuthFlowRoutesService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    AuthRedirectService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AuthRedirectService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AuthRedirectService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: RoutingService }, { type: i1__namespace$1.Router }, { type: AuthRedirectStorageService }, { type: AuthFlowRoutesService }]; } });

    /**
     * Auth service for normal user authentication.
     * Use to check auth status, login/logout with different OAuth flows.
     */
    var AuthService = /** @class */ (function () {
        function AuthService(store, userIdService, oAuthLibWrapperService, authStorageService, authRedirectService, routingService) {
            this.store = store;
            this.userIdService = userIdService;
            this.oAuthLibWrapperService = oAuthLibWrapperService;
            this.authStorageService = authStorageService;
            this.authRedirectService = authRedirectService;
            this.routingService = routingService;
            /**
             * Indicates whether the access token is being refreshed
             */
            this.refreshInProgress$ = new rxjs.BehaviorSubject(false);
            /**
             * Indicates whether the logout is being performed
             */
            this.logoutInProgress$ = new rxjs.BehaviorSubject(false);
        }
        /**
         * Check params in url and if there is an code/token then try to login with those.
         */
        AuthService.prototype.checkOAuthParamsInUrl = function () {
            return __awaiter(this, void 0, void 0, function () {
                var tokenReceivedEvent, subscription, result, token, _a_1;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            subscription = this.oAuthLibWrapperService.events$
                                .pipe(operators.filter(function (event) { return event.type === 'token_received'; }), operators.take(1))
                                .subscribe(function (event) { return (tokenReceivedEvent = event); });
                            _b.label = 1;
                        case 1:
                            _b.trys.push([1, 3, , 4]);
                            return [4 /*yield*/, this.oAuthLibWrapperService.tryLogin()];
                        case 2:
                            result = _b.sent();
                            token = this.authStorageService.getItem('access_token');
                            // We get the result in the code flow even if we did not logged in that why we also need to check if we have access_token
                            if (result && token) {
                                this.userIdService.setUserId(OCC_USER_ID_CURRENT);
                                this.store.dispatch(new Login());
                                // Only redirect if we have received a token,
                                // otherwise we are not returning from authentication server.
                                if (tokenReceivedEvent) {
                                    this.authRedirectService.redirect();
                                }
                            }
                            return [3 /*break*/, 4];
                        case 3:
                            _a_1 = _b.sent();
                            return [3 /*break*/, 4];
                        case 4:
                            subscription.unsubscribe();
                            return [2 /*return*/];
                    }
                });
            });
        };
        /**
         * Initialize Implicit/Authorization Code flow by redirecting to OAuth server.
         */
        AuthService.prototype.loginWithRedirect = function () {
            this.oAuthLibWrapperService.initLoginFlow();
            return true;
        };
        /**
         * Loads a new user token with Resource Owner Password Flow.
         * @param userId
         * @param password
         */
        AuthService.prototype.loginWithCredentials = function (userId, password) {
            return __awaiter(this, void 0, void 0, function () {
                var _a_2;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            _b.trys.push([0, 2, , 3]);
                            return [4 /*yield*/, this.oAuthLibWrapperService.authorizeWithPasswordFlow(userId, password)];
                        case 1:
                            _b.sent();
                            // OCC specific user id handling. Customize when implementing different backend
                            this.userIdService.setUserId(OCC_USER_ID_CURRENT);
                            this.store.dispatch(new Login());
                            this.authRedirectService.redirect();
                            return [3 /*break*/, 3];
                        case 2:
                            _a_2 = _b.sent();
                            return [3 /*break*/, 3];
                        case 3: return [2 /*return*/];
                    }
                });
            });
        };
        /**
         * Revokes tokens and clears state for logged user (tokens, userId).
         * To perform logout it is best to use `logout` method. Use this method with caution.
         */
        AuthService.prototype.coreLogout = function () {
            var _this = this;
            this.setLogoutProgress(true);
            this.userIdService.clearUserId();
            return new Promise(function (resolve) {
                _this.oAuthLibWrapperService.revokeAndLogout().finally(function () {
                    _this.store.dispatch(new Logout());
                    resolve();
                });
            });
        };
        /**
         * Returns `true` if the user is logged in; and `false` if the user is anonymous.
         */
        AuthService.prototype.isUserLoggedIn = function () {
            return this.authStorageService.getToken().pipe(operators.map(function (userToken) { return Boolean(userToken === null || userToken === void 0 ? void 0 : userToken.access_token); }), operators.distinctUntilChanged());
        };
        /**
         * Logout a storefront customer. It will initialize logout procedure by redirecting to the `logout` endpoint.
         */
        AuthService.prototype.logout = function () {
            this.routingService.go({ cxRoute: 'logout' });
        };
        /**
         * Start or stop the refresh process
         */
        AuthService.prototype.setRefreshProgress = function (progress) {
            this.refreshInProgress$.next(progress);
        };
        /**
         * Start or stop the logout process
         */
        AuthService.prototype.setLogoutProgress = function (progress) {
            this.logoutInProgress$.next(progress);
        };
        return AuthService;
    }());
    AuthService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AuthService, deps: [{ token: i1__namespace$2.Store }, { token: UserIdService }, { token: OAuthLibWrapperService }, { token: AuthStorageService }, { token: AuthRedirectService }, { token: RoutingService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    AuthService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AuthService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AuthService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace$2.Store }, { type: UserIdService }, { type: OAuthLibWrapperService }, { type: AuthStorageService }, { type: AuthRedirectService }, { type: RoutingService }]; } });

    var AnonymousConsentsService = /** @class */ (function () {
        function AnonymousConsentsService(store, authService) {
            this.store = store;
            this.authService = authService;
        }
        /**
         * Retrieves the anonymous consent templates.
         */
        AnonymousConsentsService.prototype.loadTemplates = function () {
            this.store.dispatch(new LoadAnonymousConsentTemplates());
        };
        /**
         * Conditionally triggers the load of the anonymous consent templates if:
         *   - `loadIfMissing` parameter is set to `true`
         *   - the `templates` in the store are `undefined`
         *
         * Otherwise it just returns the value from the store.
         *
         * @param loadIfMissing setting to `true` will trigger the load of the templates if the currently stored templates are `undefined`
         */
        AnonymousConsentsService.prototype.getTemplates = function (loadIfMissing) {
            var _this = this;
            if (loadIfMissing === void 0) { loadIfMissing = false; }
            return rxjs.iif(function () { return loadIfMissing; }, this.store.pipe(i1.select(getAnonymousConsentTemplatesValue), operators.withLatestFrom(this.getLoadTemplatesLoading()), operators.filter(function (_a) {
                var _b = __read(_a, 2), _templates = _b[0], loading = _b[1];
                return !loading;
            }), operators.tap(function (_a) {
                var _b = __read(_a, 2), templates = _b[0], _loading = _b[1];
                if (!Boolean(templates)) {
                    _this.loadTemplates();
                }
            }), operators.filter(function (_a) {
                var _b = __read(_a, 2), templates = _b[0], _loading = _b[1];
                return Boolean(templates);
            }), operators.map(function (_a) {
                var _b = __read(_a, 2), templates = _b[0], _loading = _b[1];
                return templates;
            })), this.store.pipe(i1.select(getAnonymousConsentTemplatesValue)));
        };
        /**
         * Returns the anonymous consent templates with the given template code.
         * @param templateCode a template code by which to filter anonymous consent templates.
         */
        AnonymousConsentsService.prototype.getTemplate = function (templateCode) {
            return this.store.pipe(i1.select(getAnonymousConsentTemplate(templateCode)));
        };
        /**
         * Returns an indicator for the loading status for the anonymous consent templates.
         */
        AnonymousConsentsService.prototype.getLoadTemplatesLoading = function () {
            return this.store.pipe(i1.select(getAnonymousConsentTemplatesLoading));
        };
        /**
         * Returns an indicator for the success status for the anonymous consent templates.
         */
        AnonymousConsentsService.prototype.getLoadTemplatesSuccess = function () {
            return this.store.pipe(i1.select(getAnonymousConsentTemplatesSuccess));
        };
        /**
         * Returns an indicator for the error status for the anonymous consent templates.
         */
        AnonymousConsentsService.prototype.getLoadTemplatesError = function () {
            return this.store.pipe(i1.select(getAnonymousConsentTemplatesError));
        };
        /**
         * Resets the loading, success and error indicators for the anonymous consent templates.
         */
        AnonymousConsentsService.prototype.resetLoadTemplatesState = function () {
            this.store.dispatch(new ResetLoadAnonymousConsentTemplates());
        };
        /**
         * Returns all the anonymous consents.
         */
        AnonymousConsentsService.prototype.getConsents = function () {
            return this.store.pipe(i1.select(getAnonymousConsents));
        };
        /**
         * Puts the provided anonymous consents into the store.
         */
        AnonymousConsentsService.prototype.setConsents = function (consents) {
            return this.store.dispatch(new SetAnonymousConsents(consents));
        };
        /**
         * Returns the anonymous consent for the given template ID.
         *
         * As a side-effect, the method will call `getTemplates(true)` to load the templates if those are not present.
         *
         * @param templateId a template ID by which to filter anonymous consent templates.
         */
        AnonymousConsentsService.prototype.getConsent = function (templateId) {
            var _this = this;
            return this.authService.isUserLoggedIn().pipe(operators.filter(function (authenticated) { return !authenticated; }), operators.tap(function () { return _this.getTemplates(true); }), operators.switchMap(function () { return _this.store.pipe(i1.select(getAnonymousConsentByTemplateCode(templateId))); }));
        };
        /**
         * Give a consent for the given `templateCode`
         * @param templateCode for which to give the consent
         */
        AnonymousConsentsService.prototype.giveConsent = function (templateCode) {
            this.store.dispatch(new GiveAnonymousConsent(templateCode));
        };
        /**
         * Sets all the anonymous consents' state to given.
         */
        AnonymousConsentsService.prototype.giveAllConsents = function () {
            var _this = this;
            return this.getTemplates(true).pipe(operators.tap(function (templates) { return templates.forEach(function (template) { return _this.giveConsent(template.id); }); }));
        };
        /**
         * Returns `true` if the provided `consent` is given.
         * @param consent a consent to test
         */
        AnonymousConsentsService.prototype.isConsentGiven = function (consent) {
            return consent && consent.consentState === exports.ANONYMOUS_CONSENT_STATUS.GIVEN;
        };
        /**
         * Withdraw a consent for the given `templateCode`
         * @param templateCode for which to withdraw the consent
         */
        AnonymousConsentsService.prototype.withdrawConsent = function (templateCode) {
            this.store.dispatch(new WithdrawAnonymousConsent(templateCode));
        };
        /**
         * Sets all the anonymous consents' state to withdrawn.
         */
        AnonymousConsentsService.prototype.withdrawAllConsents = function () {
            var _this = this;
            return this.getTemplates(true).pipe(operators.tap(function (templates) { return templates.forEach(function (template) { return _this.withdrawConsent(template.id); }); }));
        };
        /**
         * Returns `true` if the provided `consent` is withdrawn.
         * @param consent a consent to test
         */
        AnonymousConsentsService.prototype.isConsentWithdrawn = function (consent) {
            return (consent && consent.consentState === exports.ANONYMOUS_CONSENT_STATUS.WITHDRAWN);
        };
        /**
         * Toggles the dismissed state of the anonymous consents banner.
         * @param dismissed the banner will be dismissed if `true` is passed, otherwise it will be visible.
         */
        AnonymousConsentsService.prototype.toggleBannerDismissed = function (dismissed) {
            this.store.dispatch(new ToggleAnonymousConsentsBannerDissmissed(dismissed));
            if (dismissed) {
                this.toggleTemplatesUpdated(false);
            }
        };
        /**
         * Returns `true` if the banner was dismissed, `false` otherwise.
         */
        AnonymousConsentsService.prototype.isBannerDismissed = function () {
            return this.store.pipe(i1.select(getAnonymousConsentsBannerDismissed));
        };
        /**
         * Returns `true` if the consent templates were updated on the back-end.
         * If the templates are not present in the store, it triggers the load.
         */
        AnonymousConsentsService.prototype.getTemplatesUpdated = function () {
            var _this = this;
            return this.getTemplates(true).pipe(operators.switchMap(function () { return _this.store.pipe(i1.select(getAnonymousConsentTemplatesUpdate)); }));
        };
        /**
         * Toggles the `updated` slice of the state
         * @param updated
         */
        AnonymousConsentsService.prototype.toggleTemplatesUpdated = function (updated) {
            this.store.dispatch(new ToggleAnonymousConsentTemplatesUpdated(updated));
        };
        /**
         * Returns `true` if either the banner is not dismissed or if the templates were updated on the back-end.
         * Otherwise, it returns `false`.
         */
        AnonymousConsentsService.prototype.isBannerVisible = function () {
            var _this = this;
            return rxjs.combineLatest([
                this.isBannerDismissed(),
                this.getTemplatesUpdated(),
            ]).pipe(operators.tap(function () { return _this.checkConsentVersions(); }), operators.map(function (_a) {
                var _b = __read(_a, 2), dismissed = _b[0], updated = _b[1];
                return !dismissed || updated;
            }));
        };
        /**
         * Dispatches an action to trigger the check
         * whether the anonymous consent version have been updated
         */
        AnonymousConsentsService.prototype.checkConsentVersions = function () {
            this.store.dispatch(new AnonymousConsentCheckUpdatedVersions());
        };
        /**
         * Returns `true` if there's a mismatch in template versions between the provided `currentTemplates` and `newTemplates`
         * @param currentTemplates current templates to check
         * @param newTemplates new templates to check
         */
        AnonymousConsentsService.prototype.detectUpdatedTemplates = function (currentTemplates, newTemplates) {
            if (newTemplates.length !== currentTemplates.length) {
                return true;
            }
            for (var i = 0; i < newTemplates.length; i++) {
                var newTemplate = newTemplates[i];
                var currentTemplate = currentTemplates[i];
                if (newTemplate.version !== currentTemplate.version) {
                    return true;
                }
            }
            return false;
        };
        /**
         * Serializes using `JSON.stringify()` and encodes using `encodeURIComponent()` methods
         * @param consents to serialize and encode
         */
        AnonymousConsentsService.prototype.serializeAndEncode = function (consents) {
            if (!consents) {
                return '';
            }
            var serialized = JSON.stringify(consents);
            var encoded = encodeURIComponent(serialized);
            return encoded;
        };
        /**
         * Decodes using `decodeURIComponent()` and deserializes using `JSON.parse()`
         * @param rawConsents to decode an deserialize
         */
        AnonymousConsentsService.prototype.decodeAndDeserialize = function (rawConsents) {
            var decoded = decodeURIComponent(rawConsents);
            var unserialized = JSON.parse(decoded);
            return unserialized;
        };
        /**
         *
         * Compares the given `newConsents` and `previousConsents` and returns `true` if there are differences (the `newConsents` are updates).
         * Otherwise it returns `false`.
         *
         * @param newConsents new consents to compare
         * @param previousConsents old consents to compare
         */
        AnonymousConsentsService.prototype.consentsUpdated = function (newConsents, previousConsents) {
            var newRawConsents = this.serializeAndEncode(newConsents);
            var previousRawConsents = this.serializeAndEncode(previousConsents);
            return newRawConsents !== previousRawConsents;
        };
        return AnonymousConsentsService;
    }());
    AnonymousConsentsService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AnonymousConsentsService, deps: [{ token: i1__namespace$2.Store }, { token: AuthService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    AnonymousConsentsService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AnonymousConsentsService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AnonymousConsentsService, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }], ctorParameters: function () { return [{ type: i1__namespace$2.Store }, { type: AuthService }]; } });

    var USE_CLIENT_TOKEN = 'cx-use-client-token';
    var USE_CUSTOMER_SUPPORT_AGENT_TOKEN = 'cx-use-csagent-token';
    var InterceptorUtil = /** @class */ (function () {
        function InterceptorUtil() {
        }
        InterceptorUtil.createHeader = function (headerName, interceptorParam, headers) {
            if (headers) {
                return headers.append(headerName, JSON.stringify(interceptorParam));
            }
            headers = new i1$3.HttpHeaders().set(headerName, JSON.stringify(interceptorParam));
            return headers;
        };
        InterceptorUtil.removeHeader = function (headerName, request) {
            var updatedHeaders = request.headers.delete(headerName);
            return request.clone({ headers: updatedHeaders });
        };
        InterceptorUtil.getInterceptorParam = function (headerName, headers) {
            var rawValue = headers.get(headerName);
            if (rawValue) {
                return JSON.parse(rawValue);
            }
            return undefined;
        };
        return InterceptorUtil;
    }());

    var CLIENT_AUTH_FEATURE = 'client-auth';
    var CLIENT_TOKEN_DATA = '[Client auth] Client Token Data';

    var LOAD_CLIENT_TOKEN = '[Token] Load Client Token';
    var LOAD_CLIENT_TOKEN_FAIL = '[Token] Load Client Token Fail';
    var LOAD_CLIENT_TOKEN_SUCCESS = '[Token] Load Client Token Success';
    var LoadClientToken = /** @class */ (function (_super) {
        __extends(LoadClientToken, _super);
        function LoadClientToken() {
            var _this = _super.call(this, CLIENT_TOKEN_DATA) || this;
            _this.type = LOAD_CLIENT_TOKEN;
            return _this;
        }
        return LoadClientToken;
    }(LoaderLoadAction));
    var LoadClientTokenFail = /** @class */ (function (_super) {
        __extends(LoadClientTokenFail, _super);
        function LoadClientTokenFail(payload) {
            var _this = _super.call(this, CLIENT_TOKEN_DATA, payload) || this;
            _this.payload = payload;
            _this.type = LOAD_CLIENT_TOKEN_FAIL;
            return _this;
        }
        return LoadClientTokenFail;
    }(LoaderFailAction));
    var LoadClientTokenSuccess = /** @class */ (function (_super) {
        __extends(LoadClientTokenSuccess, _super);
        function LoadClientTokenSuccess(payload) {
            var _this = _super.call(this, CLIENT_TOKEN_DATA) || this;
            _this.payload = payload;
            _this.type = LOAD_CLIENT_TOKEN_SUCCESS;
            return _this;
        }
        return LoadClientTokenSuccess;
    }(LoaderSuccessAction));

    var clientTokenGroup_actions = /*#__PURE__*/Object.freeze({
        __proto__: null,
        LOAD_CLIENT_TOKEN: LOAD_CLIENT_TOKEN,
        LOAD_CLIENT_TOKEN_FAIL: LOAD_CLIENT_TOKEN_FAIL,
        LOAD_CLIENT_TOKEN_SUCCESS: LOAD_CLIENT_TOKEN_SUCCESS,
        LoadClientToken: LoadClientToken,
        LoadClientTokenFail: LoadClientTokenFail,
        LoadClientTokenSuccess: LoadClientTokenSuccess
    });

    var getClientAuthState = i1.createFeatureSelector(CLIENT_AUTH_FEATURE);

    var getClientTokenState = i1.createSelector(getClientAuthState, function (state) { return state.clientToken; });

    var clientTokenGroup_selectors = /*#__PURE__*/Object.freeze({
        __proto__: null,
        getClientTokenState: getClientTokenState,
        getClientAuthState: getClientAuthState
    });

    /**
     * Serves a role of a facade on client token store.
     */
    var ClientTokenService = /** @class */ (function () {
        function ClientTokenService(store) {
            this.store = store;
        }
        /**
         * Returns a client token. The client token from the store is returned if there is one.
         * Otherwise a new token is fetched from the backend and saved in the store.
         */
        ClientTokenService.prototype.getClientToken = function () {
            var _this = this;
            return this.store.pipe(i1.select(getClientTokenState), operators.observeOn(rxjs.queueScheduler), operators.filter(function (state) {
                if (_this.isClientTokenLoaded(state)) {
                    return true;
                }
                else {
                    if (!state.loading) {
                        _this.store.dispatch(new LoadClientToken());
                    }
                    return false;
                }
            }), operators.map(function (state) { return state.value; }));
        };
        /**
         * Fetches a clientToken from the backend and saves it in the store where getClientToken can use it.
         * The new clientToken is returned.
         */
        ClientTokenService.prototype.refreshClientToken = function () {
            var _this = this;
            this.store.dispatch(new LoadClientToken());
            return this.store.pipe(i1.select(getClientTokenState), operators.filter(function (state) { return _this.isClientTokenLoaded(state); }), operators.map(function (state) { return state.value; }));
        };
        ClientTokenService.prototype.isClientTokenLoaded = function (state) {
            return (state.success || state.error) && !state.loading;
        };
        return ClientTokenService;
    }());
    ClientTokenService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ClientTokenService, deps: [{ token: i1__namespace$2.Store }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ClientTokenService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ClientTokenService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ClientTokenService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace$2.Store }]; } });

    /**
     * Service for handling `Authorization` header and errors for requests that
     * require client token (eg. user registration).
     */
    var ClientErrorHandlingService = /** @class */ (function () {
        function ClientErrorHandlingService(clientTokenService) {
            this.clientTokenService = clientTokenService;
        }
        /**
         * Refreshes client token and retries the request with the new token.
         *
         * @param request
         * @param httpHandler
         */
        ClientErrorHandlingService.prototype.handleExpiredClientToken = function (request, next) {
            var _this = this;
            return this.clientTokenService.refreshClientToken().pipe(operators.take(1), operators.switchMap(function (token) {
                return next.handle(_this.createNewRequestWithNewToken(request, token));
            }));
        };
        /**
         * Clones the requests and provided `Authorization` header.
         *
         * @param request
         * @param token
         */
        ClientErrorHandlingService.prototype.createNewRequestWithNewToken = function (request, token) {
            request = request.clone({
                setHeaders: {
                    Authorization: (token.token_type || 'Bearer') + " " + token.access_token,
                },
            });
            return request;
        };
        return ClientErrorHandlingService;
    }());
    ClientErrorHandlingService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ClientErrorHandlingService, deps: [{ token: ClientTokenService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ClientErrorHandlingService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ClientErrorHandlingService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ClientErrorHandlingService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: ClientTokenService }]; } });

    var StringTemplate = /** @class */ (function () {
        function StringTemplate() {
        }
        /**
         * Populates the given template with the variables provided
         *
         * @param templateString template of the OCC endpoint
         * @param templateVariables variables to replace in the template
         * @param encodeVariable encode variable before placing it in the template
         */
        StringTemplate.resolve = function (templateString, templateVariables, encodeVariable) {
            var e_1, _a;
            try {
                for (var _b = __values(Object.keys(templateVariables)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var variableLabel = _c.value;
                    var placeholder = new RegExp('\\${' + variableLabel + '}', 'g');
                    templateString = templateString.replace(placeholder, 
                    // TODO 4.0: default to encodeVariable = true
                    encodeVariable
                        ? encodeURIComponent(templateVariables[variableLabel])
                        : templateVariables[variableLabel]);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return templateString;
        };
        return StringTemplate;
    }());

    /**
     * Helper function for safely getting context parameter config
     *
     * @param config
     * @param parameter
     */
    function getContextParameterValues(config, parameter) {
        return (config.context && config.context[parameter]) || [];
    }
    /**
     * Helper function for calculating default value for context parameter from config
     *
     * @param config
     * @param parameter
     */
    function getContextParameterDefault(config, parameter) {
        var param = getContextParameterValues(config, parameter);
        return param && param.length ? param[0] : undefined;
    }

    var LANGUAGE_CONTEXT_ID = 'language';
    var CURRENCY_CONTEXT_ID = 'currency';
    var BASE_SITE_CONTEXT_ID = 'baseSite';
    var THEME_CONTEXT_ID = 'theme';

    var HttpParamsURIEncoder = /** @class */ (function () {
        function HttpParamsURIEncoder() {
        }
        HttpParamsURIEncoder.prototype.encodeKey = function (key) {
            return encodeURIComponent(key);
        };
        HttpParamsURIEncoder.prototype.encodeValue = function (value) {
            return encodeURIComponent(value);
        };
        HttpParamsURIEncoder.prototype.decodeKey = function (key) {
            return decodeURIComponent(key);
        };
        HttpParamsURIEncoder.prototype.decodeValue = function (value) {
            return decodeURIComponent(value);
        };
        return HttpParamsURIEncoder;
    }());

    var DEFAULT_SCOPE = 'default';

    /**
     * Joins the multiple parts with '/' to create a url
     *
     * @param parts the distinct parts of the url to join
     */
    function urlPathJoin() {
        var e_1, _c;
        var parts = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            parts[_i] = arguments[_i];
        }
        var _a, _b;
        var paths = [];
        parts = parts.filter(function (part) { return Boolean(part); });
        try {
            for (var parts_1 = __values(parts), parts_1_1 = parts_1.next(); !parts_1_1.done; parts_1_1 = parts_1.next()) {
                var part = parts_1_1.value;
                paths.push(cleanSlashes(part));
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (parts_1_1 && !parts_1_1.done && (_c = parts_1.return)) _c.call(parts_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        if ((_a = parts[0]) === null || _a === void 0 ? void 0 : _a.startsWith('/')) {
            paths[0] = '/' + paths[0];
        }
        if ((_b = parts[parts.length - 1]) === null || _b === void 0 ? void 0 : _b.endsWith('/')) {
            paths[paths.length - 1] = paths[paths.length - 1] + '/';
        }
        return paths.join('/');
    }
    function cleanSlashes(path) {
        path = path.startsWith('/') ? path.slice(1) : path;
        path = path.endsWith('/') ? path.slice(0, -1) : path;
        return path;
    }

    var LOAD_BASE_SITE = '[Site-context] Load BaseSite';
    var LOAD_BASE_SITE_FAIL = '[Site-context] Load BaseSite Fail';
    var LOAD_BASE_SITE_SUCCESS = '[Site-context] Load BaseSite Success';
    var LOAD_BASE_SITES = '[Site-context] Load BaseSites';
    var LOAD_BASE_SITES_FAIL = '[Site-context] Load BaseSites Fail';
    var LOAD_BASE_SITES_SUCCESS = '[Site-context] Load BaseSites Success';
    var SET_ACTIVE_BASE_SITE = '[Site-context] Set Active BaseSite';
    var BASE_SITE_CHANGE = '[Site-context] BaseSite Change';
    var LoadBaseSite = /** @class */ (function () {
        function LoadBaseSite() {
            this.type = LOAD_BASE_SITE;
        }
        return LoadBaseSite;
    }());
    var LoadBaseSiteFail = /** @class */ (function () {
        function LoadBaseSiteFail(payload) {
            this.payload = payload;
            this.type = LOAD_BASE_SITE_FAIL;
        }
        return LoadBaseSiteFail;
    }());
    var LoadBaseSiteSuccess = /** @class */ (function () {
        function LoadBaseSiteSuccess(payload) {
            this.payload = payload;
            this.type = LOAD_BASE_SITE_SUCCESS;
        }
        return LoadBaseSiteSuccess;
    }());
    var LoadBaseSites = /** @class */ (function () {
        function LoadBaseSites() {
            this.type = LOAD_BASE_SITES;
        }
        return LoadBaseSites;
    }());
    var LoadBaseSitesFail = /** @class */ (function () {
        function LoadBaseSitesFail(payload) {
            this.payload = payload;
            this.type = LOAD_BASE_SITES_FAIL;
        }
        return LoadBaseSitesFail;
    }());
    var LoadBaseSitesSuccess = /** @class */ (function () {
        function LoadBaseSitesSuccess(payload) {
            this.payload = payload;
            this.type = LOAD_BASE_SITES_SUCCESS;
        }
        return LoadBaseSitesSuccess;
    }());
    var SetActiveBaseSite = /** @class */ (function () {
        function SetActiveBaseSite(payload) {
            this.payload = payload;
            this.type = SET_ACTIVE_BASE_SITE;
        }
        return SetActiveBaseSite;
    }());
    var BaseSiteChange = /** @class */ (function () {
        function BaseSiteChange() {
            this.type = BASE_SITE_CHANGE;
        }
        return BaseSiteChange;
    }());

    var LOAD_CURRENCIES = '[Site-context] Load Currencies';
    var LOAD_CURRENCIES_FAIL = '[Site-context] Load Currencies Fail';
    var LOAD_CURRENCIES_SUCCESS = '[Site-context] Load Currencies Success';
    var SET_ACTIVE_CURRENCY = '[Site-context] Set Active Currency';
    var CURRENCY_CHANGE = '[Site-context] Currency Change';
    var LoadCurrencies = /** @class */ (function () {
        function LoadCurrencies() {
            this.type = LOAD_CURRENCIES;
        }
        return LoadCurrencies;
    }());
    var LoadCurrenciesFail = /** @class */ (function () {
        function LoadCurrenciesFail(payload) {
            this.payload = payload;
            this.type = LOAD_CURRENCIES_FAIL;
        }
        return LoadCurrenciesFail;
    }());
    var LoadCurrenciesSuccess = /** @class */ (function () {
        function LoadCurrenciesSuccess(payload) {
            this.payload = payload;
            this.type = LOAD_CURRENCIES_SUCCESS;
        }
        return LoadCurrenciesSuccess;
    }());
    var SetActiveCurrency = /** @class */ (function () {
        function SetActiveCurrency(payload) {
            this.payload = payload;
            this.type = SET_ACTIVE_CURRENCY;
        }
        return SetActiveCurrency;
    }());
    var CurrencyChange = /** @class */ (function () {
        function CurrencyChange(payload) {
            this.payload = payload;
            this.type = CURRENCY_CHANGE;
        }
        return CurrencyChange;
    }());

    var LOAD_LANGUAGES = '[Site-context] Load Languages';
    var LOAD_LANGUAGES_FAIL = '[Site-context] Load Languages Fail';
    var LOAD_LANGUAGES_SUCCESS = '[Site-context] Load Languages Success';
    var SET_ACTIVE_LANGUAGE = '[Site-context] Set Active Language';
    var LANGUAGE_CHANGE = '[Site-context] Language Change';
    var LoadLanguages = /** @class */ (function () {
        function LoadLanguages() {
            this.type = LOAD_LANGUAGES;
        }
        return LoadLanguages;
    }());
    var LoadLanguagesFail = /** @class */ (function () {
        function LoadLanguagesFail(payload) {
            this.payload = payload;
            this.type = LOAD_LANGUAGES_FAIL;
        }
        return LoadLanguagesFail;
    }());
    var LoadLanguagesSuccess = /** @class */ (function () {
        function LoadLanguagesSuccess(payload) {
            this.payload = payload;
            this.type = LOAD_LANGUAGES_SUCCESS;
        }
        return LoadLanguagesSuccess;
    }());
    var SetActiveLanguage = /** @class */ (function () {
        function SetActiveLanguage(payload) {
            this.payload = payload;
            this.type = SET_ACTIVE_LANGUAGE;
        }
        return SetActiveLanguage;
    }());
    var LanguageChange = /** @class */ (function () {
        function LanguageChange(payload) {
            this.payload = payload;
            this.type = LANGUAGE_CHANGE;
        }
        return LanguageChange;
    }());

    var siteContextGroup_actions = /*#__PURE__*/Object.freeze({
        __proto__: null,
        LOAD_BASE_SITE: LOAD_BASE_SITE,
        LOAD_BASE_SITE_FAIL: LOAD_BASE_SITE_FAIL,
        LOAD_BASE_SITE_SUCCESS: LOAD_BASE_SITE_SUCCESS,
        LOAD_BASE_SITES: LOAD_BASE_SITES,
        LOAD_BASE_SITES_FAIL: LOAD_BASE_SITES_FAIL,
        LOAD_BASE_SITES_SUCCESS: LOAD_BASE_SITES_SUCCESS,
        SET_ACTIVE_BASE_SITE: SET_ACTIVE_BASE_SITE,
        BASE_SITE_CHANGE: BASE_SITE_CHANGE,
        LoadBaseSite: LoadBaseSite,
        LoadBaseSiteFail: LoadBaseSiteFail,
        LoadBaseSiteSuccess: LoadBaseSiteSuccess,
        LoadBaseSites: LoadBaseSites,
        LoadBaseSitesFail: LoadBaseSitesFail,
        LoadBaseSitesSuccess: LoadBaseSitesSuccess,
        SetActiveBaseSite: SetActiveBaseSite,
        BaseSiteChange: BaseSiteChange,
        LOAD_CURRENCIES: LOAD_CURRENCIES,
        LOAD_CURRENCIES_FAIL: LOAD_CURRENCIES_FAIL,
        LOAD_CURRENCIES_SUCCESS: LOAD_CURRENCIES_SUCCESS,
        SET_ACTIVE_CURRENCY: SET_ACTIVE_CURRENCY,
        CURRENCY_CHANGE: CURRENCY_CHANGE,
        LoadCurrencies: LoadCurrencies,
        LoadCurrenciesFail: LoadCurrenciesFail,
        LoadCurrenciesSuccess: LoadCurrenciesSuccess,
        SetActiveCurrency: SetActiveCurrency,
        CurrencyChange: CurrencyChange,
        LOAD_LANGUAGES: LOAD_LANGUAGES,
        LOAD_LANGUAGES_FAIL: LOAD_LANGUAGES_FAIL,
        LOAD_LANGUAGES_SUCCESS: LOAD_LANGUAGES_SUCCESS,
        SET_ACTIVE_LANGUAGE: SET_ACTIVE_LANGUAGE,
        LANGUAGE_CHANGE: LANGUAGE_CHANGE,
        LoadLanguages: LoadLanguages,
        LoadLanguagesFail: LoadLanguagesFail,
        LoadLanguagesSuccess: LoadLanguagesSuccess,
        SetActiveLanguage: SetActiveLanguage,
        LanguageChange: LanguageChange
    });

    var SITE_CONTEXT_FEATURE = 'siteContext';

    var getSiteContextState = i1.createFeatureSelector(SITE_CONTEXT_FEATURE);

    var sitesEntitiesSelector = function (state) { return state.entities; };
    var getBaseSiteState = i1.createSelector(getSiteContextState, function (state) { return state.baseSite; });
    var getActiveBaseSite = i1.createSelector(getSiteContextState, function (state) { return state && state.baseSite && state.baseSite.activeSite; });
    var getBaseSiteData = i1.createSelector(getSiteContextState, function (state) { return state && state.baseSite && state.baseSite.details; });
    var getBaseSitesEntities = i1.createSelector(getBaseSiteState, sitesEntitiesSelector);
    var getAllBaseSites = i1.createSelector(getBaseSitesEntities, function (entities) {
        return entities ? Object.keys(entities).map(function (uid) { return entities[uid]; }) : null;
    });

    var currenciesEntitiesSelector = function (state) { return state.entities; };
    var activeCurrencySelector = function (state) { return state.activeCurrency; };
    var getCurrenciesState = i1.createSelector(getSiteContextState, function (state) { return state.currencies; });
    var getCurrenciesEntities = i1.createSelector(getCurrenciesState, currenciesEntitiesSelector);
    var getActiveCurrency = i1.createSelector(getCurrenciesState, activeCurrencySelector);
    var getAllCurrencies = i1.createSelector(getCurrenciesEntities, function (entities) {
        return entities
            ? Object.keys(entities).map(function (isocode) { return entities[isocode]; })
            : null;
    });

    var activeLanguageSelector = function (state) { return state.activeLanguage; };
    var languagesEntitiesSelector = function (state) { return state.entities; };
    var getLanguagesState = i1.createSelector(getSiteContextState, function (state) { return state.languages; });
    var getLanguagesEntities = i1.createSelector(getLanguagesState, languagesEntitiesSelector);
    var getActiveLanguage = i1.createSelector(getLanguagesState, activeLanguageSelector);
    var getAllLanguages = i1.createSelector(getLanguagesEntities, function (entities) {
        return entities
            ? Object.keys(entities).map(function (isocode) { return entities[isocode]; })
            : null;
    });

    var siteContextGroup_selectors = /*#__PURE__*/Object.freeze({
        __proto__: null,
        getBaseSiteState: getBaseSiteState,
        getActiveBaseSite: getActiveBaseSite,
        getBaseSiteData: getBaseSiteData,
        getBaseSitesEntities: getBaseSitesEntities,
        getAllBaseSites: getAllBaseSites,
        getCurrenciesState: getCurrenciesState,
        getCurrenciesEntities: getCurrenciesEntities,
        getActiveCurrency: getActiveCurrency,
        getAllCurrencies: getAllCurrencies,
        getLanguagesState: getLanguagesState,
        getLanguagesEntities: getLanguagesEntities,
        getActiveLanguage: getActiveLanguage,
        getAllLanguages: getAllLanguages,
        getSiteContextState: getSiteContextState
    });

    var BaseSiteService = /** @class */ (function () {
        function BaseSiteService(store, config) {
            this.store = store;
            this.config = config;
        }
        /**
         * Represents the current baseSite uid.
         */
        BaseSiteService.prototype.getActive = function () {
            return this.store.pipe(i1.select(getActiveBaseSite), operators.filter(function (active) { return Boolean(active); }));
        };
        /**
         * Get all base sites data
         */
        BaseSiteService.prototype.getAll = function () {
            var _this = this;
            return this.store.pipe(i1.select(getAllBaseSites), operators.tap(function (sites) {
                if (!sites) {
                    _this.store.dispatch(new LoadBaseSites());
                }
            }), operators.filter(function (sites) { return Boolean(sites); }));
        };
        /**
         * Get base site data based on site uid
         */
        BaseSiteService.prototype.get = function (siteUid) {
            var _this = this;
            if (siteUid) {
                return this.getAll().pipe(operators.map(function (sites) { return sites.find(function (site) { return site.uid === siteUid; }); }));
            }
            return this.getActive().pipe(operators.switchMap(function (activeSiteUid) { return _this.getAll().pipe(operators.map(function (sites) { return sites.find(function (site) { return site.uid === activeSiteUid; }); })); }));
        };
        BaseSiteService.prototype.setActive = function (baseSite) {
            var _this = this;
            this.store
                .pipe(i1.select(getActiveBaseSite), operators.take(1))
                .subscribe(function (activeBaseSite) {
                if (baseSite && activeBaseSite !== baseSite) {
                    _this.store.dispatch(new SetActiveBaseSite(baseSite));
                }
            });
        };
        /**
         * Tells whether the value of the base site has been already initialized
         */
        BaseSiteService.prototype.isInitialized = function () {
            var valueInitialized = false;
            this.getActive()
                .subscribe(function () { return (valueInitialized = true); })
                .unsubscribe();
            return valueInitialized;
        };
        /**
         * Tells whether the given iso code is allowed.
         *
         * The list of allowed iso codes can be configured in the `context` config of Spartacus.
         */
        BaseSiteService.prototype.isValid = function (value) {
            return (!!value &&
                getContextParameterValues(this.config, BASE_SITE_CONTEXT_ID).includes(value));
        };
        return BaseSiteService;
    }());
    BaseSiteService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: BaseSiteService, deps: [{ token: i1__namespace$2.Store }, { token: SiteContextConfig }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    BaseSiteService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: BaseSiteService });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: BaseSiteService, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: i1__namespace$2.Store }, { type: SiteContextConfig }]; } });

    var OccEndpointsService = /** @class */ (function () {
        function OccEndpointsService(config, baseSiteService) {
            var _this = this;
            this.config = config;
            this.baseSiteService = baseSiteService;
            if (this.baseSiteService) {
                this.baseSiteService
                    .getActive()
                    .subscribe(function (value) { return (_this._activeBaseSite = value); });
            }
        }
        Object.defineProperty(OccEndpointsService.prototype, "activeBaseSite", {
            get: function () {
                var _a;
                return ((_a = this._activeBaseSite) !== null && _a !== void 0 ? _a : getContextParameterDefault(this.config, BASE_SITE_CONTEXT_ID));
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Returns the value configured for a specific endpoint
         *
         * @param endpointKey the configuration key for the endpoint to return
         * @param scope endpoint configuration scope
         */
        OccEndpointsService.prototype.getRawEndpointValue = function (endpoint, scope) {
            var endpointValue = this.getEndpointForScope(endpoint, scope);
            return endpointValue;
        };
        /**
         * Returns true when the endpoint is configured
         *
         * @param endpointKey the configuration key for the endpoint to return
         * @param scope endpoint configuration scope
         */
        OccEndpointsService.prototype.isConfigured = function (endpoint, scope) {
            return !(typeof this.getEndpointFromConfig(endpoint, scope) === 'undefined');
        };
        /**
         * Returns base OCC endpoint (baseUrl + prefix + baseSite) base on provided values
         *
         * @param baseUrlProperties Specify properties to not add to the url (baseUrl, prefix, baseSite)
         */
        OccEndpointsService.prototype.getBaseUrl = function (baseUrlProperties) {
            if (baseUrlProperties === void 0) { baseUrlProperties = {
                baseUrl: true,
                prefix: true,
                baseSite: true,
            }; }
            var _a, _b, _c, _d;
            var baseUrl = baseUrlProperties.baseUrl === false
                ? ''
                : (_d = (_c = (_b = (_a = this.config) === null || _a === void 0 ? void 0 : _a.backend) === null || _b === void 0 ? void 0 : _b.occ) === null || _c === void 0 ? void 0 : _c.baseUrl) !== null && _d !== void 0 ? _d : '';
            var prefix = baseUrlProperties.prefix === false ? '' : this.getPrefix();
            var baseSite = baseUrlProperties.baseSite === false ? '' : this.activeBaseSite;
            return urlPathJoin(baseUrl, prefix, baseSite);
        };
        /**
         * Returns a fully qualified OCC Url
         *
         * @param endpoint Name of the OCC endpoint key
         * @param attributes Dynamic attributes used to build the url
         * @param propertiesToOmit Specify properties to not add to the url (baseUrl, prefix, baseSite)
         */
        OccEndpointsService.prototype.buildUrl = function (endpoint, attributes, propertiesToOmit) {
            var _h;
            var url = this.getEndpointForScope(endpoint, attributes === null || attributes === void 0 ? void 0 : attributes.scope);
            if (attributes) {
                var urlParams = attributes.urlParams, queryParams_1 = attributes.queryParams;
                if (urlParams) {
                    url = StringTemplate.resolve(url, attributes.urlParams, true);
                }
                if (queryParams_1) {
                    var httpParamsOptions = { encoder: new HttpParamsURIEncoder() };
                    if (url.includes('?')) {
                        var queryParamsFromEndpoint = void 0;
                        _h = __read(url.split('?'), 2), url = _h[0], queryParamsFromEndpoint = _h[1];
                        httpParamsOptions = Object.assign(Object.assign({}, httpParamsOptions), { fromString: queryParamsFromEndpoint });
                    }
                    var httpParams_1 = new i1$3.HttpParams(httpParamsOptions);
                    Object.keys(queryParams_1).forEach(function (key) {
                        var value = queryParams_1[key];
                        if (value !== undefined) {
                            if (value === null) {
                                httpParams_1 = httpParams_1.delete(key);
                            }
                            else {
                                httpParams_1 = httpParams_1.set(key, value);
                            }
                        }
                    });
                    var params = httpParams_1.toString();
                    if (params.length) {
                        url += '?' + params;
                    }
                }
            }
            return this.buildUrlFromEndpointString(url, propertiesToOmit);
        };
        OccEndpointsService.prototype.getEndpointFromConfig = function (endpoint, scope) {
            var _a, _b;
            var endpointsConfig = (_b = (_a = this.config.backend) === null || _a === void 0 ? void 0 : _a.occ) === null || _b === void 0 ? void 0 : _b.endpoints;
            if (!endpointsConfig) {
                return undefined;
            }
            var endpointConfig = endpointsConfig[endpoint];
            if (scope) {
                if (scope === DEFAULT_SCOPE && typeof endpointConfig === 'string') {
                    return endpointConfig;
                }
                return endpointConfig === null || endpointConfig === void 0 ? void 0 : endpointConfig[scope];
            }
            return typeof endpointConfig === 'string'
                ? endpointConfig
                : endpointConfig === null || endpointConfig === void 0 ? void 0 : endpointConfig[DEFAULT_SCOPE];
        };
        // TODO: Can we reuse getEndpointFromConfig in this method? Should we change behavior of this function?
        OccEndpointsService.prototype.getEndpointForScope = function (endpoint, scope) {
            var _a, _b;
            var endpointsConfig = (_b = (_a = this.config.backend) === null || _a === void 0 ? void 0 : _a.occ) === null || _b === void 0 ? void 0 : _b.endpoints;
            if (!Boolean(endpointsConfig)) {
                return '';
            }
            var endpointConfig = endpointsConfig[endpoint];
            if (scope) {
                if (endpointConfig === null || endpointConfig === void 0 ? void 0 : endpointConfig[scope]) {
                    return endpointConfig === null || endpointConfig === void 0 ? void 0 : endpointConfig[scope];
                }
                if (scope === DEFAULT_SCOPE && typeof endpointConfig === 'string') {
                    return endpointConfig;
                }
                if (i0.isDevMode()) {
                    console.warn(endpoint + " endpoint configuration missing for scope \"" + scope + "\"");
                }
            }
            return ((typeof endpointConfig === 'string'
                ? endpointConfig
                : endpointConfig === null || endpointConfig === void 0 ? void 0 : endpointConfig[DEFAULT_SCOPE]) || endpoint);
        };
        /**
         * Add the base OCC url properties to the specified endpoint string
         *
         * @param endpointString String value for the url endpoint
         * @param propertiesToOmit Specify properties to not add to the url (baseUrl, prefix, baseSite)
         */
        OccEndpointsService.prototype.buildUrlFromEndpointString = function (endpointString, propertiesToOmit) {
            return urlPathJoin(this.getBaseUrl(propertiesToOmit), endpointString);
        };
        OccEndpointsService.prototype.getPrefix = function () {
            var _a, _b, _c, _d, _e, _f, _g;
            if (((_c = (_b = (_a = this.config) === null || _a === void 0 ? void 0 : _a.backend) === null || _b === void 0 ? void 0 : _b.occ) === null || _c === void 0 ? void 0 : _c.prefix) &&
                !this.config.backend.occ.prefix.startsWith('/')) {
                return '/' + this.config.backend.occ.prefix;
            }
            return (_g = (_f = (_e = (_d = this.config) === null || _d === void 0 ? void 0 : _d.backend) === null || _e === void 0 ? void 0 : _e.occ) === null || _f === void 0 ? void 0 : _f.prefix) !== null && _g !== void 0 ? _g : '';
        };
        return OccEndpointsService;
    }());
    OccEndpointsService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccEndpointsService, deps: [{ token: OccConfig }, { token: BaseSiteService, optional: true }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    OccEndpointsService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccEndpointsService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccEndpointsService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () {
            return [{ type: OccConfig }, { type: BaseSiteService, decorators: [{
                            type: i0.Optional
                        }] }];
        } });

    /**
     * Interceptor for handling requests with `USE_CLIENT_TOKEN` header.
     * Provides `Authorization` header with client token and handles errors related to client auth.
     */
    var ClientTokenInterceptor = /** @class */ (function () {
        function ClientTokenInterceptor(clientTokenService, clientErrorHandlingService, occEndpoints) {
            this.clientTokenService = clientTokenService;
            this.clientErrorHandlingService = clientErrorHandlingService;
            this.occEndpoints = occEndpoints;
        }
        ClientTokenInterceptor.prototype.intercept = function (request, next) {
            var _this = this;
            var isClientTokenRequest = this.isClientTokenRequest(request);
            if (isClientTokenRequest) {
                request = InterceptorUtil.removeHeader(USE_CLIENT_TOKEN, request);
            }
            return this.getClientToken(isClientTokenRequest).pipe(operators.take(1), operators.switchMap(function (token) {
                if ((token === null || token === void 0 ? void 0 : token.access_token) &&
                    request.url.includes(_this.occEndpoints.getBaseUrl())) {
                    request = request.clone({
                        setHeaders: {
                            Authorization: (token.token_type || 'Bearer') + " " + token.access_token,
                        },
                    });
                }
                return next.handle(request).pipe(operators.catchError(function (errResponse) {
                    if (errResponse instanceof i1$3.HttpErrorResponse) {
                        if (errResponse.status === 401) {
                            if (isClientTokenRequest) {
                                if (_this.isExpiredToken(errResponse)) {
                                    return _this.clientErrorHandlingService.handleExpiredClientToken(request, next);
                                }
                            }
                        }
                    }
                    return rxjs.throwError(errResponse);
                }));
            }));
        };
        ClientTokenInterceptor.prototype.getClientToken = function (isClientTokenRequest) {
            if (isClientTokenRequest) {
                return this.clientTokenService.getClientToken();
            }
            return rxjs.of(null);
        };
        ClientTokenInterceptor.prototype.isClientTokenRequest = function (request) {
            var isRequestMapping = InterceptorUtil.getInterceptorParam(USE_CLIENT_TOKEN, request.headers);
            return Boolean(isRequestMapping);
        };
        ClientTokenInterceptor.prototype.isExpiredToken = function (resp) {
            var _a, _b, _c;
            return ((_c = (_b = (_a = resp.error) === null || _a === void 0 ? void 0 : _a.errors) === null || _b === void 0 ? void 0 : _b[0]) === null || _c === void 0 ? void 0 : _c.type) === 'InvalidTokenError';
        };
        return ClientTokenInterceptor;
    }());
    ClientTokenInterceptor.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ClientTokenInterceptor, deps: [{ token: ClientTokenService }, { token: ClientErrorHandlingService }, { token: OccEndpointsService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ClientTokenInterceptor.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ClientTokenInterceptor, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ClientTokenInterceptor, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }], ctorParameters: function () { return [{ type: ClientTokenService }, { type: ClientErrorHandlingService }, { type: OccEndpointsService }]; } });

    var interceptors$2 = [
        {
            provide: i1$3.HTTP_INTERCEPTORS,
            useExisting: ClientTokenInterceptor,
            multi: true,
        },
    ];

    exports.StorageSyncType = void 0;
    (function (StorageSyncType) {
        StorageSyncType["NO_STORAGE"] = "NO_STORAGE";
        StorageSyncType["LOCAL_STORAGE"] = "LOCAL_STORAGE";
        StorageSyncType["SESSION_STORAGE"] = "SESSION_STORAGE";
    })(exports.StorageSyncType || (exports.StorageSyncType = {}));
    exports.StateTransferType = void 0;
    (function (StateTransferType) {
        StateTransferType["TRANSFER_STATE"] = "SSR";
    })(exports.StateTransferType || (exports.StateTransferType = {}));
    var StateConfig = /** @class */ (function () {
        function StateConfig() {
        }
        return StateConfig;
    }());
    StateConfig.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: StateConfig, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    StateConfig.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: StateConfig, providedIn: 'root', useExisting: Config });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: StateConfig, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                        useExisting: Config,
                    }]
            }] });

    function getStorage(storageType, winRef) {
        var storage;
        switch (storageType) {
            case exports.StorageSyncType.LOCAL_STORAGE: {
                storage = winRef.localStorage;
                break;
            }
            case exports.StorageSyncType.SESSION_STORAGE: {
                storage = winRef.sessionStorage;
                break;
            }
            case exports.StorageSyncType.NO_STORAGE: {
                storage = undefined;
                break;
            }
            default: {
                storage = winRef.sessionStorage;
            }
        }
        return storage;
    }
    function persistToStorage(configKey, value, storage) {
        if (!isSsr(storage) && value) {
            storage.setItem(configKey, JSON.stringify(value));
        }
    }
    function readFromStorage(storage, key) {
        if (isSsr(storage)) {
            return;
        }
        var storageValue = storage.getItem(key);
        if (!storageValue) {
            return;
        }
        return JSON.parse(storageValue);
    }
    function isSsr(storage) {
        return !Boolean(storage);
    }

    var StatePersistenceService = /** @class */ (function () {
        function StatePersistenceService(winRef) {
            this.winRef = winRef;
        }
        /**
         * Helper to synchronize state to more persistent storage (localStorage, sessionStorage).
         * It is context aware, so you can keep different state for te same feature based on specified context.
         *
         * Eg. cart is valid only under the same base site. So you want to synchronize cart only with the same base site.
         * Usage for that case: `syncWithStorage({ key: 'cart', state$: activeCartSelector$, context$: this.siteContextParamsService.getValues([BASE_SITE_CONTEXT_ID]), onRead: (state) => setCorrectStateInStore(state) })`.
         * Active cart for the `electronics` base site will be stored under `spartacus⚿electronics⚿cart` and for apparel under `spartacus⚿apparel⚿cart`.
         *
         * On each context change onRead function will be executed with state from storage provided as a parameter.
         *
         * Omitting context$ will trigger onRead only once at initialization.
         *
         * @param key Key to use in storage for the synchronized state. Should be unique for each feature.
         * @param state$ State to be saved and later restored.
         * @param context$ Context for state
         * @param storageType Storage type to be used to persist state
         * @param onRead Function to be executed on each storage read after context change
         *
         * @returns Subscriptions for reading/writing in storage on context/state change
         */
        StatePersistenceService.prototype.syncWithStorage = function (_a) {
            var _this = this;
            var key = _a.key, state$ = _a.state$, _b = _a.context$, context$ = _b === void 0 ? rxjs.of('') : _b, _c = _a.storageType, storageType = _c === void 0 ? exports.StorageSyncType.LOCAL_STORAGE : _c, _d = _a.onRead, onRead = _d === void 0 ? function () { } : _d;
            var storage = getStorage(storageType, this.winRef);
            var subscriptions = new rxjs.Subscription();
            // Do not change order of subscription! Read should happen before write on context change.
            subscriptions.add(context$
                .pipe(operators.map(function (context) {
                return readFromStorage(storage, _this.generateKeyWithContext(context, key));
            }), operators.tap(function (state) { return onRead(state); }))
                .subscribe());
            subscriptions.add(state$.pipe(operators.withLatestFrom(context$)).subscribe(function (_a) {
                var _b = __read(_a, 2), state = _b[0], context = _b[1];
                persistToStorage(_this.generateKeyWithContext(context, key), state, storage);
            }));
            return subscriptions;
        };
        /**
         * Helper to read state from persistent storage (localStorage, sessionStorage).
         * It is useful if you need synchronously access state saved with `syncWithStorage`.
         *
         * @param key Key to use in storage for state. Should be unique for each feature.
         * @param context Context value for state
         * @param storageType Storage type from to read state
         *
         * @returns State from the storage
         */
        StatePersistenceService.prototype.readStateFromStorage = function (_a) {
            var key = _a.key, _b = _a.context, context = _b === void 0 ? '' : _b, _c = _a.storageType, storageType = _c === void 0 ? exports.StorageSyncType.LOCAL_STORAGE : _c;
            var storage = getStorage(storageType, this.winRef);
            return readFromStorage(storage, this.generateKeyWithContext(context, key));
        };
        StatePersistenceService.prototype.generateKeyWithContext = function (context, key) {
            return "spartacus\u26BF" + []
                .concat(context)
                .join('⚿') + "\u26BF" + key;
        };
        return StatePersistenceService;
    }());
    StatePersistenceService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: StatePersistenceService, deps: [{ token: WindowRef }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    StatePersistenceService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: StatePersistenceService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: StatePersistenceService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: WindowRef }]; } });

    /**
     * Responsible for saving the authorization data (userId, token, redirectUrl) in browser storage.
     */
    var AuthStatePersistenceService = /** @class */ (function () {
        function AuthStatePersistenceService(statePersistenceService, userIdService, authStorageService, authRedirectStorageService) {
            this.statePersistenceService = statePersistenceService;
            this.userIdService = userIdService;
            this.authStorageService = authStorageService;
            this.authRedirectStorageService = authRedirectStorageService;
            this.subscription = new rxjs.Subscription();
            /**
             * Identifier used for storage key.
             */
            this.key = 'auth';
        }
        /**
         * Initializes the synchronization between state and browser storage.
         */
        AuthStatePersistenceService.prototype.initSync = function () {
            var _this = this;
            this.subscription.add(this.statePersistenceService.syncWithStorage({
                key: this.key,
                state$: this.getAuthState(),
                onRead: function (state) { return _this.onRead(state); },
            }));
        };
        /**
         * Gets and transforms state from different sources into the form that should
         * be saved in storage.
         */
        AuthStatePersistenceService.prototype.getAuthState = function () {
            return rxjs.combineLatest([
                this.authStorageService.getToken().pipe(operators.filter(function (state) { return !!state; }), operators.map(function (state) {
                    return Object.assign({}, state);
                })),
                this.userIdService.getUserId(),
                this.authRedirectStorageService.getRedirectUrl(),
            ]).pipe(operators.map(function (_c) {
                var _d = __read(_c, 3), authToken = _d[0], userId = _d[1], redirectUrl = _d[2];
                var token = authToken;
                if (token) {
                    token = Object.assign({}, token);
                    // To minimize risk of user account hijacking we don't persist user refresh_token
                    delete token.refresh_token;
                }
                return { token: token, userId: userId, redirectUrl: redirectUrl };
            }));
        };
        /**
         * Function called on each browser storage read.
         * Used to update state from browser -> state.
         */
        AuthStatePersistenceService.prototype.onRead = function (state) {
            if (state === null || state === void 0 ? void 0 : state.token) {
                this.authStorageService.setToken(state.token);
            }
            if (state === null || state === void 0 ? void 0 : state.redirectUrl) {
                this.authRedirectStorageService.setRedirectUrl(state.redirectUrl);
            }
            if (state === null || state === void 0 ? void 0 : state.userId) {
                this.userIdService.setUserId(state.userId);
            }
            else {
                this.userIdService.clearUserId();
            }
        };
        /**
         * Reads synchronously state from storage and returns it.
         */
        AuthStatePersistenceService.prototype.readStateFromStorage = function () {
            return this.statePersistenceService.readStateFromStorage({
                key: this.key,
            });
        };
        /**
         * Check synchronously in browser storage if user is logged in (required by transfer state reducer).
         * For most cases `isUserLoggedIn` from the `AuthService` should be used instead of this.
         */
        AuthStatePersistenceService.prototype.isUserLoggedIn = function () {
            var _a, _b;
            return Boolean((_b = (_a = this.readStateFromStorage()) === null || _a === void 0 ? void 0 : _a.token) === null || _b === void 0 ? void 0 : _b.access_token);
        };
        AuthStatePersistenceService.prototype.ngOnDestroy = function () {
            this.subscription.unsubscribe();
        };
        return AuthStatePersistenceService;
    }());
    AuthStatePersistenceService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AuthStatePersistenceService, deps: [{ token: StatePersistenceService }, { token: UserIdService }, { token: AuthStorageService }, { token: AuthRedirectStorageService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    AuthStatePersistenceService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AuthStatePersistenceService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AuthStatePersistenceService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: StatePersistenceService }, { type: UserIdService }, { type: AuthStorageService }, { type: AuthRedirectStorageService }]; } });

    var CX_KEY = platformBrowser.makeStateKey('cx-state');
    function getTransferStateReducer(platformId, transferState, config, authStatePersistenceService) {
        var _a, _b;
        if (transferState && ((_b = (_a = config === null || config === void 0 ? void 0 : config.state) === null || _a === void 0 ? void 0 : _a.ssrTransfer) === null || _b === void 0 ? void 0 : _b.keys)) {
            if (i6.isPlatformBrowser(platformId)) {
                return getBrowserTransferStateReducer(transferState, config.state.ssrTransfer.keys, Boolean(authStatePersistenceService === null || authStatePersistenceService === void 0 ? void 0 : authStatePersistenceService.isUserLoggedIn()));
            }
            else if (i6.isPlatformServer(platformId)) {
                return getServerTransferStateReducer(transferState, config.state.ssrTransfer.keys);
            }
        }
        return function (reducer) { return reducer; };
    }
    function getServerTransferStateReducer(transferState, keys) {
        var transferStateKeys = filterKeysByType(keys, exports.StateTransferType.TRANSFER_STATE);
        return function (reducer) {
            return function (state, action) {
                var newState = reducer(state, action);
                if (newState) {
                    var stateSlice = getStateSlice(transferStateKeys, [], newState);
                    transferState.set(CX_KEY, stateSlice);
                }
                return newState;
            };
        };
    }
    function getBrowserTransferStateReducer(transferState, keys, isLoggedIn) {
        var transferStateKeys = filterKeysByType(keys, exports.StateTransferType.TRANSFER_STATE);
        return function (reducer) {
            return function (state, action) {
                if (action.type === i1.INIT) {
                    if (!state) {
                        state = reducer(state, action);
                    }
                    if (!isLoggedIn && transferState.hasKey(CX_KEY)) {
                        var cxKey = transferState.get(CX_KEY, {});
                        var transferredStateSlice = getStateSlice(transferStateKeys, [], cxKey);
                        state = deepMerge({}, state, transferredStateSlice);
                    }
                    return state;
                }
                return reducer(state, action);
            };
        };
    }

    var TRANSFER_STATE_META_REDUCER = new i0.InjectionToken('TransferStateMetaReducer');
    var stateMetaReducers = [
        {
            provide: TRANSFER_STATE_META_REDUCER,
            useFactory: getTransferStateReducer,
            deps: [
                i0.PLATFORM_ID,
                [new i0.Optional(), platformBrowser.TransferState],
                [new i0.Optional(), Config],
                [new i0.Optional(), AuthStatePersistenceService],
            ],
        },
        {
            provide: i1.META_REDUCERS,
            useExisting: TRANSFER_STATE_META_REDUCER,
            multi: true,
        },
    ];

    var StateModule = /** @class */ (function () {
        function StateModule() {
        }
        StateModule.forRoot = function () {
            return {
                ngModule: StateModule,
                providers: __spreadArray([], __read(stateMetaReducers)),
            };
        };
        return StateModule;
    }());
    StateModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: StateModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    StateModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: StateModule });
    StateModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: StateModule });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: StateModule, decorators: [{
                type: i0.NgModule,
                args: [{}]
            }] });

    /**
     * Normalizes HttpErrorResponse to HttpErrorModel.
     *
     * Can be used as a safe and generic way for embodying http errors into
     * NgRx Action payload, as it will strip potentially unserializable parts from
     * it and warn in debug mode if passed error is not instance of HttpErrorModel
     * (which usually happens when logic in NgRx Effect is not sealed correctly)
     */
    function normalizeHttpError(error) {
        if (error instanceof i1$3.HttpErrorResponse) {
            var normalizedError = new HttpErrorModel();
            normalizedError.message = error.message;
            normalizedError.status = error.status;
            normalizedError.statusText = error.statusText;
            normalizedError.url = error.url;
            // include backend's error details
            if (Array.isArray(error.error.errors)) {
                normalizedError.details = error.error.errors;
            }
            else if (typeof error.error.error === 'string') {
                normalizedError.details = [
                    {
                        type: error.error.error,
                        message: error.error.error_description,
                    },
                ];
            }
            return normalizedError;
        }
        if (i0.isDevMode()) {
            console.error('Error passed to normalizeHttpError is not HttpErrorResponse instance', error);
        }
        return undefined;
    }

    /**
     * Responsible for requesting from OAuth server `ClientToken` for a particular
     * auth client.
     */
    var ClientAuthenticationTokenService = /** @class */ (function () {
        function ClientAuthenticationTokenService(http, authConfigService) {
            this.http = http;
            this.authConfigService = authConfigService;
        }
        /**
         * Loads token with client authentication flow.
         *
         * @returns observable with ClientToken
         */
        ClientAuthenticationTokenService.prototype.loadClientAuthenticationToken = function () {
            var url = this.authConfigService.getTokenEndpoint();
            var params = new i1$3.HttpParams()
                .set('client_id', encodeURIComponent(this.authConfigService.getClientId()))
                .set('client_secret', encodeURIComponent(this.authConfigService.getClientSecret()))
                .set('grant_type', 'client_credentials');
            var headers = new i1$3.HttpHeaders({
                'Content-Type': 'application/x-www-form-urlencoded',
            });
            return this.http.post(url, params, { headers: headers });
        };
        return ClientAuthenticationTokenService;
    }());
    ClientAuthenticationTokenService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ClientAuthenticationTokenService, deps: [{ token: i1__namespace$3.HttpClient }, { token: AuthConfigService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ClientAuthenticationTokenService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ClientAuthenticationTokenService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ClientAuthenticationTokenService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace$3.HttpClient }, { type: AuthConfigService }]; } });

    var ClientTokenEffect = /** @class */ (function () {
        function ClientTokenEffect(actions$, clientAuthenticationTokenService) {
            var _this = this;
            this.actions$ = actions$;
            this.clientAuthenticationTokenService = clientAuthenticationTokenService;
            this.loadClientToken$ = this.actions$.pipe(i1$4.ofType(LOAD_CLIENT_TOKEN), operators.exhaustMap(function () {
                return _this.clientAuthenticationTokenService
                    .loadClientAuthenticationToken()
                    .pipe(operators.map(function (token) {
                    return new LoadClientTokenSuccess(token);
                }), operators.catchError(function (error) { return rxjs.of(new LoadClientTokenFail(normalizeHttpError(error))); }));
            }));
        }
        return ClientTokenEffect;
    }());
    ClientTokenEffect.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ClientTokenEffect, deps: [{ token: i1__namespace$4.Actions }, { token: ClientAuthenticationTokenService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ClientTokenEffect.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ClientTokenEffect });
    __decorate([
        i1$4.Effect()
    ], ClientTokenEffect.prototype, "loadClientToken$", void 0);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ClientTokenEffect, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: i1__namespace$4.Actions }, { type: ClientAuthenticationTokenService }]; }, propDecorators: { loadClientToken$: [] } });

    var effects$6 = [ClientTokenEffect];

    function getReducers$8() {
        return {
            clientToken: loaderReducer(CLIENT_TOKEN_DATA),
        };
    }
    var reducerToken$8 = new i0.InjectionToken('ClientAuthReducers');
    var reducerProvider$8 = {
        provide: reducerToken$8,
        useFactory: getReducers$8,
    };

    var ClientAuthStoreModule = /** @class */ (function () {
        function ClientAuthStoreModule() {
        }
        return ClientAuthStoreModule;
    }());
    ClientAuthStoreModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ClientAuthStoreModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    ClientAuthStoreModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ClientAuthStoreModule, imports: [i6.CommonModule,
            i1$3.HttpClientModule,
            StateModule, i1__namespace$2.StoreFeatureModule, i1__namespace$4.EffectsFeatureModule] });
    ClientAuthStoreModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ClientAuthStoreModule, providers: [reducerProvider$8], imports: [[
                i6.CommonModule,
                i1$3.HttpClientModule,
                StateModule,
                i1.StoreModule.forFeature(CLIENT_AUTH_FEATURE, reducerToken$8),
                i1$4.EffectsModule.forFeature(effects$6),
            ]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ClientAuthStoreModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [
                            i6.CommonModule,
                            i1$3.HttpClientModule,
                            StateModule,
                            i1.StoreModule.forFeature(CLIENT_AUTH_FEATURE, reducerToken$8),
                            i1$4.EffectsModule.forFeature(effects$6),
                        ],
                        providers: [reducerProvider$8],
                    }]
            }] });

    /**
     * Some of the OCC endpoints require Authorization header with the client token (eg. user registration).
     * This pattern should not be used in the frontend apps, but until OCC changes this requirement
     * we provide this module to support using those endpoints.
     *
     * After OCC improvements regarding client authentication this module can be safely removed.
     */
    var ClientAuthModule = /** @class */ (function () {
        function ClientAuthModule() {
        }
        ClientAuthModule.forRoot = function () {
            return {
                ngModule: ClientAuthModule,
                providers: __spreadArray([], __read(interceptors$2)),
            };
        };
        return ClientAuthModule;
    }());
    ClientAuthModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ClientAuthModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    ClientAuthModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ClientAuthModule, imports: [i6.CommonModule, ClientAuthStoreModule] });
    ClientAuthModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ClientAuthModule, imports: [[i6.CommonModule, ClientAuthStoreModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ClientAuthModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [i6.CommonModule, ClientAuthStoreModule],
                    }]
            }] });

    var CONFIG_INITIALIZER = new i0.InjectionToken('ConfigInitializer');
    var CONFIG_INITIALIZER_FORROOT_GUARD = new i0.InjectionToken('CONFIG_INITIALIZER_FORROOT_GUARD');

    /**
     * Provides support for CONFIG_INITIALIZERS
     */
    var ConfigInitializerService = /** @class */ (function () {
        function ConfigInitializerService(config, initializerGuard, rootConfig) {
            this.config = config;
            this.initializerGuard = initializerGuard;
            this.rootConfig = rootConfig;
            this.ongoingScopes$ = new rxjs.BehaviorSubject(undefined);
        }
        Object.defineProperty(ConfigInitializerService.prototype, "isStable", {
            /**
             * Returns true if config is stable, i.e. all CONFIG_INITIALIZERS resolved correctly
             */
            get: function () {
                var _a;
                return !this.initializerGuard || ((_a = this.ongoingScopes$.value) === null || _a === void 0 ? void 0 : _a.length) === 0;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Recommended way to get config for code that can run before app will finish
         * initialization (APP_INITIALIZERS, selected service constructors)
         *
         * Used without parameters waits for the whole config to become stable
         *
         * Parameters allow to describe which part of the config should be stable using
         * string describing config part, e.g.:
         * 'siteContext', 'siteContext.language', etc.
         *
         * @param scopes String describing parts of the config we want to be sure are stable
         */
        ConfigInitializerService.prototype.getStable = function () {
            var _this = this;
            var scopes = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                scopes[_i] = arguments[_i];
            }
            if (this.isStable) {
                return rxjs.of(this.config);
            }
            return this.ongoingScopes$.pipe(operators.filter(function (ongoingScopes) { return !!ongoingScopes && _this.areReady(scopes, ongoingScopes); }), operators.take(1), operators.mapTo(this.config));
        };
        /**
         * Removes provided scopes from currently ongoingScopes
         *
         * @param scopes
         */
        ConfigInitializerService.prototype.finishScopes = function (scopes) {
            var e_1, _b;
            var _a;
            var newScopes = __spreadArray([], __read(((_a = this.ongoingScopes$.value) !== null && _a !== void 0 ? _a : [])));
            try {
                for (var scopes_1 = __values(scopes), scopes_1_1 = scopes_1.next(); !scopes_1_1.done; scopes_1_1 = scopes_1.next()) {
                    var scope = scopes_1_1.value;
                    newScopes.splice(newScopes.indexOf(scope), 1);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (scopes_1_1 && !scopes_1_1.done && (_b = scopes_1.return)) _b.call(scopes_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            this.ongoingScopes$.next(newScopes);
        };
        /**
         * Return true if provided scopes are not part of ongoingScopes
         *
         * @param scopes
         * @param ongoingScopes
         */
        ConfigInitializerService.prototype.areReady = function (scopes, ongoingScopes) {
            var e_2, _b, e_3, _c;
            if (!scopes.length) {
                return !ongoingScopes.length;
            }
            try {
                for (var scopes_2 = __values(scopes), scopes_2_1 = scopes_2.next(); !scopes_2_1.done; scopes_2_1 = scopes_2.next()) {
                    var scope = scopes_2_1.value;
                    try {
                        for (var ongoingScopes_1 = (e_3 = void 0, __values(ongoingScopes)), ongoingScopes_1_1 = ongoingScopes_1.next(); !ongoingScopes_1_1.done; ongoingScopes_1_1 = ongoingScopes_1.next()) {
                            var ongoingScope = ongoingScopes_1_1.value;
                            if (this.scopesOverlap(scope, ongoingScope)) {
                                return false;
                            }
                        }
                    }
                    catch (e_3_1) { e_3 = { error: e_3_1 }; }
                    finally {
                        try {
                            if (ongoingScopes_1_1 && !ongoingScopes_1_1.done && (_c = ongoingScopes_1.return)) _c.call(ongoingScopes_1);
                        }
                        finally { if (e_3) throw e_3.error; }
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (scopes_2_1 && !scopes_2_1.done && (_b = scopes_2.return)) _b.call(scopes_2);
                }
                finally { if (e_2) throw e_2.error; }
            }
            return true;
        };
        /**
         * Check if two scopes overlap.
         *
         * Example of scopes that overlap:
         * 'test' and 'test', 'test.a' and 'test', 'test' and 'test.a'
         *
         * Example of scopes that do not overlap:
         * 'test' and 'testA', 'test.a' and 'test.b', 'test.nested' and 'test.nest'
         *
         * @param a ScopeA
         * @param b ScopeB
         */
        ConfigInitializerService.prototype.scopesOverlap = function (a, b) {
            var _b;
            if (b.length > a.length) {
                _b = __read([b, a], 2), a = _b[0], b = _b[1];
            }
            return a.startsWith(b) && (a[b.length] || '.') === '.';
        };
        /**
         * @internal
         *
         * Not a part of a public API, used by APP_INITIALIZER to initialize all provided CONFIG_INITIALIZERS
         *
         */
        ConfigInitializerService.prototype.initialize = function (initializers) {
            return __awaiter(this, void 0, void 0, function () {
                var ongoingScopes, asyncConfigs, _loop_1, this_1, _b, _c, initializer;
                var e_4, _d;
                var _this = this;
                return __generator(this, function (_e) {
                    switch (_e.label) {
                        case 0:
                            if (this.ongoingScopes$.value) {
                                // guard for double initialization
                                return [2 /*return*/];
                            }
                            ongoingScopes = [];
                            asyncConfigs = [];
                            _loop_1 = function (initializer) {
                                if (!initializer) {
                                    return "continue";
                                }
                                if (!initializer.scopes || !initializer.scopes.length) {
                                    throw new Error('CONFIG_INITIALIZER should provide scope!');
                                }
                                if (i0.isDevMode() && !this_1.areReady(initializer.scopes, ongoingScopes)) {
                                    console.warn('More than one CONFIG_INITIALIZER is initializing the same config scope.');
                                }
                                ongoingScopes.push.apply(ongoingScopes, __spreadArray([], __read(initializer.scopes)));
                                asyncConfigs.push((function () { return __awaiter(_this, void 0, void 0, function () {
                                    var initializerConfig;
                                    return __generator(this, function (_b) {
                                        switch (_b.label) {
                                            case 0: return [4 /*yield*/, initializer.configFactory()];
                                            case 1:
                                                initializerConfig = _b.sent();
                                                // contribute configuration to rootConfig
                                                deepMerge(this.rootConfig, initializerConfig);
                                                // contribute configuration to global config
                                                deepMerge(this.config, initializerConfig);
                                                this.finishScopes(initializer.scopes);
                                                return [2 /*return*/];
                                        }
                                    });
                                }); })());
                            };
                            this_1 = this;
                            try {
                                for (_b = __values(initializers || []), _c = _b.next(); !_c.done; _c = _b.next()) {
                                    initializer = _c.value;
                                    _loop_1(initializer);
                                }
                            }
                            catch (e_4_1) { e_4 = { error: e_4_1 }; }
                            finally {
                                try {
                                    if (_c && !_c.done && (_d = _b.return)) _d.call(_b);
                                }
                                finally { if (e_4) throw e_4.error; }
                            }
                            this.ongoingScopes$.next(ongoingScopes);
                            if (!asyncConfigs.length) return [3 /*break*/, 2];
                            return [4 /*yield*/, Promise.all(asyncConfigs)];
                        case 1:
                            _e.sent();
                            _e.label = 2;
                        case 2: return [2 /*return*/];
                    }
                });
            });
        };
        return ConfigInitializerService;
    }());
    ConfigInitializerService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ConfigInitializerService, deps: [{ token: Config }, { token: CONFIG_INITIALIZER_FORROOT_GUARD, optional: true }, { token: RootConfig }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ConfigInitializerService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ConfigInitializerService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ConfigInitializerService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () {
            return [{ type: Config }, { type: undefined, decorators: [{
                            type: i0.Optional
                        }, {
                            type: i0.Inject,
                            args: [CONFIG_INITIALIZER_FORROOT_GUARD]
                        }] }, { type: Config, decorators: [{
                            type: i0.Inject,
                            args: [RootConfig]
                        }] }];
        } });

    var ConfigValidatorToken = new i0.InjectionToken('ConfigurationValidator');
    /**
     * Use to probide config validation at app bootstrap (when all config chunks are merged)
     *
     * @param configValidator
     */
    function provideConfigValidator(configValidator) {
        return {
            provide: ConfigValidatorToken,
            useValue: configValidator,
            multi: true,
        };
    }
    function validateConfig(config, configValidators) {
        var e_1, _a;
        try {
            for (var configValidators_1 = __values(configValidators), configValidators_1_1 = configValidators_1.next(); !configValidators_1_1.done; configValidators_1_1 = configValidators_1.next()) {
                var validate = configValidators_1_1.value;
                var warning = validate(config);
                if (warning) {
                    console.warn(warning);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (configValidators_1_1 && !configValidators_1_1.done && (_a = configValidators_1.return)) _a.call(configValidators_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }

    function baseUrlConfigValidator(config) {
        var _a, _b, _c, _d, _e;
        if (typeof ((_a = config === null || config === void 0 ? void 0 : config.authentication) === null || _a === void 0 ? void 0 : _a.baseUrl) === 'undefined' &&
            typeof ((_c = (_b = config === null || config === void 0 ? void 0 : config.backend) === null || _b === void 0 ? void 0 : _b.occ) === null || _c === void 0 ? void 0 : _c.baseUrl) === 'undefined' &&
            // Don't show warning when user tries to work around the issue.
            ((_e = (_d = config === null || config === void 0 ? void 0 : config.authentication) === null || _d === void 0 ? void 0 : _d.OAuthLibConfig) === null || _e === void 0 ? void 0 : _e.requireHttps) !== false) {
            return 'Authentication might not work correctly without setting either authentication.baseUrl or backend.occ.baseUrl configuration option! Workaround: To support relative urls in angular-oauth2-oidc library you can try setting authentication.OAuthLibConfig.requireHttps to false.';
        }
    }

    var defaultAuthConfig = {
        authentication: {
            client_id: 'mobile_android',
            client_secret: 'secret',
            tokenEndpoint: '/oauth/token',
            revokeEndpoint: '/oauth/revoke',
            loginUrl: '/oauth/authorize',
            OAuthLibConfig: {
                scope: '',
                customTokenParameters: ['token_type'],
                strictDiscoveryDocumentValidation: false,
                skipIssuerCheck: true,
                disablePKCE: true,
                oidc: false,
                clearHashAfterLogin: false,
            },
        },
    };

    /**
     * Creates an instance of the given class and fills its properties with the given data.
     *
     * @param type reference to the class
     * @param data object with properties to be copied to the class
     */
    function createFrom(type, data) {
        return Object.assign(new type(), data);
    }

    /**
     * Intended to be inherited by all other Spartacus' events.
     *
     * "One event to rule them all".
     */
    var CxEvent = /** @class */ (function () {
        function CxEvent() {
        }
        return CxEvent;
    }());
    /**
     * Event's type
     */
    CxEvent.type = 'CxEvent';

    /**
     * Indicates that the user has logged out
     *
     * * The event is fired even for customer emulation
     * * The event is NOT fired for a ASM support agent authentication
     */
    var LogoutEvent = /** @class */ (function (_super) {
        __extends(LogoutEvent, _super);
        function LogoutEvent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return LogoutEvent;
    }(CxEvent));
    /**
     * Event's type
     */
    LogoutEvent.type = 'LogoutEvent';
    /**
     * Indicates that the user has logged in
     *
     * * The event is fired even for customer emulation
     * * The event is NOT fired for a ASM support agent authentication
     */
    var LoginEvent = /** @class */ (function (_super) {
        __extends(LoginEvent, _super);
        function LoginEvent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return LoginEvent;
    }(CxEvent));
    /**
     * Event's type
     */
    LoginEvent.type = 'LoginEvent';

    // PRIVATE API
    /**
     * Allows for dynamic adding and removing source observables
     * and exposes them as one merged observable at a property `output$`.
     *
     * Thanks to the `share()` operator used inside, it subscribes to source observables
     * only when someone subscribes to it. And it unsubscribes from source observables
     * when the counter of consumers drops to 0.
     *
     * **To avoid memory leaks**, all manually added sources should be manually removed
     * when not plan to emit values anymore. In particular closed event sources won't be
     * automatically removed.
     */
    var MergingSubject = /** @class */ (function () {
        function MergingSubject() {
            var _this = this;
            /**
             * List of already added sources (but not removed yet)
             */
            this.sources = [];
            /**
             * For each source: it stores a subscription responsible for
             * passing all values from source to the consumer
             */
            this.subscriptionsToSources = new Map();
            /**
             * Observable with all sources merged.
             *
             * Only after subscribing to it, under the hood it subscribes to the source observables.
             * When the number of subscribers drops to 0, it unsubscribes from all source observables.
             * But if later on something subscribes to it again, it subscribes to the source observables again.
             *
             * It multicasts the emissions for each subscriber.
             */
            this.output$ = new rxjs.Observable(function (consumer) {
                // There can be only 0 or 1 consumer of this observable coming from the `share()` operator
                // that is piped right after this observable.
                // `share()` not only multicasts the results but also  When all end-subscribers unsubscribe from `share()` operator, it will unsubscribe
                // from this observable (by the nature `refCount`-nature of the `share()` operator).
                _this.consumer = consumer;
                _this.bindAllSourcesToConsumer(consumer);
                return function () {
                    _this.consumer = null;
                    _this.unbindAllSourcesFromConsumer();
                };
            }).pipe(operators.share());
            /**
             * Reference to the subscriber coming from the `share()` operator piped to the `output$` observable.
             * For more, see docs of the `output$` observable;
             */
            this.consumer = null;
        }
        /**
         * Registers the given source to pass its values to the `output$` observable.
         *
         * It does nothing, when the source has been already added (but not removed yet).
         */
        MergingSubject.prototype.add = function (source) {
            if (this.has(source)) {
                return;
            }
            if (this.consumer) {
                this.bindSourceToConsumer(source, this.consumer);
            }
            this.sources.push(source);
        };
        /**
         * Starts passing all values from already added sources to consumer
         */
        MergingSubject.prototype.bindAllSourcesToConsumer = function (consumer) {
            var _this = this;
            this.sources.forEach(function (source) { return _this.bindSourceToConsumer(source, consumer); });
        };
        /**
         * Stops passing all values from already added sources to consumer
         * (if any consumer is active at the moment)
         */
        MergingSubject.prototype.unbindAllSourcesFromConsumer = function () {
            var _this = this;
            this.sources.forEach(function (source) { return _this.unbindSourceFromConsumer(source); });
        };
        /**
         * Starts passing all values from a single source to consumer
         */
        MergingSubject.prototype.bindSourceToConsumer = function (source, consumer) {
            var subscriptionToSource = source.subscribe(function (val) { return consumer.next(val); }); // passes all emissions from source to consumer
            this.subscriptionsToSources.set(source, subscriptionToSource);
        };
        /**
         * Stops passing all values from a single source to consumer
         * (if any consumer is active at the moment)
         */
        MergingSubject.prototype.unbindSourceFromConsumer = function (source) {
            var subscriptionToSource = this.subscriptionsToSources.get(source);
            if (subscriptionToSource !== undefined) {
                subscriptionToSource.unsubscribe();
                this.subscriptionsToSources.delete(source);
            }
        };
        /**
         * Unregisters the given source so it stops passing its values to `output$` observable.
         *
         * Should be used when a source is no longer maintained **to avoid memory leaks**.
         */
        MergingSubject.prototype.remove = function (source) {
            // clear binding from source to consumer (if any consumer exists at the moment)
            this.unbindSourceFromConsumer(source);
            // remove source from array
            var i;
            if ((i = this.sources.findIndex(function (s) { return s === source; })) !== -1) {
                this.sources.splice(i, 1);
            }
        };
        /**
         * Returns whether the given source has been already addded
         */
        MergingSubject.prototype.has = function (source) {
            return this.sources.includes(source);
        };
        return MergingSubject;
    }());

    /**
     * A service to register and observe event sources. Events are driven by event types, which are class signatures
     * for the given event.
     *
     * It is possible to register multiple sources to a single event, even without
     * knowing as multiple decoupled features can attach sources to the same
     * event type.
     */
    var EventService = /** @class */ (function () {
        function EventService() {
            /**
             * The various events meta are collected in a map, stored by the event type class
             */
            this.eventsMeta = new Map();
        }
        /**
         * Register an event source for the given event type.
         *
         * CAUTION: To avoid memory leaks, the returned teardown function should be called
         *  when the event source is no longer maintained by its creator
         * (i.e. in `ngOnDestroy` if the event source was registered in the component).
         *
         * @since 3.1 - registers the given `source$` for the parent classes of the given `eventType`.
         *
         * @param eventType the event type
         * @param source$ an observable that represents the source
         *
         * @returns a teardown function which unregisters the given event source
         */
        EventService.prototype.register = function (eventType, source$) {
            var eventMeta = this.getEventMeta(eventType);
            if (eventMeta.mergingSubject.has(source$)) {
                if (i0.isDevMode()) {
                    console.warn("EventService: the event source", source$, "has been already registered for the type", eventType);
                }
            }
            else {
                eventMeta.mergingSubject.add(source$);
            }
            return function () { return eventMeta.mergingSubject.remove(source$); };
        };
        /**
         * Returns a stream of events for the given event type
         * @param eventTypes event type
         */
        EventService.prototype.get = function (eventType) {
            var output$ = this.getEventMeta(eventType).mergingSubject.output$;
            if (i0.isDevMode()) {
                output$ = this.getValidatedEventStream(output$, eventType);
            }
            return output$;
        };
        /**
         * Dispatches an instance of an individual event.
         * If the eventType is provided a new event will be created for that type and with the event data.
         *
         * @param event an event
         * @param eventType (optional) - type of event
         */
        EventService.prototype.dispatch = function (event, eventType) {
            if (!eventType) {
                eventType = event.constructor;
            }
            else if (!(event instanceof eventType)) {
                event = createFrom(eventType, event);
            }
            var inputSubject$ = this.getInputSubject(eventType);
            inputSubject$.next(event);
        };
        /**
         * Returns the input subject used to dispatch a single event.
         * The subject is created on demand, when it's needed for the first time.
         * @param eventType type of event
         */
        EventService.prototype.getInputSubject = function (eventType) {
            var eventMeta = this.getEventMeta(eventType);
            if (!eventMeta.inputSubject$) {
                eventMeta.inputSubject$ = new rxjs.Subject();
                this.register(eventType, eventMeta.inputSubject$);
            }
            return eventMeta.inputSubject$;
        };
        /**
         * Returns the event meta object for the given event type
         */
        EventService.prototype.getEventMeta = function (eventType) {
            if (!this.eventsMeta.get(eventType)) {
                if (i0.isDevMode()) {
                    this.validateEventType(eventType);
                }
                this.createEventMeta(eventType);
            }
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            return this.eventsMeta.get(eventType);
        };
        EventService.prototype.createEventMeta = function (eventType) {
            var eventMeta = {
                inputSubject$: null,
                mergingSubject: new MergingSubject(),
            };
            this.eventsMeta.set(eventType, eventMeta);
            var parentEvent = Object.getPrototypeOf(eventType);
            while (parentEvent !== null &&
                Object.getPrototypeOf(parentEvent) !== Object.getPrototypeOf({})) {
                this.register(parentEvent, eventMeta.mergingSubject.output$);
                parentEvent = Object.getPrototypeOf(parentEvent);
            }
        };
        /**
         * Checks if the event type is a valid type (is a class with constructor).
         *
         * Should be used only in dev mode.
         */
        EventService.prototype.validateEventType = function (eventType) {
            if (!(eventType === null || eventType === void 0 ? void 0 : eventType.constructor)) {
                throw new Error("EventService:  " + eventType + " is not a valid event type. Please provide a class reference.");
            }
            this.validateCxEvent(eventType);
        };
        /**
         * Validates if the given type (or its prototype chain) extends from the CxEvent.
         *
         * Should be used only in the dev mode.
         */
        EventService.prototype.validateCxEvent = function (eventType) {
            var parentType = eventType;
            while (parentType !== null &&
                Object.getPrototypeOf(parentType) !== Object.getPrototypeOf({})) {
                if (parentType.type === CxEvent.type) {
                    return;
                }
                parentType = Object.getPrototypeOf(parentType);
            }
            console.warn("The " + eventType.name + " (or one of its parent classes) does not inherit from the " + CxEvent.type);
        };
        /**
         * Returns the given event source with runtime validation whether the emitted values are instances of given event type.
         *
         * Should be used only in dev mode.
         */
        EventService.prototype.getValidatedEventStream = function (source$, eventType) {
            return source$.pipe(operators.tap(function (event) {
                if (!(event instanceof eventType)) {
                    console.warn("EventService: The stream", source$, "emitted the event", event, "that is not an instance of the declared type", eventType.name);
                }
            }));
        };
        return EventService;
    }());
    EventService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: EventService, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    EventService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: EventService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: EventService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }] });

    /**
     * Registers streams of ngrx actions as events source streams
     */
    var StateEventService = /** @class */ (function () {
        function StateEventService(actionsSubject, eventService) {
            this.actionsSubject = actionsSubject;
            this.eventService = eventService;
        }
        /**
         * Registers an event source stream of specific events
         * mapped from a given action type.
         *
         * @param mapping mapping from action to event
         *
         * @returns a teardown function that unregisters the event source
         */
        StateEventService.prototype.register = function (mapping) {
            return this.eventService.register(mapping.event, this.getFromAction(mapping));
        };
        /**
         * Returns a stream of specific events mapped from a specific action.
         * @param mapping mapping from action to event
         */
        StateEventService.prototype.getFromAction = function (mapping) {
            var _this = this;
            return this.actionsSubject
                .pipe(i1$4.ofType.apply(void 0, __spreadArray([], __read([].concat(mapping.action)))))
                .pipe(operators.map(function (action) { return _this.createEvent(action, mapping.event, mapping.factory); }));
        };
        /**
         * Creates an event instance for given class out from the action object.
         * Unless the `factory` parameter is given, the action's `payload` is used
         * as the argument for the event's constructor.
         *
         * @param action instance of an Action
         * @param mapping mapping from action to event
         * @param factory optional function getting an action instance and returning an event instance
         *
         * @returns instance of an Event
         */
        StateEventService.prototype.createEvent = function (action, eventType, factory) {
            var _a;
            return factory
                ? factory(action)
                : createFrom(eventType, (_a = action.payload) !== null && _a !== void 0 ? _a : {});
        };
        return StateEventService;
    }());
    StateEventService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: StateEventService, deps: [{ token: i1__namespace$2.ActionsSubject }, { token: EventService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    StateEventService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: StateEventService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: StateEventService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace$2.ActionsSubject }, { type: EventService }]; } });

    var UserAuthEventBuilder = /** @class */ (function () {
        function UserAuthEventBuilder(stateEventService, eventService, authService) {
            this.stateEventService = stateEventService;
            this.eventService = eventService;
            this.authService = authService;
            this.register();
        }
        /**
         * Registers user auth events
         */
        UserAuthEventBuilder.prototype.register = function () {
            this.registerLoginEvent();
            this.registerLogoutEvent();
        };
        /**
         * Register a login event
         */
        UserAuthEventBuilder.prototype.registerLoginEvent = function () {
            this.stateEventService.register({
                action: LOGIN,
                event: LoginEvent,
            });
        };
        /**
         * Register a logout event
         */
        UserAuthEventBuilder.prototype.registerLogoutEvent = function () {
            this.eventService.register(LogoutEvent, this.buildLogoutEvent());
        };
        /**
         * Returns logout event stream
         */
        UserAuthEventBuilder.prototype.buildLogoutEvent = function () {
            return this.authService.isUserLoggedIn().pipe(operators.pairwise(), operators.filter(function (_a) {
                var _b = __read(_a, 2), prev = _b[0], curr = _b[1];
                return prev && !curr;
            }), operators.map(function () { return createFrom(LogoutEvent, {}); }));
        };
        return UserAuthEventBuilder;
    }());
    UserAuthEventBuilder.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserAuthEventBuilder, deps: [{ token: StateEventService }, { token: EventService }, { token: AuthService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    UserAuthEventBuilder.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserAuthEventBuilder, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserAuthEventBuilder, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: StateEventService }, { type: EventService }, { type: AuthService }]; } });

    var UserAuthEventModule = /** @class */ (function () {
        function UserAuthEventModule(_userAuthEventBuilder) {
        }
        return UserAuthEventModule;
    }());
    UserAuthEventModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserAuthEventModule, deps: [{ token: UserAuthEventBuilder }], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    UserAuthEventModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserAuthEventModule });
    UserAuthEventModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserAuthEventModule });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserAuthEventModule, decorators: [{
                type: i0.NgModule,
                args: [{}]
            }], ctorParameters: function () { return [{ type: UserAuthEventBuilder }]; } });

    exports.GlobalMessageType = void 0;
    (function (GlobalMessageType) {
        GlobalMessageType["MSG_TYPE_CONFIRMATION"] = "[GlobalMessage] Confirmation";
        GlobalMessageType["MSG_TYPE_ERROR"] = "[GlobalMessage] Error";
        GlobalMessageType["MSG_TYPE_INFO"] = "[GlobalMessage] Information";
        GlobalMessageType["MSG_TYPE_WARNING"] = "[GlobalMessage] Warning";
    })(exports.GlobalMessageType || (exports.GlobalMessageType = {}));

    function isNotUndefined(value) {
        return typeof value !== 'undefined';
    }
    function isNotNullable(value) {
        return isNotUndefined(value) && value !== null;
    }

    var ADD_MESSAGE = '[Global-message] Add a Message';
    var REMOVE_MESSAGE = '[Global-message] Remove a Message';
    var REMOVE_MESSAGES_BY_TYPE = '[Global-message] Remove messages by type';
    var AddMessage = /** @class */ (function () {
        function AddMessage(payload) {
            this.payload = payload;
            this.type = ADD_MESSAGE;
        }
        return AddMessage;
    }());
    var RemoveMessage = /** @class */ (function () {
        function RemoveMessage(payload) {
            this.payload = payload;
            this.type = REMOVE_MESSAGE;
        }
        return RemoveMessage;
    }());
    var RemoveMessagesByType = /** @class */ (function () {
        function RemoveMessagesByType(payload) {
            this.payload = payload;
            this.type = REMOVE_MESSAGES_BY_TYPE;
        }
        return RemoveMessagesByType;
    }());

    var globalMessageGroup_actions = /*#__PURE__*/Object.freeze({
        __proto__: null,
        ADD_MESSAGE: ADD_MESSAGE,
        REMOVE_MESSAGE: REMOVE_MESSAGE,
        REMOVE_MESSAGES_BY_TYPE: REMOVE_MESSAGES_BY_TYPE,
        AddMessage: AddMessage,
        RemoveMessage: RemoveMessage,
        RemoveMessagesByType: RemoveMessagesByType
    });

    var GLOBAL_MESSAGE_FEATURE = 'global-message';

    var getGlobalMessageState = i1.createFeatureSelector(GLOBAL_MESSAGE_FEATURE);

    var getGlobalMessageEntities = i1.createSelector(getGlobalMessageState, function (state) { return state.entities; });
    var getGlobalMessageEntitiesByType = function (type) {
        return i1.createSelector(getGlobalMessageEntities, function (entities) { return entities && entities[type]; });
    };
    var getGlobalMessageCountByType = function (type) {
        return i1.createSelector(getGlobalMessageEntitiesByType(type), function (entities) { return entities && entities.length; });
    };

    var globalMessageGroup_selectors = /*#__PURE__*/Object.freeze({
        __proto__: null,
        getGlobalMessageState: getGlobalMessageState,
        getGlobalMessageEntities: getGlobalMessageEntities,
        getGlobalMessageEntitiesByType: getGlobalMessageEntitiesByType,
        getGlobalMessageCountByType: getGlobalMessageCountByType
    });

    var GlobalMessageService = /** @class */ (function () {
        function GlobalMessageService(store) {
            this.store = store;
        }
        /**
         * Get all global messages
         */
        GlobalMessageService.prototype.get = function () {
            return this.store.pipe(i1.select(getGlobalMessageEntities), operators.filter(isNotUndefined));
        };
        /**
         * Add one message into store
         * @param text: string | Translatable
         * @param type: GlobalMessageType object
         * @param timeout: number
         */
        GlobalMessageService.prototype.add = function (text, type, timeout) {
            this.store.dispatch(new AddMessage({
                text: typeof text === 'string' ? { raw: text } : text,
                type: type,
                timeout: timeout,
            }));
        };
        /**
         * Remove message(s) from store
         * @param type: GlobalMessageType
         * @param index:optional. Without it, messages will be removed by type; otherwise,
         * message will be removed from list by index.
         */
        GlobalMessageService.prototype.remove = function (type, index) {
            this.store.dispatch(index !== undefined
                ? new RemoveMessage({
                    type: type,
                    index: index,
                })
                : new RemoveMessagesByType(type));
        };
        return GlobalMessageService;
    }());
    GlobalMessageService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: GlobalMessageService, deps: [{ token: i1__namespace$2.Store }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    GlobalMessageService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: GlobalMessageService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: GlobalMessageService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace$2.Store }]; } });

    /**
     * Extendable service for `AuthInterceptor`.
     */
    var AuthHttpHeaderService = /** @class */ (function () {
        function AuthHttpHeaderService(authService, authStorageService, oAuthLibWrapperService, routingService, occEndpoints, globalMessageService, authRedirectService) {
            var _this = this;
            this.authService = authService;
            this.authStorageService = authStorageService;
            this.oAuthLibWrapperService = oAuthLibWrapperService;
            this.routingService = routingService;
            this.occEndpoints = occEndpoints;
            this.globalMessageService = globalMessageService;
            this.authRedirectService = authRedirectService;
            /**
             * Indicates whether the access token is being refreshed
             *
             * @deprecated will be removed in the next major. Use `AuthService.refreshInProgress$` instead.
             */
            // TODO:#13421 - legacy, remove this flag
            this.refreshInProgress = false;
            /**
             * Starts the refresh of the access token
             */
            this.refreshTokenTrigger$ = new rxjs.Subject();
            /**
             * Internal token streams which reads the latest from the storage.
             * Emits the token or `undefined`
             */
            this.token$ = this.authStorageService
                .getToken()
                .pipe(operators.map(function (token) { return ((token === null || token === void 0 ? void 0 : token.access_token) ? token : undefined); }));
            /**
             * Compares the previous and the new token in order to stop the refresh or logout processes
             */
            this.stopProgress$ = this.token$.pipe(
            // Keeps the previous and the new token
            operators.pairwise(), operators.tap(function (_a) {
                var _b = __read(_a, 2), oldToken = _b[0], newToken = _b[1];
                // if we got the new token we know that either the refresh or logout finished
                if ((oldToken === null || oldToken === void 0 ? void 0 : oldToken.access_token) !== (newToken === null || newToken === void 0 ? void 0 : newToken.access_token)) {
                    _this.authService.setLogoutProgress(false);
                    _this.authService.setRefreshProgress(false);
                }
            }));
            /**
             * Refreshes the token only if currently there's no refresh nor logout in progress.
             * If the refresh token is not present, it triggers the logout process
             */
            this.refreshToken$ = this.refreshTokenTrigger$.pipe(operators.withLatestFrom(this.authService.refreshInProgress$, this.authService.logoutInProgress$), operators.filter(function (_a) {
                var _b = __read(_a, 3), refreshInProgress = _b[1], logoutInProgress = _b[2];
                return !refreshInProgress && !logoutInProgress;
            }), operators.tap(function (_a) {
                var _b = __read(_a, 1), token = _b[0];
                if (token === null || token === void 0 ? void 0 : token.refresh_token) {
                    _this.oAuthLibWrapperService.refreshToken();
                    _this.authService.setRefreshProgress(true);
                }
                else {
                    _this.handleExpiredRefreshToken();
                }
            }));
            /**
             * Kicks of the process by listening to the new token and refresh token processes.
             * This token should be used when retrying the failed http request.
             */
            this.tokenToRetryRequest$ = rxjs.using(function () { return _this.refreshToken$.subscribe(); }, function () { return _this.getStableToken(); }).pipe(operators.shareReplay({ refCount: true, bufferSize: 1 }));
            this.subscriptions = new rxjs.Subscription();
            // We need to have stopProgress$ stream active for the whole time,
            // so when the logout finishes we finish it's process.
            // It could happen when retryToken$ is not active.
            this.subscriptions.add(this.stopProgress$.subscribe());
        }
        /**
         * Checks if request should be handled by this service (if it's OCC call).
         */
        AuthHttpHeaderService.prototype.shouldCatchError = function (request) {
            return this.isOccUrl(request.url);
        };
        AuthHttpHeaderService.prototype.shouldAddAuthorizationHeader = function (request) {
            var hasAuthorizationHeader = !!this.getAuthorizationHeader(request);
            var isOccUrl = this.isOccUrl(request.url);
            return !hasAuthorizationHeader && isOccUrl;
        };
        /**
         * Adds `Authorization` header for OCC calls.
         */
        AuthHttpHeaderService.prototype.alterRequest = function (request, token) {
            var hasAuthorizationHeader = !!this.getAuthorizationHeader(request);
            var isOccUrl = this.isOccUrl(request.url);
            if (!hasAuthorizationHeader && isOccUrl) {
                return request.clone({
                    setHeaders: Object.assign({}, this.createAuthorizationHeader(token)),
                });
            }
            return request;
        };
        AuthHttpHeaderService.prototype.isOccUrl = function (url) {
            return url.includes(this.occEndpoints.getBaseUrl());
        };
        AuthHttpHeaderService.prototype.getAuthorizationHeader = function (request) {
            var rawValue = request.headers.get('Authorization');
            return rawValue;
        };
        AuthHttpHeaderService.prototype.createAuthorizationHeader = function (token) {
            if (token === null || token === void 0 ? void 0 : token.access_token) {
                return {
                    Authorization: (token.token_type || 'Bearer') + " " + token.access_token,
                };
            }
            var currentToken;
            this.authStorageService
                .getToken()
                .subscribe(function (token) { return (currentToken = token); })
                .unsubscribe();
            if (currentToken === null || currentToken === void 0 ? void 0 : currentToken.access_token) {
                return {
                    Authorization: (currentToken.token_type || 'Bearer') + " " + currentToken.access_token,
                };
            }
            return {};
        };
        /**
         * Refreshes access_token and then retries the call with the new token.
         */
        AuthHttpHeaderService.prototype.handleExpiredAccessToken = function (request, next, 
        // TODO:#13421 make required
        initialToken) {
            var _this = this;
            // TODO:#13421 remove this if-statement, and just return the stream.
            if (initialToken) {
                return this.getValidToken(initialToken).pipe(operators.switchMap(function (token) {
                    // we break the stream with EMPTY when we don't have the token. This prevents sending the requests with `Authorization: bearer undefined` header
                    return token
                        ? next.handle(_this.createNewRequestWithNewToken(request, token))
                        : rxjs.EMPTY;
                }));
            }
            // TODO:#13421 legacy - remove in 5.0
            return this.handleExpiredToken().pipe(operators.switchMap(function (token) {
                return token
                    ? next.handle(_this.createNewRequestWithNewToken(request, token))
                    : rxjs.EMPTY;
            }));
        };
        /**
         * Logout user, redirected to login page and informs about expired session.
         */
        AuthHttpHeaderService.prototype.handleExpiredRefreshToken = function () {
            var _this = this;
            // There might be 2 cases:
            // 1. when user is already on some page (router is stable) and performs an UI action
            // that triggers http call (i.e. button click to save data in backend)
            // 2. when user is navigating to some page and a route guard triggers the http call
            // (i.e. guard loading cms page data)
            //
            // In the second case, we want to remember the anticipated url before we navigate to
            // the login page, so we can redirect back to that URL after user authenticates.
            this.authRedirectService.saveCurrentNavigationUrl();
            // Logout user
            // TODO(#9638): Use logout route when it will support passing redirect url
            this.authService.coreLogout().finally(function () {
                _this.routingService.go({ cxRoute: 'login' });
                _this.globalMessageService.add({
                    key: 'httpHandlers.sessionExpired',
                }, exports.GlobalMessageType.MSG_TYPE_ERROR);
            });
        };
        // TODO:#13421 - remove this method
        /**
         * Attempts to refresh token if possible.
         * If it is not possible calls `handleExpiredRefreshToken`.
         *
         * @return observable which omits new access_token. (Warn: might never emit!).
         *
         * @deprecated will be removed in the next major. Use `getValidToken()` instead
         */
        AuthHttpHeaderService.prototype.handleExpiredToken = function () {
            var _this = this;
            var stream = this.authStorageService.getToken();
            var oldToken;
            return stream.pipe(operators.tap(function (token) {
                if (token.access_token &&
                    token.refresh_token &&
                    !oldToken &&
                    !_this.refreshInProgress) {
                    _this.refreshInProgress = true;
                    _this.oAuthLibWrapperService.refreshToken();
                }
                else if (!token.refresh_token) {
                    _this.handleExpiredRefreshToken();
                }
                oldToken = oldToken || token;
            }), operators.filter(function (token) { return oldToken.access_token !== token.access_token; }), operators.tap(function () {
                _this.refreshInProgress = false;
            }), operators.map(function (token) { return ((token === null || token === void 0 ? void 0 : token.access_token) ? token : undefined); }), operators.take(1));
        };
        /**
         * Emits the token or `undefined` only when the refresh or the logout processes are finished.
         */
        AuthHttpHeaderService.prototype.getStableToken = function () {
            var _this = this;
            return rxjs.combineLatest([
                this.token$,
                this.authService.refreshInProgress$,
                this.authService.logoutInProgress$,
            ]).pipe(operators.observeOn(rxjs.queueScheduler), operators.filter(function (_a) {
                var _b = __read(_a, 3), _ = _b[0], refreshInProgress = _b[1], logoutInProgress = _b[2];
                return !refreshInProgress && !logoutInProgress;
            }), operators.switchMap(function () { return _this.token$; }));
        };
        /**
         * Returns a valid access token.
         * It will attempt to refresh it if the current one expired; emits after the new one is retrieved.
         */
        AuthHttpHeaderService.prototype.getValidToken = function (requestToken) {
            var _this = this;
            return rxjs.defer(function () {
                // flag to only refresh token only on first emission
                var refreshTriggered = false;
                return _this.tokenToRetryRequest$.pipe(operators.tap(function (token) {
                    // we want to refresh the access token only when it is old.
                    // this is a guard for the case when there are multiple parallel http calls
                    if ((token === null || token === void 0 ? void 0 : token.access_token) === (requestToken === null || requestToken === void 0 ? void 0 : requestToken.access_token) &&
                        !refreshTriggered) {
                        _this.refreshTokenTrigger$.next(token);
                    }
                    refreshTriggered = true;
                }), operators.skipWhile(function (token) { return (token === null || token === void 0 ? void 0 : token.access_token) === requestToken.access_token; }), operators.take(1));
            });
        };
        AuthHttpHeaderService.prototype.createNewRequestWithNewToken = function (request, token) {
            request = request.clone({
                setHeaders: {
                    Authorization: (token.token_type || 'Bearer') + " " + token.access_token,
                },
            });
            return request;
        };
        AuthHttpHeaderService.prototype.ngOnDestroy = function () {
            this.subscriptions.unsubscribe();
        };
        return AuthHttpHeaderService;
    }());
    AuthHttpHeaderService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AuthHttpHeaderService, deps: [{ token: AuthService }, { token: AuthStorageService }, { token: OAuthLibWrapperService }, { token: RoutingService }, { token: OccEndpointsService }, { token: GlobalMessageService }, { token: AuthRedirectService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    AuthHttpHeaderService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AuthHttpHeaderService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AuthHttpHeaderService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: AuthService }, { type: AuthStorageService }, { type: OAuthLibWrapperService }, { type: RoutingService }, { type: OccEndpointsService }, { type: GlobalMessageService }, { type: AuthRedirectService }]; } });

    /**
     * Responsible for catching auth errors and providing `Authorization` header for API calls.
     * Uses AuthHttpHeaderService for request manipulation and error handling. Interceptor only hooks into request send/received events.
     */
    var AuthInterceptor = /** @class */ (function () {
        function AuthInterceptor(authHttpHeaderService, authConfigService) {
            this.authHttpHeaderService = authHttpHeaderService;
            this.authConfigService = authConfigService;
        }
        AuthInterceptor.prototype.intercept = function (request, next) {
            var _this = this;
            var shouldCatchError = this.authHttpHeaderService.shouldCatchError(request);
            var shouldAddAuthorizationHeader = this.authHttpHeaderService.shouldAddAuthorizationHeader(request);
            var token$ = shouldAddAuthorizationHeader
                ? // emits sync, unless there is refresh or logout in progress, in which case it emits async
                    this.authHttpHeaderService.getStableToken().pipe(operators.take(1))
                : rxjs.of(undefined);
            var requestAndToken$ = token$.pipe(operators.map(function (token) { return ({
                token: token,
                request: _this.authHttpHeaderService.alterRequest(request, token),
            }); }));
            return requestAndToken$.pipe(operators.switchMap(function (_d) {
                var request = _d.request, token = _d.token;
                return next.handle(request).pipe(operators.catchError(function (errResponse) {
                    var _a, _b;
                    if (errResponse instanceof i1$3.HttpErrorResponse) {
                        switch (errResponse.status) {
                            case 401: // Unauthorized
                                if (_this.isExpiredToken(errResponse) && shouldCatchError) {
                                    // request failed because of the expired access token
                                    // we should get refresh the token and retry the request, or logout if the refresh is missing / expired
                                    return _this.authHttpHeaderService.handleExpiredAccessToken(request, next, token);
                                }
                                else if (
                                // Refresh the expired token
                                // Check if the OAuth endpoint was called and the error is because the refresh token expired
                                ((_a = errResponse.url) === null || _a === void 0 ? void 0 : _a.includes(_this.authConfigService.getTokenEndpoint())) &&
                                    errResponse.error.error === 'invalid_token') {
                                    _this.authHttpHeaderService.handleExpiredRefreshToken();
                                    return rxjs.of();
                                }
                                break;
                            case 400: // Bad Request
                                if (((_b = errResponse.url) === null || _b === void 0 ? void 0 : _b.includes(_this.authConfigService.getTokenEndpoint())) &&
                                    errResponse.error.error === 'invalid_grant') {
                                    if (request.body.get('grant_type') === 'refresh_token') {
                                        _this.authHttpHeaderService.handleExpiredRefreshToken();
                                    }
                                }
                                break;
                        }
                    }
                    return rxjs.throwError(errResponse);
                }));
            }));
        };
        AuthInterceptor.prototype.isExpiredToken = function (resp) {
            var _a, _b, _c;
            return ((_c = (_b = (_a = resp.error) === null || _a === void 0 ? void 0 : _a.errors) === null || _b === void 0 ? void 0 : _b[0]) === null || _c === void 0 ? void 0 : _c.type) === 'InvalidTokenError';
        };
        return AuthInterceptor;
    }());
    AuthInterceptor.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AuthInterceptor, deps: [{ token: AuthHttpHeaderService }, { token: AuthConfigService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    AuthInterceptor.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AuthInterceptor, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AuthInterceptor, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }], ctorParameters: function () { return [{ type: AuthHttpHeaderService }, { type: AuthConfigService }]; } });

    /**
     * This interceptor is dedicated for Hybris OAuth server which requires `Authorization` header for revoke token calls.
     */
    var TokenRevocationInterceptor = /** @class */ (function () {
        function TokenRevocationInterceptor(authStorageService, authConfigService) {
            this.authStorageService = authStorageService;
            this.authConfigService = authConfigService;
        }
        TokenRevocationInterceptor.prototype.intercept = function (request, next) {
            var isTokenRevocationRequest = this.isTokenRevocationRequest(request);
            return this.authStorageService.getToken().pipe(operators.take(1), operators.switchMap(function (token) {
                if (isTokenRevocationRequest) {
                    request = request.clone({
                        setHeaders: {
                            Authorization: (token.token_type || 'Bearer') + " " + token.access_token,
                        },
                    });
                }
                return next.handle(request);
            }));
        };
        TokenRevocationInterceptor.prototype.isTokenRevocationRequest = function (request) {
            return request.url === this.authConfigService.getRevokeEndpoint();
        };
        return TokenRevocationInterceptor;
    }());
    TokenRevocationInterceptor.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: TokenRevocationInterceptor, deps: [{ token: AuthStorageService }, { token: AuthConfigService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    TokenRevocationInterceptor.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: TokenRevocationInterceptor, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: TokenRevocationInterceptor, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }], ctorParameters: function () { return [{ type: AuthStorageService }, { type: AuthConfigService }]; } });

    var interceptors$1 = [
        {
            provide: i1$3.HTTP_INTERCEPTORS,
            useExisting: AuthInterceptor,
            multi: true,
        },
        {
            provide: i1$3.HTTP_INTERCEPTORS,
            useExisting: TokenRevocationInterceptor,
            multi: true,
        },
    ];

    /**
     * Initialize the check for `token` or `code` in the url returned from the OAuth server.
     */
    function checkOAuthParamsInUrl(authService, configInit) {
        var result = function () { return configInit
            .getStable()
            .pipe(operators.switchMap(function () {
            // Wait for stable config is used, because with auth redirect would kick so quickly that the page would not be loaded correctly
            return authService.checkOAuthParamsInUrl();
        }))
            .toPromise(); };
        return result;
    }
    function authStatePersistenceFactory(authStatePersistenceService) {
        var result = function () { return authStatePersistenceService.initSync(); };
        return result;
    }
    /**
     * Authentication module for a user. Handlers requests for logged in users,
     * provides authorization services and storage for tokens.
     */
    var UserAuthModule = /** @class */ (function () {
        function UserAuthModule() {
        }
        UserAuthModule.forRoot = function () {
            return {
                ngModule: UserAuthModule,
                providers: __spreadArray(__spreadArray([
                    provideDefaultConfig(defaultAuthConfig),
                    provideConfigValidator(baseUrlConfigValidator)
                ], __read(interceptors$1)), [
                    {
                        provide: i1$1.OAuthStorage,
                        useExisting: AuthStorageService,
                    },
                    {
                        provide: i0.APP_INITIALIZER,
                        useFactory: authStatePersistenceFactory,
                        deps: [AuthStatePersistenceService],
                        multi: true,
                    },
                    {
                        provide: i0.APP_INITIALIZER,
                        useFactory: checkOAuthParamsInUrl,
                        deps: [AuthService, ConfigInitializerService],
                        multi: true,
                    },
                ]),
            };
        };
        return UserAuthModule;
    }());
    UserAuthModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserAuthModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    UserAuthModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserAuthModule, imports: [i6.CommonModule, i1__namespace.OAuthModule, UserAuthEventModule] });
    UserAuthModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserAuthModule, imports: [[i6.CommonModule, i1$1.OAuthModule.forRoot(), UserAuthEventModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserAuthModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [i6.CommonModule, i1$1.OAuthModule.forRoot(), UserAuthEventModule],
                    }]
            }] });

    var AuthModule = /** @class */ (function () {
        function AuthModule() {
        }
        AuthModule.forRoot = function () {
            return {
                ngModule: AuthModule,
            };
        };
        return AuthModule;
    }());
    AuthModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AuthModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    AuthModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AuthModule, imports: [i6.CommonModule, UserAuthModule, ClientAuthModule] });
    AuthModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AuthModule, imports: [[i6.CommonModule, UserAuthModule.forRoot(), ClientAuthModule.forRoot()]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AuthModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        // ClientAuthModule should always be imported after UserAuthModule because the ClientTokenInterceptor must be imported after the AuthInterceptor.
                        // This way, the ClientTokenInterceptor is the first to handle 401 errors and attempt to refresh the client token.
                        // If the request is not for the client token, the AuthInterceptor handles the refresh.
                        imports: [i6.CommonModule, UserAuthModule.forRoot(), ClientAuthModule.forRoot()],
                    }]
            }] });

    /**
     * Checks if there is currently logged in user.
     * Use to protect pages dedicated only for logged in users.
     */
    var AuthGuard = /** @class */ (function () {
        function AuthGuard(authService, authRedirectService, router, semanticPathService) {
            this.authService = authService;
            this.authRedirectService = authRedirectService;
            this.router = router;
            this.semanticPathService = semanticPathService;
        }
        AuthGuard.prototype.canActivate = function () {
            var _this = this;
            return this.authService.isUserLoggedIn().pipe(operators.map(function (isLoggedIn) {
                if (!isLoggedIn) {
                    _this.authRedirectService.saveCurrentNavigationUrl();
                    return _this.router.parseUrl(_this.semanticPathService.get('login'));
                }
                return isLoggedIn;
            }));
        };
        return AuthGuard;
    }());
    AuthGuard.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AuthGuard, deps: [{ token: AuthService }, { token: AuthRedirectService }, { token: i1__namespace$1.Router }, { token: SemanticPathService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    AuthGuard.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AuthGuard, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AuthGuard, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: AuthService }, { type: AuthRedirectService }, { type: i1__namespace$1.Router }, { type: SemanticPathService }]; } });

    /**
     * Checks if there isn't any logged in user.
     * Use to protect pages dedicated only for guests (eg. login page).
     */
    var NotAuthGuard = /** @class */ (function () {
        function NotAuthGuard(authService, authRedirectService, semanticPathService, router) {
            this.authService = authService;
            this.authRedirectService = authRedirectService;
            this.semanticPathService = semanticPathService;
            this.router = router;
        }
        NotAuthGuard.prototype.canActivate = function () {
            var _this = this;
            this.authRedirectService.reportNotAuthGuard();
            // redirect, if user is already logged in:
            return this.authService.isUserLoggedIn().pipe(operators.map(function (isLoggedIn) {
                if (isLoggedIn) {
                    return _this.router.parseUrl(_this.semanticPathService.get('home'));
                }
                return !isLoggedIn;
            }));
        };
        return NotAuthGuard;
    }());
    NotAuthGuard.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: NotAuthGuard, deps: [{ token: AuthService }, { token: AuthRedirectService }, { token: SemanticPathService }, { token: i1__namespace$1.Router }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    NotAuthGuard.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: NotAuthGuard, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: NotAuthGuard, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: AuthService }, { type: AuthRedirectService }, { type: SemanticPathService }, { type: i1__namespace$1.Router }]; } });

    var AnonymousConsentsConfig = /** @class */ (function (_super) {
        __extends(AnonymousConsentsConfig, _super);
        function AnonymousConsentsConfig() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return AnonymousConsentsConfig;
    }(OccConfig));
    AnonymousConsentsConfig.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AnonymousConsentsConfig, deps: null, target: i0__namespace.ɵɵFactoryTarget.Injectable });
    AnonymousConsentsConfig.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AnonymousConsentsConfig, providedIn: 'root', useExisting: Config });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AnonymousConsentsConfig, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                        useExisting: Config,
                    }]
            }] });

    var AnonymousConsentsInterceptor = /** @class */ (function () {
        function AnonymousConsentsInterceptor(anonymousConsentsService, authService, occEndpoints, config) {
            this.anonymousConsentsService = anonymousConsentsService;
            this.authService = authService;
            this.occEndpoints = occEndpoints;
            this.config = config;
        }
        AnonymousConsentsInterceptor.prototype.intercept = function (request, next) {
            var _this = this;
            return rxjs.combineLatest([
                this.anonymousConsentsService.getConsents(),
                this.authService.isUserLoggedIn(),
            ]).pipe(operators.take(1), operators.switchMap(function (_b) {
                var _c = __read(_b, 2), consents = _c[0], isUserLoggedIn = _c[1];
                if (!_this.isOccUrl(request.url)) {
                    return next.handle(request);
                }
                var clonedRequest = _this.handleRequest(consents, request);
                return next.handle(clonedRequest).pipe(operators.tap(function (event) {
                    var _a;
                    if (event instanceof i1$3.HttpResponse &&
                        ((_a = event.url) !== null && _a !== void 0 ? _a : '').startsWith(_this.occEndpoints.buildUrl('anonymousConsentTemplates'))) {
                        _this.handleResponse(isUserLoggedIn, event.headers.get(ANONYMOUS_CONSENTS_HEADER), consents);
                    }
                }));
            }));
        };
        AnonymousConsentsInterceptor.prototype.handleResponse = function (isUserLoggedIn, newRawConsents, previousConsents) {
            if (!isUserLoggedIn && newRawConsents) {
                var newConsents = [];
                newConsents =
                    this.anonymousConsentsService.decodeAndDeserialize(newRawConsents);
                newConsents = this.giveRequiredConsents(newConsents);
                if (this.anonymousConsentsService.consentsUpdated(newConsents, previousConsents)) {
                    this.anonymousConsentsService.setConsents(newConsents);
                }
            }
        };
        AnonymousConsentsInterceptor.prototype.handleRequest = function (consents, request) {
            var _b;
            if (!consents) {
                return request;
            }
            var rawConsents = this.anonymousConsentsService.serializeAndEncode(consents);
            return request.clone({
                setHeaders: (_b = {},
                    _b[ANONYMOUS_CONSENTS_HEADER] = rawConsents,
                    _b),
            });
        };
        AnonymousConsentsInterceptor.prototype.isOccUrl = function (url) {
            return url.includes(this.occEndpoints.getBaseUrl());
        };
        AnonymousConsentsInterceptor.prototype.giveRequiredConsents = function (consents) {
            var e_1, _b;
            var givenConsents = __spreadArray([], __read(consents));
            if (Boolean(this.config.anonymousConsents) &&
                Boolean(this.config.anonymousConsents.requiredConsents)) {
                try {
                    for (var givenConsents_1 = __values(givenConsents), givenConsents_1_1 = givenConsents_1.next(); !givenConsents_1_1.done; givenConsents_1_1 = givenConsents_1.next()) {
                        var consent = givenConsents_1_1.value;
                        if (this.config.anonymousConsents.requiredConsents.includes(consent.templateCode)) {
                            consent.consentState = exports.ANONYMOUS_CONSENT_STATUS.GIVEN;
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (givenConsents_1_1 && !givenConsents_1_1.done && (_b = givenConsents_1.return)) _b.call(givenConsents_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
            return givenConsents;
        };
        return AnonymousConsentsInterceptor;
    }());
    AnonymousConsentsInterceptor.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AnonymousConsentsInterceptor, deps: [{ token: AnonymousConsentsService }, { token: AuthService }, { token: OccEndpointsService }, { token: AnonymousConsentsConfig }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    AnonymousConsentsInterceptor.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AnonymousConsentsInterceptor, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AnonymousConsentsInterceptor, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }], ctorParameters: function () { return [{ type: AnonymousConsentsService }, { type: AuthService }, { type: OccEndpointsService }, { type: AnonymousConsentsConfig }]; } });

    var interceptors = [
        {
            provide: i1$3.HTTP_INTERCEPTORS,
            useExisting: AnonymousConsentsInterceptor,
            multi: true,
        },
    ];

    var LOAD_BILLING_COUNTRIES = '[User] Load Billing Countries';
    var LOAD_BILLING_COUNTRIES_FAIL = '[User] Load Billing Countries Fail';
    var LOAD_BILLING_COUNTRIES_SUCCESS = '[User] Load Billing Countries Success';
    var LoadBillingCountries = /** @class */ (function () {
        function LoadBillingCountries() {
            this.type = LOAD_BILLING_COUNTRIES;
        }
        return LoadBillingCountries;
    }());
    var LoadBillingCountriesFail = /** @class */ (function () {
        function LoadBillingCountriesFail(payload) {
            this.payload = payload;
            this.type = LOAD_BILLING_COUNTRIES_FAIL;
        }
        return LoadBillingCountriesFail;
    }());
    var LoadBillingCountriesSuccess = /** @class */ (function () {
        function LoadBillingCountriesSuccess(payload) {
            this.payload = payload;
            this.type = LOAD_BILLING_COUNTRIES_SUCCESS;
        }
        return LoadBillingCountriesSuccess;
    }());

    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var LOAD_CONSIGNMENT_TRACKING = '[User] Load Consignment Tracking';
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var LOAD_CONSIGNMENT_TRACKING_FAIL = '[User] Load Consignment Tracking Fail';
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var LOAD_CONSIGNMENT_TRACKING_SUCCESS = '[User] Load Consignment Tracking Success';
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var CLEAR_CONSIGNMENT_TRACKING = '[User] Clear Consignment Tracking';
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var LoadConsignmentTracking = /** @class */ (function () {
        function LoadConsignmentTracking(payload) {
            this.payload = payload;
            this.type = LOAD_CONSIGNMENT_TRACKING;
        }
        return LoadConsignmentTracking;
    }());
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var LoadConsignmentTrackingFail = /** @class */ (function () {
        function LoadConsignmentTrackingFail(payload) {
            this.payload = payload;
            this.type = LOAD_CONSIGNMENT_TRACKING_FAIL;
        }
        return LoadConsignmentTrackingFail;
    }());
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var LoadConsignmentTrackingSuccess = /** @class */ (function () {
        function LoadConsignmentTrackingSuccess(payload) {
            this.payload = payload;
            this.type = LOAD_CONSIGNMENT_TRACKING_SUCCESS;
        }
        return LoadConsignmentTrackingSuccess;
    }());
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var ClearConsignmentTracking = /** @class */ (function () {
        function ClearConsignmentTracking() {
            this.type = CLEAR_CONSIGNMENT_TRACKING;
        }
        return ClearConsignmentTracking;
    }());

    var USER_FEATURE = 'user';
    var REGISTER_USER_PROCESS_ID = 'registerUser';
    var GIVE_CONSENT_PROCESS_ID = 'giveConsent';
    var WITHDRAW_CONSENT_PROCESS_ID = 'withdrawConsent';
    var UPDATE_NOTIFICATION_PREFERENCES_PROCESS_ID = 'updateNotificationPreferences';
    var ADD_PRODUCT_INTEREST_PROCESS_ID = 'addProductInterests';
    var REMOVE_PRODUCT_INTERESTS_PROCESS_ID = 'removeProductInterests';
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var CANCEL_ORDER_PROCESS_ID = 'cancelOrder';
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var CANCEL_RETURN_PROCESS_ID = 'cancelReturn';
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var CANCEL_REPLENISHMENT_ORDER_PROCESS_ID = 'cancelReplenishmentOrder';
    var USER_CONSENTS = '[User] User Consents';
    var USER_PAYMENT_METHODS = '[User] User Payment Methods';
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var USER_ORDERS = '[User] User Orders';
    var USER_ADDRESSES = '[User] User Addresses';
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var USER_RETURN_REQUESTS = '[User] Order Return Requests';
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var USER_RETURN_REQUEST_DETAILS = '[User] Return Request Details';
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var USER_ORDER_DETAILS = '[User] User Order Details';
    var USER_COST_CENTERS = '[User] User Cost Centers';
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var USER_REPLENISHMENT_ORDERS = '[User] User Replenishment Orders';
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var USER_REPLENISHMENT_ORDER_DETAILS = '[User] User Replenishment Order Details';
    var REGIONS = '[User] Regions';
    var CUSTOMER_COUPONS = '[User] Customer Coupons';
    var SUBSCRIBE_CUSTOMER_COUPON_PROCESS_ID = 'subscribeCustomerCoupon';
    var UNSUBSCRIBE_CUSTOMER_COUPON_PROCESS_ID = 'unsubscribeCustomerCoupon';
    var CLAIM_CUSTOMER_COUPON_PROCESS_ID = 'claimCustomerCoupon';
    var NOTIFICATION_PREFERENCES = '[User] Notification Preferences';
    var PRODUCT_INTERESTS = '[User] Product Interests';

    var PROCESS_FEATURE = 'process';

    function getProcessState() {
        return i1.createFeatureSelector(PROCESS_FEATURE);
    }

    function getProcessStateFactory(processId) {
        return i1.createSelector(getProcessState(), function (entityState) { return entityLoaderStateSelector(entityState, processId); });
    }
    function getProcessLoadingFactory(processId) {
        return i1.createSelector(getProcessStateFactory(processId), function (loaderState) { return loaderLoadingSelector(loaderState); });
    }
    function getProcessSuccessFactory(processId) {
        return i1.createSelector(getProcessStateFactory(processId), function (loaderState) { return loaderSuccessSelector(loaderState); });
    }
    function getProcessErrorFactory(processId) {
        return i1.createSelector(getProcessStateFactory(processId), function (loaderState) { return loaderErrorSelector(loaderState); });
    }

    var process_selectors = /*#__PURE__*/Object.freeze({
        __proto__: null,
        getProcessStateFactory: getProcessStateFactory,
        getProcessLoadingFactory: getProcessLoadingFactory,
        getProcessSuccessFactory: getProcessSuccessFactory,
        getProcessErrorFactory: getProcessErrorFactory
    });

    var LOAD_CUSTOMER_COUPONS = '[User] Load Customer Coupons';
    var LOAD_CUSTOMER_COUPONS_FAIL = '[User] Load Customer Coupons Fail';
    var LOAD_CUSTOMER_COUPONS_SUCCESS = '[User] Load Customer Coupons Success';
    var RESET_LOAD_CUSTOMER_COUPONS = '[User] Reset Load Customer Coupons';
    var SUBSCRIBE_CUSTOMER_COUPON = '[User] Subscribe Customer Notification Coupon';
    var SUBSCRIBE_CUSTOMER_COUPON_FAIL = '[User] Subscribe Customer Coupon Notification Fail';
    var SUBSCRIBE_CUSTOMER_COUPON_SUCCESS = '[User] Subscribe Customer Coupon Notification Success';
    var RESET_SUBSCRIBE_CUSTOMER_COUPON_PROCESS = '[User] Reset Subscribe Customer Coupon Process';
    var UNSUBSCRIBE_CUSTOMER_COUPON = '[User] Unsubscribe Customer Notification Coupon';
    var UNSUBSCRIBE_CUSTOMER_COUPON_FAIL = '[User] Unsubscribe Customer Coupon Notification Fail';
    var UNSUBSCRIBE_CUSTOMER_COUPON_SUCCESS = '[User] Unsubscribe Customer Coupon Notification Success';
    var RESET_UNSUBSCRIBE_CUSTOMER_COUPON_PROCESS = '[User] Reset Unsubscribe Customer Coupon Process';
    var CLAIM_CUSTOMER_COUPON = '[User] Claim Customer';
    var CLAIM_CUSTOMER_COUPON_FAIL = '[User] Claim Customer Fail';
    var CLAIM_CUSTOMER_COUPON_SUCCESS = '[User] Claim Customer Success';
    var LoadCustomerCoupons = /** @class */ (function (_super) {
        __extends(LoadCustomerCoupons, _super);
        function LoadCustomerCoupons(payload) {
            var _this = _super.call(this, CUSTOMER_COUPONS) || this;
            _this.payload = payload;
            _this.type = LOAD_CUSTOMER_COUPONS;
            return _this;
        }
        return LoadCustomerCoupons;
    }(LoaderLoadAction));
    var LoadCustomerCouponsFail = /** @class */ (function (_super) {
        __extends(LoadCustomerCouponsFail, _super);
        function LoadCustomerCouponsFail(payload) {
            var _this = _super.call(this, CUSTOMER_COUPONS, payload) || this;
            _this.payload = payload;
            _this.type = LOAD_CUSTOMER_COUPONS_FAIL;
            return _this;
        }
        return LoadCustomerCouponsFail;
    }(LoaderFailAction));
    var LoadCustomerCouponsSuccess = /** @class */ (function (_super) {
        __extends(LoadCustomerCouponsSuccess, _super);
        function LoadCustomerCouponsSuccess(payload) {
            var _this = _super.call(this, CUSTOMER_COUPONS) || this;
            _this.payload = payload;
            _this.type = LOAD_CUSTOMER_COUPONS_SUCCESS;
            return _this;
        }
        return LoadCustomerCouponsSuccess;
    }(LoaderSuccessAction));
    var ResetLoadCustomerCoupons = /** @class */ (function (_super) {
        __extends(ResetLoadCustomerCoupons, _super);
        function ResetLoadCustomerCoupons() {
            var _this = _super.call(this, CUSTOMER_COUPONS) || this;
            _this.type = RESET_LOAD_CUSTOMER_COUPONS;
            return _this;
        }
        return ResetLoadCustomerCoupons;
    }(LoaderResetAction));
    // Subscribe coupon notification actions
    var SubscribeCustomerCoupon = /** @class */ (function (_super) {
        __extends(SubscribeCustomerCoupon, _super);
        function SubscribeCustomerCoupon(payload) {
            var _this = _super.call(this, PROCESS_FEATURE, SUBSCRIBE_CUSTOMER_COUPON_PROCESS_ID) || this;
            _this.payload = payload;
            _this.type = SUBSCRIBE_CUSTOMER_COUPON;
            return _this;
        }
        return SubscribeCustomerCoupon;
    }(EntityLoadAction));
    var SubscribeCustomerCouponFail = /** @class */ (function (_super) {
        __extends(SubscribeCustomerCouponFail, _super);
        function SubscribeCustomerCouponFail(payload) {
            var _this = _super.call(this, PROCESS_FEATURE, SUBSCRIBE_CUSTOMER_COUPON_PROCESS_ID, payload) || this;
            _this.payload = payload;
            _this.type = SUBSCRIBE_CUSTOMER_COUPON_FAIL;
            return _this;
        }
        return SubscribeCustomerCouponFail;
    }(EntityFailAction));
    var SubscribeCustomerCouponSuccess = /** @class */ (function (_super) {
        __extends(SubscribeCustomerCouponSuccess, _super);
        function SubscribeCustomerCouponSuccess(payload) {
            var _this = _super.call(this, PROCESS_FEATURE, SUBSCRIBE_CUSTOMER_COUPON_PROCESS_ID, payload) || this;
            _this.payload = payload;
            _this.type = SUBSCRIBE_CUSTOMER_COUPON_SUCCESS;
            return _this;
        }
        return SubscribeCustomerCouponSuccess;
    }(EntitySuccessAction));
    var ResetSubscribeCustomerCouponProcess = /** @class */ (function (_super) {
        __extends(ResetSubscribeCustomerCouponProcess, _super);
        function ResetSubscribeCustomerCouponProcess() {
            var _this = _super.call(this, PROCESS_FEATURE, SUBSCRIBE_CUSTOMER_COUPON_PROCESS_ID) || this;
            _this.type = RESET_SUBSCRIBE_CUSTOMER_COUPON_PROCESS;
            return _this;
        }
        return ResetSubscribeCustomerCouponProcess;
    }(EntityLoaderResetAction));
    var UnsubscribeCustomerCoupon = /** @class */ (function (_super) {
        __extends(UnsubscribeCustomerCoupon, _super);
        function UnsubscribeCustomerCoupon(payload) {
            var _this = _super.call(this, PROCESS_FEATURE, UNSUBSCRIBE_CUSTOMER_COUPON_PROCESS_ID) || this;
            _this.payload = payload;
            _this.type = UNSUBSCRIBE_CUSTOMER_COUPON;
            return _this;
        }
        return UnsubscribeCustomerCoupon;
    }(EntityLoadAction));
    var UnsubscribeCustomerCouponFail = /** @class */ (function (_super) {
        __extends(UnsubscribeCustomerCouponFail, _super);
        function UnsubscribeCustomerCouponFail(payload) {
            var _this = _super.call(this, PROCESS_FEATURE, UNSUBSCRIBE_CUSTOMER_COUPON_PROCESS_ID, payload) || this;
            _this.payload = payload;
            _this.type = UNSUBSCRIBE_CUSTOMER_COUPON_FAIL;
            return _this;
        }
        return UnsubscribeCustomerCouponFail;
    }(EntityFailAction));
    var UnsubscribeCustomerCouponSuccess = /** @class */ (function (_super) {
        __extends(UnsubscribeCustomerCouponSuccess, _super);
        function UnsubscribeCustomerCouponSuccess(payload) {
            var _this = _super.call(this, PROCESS_FEATURE, UNSUBSCRIBE_CUSTOMER_COUPON_PROCESS_ID, payload) || this;
            _this.payload = payload;
            _this.type = UNSUBSCRIBE_CUSTOMER_COUPON_SUCCESS;
            return _this;
        }
        return UnsubscribeCustomerCouponSuccess;
    }(EntitySuccessAction));
    var ResetUnsubscribeCustomerCouponProcess = /** @class */ (function (_super) {
        __extends(ResetUnsubscribeCustomerCouponProcess, _super);
        function ResetUnsubscribeCustomerCouponProcess() {
            var _this = _super.call(this, PROCESS_FEATURE, UNSUBSCRIBE_CUSTOMER_COUPON_PROCESS_ID) || this;
            _this.type = RESET_UNSUBSCRIBE_CUSTOMER_COUPON_PROCESS;
            return _this;
        }
        return ResetUnsubscribeCustomerCouponProcess;
    }(EntityLoaderResetAction));
    var ClaimCustomerCoupon = /** @class */ (function (_super) {
        __extends(ClaimCustomerCoupon, _super);
        function ClaimCustomerCoupon(payload) {
            var _this = _super.call(this, PROCESS_FEATURE, CLAIM_CUSTOMER_COUPON_PROCESS_ID) || this;
            _this.payload = payload;
            _this.type = CLAIM_CUSTOMER_COUPON;
            return _this;
        }
        return ClaimCustomerCoupon;
    }(EntityLoadAction));
    var ClaimCustomerCouponFail = /** @class */ (function (_super) {
        __extends(ClaimCustomerCouponFail, _super);
        function ClaimCustomerCouponFail(payload) {
            var _this = _super.call(this, PROCESS_FEATURE, CLAIM_CUSTOMER_COUPON_PROCESS_ID, payload) || this;
            _this.payload = payload;
            _this.type = CLAIM_CUSTOMER_COUPON_FAIL;
            return _this;
        }
        return ClaimCustomerCouponFail;
    }(EntityFailAction));
    var ClaimCustomerCouponSuccess = /** @class */ (function (_super) {
        __extends(ClaimCustomerCouponSuccess, _super);
        function ClaimCustomerCouponSuccess(payload) {
            var _this = _super.call(this, PROCESS_FEATURE, CLAIM_CUSTOMER_COUPON_PROCESS_ID, payload) || this;
            _this.payload = payload;
            _this.type = CLAIM_CUSTOMER_COUPON_SUCCESS;
            return _this;
        }
        return ClaimCustomerCouponSuccess;
    }(EntitySuccessAction));

    var LOAD_DELIVERY_COUNTRIES = '[User] Load Delivery Countries';
    var LOAD_DELIVERY_COUNTRIES_FAIL = '[User] Load Delivery Countries Fail';
    var LOAD_DELIVERY_COUNTRIES_SUCCESS = '[User] Load Delivery Countries Success';
    var LoadDeliveryCountries = /** @class */ (function () {
        function LoadDeliveryCountries() {
            this.type = LOAD_DELIVERY_COUNTRIES;
        }
        return LoadDeliveryCountries;
    }());
    var LoadDeliveryCountriesFail = /** @class */ (function () {
        function LoadDeliveryCountriesFail(payload) {
            this.payload = payload;
            this.type = LOAD_DELIVERY_COUNTRIES_FAIL;
        }
        return LoadDeliveryCountriesFail;
    }());
    var LoadDeliveryCountriesSuccess = /** @class */ (function () {
        function LoadDeliveryCountriesSuccess(payload) {
            this.payload = payload;
            this.type = LOAD_DELIVERY_COUNTRIES_SUCCESS;
        }
        return LoadDeliveryCountriesSuccess;
    }());

    var LOAD_NOTIFICATION_PREFERENCES = '[User] Load Notification Preferences';
    var LOAD_NOTIFICATION_PREFERENCES_FAIL = '[User] Load Notification Preferences Fail';
    var LOAD_NOTIFICATION_PREFERENCES_SUCCESS = '[User] Load Notification Preferences Success';
    var UPDATE_NOTIFICATION_PREFERENCES = '[User] Update Notification Preferences';
    var UPDATE_NOTIFICATION_PREFERENCES_FAIL = '[User] Update Notification Preferences Fail';
    var UPDATE_NOTIFICATION_PREFERENCES_SUCCESS = '[User] Update Notification Preferences Success';
    var RESET_NOTIFICATION_PREFERENCES = '[User] Reset Notification Preferences';
    var CLEAR_NOTIFICATION_PREFERENCES = '[User] Clear Notification Preferences';
    var LoadNotificationPreferences = /** @class */ (function (_super) {
        __extends(LoadNotificationPreferences, _super);
        function LoadNotificationPreferences(payload) {
            var _this = _super.call(this, NOTIFICATION_PREFERENCES) || this;
            _this.payload = payload;
            _this.type = LOAD_NOTIFICATION_PREFERENCES;
            return _this;
        }
        return LoadNotificationPreferences;
    }(LoaderLoadAction));
    var LoadNotificationPreferencesFail = /** @class */ (function (_super) {
        __extends(LoadNotificationPreferencesFail, _super);
        function LoadNotificationPreferencesFail(payload) {
            var _this = _super.call(this, NOTIFICATION_PREFERENCES, payload) || this;
            _this.payload = payload;
            _this.type = LOAD_NOTIFICATION_PREFERENCES_FAIL;
            return _this;
        }
        return LoadNotificationPreferencesFail;
    }(LoaderFailAction));
    var LoadNotificationPreferencesSuccess = /** @class */ (function (_super) {
        __extends(LoadNotificationPreferencesSuccess, _super);
        function LoadNotificationPreferencesSuccess(payload) {
            var _this = _super.call(this, NOTIFICATION_PREFERENCES) || this;
            _this.payload = payload;
            _this.type = LOAD_NOTIFICATION_PREFERENCES_SUCCESS;
            return _this;
        }
        return LoadNotificationPreferencesSuccess;
    }(LoaderSuccessAction));
    var UpdateNotificationPreferences = /** @class */ (function (_super) {
        __extends(UpdateNotificationPreferences, _super);
        function UpdateNotificationPreferences(payload) {
            var _this = _super.call(this, PROCESS_FEATURE, UPDATE_NOTIFICATION_PREFERENCES_PROCESS_ID) || this;
            _this.payload = payload;
            _this.type = UPDATE_NOTIFICATION_PREFERENCES;
            return _this;
        }
        return UpdateNotificationPreferences;
    }(EntityLoadAction));
    var UpdateNotificationPreferencesFail = /** @class */ (function (_super) {
        __extends(UpdateNotificationPreferencesFail, _super);
        function UpdateNotificationPreferencesFail(payload) {
            var _this = _super.call(this, PROCESS_FEATURE, UPDATE_NOTIFICATION_PREFERENCES_PROCESS_ID, payload) || this;
            _this.payload = payload;
            _this.type = UPDATE_NOTIFICATION_PREFERENCES_FAIL;
            return _this;
        }
        return UpdateNotificationPreferencesFail;
    }(EntityFailAction));
    var UpdateNotificationPreferencesSuccess = /** @class */ (function (_super) {
        __extends(UpdateNotificationPreferencesSuccess, _super);
        function UpdateNotificationPreferencesSuccess(payload) {
            var _this = _super.call(this, PROCESS_FEATURE, UPDATE_NOTIFICATION_PREFERENCES_PROCESS_ID) || this;
            _this.payload = payload;
            _this.type = UPDATE_NOTIFICATION_PREFERENCES_SUCCESS;
            return _this;
        }
        return UpdateNotificationPreferencesSuccess;
    }(EntitySuccessAction));
    var ResetNotificationPreferences = /** @class */ (function (_super) {
        __extends(ResetNotificationPreferences, _super);
        function ResetNotificationPreferences() {
            var _this = _super.call(this, PROCESS_FEATURE, UPDATE_NOTIFICATION_PREFERENCES_PROCESS_ID) || this;
            _this.type = RESET_NOTIFICATION_PREFERENCES;
            return _this;
        }
        return ResetNotificationPreferences;
    }(EntityLoaderResetAction));
    var ClearNotificationPreferences = /** @class */ (function (_super) {
        __extends(ClearNotificationPreferences, _super);
        function ClearNotificationPreferences() {
            var _this = _super.call(this, NOTIFICATION_PREFERENCES) || this;
            _this.type = CLEAR_NOTIFICATION_PREFERENCES;
            return _this;
        }
        return ClearNotificationPreferences;
    }(LoaderResetAction));

    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var LOAD_ORDER_DETAILS = '[User] Load Order Details';
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var LOAD_ORDER_DETAILS_FAIL = '[User] Load Order Details Fail';
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var LOAD_ORDER_DETAILS_SUCCESS = '[User] Load Order Details Success';
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var CLEAR_ORDER_DETAILS = '[User] Clear Order Details';
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var CANCEL_ORDER = '[User] Cancel Order';
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var CANCEL_ORDER_FAIL = '[User] Cancel Order Fail';
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var CANCEL_ORDER_SUCCESS = '[User] Cancel Order Success';
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var RESET_CANCEL_ORDER_PROCESS = '[User] Reset Cancel Order Process';
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var LoadOrderDetails = /** @class */ (function (_super) {
        __extends(LoadOrderDetails, _super);
        function LoadOrderDetails(payload) {
            var _this = _super.call(this, USER_ORDER_DETAILS) || this;
            _this.payload = payload;
            _this.type = LOAD_ORDER_DETAILS;
            return _this;
        }
        return LoadOrderDetails;
    }(LoaderLoadAction));
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var LoadOrderDetailsFail = /** @class */ (function (_super) {
        __extends(LoadOrderDetailsFail, _super);
        function LoadOrderDetailsFail(payload) {
            var _this = _super.call(this, USER_ORDER_DETAILS, payload) || this;
            _this.payload = payload;
            _this.type = LOAD_ORDER_DETAILS_FAIL;
            return _this;
        }
        return LoadOrderDetailsFail;
    }(LoaderFailAction));
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var LoadOrderDetailsSuccess = /** @class */ (function (_super) {
        __extends(LoadOrderDetailsSuccess, _super);
        function LoadOrderDetailsSuccess(payload) {
            var _this = _super.call(this, USER_ORDER_DETAILS) || this;
            _this.payload = payload;
            _this.type = LOAD_ORDER_DETAILS_SUCCESS;
            return _this;
        }
        return LoadOrderDetailsSuccess;
    }(LoaderSuccessAction));
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var ClearOrderDetails = /** @class */ (function (_super) {
        __extends(ClearOrderDetails, _super);
        function ClearOrderDetails() {
            var _this = _super.call(this, USER_ORDER_DETAILS) || this;
            _this.type = CLEAR_ORDER_DETAILS;
            return _this;
        }
        return ClearOrderDetails;
    }(LoaderResetAction));
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var CancelOrder = /** @class */ (function (_super) {
        __extends(CancelOrder, _super);
        function CancelOrder(payload) {
            var _this = _super.call(this, PROCESS_FEATURE, CANCEL_ORDER_PROCESS_ID) || this;
            _this.payload = payload;
            _this.type = CANCEL_ORDER;
            return _this;
        }
        return CancelOrder;
    }(EntityLoadAction));
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var CancelOrderFail = /** @class */ (function (_super) {
        __extends(CancelOrderFail, _super);
        function CancelOrderFail(payload) {
            var _this = _super.call(this, PROCESS_FEATURE, CANCEL_ORDER_PROCESS_ID, payload) || this;
            _this.payload = payload;
            _this.type = CANCEL_ORDER_FAIL;
            return _this;
        }
        return CancelOrderFail;
    }(EntityFailAction));
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var CancelOrderSuccess = /** @class */ (function (_super) {
        __extends(CancelOrderSuccess, _super);
        function CancelOrderSuccess() {
            var _this = _super.call(this, PROCESS_FEATURE, CANCEL_ORDER_PROCESS_ID) || this;
            _this.type = CANCEL_ORDER_SUCCESS;
            return _this;
        }
        return CancelOrderSuccess;
    }(EntitySuccessAction));
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var ResetCancelOrderProcess = /** @class */ (function (_super) {
        __extends(ResetCancelOrderProcess, _super);
        function ResetCancelOrderProcess() {
            var _this = _super.call(this, PROCESS_FEATURE, CANCEL_ORDER_PROCESS_ID) || this;
            _this.type = RESET_CANCEL_ORDER_PROCESS;
            return _this;
        }
        return ResetCancelOrderProcess;
    }(EntityLoaderResetAction));

    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var CREATE_ORDER_RETURN_REQUEST = '[User] Create Order Return Request';
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var CREATE_ORDER_RETURN_REQUEST_FAIL = '[User] Create Order Return Request Fail';
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var CREATE_ORDER_RETURN_REQUEST_SUCCESS = '[User] Create Order Return Request Success';
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var LOAD_ORDER_RETURN_REQUEST = '[User] Load Order Return Request details';
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var LOAD_ORDER_RETURN_REQUEST_FAIL = '[User] Load Order Return Request details Fail';
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var LOAD_ORDER_RETURN_REQUEST_SUCCESS = '[User] Load Order Return Request details Success';
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var CANCEL_ORDER_RETURN_REQUEST = '[User] Cancel Order Return Request';
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var CANCEL_ORDER_RETURN_REQUEST_FAIL = '[User] Cancel Order Return Request Fail';
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var CANCEL_ORDER_RETURN_REQUEST_SUCCESS = '[User] Cancel Order Return Request Success';
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var LOAD_ORDER_RETURN_REQUEST_LIST = '[User] Load User Order Return Request List';
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var LOAD_ORDER_RETURN_REQUEST_LIST_FAIL = '[User] Load User Order Return Request List Fail';
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var LOAD_ORDER_RETURN_REQUEST_LIST_SUCCESS = '[User] Load User Order Return Request List Success';
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var CLEAR_ORDER_RETURN_REQUEST = '[User] Clear Order Return Request Details';
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var CLEAR_ORDER_RETURN_REQUEST_LIST = '[User] Clear Order Return Request List';
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var RESET_CANCEL_RETURN_PROCESS = '[User] Reset Cancel Return Request Process';
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var CreateOrderReturnRequest = /** @class */ (function (_super) {
        __extends(CreateOrderReturnRequest, _super);
        function CreateOrderReturnRequest(payload) {
            var _this = _super.call(this, USER_RETURN_REQUEST_DETAILS) || this;
            _this.payload = payload;
            _this.type = CREATE_ORDER_RETURN_REQUEST;
            return _this;
        }
        return CreateOrderReturnRequest;
    }(LoaderLoadAction));
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var CreateOrderReturnRequestFail = /** @class */ (function (_super) {
        __extends(CreateOrderReturnRequestFail, _super);
        function CreateOrderReturnRequestFail(payload) {
            var _this = _super.call(this, USER_RETURN_REQUEST_DETAILS, payload) || this;
            _this.payload = payload;
            _this.type = CREATE_ORDER_RETURN_REQUEST_FAIL;
            return _this;
        }
        return CreateOrderReturnRequestFail;
    }(LoaderFailAction));
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var CreateOrderReturnRequestSuccess = /** @class */ (function (_super) {
        __extends(CreateOrderReturnRequestSuccess, _super);
        function CreateOrderReturnRequestSuccess(payload) {
            var _this = _super.call(this, USER_RETURN_REQUEST_DETAILS) || this;
            _this.payload = payload;
            _this.type = CREATE_ORDER_RETURN_REQUEST_SUCCESS;
            return _this;
        }
        return CreateOrderReturnRequestSuccess;
    }(LoaderSuccessAction));
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var LoadOrderReturnRequest = /** @class */ (function (_super) {
        __extends(LoadOrderReturnRequest, _super);
        function LoadOrderReturnRequest(payload) {
            var _this = _super.call(this, USER_RETURN_REQUEST_DETAILS) || this;
            _this.payload = payload;
            _this.type = LOAD_ORDER_RETURN_REQUEST;
            return _this;
        }
        return LoadOrderReturnRequest;
    }(LoaderLoadAction));
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var LoadOrderReturnRequestFail = /** @class */ (function (_super) {
        __extends(LoadOrderReturnRequestFail, _super);
        function LoadOrderReturnRequestFail(payload) {
            var _this = _super.call(this, USER_RETURN_REQUEST_DETAILS, payload) || this;
            _this.payload = payload;
            _this.type = LOAD_ORDER_RETURN_REQUEST_FAIL;
            return _this;
        }
        return LoadOrderReturnRequestFail;
    }(LoaderFailAction));
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var LoadOrderReturnRequestSuccess = /** @class */ (function (_super) {
        __extends(LoadOrderReturnRequestSuccess, _super);
        function LoadOrderReturnRequestSuccess(payload) {
            var _this = _super.call(this, USER_RETURN_REQUEST_DETAILS) || this;
            _this.payload = payload;
            _this.type = LOAD_ORDER_RETURN_REQUEST_SUCCESS;
            return _this;
        }
        return LoadOrderReturnRequestSuccess;
    }(LoaderSuccessAction));
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var CancelOrderReturnRequest = /** @class */ (function (_super) {
        __extends(CancelOrderReturnRequest, _super);
        function CancelOrderReturnRequest(payload) {
            var _this = _super.call(this, PROCESS_FEATURE, CANCEL_RETURN_PROCESS_ID) || this;
            _this.payload = payload;
            _this.type = CANCEL_ORDER_RETURN_REQUEST;
            return _this;
        }
        return CancelOrderReturnRequest;
    }(EntityLoadAction));
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var CancelOrderReturnRequestFail = /** @class */ (function (_super) {
        __extends(CancelOrderReturnRequestFail, _super);
        function CancelOrderReturnRequestFail(payload) {
            var _this = _super.call(this, PROCESS_FEATURE, CANCEL_RETURN_PROCESS_ID, payload) || this;
            _this.payload = payload;
            _this.type = CANCEL_ORDER_RETURN_REQUEST_FAIL;
            return _this;
        }
        return CancelOrderReturnRequestFail;
    }(EntityFailAction));
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var CancelOrderReturnRequestSuccess = /** @class */ (function (_super) {
        __extends(CancelOrderReturnRequestSuccess, _super);
        function CancelOrderReturnRequestSuccess() {
            var _this = _super.call(this, PROCESS_FEATURE, CANCEL_RETURN_PROCESS_ID) || this;
            _this.type = CANCEL_ORDER_RETURN_REQUEST_SUCCESS;
            return _this;
        }
        return CancelOrderReturnRequestSuccess;
    }(EntitySuccessAction));
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var LoadOrderReturnRequestList = /** @class */ (function (_super) {
        __extends(LoadOrderReturnRequestList, _super);
        function LoadOrderReturnRequestList(payload) {
            var _this = _super.call(this, USER_RETURN_REQUESTS) || this;
            _this.payload = payload;
            _this.type = LOAD_ORDER_RETURN_REQUEST_LIST;
            return _this;
        }
        return LoadOrderReturnRequestList;
    }(LoaderLoadAction));
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var LoadOrderReturnRequestListFail = /** @class */ (function (_super) {
        __extends(LoadOrderReturnRequestListFail, _super);
        function LoadOrderReturnRequestListFail(payload) {
            var _this = _super.call(this, USER_RETURN_REQUESTS, payload) || this;
            _this.payload = payload;
            _this.type = LOAD_ORDER_RETURN_REQUEST_LIST_FAIL;
            return _this;
        }
        return LoadOrderReturnRequestListFail;
    }(LoaderFailAction));
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var LoadOrderReturnRequestListSuccess = /** @class */ (function (_super) {
        __extends(LoadOrderReturnRequestListSuccess, _super);
        function LoadOrderReturnRequestListSuccess(payload) {
            var _this = _super.call(this, USER_RETURN_REQUESTS) || this;
            _this.payload = payload;
            _this.type = LOAD_ORDER_RETURN_REQUEST_LIST_SUCCESS;
            return _this;
        }
        return LoadOrderReturnRequestListSuccess;
    }(LoaderSuccessAction));
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var ClearOrderReturnRequest = /** @class */ (function (_super) {
        __extends(ClearOrderReturnRequest, _super);
        function ClearOrderReturnRequest() {
            var _this = _super.call(this, USER_RETURN_REQUEST_DETAILS) || this;
            _this.type = CLEAR_ORDER_RETURN_REQUEST;
            return _this;
        }
        return ClearOrderReturnRequest;
    }(LoaderResetAction));
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var ClearOrderReturnRequestList = /** @class */ (function (_super) {
        __extends(ClearOrderReturnRequestList, _super);
        function ClearOrderReturnRequestList() {
            var _this = _super.call(this, USER_RETURN_REQUESTS) || this;
            _this.type = CLEAR_ORDER_RETURN_REQUEST_LIST;
            return _this;
        }
        return ClearOrderReturnRequestList;
    }(LoaderResetAction));
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var ResetCancelReturnProcess = /** @class */ (function (_super) {
        __extends(ResetCancelReturnProcess, _super);
        function ResetCancelReturnProcess() {
            var _this = _super.call(this, PROCESS_FEATURE, CANCEL_RETURN_PROCESS_ID) || this;
            _this.type = RESET_CANCEL_RETURN_PROCESS;
            return _this;
        }
        return ResetCancelReturnProcess;
    }(EntityLoaderResetAction));

    var LOAD_USER_PAYMENT_METHODS = '[User] Load User Payment Methods';
    var LOAD_USER_PAYMENT_METHODS_FAIL = '[User] Load User Payment Methods Fail';
    var LOAD_USER_PAYMENT_METHODS_SUCCESS = '[User] Load User Payment Methods Success';
    var SET_DEFAULT_USER_PAYMENT_METHOD = '[User] Set Default User Payment Method';
    var SET_DEFAULT_USER_PAYMENT_METHOD_FAIL = '[User] Set Default User Payment Method Fail';
    var SET_DEFAULT_USER_PAYMENT_METHOD_SUCCESS = '[User] Set Default User Payment Method Success';
    var DELETE_USER_PAYMENT_METHOD = '[User] Delete User Payment Method';
    var DELETE_USER_PAYMENT_METHOD_FAIL = '[User] Delete User Payment Method Fail';
    var DELETE_USER_PAYMENT_METHOD_SUCCESS = '[User] Delete User  Payment Method Success';
    var LoadUserPaymentMethods = /** @class */ (function (_super) {
        __extends(LoadUserPaymentMethods, _super);
        function LoadUserPaymentMethods(payload) {
            var _this = _super.call(this, USER_PAYMENT_METHODS) || this;
            _this.payload = payload;
            _this.type = LOAD_USER_PAYMENT_METHODS;
            return _this;
        }
        return LoadUserPaymentMethods;
    }(LoaderLoadAction));
    var LoadUserPaymentMethodsFail = /** @class */ (function (_super) {
        __extends(LoadUserPaymentMethodsFail, _super);
        function LoadUserPaymentMethodsFail(payload) {
            var _this = _super.call(this, USER_PAYMENT_METHODS, payload) || this;
            _this.payload = payload;
            _this.type = LOAD_USER_PAYMENT_METHODS_FAIL;
            return _this;
        }
        return LoadUserPaymentMethodsFail;
    }(LoaderFailAction));
    var LoadUserPaymentMethodsSuccess = /** @class */ (function (_super) {
        __extends(LoadUserPaymentMethodsSuccess, _super);
        function LoadUserPaymentMethodsSuccess(payload) {
            var _this = _super.call(this, USER_PAYMENT_METHODS) || this;
            _this.payload = payload;
            _this.type = LOAD_USER_PAYMENT_METHODS_SUCCESS;
            return _this;
        }
        return LoadUserPaymentMethodsSuccess;
    }(LoaderSuccessAction));
    var SetDefaultUserPaymentMethod = /** @class */ (function (_super) {
        __extends(SetDefaultUserPaymentMethod, _super);
        function SetDefaultUserPaymentMethod(payload) {
            var _this = _super.call(this, USER_PAYMENT_METHODS) || this;
            _this.payload = payload;
            _this.type = SET_DEFAULT_USER_PAYMENT_METHOD;
            return _this;
        }
        return SetDefaultUserPaymentMethod;
    }(LoaderLoadAction));
    var SetDefaultUserPaymentMethodFail = /** @class */ (function (_super) {
        __extends(SetDefaultUserPaymentMethodFail, _super);
        function SetDefaultUserPaymentMethodFail(payload) {
            var _this = _super.call(this, USER_PAYMENT_METHODS, payload) || this;
            _this.payload = payload;
            _this.type = SET_DEFAULT_USER_PAYMENT_METHOD_FAIL;
            return _this;
        }
        return SetDefaultUserPaymentMethodFail;
    }(LoaderFailAction));
    var SetDefaultUserPaymentMethodSuccess = /** @class */ (function (_super) {
        __extends(SetDefaultUserPaymentMethodSuccess, _super);
        function SetDefaultUserPaymentMethodSuccess(payload) {
            var _this = _super.call(this, USER_PAYMENT_METHODS) || this;
            _this.payload = payload;
            _this.type = SET_DEFAULT_USER_PAYMENT_METHOD_SUCCESS;
            return _this;
        }
        return SetDefaultUserPaymentMethodSuccess;
    }(LoaderSuccessAction));
    var DeleteUserPaymentMethod = /** @class */ (function (_super) {
        __extends(DeleteUserPaymentMethod, _super);
        function DeleteUserPaymentMethod(payload) {
            var _this = _super.call(this, USER_PAYMENT_METHODS) || this;
            _this.payload = payload;
            _this.type = DELETE_USER_PAYMENT_METHOD;
            return _this;
        }
        return DeleteUserPaymentMethod;
    }(LoaderLoadAction));
    var DeleteUserPaymentMethodFail = /** @class */ (function (_super) {
        __extends(DeleteUserPaymentMethodFail, _super);
        function DeleteUserPaymentMethodFail(payload) {
            var _this = _super.call(this, USER_PAYMENT_METHODS, payload) || this;
            _this.payload = payload;
            _this.type = DELETE_USER_PAYMENT_METHOD_FAIL;
            return _this;
        }
        return DeleteUserPaymentMethodFail;
    }(LoaderFailAction));
    var DeleteUserPaymentMethodSuccess = /** @class */ (function (_super) {
        __extends(DeleteUserPaymentMethodSuccess, _super);
        function DeleteUserPaymentMethodSuccess(payload) {
            var _this = _super.call(this, USER_PAYMENT_METHODS) || this;
            _this.payload = payload;
            _this.type = DELETE_USER_PAYMENT_METHOD_SUCCESS;
            return _this;
        }
        return DeleteUserPaymentMethodSuccess;
    }(LoaderSuccessAction));

    var LOAD_PRODUCT_INTERESTS = 'Load Product Interests';
    var LOAD_PRODUCT_INTERESTS_FAIL = 'Load Product Interests Fail';
    var LOAD_PRODUCT_INTERESTS_SUCCESS = 'Load Product Interests Success';
    var REMOVE_PRODUCT_INTEREST = 'Remove Product Interest';
    var REMOVE_PRODUCT_INTEREST_SUCCESS = 'Remove Product Interest Success';
    var REMOVE_PRODUCT_INTEREST_FAIL = 'Remove Product Interest Fail';
    var ADD_PRODUCT_INTEREST = 'Add Product Interest';
    var ADD_PRODUCT_INTEREST_FAIL = 'Add Product Interest Fail';
    var ADD_PRODUCT_INTEREST_SUCCESS = 'Add Product Interest Success';
    var ADD_PRODUCT_INTEREST_RESET = 'Add Product Interest Reset';
    var REMOVE_PRODUCT_INTEREST_RESET = 'Remove Product Interest Reset';
    var CLEAR_PRODUCT_INTERESTS = 'Clear Product Interests';
    var LoadProductInterests = /** @class */ (function (_super) {
        __extends(LoadProductInterests, _super);
        function LoadProductInterests(payload) {
            var _this = _super.call(this, PRODUCT_INTERESTS) || this;
            _this.payload = payload;
            _this.type = LOAD_PRODUCT_INTERESTS;
            return _this;
        }
        return LoadProductInterests;
    }(LoaderLoadAction));
    var LoadProductInterestsFail = /** @class */ (function (_super) {
        __extends(LoadProductInterestsFail, _super);
        function LoadProductInterestsFail(payload) {
            var _this = _super.call(this, PRODUCT_INTERESTS, payload) || this;
            _this.payload = payload;
            _this.type = LOAD_PRODUCT_INTERESTS_FAIL;
            return _this;
        }
        return LoadProductInterestsFail;
    }(LoaderFailAction));
    var LoadProductInterestsSuccess = /** @class */ (function (_super) {
        __extends(LoadProductInterestsSuccess, _super);
        function LoadProductInterestsSuccess(payload) {
            var _this = _super.call(this, PRODUCT_INTERESTS) || this;
            _this.payload = payload;
            _this.type = LOAD_PRODUCT_INTERESTS_SUCCESS;
            return _this;
        }
        return LoadProductInterestsSuccess;
    }(LoaderSuccessAction));
    var RemoveProductInterest = /** @class */ (function (_super) {
        __extends(RemoveProductInterest, _super);
        function RemoveProductInterest(payload) {
            var _this = _super.call(this, PROCESS_FEATURE, REMOVE_PRODUCT_INTERESTS_PROCESS_ID) || this;
            _this.payload = payload;
            _this.type = REMOVE_PRODUCT_INTEREST;
            return _this;
        }
        return RemoveProductInterest;
    }(EntityLoadAction));
    var RemoveProductInterestSuccess = /** @class */ (function (_super) {
        __extends(RemoveProductInterestSuccess, _super);
        function RemoveProductInterestSuccess(payload) {
            var _this = _super.call(this, PROCESS_FEATURE, REMOVE_PRODUCT_INTERESTS_PROCESS_ID) || this;
            _this.payload = payload;
            _this.type = REMOVE_PRODUCT_INTEREST_SUCCESS;
            return _this;
        }
        return RemoveProductInterestSuccess;
    }(EntitySuccessAction));
    var RemoveProductInterestFail = /** @class */ (function (_super) {
        __extends(RemoveProductInterestFail, _super);
        function RemoveProductInterestFail(payload) {
            var _this = _super.call(this, PROCESS_FEATURE, REMOVE_PRODUCT_INTERESTS_PROCESS_ID, payload) || this;
            _this.payload = payload;
            _this.type = REMOVE_PRODUCT_INTEREST_FAIL;
            return _this;
        }
        return RemoveProductInterestFail;
    }(EntityFailAction));
    var AddProductInterest = /** @class */ (function (_super) {
        __extends(AddProductInterest, _super);
        function AddProductInterest(payload) {
            var _this = _super.call(this, PROCESS_FEATURE, ADD_PRODUCT_INTEREST_PROCESS_ID) || this;
            _this.payload = payload;
            _this.type = ADD_PRODUCT_INTEREST;
            return _this;
        }
        return AddProductInterest;
    }(EntityLoadAction));
    var AddProductInterestSuccess = /** @class */ (function (_super) {
        __extends(AddProductInterestSuccess, _super);
        function AddProductInterestSuccess(payload) {
            var _this = _super.call(this, PROCESS_FEATURE, ADD_PRODUCT_INTEREST_PROCESS_ID) || this;
            _this.payload = payload;
            _this.type = ADD_PRODUCT_INTEREST_SUCCESS;
            return _this;
        }
        return AddProductInterestSuccess;
    }(EntitySuccessAction));
    var AddProductInterestFail = /** @class */ (function (_super) {
        __extends(AddProductInterestFail, _super);
        function AddProductInterestFail(payload) {
            var _this = _super.call(this, PROCESS_FEATURE, ADD_PRODUCT_INTEREST_PROCESS_ID, payload) || this;
            _this.payload = payload;
            _this.type = ADD_PRODUCT_INTEREST_FAIL;
            return _this;
        }
        return AddProductInterestFail;
    }(EntityFailAction));
    var ResetAddInterestState = /** @class */ (function (_super) {
        __extends(ResetAddInterestState, _super);
        function ResetAddInterestState() {
            var _this = _super.call(this, PROCESS_FEATURE, ADD_PRODUCT_INTEREST_PROCESS_ID) || this;
            _this.type = ADD_PRODUCT_INTEREST_RESET;
            return _this;
        }
        return ResetAddInterestState;
    }(EntityLoaderResetAction));
    var ResetRemoveInterestState = /** @class */ (function (_super) {
        __extends(ResetRemoveInterestState, _super);
        function ResetRemoveInterestState() {
            var _this = _super.call(this, PROCESS_FEATURE, REMOVE_PRODUCT_INTERESTS_PROCESS_ID) || this;
            _this.type = REMOVE_PRODUCT_INTEREST_RESET;
            return _this;
        }
        return ResetRemoveInterestState;
    }(EntityLoaderResetAction));
    var ClearProductInterests = /** @class */ (function (_super) {
        __extends(ClearProductInterests, _super);
        function ClearProductInterests() {
            var _this = _super.call(this, PRODUCT_INTERESTS) || this;
            _this.type = CLEAR_PRODUCT_INTERESTS;
            return _this;
        }
        return ClearProductInterests;
    }(LoaderResetAction));

    var LOAD_REGIONS = '[User] Load Regions';
    var LOAD_REGIONS_SUCCESS = '[User] Load Regions Success';
    var LOAD_REGIONS_FAIL = '[User] Load Regions Fail';
    var CLEAR_REGIONS = '[User] Clear Regions';
    var LoadRegions = /** @class */ (function (_super) {
        __extends(LoadRegions, _super);
        function LoadRegions(payload) {
            var _this = _super.call(this, REGIONS) || this;
            _this.payload = payload;
            _this.type = LOAD_REGIONS;
            return _this;
        }
        return LoadRegions;
    }(LoaderLoadAction));
    var LoadRegionsFail = /** @class */ (function (_super) {
        __extends(LoadRegionsFail, _super);
        function LoadRegionsFail(payload) {
            var _this = _super.call(this, REGIONS, payload) || this;
            _this.payload = payload;
            _this.type = LOAD_REGIONS_FAIL;
            return _this;
        }
        return LoadRegionsFail;
    }(LoaderFailAction));
    var LoadRegionsSuccess = /** @class */ (function (_super) {
        __extends(LoadRegionsSuccess, _super);
        function LoadRegionsSuccess(payload) {
            var _this = _super.call(this, REGIONS) || this;
            _this.payload = payload;
            _this.type = LOAD_REGIONS_SUCCESS;
            return _this;
        }
        return LoadRegionsSuccess;
    }(LoaderSuccessAction));
    var ClearRegions = /** @class */ (function () {
        function ClearRegions() {
            this.type = CLEAR_REGIONS;
        }
        return ClearRegions;
    }());

    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var LOAD_REPLENISHMENT_ORDER_DETAILS = '[User] Load Replenishment Order Details';
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var LOAD_REPLENISHMENT_ORDER_DETAILS_SUCCESS = '[User] Load Replenishment Order Details Success';
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var LOAD_REPLENISHMENT_ORDER_DETAILS_FAIL = '[User] Load Replenishment Order Details Fail';
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var ClEAR_REPLENISHMENT_ORDER_DETAILS = '[User] Clear Replenishment Order Details';
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var CANCEL_REPLENISHMENT_ORDER = '[User] Cancel Replenishment Order';
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var CANCEL_REPLENISHMENT_ORDER_SUCCESS = '[User] Cancel Replenishment Order Success';
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var CANCEL_REPLENISHMENT_ORDER_FAIL = '[User] Cancel Replenishment Order Fail';
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var CLEAR_CANCEL_REPLENISHMENT_ORDER = '[User] Clear Cancel Replenishment Order';
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var LoadReplenishmentOrderDetails = /** @class */ (function (_super) {
        __extends(LoadReplenishmentOrderDetails, _super);
        function LoadReplenishmentOrderDetails(payload) {
            var _this = _super.call(this, USER_REPLENISHMENT_ORDER_DETAILS) || this;
            _this.payload = payload;
            _this.type = LOAD_REPLENISHMENT_ORDER_DETAILS;
            return _this;
        }
        return LoadReplenishmentOrderDetails;
    }(LoaderLoadAction));
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var LoadReplenishmentOrderDetailsSuccess = /** @class */ (function (_super) {
        __extends(LoadReplenishmentOrderDetailsSuccess, _super);
        function LoadReplenishmentOrderDetailsSuccess(payload) {
            var _this = _super.call(this, USER_REPLENISHMENT_ORDER_DETAILS) || this;
            _this.payload = payload;
            _this.type = LOAD_REPLENISHMENT_ORDER_DETAILS_SUCCESS;
            return _this;
        }
        return LoadReplenishmentOrderDetailsSuccess;
    }(LoaderSuccessAction));
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var LoadReplenishmentOrderDetailsFail = /** @class */ (function (_super) {
        __extends(LoadReplenishmentOrderDetailsFail, _super);
        function LoadReplenishmentOrderDetailsFail(payload) {
            var _this = _super.call(this, USER_REPLENISHMENT_ORDER_DETAILS, payload) || this;
            _this.payload = payload;
            _this.type = LOAD_REPLENISHMENT_ORDER_DETAILS_FAIL;
            return _this;
        }
        return LoadReplenishmentOrderDetailsFail;
    }(LoaderFailAction));
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var ClearReplenishmentOrderDetails = /** @class */ (function (_super) {
        __extends(ClearReplenishmentOrderDetails, _super);
        function ClearReplenishmentOrderDetails() {
            var _this = _super.call(this, USER_REPLENISHMENT_ORDER_DETAILS) || this;
            _this.type = ClEAR_REPLENISHMENT_ORDER_DETAILS;
            return _this;
        }
        return ClearReplenishmentOrderDetails;
    }(LoaderResetAction));
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var CancelReplenishmentOrder = /** @class */ (function (_super) {
        __extends(CancelReplenishmentOrder, _super);
        function CancelReplenishmentOrder(payload) {
            var _this = _super.call(this, PROCESS_FEATURE, CANCEL_REPLENISHMENT_ORDER_PROCESS_ID) || this;
            _this.payload = payload;
            _this.type = CANCEL_REPLENISHMENT_ORDER;
            return _this;
        }
        return CancelReplenishmentOrder;
    }(EntityLoadAction));
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var CancelReplenishmentOrderSuccess = /** @class */ (function (_super) {
        __extends(CancelReplenishmentOrderSuccess, _super);
        function CancelReplenishmentOrderSuccess(payload) {
            var _this = _super.call(this, PROCESS_FEATURE, CANCEL_REPLENISHMENT_ORDER_PROCESS_ID) || this;
            _this.payload = payload;
            _this.type = CANCEL_REPLENISHMENT_ORDER_SUCCESS;
            return _this;
        }
        return CancelReplenishmentOrderSuccess;
    }(EntitySuccessAction));
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var CancelReplenishmentOrderFail = /** @class */ (function (_super) {
        __extends(CancelReplenishmentOrderFail, _super);
        function CancelReplenishmentOrderFail(payload) {
            var _this = _super.call(this, PROCESS_FEATURE, CANCEL_REPLENISHMENT_ORDER_PROCESS_ID, payload) || this;
            _this.payload = payload;
            _this.type = CANCEL_REPLENISHMENT_ORDER_FAIL;
            return _this;
        }
        return CancelReplenishmentOrderFail;
    }(EntityFailAction));
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var ClearCancelReplenishmentOrder = /** @class */ (function (_super) {
        __extends(ClearCancelReplenishmentOrder, _super);
        function ClearCancelReplenishmentOrder() {
            var _this = _super.call(this, PROCESS_FEATURE, CANCEL_REPLENISHMENT_ORDER_PROCESS_ID) || this;
            _this.type = CLEAR_CANCEL_REPLENISHMENT_ORDER;
            return _this;
        }
        return ClearCancelReplenishmentOrder;
    }(EntityLoaderResetAction));

    var LOAD_USER_ADDRESSES = '[User] Load User Addresses';
    var LOAD_USER_ADDRESSES_FAIL = '[User] Load User Addresses Fail';
    var LOAD_USER_ADDRESSES_SUCCESS = '[User] Load User Addresses Success';
    var ADD_USER_ADDRESS = '[User] Add User Address';
    var ADD_USER_ADDRESS_FAIL = '[User] Add User Address Fail';
    var ADD_USER_ADDRESS_SUCCESS = '[User] Add User Address Success';
    var UPDATE_USER_ADDRESS = '[User] Update User Address';
    var UPDATE_USER_ADDRESS_FAIL = '[User] Update User Address Fail';
    var UPDATE_USER_ADDRESS_SUCCESS = '[User] Update User Address Success';
    var DELETE_USER_ADDRESS = '[User] Delete User Address';
    var DELETE_USER_ADDRESS_FAIL = '[User] Delete User Address Fail';
    var DELETE_USER_ADDRESS_SUCCESS = '[User] Delete User Address Success';
    var LoadUserAddresses = /** @class */ (function (_super) {
        __extends(LoadUserAddresses, _super);
        function LoadUserAddresses(payload) {
            var _this = _super.call(this, USER_ADDRESSES) || this;
            _this.payload = payload;
            _this.type = LOAD_USER_ADDRESSES;
            return _this;
        }
        return LoadUserAddresses;
    }(LoaderLoadAction));
    var LoadUserAddressesFail = /** @class */ (function (_super) {
        __extends(LoadUserAddressesFail, _super);
        function LoadUserAddressesFail(payload) {
            var _this = _super.call(this, USER_ADDRESSES, payload) || this;
            _this.payload = payload;
            _this.type = LOAD_USER_ADDRESSES_FAIL;
            return _this;
        }
        return LoadUserAddressesFail;
    }(LoaderFailAction));
    var LoadUserAddressesSuccess = /** @class */ (function (_super) {
        __extends(LoadUserAddressesSuccess, _super);
        function LoadUserAddressesSuccess(payload) {
            var _this = _super.call(this, USER_ADDRESSES) || this;
            _this.payload = payload;
            _this.type = LOAD_USER_ADDRESSES_SUCCESS;
            return _this;
        }
        return LoadUserAddressesSuccess;
    }(LoaderSuccessAction));
    // Adding address actions
    var AddUserAddress = /** @class */ (function (_super) {
        __extends(AddUserAddress, _super);
        function AddUserAddress(payload) {
            var _this = _super.call(this, USER_ADDRESSES) || this;
            _this.payload = payload;
            _this.type = ADD_USER_ADDRESS;
            return _this;
        }
        return AddUserAddress;
    }(LoaderLoadAction));
    var AddUserAddressFail = /** @class */ (function (_super) {
        __extends(AddUserAddressFail, _super);
        function AddUserAddressFail(payload) {
            var _this = _super.call(this, USER_ADDRESSES, payload) || this;
            _this.payload = payload;
            _this.type = ADD_USER_ADDRESS_FAIL;
            return _this;
        }
        return AddUserAddressFail;
    }(LoaderFailAction));
    var AddUserAddressSuccess = /** @class */ (function (_super) {
        __extends(AddUserAddressSuccess, _super);
        function AddUserAddressSuccess(payload) {
            var _this = _super.call(this, USER_ADDRESSES) || this;
            _this.payload = payload;
            _this.type = ADD_USER_ADDRESS_SUCCESS;
            return _this;
        }
        return AddUserAddressSuccess;
    }(LoaderSuccessAction));
    // Updating address actions
    var UpdateUserAddress = /** @class */ (function (_super) {
        __extends(UpdateUserAddress, _super);
        function UpdateUserAddress(payload) {
            var _this = _super.call(this, USER_ADDRESSES) || this;
            _this.payload = payload;
            _this.type = UPDATE_USER_ADDRESS;
            return _this;
        }
        return UpdateUserAddress;
    }(LoaderLoadAction));
    var UpdateUserAddressFail = /** @class */ (function (_super) {
        __extends(UpdateUserAddressFail, _super);
        function UpdateUserAddressFail(payload) {
            var _this = _super.call(this, USER_ADDRESSES, payload) || this;
            _this.payload = payload;
            _this.type = UPDATE_USER_ADDRESS_FAIL;
            return _this;
        }
        return UpdateUserAddressFail;
    }(LoaderFailAction));
    var UpdateUserAddressSuccess = /** @class */ (function (_super) {
        __extends(UpdateUserAddressSuccess, _super);
        function UpdateUserAddressSuccess(payload) {
            var _this = _super.call(this, USER_ADDRESSES) || this;
            _this.payload = payload;
            _this.type = UPDATE_USER_ADDRESS_SUCCESS;
            return _this;
        }
        return UpdateUserAddressSuccess;
    }(LoaderSuccessAction));
    // Deleting address actions
    var DeleteUserAddress = /** @class */ (function (_super) {
        __extends(DeleteUserAddress, _super);
        function DeleteUserAddress(payload) {
            var _this = _super.call(this, USER_ADDRESSES) || this;
            _this.payload = payload;
            _this.type = DELETE_USER_ADDRESS;
            return _this;
        }
        return DeleteUserAddress;
    }(LoaderLoadAction));
    var DeleteUserAddressFail = /** @class */ (function (_super) {
        __extends(DeleteUserAddressFail, _super);
        function DeleteUserAddressFail(payload) {
            var _this = _super.call(this, USER_ADDRESSES, payload) || this;
            _this.payload = payload;
            _this.type = DELETE_USER_ADDRESS_FAIL;
            return _this;
        }
        return DeleteUserAddressFail;
    }(LoaderFailAction));
    var DeleteUserAddressSuccess = /** @class */ (function (_super) {
        __extends(DeleteUserAddressSuccess, _super);
        function DeleteUserAddressSuccess(payload) {
            var _this = _super.call(this, USER_ADDRESSES) || this;
            _this.payload = payload;
            _this.type = DELETE_USER_ADDRESS_SUCCESS;
            return _this;
        }
        return DeleteUserAddressSuccess;
    }(LoaderSuccessAction));

    var LOAD_USER_CONSENTS = '[User] Load User Consents';
    var LOAD_USER_CONSENTS_SUCCESS = '[User] Load User Consents Success';
    var LOAD_USER_CONSENTS_FAIL = '[User] Load User Consents Fail';
    var RESET_LOAD_USER_CONSENTS = '[User] Reset Load User Consents';
    var GIVE_USER_CONSENT = '[User] Give User Consent';
    var GIVE_USER_CONSENT_FAIL = '[User] Give User Consent Fail';
    var GIVE_USER_CONSENT_SUCCESS = '[User] Give User Consent Success';
    var RESET_GIVE_USER_CONSENT_PROCESS = '[User] Reset Give User Consent Process';
    var TRANSFER_ANONYMOUS_CONSENT = '[User] Transfer Anonymous Consent';
    var WITHDRAW_USER_CONSENT = '[User] Withdraw User Consent';
    var WITHDRAW_USER_CONSENT_FAIL = '[User] Withdraw User Consent Fail';
    var WITHDRAW_USER_CONSENT_SUCCESS = '[User] Withdraw User Consent Success';
    var RESET_WITHDRAW_USER_CONSENT_PROCESS = '[User] Reset Withdraw User Consent Process';
    var LoadUserConsents = /** @class */ (function (_super) {
        __extends(LoadUserConsents, _super);
        function LoadUserConsents(payload) {
            var _this = _super.call(this, USER_CONSENTS) || this;
            _this.payload = payload;
            _this.type = LOAD_USER_CONSENTS;
            return _this;
        }
        return LoadUserConsents;
    }(LoaderLoadAction));
    var LoadUserConsentsFail = /** @class */ (function (_super) {
        __extends(LoadUserConsentsFail, _super);
        function LoadUserConsentsFail(payload) {
            var _this = _super.call(this, USER_CONSENTS, payload) || this;
            _this.payload = payload;
            _this.type = LOAD_USER_CONSENTS_FAIL;
            return _this;
        }
        return LoadUserConsentsFail;
    }(LoaderFailAction));
    var LoadUserConsentsSuccess = /** @class */ (function (_super) {
        __extends(LoadUserConsentsSuccess, _super);
        function LoadUserConsentsSuccess(payload) {
            var _this = _super.call(this, USER_CONSENTS) || this;
            _this.payload = payload;
            _this.type = LOAD_USER_CONSENTS_SUCCESS;
            return _this;
        }
        return LoadUserConsentsSuccess;
    }(LoaderSuccessAction));
    var ResetLoadUserConsents = /** @class */ (function (_super) {
        __extends(ResetLoadUserConsents, _super);
        function ResetLoadUserConsents() {
            var _this = _super.call(this, USER_CONSENTS) || this;
            _this.type = RESET_LOAD_USER_CONSENTS;
            return _this;
        }
        return ResetLoadUserConsents;
    }(LoaderResetAction));
    var GiveUserConsent = /** @class */ (function (_super) {
        __extends(GiveUserConsent, _super);
        function GiveUserConsent(payload) {
            var _this = _super.call(this, PROCESS_FEATURE, GIVE_CONSENT_PROCESS_ID) || this;
            _this.payload = payload;
            _this.type = GIVE_USER_CONSENT;
            return _this;
        }
        return GiveUserConsent;
    }(EntityLoadAction));
    var GiveUserConsentFail = /** @class */ (function (_super) {
        __extends(GiveUserConsentFail, _super);
        function GiveUserConsentFail(payload) {
            var _this = _super.call(this, PROCESS_FEATURE, GIVE_CONSENT_PROCESS_ID, payload) || this;
            _this.type = GIVE_USER_CONSENT_FAIL;
            return _this;
        }
        return GiveUserConsentFail;
    }(EntityFailAction));
    var GiveUserConsentSuccess = /** @class */ (function (_super) {
        __extends(GiveUserConsentSuccess, _super);
        function GiveUserConsentSuccess(consentTemplate) {
            var _this = _super.call(this, PROCESS_FEATURE, GIVE_CONSENT_PROCESS_ID) || this;
            _this.consentTemplate = consentTemplate;
            _this.type = GIVE_USER_CONSENT_SUCCESS;
            return _this;
        }
        return GiveUserConsentSuccess;
    }(EntitySuccessAction));
    var ResetGiveUserConsentProcess = /** @class */ (function (_super) {
        __extends(ResetGiveUserConsentProcess, _super);
        function ResetGiveUserConsentProcess() {
            var _this = _super.call(this, PROCESS_FEATURE, GIVE_CONSENT_PROCESS_ID) || this;
            _this.type = RESET_GIVE_USER_CONSENT_PROCESS;
            return _this;
        }
        return ResetGiveUserConsentProcess;
    }(EntityLoaderResetAction));
    var TransferAnonymousConsent = /** @class */ (function () {
        function TransferAnonymousConsent(payload) {
            this.payload = payload;
            this.type = TRANSFER_ANONYMOUS_CONSENT;
        }
        return TransferAnonymousConsent;
    }());
    var WithdrawUserConsent = /** @class */ (function (_super) {
        __extends(WithdrawUserConsent, _super);
        function WithdrawUserConsent(payload) {
            var _this = _super.call(this, PROCESS_FEATURE, WITHDRAW_CONSENT_PROCESS_ID) || this;
            _this.payload = payload;
            _this.type = WITHDRAW_USER_CONSENT;
            return _this;
        }
        return WithdrawUserConsent;
    }(EntityLoadAction));
    var WithdrawUserConsentFail = /** @class */ (function (_super) {
        __extends(WithdrawUserConsentFail, _super);
        function WithdrawUserConsentFail(payload) {
            var _this = _super.call(this, PROCESS_FEATURE, WITHDRAW_CONSENT_PROCESS_ID, payload) || this;
            _this.type = WITHDRAW_USER_CONSENT_FAIL;
            return _this;
        }
        return WithdrawUserConsentFail;
    }(EntityFailAction));
    var WithdrawUserConsentSuccess = /** @class */ (function (_super) {
        __extends(WithdrawUserConsentSuccess, _super);
        function WithdrawUserConsentSuccess() {
            var _this = _super.call(this, PROCESS_FEATURE, WITHDRAW_CONSENT_PROCESS_ID) || this;
            _this.type = WITHDRAW_USER_CONSENT_SUCCESS;
            return _this;
        }
        return WithdrawUserConsentSuccess;
    }(EntitySuccessAction));
    var ResetWithdrawUserConsentProcess = /** @class */ (function (_super) {
        __extends(ResetWithdrawUserConsentProcess, _super);
        function ResetWithdrawUserConsentProcess() {
            var _this = _super.call(this, PROCESS_FEATURE, WITHDRAW_CONSENT_PROCESS_ID) || this;
            _this.type = RESET_WITHDRAW_USER_CONSENT_PROCESS;
            return _this;
        }
        return ResetWithdrawUserConsentProcess;
    }(EntityLoaderResetAction));

    var LOAD_ACTIVE_COST_CENTERS = '[User] Load Active CostCenters';
    var LOAD_ACTIVE_COST_CENTERS_FAIL = '[User] Load Active CostCenters Fail';
    var LOAD_ACTIVE_COST_CENTERS_SUCCESS = '[User] Load Active CostCenters Success';
    var LoadActiveCostCenters = /** @class */ (function (_super) {
        __extends(LoadActiveCostCenters, _super);
        function LoadActiveCostCenters(payload) {
            var _this = _super.call(this, USER_COST_CENTERS) || this;
            _this.payload = payload;
            _this.type = LOAD_ACTIVE_COST_CENTERS;
            return _this;
        }
        return LoadActiveCostCenters;
    }(LoaderLoadAction));
    var LoadActiveCostCentersFail = /** @class */ (function (_super) {
        __extends(LoadActiveCostCentersFail, _super);
        function LoadActiveCostCentersFail(payload) {
            var _this = _super.call(this, USER_COST_CENTERS, payload) || this;
            _this.payload = payload;
            _this.type = LOAD_ACTIVE_COST_CENTERS_FAIL;
            return _this;
        }
        return LoadActiveCostCentersFail;
    }(LoaderFailAction));
    var LoadActiveCostCentersSuccess = /** @class */ (function (_super) {
        __extends(LoadActiveCostCentersSuccess, _super);
        function LoadActiveCostCentersSuccess(payload) {
            var _this = _super.call(this, USER_COST_CENTERS) || this;
            _this.payload = payload;
            _this.type = LOAD_ACTIVE_COST_CENTERS_SUCCESS;
            return _this;
        }
        return LoadActiveCostCentersSuccess;
    }(LoaderSuccessAction));

    var CLEAR_USER_MISCS_DATA = '[User] Clear User Misc Data';
    var ClearUserMiscsData = /** @class */ (function () {
        function ClearUserMiscsData() {
            this.type = CLEAR_USER_MISCS_DATA;
        }
        return ClearUserMiscsData;
    }());

    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var LOAD_USER_ORDERS = '[User] Load User Orders';
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var LOAD_USER_ORDERS_FAIL = '[User] Load User Orders Fail';
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var LOAD_USER_ORDERS_SUCCESS = '[User] Load User Orders Success';
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var CLEAR_USER_ORDERS = '[User] Clear User Orders';
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var LoadUserOrders = /** @class */ (function (_super) {
        __extends(LoadUserOrders, _super);
        function LoadUserOrders(payload) {
            var _this = _super.call(this, USER_ORDERS) || this;
            _this.payload = payload;
            _this.type = LOAD_USER_ORDERS;
            return _this;
        }
        return LoadUserOrders;
    }(LoaderLoadAction));
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var LoadUserOrdersFail = /** @class */ (function (_super) {
        __extends(LoadUserOrdersFail, _super);
        function LoadUserOrdersFail(payload) {
            var _this = _super.call(this, USER_ORDERS, payload) || this;
            _this.payload = payload;
            _this.type = LOAD_USER_ORDERS_FAIL;
            return _this;
        }
        return LoadUserOrdersFail;
    }(LoaderFailAction));
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var LoadUserOrdersSuccess = /** @class */ (function (_super) {
        __extends(LoadUserOrdersSuccess, _super);
        function LoadUserOrdersSuccess(payload) {
            var _this = _super.call(this, USER_ORDERS) || this;
            _this.payload = payload;
            _this.type = LOAD_USER_ORDERS_SUCCESS;
            return _this;
        }
        return LoadUserOrdersSuccess;
    }(LoaderSuccessAction));
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var ClearUserOrders = /** @class */ (function (_super) {
        __extends(ClearUserOrders, _super);
        function ClearUserOrders() {
            var _this = _super.call(this, USER_ORDERS) || this;
            _this.type = CLEAR_USER_ORDERS;
            return _this;
        }
        return ClearUserOrders;
    }(LoaderResetAction));

    var REGISTER_USER_SUCCESS = '[User] Register User Success';
    /**
     * @deprecated since 3.2, moved to `@spartacus/user/profile/core`
     */
    var RegisterUserSuccess = /** @class */ (function (_super) {
        __extends(RegisterUserSuccess, _super);
        function RegisterUserSuccess() {
            var _this = _super.call(this, PROCESS_FEATURE, REGISTER_USER_PROCESS_ID) || this;
            _this.type = REGISTER_USER_SUCCESS;
            return _this;
        }
        return RegisterUserSuccess;
    }(EntitySuccessAction));

    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var LOAD_USER_REPLENISHMENT_ORDERS = '[User] Load User Replenishment Orders';
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var LOAD_USER_REPLENISHMENT_ORDERS_FAIL = '[User] Load User Replenishment Orders Fail';
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var LOAD_USER_REPLENISHMENT_ORDERS_SUCCESS = '[User] Load User Replenishment Orders Success';
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var CLEAR_USER_REPLENISHMENT_ORDERS = '[User] Clear User Replenishment Orders';
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var LoadUserReplenishmentOrders = /** @class */ (function (_super) {
        __extends(LoadUserReplenishmentOrders, _super);
        function LoadUserReplenishmentOrders(payload) {
            var _this = _super.call(this, USER_REPLENISHMENT_ORDERS) || this;
            _this.payload = payload;
            _this.type = LOAD_USER_REPLENISHMENT_ORDERS;
            return _this;
        }
        return LoadUserReplenishmentOrders;
    }(LoaderLoadAction));
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var LoadUserReplenishmentOrdersFail = /** @class */ (function (_super) {
        __extends(LoadUserReplenishmentOrdersFail, _super);
        function LoadUserReplenishmentOrdersFail(payload) {
            var _this = _super.call(this, USER_REPLENISHMENT_ORDERS, payload) || this;
            _this.payload = payload;
            _this.type = LOAD_USER_REPLENISHMENT_ORDERS_FAIL;
            return _this;
        }
        return LoadUserReplenishmentOrdersFail;
    }(LoaderFailAction));
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var LoadUserReplenishmentOrdersSuccess = /** @class */ (function (_super) {
        __extends(LoadUserReplenishmentOrdersSuccess, _super);
        function LoadUserReplenishmentOrdersSuccess(payload) {
            var _this = _super.call(this, USER_REPLENISHMENT_ORDERS) || this;
            _this.payload = payload;
            _this.type = LOAD_USER_REPLENISHMENT_ORDERS_SUCCESS;
            return _this;
        }
        return LoadUserReplenishmentOrdersSuccess;
    }(LoaderSuccessAction));
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var ClearUserReplenishmentOrders = /** @class */ (function (_super) {
        __extends(ClearUserReplenishmentOrders, _super);
        function ClearUserReplenishmentOrders() {
            var _this = _super.call(this, USER_REPLENISHMENT_ORDERS) || this;
            _this.type = CLEAR_USER_REPLENISHMENT_ORDERS;
            return _this;
        }
        return ClearUserReplenishmentOrders;
    }(LoaderResetAction));

    var userGroup_actions = /*#__PURE__*/Object.freeze({
        __proto__: null,
        LOAD_BILLING_COUNTRIES: LOAD_BILLING_COUNTRIES,
        LOAD_BILLING_COUNTRIES_FAIL: LOAD_BILLING_COUNTRIES_FAIL,
        LOAD_BILLING_COUNTRIES_SUCCESS: LOAD_BILLING_COUNTRIES_SUCCESS,
        LoadBillingCountries: LoadBillingCountries,
        LoadBillingCountriesFail: LoadBillingCountriesFail,
        LoadBillingCountriesSuccess: LoadBillingCountriesSuccess,
        LOAD_CONSIGNMENT_TRACKING: LOAD_CONSIGNMENT_TRACKING,
        LOAD_CONSIGNMENT_TRACKING_FAIL: LOAD_CONSIGNMENT_TRACKING_FAIL,
        LOAD_CONSIGNMENT_TRACKING_SUCCESS: LOAD_CONSIGNMENT_TRACKING_SUCCESS,
        CLEAR_CONSIGNMENT_TRACKING: CLEAR_CONSIGNMENT_TRACKING,
        LoadConsignmentTracking: LoadConsignmentTracking,
        LoadConsignmentTrackingFail: LoadConsignmentTrackingFail,
        LoadConsignmentTrackingSuccess: LoadConsignmentTrackingSuccess,
        ClearConsignmentTracking: ClearConsignmentTracking,
        LOAD_CUSTOMER_COUPONS: LOAD_CUSTOMER_COUPONS,
        LOAD_CUSTOMER_COUPONS_FAIL: LOAD_CUSTOMER_COUPONS_FAIL,
        LOAD_CUSTOMER_COUPONS_SUCCESS: LOAD_CUSTOMER_COUPONS_SUCCESS,
        RESET_LOAD_CUSTOMER_COUPONS: RESET_LOAD_CUSTOMER_COUPONS,
        SUBSCRIBE_CUSTOMER_COUPON: SUBSCRIBE_CUSTOMER_COUPON,
        SUBSCRIBE_CUSTOMER_COUPON_FAIL: SUBSCRIBE_CUSTOMER_COUPON_FAIL,
        SUBSCRIBE_CUSTOMER_COUPON_SUCCESS: SUBSCRIBE_CUSTOMER_COUPON_SUCCESS,
        RESET_SUBSCRIBE_CUSTOMER_COUPON_PROCESS: RESET_SUBSCRIBE_CUSTOMER_COUPON_PROCESS,
        UNSUBSCRIBE_CUSTOMER_COUPON: UNSUBSCRIBE_CUSTOMER_COUPON,
        UNSUBSCRIBE_CUSTOMER_COUPON_FAIL: UNSUBSCRIBE_CUSTOMER_COUPON_FAIL,
        UNSUBSCRIBE_CUSTOMER_COUPON_SUCCESS: UNSUBSCRIBE_CUSTOMER_COUPON_SUCCESS,
        RESET_UNSUBSCRIBE_CUSTOMER_COUPON_PROCESS: RESET_UNSUBSCRIBE_CUSTOMER_COUPON_PROCESS,
        CLAIM_CUSTOMER_COUPON: CLAIM_CUSTOMER_COUPON,
        CLAIM_CUSTOMER_COUPON_FAIL: CLAIM_CUSTOMER_COUPON_FAIL,
        CLAIM_CUSTOMER_COUPON_SUCCESS: CLAIM_CUSTOMER_COUPON_SUCCESS,
        LoadCustomerCoupons: LoadCustomerCoupons,
        LoadCustomerCouponsFail: LoadCustomerCouponsFail,
        LoadCustomerCouponsSuccess: LoadCustomerCouponsSuccess,
        ResetLoadCustomerCoupons: ResetLoadCustomerCoupons,
        SubscribeCustomerCoupon: SubscribeCustomerCoupon,
        SubscribeCustomerCouponFail: SubscribeCustomerCouponFail,
        SubscribeCustomerCouponSuccess: SubscribeCustomerCouponSuccess,
        ResetSubscribeCustomerCouponProcess: ResetSubscribeCustomerCouponProcess,
        UnsubscribeCustomerCoupon: UnsubscribeCustomerCoupon,
        UnsubscribeCustomerCouponFail: UnsubscribeCustomerCouponFail,
        UnsubscribeCustomerCouponSuccess: UnsubscribeCustomerCouponSuccess,
        ResetUnsubscribeCustomerCouponProcess: ResetUnsubscribeCustomerCouponProcess,
        ClaimCustomerCoupon: ClaimCustomerCoupon,
        ClaimCustomerCouponFail: ClaimCustomerCouponFail,
        ClaimCustomerCouponSuccess: ClaimCustomerCouponSuccess,
        LOAD_DELIVERY_COUNTRIES: LOAD_DELIVERY_COUNTRIES,
        LOAD_DELIVERY_COUNTRIES_FAIL: LOAD_DELIVERY_COUNTRIES_FAIL,
        LOAD_DELIVERY_COUNTRIES_SUCCESS: LOAD_DELIVERY_COUNTRIES_SUCCESS,
        LoadDeliveryCountries: LoadDeliveryCountries,
        LoadDeliveryCountriesFail: LoadDeliveryCountriesFail,
        LoadDeliveryCountriesSuccess: LoadDeliveryCountriesSuccess,
        LOAD_NOTIFICATION_PREFERENCES: LOAD_NOTIFICATION_PREFERENCES,
        LOAD_NOTIFICATION_PREFERENCES_FAIL: LOAD_NOTIFICATION_PREFERENCES_FAIL,
        LOAD_NOTIFICATION_PREFERENCES_SUCCESS: LOAD_NOTIFICATION_PREFERENCES_SUCCESS,
        UPDATE_NOTIFICATION_PREFERENCES: UPDATE_NOTIFICATION_PREFERENCES,
        UPDATE_NOTIFICATION_PREFERENCES_FAIL: UPDATE_NOTIFICATION_PREFERENCES_FAIL,
        UPDATE_NOTIFICATION_PREFERENCES_SUCCESS: UPDATE_NOTIFICATION_PREFERENCES_SUCCESS,
        RESET_NOTIFICATION_PREFERENCES: RESET_NOTIFICATION_PREFERENCES,
        CLEAR_NOTIFICATION_PREFERENCES: CLEAR_NOTIFICATION_PREFERENCES,
        LoadNotificationPreferences: LoadNotificationPreferences,
        LoadNotificationPreferencesFail: LoadNotificationPreferencesFail,
        LoadNotificationPreferencesSuccess: LoadNotificationPreferencesSuccess,
        UpdateNotificationPreferences: UpdateNotificationPreferences,
        UpdateNotificationPreferencesFail: UpdateNotificationPreferencesFail,
        UpdateNotificationPreferencesSuccess: UpdateNotificationPreferencesSuccess,
        ResetNotificationPreferences: ResetNotificationPreferences,
        ClearNotificationPreferences: ClearNotificationPreferences,
        LOAD_ORDER_DETAILS: LOAD_ORDER_DETAILS,
        LOAD_ORDER_DETAILS_FAIL: LOAD_ORDER_DETAILS_FAIL,
        LOAD_ORDER_DETAILS_SUCCESS: LOAD_ORDER_DETAILS_SUCCESS,
        CLEAR_ORDER_DETAILS: CLEAR_ORDER_DETAILS,
        CANCEL_ORDER: CANCEL_ORDER,
        CANCEL_ORDER_FAIL: CANCEL_ORDER_FAIL,
        CANCEL_ORDER_SUCCESS: CANCEL_ORDER_SUCCESS,
        RESET_CANCEL_ORDER_PROCESS: RESET_CANCEL_ORDER_PROCESS,
        LoadOrderDetails: LoadOrderDetails,
        LoadOrderDetailsFail: LoadOrderDetailsFail,
        LoadOrderDetailsSuccess: LoadOrderDetailsSuccess,
        ClearOrderDetails: ClearOrderDetails,
        CancelOrder: CancelOrder,
        CancelOrderFail: CancelOrderFail,
        CancelOrderSuccess: CancelOrderSuccess,
        ResetCancelOrderProcess: ResetCancelOrderProcess,
        CREATE_ORDER_RETURN_REQUEST: CREATE_ORDER_RETURN_REQUEST,
        CREATE_ORDER_RETURN_REQUEST_FAIL: CREATE_ORDER_RETURN_REQUEST_FAIL,
        CREATE_ORDER_RETURN_REQUEST_SUCCESS: CREATE_ORDER_RETURN_REQUEST_SUCCESS,
        LOAD_ORDER_RETURN_REQUEST: LOAD_ORDER_RETURN_REQUEST,
        LOAD_ORDER_RETURN_REQUEST_FAIL: LOAD_ORDER_RETURN_REQUEST_FAIL,
        LOAD_ORDER_RETURN_REQUEST_SUCCESS: LOAD_ORDER_RETURN_REQUEST_SUCCESS,
        CANCEL_ORDER_RETURN_REQUEST: CANCEL_ORDER_RETURN_REQUEST,
        CANCEL_ORDER_RETURN_REQUEST_FAIL: CANCEL_ORDER_RETURN_REQUEST_FAIL,
        CANCEL_ORDER_RETURN_REQUEST_SUCCESS: CANCEL_ORDER_RETURN_REQUEST_SUCCESS,
        LOAD_ORDER_RETURN_REQUEST_LIST: LOAD_ORDER_RETURN_REQUEST_LIST,
        LOAD_ORDER_RETURN_REQUEST_LIST_FAIL: LOAD_ORDER_RETURN_REQUEST_LIST_FAIL,
        LOAD_ORDER_RETURN_REQUEST_LIST_SUCCESS: LOAD_ORDER_RETURN_REQUEST_LIST_SUCCESS,
        CLEAR_ORDER_RETURN_REQUEST: CLEAR_ORDER_RETURN_REQUEST,
        CLEAR_ORDER_RETURN_REQUEST_LIST: CLEAR_ORDER_RETURN_REQUEST_LIST,
        RESET_CANCEL_RETURN_PROCESS: RESET_CANCEL_RETURN_PROCESS,
        CreateOrderReturnRequest: CreateOrderReturnRequest,
        CreateOrderReturnRequestFail: CreateOrderReturnRequestFail,
        CreateOrderReturnRequestSuccess: CreateOrderReturnRequestSuccess,
        LoadOrderReturnRequest: LoadOrderReturnRequest,
        LoadOrderReturnRequestFail: LoadOrderReturnRequestFail,
        LoadOrderReturnRequestSuccess: LoadOrderReturnRequestSuccess,
        CancelOrderReturnRequest: CancelOrderReturnRequest,
        CancelOrderReturnRequestFail: CancelOrderReturnRequestFail,
        CancelOrderReturnRequestSuccess: CancelOrderReturnRequestSuccess,
        LoadOrderReturnRequestList: LoadOrderReturnRequestList,
        LoadOrderReturnRequestListFail: LoadOrderReturnRequestListFail,
        LoadOrderReturnRequestListSuccess: LoadOrderReturnRequestListSuccess,
        ClearOrderReturnRequest: ClearOrderReturnRequest,
        ClearOrderReturnRequestList: ClearOrderReturnRequestList,
        ResetCancelReturnProcess: ResetCancelReturnProcess,
        LOAD_USER_PAYMENT_METHODS: LOAD_USER_PAYMENT_METHODS,
        LOAD_USER_PAYMENT_METHODS_FAIL: LOAD_USER_PAYMENT_METHODS_FAIL,
        LOAD_USER_PAYMENT_METHODS_SUCCESS: LOAD_USER_PAYMENT_METHODS_SUCCESS,
        SET_DEFAULT_USER_PAYMENT_METHOD: SET_DEFAULT_USER_PAYMENT_METHOD,
        SET_DEFAULT_USER_PAYMENT_METHOD_FAIL: SET_DEFAULT_USER_PAYMENT_METHOD_FAIL,
        SET_DEFAULT_USER_PAYMENT_METHOD_SUCCESS: SET_DEFAULT_USER_PAYMENT_METHOD_SUCCESS,
        DELETE_USER_PAYMENT_METHOD: DELETE_USER_PAYMENT_METHOD,
        DELETE_USER_PAYMENT_METHOD_FAIL: DELETE_USER_PAYMENT_METHOD_FAIL,
        DELETE_USER_PAYMENT_METHOD_SUCCESS: DELETE_USER_PAYMENT_METHOD_SUCCESS,
        LoadUserPaymentMethods: LoadUserPaymentMethods,
        LoadUserPaymentMethodsFail: LoadUserPaymentMethodsFail,
        LoadUserPaymentMethodsSuccess: LoadUserPaymentMethodsSuccess,
        SetDefaultUserPaymentMethod: SetDefaultUserPaymentMethod,
        SetDefaultUserPaymentMethodFail: SetDefaultUserPaymentMethodFail,
        SetDefaultUserPaymentMethodSuccess: SetDefaultUserPaymentMethodSuccess,
        DeleteUserPaymentMethod: DeleteUserPaymentMethod,
        DeleteUserPaymentMethodFail: DeleteUserPaymentMethodFail,
        DeleteUserPaymentMethodSuccess: DeleteUserPaymentMethodSuccess,
        LOAD_PRODUCT_INTERESTS: LOAD_PRODUCT_INTERESTS,
        LOAD_PRODUCT_INTERESTS_FAIL: LOAD_PRODUCT_INTERESTS_FAIL,
        LOAD_PRODUCT_INTERESTS_SUCCESS: LOAD_PRODUCT_INTERESTS_SUCCESS,
        REMOVE_PRODUCT_INTEREST: REMOVE_PRODUCT_INTEREST,
        REMOVE_PRODUCT_INTEREST_SUCCESS: REMOVE_PRODUCT_INTEREST_SUCCESS,
        REMOVE_PRODUCT_INTEREST_FAIL: REMOVE_PRODUCT_INTEREST_FAIL,
        ADD_PRODUCT_INTEREST: ADD_PRODUCT_INTEREST,
        ADD_PRODUCT_INTEREST_FAIL: ADD_PRODUCT_INTEREST_FAIL,
        ADD_PRODUCT_INTEREST_SUCCESS: ADD_PRODUCT_INTEREST_SUCCESS,
        ADD_PRODUCT_INTEREST_RESET: ADD_PRODUCT_INTEREST_RESET,
        REMOVE_PRODUCT_INTEREST_RESET: REMOVE_PRODUCT_INTEREST_RESET,
        CLEAR_PRODUCT_INTERESTS: CLEAR_PRODUCT_INTERESTS,
        LoadProductInterests: LoadProductInterests,
        LoadProductInterestsFail: LoadProductInterestsFail,
        LoadProductInterestsSuccess: LoadProductInterestsSuccess,
        RemoveProductInterest: RemoveProductInterest,
        RemoveProductInterestSuccess: RemoveProductInterestSuccess,
        RemoveProductInterestFail: RemoveProductInterestFail,
        AddProductInterest: AddProductInterest,
        AddProductInterestSuccess: AddProductInterestSuccess,
        AddProductInterestFail: AddProductInterestFail,
        ResetAddInterestState: ResetAddInterestState,
        ResetRemoveInterestState: ResetRemoveInterestState,
        ClearProductInterests: ClearProductInterests,
        LOAD_REGIONS: LOAD_REGIONS,
        LOAD_REGIONS_SUCCESS: LOAD_REGIONS_SUCCESS,
        LOAD_REGIONS_FAIL: LOAD_REGIONS_FAIL,
        CLEAR_REGIONS: CLEAR_REGIONS,
        LoadRegions: LoadRegions,
        LoadRegionsFail: LoadRegionsFail,
        LoadRegionsSuccess: LoadRegionsSuccess,
        ClearRegions: ClearRegions,
        LOAD_REPLENISHMENT_ORDER_DETAILS: LOAD_REPLENISHMENT_ORDER_DETAILS,
        LOAD_REPLENISHMENT_ORDER_DETAILS_SUCCESS: LOAD_REPLENISHMENT_ORDER_DETAILS_SUCCESS,
        LOAD_REPLENISHMENT_ORDER_DETAILS_FAIL: LOAD_REPLENISHMENT_ORDER_DETAILS_FAIL,
        ClEAR_REPLENISHMENT_ORDER_DETAILS: ClEAR_REPLENISHMENT_ORDER_DETAILS,
        CANCEL_REPLENISHMENT_ORDER: CANCEL_REPLENISHMENT_ORDER,
        CANCEL_REPLENISHMENT_ORDER_SUCCESS: CANCEL_REPLENISHMENT_ORDER_SUCCESS,
        CANCEL_REPLENISHMENT_ORDER_FAIL: CANCEL_REPLENISHMENT_ORDER_FAIL,
        CLEAR_CANCEL_REPLENISHMENT_ORDER: CLEAR_CANCEL_REPLENISHMENT_ORDER,
        LoadReplenishmentOrderDetails: LoadReplenishmentOrderDetails,
        LoadReplenishmentOrderDetailsSuccess: LoadReplenishmentOrderDetailsSuccess,
        LoadReplenishmentOrderDetailsFail: LoadReplenishmentOrderDetailsFail,
        ClearReplenishmentOrderDetails: ClearReplenishmentOrderDetails,
        CancelReplenishmentOrder: CancelReplenishmentOrder,
        CancelReplenishmentOrderSuccess: CancelReplenishmentOrderSuccess,
        CancelReplenishmentOrderFail: CancelReplenishmentOrderFail,
        ClearCancelReplenishmentOrder: ClearCancelReplenishmentOrder,
        LOAD_USER_ADDRESSES: LOAD_USER_ADDRESSES,
        LOAD_USER_ADDRESSES_FAIL: LOAD_USER_ADDRESSES_FAIL,
        LOAD_USER_ADDRESSES_SUCCESS: LOAD_USER_ADDRESSES_SUCCESS,
        ADD_USER_ADDRESS: ADD_USER_ADDRESS,
        ADD_USER_ADDRESS_FAIL: ADD_USER_ADDRESS_FAIL,
        ADD_USER_ADDRESS_SUCCESS: ADD_USER_ADDRESS_SUCCESS,
        UPDATE_USER_ADDRESS: UPDATE_USER_ADDRESS,
        UPDATE_USER_ADDRESS_FAIL: UPDATE_USER_ADDRESS_FAIL,
        UPDATE_USER_ADDRESS_SUCCESS: UPDATE_USER_ADDRESS_SUCCESS,
        DELETE_USER_ADDRESS: DELETE_USER_ADDRESS,
        DELETE_USER_ADDRESS_FAIL: DELETE_USER_ADDRESS_FAIL,
        DELETE_USER_ADDRESS_SUCCESS: DELETE_USER_ADDRESS_SUCCESS,
        LoadUserAddresses: LoadUserAddresses,
        LoadUserAddressesFail: LoadUserAddressesFail,
        LoadUserAddressesSuccess: LoadUserAddressesSuccess,
        AddUserAddress: AddUserAddress,
        AddUserAddressFail: AddUserAddressFail,
        AddUserAddressSuccess: AddUserAddressSuccess,
        UpdateUserAddress: UpdateUserAddress,
        UpdateUserAddressFail: UpdateUserAddressFail,
        UpdateUserAddressSuccess: UpdateUserAddressSuccess,
        DeleteUserAddress: DeleteUserAddress,
        DeleteUserAddressFail: DeleteUserAddressFail,
        DeleteUserAddressSuccess: DeleteUserAddressSuccess,
        LOAD_USER_CONSENTS: LOAD_USER_CONSENTS,
        LOAD_USER_CONSENTS_SUCCESS: LOAD_USER_CONSENTS_SUCCESS,
        LOAD_USER_CONSENTS_FAIL: LOAD_USER_CONSENTS_FAIL,
        RESET_LOAD_USER_CONSENTS: RESET_LOAD_USER_CONSENTS,
        GIVE_USER_CONSENT: GIVE_USER_CONSENT,
        GIVE_USER_CONSENT_FAIL: GIVE_USER_CONSENT_FAIL,
        GIVE_USER_CONSENT_SUCCESS: GIVE_USER_CONSENT_SUCCESS,
        RESET_GIVE_USER_CONSENT_PROCESS: RESET_GIVE_USER_CONSENT_PROCESS,
        TRANSFER_ANONYMOUS_CONSENT: TRANSFER_ANONYMOUS_CONSENT,
        WITHDRAW_USER_CONSENT: WITHDRAW_USER_CONSENT,
        WITHDRAW_USER_CONSENT_FAIL: WITHDRAW_USER_CONSENT_FAIL,
        WITHDRAW_USER_CONSENT_SUCCESS: WITHDRAW_USER_CONSENT_SUCCESS,
        RESET_WITHDRAW_USER_CONSENT_PROCESS: RESET_WITHDRAW_USER_CONSENT_PROCESS,
        LoadUserConsents: LoadUserConsents,
        LoadUserConsentsFail: LoadUserConsentsFail,
        LoadUserConsentsSuccess: LoadUserConsentsSuccess,
        ResetLoadUserConsents: ResetLoadUserConsents,
        GiveUserConsent: GiveUserConsent,
        GiveUserConsentFail: GiveUserConsentFail,
        GiveUserConsentSuccess: GiveUserConsentSuccess,
        ResetGiveUserConsentProcess: ResetGiveUserConsentProcess,
        TransferAnonymousConsent: TransferAnonymousConsent,
        WithdrawUserConsent: WithdrawUserConsent,
        WithdrawUserConsentFail: WithdrawUserConsentFail,
        WithdrawUserConsentSuccess: WithdrawUserConsentSuccess,
        ResetWithdrawUserConsentProcess: ResetWithdrawUserConsentProcess,
        LOAD_ACTIVE_COST_CENTERS: LOAD_ACTIVE_COST_CENTERS,
        LOAD_ACTIVE_COST_CENTERS_FAIL: LOAD_ACTIVE_COST_CENTERS_FAIL,
        LOAD_ACTIVE_COST_CENTERS_SUCCESS: LOAD_ACTIVE_COST_CENTERS_SUCCESS,
        LoadActiveCostCenters: LoadActiveCostCenters,
        LoadActiveCostCentersFail: LoadActiveCostCentersFail,
        LoadActiveCostCentersSuccess: LoadActiveCostCentersSuccess,
        CLEAR_USER_MISCS_DATA: CLEAR_USER_MISCS_DATA,
        ClearUserMiscsData: ClearUserMiscsData,
        LOAD_USER_ORDERS: LOAD_USER_ORDERS,
        LOAD_USER_ORDERS_FAIL: LOAD_USER_ORDERS_FAIL,
        LOAD_USER_ORDERS_SUCCESS: LOAD_USER_ORDERS_SUCCESS,
        CLEAR_USER_ORDERS: CLEAR_USER_ORDERS,
        LoadUserOrders: LoadUserOrders,
        LoadUserOrdersFail: LoadUserOrdersFail,
        LoadUserOrdersSuccess: LoadUserOrdersSuccess,
        ClearUserOrders: ClearUserOrders,
        REGISTER_USER_SUCCESS: REGISTER_USER_SUCCESS,
        RegisterUserSuccess: RegisterUserSuccess,
        LOAD_USER_REPLENISHMENT_ORDERS: LOAD_USER_REPLENISHMENT_ORDERS,
        LOAD_USER_REPLENISHMENT_ORDERS_FAIL: LOAD_USER_REPLENISHMENT_ORDERS_FAIL,
        LOAD_USER_REPLENISHMENT_ORDERS_SUCCESS: LOAD_USER_REPLENISHMENT_ORDERS_SUCCESS,
        CLEAR_USER_REPLENISHMENT_ORDERS: CLEAR_USER_REPLENISHMENT_ORDERS,
        LoadUserReplenishmentOrders: LoadUserReplenishmentOrders,
        LoadUserReplenishmentOrdersFail: LoadUserReplenishmentOrdersFail,
        LoadUserReplenishmentOrdersSuccess: LoadUserReplenishmentOrdersSuccess,
        ClearUserReplenishmentOrders: ClearUserReplenishmentOrders
    });

    var AnonymousConsentTemplatesAdapter = /** @class */ (function () {
        function AnonymousConsentTemplatesAdapter() {
        }
        return AnonymousConsentTemplatesAdapter;
    }());

    var AnonymousConsentTemplatesConnector = /** @class */ (function () {
        function AnonymousConsentTemplatesConnector(adapter) {
            this.adapter = adapter;
        }
        AnonymousConsentTemplatesConnector.prototype.loadAnonymousConsentTemplates = function () {
            return this.adapter.loadAnonymousConsentTemplates();
        };
        AnonymousConsentTemplatesConnector.prototype.loadAnonymousConsents = function () {
            return this.adapter.loadAnonymousConsents();
        };
        return AnonymousConsentTemplatesConnector;
    }());
    AnonymousConsentTemplatesConnector.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AnonymousConsentTemplatesConnector, deps: [{ token: AnonymousConsentTemplatesAdapter }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    AnonymousConsentTemplatesConnector.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AnonymousConsentTemplatesConnector, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AnonymousConsentTemplatesConnector, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: AnonymousConsentTemplatesAdapter }]; } });

    var getUserState = i1.createFeatureSelector(USER_FEATURE);

    var getBillingCountriesState = i1.createSelector(getUserState, function (state) { return state.billingCountries; });
    var getBillingCountriesEntites = i1.createSelector(getBillingCountriesState, function (state) { return state.entities; });
    var getAllBillingCountries = i1.createSelector(getBillingCountriesEntites, function (entites) { return Object.keys(entites).map(function (isocode) { return entites[isocode]; }); });

    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var getConsignmentTrackingState = i1.createSelector(getUserState, function (state) { return state.consignmentTracking; });
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var getConsignmentTracking = i1.createSelector(getConsignmentTrackingState, function (state) { return state.tracking; });

    var getCustomerCouponsState = i1.createSelector(getUserState, function (state) { return state.customerCoupons; });
    var getCustomerCouponsLoaded = i1.createSelector(getCustomerCouponsState, function (state) { return loaderSuccessSelector(state); });
    var getCustomerCouponsLoading = i1.createSelector(getCustomerCouponsState, function (state) { return loaderLoadingSelector(state); });
    var getCustomerCoupons = i1.createSelector(getCustomerCouponsState, function (state) { return loaderValueSelector(state); });

    var getDeliveryCountriesState = i1.createSelector(getUserState, function (state) { return state.countries; });
    var getDeliveryCountriesEntites = i1.createSelector(getDeliveryCountriesState, function (state) { return state.entities; });
    var getAllDeliveryCountries = i1.createSelector(getDeliveryCountriesEntites, function (entites) { return Object.keys(entites).map(function (isocode) { return entites[isocode]; }); });
    var countrySelectorFactory = function (isocode) { return i1.createSelector(getDeliveryCountriesEntites, function (entities) { return Object.keys(entities).length !== 0 ? entities[isocode] : null; }); };

    var getPreferencesLoaderState = i1.createSelector(getUserState, function (state) { return state.notificationPreferences; });
    var getPreferences = i1.createSelector(getPreferencesLoaderState, function (state) { return loaderValueSelector(state); });
    var getEnabledPreferences = i1.createSelector(getPreferencesLoaderState, function (state) { return loaderValueSelector(state).filter(function (p) { return p.enabled; }); });
    var getPreferencesLoading = i1.createSelector(getPreferencesLoaderState, function (state) { return loaderLoadingSelector(state); });

    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var getOrderState = i1.createSelector(getUserState, function (state) { return state.order; });
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var getOrderDetails = i1.createSelector(getOrderState, function (state) { return loaderValueSelector(state); });

    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var getOrderReturnRequestState = i1.createSelector(getUserState, function (state) { return state.orderReturn; });
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var getOrderReturnRequest = i1.createSelector(getOrderReturnRequestState, function (state) { return loaderValueSelector(state); });
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var getOrderReturnRequestLoading = i1.createSelector(getOrderReturnRequestState, function (state) { return loaderLoadingSelector(state); });
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var getOrderReturnRequestSuccess = i1.createSelector(getOrderReturnRequestState, function (state) { return loaderSuccessSelector(state) &&
        !loaderLoadingSelector(state); });
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var getOrderReturnRequestListState = i1.createSelector(getUserState, function (state) { return state.orderReturnList; });
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var getOrderReturnRequestList = i1.createSelector(getOrderReturnRequestListState, function (state) { return loaderValueSelector(state); });

    var getPaymentMethodsState = i1.createSelector(getUserState, function (state) { return state.payments; });
    var getPaymentMethods = i1.createSelector(getPaymentMethodsState, function (state) { return loaderValueSelector(state); });
    var getPaymentMethodsLoading = i1.createSelector(getPaymentMethodsState, function (state) { return loaderLoadingSelector(state); });
    var getPaymentMethodsLoadedSuccess = i1.createSelector(getPaymentMethodsState, function (state) { return loaderSuccessSelector(state) &&
        !loaderLoadingSelector(state); });

    var getInterestsState = i1.createSelector(getUserState, function (state) { return state.productInterests; });
    var getInterests = i1.createSelector(getInterestsState, function (state) { return loaderValueSelector(state); });
    var getInterestsLoading = i1.createSelector(getInterestsState, function (state) { return loaderLoadingSelector(state); });

    var getRegionsLoaderState = i1.createSelector(getUserState, function (state) { return state.regions; });
    var getAllRegions = i1.createSelector(getRegionsLoaderState, function (state) {
        return loaderValueSelector(state).entities;
    });
    var getRegionsDataAndLoading = i1.createSelector(getRegionsLoaderState, function (state) { return ({
        loaded: loaderSuccessSelector(state),
        loading: loaderLoadingSelector(state),
        regions: loaderValueSelector(state).entities,
        country: loaderValueSelector(state).country,
    }); });
    var getRegionsCountry = i1.createSelector(getRegionsLoaderState, function (state) { return loaderValueSelector(state).country; });
    var getRegionsLoading = i1.createSelector(getRegionsLoaderState, function (state) { return loaderLoadingSelector(state); });
    var getRegionsLoaded = i1.createSelector(getRegionsLoaderState, function (state) { return loaderSuccessSelector(state); });

    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var getReplenishmentOrderState = i1.createSelector(getUserState, function (state) { return state.replenishmentOrder; });
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var getReplenishmentOrderDetailsValue = i1.createSelector(getReplenishmentOrderState, function (state) { return loaderValueSelector(state); });
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var getReplenishmentOrderDetailsLoading = i1.createSelector(getReplenishmentOrderState, function (state) { return loaderLoadingSelector(state); });
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var getReplenishmentOrderDetailsSuccess = i1.createSelector(getReplenishmentOrderState, function (state) { return loaderSuccessSelector(state); });
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var getReplenishmentOrderDetailsError = i1.createSelector(getReplenishmentOrderState, function (state) { return loaderErrorSelector(state); });

    var getAddressesLoaderState = i1.createSelector(getUserState, function (state) { return state.addresses; });
    var getAddresses = i1.createSelector(getAddressesLoaderState, function (state) { return loaderValueSelector(state); });
    var getAddressesLoading = i1.createSelector(getAddressesLoaderState, function (state) { return loaderLoadingSelector(state); });
    var getAddressesLoadedSuccess = i1.createSelector(getAddressesLoaderState, function (state) { return loaderSuccessSelector(state) &&
        !loaderLoadingSelector(state); });

    var getConsentsState = i1.createSelector(getUserState, function (state) { return state.consents; });
    var getConsentsValue = i1.createSelector(getConsentsState, loaderValueSelector);
    var getConsentByTemplateId = function (templateId) { return i1.createSelector(getConsentsValue, function (templates) { return templates.find(function (template) { return template.id === templateId; }); }); };
    var getConsentsLoading = i1.createSelector(getConsentsState, loaderLoadingSelector);
    var getConsentsSuccess = i1.createSelector(getConsentsState, loaderSuccessSelector);
    var getConsentsError = i1.createSelector(getConsentsState, loaderErrorSelector);

    var getCostCentersState = i1.createSelector(getUserState, function (state) { return state.costCenters; });
    var getCostCenters = i1.createSelector(getCostCentersState, function (state) { return loaderValueSelector(state); });

    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var getOrdersState = i1.createSelector(getUserState, function (state) { return state.orders; });
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var getOrdersLoaded = i1.createSelector(getOrdersState, function (state) { return loaderSuccessSelector(state); });
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var getOrders = i1.createSelector(getOrdersState, function (state) { return loaderValueSelector(state); });

    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var getReplenishmentOrdersState = i1.createSelector(getUserState, function (state) { return state.replenishmentOrders; });
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var getReplenishmentOrders = i1.createSelector(getReplenishmentOrdersState, function (state) { return loaderValueSelector(state); });
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var getReplenishmentOrdersLoading = i1.createSelector(getReplenishmentOrdersState, function (state) { return loaderLoadingSelector(state); });
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var getReplenishmentOrdersError = i1.createSelector(getReplenishmentOrdersState, function (state) { return loaderErrorSelector(state); });
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var getReplenishmentOrdersSuccess = i1.createSelector(getReplenishmentOrdersState, function (state) { return loaderSuccessSelector(state); });

    var usersGroup_selectors = /*#__PURE__*/Object.freeze({
        __proto__: null,
        getBillingCountriesState: getBillingCountriesState,
        getBillingCountriesEntites: getBillingCountriesEntites,
        getAllBillingCountries: getAllBillingCountries,
        getConsignmentTrackingState: getConsignmentTrackingState,
        getConsignmentTracking: getConsignmentTracking,
        getCustomerCouponsState: getCustomerCouponsState,
        getCustomerCouponsLoaded: getCustomerCouponsLoaded,
        getCustomerCouponsLoading: getCustomerCouponsLoading,
        getCustomerCoupons: getCustomerCoupons,
        getDeliveryCountriesState: getDeliveryCountriesState,
        getDeliveryCountriesEntites: getDeliveryCountriesEntites,
        getAllDeliveryCountries: getAllDeliveryCountries,
        countrySelectorFactory: countrySelectorFactory,
        getUserState: getUserState,
        getPreferencesLoaderState: getPreferencesLoaderState,
        getPreferences: getPreferences,
        getEnabledPreferences: getEnabledPreferences,
        getPreferencesLoading: getPreferencesLoading,
        getOrderState: getOrderState,
        getOrderDetails: getOrderDetails,
        getOrderReturnRequestState: getOrderReturnRequestState,
        getOrderReturnRequest: getOrderReturnRequest,
        getOrderReturnRequestLoading: getOrderReturnRequestLoading,
        getOrderReturnRequestSuccess: getOrderReturnRequestSuccess,
        getOrderReturnRequestListState: getOrderReturnRequestListState,
        getOrderReturnRequestList: getOrderReturnRequestList,
        getPaymentMethodsState: getPaymentMethodsState,
        getPaymentMethods: getPaymentMethods,
        getPaymentMethodsLoading: getPaymentMethodsLoading,
        getPaymentMethodsLoadedSuccess: getPaymentMethodsLoadedSuccess,
        getInterestsState: getInterestsState,
        getInterests: getInterests,
        getInterestsLoading: getInterestsLoading,
        getRegionsLoaderState: getRegionsLoaderState,
        getAllRegions: getAllRegions,
        getRegionsDataAndLoading: getRegionsDataAndLoading,
        getRegionsCountry: getRegionsCountry,
        getRegionsLoading: getRegionsLoading,
        getRegionsLoaded: getRegionsLoaded,
        getReplenishmentOrderState: getReplenishmentOrderState,
        getReplenishmentOrderDetailsValue: getReplenishmentOrderDetailsValue,
        getReplenishmentOrderDetailsLoading: getReplenishmentOrderDetailsLoading,
        getReplenishmentOrderDetailsSuccess: getReplenishmentOrderDetailsSuccess,
        getReplenishmentOrderDetailsError: getReplenishmentOrderDetailsError,
        getAddressesLoaderState: getAddressesLoaderState,
        getAddresses: getAddresses,
        getAddressesLoading: getAddressesLoading,
        getAddressesLoadedSuccess: getAddressesLoadedSuccess,
        getConsentsState: getConsentsState,
        getConsentsValue: getConsentsValue,
        getConsentByTemplateId: getConsentByTemplateId,
        getConsentsLoading: getConsentsLoading,
        getConsentsSuccess: getConsentsSuccess,
        getConsentsError: getConsentsError,
        getCostCentersState: getCostCentersState,
        getCostCenters: getCostCenters,
        getOrdersState: getOrdersState,
        getOrdersLoaded: getOrdersLoaded,
        getOrders: getOrders,
        getReplenishmentOrdersState: getReplenishmentOrdersState,
        getReplenishmentOrders: getReplenishmentOrders,
        getReplenishmentOrdersLoading: getReplenishmentOrdersLoading,
        getReplenishmentOrdersError: getReplenishmentOrdersError,
        getReplenishmentOrdersSuccess: getReplenishmentOrdersSuccess
    });

    var UserConsentService = /** @class */ (function () {
        function UserConsentService(store, authService, userIdService) {
            this.store = store;
            this.authService = authService;
            this.userIdService = userIdService;
        }
        /**
         * Retrieves all consents.
         */
        UserConsentService.prototype.loadConsents = function () {
            var _this = this;
            this.userIdService.takeUserId().subscribe(function (userId) {
                _this.store.dispatch(new LoadUserConsents(userId));
            });
        };
        /**
         * Returns all consent templates. If `loadIfMissing` parameter is set to `true`, the method triggers the load if consent templates.
         * @param loadIfMissing is set to `true`, the method will load templates if those are not already present. The default value is `false`.
         */
        UserConsentService.prototype.getConsents = function (loadIfMissing) {
            var _this = this;
            if (loadIfMissing === void 0) { loadIfMissing = false; }
            return rxjs.iif(function () { return loadIfMissing; }, this.store.pipe(i1.select(getConsentsValue), operators.withLatestFrom(this.getConsentsResultLoading(), this.getConsentsResultSuccess()), operators.filter(function (_a) {
                var _b = __read(_a, 3), _templates = _b[0], loading = _b[1], _success = _b[2];
                return !loading;
            }), operators.tap(function (_a) {
                var _b = __read(_a, 3), templates = _b[0], _loading = _b[1], success = _b[2];
                if (!templates || templates.length === 0) {
                    // avoid infite loop - if we've already attempted to load templates and we got an empty array as the response
                    if (!success) {
                        _this.loadConsents();
                    }
                }
            }), operators.filter(function (_a) {
                var _b = __read(_a, 2), templates = _b[0], _loading = _b[1];
                return Boolean(templates);
            }), operators.map(function (_a) {
                var _b = __read(_a, 2), templates = _b[0], _loading = _b[1];
                return templates;
            })), this.store.pipe(i1.select(getConsentsValue)));
        };
        /**
         * Returns the consents loading flag
         */
        UserConsentService.prototype.getConsentsResultLoading = function () {
            return this.store.pipe(i1.select(getConsentsLoading));
        };
        /**
         * Returns the consents success flag
         */
        UserConsentService.prototype.getConsentsResultSuccess = function () {
            return this.store.pipe(i1.select(getConsentsSuccess));
        };
        /**
         * Returns the consents error flag
         */
        UserConsentService.prototype.getConsentsResultError = function () {
            return this.store.pipe(i1.select(getConsentsError));
        };
        /**
         * Resets the processing state for consent retrieval
         */
        UserConsentService.prototype.resetConsentsProcessState = function () {
            this.store.dispatch(new ResetLoadUserConsents());
        };
        /**
         * Returns the registered consent for the given template ID.
         *
         * As a side-effect, the method will call `getConsents(true)` to load the templates if those are not present.
         *
         * @param templateId a template ID by which to filter the registered templates.
         */
        UserConsentService.prototype.getConsent = function (templateId) {
            var _this = this;
            return this.authService.isUserLoggedIn().pipe(operators.filter(Boolean), operators.switchMap(function () { return _this.getConsents(true); }), operators.switchMap(function () { return _this.store.pipe(i1.select(getConsentByTemplateId(templateId))); }), operators.filter(function (template) { return Boolean(template); }), operators.map(function (template) { return template.currentConsent; }));
        };
        /**
         * Returns `true` if the consent is truthy and if `consentWithdrawnDate` doesn't exist.
         * Otherwise, `false` is returned.
         *
         * @param consent to check
         */
        UserConsentService.prototype.isConsentGiven = function (consent) {
            return (Boolean(consent) &&
                Boolean(consent.consentGivenDate) &&
                !Boolean(consent.consentWithdrawnDate));
        };
        /**
         * Returns `true` if the consent is either falsy or if `consentWithdrawnDate` is present.
         * Otherwise, `false` is returned.
         *
         * @param consent to check
         */
        UserConsentService.prototype.isConsentWithdrawn = function (consent) {
            if (Boolean(consent)) {
                return Boolean(consent.consentWithdrawnDate);
            }
            return true;
        };
        /**
         * Give consent for specified consent template ID and version.
         * @param consentTemplateId a template ID for which to give a consent
         * @param consentTemplateVersion a template version for which to give a consent
         */
        UserConsentService.prototype.giveConsent = function (consentTemplateId, consentTemplateVersion) {
            var _this = this;
            this.userIdService.takeUserId().subscribe(function (userId) {
                _this.store.dispatch(new GiveUserConsent({
                    userId: userId,
                    consentTemplateId: consentTemplateId,
                    consentTemplateVersion: consentTemplateVersion,
                }));
            });
        };
        /**
         * Returns the give consent process loading flag
         */
        UserConsentService.prototype.getGiveConsentResultLoading = function () {
            return this.store.pipe(i1.select(getProcessLoadingFactory(GIVE_CONSENT_PROCESS_ID)));
        };
        /**
         * Returns the give consent process success flag
         */
        UserConsentService.prototype.getGiveConsentResultSuccess = function () {
            return this.store.pipe(i1.select(getProcessSuccessFactory(GIVE_CONSENT_PROCESS_ID)));
        };
        /**
         * Returns the give consent process error flag
         */
        UserConsentService.prototype.getGiveConsentResultError = function () {
            return this.store.pipe(i1.select(getProcessErrorFactory(GIVE_CONSENT_PROCESS_ID)));
        };
        /**
         * Resents the give consent process flags
         */
        UserConsentService.prototype.resetGiveConsentProcessState = function () {
            return this.store.dispatch(new ResetGiveUserConsentProcess());
        };
        /**
         * Withdraw consent for the given `consentCode`
         * @param consentCode for which to withdraw the consent
         */
        UserConsentService.prototype.withdrawConsent = function (consentCode) {
            var _this = this;
            this.userIdService.takeUserId().subscribe(function (userId) {
                _this.store.dispatch(new WithdrawUserConsent({
                    userId: userId,
                    consentCode: consentCode,
                }));
            });
        };
        /**
         * Returns the withdraw consent process loading flag
         */
        UserConsentService.prototype.getWithdrawConsentResultLoading = function () {
            return this.store.pipe(i1.select(getProcessLoadingFactory(WITHDRAW_CONSENT_PROCESS_ID)));
        };
        /**
         * Returns the withdraw consent process success flag
         */
        UserConsentService.prototype.getWithdrawConsentResultSuccess = function () {
            return this.store.pipe(i1.select(getProcessSuccessFactory(WITHDRAW_CONSENT_PROCESS_ID)));
        };
        /**
         * Returns the withdraw consent process error flag
         */
        UserConsentService.prototype.getWithdrawConsentResultError = function () {
            return this.store.pipe(i1.select(getProcessErrorFactory(WITHDRAW_CONSENT_PROCESS_ID)));
        };
        /**
         * Resets the process flags for withdraw consent
         */
        UserConsentService.prototype.resetWithdrawConsentProcessState = function () {
            return this.store.dispatch(new ResetWithdrawUserConsentProcess());
        };
        /**
         * Filters the provided `templateList`' templates by hiding the template IDs specified in `hideTemplateIds`.
         * If the `hideTemplateIds` is empty, the provided `templateList` is returned.
         *
         * @param templateList a list of consent templates to filter
         * @param hideTemplateIds template IDs to hide
         */
        UserConsentService.prototype.filterConsentTemplates = function (templateList, hideTemplateIds) {
            var e_1, _a;
            if (hideTemplateIds === void 0) { hideTemplateIds = []; }
            if (hideTemplateIds.length === 0) {
                return templateList;
            }
            var updatedTemplateList = [];
            try {
                for (var templateList_1 = __values(templateList), templateList_1_1 = templateList_1.next(); !templateList_1_1.done; templateList_1_1 = templateList_1.next()) {
                    var template = templateList_1_1.value;
                    var show = !hideTemplateIds.includes(template.id);
                    if (show) {
                        updatedTemplateList.push(template);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (templateList_1_1 && !templateList_1_1.done && (_a = templateList_1.return)) _a.call(templateList_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return updatedTemplateList;
        };
        return UserConsentService;
    }());
    UserConsentService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserConsentService, deps: [{ token: i1__namespace$2.Store }, { token: AuthService }, { token: UserIdService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    UserConsentService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserConsentService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserConsentService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace$2.Store }, { type: AuthService }, { type: UserIdService }]; } });

    var AnonymousConsentsEffects = /** @class */ (function () {
        function AnonymousConsentsEffects(actions$, anonymousConsentTemplatesConnector, authService, anonymousConsentsConfig, anonymousConsentService, userConsentService, userIdService) {
            var _this = this;
            this.actions$ = actions$;
            this.anonymousConsentTemplatesConnector = anonymousConsentTemplatesConnector;
            this.authService = authService;
            this.anonymousConsentsConfig = anonymousConsentsConfig;
            this.anonymousConsentService = anonymousConsentService;
            this.userConsentService = userConsentService;
            this.userIdService = userIdService;
            this.checkConsentVersions$ = this.actions$.pipe(i1$4.ofType(ANONYMOUS_CONSENT_CHECK_UPDATED_VERSIONS), operators.withLatestFrom(this.anonymousConsentService.getConsents()), operators.concatMap(function (_a) {
                var _b = __read(_a, 2), _ = _b[0], currentConsents = _b[1];
                return _this.anonymousConsentTemplatesConnector
                    .loadAnonymousConsents()
                    .pipe(operators.map(function (newConsents) {
                    if (!newConsents) {
                        if (i0.isDevMode()) {
                            console.warn('No consents were loaded. Please check the Spartacus documentation as this could be a back-end configuration issue.');
                        }
                        return false;
                    }
                    var currentConsentVersions = currentConsents.map(function (consent) { return consent.templateVersion; });
                    var newConsentVersions = newConsents.map(function (consent) { return consent.templateVersion; });
                    return _this.detectUpdatedVersion(currentConsentVersions, newConsentVersions);
                }), operators.switchMap(function (updated) { return updated
                    ? rxjs.of(new LoadAnonymousConsentTemplates())
                    : rxjs.EMPTY; }), operators.catchError(function (error) { return rxjs.of(new LoadAnonymousConsentTemplatesFail(normalizeHttpError(error))); }));
            }));
            this.loadAnonymousConsentTemplates$ = this.actions$.pipe(i1$4.ofType(LOAD_ANONYMOUS_CONSENT_TEMPLATES), operators.withLatestFrom(this.anonymousConsentService.getTemplates()), operators.concatMap(function (_a) {
                var _b = __read(_a, 2), _ = _b[0], currentConsentTemplates = _b[1];
                return _this.anonymousConsentTemplatesConnector
                    .loadAnonymousConsentTemplates()
                    .pipe(operators.mergeMap(function (newConsentTemplates) {
                    var updated = false;
                    if (currentConsentTemplates &&
                        currentConsentTemplates.length !== 0) {
                        updated = _this.anonymousConsentService.detectUpdatedTemplates(currentConsentTemplates, newConsentTemplates);
                    }
                    return [
                        new LoadAnonymousConsentTemplatesSuccess(newConsentTemplates),
                        new ToggleAnonymousConsentTemplatesUpdated(updated),
                    ];
                }), operators.catchError(function (error) { return rxjs.of(new LoadAnonymousConsentTemplatesFail(normalizeHttpError(error))); }));
            }));
            // TODO(#9416): This won't work with flow different than `Resource Owner Password Flow` which involves redirect (maybe in popup in will work)
            this.transferAnonymousConsentsToUser$ = this.actions$.pipe(i1$4.ofType(LOGIN), operators.filter(function () { return Boolean(_this.anonymousConsentsConfig.anonymousConsents); }), operators.withLatestFrom(this.actions$.pipe(i1$4.ofType(REGISTER_USER_SUCCESS))), operators.filter(function (_a) {
                var _b = __read(_a, 2), registerAction = _b[1];
                return Boolean(registerAction);
            }), operators.switchMap(function () { return _this.anonymousConsentService.getConsents().pipe(operators.withLatestFrom(_this.userIdService.getUserId(), _this.anonymousConsentService.getTemplates(), _this.authService.isUserLoggedIn()), operators.filter(function (_a) {
                var _b = __read(_a, 4), loggedIn = _b[3];
                return loggedIn;
            }), operators.concatMap(function (_a) {
                var e_1, _b, e_2, _c;
                var _d = __read(_a, 4), consents = _d[0], userId = _d[1], templates = _d[2], _loggedIn = _d[3];
                var actions = [];
                try {
                    for (var consents_1 = __values(consents), consents_1_1 = consents_1.next(); !consents_1_1.done; consents_1_1 = consents_1.next()) {
                        var consent = consents_1_1.value;
                        if (_this.anonymousConsentService.isConsentGiven(consent) &&
                            (!_this.anonymousConsentsConfig.anonymousConsents
                                .requiredConsents ||
                                !_this.anonymousConsentsConfig.anonymousConsents.requiredConsents.includes(consent.templateCode))) {
                            try {
                                for (var templates_1 = (e_2 = void 0, __values(templates)), templates_1_1 = templates_1.next(); !templates_1_1.done; templates_1_1 = templates_1.next()) {
                                    var template = templates_1_1.value;
                                    if (template.id === consent.templateCode) {
                                        actions.push(new TransferAnonymousConsent({
                                            userId: userId,
                                            consentTemplateId: template.id,
                                            consentTemplateVersion: template.version,
                                        }));
                                        break;
                                    }
                                }
                            }
                            catch (e_2_1) { e_2 = { error: e_2_1 }; }
                            finally {
                                try {
                                    if (templates_1_1 && !templates_1_1.done && (_c = templates_1.return)) _c.call(templates_1);
                                }
                                finally { if (e_2) throw e_2.error; }
                            }
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (consents_1_1 && !consents_1_1.done && (_b = consents_1.return)) _b.call(consents_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                if (actions.length > 0) {
                    return actions;
                }
                return rxjs.EMPTY;
            })); }));
            this.giveRequiredConsentsToUser$ = this.actions$.pipe(i1$4.ofType(LOGIN), operators.filter(function (action) { return Boolean(_this.anonymousConsentsConfig.anonymousConsents) &&
                Boolean(_this.anonymousConsentsConfig.anonymousConsents.requiredConsents) &&
                Boolean(action); }), operators.concatMap(function () { return _this.userConsentService.getConsentsResultSuccess().pipe(operators.withLatestFrom(_this.userIdService.getUserId(), _this.userConsentService.getConsents(), _this.authService.isUserLoggedIn()), operators.filter(function (_a) {
                var _b = __read(_a, 4), loggedIn = _b[3];
                return loggedIn;
            }), operators.tap(function (_a) {
                var _b = __read(_a, 4), loaded = _b[0], _userId = _b[1], _templates = _b[2], _loggedIn = _b[3];
                if (!loaded) {
                    _this.userConsentService.loadConsents();
                }
            }), operators.map(function (_a) {
                var _b = __read(_a, 4), _loaded = _b[0], userId = _b[1], templates = _b[2], _loggedIn = _b[3];
                return { userId: userId, templates: templates };
            }), operators.concatMap(function (_a) {
                var e_3, _b;
                var userId = _a.userId, templates = _a.templates;
                var actions = [];
                try {
                    for (var templates_2 = __values(templates), templates_2_1 = templates_2.next(); !templates_2_1.done; templates_2_1 = templates_2.next()) {
                        var template = templates_2_1.value;
                        if (_this.userConsentService.isConsentWithdrawn(template.currentConsent) &&
                            _this.anonymousConsentsConfig.anonymousConsents.requiredConsents.includes(template.id)) {
                            actions.push(new GiveUserConsent({
                                userId: userId,
                                consentTemplateId: template.id,
                                consentTemplateVersion: template.version,
                            }));
                        }
                    }
                }
                catch (e_3_1) { e_3 = { error: e_3_1 }; }
                finally {
                    try {
                        if (templates_2_1 && !templates_2_1.done && (_b = templates_2.return)) _b.call(templates_2);
                    }
                    finally { if (e_3) throw e_3.error; }
                }
                if (actions.length > 0) {
                    return actions;
                }
                return rxjs.EMPTY;
            })); }));
        }
        /**
         * Compares the given versions and determines if there's a mismatch,
         * in which case `true` is returned.
         *
         * @param currentVersions versions of the current consents
         * @param newVersions versions of the new consents
         */
        AnonymousConsentsEffects.prototype.detectUpdatedVersion = function (currentVersions, newVersions) {
            if (currentVersions.length !== newVersions.length) {
                return true;
            }
            for (var i = 0; i < newVersions.length; i++) {
                if (currentVersions[i] !== newVersions[i]) {
                    return true;
                }
            }
            return false;
        };
        return AnonymousConsentsEffects;
    }());
    AnonymousConsentsEffects.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AnonymousConsentsEffects, deps: [{ token: i1__namespace$4.Actions }, { token: AnonymousConsentTemplatesConnector }, { token: AuthService }, { token: AnonymousConsentsConfig }, { token: AnonymousConsentsService }, { token: UserConsentService }, { token: UserIdService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    AnonymousConsentsEffects.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AnonymousConsentsEffects });
    __decorate([
        i1$4.Effect()
    ], AnonymousConsentsEffects.prototype, "checkConsentVersions$", void 0);
    __decorate([
        i1$4.Effect()
    ], AnonymousConsentsEffects.prototype, "loadAnonymousConsentTemplates$", void 0);
    __decorate([
        i1$4.Effect()
    ], AnonymousConsentsEffects.prototype, "transferAnonymousConsentsToUser$", void 0);
    __decorate([
        i1$4.Effect()
    ], AnonymousConsentsEffects.prototype, "giveRequiredConsentsToUser$", void 0);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AnonymousConsentsEffects, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: i1__namespace$4.Actions }, { type: AnonymousConsentTemplatesConnector }, { type: AuthService }, { type: AnonymousConsentsConfig }, { type: AnonymousConsentsService }, { type: UserConsentService }, { type: UserIdService }]; }, propDecorators: { checkConsentVersions$: [], loadAnonymousConsentTemplates$: [], transferAnonymousConsentsToUser$: [], giveRequiredConsentsToUser$: [] } });

    var effects$5 = [AnonymousConsentsEffects];

    var JavaRegExpConverter = /** @class */ (function () {
        function JavaRegExpConverter() {
            /**
             * Pattern that extracts modifiers from the Java regexp.
             *
             * Java regexps MAY start with ONE or MANY modifiers like `(?MODIFIERS)PATTERN`. Examples:
             * - `(?i)` for Case Insensitive Mode: `(?i)PATTERN`
             * - `(?u)` for Unicode-Aware Case Folding; `(?u)PATTERN`
             * - or multiple combined:  `(?iu)PATTERN`
             * - (more modifiers in the official Java docs https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html)
             *
             * This pattern extracts 3 parts from the input string, i.e. for `(?iu)PATTERN`:
             *    1. original modifiers syntax, i.e. `(?iu)` (or undefined if no modifiers present)
             *    2. extracted modifiers, i.e. `iu` (or undefined if no modifiers present)
             *    3. the rest of the regexp, i.e. `PATTERN`
             */
            this.EXTRACT_JAVA_REGEXP_MODIFIERS = /^(\(\?([a-z]+)\))?(.*)/;
        }
        /**
         * Converts RegExp from Java syntax to Javascript, by recognizing Java regexp modifiers
         * and converting them to the Javascript ones (i.e. case insensitive mode: `(?i)PATTERN` -> `/pattern/i`)
         *
         * **CAUTION!** Not all features and modifiers of Java regexps are valid in Javascript!
         * If unsupported feature or modifier is used, then `null` will be returned instead of Javascript RegExp.
         *
         * See differences between Java and Javascript regexps:
         * - https://stackoverflow.com/questions/8754444/convert-javascript-regular-expression-to-java-syntax
         * - https://en.wikipedia.org/wiki/Comparison_of_regular_expression_engines#Language_features
         */
        JavaRegExpConverter.prototype.toJsRegExp = function (javaSyntax) {
            var parts = javaSyntax.match(this.EXTRACT_JAVA_REGEXP_MODIFIERS);
            if (!parts) {
                return null;
            }
            var _a = __read(parts, 4), modifiers = _a[2], jsSyntax = _a[3];
            try {
                return new RegExp(jsSyntax, modifiers);
            }
            catch (error) {
                if (i0.isDevMode()) {
                    console.warn("WARNING: Could not convert Java regexp into Javascript. Original regexp: " + javaSyntax + " \nMessage: " + error);
                }
                return null;
            }
        };
        return JavaRegExpConverter;
    }());
    JavaRegExpConverter.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: JavaRegExpConverter, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    JavaRegExpConverter.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: JavaRegExpConverter, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: JavaRegExpConverter, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }] });

    var SiteContextConfigInitializer = /** @class */ (function () {
        function SiteContextConfigInitializer(baseSiteService, javaRegExpConverter, winRef) {
            var _this = this;
            this.baseSiteService = baseSiteService;
            this.javaRegExpConverter = javaRegExpConverter;
            this.winRef = winRef;
            this.scopes = ['context'];
            this.configFactory = function () { return _this.resolveConfig().toPromise(); };
        }
        Object.defineProperty(SiteContextConfigInitializer.prototype, "currentUrl", {
            get: function () {
                return this.winRef.location.href;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Emits the site context config basing on the current base site data.
         *
         * Completes after emitting the value.
         */
        SiteContextConfigInitializer.prototype.resolveConfig = function () {
            var _this = this;
            return this.baseSiteService.getAll().pipe(operators.map(function (baseSites) { return baseSites === null || baseSites === void 0 ? void 0 : baseSites.find(function (site) { return _this.isCurrentBaseSite(site); }); }), operators.filter(function (baseSite) {
                if (!baseSite) {
                    throw new Error("Error: Cannot get base site config! Current url (" + _this.currentUrl + ") doesn't match any of url patterns of any base sites.");
                }
                return Boolean(baseSite);
            }), operators.map(function (baseSite) { return _this.getConfig(baseSite); }), operators.take(1));
        };
        SiteContextConfigInitializer.prototype.getConfig = function (source) {
            var _e;
            var _a, _b, _c, _d;
            var result = {
                context: (_e = {
                        urlParameters: this.getUrlParams(source.urlEncodingAttributes)
                    },
                    _e[BASE_SITE_CONTEXT_ID] = [source.uid],
                    _e[LANGUAGE_CONTEXT_ID] = this.getIsoCodes((_a = source.baseStore) === null || _a === void 0 ? void 0 : _a.languages, source.defaultLanguage || ((_b = source.baseStore) === null || _b === void 0 ? void 0 : _b.defaultLanguage)),
                    _e[CURRENCY_CONTEXT_ID] = this.getIsoCodes((_c = source.baseStore) === null || _c === void 0 ? void 0 : _c.currencies, (_d = source.baseStore) === null || _d === void 0 ? void 0 : _d.defaultCurrency),
                    _e[THEME_CONTEXT_ID] = [source.theme],
                    _e),
            };
            return result;
        };
        SiteContextConfigInitializer.prototype.isCurrentBaseSite = function (site) {
            var _this = this;
            var index = (site.urlPatterns || []).findIndex(function (javaRegexp) {
                var jsRegexp = _this.javaRegExpConverter.toJsRegExp(javaRegexp);
                if (jsRegexp) {
                    var result = jsRegexp.test(_this.currentUrl);
                    return result;
                }
            });
            return index !== -1;
        };
        /**
         * Returns an array of url encoded site context parameters.
         *
         * It maps the string "storefront" (used in OCC) to the "baseSite" (used in Spartacus)
         */
        SiteContextConfigInitializer.prototype.getUrlParams = function (params) {
            var STOREFRONT_PARAM = 'storefront';
            return (params || []).map(function (param) { return param === STOREFRONT_PARAM ? BASE_SITE_CONTEXT_ID : param; });
        };
        /**
         * Returns iso codes in a array, where the first element is the default iso code.
         */
        SiteContextConfigInitializer.prototype.getIsoCodes = function (elements, defaultElement) {
            if (elements && defaultElement) {
                var result = this.moveToFirst(elements, function (el) { return el.isocode === defaultElement.isocode; }).map(function (el) { return el.isocode; });
                return result;
            }
        };
        /**
         * Moves to the start of the array the first element that satisfies the given predicate.
         *
         * @param array array to modify
         * @param predicate function called on elements
         */
        SiteContextConfigInitializer.prototype.moveToFirst = function (array, predicate) {
            array = __spreadArray([], __read(array));
            var index = array.findIndex(predicate);
            if (index !== -1) {
                var _e = __read(array.splice(index, 1), 1), el = _e[0];
                array.unshift(el);
            }
            return array;
        };
        return SiteContextConfigInitializer;
    }());
    SiteContextConfigInitializer.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SiteContextConfigInitializer, deps: [{ token: BaseSiteService }, { token: JavaRegExpConverter }, { token: WindowRef }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    SiteContextConfigInitializer.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SiteContextConfigInitializer, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SiteContextConfigInitializer, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }], ctorParameters: function () { return [{ type: BaseSiteService }, { type: JavaRegExpConverter }, { type: WindowRef }]; } });

    var SiteAdapter = /** @class */ (function () {
        function SiteAdapter() {
        }
        return SiteAdapter;
    }());

    var SiteConnector = /** @class */ (function () {
        function SiteConnector(adapter) {
            this.adapter = adapter;
        }
        SiteConnector.prototype.getLanguages = function () {
            return this.adapter.loadLanguages();
        };
        SiteConnector.prototype.getCurrencies = function () {
            return this.adapter.loadCurrencies();
        };
        SiteConnector.prototype.getCountries = function (type) {
            return this.adapter.loadCountries(type);
        };
        SiteConnector.prototype.getRegions = function (countryIsoCode) {
            return this.adapter.loadRegions(countryIsoCode);
        };
        SiteConnector.prototype.getBaseSite = function (siteUid) {
            return this.adapter.loadBaseSite(siteUid);
        };
        SiteConnector.prototype.getBaseSites = function () {
            return this.adapter.loadBaseSites();
        };
        return SiteConnector;
    }());
    SiteConnector.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SiteConnector, deps: [{ token: SiteAdapter }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    SiteConnector.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SiteConnector, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SiteConnector, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: SiteAdapter }]; } });

    var LANGUAGE_NORMALIZER = new i0.InjectionToken('LanguageNormalizer');
    var CURRENCY_NORMALIZER = new i0.InjectionToken('CurrencyNormalizer');
    var COUNTRY_NORMALIZER = new i0.InjectionToken('CountryNormalizer');
    var REGION_NORMALIZER = new i0.InjectionToken('RegionNormalizer');
    var BASE_SITE_NORMALIZER = new i0.InjectionToken('BaseSiteNormalizer');

    /**
     * Indicates that the language has changed.
     */
    var LanguageSetEvent = /** @class */ (function (_super) {
        __extends(LanguageSetEvent, _super);
        function LanguageSetEvent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return LanguageSetEvent;
    }(CxEvent));
    /**
     * Event's type
     */
    LanguageSetEvent.type = 'LanguageSetEvent';
    /**
     * Indicates that the Currency has changed.
     */
    var CurrencySetEvent = /** @class */ (function (_super) {
        __extends(CurrencySetEvent, _super);
        function CurrencySetEvent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return CurrencySetEvent;
    }(CxEvent));
    /**
     * Event's type
     */
    CurrencySetEvent.type = 'CurrencySetEvent';

    /**
     * Builds and registers the site context events
     */
    var SiteContextEventBuilder = /** @class */ (function () {
        function SiteContextEventBuilder(actionsSubject, eventService) {
            this.actionsSubject = actionsSubject;
            this.eventService = eventService;
            this.register();
        }
        /**
         * Registers the site context events
         */
        SiteContextEventBuilder.prototype.register = function () {
            this.registerSetLanguage();
            this.registerSetCurrency();
        };
        /**
         * Register the language set action
         */
        SiteContextEventBuilder.prototype.registerSetLanguage = function () {
            var languageEvent$ = this.actionsSubject.pipe(i1$4.ofType(SET_ACTIVE_LANGUAGE), operators.map(function (languageAction) { return createFrom(LanguageSetEvent, {
                activeLanguage: languageAction.payload,
            }); }));
            this.eventService.register(LanguageSetEvent, languageEvent$);
        };
        /**
         * Register the currency set action
         */
        SiteContextEventBuilder.prototype.registerSetCurrency = function () {
            var currencyEvent$ = this.actionsSubject.pipe(i1$4.ofType(SET_ACTIVE_CURRENCY), operators.map(function (currencyAction) { return createFrom(CurrencySetEvent, {
                activeCurrency: currencyAction.payload,
            }); }));
            this.eventService.register(CurrencySetEvent, currencyEvent$);
        };
        return SiteContextEventBuilder;
    }());
    SiteContextEventBuilder.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SiteContextEventBuilder, deps: [{ token: i1__namespace$2.ActionsSubject }, { token: EventService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    SiteContextEventBuilder.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SiteContextEventBuilder, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SiteContextEventBuilder, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace$2.ActionsSubject }, { type: EventService }]; } });

    var SiteContextEventModule = /** @class */ (function () {
        function SiteContextEventModule(_siteContextEventBuilder) {
        }
        return SiteContextEventModule;
    }());
    SiteContextEventModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SiteContextEventModule, deps: [{ token: SiteContextEventBuilder }], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    SiteContextEventModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SiteContextEventModule });
    SiteContextEventModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SiteContextEventModule });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SiteContextEventModule, decorators: [{
                type: i0.NgModule,
                args: [{}]
            }], ctorParameters: function () { return [{ type: SiteContextEventBuilder }]; } });

    /**
     * Facade that provides easy access to currency state, actions and selectors.
     */
    var CurrencyService = /** @class */ (function () {
        function CurrencyService(store, config) {
            this.store = store;
            this.config = config;
        }
        /**
         * Represents all the currencies supported by the current store.
         */
        CurrencyService.prototype.getAll = function () {
            var _this = this;
            return this.store.pipe(i1.select(getAllCurrencies), operators.tap(function (currencies) {
                if (!currencies) {
                    _this.store.dispatch(new LoadCurrencies());
                }
            }), operators.filter(function (currencies) { return Boolean(currencies); }));
        };
        /**
         * Represents the isocode of the active currency.
         */
        CurrencyService.prototype.getActive = function () {
            return this.store.pipe(i1.select(getActiveCurrency), operators.filter(function (active) { return Boolean(active); }));
        };
        /**
         * Sets the active language.
         */
        CurrencyService.prototype.setActive = function (isocode) {
            var _this = this;
            this.store
                .pipe(i1.select(getActiveCurrency), operators.take(1))
                .subscribe(function (activeCurrency) {
                if (activeCurrency !== isocode && _this.isValid(isocode)) {
                    _this.store.dispatch(new SetActiveCurrency(isocode));
                }
            });
        };
        /**
         * Tells whether the value of the active currency has been already initialized
         */
        CurrencyService.prototype.isInitialized = function () {
            var valueInitialized = false;
            this.getActive()
                .subscribe(function () { return (valueInitialized = true); })
                .unsubscribe();
            return valueInitialized;
        };
        /**
         * Tells whether the given iso code is allowed.
         *
         * The list of allowed iso codes can be configured in the `context` config of Spartacus.
         */
        CurrencyService.prototype.isValid = function (value) {
            return (!!value &&
                getContextParameterValues(this.config, CURRENCY_CONTEXT_ID).includes(value));
        };
        return CurrencyService;
    }());
    CurrencyService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CurrencyService, deps: [{ token: i1__namespace$2.Store }, { token: SiteContextConfig }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    CurrencyService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CurrencyService });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CurrencyService, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: i1__namespace$2.Store }, { type: SiteContextConfig }]; } });

    /**
     * Facade that provides easy access to language state, actions and selectors.
     */
    var LanguageService = /** @class */ (function () {
        function LanguageService(store, config) {
            this.store = store;
            this.config = config;
        }
        /**
         * Represents all the languages supported by the current store.
         */
        LanguageService.prototype.getAll = function () {
            var _this = this;
            return this.store.pipe(i1.select(getAllLanguages), operators.tap(function (languages) {
                if (!languages) {
                    _this.store.dispatch(new LoadLanguages());
                }
            }), operators.filter(function (languages) { return Boolean(languages); }));
        };
        /**
         * Represents the isocode of the active language.
         */
        LanguageService.prototype.getActive = function () {
            return this.store.pipe(i1.select(getActiveLanguage), operators.filter(function (active) { return Boolean(active); }));
        };
        /**
         * Sets the active language.
         */
        LanguageService.prototype.setActive = function (isocode) {
            var _this = this;
            this.store
                .pipe(i1.select(getActiveLanguage), operators.take(1))
                .subscribe(function (activeLanguage) {
                if (activeLanguage !== isocode && _this.isValid(isocode)) {
                    _this.store.dispatch(new SetActiveLanguage(isocode));
                }
            });
        };
        /**
         * Tells whether the value of the active language has been already initialized
         */
        LanguageService.prototype.isInitialized = function () {
            var valueInitialized = false;
            this.getActive()
                .subscribe(function () { return (valueInitialized = true); })
                .unsubscribe();
            return valueInitialized;
        };
        /**
         * Tells whether the given iso code is allowed.
         *
         * The list of allowed iso codes can be configured in the `context` config of Spartacus.
         */
        LanguageService.prototype.isValid = function (value) {
            return (!!value &&
                getContextParameterValues(this.config, LANGUAGE_CONTEXT_ID).includes(value));
        };
        return LanguageService;
    }());
    LanguageService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: LanguageService, deps: [{ token: i1__namespace$2.Store }, { token: SiteContextConfig }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    LanguageService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: LanguageService });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: LanguageService, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: i1__namespace$2.Store }, { type: SiteContextConfig }]; } });

    var ContextServiceMap = /** @class */ (function () {
        function ContextServiceMap() {
        }
        return ContextServiceMap;
    }());
    function serviceMapFactory() {
        var _a;
        return _a = {},
            _a[LANGUAGE_CONTEXT_ID] = LanguageService,
            _a[CURRENCY_CONTEXT_ID] = CurrencyService,
            _a[BASE_SITE_CONTEXT_ID] = BaseSiteService,
            _a;
    }
    var contextServiceMapProvider = {
        provide: ContextServiceMap,
        useFactory: serviceMapFactory,
    };

    var BaseSiteInitializer = /** @class */ (function () {
        function BaseSiteInitializer(baseSiteService, configInit) {
            this.baseSiteService = baseSiteService;
            this.configInit = configInit;
        }
        /**
         * Initializes the value of the base site
         */
        BaseSiteInitializer.prototype.initialize = function () {
            var _this = this;
            this.subscription = this.configInit
                .getStable('context')
                .pipe(
            // TODO(#12351): <--- plug here explicitly SiteContextRoutesHandler
            operators.switchMap(function () { return _this.setFallbackValue(); }))
                .subscribe();
        };
        /**
         * On subscription to the returned observable:
         *
         * Sets the default value taken from config, unless the active base site has been already initialized.
         */
        BaseSiteInitializer.prototype.setFallbackValue = function () {
            var _this = this;
            return this.configInit
                .getStable('context')
                .pipe(operators.tap(function (config) { return _this.setDefaultFromConfig(config); }));
        };
        /**
         * Sets the active base site value based on the default value from the config,
         * unless the active base site has been already initialized.
         */
        BaseSiteInitializer.prototype.setDefaultFromConfig = function (config) {
            if (!this.baseSiteService.isInitialized()) {
                this.baseSiteService.setActive(getContextParameterDefault(config, BASE_SITE_CONTEXT_ID));
            }
        };
        BaseSiteInitializer.prototype.ngOnDestroy = function () {
            var _a;
            (_a = this.subscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();
        };
        return BaseSiteInitializer;
    }());
    BaseSiteInitializer.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: BaseSiteInitializer, deps: [{ token: BaseSiteService }, { token: ConfigInitializerService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    BaseSiteInitializer.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: BaseSiteInitializer, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: BaseSiteInitializer, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }], ctorParameters: function () { return [{ type: BaseSiteService }, { type: ConfigInitializerService }]; } });

    var CurrencyStatePersistenceService = /** @class */ (function () {
        function CurrencyStatePersistenceService(statePersistenceService, currencyService, config) {
            this.statePersistenceService = statePersistenceService;
            this.currencyService = currencyService;
            this.config = config;
            this.initialized$ = new rxjs.ReplaySubject(1);
        }
        CurrencyStatePersistenceService.prototype.initSync = function () {
            var _this = this;
            this.statePersistenceService.syncWithStorage({
                key: CURRENCY_CONTEXT_ID,
                state$: this.currencyService.getActive(),
                onRead: function (state) { return _this.onRead(state); },
            });
            return this.initialized$;
        };
        CurrencyStatePersistenceService.prototype.onRead = function (valueFromStorage) {
            if (!this.currencyService.isInitialized() && valueFromStorage) {
                this.currencyService.setActive(valueFromStorage);
            }
            if (!this.initialized$.closed) {
                this.initialized$.next();
                this.initialized$.complete();
            }
        };
        return CurrencyStatePersistenceService;
    }());
    CurrencyStatePersistenceService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CurrencyStatePersistenceService, deps: [{ token: StatePersistenceService }, { token: CurrencyService }, { token: SiteContextConfig }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    CurrencyStatePersistenceService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CurrencyStatePersistenceService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CurrencyStatePersistenceService, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }], ctorParameters: function () { return [{ type: StatePersistenceService }, { type: CurrencyService }, { type: SiteContextConfig }]; } });

    function configInitializerFactory(configInitializer, initializers) {
        var isReady = function () { return configInitializer.initialize(initializers); };
        return isReady;
    }
    function locationInitializedFactory(configInitializer) {
        return configInitializer.getStable().toPromise();
    }
    var ConfigInitializerModule = /** @class */ (function () {
        function ConfigInitializerModule() {
        }
        ConfigInitializerModule.forRoot = function () {
            return {
                ngModule: ConfigInitializerModule,
                providers: [
                    {
                        provide: CONFIG_INITIALIZER_FORROOT_GUARD,
                        useValue: true,
                    },
                    {
                        provide: i0.APP_INITIALIZER,
                        multi: true,
                        useFactory: configInitializerFactory,
                        deps: [
                            ConfigInitializerService,
                            [new i0.Optional(), CONFIG_INITIALIZER],
                        ],
                    },
                    {
                        // Hold on the initial navigation until the Spartacus configuration is stable
                        provide: i6.LOCATION_INITIALIZED,
                        useFactory: locationInitializedFactory,
                        deps: [ConfigInitializerService],
                    },
                ],
            };
        };
        return ConfigInitializerModule;
    }());
    ConfigInitializerModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ConfigInitializerModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    ConfigInitializerModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ConfigInitializerModule });
    ConfigInitializerModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ConfigInitializerModule });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ConfigInitializerModule, decorators: [{
                type: i0.NgModule,
                args: [{}]
            }] });

    function configValidatorFactory(configInitializer, validators) {
        var validate = function () {
            if (i0.isDevMode()) {
                configInitializer
                    .getStable()
                    .subscribe(function (config) { return validateConfig(config, validators || []); });
            }
        };
        return validate;
    }
    /**
     * Should stay private in 1.x
     * as forRoot() is used internally by ConfigInitializerModule
     *
     * issue: #5279
     */
    var ConfigValidatorModule = /** @class */ (function () {
        function ConfigValidatorModule() {
        }
        ConfigValidatorModule.forRoot = function () {
            return {
                ngModule: ConfigValidatorModule,
                providers: [
                    {
                        provide: i0.APP_INITIALIZER,
                        multi: true,
                        useFactory: configValidatorFactory,
                        deps: [
                            ConfigInitializerService,
                            [new i0.Optional(), ConfigValidatorToken],
                        ],
                    },
                ],
            };
        };
        return ConfigValidatorModule;
    }());
    ConfigValidatorModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ConfigValidatorModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    ConfigValidatorModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ConfigValidatorModule });
    ConfigValidatorModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ConfigValidatorModule });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ConfigValidatorModule, decorators: [{
                type: i0.NgModule
            }] });

    function isFeatureConfig(config) {
        return typeof config === 'object' && !!config.features;
    }
    function isInLevel(level, version) {
        if (level === '*') {
            return true;
        }
        var levelParts = level.split('.');
        var versionParts = version.split('.');
        for (var i = 0; i < versionParts.length; i++) {
            var versionNumberPart = Number(versionParts[i]);
            var levelNumberPart = Number(levelParts[i]) || 0;
            if (versionNumberPart !== levelNumberPart) {
                return levelNumberPart > versionNumberPart;
            }
        }
        return true;
    }
    function isFeatureLevel(config, level) {
        if (isFeatureConfig(config) && config.features.level) {
            return level.startsWith('!')
                ? !isInLevel(config.features.level, level.substr(1, level.length))
                : isInLevel(config.features.level, level);
        }
        return false;
    }
    function isFeatureEnabled(config, feature) {
        if (isFeatureConfig(config)) {
            var featureConfig = feature[0] === '!'
                ? config.features[feature.substr(1, feature.length)]
                : config.features[feature];
            var result = typeof featureConfig === 'string'
                ? isFeatureLevel(config, featureConfig)
                : featureConfig;
            return feature.startsWith('!') ? !result : !!result;
        }
        return false;
    }

    var FeaturesConfig = /** @class */ (function () {
        function FeaturesConfig() {
        }
        return FeaturesConfig;
    }());
    FeaturesConfig.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: FeaturesConfig, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    FeaturesConfig.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: FeaturesConfig, providedIn: 'root', useExisting: Config });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: FeaturesConfig, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                        useExisting: Config,
                    }]
            }] });

    var FeatureConfigService = /** @class */ (function () {
        function FeatureConfigService(config) {
            this.config = config;
        }
        FeatureConfigService.prototype.isLevel = function (version) {
            return isFeatureLevel(this.config, version);
        };
        FeatureConfigService.prototype.isEnabled = function (feature) {
            return isFeatureEnabled(this.config, feature);
        };
        return FeatureConfigService;
    }());
    FeatureConfigService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: FeatureConfigService, deps: [{ token: FeaturesConfig }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    FeatureConfigService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: FeatureConfigService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: FeatureConfigService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: FeaturesConfig }]; } });

    var FeatureLevelDirective = /** @class */ (function () {
        function FeatureLevelDirective(templateRef, viewContainer, featureConfig) {
            this.templateRef = templateRef;
            this.viewContainer = viewContainer;
            this.featureConfig = featureConfig;
            this.hasView = false;
        }
        Object.defineProperty(FeatureLevelDirective.prototype, "cxFeatureLevel", {
            set: function (level) {
                if (this.featureConfig.isLevel(level.toString()) && !this.hasView) {
                    this.viewContainer.createEmbeddedView(this.templateRef);
                    this.hasView = true;
                }
                else if (!this.featureConfig.isLevel(level.toString()) && this.hasView) {
                    this.viewContainer.clear();
                    this.hasView = false;
                }
            },
            enumerable: false,
            configurable: true
        });
        return FeatureLevelDirective;
    }());
    FeatureLevelDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: FeatureLevelDirective, deps: [{ token: i0__namespace.TemplateRef }, { token: i0__namespace.ViewContainerRef }, { token: FeatureConfigService }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    FeatureLevelDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.5", type: FeatureLevelDirective, selector: "[cxFeatureLevel]", inputs: { cxFeatureLevel: "cxFeatureLevel" }, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: FeatureLevelDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        selector: '[cxFeatureLevel]',
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.TemplateRef }, { type: i0__namespace.ViewContainerRef }, { type: FeatureConfigService }]; }, propDecorators: { cxFeatureLevel: [{
                    type: i0.Input
                }] } });

    var FeatureDirective = /** @class */ (function () {
        function FeatureDirective(templateRef, viewContainer, featureConfig) {
            this.templateRef = templateRef;
            this.viewContainer = viewContainer;
            this.featureConfig = featureConfig;
            this.hasView = false;
        }
        Object.defineProperty(FeatureDirective.prototype, "cxFeature", {
            set: function (feature) {
                if (this.featureConfig.isEnabled(feature) && !this.hasView) {
                    this.viewContainer.createEmbeddedView(this.templateRef);
                    this.hasView = true;
                }
                else if (!this.featureConfig.isEnabled(feature) && this.hasView) {
                    this.viewContainer.clear();
                    this.hasView = false;
                }
            },
            enumerable: false,
            configurable: true
        });
        return FeatureDirective;
    }());
    FeatureDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: FeatureDirective, deps: [{ token: i0__namespace.TemplateRef }, { token: i0__namespace.ViewContainerRef }, { token: FeatureConfigService }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    FeatureDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.5", type: FeatureDirective, selector: "[cxFeature]", inputs: { cxFeature: "cxFeature" }, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: FeatureDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        selector: '[cxFeature]',
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.TemplateRef }, { type: i0__namespace.ViewContainerRef }, { type: FeatureConfigService }]; }, propDecorators: { cxFeature: [{
                    type: i0.Input
                }] } });

    var FeaturesConfigModule = /** @class */ (function () {
        function FeaturesConfigModule() {
        }
        FeaturesConfigModule.forRoot = function (defaultLevel) {
            if (defaultLevel === void 0) { defaultLevel = '3.0'; }
            return {
                ngModule: FeaturesConfigModule,
                providers: [
                    provideDefaultConfig({
                        features: {
                            level: defaultLevel || '*',
                        },
                    }),
                ],
            };
        };
        return FeaturesConfigModule;
    }());
    FeaturesConfigModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: FeaturesConfigModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    FeaturesConfigModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: FeaturesConfigModule, declarations: [FeatureLevelDirective, FeatureDirective], exports: [FeatureLevelDirective, FeatureDirective] });
    FeaturesConfigModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: FeaturesConfigModule });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: FeaturesConfigModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        declarations: [FeatureLevelDirective, FeatureDirective],
                        exports: [FeatureLevelDirective, FeatureDirective],
                    }]
            }] });

    var NOT_FOUND_SYMBOL$1 = {};
    /**
     * CombinedInjector is able to combine more than one injector together.
     *
     * Can be used to instantiate lazy loaded modules with dependency modules,
     * so lazy loaded module can use instances provided in all dependency modules.
     *
     * Injector tries to resolve token in all Injector, taking into account the order
     * in which they were provided in complementaryInjectors and fallbacks to the
     * mainInjector.
     */
    var CombinedInjector = /** @class */ (function () {
        /**
         * @param mainInjector Component hierarchical injector
         * @param complementaryInjectors Additional injector that will be taken into an account when resolving dependencies
         */
        function CombinedInjector(mainInjector, complementaryInjectors) {
            this.mainInjector = mainInjector;
            this.complementaryInjectors = complementaryInjectors;
        }
        CombinedInjector.prototype.get = function (token, notFoundValue, flags) {
            var e_1, _a, e_2, _b;
            // eslint-disable-next-line no-bitwise
            if (flags & i0.InjectFlags.Self) {
                if (notFoundValue !== undefined) {
                    return notFoundValue;
                }
                throw new Error("CombinedInjector should be used as a parent injector / doesn't support self dependencies");
            }
            try {
                for (var _c = __values(this.complementaryInjectors), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var injector = _d.value;
                    // First we are resolving providers provided at Self level
                    // in all complementary injectors...
                    var service = injector.get(token, NOT_FOUND_SYMBOL$1, i0.InjectFlags.Self);
                    if (service !== NOT_FOUND_SYMBOL$1) {
                        return service;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_1) throw e_1.error; }
            }
            try {
                for (var _e = __values(this.complementaryInjectors), _f = _e.next(); !_f.done; _f = _e.next()) {
                    var injector = _f.value;
                    // next we try to resolve tokens from all levels
                    var service = injector.get(token, NOT_FOUND_SYMBOL$1);
                    if (service !== NOT_FOUND_SYMBOL$1) {
                        return service;
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                }
                finally { if (e_2) throw e_2.error; }
            }
            // ...and then fallback to main injector
            return this.mainInjector.get(token, notFoundValue);
        };
        return CombinedInjector;
    }());

    /**
     * Will be thrown in case lazy loaded modules are loaded and instantiated.
     *
     * This event is thrown for cms driven lazy loaded feature modules amd it's
     * dependencies
     */
    var ModuleInitializedEvent = /** @class */ (function (_super) {
        __extends(ModuleInitializedEvent, _super);
        function ModuleInitializedEvent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return ModuleInitializedEvent;
    }(CxEvent));
    /**
     * Event's type
     */
    ModuleInitializedEvent.type = 'ModuleInitializedEvent';

    /**
     * The MODULE_INITIALIZER is used as a multi provider that returns
     * a function that should be executed when the module is lazy loaded.
     * It is, in a way, an APP_INITIALIZER for lazy loaded modules.
     *
     * If the module is eagerly loaded, the MODULE_INITIALIZER functions
     * run when the app is initialized.  Therfore, if the module in which it is
     * defined is used in a eager loading configuration, MODULE_INITIALIZER
     * will fall back to work like APP_INITIALIZER.
     */
    var MODULE_INITIALIZER = new i0.InjectionToken('MODULE_INITIALIZER');

    /**
     * Utility service for managing dynamic imports of Angular services
     */
    var LazyModulesService = /** @class */ (function () {
        function LazyModulesService(compiler, injector, events) {
            this.compiler = compiler;
            this.injector = injector;
            this.events = events;
            /**
             * Expose lazy loaded module references
             */
            this.modules$ = this.events
                .get(ModuleInitializedEvent)
                .pipe(operators.map(function (event) { return event.moduleRef; }), operators.publishReplay());
            this.dependencyModules = new Map();
            this.eventSubscription = this.modules$.connect();
        }
        /**
         * Resolves module instance based dynamic import wrapped in an arrow function
         *
         * New module instance will be created with each call.
         *
         * @param moduleFunc
         * @param feature
         */
        LazyModulesService.prototype.resolveModuleInstance = function (moduleFunc, feature, dependencyModuleRefs) {
            var _this = this;
            if (dependencyModuleRefs === void 0) { dependencyModuleRefs = []; }
            var parentInjector;
            if (!dependencyModuleRefs.length) {
                parentInjector = this.injector;
            }
            else if (dependencyModuleRefs.length === 1) {
                parentInjector = dependencyModuleRefs[0].injector;
            }
            else {
                parentInjector = new CombinedInjector(this.injector, dependencyModuleRefs.map(function (moduleRef) { return moduleRef.injector; }));
            }
            return this.resolveModuleFactory(moduleFunc).pipe(operators.map(function (_a) {
                var _b = __read(_a, 1), moduleFactory = _b[0];
                return moduleFactory.create(parentInjector);
            }), operators.concatMap(function (moduleRef) { return _this.runModuleInitializersForModule(moduleRef); }), operators.tap(function (moduleRef) { return _this.events.dispatch(createFrom(ModuleInitializedEvent, {
                feature: feature,
                moduleRef: moduleRef,
            })); }));
        };
        /**
         * Returns dependency module instance and initializes it when needed.
         *
         * Module will be instantiated only once, at first request for a this specific module class
         */
        LazyModulesService.prototype.resolveDependencyModuleInstance = function (moduleFunc) {
            var _this = this;
            // We grab moduleFactory symbol from module function and if there is no
            // such a module created yet, we create it and store it in a
            // dependencyModules map
            return this.resolveModuleFactory(moduleFunc).pipe(operators.map(function (_a) {
                var _b = __read(_a, 2), moduleFactory = _b[0], module = _b[1];
                if (!_this.dependencyModules.has(module)) {
                    var moduleRef = moduleFactory.create(_this.injector);
                    _this.dependencyModules.set(module, moduleRef);
                }
                return _this.dependencyModules.get(module);
            }), operators.concatMap(function (moduleRef) { return _this.runModuleInitializersForModule(moduleRef); }), operators.tap(function (moduleRef) { return _this.events.dispatch(createFrom(ModuleInitializedEvent, {
                moduleRef: moduleRef,
            })); }));
        };
        /**
         * The purpose of this function is to run MODULE_INITIALIZER logic that can be provided
         * by a lazy loaded module.  The module is recieved as a function parameter.
         * This function returns an Observable to the module reference passed as an argument.
         *
         * @param {NgModuleRef<any>} moduleRef
         *
         * @returns {Observable<NgModuleRef<any>>}
         */
        LazyModulesService.prototype.runModuleInitializersForModule = function (moduleRef) {
            var moduleInits = moduleRef.injector.get(MODULE_INITIALIZER, [], i0.InjectFlags.Self);
            var asyncInitPromises = this.runModuleInitializerFunctions(moduleInits);
            if (asyncInitPromises.length) {
                return rxjs.from(Promise.all(asyncInitPromises)).pipe(operators.catchError(function (error) {
                    console.error('MODULE_INITIALIZER promise was rejected while lazy loading a module.', error);
                    return rxjs.throwError(error);
                }), operators.switchMapTo(rxjs.of(moduleRef)));
            }
            else {
                return rxjs.of(moduleRef);
            }
        };
        /**
         * This function accepts an array of functions and runs them all. For each function that returns a promise,
         * the resulting promise is stored in an array of promises.  That array of promises is returned.
         * It is not required for the functions to return a Promise.  All functions are run.  The return values
         * that are not a Promise are simply not stored and returned.
         *
         * @param {(() => any)[]} initFunctions An array of functions too be run.
         *
         * @return {Promise<any>[]} An array of Promise returned by the functions, if any,
         */
        LazyModulesService.prototype.runModuleInitializerFunctions = function (initFunctions) {
            var initPromises = [];
            try {
                if (initFunctions) {
                    for (var i = 0; i < initFunctions.length; i++) {
                        var initResult = initFunctions[i]();
                        if (this.isObjectPromise(initResult)) {
                            initPromises.push(initResult);
                        }
                    }
                }
                return initPromises;
            }
            catch (error) {
                console.error("MODULE_INITIALIZER init function throwed an error. ", error);
                throw error;
            }
        };
        /**
         * Determine if the argument is shaped like a Promise
         */
        LazyModulesService.prototype.isObjectPromise = function (obj) {
            return !!obj && typeof obj.then === 'function';
        };
        /**
         * Resolve any Angular module from an function that return module or moduleFactory
         */
        LazyModulesService.prototype.resolveModuleFactory = function (moduleFunc) {
            var _this = this;
            return rxjs.from(moduleFunc()).pipe(operators.switchMap(function (module) { return module instanceof i0.NgModuleFactory
                ? rxjs.of([module, module])
                : rxjs.combineLatest([
                    // using compiler here is for jit compatibility, there is no overhead
                    // for aot production builds as it will be stubbed
                    rxjs.from(_this.compiler.compileModuleAsync(module)),
                    rxjs.of(module),
                ]); }), operators.observeOn(rxjs.queueScheduler));
        };
        LazyModulesService.prototype.ngOnDestroy = function () {
            if (this.eventSubscription) {
                this.eventSubscription.unsubscribe();
            }
            // clean up all initialized dependency modules
            this.dependencyModules.forEach(function (dependency) { return dependency.destroy(); });
        };
        return LazyModulesService;
    }());
    LazyModulesService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: LazyModulesService, deps: [{ token: i0__namespace.Compiler }, { token: i0__namespace.Injector }, { token: EventService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    LazyModulesService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: LazyModulesService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: LazyModulesService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.Compiler }, { type: i0__namespace.Injector }, { type: EventService }]; } });

    var NOT_FOUND_SYMBOL = {};
    /**
     * UnifiedInjector provides a way to get instances of tokens not only once, from the root injector,
     * but also from lazy loaded module injectors that can be initialized over time.
     */
    var UnifiedInjector = /** @class */ (function () {
        function UnifiedInjector(rootInjector, lazyModules) {
            this.rootInjector = rootInjector;
            this.lazyModules = lazyModules;
            /**
             * Gather all the injectors, with the root injector as a first one
             *
             */
            this.injectors$ = this.lazyModules.modules$.pipe(operators.map(function (moduleRef) { return moduleRef.injector; }), operators.startWith(this.rootInjector));
        }
        /**
         * Gen instances for specified tokens.
         *
         * When notFoundValue is provided, it will consistently emit once per injector,
         * even if injector doesn't contain instances for specified token.
         * Otherwise, emissions will only involve cases, where new instances will be found.
         *
         * @param token
         * @param notFoundValue
         */
        UnifiedInjector.prototype.get = function (token, notFoundValue) {
            return this.injectors$.pipe(operators.map(function (injector, index) { return injector.get(token, notFoundValue !== null && notFoundValue !== void 0 ? notFoundValue : NOT_FOUND_SYMBOL, 
            // we want to get only Self instances from all injectors except the
            // first one, which is a root injector
            index ? i0.InjectFlags.Self : undefined); }), operators.filter(function (instance) { return instance !== NOT_FOUND_SYMBOL; }));
        };
        UnifiedInjector.prototype.getMulti = function (token) {
            return this.get(token, []).pipe(operators.filter(function (instances) {
                if (!Array.isArray(instances)) {
                    throw new Error("Multi-providers mixed with single providers for " + token.toString() + "!");
                }
                return instances.length > 0;
            }), operators.scan(function (acc, services) { return __spreadArray(__spreadArray([], __read(acc)), __read(services)); }, []));
        };
        return UnifiedInjector;
    }());
    UnifiedInjector.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UnifiedInjector, deps: [{ token: i0__namespace.Injector }, { token: LazyModulesService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    UnifiedInjector.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UnifiedInjector, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UnifiedInjector, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.Injector }, { type: LazyModulesService }]; } });

    var ConfigurationService = /** @class */ (function () {
        function ConfigurationService(rootConfig, defaultConfig, unifiedInjector, config) {
            this.rootConfig = rootConfig;
            this.defaultConfig = defaultConfig;
            this.unifiedInjector = unifiedInjector;
            this.ambientDefaultConfig = {};
            this.ambientConfig = {};
            this.config = config;
            this.unifiedConfig$ = new rxjs.BehaviorSubject(config);
            // We need to use subscription to propagate changes to the config from the beginning.
            // It will be possible to make it lazy, when we drop this compatibility feature
            // in the future.
            this.subscription = this.feedUnifiedConfig().subscribe();
        }
        ConfigurationService.prototype.feedUnifiedConfig = function () {
            var _this = this;
            var configChunks$ = this.unifiedInjector.get(ConfigChunk, []);
            var defaultConfigChunks$ = this.unifiedInjector.get(DefaultConfigChunk, []);
            return rxjs.zip(configChunks$, defaultConfigChunks$).pipe(
            // we don't need result from the root injector
            operators.skip(1), operators.tap(function (_a) {
                var _b = __read(_a, 2), configChunks = _b[0], defaultConfigChunks = _b[1];
                return _this.processConfig(configChunks, defaultConfigChunks);
            }));
        };
        ConfigurationService.prototype.processConfig = function (configChunks, defaultConfigChunks) {
            if (defaultConfigChunks === null || defaultConfigChunks === void 0 ? void 0 : defaultConfigChunks.length) {
                deepMerge.apply(void 0, __spreadArray([this.ambientDefaultConfig], __read(defaultConfigChunks)));
            }
            if (configChunks.length) {
                deepMerge.apply(void 0, __spreadArray([this.ambientConfig], __read(configChunks)));
            }
            if (configChunks.length || defaultConfigChunks.length) {
                this.emitUnifiedConfig();
            }
        };
        ConfigurationService.prototype.emitUnifiedConfig = function () {
            var newConfig = deepMerge({}, this.defaultConfig, this.ambientDefaultConfig, this.ambientConfig, this.rootConfig);
            this.unifiedConfig$.next(newConfig);
            // compatibility mechanism, can be disabled with feature toggle
            if (!isFeatureEnabled(this.config, 'disableConfigUpdates')) {
                deepMerge(this.config, newConfig);
            }
        };
        ConfigurationService.prototype.ngOnDestroy = function () {
            if (this.subscription) {
                this.subscription.unsubscribe();
            }
            this.unifiedConfig$.complete();
        };
        return ConfigurationService;
    }());
    ConfigurationService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ConfigurationService, deps: [{ token: RootConfig }, { token: DefaultConfig }, { token: UnifiedInjector }, { token: Config }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ConfigurationService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ConfigurationService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ConfigurationService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () {
            return [{ type: Config, decorators: [{
                            type: i0.Inject,
                            args: [RootConfig]
                        }] }, { type: Config, decorators: [{
                            type: i0.Inject,
                            args: [DefaultConfig]
                        }] }, { type: UnifiedInjector }, { type: Config }];
        } });

    var ConfigModule = /** @class */ (function () {
        // To make sure ConfigurationService will be instantiated, we inject it into
        // module constructor
        function ConfigModule(_configurationService) {
        }
        /**
         * Import ConfigModule and contribute config to the global configuration
         *
         * To provide default configuration in libraries provideDefaultConfig should be used instead.
         *
         * @param config Config object to merge with the global configuration
         */
        ConfigModule.withConfig = function (config) {
            return {
                ngModule: ConfigModule,
                providers: [provideConfig(config)],
            };
        };
        /**
         * Import ConfigModule and contribute config to the global configuration using factory function
         *
         * To provide default configuration in libraries provideDefaultConfigFactory should be used instead.
         *
         * @param configFactory Factory function that will generate configuration
         * @param deps Optional dependencies to factory function
         */
        ConfigModule.withConfigFactory = function (configFactory, deps) {
            return {
                ngModule: ConfigModule,
                providers: [provideConfigFactory(configFactory, deps)],
            };
        };
        /**
         * Module with providers, should be imported only once, if possible, at the root of the app.
         *
         * @param config
         */
        ConfigModule.forRoot = function (config) {
            if (config === void 0) { config = {}; }
            return {
                ngModule: ConfigModule,
                providers: [provideConfig(config)],
            };
        };
        return ConfigModule;
    }());
    ConfigModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ConfigModule, deps: [{ token: ConfigurationService }], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    ConfigModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ConfigModule });
    ConfigModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ConfigModule });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ConfigModule, decorators: [{
                type: i0.NgModule,
                args: [{}]
            }], ctorParameters: function () { return [{ type: ConfigurationService }]; } });

    function getCookie(cookie, name) {
        var regExp = new RegExp('(?:^|;\\s*)' + name + '=([^;]*)', 'g');
        var result = regExp.exec(cookie);
        return (result && decodeURIComponent(result[1])) || '';
    }

    var TEST_CONFIG_COOKIE_NAME = new i0.InjectionToken('TEST_CONFIG_COOKIE_NAME');
    function parseConfigJSON(config) {
        try {
            return JSON.parse(decodeURIComponent(config));
        }
        catch (_) {
            return {};
        }
    }
    function configFromCookieFactory(cookieName, platform, document) {
        if (i6.isPlatformBrowser(platform) && cookieName) {
            var config = getCookie(document.cookie, cookieName);
            return parseConfigJSON(config);
        }
        return {};
    }
    /**
     * Designed/intended to provide dynamic configuration for testing scenarios ONLY (e.g. e2e tests).
     *
     * CAUTION: DON'T USE IT IN PRODUCTION! IT HASN'T BEEN REVIEWED FOR SECURITY ISSUES.
     */
    var TestConfigModule = /** @class */ (function () {
        function TestConfigModule() {
        }
        /**
         * Injects JSON config from the cookie of the given name.
         *
         * Be aware of the cookie limitations (4096 bytes).
         *
         * CAUTION: DON'T USE IT IN PRODUCTION! IT HASN'T BEEN REVIEWED FOR SECURITY ISSUES.
         */
        TestConfigModule.forRoot = function (options) {
            return {
                ngModule: TestConfigModule,
                providers: [
                    {
                        provide: TEST_CONFIG_COOKIE_NAME,
                        useValue: options && options.cookie,
                    },
                    provideConfigFactory(configFromCookieFactory, [
                        TEST_CONFIG_COOKIE_NAME,
                        i0.PLATFORM_ID,
                        i6.DOCUMENT,
                    ]),
                ],
            };
        };
        return TestConfigModule;
    }());
    TestConfigModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: TestConfigModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    TestConfigModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: TestConfigModule });
    TestConfigModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: TestConfigModule });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: TestConfigModule, decorators: [{
                type: i0.NgModule,
                args: [{}]
            }] });

    var CurrencyInitializer = /** @class */ (function () {
        function CurrencyInitializer(currencyService, currencyStatePersistenceService, configInit) {
            this.currencyService = currencyService;
            this.currencyStatePersistenceService = currencyStatePersistenceService;
            this.configInit = configInit;
        }
        /**
         * Initializes the value of the active currency.
         */
        CurrencyInitializer.prototype.initialize = function () {
            var _this = this;
            this.subscription = this.configInit
                .getStable('context')
                .pipe(
            // TODO(#12351): <--- plug here explicitly SiteContextRoutesHandler
            operators.switchMap(function () { return _this.currencyStatePersistenceService.initSync(); }), operators.switchMap(function () { return _this.setFallbackValue(); }))
                .subscribe();
        };
        /**
         * On subscription to the returned observable:
         *
         * Sets the default value taken from config, unless the active currency has been already initialized.
         */
        CurrencyInitializer.prototype.setFallbackValue = function () {
            var _this = this;
            return this.configInit
                .getStable('context')
                .pipe(operators.tap(function (config) { return _this.setDefaultFromConfig(config); }));
        };
        /**
         * Sets the active currency value based on the default value from the config,
         * unless the active currency has been already initialized.
         */
        CurrencyInitializer.prototype.setDefaultFromConfig = function (config) {
            if (!this.currencyService.isInitialized()) {
                this.currencyService.setActive(getContextParameterDefault(config, CURRENCY_CONTEXT_ID));
            }
        };
        CurrencyInitializer.prototype.ngOnDestroy = function () {
            var _a;
            (_a = this.subscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();
        };
        return CurrencyInitializer;
    }());
    CurrencyInitializer.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CurrencyInitializer, deps: [{ token: CurrencyService }, { token: CurrencyStatePersistenceService }, { token: ConfigInitializerService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    CurrencyInitializer.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CurrencyInitializer, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CurrencyInitializer, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }], ctorParameters: function () { return [{ type: CurrencyService }, { type: CurrencyStatePersistenceService }, { type: ConfigInitializerService }]; } });

    var LanguageStatePersistenceService = /** @class */ (function () {
        function LanguageStatePersistenceService(statePersistenceService, languageService, config) {
            this.statePersistenceService = statePersistenceService;
            this.languageService = languageService;
            this.config = config;
            this.initialized$ = new rxjs.ReplaySubject(1);
        }
        /**
         * Initializes the synchronization of the active language with the local storage.
         *
         * @returns Observable that emits and completes when the value is read from the storage.
         */
        LanguageStatePersistenceService.prototype.initSync = function () {
            var _this = this;
            this.statePersistenceService.syncWithStorage({
                key: LANGUAGE_CONTEXT_ID,
                state$: this.languageService.getActive(),
                onRead: function (state) { return _this.onRead(state); },
            });
            return this.initialized$;
        };
        LanguageStatePersistenceService.prototype.onRead = function (valueFromStorage) {
            if (!this.languageService.isInitialized() && valueFromStorage) {
                this.languageService.setActive(valueFromStorage);
            }
            if (!this.initialized$.closed) {
                this.initialized$.next();
                this.initialized$.complete();
            }
        };
        return LanguageStatePersistenceService;
    }());
    LanguageStatePersistenceService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: LanguageStatePersistenceService, deps: [{ token: StatePersistenceService }, { token: LanguageService }, { token: SiteContextConfig }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    LanguageStatePersistenceService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: LanguageStatePersistenceService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: LanguageStatePersistenceService, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }], ctorParameters: function () { return [{ type: StatePersistenceService }, { type: LanguageService }, { type: SiteContextConfig }]; } });

    var LanguageInitializer = /** @class */ (function () {
        function LanguageInitializer(languageService, languageStatePersistenceService, configInit) {
            this.languageService = languageService;
            this.languageStatePersistenceService = languageStatePersistenceService;
            this.configInit = configInit;
        }
        /**
         * Initializes the value of the active language.
         */
        LanguageInitializer.prototype.initialize = function () {
            var _this = this;
            this.subscription = this.configInit
                .getStable('context')
                .pipe(
            // TODO(#12351): <--- plug here explicitly SiteContextRoutesHandler
            operators.switchMap(function () { return _this.languageStatePersistenceService.initSync(); }), operators.switchMap(function () { return _this.setFallbackValue(); }))
                .subscribe();
        };
        /**
         * On subscription to the returned observable:
         *
         * Sets the default value taken from config, unless the active language has been already initialized.
         */
        LanguageInitializer.prototype.setFallbackValue = function () {
            var _this = this;
            return this.configInit
                .getStable('context')
                .pipe(operators.tap(function (config) { return _this.setDefaultFromConfig(config); }));
        };
        /**
         * Sets the active language value based on the default value from the config,
         * unless the active language has been already initialized.
         */
        LanguageInitializer.prototype.setDefaultFromConfig = function (config) {
            if (!this.languageService.isInitialized()) {
                this.languageService.setActive(getContextParameterDefault(config, LANGUAGE_CONTEXT_ID));
            }
        };
        LanguageInitializer.prototype.ngOnDestroy = function () {
            var _a;
            (_a = this.subscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();
        };
        return LanguageInitializer;
    }());
    LanguageInitializer.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: LanguageInitializer, deps: [{ token: LanguageService }, { token: LanguageStatePersistenceService }, { token: ConfigInitializerService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    LanguageInitializer.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: LanguageInitializer, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: LanguageInitializer, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }], ctorParameters: function () { return [{ type: LanguageService }, { type: LanguageStatePersistenceService }, { type: ConfigInitializerService }]; } });

    var SiteContextParamsService = /** @class */ (function () {
        function SiteContextParamsService(config, injector, serviceMap) {
            this.config = config;
            this.injector = injector;
            this.serviceMap = serviceMap;
        }
        SiteContextParamsService.prototype.getContextParameters = function () {
            if (this.config.context) {
                return Object.keys(this.config.context).filter(function (param) { return param !== 'urlParameters'; });
            }
            return [];
        };
        SiteContextParamsService.prototype.getUrlEncodingParameters = function () {
            return (this.config.context && this.config.context.urlParameters) || [];
        };
        SiteContextParamsService.prototype.getParamValues = function (param) {
            return getContextParameterValues(this.config, param);
        };
        SiteContextParamsService.prototype.getParamDefaultValue = function (param) {
            return getContextParameterDefault(this.config, param);
        };
        SiteContextParamsService.prototype.getSiteContextService = function (param) {
            if (this.serviceMap[param]) {
                try {
                    return this.injector.get(this.serviceMap[param]);
                }
                catch (_a) {
                    if (i0.isDevMode()) {
                        console.warn("Couldn't find site context service for '" + param + "'.");
                    }
                    return undefined;
                }
            }
        };
        SiteContextParamsService.prototype.getValue = function (param) {
            var value;
            var service = this.getSiteContextService(param);
            if (service) {
                service
                    .getActive()
                    .subscribe(function (val) { return (value = val); })
                    .unsubscribe();
            }
            return value !== undefined ? value : this.getParamDefaultValue(param);
        };
        SiteContextParamsService.prototype.setValue = function (param, value) {
            var service = this.getSiteContextService(param);
            if (service) {
                service.setActive(value);
            }
        };
        /**
         * Get active values for all provided context parameters
         *
         * @param params Context parameters
         *
         * @returns Observable emitting array of all passed active context values
         */
        SiteContextParamsService.prototype.getValues = function (params) {
            var _this = this;
            if (params.length === 0) {
                return rxjs.of([]);
            }
            return rxjs.combineLatest(params.map(function (param) {
                var service = _this.getSiteContextService(param);
                if (service) {
                    return service.getActive().pipe(operators.distinctUntilChanged());
                }
                return rxjs.of('');
            })).pipe(operators.filter(function (value) { return value.every(function (param) { return !!param; }); }));
        };
        return SiteContextParamsService;
    }());
    SiteContextParamsService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SiteContextParamsService, deps: [{ token: SiteContextConfig }, { token: i0__namespace.Injector }, { token: ContextServiceMap }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    SiteContextParamsService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SiteContextParamsService });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SiteContextParamsService, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: SiteContextConfig }, { type: i0__namespace.Injector }, { type: ContextServiceMap }]; } });

    /**
     * Angular URL Serializer aware of Spartacus site context parameters
     * encoded in the URL.
     */
    var SiteContextUrlSerializer = /** @class */ (function (_super) {
        __extends(SiteContextUrlSerializer, _super);
        function SiteContextUrlSerializer(siteContextParams) {
            var _this = _super.call(this) || this;
            _this.siteContextParams = siteContextParams;
            /**
             * Splits the URL into 2 parts: path and the query/fragment part
             */
            _this.URL_SPLIT = /(^[^#?]*)(.*)/;
            return _this;
        }
        Object.defineProperty(SiteContextUrlSerializer.prototype, "urlEncodingParameters", {
            /**
             * Names of site context parameters encoded in the URL
             */
            get: function () {
                return this.siteContextParams.getUrlEncodingParameters();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(SiteContextUrlSerializer.prototype, "hasContextInRoutes", {
            /**
             * Tells whether any site context parameters should be encoded in the URL
             */
            get: function () {
                return this.urlEncodingParameters.length > 0;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @override Recognizes the site context parameters encoded in the prefix segments
         * of the given URL.
         *
         * It returns the UrlTree for the given URL shortened by the recognized params, but saves
         * the params' values in the custom property of UrlTree: `siteContext`.
         */
        SiteContextUrlSerializer.prototype.parse = function (url) {
            if (this.hasContextInRoutes) {
                var urlWithParams = this.urlExtractContextParameters(url);
                var parsed = _super.prototype.parse.call(this, urlWithParams.url);
                this.urlTreeIncludeContextParameters(parsed, urlWithParams.params);
                return parsed;
            }
            else {
                return _super.prototype.parse.call(this, url);
            }
        };
        /**
         * Recognizes the site context parameters encoded in the prefix segments of the given URL.
         *
         * It returns the recognized site context params as well as the
         * URL shortened by the recognized params.
         */
        SiteContextUrlSerializer.prototype.urlExtractContextParameters = function (url) {
            var _a = __read(url.match(this.URL_SPLIT), 3), urlPart = _a[1], queryPart = _a[2];
            var segments = urlPart.split('/');
            if (segments[0] === '') {
                segments.shift();
            }
            var params = {};
            var paramId = 0;
            var segmentId = 0;
            while (paramId < this.urlEncodingParameters.length &&
                segmentId < segments.length) {
                var paramName = this.urlEncodingParameters[paramId];
                var paramValues = this.siteContextParams.getParamValues(paramName);
                if (paramValues.includes(segments[segmentId])) {
                    params[paramName] = segments[segmentId];
                    segmentId++;
                }
                paramId++;
            }
            url = segments.slice(segmentId).join('/') + queryPart;
            return { url: url, params: params };
        };
        /**
         * Saves the given site context parameters in the custom property
         * of the given UrlTree: `siteContext`.
         */
        SiteContextUrlSerializer.prototype.urlTreeIncludeContextParameters = function (urlTree, params) {
            urlTree.siteContext = params;
        };
        /**
         * @override Serializes the given UrlTree to a string and prepends
         *  to it the current values of the site context parameters.
         */
        SiteContextUrlSerializer.prototype.serialize = function (tree) {
            var params = this.urlTreeExtractContextParameters(tree);
            var url = _super.prototype.serialize.call(this, tree);
            var serialized = this.urlIncludeContextParameters(url, params);
            return serialized;
        };
        /**
         * Returns the site context parameters stored in the custom property
         * of the UrlTree: `siteContext`.
         */
        SiteContextUrlSerializer.prototype.urlTreeExtractContextParameters = function (urlTree) {
            return urlTree.siteContext ? urlTree.siteContext : {};
        };
        /**
         * Prepends the current values of the site context parameters to the given URL.
         */
        SiteContextUrlSerializer.prototype.urlIncludeContextParameters = function (url, params) {
            var _this = this;
            var contextRoutePart = this.urlEncodingParameters
                .map(function (param) {
                return params[param]
                    ? params[param]
                    : _this.siteContextParams.getValue(param);
            })
                .join('/');
            return contextRoutePart + url;
        };
        return SiteContextUrlSerializer;
    }(i1$2.DefaultUrlSerializer));
    SiteContextUrlSerializer.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SiteContextUrlSerializer, deps: [{ token: SiteContextParamsService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    SiteContextUrlSerializer.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SiteContextUrlSerializer });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SiteContextUrlSerializer, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: SiteContextParamsService }]; } });

    function baseSiteConfigValidator(config) {
        if (getContextParameterDefault(config, BASE_SITE_CONTEXT_ID) === undefined) {
            return 'Please configure context.parameters.baseSite before using storefront library!';
        }
    }

    function defaultSiteContextConfigFactory() {
        var _a;
        return {
            context: (_a = {},
                _a[LANGUAGE_CONTEXT_ID] = [
                    'en',
                    'de',
                    'ja',
                    'zh',
                    'ru',
                    'fr',
                    'tr',
                    'it',
                    'es',
                    'uk',
                    'pl',
                    'nl',
                    'hi',
                    'ar',
                    'pt',
                    'bn',
                    'pa',
                ],
                _a[CURRENCY_CONTEXT_ID] = [
                    'USD',
                    'EUR',
                    'JPY',
                    'GBP',
                    'AUD',
                    'CAD',
                    'CHF',
                    'CNY',
                    'SEK',
                    'NZD',
                    'MXN',
                    'SGD',
                    'HKD',
                    'NOK',
                    'KRW',
                    'TRY',
                    'RUB',
                    'INR',
                    'BRL',
                    'ZAR',
                ],
                _a),
        };
    }

    function initializeCurrency(currencyInitializer) {
        var result = function () {
            currencyInitializer.initialize();
        };
        return result;
    }
    function initializeLanguage(languageInitializer) {
        var result = function () {
            languageInitializer.initialize();
        };
        return result;
    }
    function initializeBaseSite(baseSiteInitializer) {
        var result = function () {
            baseSiteInitializer.initialize();
        };
        return result;
    }
    var contextInitializerProviders = [
        {
            provide: i0.APP_INITIALIZER,
            useFactory: initializeLanguage,
            deps: [LanguageInitializer],
            multi: true,
        },
        {
            provide: i0.APP_INITIALIZER,
            useFactory: initializeCurrency,
            deps: [CurrencyInitializer],
            multi: true,
        },
        {
            provide: i0.APP_INITIALIZER,
            useFactory: initializeBaseSite,
            deps: [BaseSiteInitializer],
            multi: true,
        },
    ];

    // PRIVATE API
    var SiteContextRoutesHandler = /** @class */ (function () {
        function SiteContextRoutesHandler(siteContextParams, serializer, injector) {
            this.siteContextParams = siteContextParams;
            this.serializer = serializer;
            this.injector = injector;
            this.subscription = new rxjs.Subscription();
            this.contextValues = {};
            /**
             * Tells whether there is a pending navigation at the moment, so we can avoid an infinite loop caused by the cyclic dependency:
             * - `subscribeChanges` method triggers a navigation on update of site context state
             * - `subscribeRouting` method updates the site context state on navigation
             */
            this.isNavigating = false;
        }
        /**
         * Initializes the two-way synchronization between the site context state and the URL.
         */
        SiteContextRoutesHandler.prototype.init = function () {
            this.router = this.injector.get(i1$2.Router);
            this.location = this.injector.get(i6.Location);
            var routingParams = this.siteContextParams.getUrlEncodingParameters();
            if (routingParams.length) {
                this.setContextParamsFromRoute(this.location.path(true));
                this.subscribeChanges(routingParams);
                this.subscribeRouting();
            }
        };
        /**
         * After each change of the site context state, it modifies the current URL in place.
         * But it happens only for the parameters configured to be persisted in the URL.
         */
        SiteContextRoutesHandler.prototype.subscribeChanges = function (params) {
            var _this = this;
            params.forEach(function (param) {
                var service = _this.siteContextParams.getSiteContextService(param);
                if (service) {
                    _this.subscription.add(service.getActive().subscribe(function (value) {
                        if (!_this.isNavigating &&
                            _this.contextValues[param] &&
                            _this.contextValues[param] !== value) {
                            var parsed = _this.router.parseUrl(_this.router.url);
                            var serialized = _this.router.serializeUrl(parsed);
                            _this.location.replaceState(serialized);
                        }
                        _this.contextValues[param] = value;
                    }));
                }
            });
        };
        /**
         * After each Angular NavigationStart event it updates the site context state based on
         * site context params encoded in the anticipated URL.
         */
        SiteContextRoutesHandler.prototype.subscribeRouting = function () {
            var _this = this;
            this.subscription.add(this.router.events
                .pipe(operators.filter(function (event) { return event instanceof i1$2.NavigationStart ||
                event instanceof i1$2.NavigationEnd ||
                event instanceof i1$2.NavigationError ||
                event instanceof i1$2.NavigationCancel; }))
                .subscribe(function (event) {
                _this.isNavigating = event instanceof i1$2.NavigationStart;
                if (_this.isNavigating) {
                    _this.setContextParamsFromRoute(event.url);
                }
            }));
        };
        /**
         * Updates the site context state based on the context params encoded in the given URL
         *
         * @param url URL with encoded context params
         */
        SiteContextRoutesHandler.prototype.setContextParamsFromRoute = function (url) {
            var _this = this;
            var params = this.serializer.urlExtractContextParameters(url).params;
            Object.keys(params).forEach(function (param) { return _this.siteContextParams.setValue(param, params[param]); });
        };
        SiteContextRoutesHandler.prototype.ngOnDestroy = function () {
            this.subscription.unsubscribe();
        };
        return SiteContextRoutesHandler;
    }());
    SiteContextRoutesHandler.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SiteContextRoutesHandler, deps: [{ token: SiteContextParamsService }, { token: SiteContextUrlSerializer }, { token: i0__namespace.Injector }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    SiteContextRoutesHandler.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SiteContextRoutesHandler, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SiteContextRoutesHandler, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: SiteContextParamsService }, { type: SiteContextUrlSerializer }, { type: i0__namespace.Injector }]; } });

    function initializeContext(configInit, siteContextRoutesHandler) {
        return function () {
            return configInit
                .getStable('context')
                .pipe(operators.tap(function () {
                // `siteContextRoutesHandler.init()` should be executed before CurrencyInitializer,
                // LanguageInitializer and BaseSiteInitializer
                // (now it's the case, thanks to the order of providers for APP_INITIALIZER).
                //
                // TODO(#12351): move it to the logic of specific context initializers
                siteContextRoutesHandler.init();
            }))
                .toPromise();
        };
    }
    var contextServiceProviders = [
        BaseSiteService,
        LanguageService,
        CurrencyService,
        {
            provide: i0.APP_INITIALIZER,
            useFactory: initializeContext,
            deps: [ConfigInitializerService, SiteContextRoutesHandler],
            multi: true,
        },
    ];

    // functions below should not be exposed in public API:
    var siteContextParamsProviders = [
        SiteContextParamsService,
        SiteContextUrlSerializer,
        { provide: i1$2.UrlSerializer, useExisting: SiteContextUrlSerializer },
    ];

    var BaseSiteEffects = /** @class */ (function () {
        function BaseSiteEffects(actions$, siteConnector) {
            var _this = this;
            this.actions$ = actions$;
            this.siteConnector = siteConnector;
            this.loadBaseSite$ = this.actions$.pipe(i1$4.ofType(LOAD_BASE_SITE), operators.exhaustMap(function () {
                return _this.siteConnector.getBaseSite().pipe(operators.map(function (baseSite) { return new LoadBaseSiteSuccess(baseSite); }), operators.catchError(function (error) { return rxjs.of(new LoadBaseSiteFail(normalizeHttpError(error))); }));
            }));
            this.loadBaseSites$ = this.actions$.pipe(i1$4.ofType(LOAD_BASE_SITES), operators.exhaustMap(function () {
                return _this.siteConnector.getBaseSites().pipe(operators.map(function (baseSites) { return new LoadBaseSitesSuccess(baseSites); }), operators.catchError(function (error) { return rxjs.of(new LoadBaseSitesFail(normalizeHttpError(error))); }));
            }));
        }
        return BaseSiteEffects;
    }());
    BaseSiteEffects.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: BaseSiteEffects, deps: [{ token: i1__namespace$4.Actions }, { token: SiteConnector }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    BaseSiteEffects.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: BaseSiteEffects });
    __decorate([
        i1$4.Effect()
    ], BaseSiteEffects.prototype, "loadBaseSite$", void 0);
    __decorate([
        i1$4.Effect()
    ], BaseSiteEffects.prototype, "loadBaseSites$", void 0);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: BaseSiteEffects, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: i1__namespace$4.Actions }, { type: SiteConnector }]; }, propDecorators: { loadBaseSite$: [], loadBaseSites$: [] } });

    var CurrenciesEffects = /** @class */ (function () {
        function CurrenciesEffects(actions$, siteConnector, state) {
            var _this = this;
            this.actions$ = actions$;
            this.siteConnector = siteConnector;
            this.state = state;
            this.loadCurrencies$ = this.actions$.pipe(i1$4.ofType(LOAD_CURRENCIES), operators.exhaustMap(function () {
                return _this.siteConnector.getCurrencies().pipe(operators.map(function (currencies) { return new LoadCurrenciesSuccess(currencies); }), operators.catchError(function (error) { return rxjs.of(new LoadCurrenciesFail(normalizeHttpError(error))); }));
            }));
            this.activateCurrency$ = this.state
                .select(getActiveCurrency)
                .pipe(operators.bufferCount(2, 1), 
            // avoid dispatching `change` action when we're just setting the initial value:
            operators.filter(function (_a) {
                var _b = __read(_a, 1), previous = _b[0];
                return !!previous;
            }), operators.map(function (_a) {
                var _b = __read(_a, 2), previous = _b[0], current = _b[1];
                return new CurrencyChange({ previous: previous, current: current });
            }));
        }
        return CurrenciesEffects;
    }());
    CurrenciesEffects.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CurrenciesEffects, deps: [{ token: i1__namespace$4.Actions }, { token: SiteConnector }, { token: i1__namespace$2.Store }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    CurrenciesEffects.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CurrenciesEffects });
    __decorate([
        i1$4.Effect()
    ], CurrenciesEffects.prototype, "loadCurrencies$", void 0);
    __decorate([
        i1$4.Effect()
    ], CurrenciesEffects.prototype, "activateCurrency$", void 0);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CurrenciesEffects, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: i1__namespace$4.Actions }, { type: SiteConnector }, { type: i1__namespace$2.Store }]; }, propDecorators: { loadCurrencies$: [], activateCurrency$: [] } });

    var LanguagesEffects = /** @class */ (function () {
        function LanguagesEffects(actions$, siteConnector, state) {
            var _this = this;
            this.actions$ = actions$;
            this.siteConnector = siteConnector;
            this.state = state;
            this.loadLanguages$ = this.actions$.pipe(i1$4.ofType(LOAD_LANGUAGES), operators.exhaustMap(function () {
                return _this.siteConnector.getLanguages().pipe(operators.map(function (languages) { return new LoadLanguagesSuccess(languages); }), operators.catchError(function (error) { return rxjs.of(new LoadLanguagesFail(normalizeHttpError(error))); }));
            }));
            this.activateLanguage$ = this.state
                .select(getActiveLanguage)
                .pipe(operators.bufferCount(2, 1), 
            // avoid dispatching `change` action when we're just setting the initial value:
            operators.filter(function (_a) {
                var _b = __read(_a, 1), previous = _b[0];
                return !!previous;
            }), operators.map(function (_a) {
                var _b = __read(_a, 2), previous = _b[0], current = _b[1];
                return new LanguageChange({ previous: previous, current: current });
            }));
        }
        return LanguagesEffects;
    }());
    LanguagesEffects.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: LanguagesEffects, deps: [{ token: i1__namespace$4.Actions }, { token: SiteConnector }, { token: i1__namespace$2.Store }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    LanguagesEffects.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: LanguagesEffects });
    __decorate([
        i1$4.Effect()
    ], LanguagesEffects.prototype, "loadLanguages$", void 0);
    __decorate([
        i1$4.Effect()
    ], LanguagesEffects.prototype, "activateLanguage$", void 0);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: LanguagesEffects, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: i1__namespace$4.Actions }, { type: SiteConnector }, { type: i1__namespace$2.Store }]; }, propDecorators: { loadLanguages$: [], activateLanguage$: [] } });

    var effects$4 = [
        LanguagesEffects,
        CurrenciesEffects,
        BaseSiteEffects,
    ];

    var initialState$u = {
        entities: null,
        details: {},
        activeSite: '',
    };
    function reducer$u(state, action) {
        if (state === void 0) { state = initialState$u; }
        switch (action.type) {
            case LOAD_BASE_SITE_SUCCESS: {
                return Object.assign(Object.assign({}, state), { details: action.payload });
            }
            case SET_ACTIVE_BASE_SITE: {
                // if active base site is updated,
                // the active base site details data should also be updated
                var details = {};
                if (state.entities) {
                    details = state.entities[action.payload];
                }
                return Object.assign(Object.assign({}, state), { details: details, activeSite: action.payload });
            }
            case LOAD_BASE_SITES_SUCCESS: {
                var sites = action.payload;
                var entities = sites.reduce(function (siteEntities, site) {
                    var _a;
                    return Object.assign(Object.assign({}, siteEntities), (_a = {}, _a[site.uid] = site, _a));
                }, Object.assign({}, state.entities));
                // after base sites entities are populated,
                // the active base site details data is also populated
                var details = entities[state.activeSite];
                return Object.assign(Object.assign({}, state), { details: details,
                    entities: entities });
            }
        }
        return state;
    }

    var initialState$t = {
        entities: null,
        activeCurrency: null,
    };
    function reducer$t(state, action) {
        if (state === void 0) { state = initialState$t; }
        switch (action.type) {
            case LOAD_CURRENCIES_SUCCESS: {
                var currencies = action.payload;
                var entities = currencies.reduce(function (currEntities, currency) {
                    var _a;
                    return Object.assign(Object.assign({}, currEntities), (_a = {}, _a[currency.isocode] = currency, _a));
                }, Object.assign({}, state.entities));
                return Object.assign(Object.assign({}, state), { entities: entities });
            }
            case SET_ACTIVE_CURRENCY: {
                var isocode = action.payload;
                return Object.assign(Object.assign({}, state), { activeCurrency: isocode });
            }
        }
        return state;
    }

    var initialState$s = {
        entities: null,
        activeLanguage: null,
    };
    function reducer$s(state, action) {
        if (state === void 0) { state = initialState$s; }
        switch (action.type) {
            case LOAD_LANGUAGES_SUCCESS: {
                var languages = action.payload;
                var entities = languages.reduce(function (langEntities, language) {
                    var _a;
                    return Object.assign(Object.assign({}, langEntities), (_a = {}, _a[language.isocode] = language, _a));
                }, Object.assign({}, state.entities));
                return Object.assign(Object.assign({}, state), { entities: entities });
            }
            case SET_ACTIVE_LANGUAGE: {
                var isocode = action.payload;
                return Object.assign(Object.assign({}, state), { activeLanguage: isocode });
            }
        }
        return state;
    }

    function getReducers$7() {
        return {
            languages: reducer$s,
            currencies: reducer$t,
            baseSite: reducer$u,
        };
    }
    var reducerToken$7 = new i0.InjectionToken('SiteContextReducers');
    var reducerProvider$7 = {
        provide: reducerToken$7,
        useFactory: getReducers$7,
    };

    function siteContextStoreConfigFactory() {
        var _a;
        // if we want to reuse SITE_CONTEXT_FEATURE const in config, we have to use factory instead of plain object
        var config = {
            state: {
                ssrTransfer: {
                    keys: (_a = {}, _a[SITE_CONTEXT_FEATURE] = exports.StateTransferType.TRANSFER_STATE, _a),
                },
            },
        };
        return config;
    }
    var SiteContextStoreModule = /** @class */ (function () {
        function SiteContextStoreModule() {
        }
        return SiteContextStoreModule;
    }());
    SiteContextStoreModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SiteContextStoreModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    SiteContextStoreModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SiteContextStoreModule, imports: [i6.CommonModule, i1__namespace$2.StoreFeatureModule, i1__namespace$4.EffectsFeatureModule] });
    SiteContextStoreModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SiteContextStoreModule, providers: [
            provideDefaultConfigFactory(siteContextStoreConfigFactory),
            reducerProvider$7,
        ], imports: [[
                i6.CommonModule,
                i1.StoreModule.forFeature(SITE_CONTEXT_FEATURE, reducerToken$7),
                i1$4.EffectsModule.forFeature(effects$4),
            ]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SiteContextStoreModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [
                            i6.CommonModule,
                            i1.StoreModule.forFeature(SITE_CONTEXT_FEATURE, reducerToken$7),
                            i1$4.EffectsModule.forFeature(effects$4),
                        ],
                        providers: [
                            provideDefaultConfigFactory(siteContextStoreConfigFactory),
                            reducerProvider$7,
                        ],
                    }]
            }] });

    /**
     * Initializes the site context config
     */
    function initSiteContextConfig(configInitializer, config) {
        /**
         * Load config for `context` from backend only when there is no static config for `context.baseSite`
         */
        if (!config.context || !config.context[BASE_SITE_CONTEXT_ID]) {
            return configInitializer;
        }
        return null;
    }
    var SiteContextModule = /** @class */ (function () {
        function SiteContextModule() {
        }
        SiteContextModule.forRoot = function () {
            return {
                ngModule: SiteContextModule,
                providers: __spreadArray(__spreadArray(__spreadArray(__spreadArray([
                    provideDefaultConfigFactory(defaultSiteContextConfigFactory),
                    contextServiceMapProvider
                ], __read(contextServiceProviders)), __read(siteContextParamsProviders)), [
                    provideConfigValidator(baseSiteConfigValidator),
                    {
                        provide: CONFIG_INITIALIZER,
                        useFactory: initSiteContextConfig,
                        deps: [SiteContextConfigInitializer, SiteContextConfig],
                        multi: true,
                    }
                ]), __read(contextInitializerProviders)),
            };
        };
        return SiteContextModule;
    }());
    SiteContextModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SiteContextModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    SiteContextModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SiteContextModule, imports: [StateModule, SiteContextStoreModule, SiteContextEventModule] });
    SiteContextModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SiteContextModule, imports: [[StateModule, SiteContextStoreModule, SiteContextEventModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SiteContextModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [StateModule, SiteContextStoreModule, SiteContextEventModule],
                    }]
            }] });

    var initialState$r = false;
    function reducer$r(state, action) {
        if (state === void 0) { state = initialState$r; }
        switch (action.type) {
            case TOGGLE_ANONYMOUS_CONSENTS_BANNER_DISMISSED: {
                return action.dismissed;
            }
        }
        return state;
    }

    var initialState$q = false;
    function reducer$q(state, action) {
        if (state === void 0) { state = initialState$q; }
        switch (action.type) {
            case TOGGLE_ANONYMOUS_CONSENT_TEMPLATES_UPDATED: {
                return action.updated;
            }
        }
        return state;
    }

    var initialState$p = [];
    function toggleConsentStatus(consents, templateCode, status) {
        if (!consents) {
            return [];
        }
        return consents.map(function (consent) {
            if (consent.templateCode === templateCode) {
                consent = Object.assign(Object.assign({}, consent), { consentState: status });
            }
            return consent;
        });
    }
    function reducer$p(state, action) {
        if (state === void 0) { state = initialState$p; }
        switch (action.type) {
            case GIVE_ANONYMOUS_CONSENT: {
                return toggleConsentStatus(state, action.templateCode, exports.ANONYMOUS_CONSENT_STATUS.GIVEN);
            }
            case WITHDRAW_ANONYMOUS_CONSENT: {
                return toggleConsentStatus(state, action.templateCode, exports.ANONYMOUS_CONSENT_STATUS.WITHDRAWN);
            }
            case SET_ANONYMOUS_CONSENTS: {
                return action.payload;
            }
        }
        return state;
    }

    function getReducers$6() {
        return {
            templates: loaderReducer(ANONYMOUS_CONSENTS),
            consents: reducer$p,
            ui: i1.combineReducers({
                bannerDismissed: reducer$r,
                updated: reducer$q,
            }),
        };
    }
    var reducerToken$6 = new i0.InjectionToken('AnonymousConsentsReducers');
    var reducerProvider$6 = {
        provide: reducerToken$6,
        useFactory: getReducers$6,
    };
    function clearAnonymousConsentTemplates(reducer) {
        return function (state, action) {
            if (action.type === LOGOUT ||
                action.type === LANGUAGE_CHANGE) {
                state = Object.assign(Object.assign({}, state), { templates: undefined });
            }
            return reducer(state, action);
        };
    }
    var metaReducers$3 = [
        clearAnonymousConsentTemplates,
    ];

    /**
     * Responsible for saving the anonymous consents data in browser storage.
     */
    var AnonymousConsentsStatePersistenceService = /** @class */ (function () {
        function AnonymousConsentsStatePersistenceService(statePersistenceService, store, anonymousConsentsService) {
            this.statePersistenceService = statePersistenceService;
            this.store = store;
            this.anonymousConsentsService = anonymousConsentsService;
            this.subscription = new rxjs.Subscription();
            /**
             * Identifier used for storage key.
             */
            this.key = 'anonymous-consents';
        }
        /**
         * Initializes the synchronization between state and browser storage.
         */
        AnonymousConsentsStatePersistenceService.prototype.initSync = function () {
            var _this = this;
            this.subscription.add(this.statePersistenceService.syncWithStorage({
                key: this.key,
                state$: this.getAuthState(),
                onRead: function (state) { return _this.onRead(state); },
            }));
        };
        /**
         * Gets and transforms state from different sources into the form that should
         * be saved in storage.
         */
        AnonymousConsentsStatePersistenceService.prototype.getAuthState = function () {
            return this.store.select(getAnonymousConsentState);
        };
        /**
         * Function called on each browser storage read.
         * Used to update state from browser -> state.
         */
        AnonymousConsentsStatePersistenceService.prototype.onRead = function (state) {
            var _a;
            var templates = state === null || state === void 0 ? void 0 : state.templates;
            var consents = state === null || state === void 0 ? void 0 : state.consents;
            var ui = state === null || state === void 0 ? void 0 : state.ui;
            // templates
            if (templates === null || templates === void 0 ? void 0 : templates.success) {
                this.store.dispatch(new LoadAnonymousConsentTemplatesSuccess((_a = templates.value) !== null && _a !== void 0 ? _a : []));
            }
            // consents
            if (consents) {
                this.anonymousConsentsService.setConsents(consents);
            }
            // ui
            if (ui) {
                this.anonymousConsentsService.toggleBannerDismissed(ui === null || ui === void 0 ? void 0 : ui.bannerDismissed);
                this.anonymousConsentsService.toggleTemplatesUpdated(ui === null || ui === void 0 ? void 0 : ui.updated);
            }
        };
        AnonymousConsentsStatePersistenceService.prototype.ngOnDestroy = function () {
            this.subscription.unsubscribe();
        };
        return AnonymousConsentsStatePersistenceService;
    }());
    AnonymousConsentsStatePersistenceService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AnonymousConsentsStatePersistenceService, deps: [{ token: StatePersistenceService }, { token: i1__namespace$2.Store }, { token: AnonymousConsentsService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    AnonymousConsentsStatePersistenceService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AnonymousConsentsStatePersistenceService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AnonymousConsentsStatePersistenceService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: StatePersistenceService }, { type: i1__namespace$2.Store }, { type: AnonymousConsentsService }]; } });

    function anonymousConsentsStatePersistenceFactory(anonymousConsentsStatePersistenceService) {
        var result = function () { return anonymousConsentsStatePersistenceService.initSync(); };
        return result;
    }
    var AnonymousConsentsStoreModule = /** @class */ (function () {
        function AnonymousConsentsStoreModule() {
        }
        return AnonymousConsentsStoreModule;
    }());
    AnonymousConsentsStoreModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AnonymousConsentsStoreModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    AnonymousConsentsStoreModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AnonymousConsentsStoreModule, imports: [i6.CommonModule,
            StateModule, i1__namespace$2.StoreFeatureModule, i1__namespace$4.EffectsFeatureModule] });
    AnonymousConsentsStoreModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AnonymousConsentsStoreModule, providers: [
            reducerProvider$6,
            {
                provide: i0.APP_INITIALIZER,
                useFactory: anonymousConsentsStatePersistenceFactory,
                deps: [AnonymousConsentsStatePersistenceService],
                multi: true,
            },
        ], imports: [[
                i6.CommonModule,
                StateModule,
                i1.StoreModule.forFeature(ANONYMOUS_CONSENTS_STORE_FEATURE, reducerToken$6, {
                    metaReducers: metaReducers$3,
                }),
                i1$4.EffectsModule.forFeature(effects$5),
            ]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AnonymousConsentsStoreModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [
                            i6.CommonModule,
                            StateModule,
                            i1.StoreModule.forFeature(ANONYMOUS_CONSENTS_STORE_FEATURE, reducerToken$6, {
                                metaReducers: metaReducers$3,
                            }),
                            i1$4.EffectsModule.forFeature(effects$5),
                        ],
                        providers: [
                            reducerProvider$6,
                            {
                                provide: i0.APP_INITIALIZER,
                                useFactory: anonymousConsentsStatePersistenceFactory,
                                deps: [AnonymousConsentsStatePersistenceService],
                                multi: true,
                            },
                        ],
                    }]
            }] });

    var AnonymousConsentsModule = /** @class */ (function () {
        function AnonymousConsentsModule() {
        }
        AnonymousConsentsModule.forRoot = function () {
            return {
                ngModule: AnonymousConsentsModule,
                providers: __spreadArray(__spreadArray([], __read(interceptors)), [
                    AnonymousConsentsService,
                    provideDefaultConfig(defaultAnonymousConsentsConfig),
                ]),
            };
        };
        return AnonymousConsentsModule;
    }());
    AnonymousConsentsModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AnonymousConsentsModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    AnonymousConsentsModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AnonymousConsentsModule, imports: [AnonymousConsentsStoreModule] });
    AnonymousConsentsModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AnonymousConsentsModule, imports: [[AnonymousConsentsStoreModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AnonymousConsentsModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [AnonymousConsentsStoreModule],
                    }]
            }] });

    var ANONYMOUS_CONSENT_NORMALIZER = new i0.InjectionToken('AnonymousConsentNormalizer');

    var MULTI_CART_FEATURE = 'cart';
    var MULTI_CART_DATA = '[Multi Cart] Multi Cart Data';
    // TODO(#7241): Drop after event system implementation for cart vouchers
    /**
     * Add voucher process const
     * @deprecated since 2.0
     */
    var ADD_VOUCHER_PROCESS_ID = 'addVoucher';

    var CART_ADD_ENTRY = '[Cart-entry] Add Entry';
    var CART_ADD_ENTRY_SUCCESS = '[Cart-entry] Add Entry Success';
    var CART_ADD_ENTRY_FAIL = '[Cart-entry] Add Entry Fail';
    var CART_REMOVE_ENTRY = '[Cart-entry] Remove Entry';
    var CART_REMOVE_ENTRY_SUCCESS = '[Cart-entry] Remove Entry Success';
    var CART_REMOVE_ENTRY_FAIL = '[Cart-entry] Remove Entry Fail';
    var CART_UPDATE_ENTRY = '[Cart-entry] Update Entry';
    var CART_UPDATE_ENTRY_SUCCESS = '[Cart-entry] Update Entry Success';
    var CART_UPDATE_ENTRY_FAIL = '[Cart-entry] Update Entry Fail';
    var CartAddEntry = /** @class */ (function (_super) {
        __extends(CartAddEntry, _super);
        function CartAddEntry(payload) {
            var _this = _super.call(this, MULTI_CART_DATA, payload.cartId) || this;
            _this.payload = payload;
            _this.type = CART_ADD_ENTRY;
            return _this;
        }
        return CartAddEntry;
    }(EntityProcessesIncrementAction));
    var CartAddEntrySuccess = /** @class */ (function (_super) {
        __extends(CartAddEntrySuccess, _super);
        function CartAddEntrySuccess(payload) {
            var _this = _super.call(this, MULTI_CART_DATA, payload.cartId) || this;
            _this.payload = payload;
            _this.type = CART_ADD_ENTRY_SUCCESS;
            return _this;
        }
        return CartAddEntrySuccess;
    }(EntityProcessesDecrementAction));
    var CartAddEntryFail = /** @class */ (function (_super) {
        __extends(CartAddEntryFail, _super);
        function CartAddEntryFail(payload) {
            var _this = _super.call(this, MULTI_CART_DATA, payload.cartId) || this;
            _this.payload = payload;
            _this.type = CART_ADD_ENTRY_FAIL;
            return _this;
        }
        return CartAddEntryFail;
    }(EntityProcessesDecrementAction));
    var CartRemoveEntry = /** @class */ (function (_super) {
        __extends(CartRemoveEntry, _super);
        function CartRemoveEntry(payload) {
            var _this = _super.call(this, MULTI_CART_DATA, payload.cartId) || this;
            _this.payload = payload;
            _this.type = CART_REMOVE_ENTRY;
            return _this;
        }
        return CartRemoveEntry;
    }(EntityProcessesIncrementAction));
    var CartRemoveEntrySuccess = /** @class */ (function (_super) {
        __extends(CartRemoveEntrySuccess, _super);
        function CartRemoveEntrySuccess(payload) {
            var _this = _super.call(this, MULTI_CART_DATA, payload.cartId) || this;
            _this.payload = payload;
            _this.type = CART_REMOVE_ENTRY_SUCCESS;
            return _this;
        }
        return CartRemoveEntrySuccess;
    }(EntityProcessesDecrementAction));
    var CartRemoveEntryFail = /** @class */ (function (_super) {
        __extends(CartRemoveEntryFail, _super);
        function CartRemoveEntryFail(payload) {
            var _this = _super.call(this, MULTI_CART_DATA, payload.cartId) || this;
            _this.payload = payload;
            _this.type = CART_REMOVE_ENTRY_FAIL;
            return _this;
        }
        return CartRemoveEntryFail;
    }(EntityProcessesDecrementAction));
    var CartUpdateEntry = /** @class */ (function (_super) {
        __extends(CartUpdateEntry, _super);
        function CartUpdateEntry(payload) {
            var _this = _super.call(this, MULTI_CART_DATA, payload.cartId) || this;
            _this.payload = payload;
            _this.type = CART_UPDATE_ENTRY;
            return _this;
        }
        return CartUpdateEntry;
    }(EntityProcessesIncrementAction));
    var CartUpdateEntrySuccess = /** @class */ (function (_super) {
        __extends(CartUpdateEntrySuccess, _super);
        function CartUpdateEntrySuccess(payload) {
            var _this = _super.call(this, MULTI_CART_DATA, payload.cartId) || this;
            _this.payload = payload;
            _this.type = CART_UPDATE_ENTRY_SUCCESS;
            return _this;
        }
        return CartUpdateEntrySuccess;
    }(EntityProcessesDecrementAction));
    var CartUpdateEntryFail = /** @class */ (function (_super) {
        __extends(CartUpdateEntryFail, _super);
        function CartUpdateEntryFail(payload) {
            var _this = _super.call(this, MULTI_CART_DATA, payload.cartId) || this;
            _this.payload = payload;
            _this.type = CART_UPDATE_ENTRY_FAIL;
            return _this;
        }
        return CartUpdateEntryFail;
    }(EntityProcessesDecrementAction));

    var CART_ADD_VOUCHER = '[Cart-voucher] Add Cart Vouchers';
    var CART_ADD_VOUCHER_FAIL = '[Cart-voucher] Add Cart Voucher Fail';
    var CART_ADD_VOUCHER_SUCCESS = '[Cart-voucher] Add Cart Voucher Success';
    var CART_RESET_ADD_VOUCHER = '[Cart-voucher] Reset Add Cart Voucher';
    var CART_REMOVE_VOUCHER = '[Cart-voucher] Remove Cart Voucher';
    var CART_REMOVE_VOUCHER_FAIL = '[Cart-voucher] Remove Cart Voucher Fail';
    var CART_REMOVE_VOUCHER_SUCCESS = '[Cart-voucher] Remove Cart Voucher Success';
    // Adding cart voucher actions
    var CartAddVoucher = /** @class */ (function (_super) {
        __extends(CartAddVoucher, _super);
        function CartAddVoucher(payload) {
            var _this = _super.call(this, PROCESS_FEATURE, ADD_VOUCHER_PROCESS_ID) || this;
            _this.payload = payload;
            _this.type = CART_ADD_VOUCHER;
            return _this;
        }
        return CartAddVoucher;
    }(EntityLoadAction));
    var CartAddVoucherFail = /** @class */ (function (_super) {
        __extends(CartAddVoucherFail, _super);
        function CartAddVoucherFail(payload) {
            var _this = _super.call(this, PROCESS_FEATURE, ADD_VOUCHER_PROCESS_ID, payload.error) || this;
            _this.payload = payload;
            _this.type = CART_ADD_VOUCHER_FAIL;
            return _this;
        }
        return CartAddVoucherFail;
    }(EntityFailAction));
    var CartAddVoucherSuccess = /** @class */ (function (_super) {
        __extends(CartAddVoucherSuccess, _super);
        function CartAddVoucherSuccess(payload) {
            var _this = _super.call(this, PROCESS_FEATURE, ADD_VOUCHER_PROCESS_ID) || this;
            _this.payload = payload;
            _this.type = CART_ADD_VOUCHER_SUCCESS;
            return _this;
        }
        return CartAddVoucherSuccess;
    }(EntitySuccessAction));
    // TODO(#7241): Remove when switching to event system for vouchers
    /**
     * Resets add voucher process
     *
     * @deprecated since 2.0
     */
    var CartResetAddVoucher = /** @class */ (function (_super) {
        __extends(CartResetAddVoucher, _super);
        function CartResetAddVoucher() {
            var _this = _super.call(this, PROCESS_FEATURE, ADD_VOUCHER_PROCESS_ID) || this;
            _this.type = CART_RESET_ADD_VOUCHER;
            return _this;
        }
        return CartResetAddVoucher;
    }(EntityLoaderResetAction));
    // Deleting cart voucher
    var CartRemoveVoucher = /** @class */ (function (_super) {
        __extends(CartRemoveVoucher, _super);
        function CartRemoveVoucher(payload) {
            var _this = _super.call(this, MULTI_CART_DATA, payload.cartId) || this;
            _this.payload = payload;
            _this.type = CART_REMOVE_VOUCHER;
            return _this;
        }
        return CartRemoveVoucher;
    }(EntityProcessesIncrementAction));
    var CartRemoveVoucherFail = /** @class */ (function (_super) {
        __extends(CartRemoveVoucherFail, _super);
        function CartRemoveVoucherFail(payload) {
            var _this = _super.call(this, MULTI_CART_DATA, payload.cartId) || this;
            _this.payload = payload;
            _this.type = CART_REMOVE_VOUCHER_FAIL;
            return _this;
        }
        return CartRemoveVoucherFail;
    }(EntityProcessesDecrementAction));
    var CartRemoveVoucherSuccess = /** @class */ (function (_super) {
        __extends(CartRemoveVoucherSuccess, _super);
        function CartRemoveVoucherSuccess(payload) {
            var _this = _super.call(this, MULTI_CART_DATA, payload.cartId) || this;
            _this.payload = payload;
            _this.type = CART_REMOVE_VOUCHER_SUCCESS;
            return _this;
        }
        return CartRemoveVoucherSuccess;
    }(EntityProcessesDecrementAction));

    var CREATE_CART = '[Cart] Create Cart';
    var CREATE_CART_FAIL = '[Cart] Create Cart Fail';
    var CREATE_CART_SUCCESS = '[Cart] Create Cart Success';
    var LOAD_CART = '[Cart] Load Cart';
    var LOAD_CART_FAIL = '[Cart] Load Cart Fail';
    var LOAD_CART_SUCCESS = '[Cart] Load Cart Success';
    var LOAD_CARTS_SUCCESS = '[Cart] Load Carts Success';
    var ADD_EMAIL_TO_CART = '[Cart] Add Email to Cart';
    var ADD_EMAIL_TO_CART_FAIL = '[Cart] Add Email to Cart Fail';
    var ADD_EMAIL_TO_CART_SUCCESS = '[Cart] Add Email to Cart Success';
    var MERGE_CART = '[Cart] Merge Cart';
    var MERGE_CART_SUCCESS = '[Cart] Merge Cart Success';
    var RESET_CART_DETAILS = '[Cart] Reset Cart Details';
    var REMOVE_CART = '[Cart] Remove Cart';
    var DELETE_CART = '[Cart] Delete Cart';
    var DELETE_CART_SUCCESS = '[Cart] Delete Cart Success';
    var DELETE_CART_FAIL = '[Cart] Delete Cart Fail';
    var CreateCart = /** @class */ (function (_super) {
        __extends(CreateCart, _super);
        function CreateCart(payload) {
            var _this = _super.call(this, MULTI_CART_DATA, payload.tempCartId) || this;
            _this.payload = payload;
            _this.type = CREATE_CART;
            return _this;
        }
        return CreateCart;
    }(EntityLoadAction));
    var CreateCartFail = /** @class */ (function (_super) {
        __extends(CreateCartFail, _super);
        function CreateCartFail(payload) {
            var _this = _super.call(this, MULTI_CART_DATA, payload.tempCartId) || this;
            _this.payload = payload;
            _this.type = CREATE_CART_FAIL;
            return _this;
        }
        return CreateCartFail;
    }(EntityFailAction));
    var CreateCartSuccess = /** @class */ (function (_super) {
        __extends(CreateCartSuccess, _super);
        function CreateCartSuccess(payload) {
            var _this = _super.call(this, MULTI_CART_DATA, payload.cartId) || this;
            _this.payload = payload;
            _this.type = CREATE_CART_SUCCESS;
            return _this;
        }
        return CreateCartSuccess;
    }(EntitySuccessAction));
    var AddEmailToCart = /** @class */ (function (_super) {
        __extends(AddEmailToCart, _super);
        function AddEmailToCart(payload) {
            var _this = _super.call(this, MULTI_CART_DATA, payload.cartId) || this;
            _this.payload = payload;
            _this.type = ADD_EMAIL_TO_CART;
            return _this;
        }
        return AddEmailToCart;
    }(EntityProcessesIncrementAction));
    var AddEmailToCartFail = /** @class */ (function (_super) {
        __extends(AddEmailToCartFail, _super);
        function AddEmailToCartFail(payload) {
            var _this = _super.call(this, MULTI_CART_DATA, payload.cartId) || this;
            _this.payload = payload;
            _this.type = ADD_EMAIL_TO_CART_FAIL;
            return _this;
        }
        return AddEmailToCartFail;
    }(EntityProcessesDecrementAction));
    var AddEmailToCartSuccess = /** @class */ (function (_super) {
        __extends(AddEmailToCartSuccess, _super);
        function AddEmailToCartSuccess(payload) {
            var _this = _super.call(this, MULTI_CART_DATA, payload.cartId) || this;
            _this.payload = payload;
            _this.type = ADD_EMAIL_TO_CART_SUCCESS;
            return _this;
        }
        return AddEmailToCartSuccess;
    }(EntityProcessesDecrementAction));
    var LoadCart = /** @class */ (function (_super) {
        __extends(LoadCart, _super);
        function LoadCart(payload) {
            var _this = _super.call(this, MULTI_CART_DATA, payload.cartId) || this;
            _this.payload = payload;
            _this.type = LOAD_CART;
            return _this;
        }
        return LoadCart;
    }(EntityLoadAction));
    var LoadCartFail = /** @class */ (function (_super) {
        __extends(LoadCartFail, _super);
        function LoadCartFail(payload) {
            var _this = _super.call(this, MULTI_CART_DATA, payload.cartId, payload.error) || this;
            _this.payload = payload;
            _this.type = LOAD_CART_FAIL;
            return _this;
        }
        return LoadCartFail;
    }(EntityFailAction));
    var LoadCartSuccess = /** @class */ (function (_super) {
        __extends(LoadCartSuccess, _super);
        function LoadCartSuccess(payload) {
            var _this = _super.call(this, MULTI_CART_DATA, payload.cartId) || this;
            _this.payload = payload;
            _this.type = LOAD_CART_SUCCESS;
            return _this;
        }
        return LoadCartSuccess;
    }(EntitySuccessAction));
    var LoadCartsSuccess = /** @class */ (function (_super) {
        __extends(LoadCartsSuccess, _super);
        function LoadCartsSuccess(payload) {
            var _this = _super.call(this, MULTI_CART_DATA, payload.map(function (cart) { return cart === null || cart === void 0 ? void 0 : cart.code; })) || this;
            _this.payload = payload;
            _this.type = LOAD_CARTS_SUCCESS;
            return _this;
        }
        return LoadCartsSuccess;
    }(EntitySuccessAction));
    var MergeCart = /** @class */ (function () {
        function MergeCart(payload) {
            this.payload = payload;
            this.type = MERGE_CART;
        }
        return MergeCart;
    }());
    var MergeCartSuccess = /** @class */ (function (_super) {
        __extends(MergeCartSuccess, _super);
        function MergeCartSuccess(payload) {
            var _this = _super.call(this, MULTI_CART_DATA, payload.oldCartId) || this;
            _this.payload = payload;
            _this.type = MERGE_CART_SUCCESS;
            return _this;
        }
        return MergeCartSuccess;
    }(EntityRemoveAction));
    /**
     * On site context change we want to keep current list of entities, but we want to clear the value and flags.
     * With ProcessesLoaderResetAction we run it on every entity of this type.
     */
    var ResetCartDetails = /** @class */ (function (_super) {
        __extends(ResetCartDetails, _super);
        function ResetCartDetails() {
            var _this = _super.call(this, MULTI_CART_DATA) || this;
            _this.type = RESET_CART_DETAILS;
            return _this;
        }
        return ResetCartDetails;
    }(ProcessesLoaderResetAction));
    /**
     * Used for cleaning cart in local state, when we get information that it no longer exists in the backend.
     * For removing particular cart in both places use DeleteCart actions.
     */
    var RemoveCart = /** @class */ (function (_super) {
        __extends(RemoveCart, _super);
        function RemoveCart(payload) {
            var _this = _super.call(this, MULTI_CART_DATA, payload.cartId) || this;
            _this.payload = payload;
            _this.type = REMOVE_CART;
            return _this;
        }
        return RemoveCart;
    }(EntityRemoveAction));
    var DeleteCart = /** @class */ (function () {
        function DeleteCart(payload) {
            this.payload = payload;
            this.type = DELETE_CART;
        }
        return DeleteCart;
    }());
    var DeleteCartSuccess = /** @class */ (function (_super) {
        __extends(DeleteCartSuccess, _super);
        function DeleteCartSuccess(payload) {
            var _this = _super.call(this, MULTI_CART_DATA, payload.cartId) || this;
            _this.payload = payload;
            _this.type = DELETE_CART_SUCCESS;
            return _this;
        }
        return DeleteCartSuccess;
    }(EntityRemoveAction));
    var DeleteCartFail = /** @class */ (function () {
        function DeleteCartFail(payload) {
            this.payload = payload;
            this.type = DELETE_CART_FAIL;
        }
        return DeleteCartFail;
    }());

    var SET_TEMP_CART = '[Cart] Set Temp Cart';
    var CART_PROCESSES_INCREMENT = '[Cart] Cart Processes Increment';
    var CART_PROCESSES_DECREMENT = '[Cart] Cart Processes Decrement';
    var SET_ACTIVE_CART_ID = '[Cart] Set Active Cart Id';
    var CLEAR_CART_STATE = '[Cart] Clear Cart State';
    /**
     * To keep track of cart creation process we use cart with `temp-${uuid}` id.
     * After creating cart we switch to entity with `code` or `guid`.
     * We need `temp-${uuid}` cart entities for loading/error state.
     */
    var SetTempCart = /** @class */ (function (_super) {
        __extends(SetTempCart, _super);
        function SetTempCart(payload) {
            var _this = _super.call(this, MULTI_CART_DATA, payload.tempCartId, payload.cart) || this;
            _this.payload = payload;
            _this.type = SET_TEMP_CART;
            return _this;
        }
        return SetTempCart;
    }(EntitySuccessAction));
    // TODO(#7241): Remove when there won't be any usage
    /**
     * Increases process counter on cart entities
     * All actions that cause computations on cart should extend EntityProcessesIncrementAction instead of dispatching this action.
     * @deprecated since 2.0
     */
    var CartProcessesIncrement = /** @class */ (function (_super) {
        __extends(CartProcessesIncrement, _super);
        function CartProcessesIncrement(payload) {
            var _this = _super.call(this, MULTI_CART_DATA, payload) || this;
            _this.payload = payload;
            _this.type = CART_PROCESSES_INCREMENT;
            return _this;
        }
        return CartProcessesIncrement;
    }(EntityProcessesIncrementAction));
    // TODO(#7241): Remove when there won't be any usage
    /**
     * Decrement process counter on cart entities
     * All actions that cause computations on cart should extend EntityProcessesDecrementAction instead of dispatching this action.
     * @deprecated since 2.0
     */
    var CartProcessesDecrement = /** @class */ (function (_super) {
        __extends(CartProcessesDecrement, _super);
        function CartProcessesDecrement(payload) {
            var _this = _super.call(this, MULTI_CART_DATA, payload) || this;
            _this.payload = payload;
            _this.type = CART_PROCESSES_DECREMENT;
            return _this;
        }
        return CartProcessesDecrement;
    }(EntityProcessesDecrementAction));
    /**
     * Only sets active cart property with id of active cart. Then services take care of loading that cart.
     */
    var SetActiveCartId = /** @class */ (function () {
        function SetActiveCartId(payload) {
            this.payload = payload;
            this.type = SET_ACTIVE_CART_ID;
        }
        return SetActiveCartId;
    }());
    /**
     * Clear whole cart store state: all entities + reset rest of the cart state.
     */
    var ClearCartState = /** @class */ (function (_super) {
        __extends(ClearCartState, _super);
        function ClearCartState() {
            var _this = _super.call(this, MULTI_CART_DATA) || this;
            _this.type = CLEAR_CART_STATE;
            return _this;
        }
        return ClearCartState;
    }(EntityRemoveAllAction));

    /**
     * Extract cart identifier for current user. Anonymous calls use `guid` and for logged users `code` is used.
     */
    function getCartIdByUserId(cart, userId) {
        if (userId === OCC_USER_ID_ANONYMOUS) {
            return cart.guid;
        }
        return cart.code;
    }
    /**
     * Check if cart is selective (save for later) based on id.
     */
    function isSelectiveCart(cartId) {
        if (cartId === void 0) { cartId = ''; }
        return cartId.startsWith('selectivecart');
    }
    /**
     * Check if the returned error is of type notFound.
     *
     * We additionally check if the cart is not a selective cart.
     * For selective cart this error can happen only when extension is disabled.
     * It should never happen, because in that case, selective cart should also be disabled in our configuration.
     * However if that happens we want to handle these errors silently.
     */
    function isCartNotFoundError(error) {
        return (error.reason === 'notFound' &&
            error.subjectType === 'cart' &&
            !isSelectiveCart(error.subject));
    }
    /**
     * Compute wishlist cart name for customer.
     */
    function getWishlistName(customerId) {
        return "wishlist" + customerId;
    }
    /**
     * What is a temporary cart?
     * - frontend only cart entity!
     * - can be identified in store by `temp-` prefix with some unique id (multiple carts can be created at the same time eg. active cart, wishlist)
     *
     * Why we need temporary carts?
     * - to have information about cart creation process (meta flags: loading, error - for showing loader, error message)
     * - to know if there is currently a cart creation process in progress (eg. so, we don't create more than one active cart at the same time)
     * - cart identifiers are created in the backend, so those are only known after cart is created
     *
     * Temporary cart life cycle
     * - create cart method invoked
     * - new `temp-${uuid}` cart is created with `loading=true` state
     * - backend returns created cart
     * - normal cart entity is saved under correct id (eg. for logged user under cart `code` key)
     * - temporary cart value is set to backend response (anyone observing this cart can read code/guid from it and switch selector to normal cart)
     * - in next tick temporary cart is removed
     */
    function isTempCartId(cartId) {
        return cartId.startsWith('temp-');
    }

    var CREATE_WISH_LIST = '[Wish List] Create Wish List';
    var CREATE_WISH_LIST_FAIL = '[Wish List] Create Wish List Fail';
    var CREATE_WISH_LIST_SUCCESS = '[Wish List] Create Wish List Success';
    var LOAD_WISH_LIST = '[Wish List] Load Wish List';
    var LOAD_WISH_LIST_SUCCESS = '[Wish List] Load Wish List Success';
    var LOAD_WISH_LIST_FAIL = '[Wish List] Load Wish List Fail';
    var RESET_WISH_LIST_DETAILS = '[Wish List] Reset Wish List';
    var CreateWishList = /** @class */ (function () {
        function CreateWishList(payload) {
            this.payload = payload;
            this.type = CREATE_WISH_LIST;
        }
        return CreateWishList;
    }());
    var CreateWishListSuccess = /** @class */ (function (_super) {
        __extends(CreateWishListSuccess, _super);
        function CreateWishListSuccess(payload) {
            var _this = _super.call(this, MULTI_CART_DATA, getCartIdByUserId(payload.cart, payload.userId)) || this;
            _this.payload = payload;
            _this.type = CREATE_WISH_LIST_SUCCESS;
            return _this;
        }
        return CreateWishListSuccess;
    }(EntitySuccessAction));
    var CreateWishListFail = /** @class */ (function (_super) {
        __extends(CreateWishListFail, _super);
        function CreateWishListFail(payload) {
            var _this = _super.call(this, MULTI_CART_DATA, payload.cartId, payload.error) || this;
            _this.payload = payload;
            _this.type = CREATE_WISH_LIST_FAIL;
            return _this;
        }
        return CreateWishListFail;
    }(EntityFailAction));
    var LoadWishList = /** @class */ (function (_super) {
        __extends(LoadWishList, _super);
        function LoadWishList(payload) {
            var _this = _super.call(this, MULTI_CART_DATA, payload.tempCartId) || this;
            _this.payload = payload;
            _this.type = LOAD_WISH_LIST;
            return _this;
        }
        return LoadWishList;
    }(EntityLoadAction));
    var LoadWishListSuccess = /** @class */ (function (_super) {
        __extends(LoadWishListSuccess, _super);
        function LoadWishListSuccess(payload) {
            var _this = _super.call(this, MULTI_CART_DATA, payload.cartId) || this;
            _this.payload = payload;
            _this.type = LOAD_WISH_LIST_SUCCESS;
            return _this;
        }
        return LoadWishListSuccess;
    }(EntitySuccessAction));
    var LoadWishListFail = /** @class */ (function (_super) {
        __extends(LoadWishListFail, _super);
        function LoadWishListFail(payload) {
            var _this = _super.call(this, MULTI_CART_DATA, payload.cartId, payload.error) || this;
            _this.payload = payload;
            _this.type = LOAD_WISH_LIST_FAIL;
            return _this;
        }
        return LoadWishListFail;
    }(EntityFailAction));

    var cartGroup_actions = /*#__PURE__*/Object.freeze({
        __proto__: null,
        CART_ADD_ENTRY: CART_ADD_ENTRY,
        CART_ADD_ENTRY_SUCCESS: CART_ADD_ENTRY_SUCCESS,
        CART_ADD_ENTRY_FAIL: CART_ADD_ENTRY_FAIL,
        CART_REMOVE_ENTRY: CART_REMOVE_ENTRY,
        CART_REMOVE_ENTRY_SUCCESS: CART_REMOVE_ENTRY_SUCCESS,
        CART_REMOVE_ENTRY_FAIL: CART_REMOVE_ENTRY_FAIL,
        CART_UPDATE_ENTRY: CART_UPDATE_ENTRY,
        CART_UPDATE_ENTRY_SUCCESS: CART_UPDATE_ENTRY_SUCCESS,
        CART_UPDATE_ENTRY_FAIL: CART_UPDATE_ENTRY_FAIL,
        CartAddEntry: CartAddEntry,
        CartAddEntrySuccess: CartAddEntrySuccess,
        CartAddEntryFail: CartAddEntryFail,
        CartRemoveEntry: CartRemoveEntry,
        CartRemoveEntrySuccess: CartRemoveEntrySuccess,
        CartRemoveEntryFail: CartRemoveEntryFail,
        CartUpdateEntry: CartUpdateEntry,
        CartUpdateEntrySuccess: CartUpdateEntrySuccess,
        CartUpdateEntryFail: CartUpdateEntryFail,
        CART_ADD_VOUCHER: CART_ADD_VOUCHER,
        CART_ADD_VOUCHER_FAIL: CART_ADD_VOUCHER_FAIL,
        CART_ADD_VOUCHER_SUCCESS: CART_ADD_VOUCHER_SUCCESS,
        CART_RESET_ADD_VOUCHER: CART_RESET_ADD_VOUCHER,
        CART_REMOVE_VOUCHER: CART_REMOVE_VOUCHER,
        CART_REMOVE_VOUCHER_FAIL: CART_REMOVE_VOUCHER_FAIL,
        CART_REMOVE_VOUCHER_SUCCESS: CART_REMOVE_VOUCHER_SUCCESS,
        CartAddVoucher: CartAddVoucher,
        CartAddVoucherFail: CartAddVoucherFail,
        CartAddVoucherSuccess: CartAddVoucherSuccess,
        CartResetAddVoucher: CartResetAddVoucher,
        CartRemoveVoucher: CartRemoveVoucher,
        CartRemoveVoucherFail: CartRemoveVoucherFail,
        CartRemoveVoucherSuccess: CartRemoveVoucherSuccess,
        CREATE_CART: CREATE_CART,
        CREATE_CART_FAIL: CREATE_CART_FAIL,
        CREATE_CART_SUCCESS: CREATE_CART_SUCCESS,
        LOAD_CART: LOAD_CART,
        LOAD_CART_FAIL: LOAD_CART_FAIL,
        LOAD_CART_SUCCESS: LOAD_CART_SUCCESS,
        LOAD_CARTS_SUCCESS: LOAD_CARTS_SUCCESS,
        ADD_EMAIL_TO_CART: ADD_EMAIL_TO_CART,
        ADD_EMAIL_TO_CART_FAIL: ADD_EMAIL_TO_CART_FAIL,
        ADD_EMAIL_TO_CART_SUCCESS: ADD_EMAIL_TO_CART_SUCCESS,
        MERGE_CART: MERGE_CART,
        MERGE_CART_SUCCESS: MERGE_CART_SUCCESS,
        RESET_CART_DETAILS: RESET_CART_DETAILS,
        REMOVE_CART: REMOVE_CART,
        DELETE_CART: DELETE_CART,
        DELETE_CART_SUCCESS: DELETE_CART_SUCCESS,
        DELETE_CART_FAIL: DELETE_CART_FAIL,
        CreateCart: CreateCart,
        CreateCartFail: CreateCartFail,
        CreateCartSuccess: CreateCartSuccess,
        AddEmailToCart: AddEmailToCart,
        AddEmailToCartFail: AddEmailToCartFail,
        AddEmailToCartSuccess: AddEmailToCartSuccess,
        LoadCart: LoadCart,
        LoadCartFail: LoadCartFail,
        LoadCartSuccess: LoadCartSuccess,
        LoadCartsSuccess: LoadCartsSuccess,
        MergeCart: MergeCart,
        MergeCartSuccess: MergeCartSuccess,
        ResetCartDetails: ResetCartDetails,
        RemoveCart: RemoveCart,
        DeleteCart: DeleteCart,
        DeleteCartSuccess: DeleteCartSuccess,
        DeleteCartFail: DeleteCartFail,
        SET_TEMP_CART: SET_TEMP_CART,
        CART_PROCESSES_INCREMENT: CART_PROCESSES_INCREMENT,
        CART_PROCESSES_DECREMENT: CART_PROCESSES_DECREMENT,
        SET_ACTIVE_CART_ID: SET_ACTIVE_CART_ID,
        CLEAR_CART_STATE: CLEAR_CART_STATE,
        SetTempCart: SetTempCart,
        CartProcessesIncrement: CartProcessesIncrement,
        CartProcessesDecrement: CartProcessesDecrement,
        SetActiveCartId: SetActiveCartId,
        ClearCartState: ClearCartState,
        CREATE_WISH_LIST: CREATE_WISH_LIST,
        CREATE_WISH_LIST_FAIL: CREATE_WISH_LIST_FAIL,
        CREATE_WISH_LIST_SUCCESS: CREATE_WISH_LIST_SUCCESS,
        LOAD_WISH_LIST: LOAD_WISH_LIST,
        LOAD_WISH_LIST_SUCCESS: LOAD_WISH_LIST_SUCCESS,
        LOAD_WISH_LIST_FAIL: LOAD_WISH_LIST_FAIL,
        RESET_WISH_LIST_DETAILS: RESET_WISH_LIST_DETAILS,
        CreateWishList: CreateWishList,
        CreateWishListSuccess: CreateWishListSuccess,
        CreateWishListFail: CreateWishListFail,
        LoadWishList: LoadWishList,
        LoadWishListSuccess: LoadWishListSuccess,
        LoadWishListFail: LoadWishListFail
    });

    /**
     *
     * Withdraw from the source observable when notifier emits a value
     *
     * Withdraw will result in resubscribing to the source observable
     * Operator is useful to kill ongoing emission transformation on notifier emission
     *
     * @param notifier
     */
    function withdrawOn(notifier) {
        return function (source) { return notifier.pipe(operators.startWith(undefined), operators.switchMapTo(source)); };
    }

    var CartEntryAdapter = /** @class */ (function () {
        function CartEntryAdapter() {
        }
        return CartEntryAdapter;
    }());

    var CartEntryConnector = /** @class */ (function () {
        function CartEntryConnector(adapter) {
            this.adapter = adapter;
        }
        CartEntryConnector.prototype.add = function (userId, cartId, productCode, quantity) {
            return this.adapter.add(userId, cartId, productCode, quantity);
        };
        CartEntryConnector.prototype.update = function (userId, cartId, entryNumber, qty, pickupStore) {
            return this.adapter.update(userId, cartId, entryNumber, qty, pickupStore);
        };
        CartEntryConnector.prototype.remove = function (userId, cartId, entryNumber) {
            return this.adapter.remove(userId, cartId, entryNumber);
        };
        return CartEntryConnector;
    }());
    CartEntryConnector.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartEntryConnector, deps: [{ token: CartEntryAdapter }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    CartEntryConnector.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartEntryConnector, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartEntryConnector, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: CartEntryAdapter }]; } });

    var CartEntryEffects = /** @class */ (function () {
        function CartEntryEffects(actions$, cartEntryConnector) {
            var _this = this;
            this.actions$ = actions$;
            this.cartEntryConnector = cartEntryConnector;
            this.contextChange$ = this.actions$.pipe(i1$4.ofType(CURRENCY_CHANGE, LANGUAGE_CHANGE));
            this.addEntry$ = this.actions$.pipe(i1$4.ofType(CART_ADD_ENTRY), operators.map(function (action) { return action.payload; }), operators.concatMap(function (payload) {
                return _this.cartEntryConnector
                    .add(payload.userId, payload.cartId, payload.productCode, payload.quantity)
                    .pipe(operators.map(function (cartModification) { return new CartAddEntrySuccess(Object.assign(Object.assign({}, payload), cartModification)); }), operators.catchError(function (error) { return rxjs.from([
                    new CartAddEntryFail(Object.assign(Object.assign({}, payload), { error: normalizeHttpError(error) })),
                    new LoadCart({
                        cartId: payload.cartId,
                        userId: payload.userId,
                    }),
                ]); }));
            }), withdrawOn(this.contextChange$));
            this.removeEntry$ = this.actions$.pipe(i1$4.ofType(CART_REMOVE_ENTRY), operators.map(function (action) { return action.payload; }), operators.concatMap(function (payload) { return _this.cartEntryConnector
                .remove(payload.userId, payload.cartId, payload.entryNumber)
                .pipe(operators.map(function () {
                return new CartRemoveEntrySuccess(Object.assign({}, payload));
            }), operators.catchError(function (error) { return rxjs.from([
                new CartRemoveEntryFail(Object.assign(Object.assign({}, payload), { error: normalizeHttpError(error) })),
                new LoadCart({
                    cartId: payload.cartId,
                    userId: payload.userId,
                }),
            ]); })); }), withdrawOn(this.contextChange$));
            this.updateEntry$ = this.actions$.pipe(i1$4.ofType(CART_UPDATE_ENTRY), operators.map(function (action) { return action.payload; }), operators.concatMap(function (payload) { return _this.cartEntryConnector
                .update(payload.userId, payload.cartId, payload.entryNumber, payload.quantity)
                .pipe(operators.map(function () {
                return new CartUpdateEntrySuccess(Object.assign({}, payload));
            }), operators.catchError(function (error) { return rxjs.from([
                new CartUpdateEntryFail(Object.assign(Object.assign({}, payload), { error: normalizeHttpError(error) })),
                new LoadCart({
                    cartId: payload.cartId,
                    userId: payload.userId,
                }),
            ]); })); }), withdrawOn(this.contextChange$));
        }
        return CartEntryEffects;
    }());
    CartEntryEffects.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartEntryEffects, deps: [{ token: i1__namespace$4.Actions }, { token: CartEntryConnector }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    CartEntryEffects.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartEntryEffects });
    __decorate([
        i1$4.Effect()
    ], CartEntryEffects.prototype, "addEntry$", void 0);
    __decorate([
        i1$4.Effect()
    ], CartEntryEffects.prototype, "removeEntry$", void 0);
    __decorate([
        i1$4.Effect()
    ], CartEntryEffects.prototype, "updateEntry$", void 0);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartEntryEffects, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: i1__namespace$4.Actions }, { type: CartEntryConnector }]; }, propDecorators: { addEntry$: [], removeEntry$: [], updateEntry$: [] } });

    var CartVoucherAdapter = /** @class */ (function () {
        function CartVoucherAdapter() {
        }
        return CartVoucherAdapter;
    }());

    var CartVoucherConnector = /** @class */ (function () {
        function CartVoucherConnector(adapter) {
            this.adapter = adapter;
        }
        CartVoucherConnector.prototype.add = function (userId, cartId, voucherId) {
            return this.adapter.add(userId, cartId, voucherId);
        };
        CartVoucherConnector.prototype.remove = function (userId, cartId, voucherId) {
            return this.adapter.remove(userId, cartId, voucherId);
        };
        return CartVoucherConnector;
    }());
    CartVoucherConnector.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartVoucherConnector, deps: [{ token: CartVoucherAdapter }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    CartVoucherConnector.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartVoucherConnector, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartVoucherConnector, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: CartVoucherAdapter }]; } });

    var CartVoucherEffects = /** @class */ (function () {
        function CartVoucherEffects(actions$, cartVoucherConnector, messageService) {
            var _this = this;
            this.actions$ = actions$;
            this.cartVoucherConnector = cartVoucherConnector;
            this.messageService = messageService;
            this.addCartVoucher$ = this.actions$.pipe(i1$4.ofType(CART_ADD_VOUCHER), operators.map(function (action) { return action.payload; }), operators.mergeMap(function (payload) {
                return _this.cartVoucherConnector
                    .add(payload.userId, payload.cartId, payload.voucherId)
                    .pipe(operators.map(function () {
                    _this.showGlobalMessage('voucher.applyVoucherSuccess', payload.voucherId, exports.GlobalMessageType.MSG_TYPE_CONFIRMATION);
                    return new CartAddVoucherSuccess(Object.assign({}, payload));
                }), operators.catchError(function (error) { return rxjs.from([
                    new CartAddVoucherFail(Object.assign(Object.assign({}, payload), { error: normalizeHttpError(error) })),
                    new CartProcessesDecrement(payload.cartId),
                    new LoadCart({
                        userId: payload.userId,
                        cartId: payload.cartId,
                    }),
                ]); }));
            }));
            this.removeCartVoucher$ = this.actions$.pipe(i1$4.ofType(CART_REMOVE_VOUCHER), operators.map(function (action) { return action.payload; }), operators.mergeMap(function (payload) {
                return _this.cartVoucherConnector
                    .remove(payload.userId, payload.cartId, payload.voucherId)
                    .pipe(operators.map(function () {
                    _this.showGlobalMessage('voucher.removeVoucherSuccess', payload.voucherId, exports.GlobalMessageType.MSG_TYPE_INFO);
                    return new CartRemoveVoucherSuccess({
                        userId: payload.userId,
                        cartId: payload.cartId,
                        voucherId: payload.voucherId,
                    });
                }), operators.catchError(function (error) { return rxjs.from([
                    new CartRemoveVoucherFail({
                        error: normalizeHttpError(error),
                        cartId: payload.cartId,
                        userId: payload.userId,
                        voucherId: payload.voucherId,
                    }),
                    new LoadCart({
                        userId: payload.userId,
                        cartId: payload.cartId,
                    }),
                ]); }));
            }));
        }
        CartVoucherEffects.prototype.showGlobalMessage = function (text, param, messageType) {
            this.messageService.add({ key: text, params: { voucherCode: param } }, messageType);
        };
        return CartVoucherEffects;
    }());
    CartVoucherEffects.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartVoucherEffects, deps: [{ token: i1__namespace$4.Actions }, { token: CartVoucherConnector }, { token: GlobalMessageService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    CartVoucherEffects.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartVoucherEffects });
    __decorate([
        i1$4.Effect()
    ], CartVoucherEffects.prototype, "addCartVoucher$", void 0);
    __decorate([
        i1$4.Effect()
    ], CartVoucherEffects.prototype, "removeCartVoucher$", void 0);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartVoucherEffects, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: i1__namespace$4.Actions }, { type: CartVoucherConnector }, { type: GlobalMessageService }]; }, propDecorators: { addCartVoucher$: [], removeCartVoucher$: [] } });

    var getMultiCartState = i1.createFeatureSelector(MULTI_CART_FEATURE);
    var getMultiCartEntities = i1.createSelector(getMultiCartState, function (state) { return state.carts; });
    var getCartEntitySelectorFactory = function (cartId) {
        return i1.createSelector(getMultiCartEntities, function (state) { return entityProcessesLoaderStateSelector(state, cartId); });
    };
    var getCartSelectorFactory = function (cartId) {
        return i1.createSelector(getMultiCartEntities, function (state) { return entityValueSelector(state, cartId); });
    };
    var getCartIsStableSelectorFactory = function (cartId) {
        return i1.createSelector(getMultiCartEntities, function (state) { return entityIsStableSelector(state, cartId); });
    };
    var getCartHasPendingProcessesSelectorFactory = function (cartId) {
        return i1.createSelector(getMultiCartEntities, function (state) { return entityHasPendingProcessesSelector(state, cartId); });
    };
    var getCartEntriesSelectorFactory = function (cartId) {
        return i1.createSelector(getCartSelectorFactory(cartId), function (state) {
            return state && state.entries ? state.entries : [];
        });
    };
    var getCartEntrySelectorFactory = function (cartId, productCode) {
        return i1.createSelector(getCartEntriesSelectorFactory(cartId), function (state) {
            return state
                ? state.find(function (entry) { return entry.product.code === productCode; })
                : undefined;
        });
    };
    var getActiveCartId = i1.createSelector(getMultiCartState, function (state) { return state.active; });
    var getWishListId = i1.createSelector(getMultiCartState, function (state) { return state.wishList; });
    var getCartsSelectorFactory = i1.createSelector(getMultiCartEntities, function (state) { return Object.keys(state.entities).map(function (key) { return entityValueSelector(state, key); }); });

    var CartAdapter = /** @class */ (function () {
        function CartAdapter() {
        }
        return CartAdapter;
    }());

    var CartConnector = /** @class */ (function () {
        function CartConnector(adapter) {
            this.adapter = adapter;
        }
        CartConnector.prototype.loadAll = function (userId) {
            return this.adapter.loadAll(userId);
        };
        CartConnector.prototype.load = function (userId, cartId) {
            return this.adapter.load(userId, cartId);
        };
        CartConnector.prototype.create = function (userId, oldCartId, toMergeCartGuid) {
            return this.adapter.create(userId, oldCartId, toMergeCartGuid);
        };
        CartConnector.prototype.delete = function (userId, cartId) {
            return this.adapter.delete(userId, cartId);
        };
        CartConnector.prototype.addEmail = function (userId, cartId, email) {
            return this.adapter.addEmail(userId, cartId, email);
        };
        return CartConnector;
    }());
    CartConnector.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartConnector, deps: [{ token: CartAdapter }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    CartConnector.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartConnector, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartConnector, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: CartAdapter }]; } });

    var CartEffects = /** @class */ (function () {
        function CartEffects(actions$, cartConnector, store) {
            var _this = this;
            this.actions$ = actions$;
            this.cartConnector = cartConnector;
            this.store = store;
            this.contextChange$ = this.actions$.pipe(i1$4.ofType(CURRENCY_CHANGE, LANGUAGE_CHANGE));
            this.loadCart$ = this.actions$.pipe(i1$4.ofType(LOAD_CART), operators.map(function (action) { return action.payload; }), operators.groupBy(function (payload) { return payload.cartId; }), operators.mergeMap(function (group$) { return group$.pipe(operators.switchMap(function (payload) {
                return rxjs.of(payload).pipe(operators.withLatestFrom(_this.store.pipe(i1.select(getCartHasPendingProcessesSelectorFactory(payload.cartId)))));
            }), operators.filter(function (_b) {
                var _c = __read(_b, 2), _ = _c[0], hasPendingProcesses = _c[1];
                return !hasPendingProcesses;
            }), operators.map(function (_b) {
                var _c = __read(_b, 1), payload = _c[0];
                return payload;
            }), operators.switchMap(function (payload) {
                return _this.cartConnector.load(payload.userId, payload.cartId).pipe(operators.mergeMap(function (cart) {
                    var actions = [];
                    if (cart) {
                        actions.push(new LoadCartSuccess(Object.assign(Object.assign({}, payload), { cart: cart, cartId: getCartIdByUserId(cart, payload.userId) })));
                        if (payload.cartId === OCC_CART_ID_CURRENT) {
                            // Removing cart from entity object under `current` key as it is no longer needed.
                            // Current cart is loaded under it's code entity.
                            actions.push(new RemoveCart({ cartId: OCC_CART_ID_CURRENT }));
                        }
                    }
                    else {
                        actions = [
                            new LoadCartFail(Object.assign(Object.assign({}, payload), { error: {} })),
                        ];
                    }
                    return actions;
                }), operators.catchError(function (error) {
                    var _a;
                    if ((_a = error === null || error === void 0 ? void 0 : error.error) === null || _a === void 0 ? void 0 : _a.errors) {
                        var couponExpiredErrors = error.error.errors.filter(function (err) { return err.reason === 'invalid'; });
                        if (couponExpiredErrors.length > 0) {
                            // Reload in case of expired coupon.
                            return rxjs.of(new LoadCart(Object.assign({}, payload)));
                        }
                        var cartNotFoundErrors = error.error.errors.filter(function (err) { return isCartNotFoundError(err) ||
                            err.reason === 'UnknownResourceError'; });
                        if (cartNotFoundErrors.length > 0) {
                            // Remove cart as it doesn't exist on backend (selective cart always exists).
                            return rxjs.of(new RemoveCart({ cartId: payload.cartId }));
                        }
                    }
                    return rxjs.of(new LoadCartFail(Object.assign(Object.assign({}, payload), { error: normalizeHttpError(error) })));
                }));
            })); }), withdrawOn(this.contextChange$));
            this.createCart$ = this.actions$.pipe(i1$4.ofType(CREATE_CART), operators.map(function (action) { return action.payload; }), operators.mergeMap(function (payload) {
                return _this.cartConnector
                    .create(payload.userId, payload.oldCartId, payload.toMergeCartGuid)
                    .pipe(operators.switchMap(function (cart) {
                    var conditionalActions = [];
                    if (payload.oldCartId) {
                        conditionalActions.push(new MergeCartSuccess({
                            extraData: payload.extraData,
                            userId: payload.userId,
                            tempCartId: payload.tempCartId,
                            cartId: getCartIdByUserId(cart, payload.userId),
                            oldCartId: payload.oldCartId,
                        }));
                    }
                    return __spreadArray([
                        new CreateCartSuccess(Object.assign(Object.assign({}, payload), { cart: cart, cartId: getCartIdByUserId(cart, payload.userId) })),
                        new SetTempCart({
                            cart: cart,
                            tempCartId: payload.tempCartId,
                        })
                    ], __read(conditionalActions));
                }), operators.catchError(function (error) { return rxjs.of(new CreateCartFail(Object.assign(Object.assign({}, payload), { error: normalizeHttpError(error) }))); }));
            }), withdrawOn(this.contextChange$));
            this.mergeCart$ = this.actions$.pipe(i1$4.ofType(MERGE_CART), operators.map(function (action) { return action.payload; }), operators.switchMap(function (payload) {
                return _this.cartConnector.load(payload.userId, OCC_CART_ID_CURRENT).pipe(operators.map(function (currentCart) {
                    if ((currentCart === null || currentCart === void 0 ? void 0 : currentCart.code) !== payload.cartId) {
                        return new CreateCart({
                            userId: payload.userId,
                            oldCartId: payload.cartId,
                            toMergeCartGuid: currentCart ? currentCart.guid : undefined,
                            extraData: payload.extraData,
                            tempCartId: payload.tempCartId,
                        });
                    }
                }), operators.filter(isNotUndefined));
            }), withdrawOn(this.contextChange$));
            // TODO(#7241): Remove when AddVoucherSuccess actions will extend processes actions
            this.refresh$ = this.actions$.pipe(i1$4.ofType(CART_ADD_VOUCHER_SUCCESS), operators.map(function (action) { return action.payload; }), operators.concatMap(function (payload) { return rxjs.from([
                new CartProcessesDecrement(payload.cartId),
                new LoadCart({
                    userId: payload.userId,
                    cartId: payload.cartId,
                }),
            ]); }));
            // TODO: Switch to automatic cart reload on processes count reaching 0 for cart entity
            this.refreshWithoutProcesses$ = this.actions$.pipe(i1$4.ofType(CART_ADD_ENTRY_SUCCESS, CART_REMOVE_ENTRY_SUCCESS, CART_UPDATE_ENTRY_SUCCESS, CART_REMOVE_VOUCHER_SUCCESS), operators.map(function (action) { return action.payload; }), operators.map(function (payload) { return new LoadCart({
                userId: payload.userId,
                cartId: payload.cartId,
            }); }));
            this.resetCartDetailsOnSiteContextChange$ = this.actions$.pipe(i1$4.ofType(LANGUAGE_CHANGE, CURRENCY_CHANGE), operators.mergeMap(function () {
                return [new ResetCartDetails()];
            }));
            this.addEmail$ = this.actions$.pipe(i1$4.ofType(ADD_EMAIL_TO_CART), operators.map(function (action) { return action.payload; }), operators.mergeMap(function (payload) { return _this.cartConnector
                .addEmail(payload.userId, payload.cartId, payload.email)
                .pipe(operators.mergeMap(function () {
                return [
                    new AddEmailToCartSuccess(Object.assign({}, payload)),
                    new LoadCart({
                        userId: payload.userId,
                        cartId: payload.cartId,
                    }),
                ];
            }), operators.catchError(function (error) { return rxjs.from([
                new AddEmailToCartFail(Object.assign(Object.assign({}, payload), { error: normalizeHttpError(error) })),
                new LoadCart({
                    userId: payload.userId,
                    cartId: payload.cartId,
                }),
            ]); })); }), withdrawOn(this.contextChange$));
            this.deleteCart$ = this.actions$.pipe(i1$4.ofType(DELETE_CART), operators.map(function (action) { return action.payload; }), operators.mergeMap(function (payload) { return _this.cartConnector.delete(payload.userId, payload.cartId).pipe(operators.map(function () {
                return new DeleteCartSuccess(Object.assign({}, payload));
            }), operators.catchError(function (error) { return rxjs.from([
                new DeleteCartFail(Object.assign(Object.assign({}, payload), { error: normalizeHttpError(error) })),
                // Error might happen in higher backend layer and cart could still be removed.
                // When load fail with NotFound error then RemoveCart action will kick in and clear that cart in our state.
                new LoadCart(Object.assign({}, payload)),
            ]); })); }));
        }
        return CartEffects;
    }());
    CartEffects.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartEffects, deps: [{ token: i1__namespace$4.Actions }, { token: CartConnector }, { token: i1__namespace$2.Store }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    CartEffects.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartEffects });
    __decorate([
        i1$4.Effect()
    ], CartEffects.prototype, "loadCart$", void 0);
    __decorate([
        i1$4.Effect()
    ], CartEffects.prototype, "createCart$", void 0);
    __decorate([
        i1$4.Effect()
    ], CartEffects.prototype, "mergeCart$", void 0);
    __decorate([
        i1$4.Effect()
    ], CartEffects.prototype, "refresh$", void 0);
    __decorate([
        i1$4.Effect()
    ], CartEffects.prototype, "refreshWithoutProcesses$", void 0);
    __decorate([
        i1$4.Effect()
    ], CartEffects.prototype, "resetCartDetailsOnSiteContextChange$", void 0);
    __decorate([
        i1$4.Effect()
    ], CartEffects.prototype, "addEmail$", void 0);
    __decorate([
        i1$4.Effect()
    ], CartEffects.prototype, "deleteCart$", void 0);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartEffects, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: i1__namespace$4.Actions }, { type: CartConnector }, { type: i1__namespace$2.Store }]; }, propDecorators: { loadCart$: [], createCart$: [], mergeCart$: [], refresh$: [], refreshWithoutProcesses$: [], resetCartDetailsOnSiteContextChange$: [], addEmail$: [], deleteCart$: [] } });

    var multiCartGroup_selectors = /*#__PURE__*/Object.freeze({
        __proto__: null,
        getMultiCartState: getMultiCartState,
        getMultiCartEntities: getMultiCartEntities,
        getCartEntitySelectorFactory: getCartEntitySelectorFactory,
        getCartSelectorFactory: getCartSelectorFactory,
        getCartIsStableSelectorFactory: getCartIsStableSelectorFactory,
        getCartHasPendingProcessesSelectorFactory: getCartHasPendingProcessesSelectorFactory,
        getCartEntriesSelectorFactory: getCartEntriesSelectorFactory,
        getCartEntrySelectorFactory: getCartEntrySelectorFactory,
        getActiveCartId: getActiveCartId,
        getWishListId: getWishListId,
        getCartsSelectorFactory: getCartsSelectorFactory
    });

    var SaveCartAdapter = /** @class */ (function () {
        function SaveCartAdapter() {
        }
        return SaveCartAdapter;
    }());

    var SaveCartConnector = /** @class */ (function () {
        function SaveCartConnector(adapter) {
            this.adapter = adapter;
        }
        SaveCartConnector.prototype.saveCart = function (userId, cartId, saveCartName, saveCartDescription) {
            return this.adapter.saveCart(userId, cartId, saveCartName, saveCartDescription);
        };
        return SaveCartConnector;
    }());
    SaveCartConnector.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SaveCartConnector, deps: [{ token: SaveCartAdapter }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    SaveCartConnector.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SaveCartConnector, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SaveCartConnector, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: SaveCartAdapter }]; } });

    var WishListEffects = /** @class */ (function () {
        function WishListEffects(actions$, cartConnector, saveCartConnector, userIdService, store) {
            var _this = this;
            this.actions$ = actions$;
            this.cartConnector = cartConnector;
            this.saveCartConnector = saveCartConnector;
            this.userIdService = userIdService;
            this.store = store;
            this.createWishList$ = this.actions$.pipe(i1$4.ofType(CREATE_WISH_LIST), operators.map(function (action) { return action.payload; }), operators.switchMap(function (payload) {
                return _this.cartConnector.create(payload.userId).pipe(operators.switchMap(function (cart) {
                    return _this.saveCartConnector
                        .saveCart(payload.userId, cart.code, payload.name, payload.description)
                        .pipe(operators.switchMap(function (saveCartResult) { return [
                        new CreateWishListSuccess({
                            cart: saveCartResult.savedCartData,
                            userId: payload.userId,
                        }),
                    ]; }), operators.catchError(function (error) { return rxjs.from([
                        new CreateWishListFail({
                            cartId: cart.code,
                            error: normalizeHttpError(error),
                        }),
                    ]); }));
                }));
            }));
            this.loadWishList$ = this.actions$.pipe(i1$4.ofType(LOAD_WISH_LIST), operators.map(function (action) { return action.payload; }), operators.concatMap(function (payload) {
                var userId = payload.userId, customerId = payload.customerId, tempCartId = payload.tempCartId;
                return _this.cartConnector.loadAll(userId).pipe(operators.switchMap(function (carts) {
                    if (carts) {
                        var wishList = carts.find(function (cart) { return cart.name === getWishlistName(customerId); });
                        if (Boolean(wishList)) {
                            return [
                                new LoadWishListSuccess({
                                    cart: wishList,
                                    userId: userId,
                                    tempCartId: tempCartId,
                                    customerId: customerId,
                                    cartId: getCartIdByUserId(wishList, userId),
                                }),
                                new RemoveCart({ cartId: tempCartId }),
                            ];
                        }
                        else {
                            return [
                                new CreateWishList({
                                    userId: userId,
                                    name: getWishlistName(customerId),
                                }),
                            ];
                        }
                    }
                }), operators.catchError(function (error) { return rxjs.from([
                    new LoadWishListFail({
                        userId: userId,
                        cartId: tempCartId,
                        customerId: customerId,
                        error: normalizeHttpError(error),
                    }),
                ]); }));
            }));
            this.resetWishList$ = this.actions$.pipe(i1$4.ofType(LANGUAGE_CHANGE, CURRENCY_CHANGE), operators.withLatestFrom(this.userIdService.getUserId(), this.store.pipe(i1.select(getWishListId))), operators.switchMap(function (_a) {
                var _b = __read(_a, 3), userId = _b[1], wishListId = _b[2];
                if (Boolean(wishListId)) {
                    return _this.cartConnector.load(userId, wishListId).pipe(operators.switchMap(function (wishList) { return [
                        new LoadWishListSuccess({
                            cart: wishList,
                            userId: userId,
                            cartId: getCartIdByUserId(wishList, userId),
                        }),
                    ]; }), operators.catchError(function (error) { return rxjs.from([
                        new LoadWishListFail({
                            userId: userId,
                            cartId: wishListId,
                            error: normalizeHttpError(error),
                        }),
                    ]); }));
                }
                return rxjs.EMPTY;
            }));
        }
        return WishListEffects;
    }());
    WishListEffects.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: WishListEffects, deps: [{ token: i1__namespace$4.Actions }, { token: CartConnector }, { token: SaveCartConnector }, { token: UserIdService }, { token: i1__namespace$2.Store }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    WishListEffects.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: WishListEffects });
    __decorate([
        i1$4.Effect()
    ], WishListEffects.prototype, "createWishList$", void 0);
    __decorate([
        i1$4.Effect()
    ], WishListEffects.prototype, "loadWishList$", void 0);
    __decorate([
        i1$4.Effect()
    ], WishListEffects.prototype, "resetWishList$", void 0);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: WishListEffects, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: i1__namespace$4.Actions }, { type: CartConnector }, { type: SaveCartConnector }, { type: UserIdService }, { type: i1__namespace$2.Store }]; }, propDecorators: { createWishList$: [], loadWishList$: [], resetWishList$: [] } });

    var activeCartInitialState = null;
    var activeCartDefaultState = '';
    var wishListInitialState = '';
    function activeCartReducer(state, action) {
        if (state === void 0) { state = activeCartDefaultState; }
        var _a, _b, _c;
        switch (action.type) {
            case LOAD_CART_SUCCESS:
            case CREATE_CART_SUCCESS:
            // point to `temp-${uuid}` cart when we are creating/merging cart
            case CREATE_CART:
                if ((_b = (_a = action === null || action === void 0 ? void 0 : action.payload) === null || _a === void 0 ? void 0 : _a.extraData) === null || _b === void 0 ? void 0 : _b.active) {
                    return action.meta.entityId;
                }
                else {
                    return state;
                }
            case SET_ACTIVE_CART_ID:
                return action.payload;
            case REMOVE_CART:
            case DELETE_CART_SUCCESS:
                if (((_c = action.payload) === null || _c === void 0 ? void 0 : _c.cartId) === state) {
                    return activeCartDefaultState;
                }
                return state;
            case CLEAR_CART_STATE:
                return state === activeCartInitialState
                    ? activeCartInitialState
                    : activeCartDefaultState;
        }
        return state;
    }
    var cartEntitiesInitialState = undefined;
    function cartEntitiesReducer(state, action) {
        if (state === void 0) { state = cartEntitiesInitialState; }
        switch (action.type) {
            case LOAD_CARTS_SUCCESS:
                return action.payload;
            case LOAD_CART_SUCCESS:
            case CREATE_CART_SUCCESS:
            case CREATE_WISH_LIST_SUCCESS:
            case LOAD_WISH_LIST_SUCCESS:
            case SET_TEMP_CART:
                return action.payload.cart;
        }
        return state;
    }
    function wishListReducer(state, action) {
        if (state === void 0) { state = wishListInitialState; }
        switch (action.type) {
            case CREATE_WISH_LIST_SUCCESS:
            case LOAD_WISH_LIST_SUCCESS:
                return action.meta.entityId;
            case CLEAR_CART_STATE:
                return wishListInitialState;
        }
        return state;
    }

    function clearMultiCartState(reducer) {
        return function (state, action) {
            if (action.type === LOGOUT) {
                state = undefined;
            }
            return reducer(state, action);
        };
    }
    var multiCartMetaReducers = [clearMultiCartState];
    var multiCartReducerToken = new i0.InjectionToken('MultiCartReducers');
    function getMultiCartReducers() {
        return {
            carts: entityProcessesLoaderReducer(MULTI_CART_DATA, cartEntitiesReducer),
            active: activeCartReducer,
            wishList: wishListReducer,
        };
    }
    var multiCartReducerProvider = {
        provide: multiCartReducerToken,
        useFactory: getMultiCartReducers,
    };

    var MultiCartStatePersistenceService = /** @class */ (function () {
        function MultiCartStatePersistenceService(statePersistenceService, store, siteContextParamsService) {
            this.statePersistenceService = statePersistenceService;
            this.store = store;
            this.siteContextParamsService = siteContextParamsService;
            this.subscription = new rxjs.Subscription();
        }
        MultiCartStatePersistenceService.prototype.initSync = function () {
            var _this = this;
            this.subscription.add(this.statePersistenceService.syncWithStorage({
                key: 'cart',
                state$: this.getCartState(),
                context$: this.siteContextParamsService.getValues([
                    BASE_SITE_CONTEXT_ID,
                ]),
                onRead: function (state) { return _this.onRead(state); },
            }));
        };
        MultiCartStatePersistenceService.prototype.getCartState = function () {
            return this.store.pipe(i1.select(getMultiCartState), operators.filter(function (state) { return !!state; }), operators.distinctUntilKeyChanged('active'), operators.map(function (state) {
                return {
                    active: state.active,
                };
            }));
        };
        MultiCartStatePersistenceService.prototype.onRead = function (state) {
            this.store.dispatch(new ClearCartState());
            if (state) {
                this.store.dispatch(new SetActiveCartId(state.active));
            }
            else {
                this.store.dispatch(new SetActiveCartId(''));
            }
        };
        MultiCartStatePersistenceService.prototype.ngOnDestroy = function () {
            this.subscription.unsubscribe();
        };
        return MultiCartStatePersistenceService;
    }());
    MultiCartStatePersistenceService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: MultiCartStatePersistenceService, deps: [{ token: StatePersistenceService }, { token: i1__namespace$2.Store }, { token: SiteContextParamsService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    MultiCartStatePersistenceService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: MultiCartStatePersistenceService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: MultiCartStatePersistenceService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: StatePersistenceService }, { type: i1__namespace$2.Store }, { type: SiteContextParamsService }]; } });

    function cartStatePersistenceFactory(cartStatePersistenceService, configInit) {
        var result = function () { return configInit
            .getStable('context')
            .pipe(operators.tap(function () {
            cartStatePersistenceService.initSync();
        }))
            .toPromise(); };
        return result;
    }
    /**
     * Before `MultiCartStatePersistenceService` restores the active cart id `ActiveCartService`
     * will use `current` cart instead of the one saved in browser. This meta reducer
     * sets the value on store initialization to null cart which holds active cart loading
     * until the data from storage is restored.
     */
    function uninitializeActiveCartMetaReducerFactory() {
        var metaReducer = function (reducer) { return function (state, action) {
            var newState = Object.assign({}, state);
            if (action.type === '@ngrx/store/init') {
                newState.cart = Object.assign(Object.assign({}, newState.cart), { active: activeCartInitialState });
            }
            return reducer(newState, action);
        }; };
        return metaReducer;
    }
    /**
     * Complimentary module for cart to store cart id in browser storage.
     * This makes it possible to work on the same anonymous cart even after page refresh.
     */
    var CartPersistenceModule = /** @class */ (function () {
        function CartPersistenceModule() {
        }
        CartPersistenceModule.forRoot = function () {
            return {
                ngModule: CartPersistenceModule,
                providers: [
                    {
                        provide: i0.APP_INITIALIZER,
                        useFactory: cartStatePersistenceFactory,
                        deps: [MultiCartStatePersistenceService, ConfigInitializerService],
                        multi: true,
                    },
                    {
                        provide: i1.META_REDUCERS,
                        useFactory: uninitializeActiveCartMetaReducerFactory,
                        multi: true,
                    },
                ],
            };
        };
        return CartPersistenceModule;
    }());
    CartPersistenceModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartPersistenceModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    CartPersistenceModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartPersistenceModule });
    CartPersistenceModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartPersistenceModule });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartPersistenceModule, decorators: [{
                type: i0.NgModule
            }] });

    /**
     * Base cart event. Most cart events should have these properties.
     */
    var CartEvent = /** @class */ (function (_super) {
        __extends(CartEvent, _super);
        function CartEvent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return CartEvent;
    }(CxEvent));
    // =====================================================================
    var CartAddEntryEvent = /** @class */ (function (_super) {
        __extends(CartAddEntryEvent, _super);
        function CartAddEntryEvent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return CartAddEntryEvent;
    }(CartEvent));
    /**
     * Event's type
     */
    CartAddEntryEvent.type = 'CartAddEntryEvent';
    var CartAddEntrySuccessEvent = /** @class */ (function (_super) {
        __extends(CartAddEntrySuccessEvent, _super);
        function CartAddEntrySuccessEvent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return CartAddEntrySuccessEvent;
    }(CartEvent));
    /**
     * Event's type
     */
    CartAddEntrySuccessEvent.type = 'CartAddEntrySuccessEvent';
    var CartAddEntryFailEvent = /** @class */ (function (_super) {
        __extends(CartAddEntryFailEvent, _super);
        function CartAddEntryFailEvent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return CartAddEntryFailEvent;
    }(CartEvent));
    /**
     * Event's type
     */
    CartAddEntryFailEvent.type = 'CartAddEntryFailEvent';
    var CartRemoveEntryFailEvent = /** @class */ (function (_super) {
        __extends(CartRemoveEntryFailEvent, _super);
        function CartRemoveEntryFailEvent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return CartRemoveEntryFailEvent;
    }(CartEvent));
    /**
     * Event's type
     */
    CartRemoveEntryFailEvent.type = 'CartRemoveEntryFailEvent';
    var CartRemoveEntrySuccessEvent = /** @class */ (function (_super) {
        __extends(CartRemoveEntrySuccessEvent, _super);
        function CartRemoveEntrySuccessEvent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return CartRemoveEntrySuccessEvent;
    }(CartEvent));
    /**
     * Event's type
     */
    CartRemoveEntrySuccessEvent.type = 'CartRemoveEntrySuccessEvent';
    var CartUpdateEntrySuccessEvent = /** @class */ (function (_super) {
        __extends(CartUpdateEntrySuccessEvent, _super);
        function CartUpdateEntrySuccessEvent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return CartUpdateEntrySuccessEvent;
    }(CartEvent));
    /**
     * Event's type
     */
    CartUpdateEntrySuccessEvent.type = 'CartUpdateEntrySuccessEvent';
    var CartUpdateEntryFailEvent = /** @class */ (function (_super) {
        __extends(CartUpdateEntryFailEvent, _super);
        function CartUpdateEntryFailEvent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return CartUpdateEntryFailEvent;
    }(CartEvent));
    /**
     * Event's type
     */
    CartUpdateEntryFailEvent.type = 'CartUpdateEntryFailEvent';
    var MergeCartSuccessEvent = /** @class */ (function (_super) {
        __extends(MergeCartSuccessEvent, _super);
        function MergeCartSuccessEvent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return MergeCartSuccessEvent;
    }(CartEvent));
    /**
     * Event's type
     */
    MergeCartSuccessEvent.type = 'MergeCartSuccessEvent';

    // Email Standard RFC 5322:
    var EMAIL_PATTERN = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/; // eslint-disable-line
    var PASSWORD_PATTERN = /^(?=.*?[A-Z])(?=.*?[0-9])(?=.*?[!@#$%^*()_\-+{};:.,]).{6,}$/;

    var MultiCartService = /** @class */ (function () {
        function MultiCartService(store, userIdService) {
            this.store = store;
            this.userIdService = userIdService;
        }
        /**
         * Returns cart from store as an observable
         *
         * @param cartId
         */
        MultiCartService.prototype.getCart = function (cartId) {
            return this.store.pipe(i1.select(getCartSelectorFactory(cartId)));
        };
        /**
         * Returns a list of carts from store as an observable
         *
         */
        MultiCartService.prototype.getCarts = function () {
            return this.store.pipe(i1.select(getCartsSelectorFactory));
        };
        /**
         * Returns cart entity from store (cart with loading, error, success flags) as an observable
         *
         * @param cartId
         */
        MultiCartService.prototype.getCartEntity = function (cartId) {
            return this.store.pipe(i1.select(getCartEntitySelectorFactory(cartId)));
        };
        /**
         * Returns true when there are no operations on that in progress and it is not currently loading
         *
         * @param cartId
         */
        MultiCartService.prototype.isStable = function (cartId) {
            return this.store.pipe(i1.select(getCartIsStableSelectorFactory(cartId)), 
            // We dispatch a lot of actions just after finishing some process or loading, so we want this flag not to flicker.
            // This flickering should only be avoided when switching from false to true
            // Start of loading should be showed instantly (no debounce)
            // Extra actions are only dispatched after some loading
            operators.debounce(function (isStable) { return (isStable ? rxjs.timer(0) : rxjs.EMPTY); }), operators.distinctUntilChanged());
        };
        /**
         * Simple random temp cart id generator
         */
        MultiCartService.prototype.generateTempCartId = function () {
            var pseudoUuid = Math.random().toString(36).substr(2, 9);
            return "temp-" + pseudoUuid;
        };
        /**
         * Create or merge cart
         *
         * @param params Object with userId, oldCartId, toMergeCartGuid and extraData
         */
        MultiCartService.prototype.createCart = function (_a) {
            var userId = _a.userId, oldCartId = _a.oldCartId, toMergeCartGuid = _a.toMergeCartGuid, extraData = _a.extraData;
            // to support creating multiple carts at the same time we need to use different entity for every process
            // simple random uuid generator is used here for entity names
            var tempCartId = this.generateTempCartId();
            this.store.dispatch(new CreateCart({
                extraData: extraData,
                userId: userId,
                oldCartId: oldCartId,
                toMergeCartGuid: toMergeCartGuid,
                tempCartId: tempCartId,
            }));
            return this.getCartEntity(tempCartId);
        };
        /**
         * Merge provided cart to current user cart
         *
         * @param params Object with userId, cartId and extraData
         */
        MultiCartService.prototype.mergeToCurrentCart = function (_a) {
            var userId = _a.userId, cartId = _a.cartId, extraData = _a.extraData;
            var tempCartId = this.generateTempCartId();
            this.store.dispatch(new MergeCart({
                userId: userId,
                cartId: cartId,
                extraData: extraData,
                tempCartId: tempCartId,
            }));
        };
        /**
         * Load cart
         *
         * @param params Object with userId, cartId and extraData
         */
        MultiCartService.prototype.loadCart = function (_a) {
            var cartId = _a.cartId, userId = _a.userId, extraData = _a.extraData;
            this.store.dispatch(new LoadCart({
                userId: userId,
                cartId: cartId,
                extraData: extraData,
            }));
        };
        /**
         * Get cart entries as an observable
         * @param cartId
         */
        MultiCartService.prototype.getEntries = function (cartId) {
            return this.store.pipe(i1.select(getCartEntriesSelectorFactory(cartId)));
        };
        /**
         * Get last entry for specific product code from cart.
         * Needed to cover processes where multiple entries can share the same product code
         * (e.g. promotions or configurable products)
         *
         * @param cartId
         * @param productCode
         */
        MultiCartService.prototype.getLastEntry = function (cartId, productCode) {
            return this.store.pipe(i1.select(getCartEntriesSelectorFactory(cartId)), operators.map(function (entries) {
                var filteredEntries = entries.filter(function (entry) { return entry.product.code === productCode; });
                return filteredEntries
                    ? filteredEntries[filteredEntries.length - 1]
                    : undefined;
            }));
        };
        /**
         * Add entry to cart
         *
         * @param userId
         * @param cartId
         * @param productCode
         * @param quantity
         */
        MultiCartService.prototype.addEntry = function (userId, cartId, productCode, quantity) {
            this.store.dispatch(new CartAddEntry({
                userId: userId,
                cartId: cartId,
                productCode: productCode,
                quantity: quantity,
            }));
        };
        /**
         * Add multiple entries to cart
         *
         * @param userId
         * @param cartId
         * @param products Array with items (productCode and quantity)
         */
        MultiCartService.prototype.addEntries = function (userId, cartId, products) {
            var _this = this;
            products.forEach(function (product) {
                _this.store.dispatch(new CartAddEntry({
                    userId: userId,
                    cartId: cartId,
                    productCode: product.productCode,
                    quantity: product.quantity,
                }));
            });
        };
        /**
         * Remove entry from cart
         *
         * @param userId
         * @param cartId
         * @param entryNumber
         */
        MultiCartService.prototype.removeEntry = function (userId, cartId, entryNumber) {
            this.store.dispatch(new CartRemoveEntry({
                userId: userId,
                cartId: cartId,
                entryNumber: "" + entryNumber,
            }));
        };
        /**
         * Update entry in cart. For quantity = 0 it removes entry
         *
         * @param userId
         * @param cartId
         * @param entryNumber
         * @param quantity
         */
        MultiCartService.prototype.updateEntry = function (userId, cartId, entryNumber, quantity) {
            if (quantity > 0) {
                this.store.dispatch(new CartUpdateEntry({
                    userId: userId,
                    cartId: cartId,
                    entryNumber: "" + entryNumber,
                    quantity: quantity,
                }));
            }
            else {
                this.removeEntry(userId, cartId, entryNumber);
            }
        };
        /**
         * Get first entry from cart matching the specified product code
         *
         * @param cartId
         * @param productCode
         */
        MultiCartService.prototype.getEntry = function (cartId, productCode) {
            return this.store.pipe(i1.select(getCartEntrySelectorFactory(cartId, productCode)));
        };
        /**
         * Assign email to the cart
         *
         * @param cartId
         * @param userId
         * @param email
         */
        MultiCartService.prototype.assignEmail = function (cartId, userId, email) {
            this.store.dispatch(new AddEmailToCart({
                userId: userId,
                cartId: cartId,
                email: email,
            }));
        };
        /**
         * Delete cart
         *
         * @param cartId
         * @param userId
         */
        MultiCartService.prototype.deleteCart = function (cartId, userId) {
            this.store.dispatch(new DeleteCart({
                userId: userId,
                cartId: cartId,
            }));
        };
        /**
         * Reloads the cart with specified id.
         *
         * @param cartId
         * @param extraData
         */
        MultiCartService.prototype.reloadCart = function (cartId, extraData) {
            var _this = this;
            this.userIdService.takeUserId().subscribe(function (userId) { return _this.store.dispatch(new LoadCart({
                userId: userId,
                cartId: cartId,
                extraData: extraData,
            })); });
        };
        return MultiCartService;
    }());
    MultiCartService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: MultiCartService, deps: [{ token: i1__namespace$2.Store }, { token: UserIdService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    MultiCartService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: MultiCartService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: MultiCartService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace$2.Store }, { type: UserIdService }]; } });

    var ActiveCartService = /** @class */ (function () {
        function ActiveCartService(store, multiCartService, userIdService) {
            var _this = this;
            this.store = store;
            this.multiCartService = multiCartService;
            this.userIdService = userIdService;
            this.subscription = new rxjs.Subscription();
            // This stream is used for referencing carts in API calls.
            this.activeCartId$ = this.userIdService.getUserId().pipe(
            // We want to wait with initialization of cartId until we have userId initialized
            // We have take(1) to not trigger this stream, when userId changes.
            operators.take(1), operators.switchMapTo(this.store), i1.select(getActiveCartId), 
            // We also wait until we initialize cart from localStorage. Before that happens cartId in store === null
            operators.filter(function (cartId) { return cartId !== activeCartInitialState; }), operators.map(function (cartId) {
                if (cartId === '') {
                    // We fallback to current when we don't have particular cart id -> cartId === '', because that's how you reference latest user cart.
                    return OCC_CART_ID_CURRENT;
                }
                return cartId;
            }));
            // Stream with active cart entity
            this.cartSelector$ = this.activeCartId$.pipe(operators.switchMap(function (cartId) { return _this.multiCartService.getCartEntity(cartId); }));
            this.initActiveCart();
        }
        ActiveCartService.prototype.ngOnDestroy = function () {
            this.subscription.unsubscribe();
        };
        ActiveCartService.prototype.initActiveCart = function () {
            var _this = this;
            // Any change of user id is also interesting for us, because we have to merge/load/switch cart in those cases.
            this.subscription.add(this.userIdService
                .getUserId()
                .pipe(
            // We never trigger cart merge/load on app initialization here and that's why we wait with pairwise for a change of userId (not initialization).
            operators.pairwise(), operators.switchMap(function (_b) {
                var _c = __read(_b, 2), previousUserId = _c[0], userId = _c[1];
                // We need cartId once we have the previous and current userId. We don't want to subscribe to cartId stream before.
                return rxjs.combineLatest([
                    rxjs.of(previousUserId),
                    rxjs.of(userId),
                    _this.activeCartId$,
                ]).pipe(operators.take(1));
            }))
                .subscribe(function (_b) {
                var _c = __read(_b, 3), previousUserId = _c[0], userId = _c[1], cartId = _c[2];
                // Only change of user and not a logout (current user id !== anonymous) should trigger loading mechanism
                if (_this.isJustLoggedIn(userId, previousUserId)) {
                    _this.loadOrMerge(cartId, userId, previousUserId);
                }
            }));
            // Stream for getting the cart value
            var activeCartValue$ = this.cartSelector$.pipe(operators.map(function (cartEntity) {
                return {
                    cart: cartEntity.value,
                    isStable: !cartEntity.loading && cartEntity.processesCount === 0,
                    loaded: (cartEntity.error || cartEntity.success) && !cartEntity.loading,
                };
            }), 
            // we want to emit empty carts even if those are not stable
            // on merge cart action we want to switch to empty cart so no one would use old cartId which can be already obsolete
            // so on merge action the resulting stream looks like this: old_cart -> {} -> new_cart
            operators.filter(function (_b) {
                var isStable = _b.isStable, cart = _b.cart;
                return isStable || _this.isEmpty(cart);
            }));
            // Responsible for loading cart when it's not (eg. app initialization when we have only cart id)
            var activeCartLoading$ = activeCartValue$.pipe(operators.withLatestFrom(this.activeCartId$, this.userIdService.getUserId()), operators.tap(function (_b) {
                var _c = __read(_b, 3), _d = _c[0], cart = _d.cart, loaded = _d.loaded, isStable = _d.isStable, cartId = _c[1], userId = _c[2];
                if (isStable &&
                    _this.isEmpty(cart) &&
                    !loaded &&
                    !isTempCartId(cartId)) {
                    _this.load(cartId, userId);
                }
            }));
            this.activeCart$ = rxjs.using(function () { return activeCartLoading$.subscribe(); }, function () { return activeCartValue$; }).pipe(
            // Normalization for empty cart value. It will always be returned as empty object.
            operators.map(function (_b) {
                var cart = _b.cart;
                return (cart ? cart : {});
            }), operators.distinctUntilChanged(), operators.shareReplay({ bufferSize: 1, refCount: true }));
        };
        /**
         * Returns active cart
         */
        ActiveCartService.prototype.getActive = function () {
            return this.activeCart$;
        };
        /**
         * Waits for the cart to be stable before returning the active cart.
         */
        ActiveCartService.prototype.takeActive = function () {
            var _this = this;
            return this.isStable().pipe(operators.filter(function (isStable) { return isStable; }), operators.switchMap(function () { return _this.getActive(); }), operators.filter(function (cart) { return !!cart; }), operators.take(1));
        };
        /**
         * Returns active cart id
         */
        ActiveCartService.prototype.getActiveCartId = function () {
            return this.activeCart$.pipe(operators.withLatestFrom(this.userIdService.getUserId()), operators.map(function (_b) {
                var _c = __read(_b, 2), cart = _c[0], userId = _c[1];
                return getCartIdByUserId(cart, userId);
            }), operators.distinctUntilChanged());
        };
        /**
         * Returns cart entries
         */
        ActiveCartService.prototype.getEntries = function () {
            var _this = this;
            return this.activeCartId$.pipe(operators.switchMap(function (cartId) { return _this.multiCartService.getEntries(cartId); }), operators.distinctUntilChanged());
        };
        /**
         * Returns last cart entry for provided product code.
         * Needed to cover processes where multiple entries can share the same product code
         * (e.g. promotions or configurable products)
         *
         * @param productCode
         */
        ActiveCartService.prototype.getLastEntry = function (productCode) {
            var _this = this;
            return this.activeCartId$.pipe(operators.switchMap(function (cartId) { return _this.multiCartService.getLastEntry(cartId, productCode); }), operators.distinctUntilChanged());
        };
        /**
         * Returns cart loading state
         */
        ActiveCartService.prototype.getLoading = function () {
            return this.cartSelector$.pipe(operators.map(function (cartEntity) { return cartEntity.loading; }), operators.distinctUntilChanged());
        };
        /**
         * Returns true when cart is stable (not loading and not pending processes on cart)
         */
        ActiveCartService.prototype.isStable = function () {
            var _this = this;
            // Debounce is used here, to avoid flickering when we switch between different cart entities.
            // For example during `addEntry` method. We might try to load current cart, so `current cart will be then active id.
            // After load fails we might create new cart so we switch to `temp-${uuid}` cart entity used when creating cart.
            // At the end we finally switch to cart `code` for cart id. Between those switches cart `isStable` function should not flicker.
            return this.activeCartId$.pipe(operators.switchMap(function (cartId) { return _this.multiCartService.isStable(cartId); }), operators.debounce(function (state) { return (state ? rxjs.timer(0) : rxjs.EMPTY); }), operators.distinctUntilChanged());
        };
        /**
         * Loads cart or upon login, whenever there's an existing cart, merge it into the current user cart
         * cartId will be defined (not '', null, undefined)
         */
        ActiveCartService.prototype.loadOrMerge = function (cartId, userId, previousUserId) {
            if (cartId === OCC_CART_ID_CURRENT) {
                this.multiCartService.loadCart({
                    userId: userId,
                    cartId: OCC_CART_ID_CURRENT,
                    extraData: {
                        active: true,
                    },
                });
            }
            else if (this.isGuestCart()) {
                this.guestCartMerge(cartId);
            }
            else if (userId !== previousUserId &&
                userId !== OCC_USER_ID_ANONYMOUS &&
                previousUserId !== OCC_USER_ID_ANONYMOUS) {
                // This case covers the case when you are logged in and then asm user logs in and you don't want to merge, but only load emulated user cart
                // Similarly when you are logged in as asm user and you logout and want to resume previous user session
                this.multiCartService.loadCart({
                    userId: userId,
                    cartId: cartId,
                    extraData: {
                        active: true,
                    },
                });
            }
            else {
                // We have particular cart locally, but we logged in, so we need to combine this with current cart or make it ours.
                this.multiCartService.mergeToCurrentCart({
                    userId: userId,
                    cartId: cartId,
                    extraData: {
                        active: true,
                    },
                });
            }
        };
        /**
         * Loads cart in every case apart from anonymous user and current cart combination
         */
        ActiveCartService.prototype.load = function (cartId, userId) {
            if (!(userId === OCC_USER_ID_ANONYMOUS && cartId === OCC_CART_ID_CURRENT)) {
                this.multiCartService.loadCart({
                    userId: userId,
                    cartId: cartId,
                    extraData: {
                        active: true,
                    },
                });
            }
        };
        /**
         * Adds entries from guest cart to user cart
         */
        ActiveCartService.prototype.addEntriesGuestMerge = function (cartEntries) {
            var _this = this;
            var entriesToAdd = cartEntries.map(function (entry) { return ({
                productCode: entry.product.code,
                quantity: entry.quantity,
            }); });
            this.requireLoadedCartForGuestMerge()
                .pipe(operators.withLatestFrom(this.userIdService.getUserId()))
                .subscribe(function (_b) {
                var _c = __read(_b, 2), cartState = _c[0], userId = _c[1];
                _this.multiCartService.addEntries(userId, getCartIdByUserId(cartState.value, userId), entriesToAdd);
            });
        };
        /**
         * Helper method for requiring loaded cart that is not a guest cart (guest cart is filtered out).
         * Used when merging guest cart with user cart.
         */
        ActiveCartService.prototype.requireLoadedCartForGuestMerge = function () {
            var _this = this;
            return this.requireLoadedCart(this.cartSelector$.pipe(operators.filter(function () { return !_this.isGuestCart(); })));
        };
        ActiveCartService.prototype.isCartCreating = function (cartState, cartId) {
            // cart creating is always represented with loading flags
            // when all loading flags are false it means that we restored wrong cart id
            // could happen on context change or reload right in the middle on cart create call
            return (isTempCartId(cartId) &&
                (cartState.loading || cartState.success || cartState.error));
        };
        ActiveCartService.prototype.requireLoadedCart = function (customCartSelector$) {
            var _this = this;
            // For guest cart merge we want to filter guest cart in the whole stream
            // We have to wait with load/create/addEntry after guest cart will be deleted.
            // That's why you can provide custom selector with this filter applied.
            var cartSelector$ = customCartSelector$
                ? customCartSelector$
                : this.cartSelector$;
            return cartSelector$.pipe(operators.filter(function (cartState) { return !cartState.loading; }), 
            // Avoid load/create call when there are new cart creating at the moment
            operators.withLatestFrom(this.activeCartId$), operators.filter(function (_b) {
                var _c = __read(_b, 2), cartState = _c[0], cartId = _c[1];
                return !_this.isCartCreating(cartState, cartId);
            }), operators.map(function (_b) {
                var _c = __read(_b, 1), cartState = _c[0];
                return cartState;
            }), operators.take(1), operators.withLatestFrom(this.userIdService.getUserId()), operators.tap(function (_b) {
                var _c = __read(_b, 2), cartState = _c[0], userId = _c[1];
                // Try to load the cart, because it might have been created on another device between our login and add entry call
                if (_this.isEmpty(cartState.value) && userId !== OCC_USER_ID_ANONYMOUS) {
                    _this.load(OCC_CART_ID_CURRENT, userId);
                }
            }), operators.switchMap(function () {
                return cartSelector$;
            }), operators.filter(function (cartState) { return !cartState.loading; }), 
            // create cart can happen to anonymous user if it is not empty or to any other user if it is loaded and empty
            operators.withLatestFrom(this.userIdService.getUserId()), operators.filter(function (_b) {
                var _c = __read(_b, 2), cartState = _c[0], userId = _c[1];
                return userId === OCC_USER_ID_ANONYMOUS ||
                    cartState.success ||
                    cartState.error;
            }), operators.take(1), operators.tap(function (_b) {
                var _c = __read(_b, 2), cartState = _c[0], userId = _c[1];
                if (_this.isEmpty(cartState.value)) {
                    _this.multiCartService.createCart({
                        userId: userId,
                        extraData: {
                            active: true,
                        },
                    });
                }
            }), operators.switchMap(function () {
                return cartSelector$;
            }), operators.filter(function (cartState) { return !cartState.loading; }), operators.filter(function (cartState) { return cartState.success || cartState.error; }), 
            // wait for active cart id to point to code/guid to avoid some work on temp cart entity
            operators.withLatestFrom(this.activeCartId$), operators.filter(function (_b) {
                var _c = __read(_b, 2), cartState = _c[0], cartId = _c[1];
                return !_this.isCartCreating(cartState, cartId);
            }), operators.map(function (_b) {
                var _c = __read(_b, 1), cartState = _c[0];
                return cartState;
            }), operators.filter(function (cartState) { return !_this.isEmpty(cartState.value); }), operators.take(1));
        };
        /**
         * Add entry to active cart
         *
         * @param productCode
         * @param quantity
         */
        ActiveCartService.prototype.addEntry = function (productCode, quantity) {
            var _this = this;
            // TODO(#13645): Support multiple, simultaneous invocation of this function, when cart is not loaded/created
            this.requireLoadedCart()
                .pipe(operators.withLatestFrom(this.userIdService.getUserId()))
                .subscribe(function (_b) {
                var _c = __read(_b, 2), cartState = _c[0], userId = _c[1];
                _this.multiCartService.addEntry(userId, getCartIdByUserId(cartState.value, userId), productCode, quantity);
            });
        };
        /**
         * Remove entry
         *
         * @param entry
         */
        ActiveCartService.prototype.removeEntry = function (entry) {
            var _this = this;
            this.activeCartId$
                .pipe(operators.withLatestFrom(this.userIdService.getUserId()), operators.take(1))
                .subscribe(function (_b) {
                var _c = __read(_b, 2), cartId = _c[0], userId = _c[1];
                _this.multiCartService.removeEntry(userId, cartId, entry.entryNumber);
            });
        };
        /**
         * Update entry
         *
         * @param entryNumber
         * @param quantity
         */
        ActiveCartService.prototype.updateEntry = function (entryNumber, quantity) {
            var _this = this;
            this.activeCartId$
                .pipe(operators.withLatestFrom(this.userIdService.getUserId()), operators.take(1))
                .subscribe(function (_b) {
                var _c = __read(_b, 2), cartId = _c[0], userId = _c[1];
                _this.multiCartService.updateEntry(userId, cartId, entryNumber, quantity);
            });
        };
        /**
         * Returns cart entry
         *
         * @param productCode
         */
        ActiveCartService.prototype.getEntry = function (productCode) {
            var _this = this;
            return this.activeCartId$.pipe(operators.switchMap(function (cartId) { return _this.multiCartService.getEntry(cartId, productCode); }), operators.distinctUntilChanged());
        };
        /**
         * Assign email to cart
         *
         * @param email
         */
        ActiveCartService.prototype.addEmail = function (email) {
            var _this = this;
            this.activeCartId$
                .pipe(operators.withLatestFrom(this.userIdService.getUserId()), operators.take(1))
                .subscribe(function (_b) {
                var _c = __read(_b, 2), cartId = _c[0], userId = _c[1];
                _this.multiCartService.assignEmail(cartId, userId, email);
            });
        };
        /**
         * Get assigned user to cart
         */
        ActiveCartService.prototype.getAssignedUser = function () {
            return this.getActive().pipe(operators.map(function (cart) { return cart.user; }));
        };
        // TODO: Make cart required param in 4.0 and drop the subscribe/unsubscribe.
        /**
         * Returns true for guest cart
         */
        ActiveCartService.prototype.isGuestCart = function (cart) {
            if (!cart) {
                this.activeCart$
                    .subscribe(function (activeCart) { return (cart = activeCart); })
                    .unsubscribe();
            }
            var cartUser = cart === null || cart === void 0 ? void 0 : cart.user;
            return (cartUser &&
                (cartUser.name === OCC_USER_ID_GUEST ||
                    this.isEmail(cartUser.uid.split('|').slice(1).join('|'))));
        };
        /**
         * Add multiple entries to a cart
         *
         * @param cartEntries : list of entries to add (OrderEntry[])
         */
        ActiveCartService.prototype.addEntries = function (cartEntries) {
            var _this = this;
            var entriesToAdd = cartEntries.map(function (entry) {
                var _a;
                return ({
                    productCode: (_a = entry.product) === null || _a === void 0 ? void 0 : _a.code,
                    quantity: entry.quantity,
                });
            });
            this.requireLoadedCart()
                .pipe(operators.withLatestFrom(this.userIdService.getUserId()))
                .subscribe(function (_b) {
                var _c = __read(_b, 2), cartState = _c[0], userId = _c[1];
                if (cartState.value) {
                    _this.multiCartService.addEntries(userId, getCartIdByUserId(cartState.value, userId), entriesToAdd);
                }
            });
        };
        /**
         * Indicates if given string is matching email pattern
         */
        ActiveCartService.prototype.isEmail = function (str) {
            if (str) {
                return str.match(EMAIL_PATTERN) ? true : false;
            }
            return false;
        };
        // TODO: Remove once backend is updated
        /**
         * Temporary method to merge guest cart with user cart because of backend limitation
         * This is for an edge case
         */
        ActiveCartService.prototype.guestCartMerge = function (cartId) {
            var _this = this;
            var cartEntries;
            this.getEntries()
                .pipe(operators.take(1))
                .subscribe(function (entries) {
                cartEntries = entries;
                _this.multiCartService.deleteCart(cartId, OCC_USER_ID_ANONYMOUS);
                _this.addEntriesGuestMerge(cartEntries);
            });
        };
        /**
         * Indicates if given cart is empty.
         * Returns true is cart is undefined, null or is an empty object.
         */
        ActiveCartService.prototype.isEmpty = function (cart) {
            return (!cart || (typeof cart === 'object' && Object.keys(cart).length === 0));
        };
        /**
         * Indicates if a given user is logged in on account different than preceding user account
         */
        ActiveCartService.prototype.isJustLoggedIn = function (userId, previousUserId) {
            return (userId !== OCC_USER_ID_ANONYMOUS && // not logged out
                previousUserId !== userId // *just* logged in / switched to ASM emulation
            );
        };
        /**
         * Reloads active cart
         */
        ActiveCartService.prototype.reloadActiveCart = function () {
            var _this = this;
            rxjs.combineLatest([this.getActiveCartId(), this.userIdService.takeUserId()])
                .pipe(operators.take(1), operators.map(function (_b) {
                var _c = __read(_b, 2), cartId = _c[0], userId = _c[1];
                _this.multiCartService.loadCart({ cartId: cartId, userId: userId });
            }))
                .subscribe();
        };
        return ActiveCartService;
    }());
    ActiveCartService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ActiveCartService, deps: [{ token: i1__namespace$2.Store }, { token: MultiCartService }, { token: UserIdService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ActiveCartService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ActiveCartService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ActiveCartService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace$2.Store }, { type: MultiCartService }, { type: UserIdService }]; } });

    /**
     * Registers events for the active cart
     */
    var CartEventBuilder = /** @class */ (function () {
        function CartEventBuilder(actionsSubject, event, activeCartService) {
            this.actionsSubject = actionsSubject;
            this.event = event;
            this.activeCartService = activeCartService;
            this.register();
        }
        /**
         * Registers events for the active cart
         */
        CartEventBuilder.prototype.register = function () {
            this.registerAddEntry();
            this.registerRemoveEntry();
            this.registerUpdateEntry();
            this.registerMergeCartSuccess();
        };
        /**
         * Register events for adding entry to the active cart
         */
        CartEventBuilder.prototype.registerAddEntry = function () {
            this.registerMapped({
                action: CART_ADD_ENTRY,
                event: CartAddEntryEvent,
            });
            this.registerMapped({
                action: CART_ADD_ENTRY_SUCCESS,
                event: CartAddEntrySuccessEvent,
            });
            this.registerMapped({
                action: CART_ADD_ENTRY_FAIL,
                event: CartAddEntryFailEvent,
            });
        };
        CartEventBuilder.prototype.registerRemoveEntry = function () {
            this.registerMapped({
                action: CART_REMOVE_ENTRY_SUCCESS,
                event: CartRemoveEntrySuccessEvent,
            });
            this.registerMapped({
                action: CART_REMOVE_ENTRY_FAIL,
                event: CartRemoveEntryFailEvent,
            });
        };
        CartEventBuilder.prototype.registerUpdateEntry = function () {
            this.registerMapped({
                action: CART_UPDATE_ENTRY_SUCCESS,
                event: CartUpdateEntrySuccessEvent,
            });
            this.registerMapped({
                action: CART_UPDATE_ENTRY_FAIL,
                event: CartUpdateEntryFailEvent,
            });
        };
        CartEventBuilder.prototype.registerMergeCartSuccess = function () {
            this.registerMapped({
                action: MERGE_CART_SUCCESS,
                event: MergeCartSuccessEvent,
            });
        };
        /**
         * Registers a stream of target events mapped from the source actions that contain the cart id equal to the active cart id.
         *
         * @param mapping mapping declaration - from `action` string type to `event` class type
         *   (an with optional `factory` function - by default `action.payload` will be assigned to the properties of the event instance).
         */
        CartEventBuilder.prototype.registerMapped = function (mapping) {
            var _this = this;
            var eventStream$ = this.getAction(mapping.action).pipe(operators.switchMap(function (action) {
                // SwitchMap was used instead of withLatestFrom, because we only want to subscribe to cart stream when action is dispatched.
                // Using withLatestFrom would trigger subscription to cart observables on event subscription and that causes side effects,
                // such as loading cart when we don't yet need it.
                return rxjs.of(action).pipe(operators.withLatestFrom(_this.activeCartService.getActive(), _this.activeCartService.getActiveCartId()));
            }), operators.filter(function (_a) {
                var _b = __read(_a, 3), action = _b[0], _activeCart = _b[1], activeCartId = _b[2];
                return action.payload['cartId'] === activeCartId;
            }), operators.map(function (_a) {
                var _b = __read(_a, 2), action = _b[0], activeCart = _b[1];
                return createFrom(mapping.event, Object.assign(Object.assign({}, action.payload), { cartCode: activeCart.code, entry: action.payload.entry
                        ? action.payload.entry
                        : activeCart.entries[Number(action.payload.entryNumber)] }));
            }));
            return this.event.register(mapping.event, eventStream$);
        };
        /**
         * Returns a stream of actions only of a given type(s)
         *
         * @param actionType type(s) of actions
         */
        CartEventBuilder.prototype.getAction = function (actionType) {
            return this.actionsSubject.pipe(i1$4.ofType.apply(void 0, __spreadArray([], __read([].concat(actionType)))));
        };
        return CartEventBuilder;
    }());
    CartEventBuilder.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartEventBuilder, deps: [{ token: i1__namespace$2.ActionsSubject }, { token: EventService }, { token: ActiveCartService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    CartEventBuilder.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartEventBuilder, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartEventBuilder, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }], ctorParameters: function () { return [{ type: i1__namespace$2.ActionsSubject }, { type: EventService }, { type: ActiveCartService }]; } });

    var CartEventModule = /** @class */ (function () {
        function CartEventModule(_CartEventBuilder) {
        }
        return CartEventModule;
    }());
    CartEventModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartEventModule, deps: [{ token: CartEventBuilder }], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    CartEventModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartEventModule });
    CartEventModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartEventModule });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartEventModule, decorators: [{
                type: i0.NgModule,
                args: [{}]
            }], ctorParameters: function () { return [{ type: CartEventBuilder }]; } });

    var MultiCartEffects = /** @class */ (function () {
        function MultiCartEffects(actions$) {
            this.actions$ = actions$;
            this.setTempCart$ = this.actions$.pipe(i1$4.ofType(SET_TEMP_CART), operators.map(function (action) {
                return new RemoveCart({ cartId: action.payload.tempCartId });
            }));
            // TODO(#7241): Remove when we drop ADD_VOUCHER process and we sort out checkout and cart dependencies
            this.processesIncrement$ = this.actions$.pipe(i1$4.ofType(CART_ADD_VOUCHER), operators.map(function (action) { return action.payload; }), operators.map(function (payload) { return new CartProcessesIncrement(payload.cartId); }));
        }
        return MultiCartEffects;
    }());
    MultiCartEffects.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: MultiCartEffects, deps: [{ token: i1__namespace$4.Actions }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    MultiCartEffects.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: MultiCartEffects });
    __decorate([
        i1$4.Effect()
    ], MultiCartEffects.prototype, "setTempCart$", void 0);
    __decorate([
        i1$4.Effect()
    ], MultiCartEffects.prototype, "processesIncrement$", void 0);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: MultiCartEffects, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: i1__namespace$4.Actions }]; }, propDecorators: { setTempCart$: [], processesIncrement$: [] } });

    var effects$3 = [
        CartEffects,
        CartEntryEffects,
        CartVoucherEffects,
        WishListEffects,
        MultiCartEffects,
    ];
    var MultiCartStoreModule = /** @class */ (function () {
        function MultiCartStoreModule() {
        }
        return MultiCartStoreModule;
    }());
    MultiCartStoreModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: MultiCartStoreModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    MultiCartStoreModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: MultiCartStoreModule, imports: [i6.CommonModule,
            StateModule, i1__namespace$2.StoreFeatureModule, i1__namespace$4.EffectsFeatureModule] });
    MultiCartStoreModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: MultiCartStoreModule, providers: [multiCartReducerProvider], imports: [[
                i6.CommonModule,
                StateModule,
                i1.StoreModule.forFeature(MULTI_CART_FEATURE, multiCartReducerToken, {
                    metaReducers: multiCartMetaReducers,
                }),
                i1$4.EffectsModule.forFeature(effects$3),
            ]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: MultiCartStoreModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [
                            i6.CommonModule,
                            StateModule,
                            i1.StoreModule.forFeature(MULTI_CART_FEATURE, multiCartReducerToken, {
                                metaReducers: multiCartMetaReducers,
                            }),
                            i1$4.EffectsModule.forFeature(effects$3),
                        ],
                        providers: [multiCartReducerProvider],
                    }]
            }] });

    var CartModule = /** @class */ (function () {
        function CartModule() {
        }
        CartModule.forRoot = function () {
            return {
                ngModule: CartModule,
            };
        };
        return CartModule;
    }());
    CartModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    CartModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartModule, imports: [MultiCartStoreModule,
            CartEventModule, CartPersistenceModule] });
    CartModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartModule, imports: [[
                MultiCartStoreModule,
                CartEventModule,
                CartPersistenceModule.forRoot(),
            ]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [
                            MultiCartStoreModule,
                            CartEventModule,
                            CartPersistenceModule.forRoot(),
                        ],
                    }]
            }] });

    var CartConfig = /** @class */ (function () {
        function CartConfig() {
        }
        return CartConfig;
    }());
    CartConfig.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartConfig, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    CartConfig.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartConfig, providedIn: 'root', useExisting: Config });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartConfig, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                        useExisting: Config,
                    }]
            }] });

    var CART_NORMALIZER = new i0.InjectionToken('CartNormalizer');

    var CART_MODIFICATION_NORMALIZER = new i0.InjectionToken('CartModificationNormalizer');

    var SAVE_CART_NORMALIZER = new i0.InjectionToken('SaveCartNormalizer');

    var CART_VOUCHER_NORMALIZER = new i0.InjectionToken('CartVoucherNormalizer');

    var CART_VALIDATION_NORMALIZER = new i0.InjectionToken('CartValidationNormalizer');

    var CartValidationAdapter = /** @class */ (function () {
        function CartValidationAdapter() {
        }
        return CartValidationAdapter;
    }());

    var CartValidationConnector = /** @class */ (function () {
        function CartValidationConnector(adapter) {
            this.adapter = adapter;
        }
        CartValidationConnector.prototype.validate = function (cartId, userId) {
            return this.adapter.validate(cartId, userId);
        };
        return CartValidationConnector;
    }());
    CartValidationConnector.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartValidationConnector, deps: [{ token: CartValidationAdapter }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    CartValidationConnector.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartValidationConnector, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartValidationConnector, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: CartValidationAdapter }]; } });

    var CartVoucherService = /** @class */ (function () {
        function CartVoucherService(store, activeCartService, userIdService) {
            this.store = store;
            this.activeCartService = activeCartService;
            this.userIdService = userIdService;
        }
        CartVoucherService.prototype.addVoucher = function (voucherId, cartId) {
            var _this = this;
            this.combineUserAndCartId(cartId).subscribe(function (_a) {
                var _b = __read(_a, 2), occUserId = _b[0], cartIdentifier = _b[1];
                return _this.store.dispatch(new CartAddVoucher({
                    userId: occUserId,
                    cartId: cartIdentifier,
                    voucherId: voucherId,
                }));
            });
        };
        CartVoucherService.prototype.removeVoucher = function (voucherId, cartId) {
            var _this = this;
            this.combineUserAndCartId(cartId).subscribe(function (_a) {
                var _b = __read(_a, 2), occUserId = _b[0], cartIdentifier = _b[1];
                return _this.store.dispatch(new CartRemoveVoucher({
                    userId: occUserId,
                    cartId: cartIdentifier,
                    voucherId: voucherId,
                }));
            });
        };
        // TODO(#7241): Remove when switching to event system for add voucher
        /**
         * Get add voucher process error flag
         * @deprecated since 2.0
         */
        CartVoucherService.prototype.getAddVoucherResultError = function () {
            return this.store.pipe(i1.select(getProcessErrorFactory(ADD_VOUCHER_PROCESS_ID)));
        };
        // TODO(#7241): Remove when switching to event system for add voucher
        /**
         * Get add voucher process success flag
         * @deprecated since 2.0
         */
        CartVoucherService.prototype.getAddVoucherResultSuccess = function () {
            return this.store.pipe(i1.select(getProcessSuccessFactory(ADD_VOUCHER_PROCESS_ID)));
        };
        // TODO(#7241): Remove when switching to event system for add voucher
        /**
         * Get add voucher process loading flag
         * @deprecated since 2.0
         */
        CartVoucherService.prototype.getAddVoucherResultLoading = function () {
            return this.store.pipe(i1.select(getProcessLoadingFactory(ADD_VOUCHER_PROCESS_ID)));
        };
        // TODO(#7241): Remove when switching to event system for add voucher
        /**
         * Reset add voucher process
         * @deprecated since 2.0
         */
        CartVoucherService.prototype.resetAddVoucherProcessingState = function () {
            this.store.dispatch(new CartResetAddVoucher());
        };
        CartVoucherService.prototype.combineUserAndCartId = function (cartId) {
            if (cartId) {
                return this.userIdService.getUserId().pipe(operators.take(1), operators.map(function (userId) { return [userId, cartId]; }));
            }
            else {
                return rxjs.combineLatest([
                    this.userIdService.getUserId(),
                    this.activeCartService.getActiveCartId(),
                ]).pipe(operators.take(1));
            }
        };
        return CartVoucherService;
    }());
    CartVoucherService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartVoucherService, deps: [{ token: i1__namespace$2.Store }, { token: ActiveCartService }, { token: UserIdService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    CartVoucherService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartVoucherService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartVoucherService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace$2.Store }, { type: ActiveCartService }, { type: UserIdService }]; } });

    var UserAccountFacadeTransitionalToken = /** @class */ (function () {
        function UserAccountFacadeTransitionalToken() {
        }
        return UserAccountFacadeTransitionalToken;
    }());
    var UserProfileFacadeTransitionalToken = /** @class */ (function () {
        function UserProfileFacadeTransitionalToken() {
        }
        return UserProfileFacadeTransitionalToken;
    }());

    var UserService = /** @class */ (function () {
        function UserService(store, userIdService, 
        // TODO: Remove transitional tokens in 4.0 with #11607
        userAccountFacade, userProfileFacade) {
            this.store = store;
            this.userIdService = userIdService;
            this.userAccountFacade = userAccountFacade;
            this.userProfileFacade = userProfileFacade;
        }
        /**
         * Returns a user.
         *
         * @deprecated since 3.2, use `UserAccountFacade.get()` from `@spartacus/user` package.
         */
        UserService.prototype.get = function () {
            if (this.userAccountFacade) {
                return this.userAccountFacade.get();
            }
            throw Error('Cannot get a user. Install `@spartacus/user` library which provides required services.');
        };
        /**
         * Returns titles.
         *
         * @deprecated since 3.2, use `UserProfileFacade.getTitles()` from `@spartacus/user` package.
         */
        UserService.prototype.getTitles = function () {
            if (this.userProfileFacade) {
                return this.userProfileFacade.getTitles();
            }
            throw Error('Cannot get a titles. Install `@spartacus/user` library which provides required services.');
        };
        return UserService;
    }());
    UserService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserService, deps: [{ token: i1__namespace$2.Store }, { token: UserIdService }, { token: UserAccountFacadeTransitionalToken, optional: true }, { token: UserProfileFacadeTransitionalToken, optional: true }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    UserService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserService, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }], ctorParameters: function () {
            return [{ type: i1__namespace$2.Store }, { type: UserIdService }, { type: UserAccountFacadeTransitionalToken, decorators: [{
                            type: i0.Optional
                        }] }, { type: UserProfileFacadeTransitionalToken, decorators: [{
                            type: i0.Optional
                        }] }];
        } });

    var CartConfigService = /** @class */ (function () {
        function CartConfigService(config) {
            this.config = config;
        }
        CartConfigService.prototype.isSelectiveCartEnabled = function () {
            var _a, _b, _c;
            return Boolean((_c = (_b = (_a = this.config) === null || _a === void 0 ? void 0 : _a.cart) === null || _b === void 0 ? void 0 : _b.selectiveCart) === null || _c === void 0 ? void 0 : _c.enabled);
        };
        CartConfigService.prototype.isCartValidationEnabled = function () {
            var _a, _b, _c;
            return Boolean((_c = (_b = (_a = this.config) === null || _a === void 0 ? void 0 : _a.cart) === null || _b === void 0 ? void 0 : _b.validation) === null || _c === void 0 ? void 0 : _c.enabled);
        };
        return CartConfigService;
    }());
    CartConfigService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartConfigService, deps: [{ token: CartConfig }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    CartConfigService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartConfigService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartConfigService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: CartConfig }]; } });

    var SelectiveCartService = /** @class */ (function () {
        function SelectiveCartService(store, userService, multiCartService, baseSiteService, cartConfigService, userIdService) {
            var _this = this;
            this.store = store;
            this.userService = userService;
            this.multiCartService = multiCartService;
            this.baseSiteService = baseSiteService;
            this.cartConfigService = cartConfigService;
            this.userIdService = userIdService;
            this.cartId$ = new rxjs.BehaviorSubject(undefined);
            this.PREVIOUS_USER_ID_INITIAL_VALUE = 'PREVIOUS_USER_ID_INITIAL_VALUE';
            this.previousUserId = this.PREVIOUS_USER_ID_INITIAL_VALUE;
            this.cartSelector$ = this.cartId$.pipe(operators.switchMap(function (cartId) {
                _this.cartId = cartId;
                return _this.multiCartService.getCartEntity(cartId);
            }));
            rxjs.combineLatest([
                this.userService.get(),
                this.baseSiteService.getActive(),
            ]).subscribe(function (_a) {
                var _b = __read(_a, 2), user = _b[0], activeBaseSite = _b[1];
                if (user && user.customerId && activeBaseSite) {
                    _this.customerId = user.customerId;
                    _this.cartId$.next("selectivecart" + activeBaseSite + _this.customerId);
                }
                else if (user && !user.customerId) {
                    _this.cartId$.next(undefined);
                }
            });
            this.userIdService.getUserId().subscribe(function (userId) {
                _this.userId = userId;
                if (_this.isJustLoggedIn(userId)) {
                    _this.load();
                }
                _this.previousUserId = userId;
            });
            this.selectiveCart$ = this.cartSelector$.pipe(operators.map(function (cartEntity) {
                return {
                    cart: cartEntity.value,
                    loading: cartEntity.loading,
                    loaded: (cartEntity.error || cartEntity.success) && !cartEntity.loading,
                };
            }), operators.filter(function (_a) {
                var loading = _a.loading;
                return !loading;
            }), operators.tap(function (_a) {
                var cart = _a.cart, loaded = _a.loaded;
                if (_this.cartId && _this.isEmpty(cart) && !loaded) {
                    _this.load();
                }
            }), operators.map(function (_a) {
                var cart = _a.cart;
                return (cart ? cart : {});
            }), operators.shareReplay({ bufferSize: 1, refCount: true }));
        }
        SelectiveCartService.prototype.getCart = function () {
            return this.selectiveCart$;
        };
        SelectiveCartService.prototype.getEntries = function () {
            return this.multiCartService.getEntries(this.cartId);
        };
        /**
         * Returns true when selective cart is stable (not loading and not pending processes on cart)
         */
        SelectiveCartService.prototype.isStable = function () {
            var _this = this;
            return this.cartId$.pipe(operators.switchMap(function (cartId) { return _this.multiCartService.isStable(cartId); }));
        };
        /**
         * Loads logged user's selective cart
         */
        SelectiveCartService.prototype.load = function () {
            if (this.isLoggedIn(this.userId) && this.cartId) {
                this.multiCartService.loadCart({
                    userId: this.userId,
                    cartId: this.cartId,
                });
            }
        };
        SelectiveCartService.prototype.addEntry = function (productCode, quantity) {
            var _this = this;
            var loadAttempted = false;
            this.cartSelector$
                .pipe(operators.filter(function () { return !loadAttempted; }), operators.switchMap(function (cartState) {
                if (_this.isEmpty(cartState.value) && !cartState.loading) {
                    loadAttempted = true;
                    _this.load();
                }
                return rxjs.of(cartState);
            }), operators.filter(function (cartState) { return !_this.isEmpty(cartState.value); }), operators.take(1))
                .subscribe(function () {
                _this.multiCartService.addEntry(_this.userId, _this.cartId, productCode, quantity);
            });
        };
        SelectiveCartService.prototype.removeEntry = function (entry) {
            this.multiCartService.removeEntry(this.userId, this.cartId, entry.entryNumber);
        };
        SelectiveCartService.prototype.updateEntry = function (entryNumber, quantity) {
            this.multiCartService.updateEntry(this.userId, this.cartId, entryNumber, quantity);
        };
        SelectiveCartService.prototype.getEntry = function (productCode) {
            return this.multiCartService.getEntry(this.cartId, productCode);
        };
        /**
         * Indicates if selectiveCart feature is enabled based on cart configuration.
         */
        SelectiveCartService.prototype.isEnabled = function () {
            return this.cartConfigService.isSelectiveCartEnabled();
        };
        /**
         * Indicates if given cart is empty.
         * Returns true is cart is undefined, null or is an empty object.
         */
        SelectiveCartService.prototype.isEmpty = function (cart) {
            return (!cart || (typeof cart === 'object' && Object.keys(cart).length === 0));
        };
        /**
         * Indicates if a given user is logged in on account different than preceding user account
         */
        SelectiveCartService.prototype.isJustLoggedIn = function (userId) {
            return (this.isLoggedIn(userId) &&
                this.previousUserId !== userId && // *just* logged in
                this.previousUserId !== this.PREVIOUS_USER_ID_INITIAL_VALUE // not app initialization
            );
        };
        /**
         * Indicates if given user is logged in
         */
        SelectiveCartService.prototype.isLoggedIn = function (userId) {
            return typeof userId !== 'undefined' && userId !== OCC_USER_ID_ANONYMOUS;
        };
        return SelectiveCartService;
    }());
    SelectiveCartService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SelectiveCartService, deps: [{ token: i1__namespace$2.Store }, { token: UserService }, { token: MultiCartService }, { token: BaseSiteService }, { token: CartConfigService }, { token: UserIdService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    SelectiveCartService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SelectiveCartService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SelectiveCartService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace$2.Store }, { type: UserService }, { type: MultiCartService }, { type: BaseSiteService }, { type: CartConfigService }, { type: UserIdService }]; } });

    var WishListService = /** @class */ (function () {
        function WishListService(store, userService, multiCartService, userIdService) {
            this.store = store;
            this.userService = userService;
            this.multiCartService = multiCartService;
            this.userIdService = userIdService;
        }
        WishListService.prototype.createWishList = function (userId, name, description) {
            this.store.dispatch(new CreateWishList({ userId: userId, name: name, description: description }));
        };
        WishListService.prototype.getWishList = function () {
            var _this = this;
            return rxjs.combineLatest([
                this.getWishListId(),
                this.userService.get(),
                this.userIdService.getUserId(),
            ]).pipe(operators.distinctUntilChanged(), operators.tap(function (_a) {
                var _b = __read(_a, 3), wishListId = _b[0], user = _b[1], userId = _b[2];
                if (!Boolean(wishListId) &&
                    userId !== OCC_USER_ID_ANONYMOUS &&
                    Boolean(user) &&
                    Boolean(user.customerId)) {
                    _this.loadWishList(userId, user.customerId);
                }
            }), operators.filter(function (_a) {
                var _b = __read(_a, 1), wishListId = _b[0];
                return Boolean(wishListId);
            }), operators.switchMap(function (_a) {
                var _b = __read(_a, 1), wishListId = _b[0];
                return _this.multiCartService.getCart(wishListId);
            }));
        };
        WishListService.prototype.loadWishList = function (userId, customerId) {
            this.store.dispatch(new LoadWishList({
                userId: userId,
                customerId: customerId,
                tempCartId: getWishlistName(customerId),
            }));
        };
        WishListService.prototype.addEntry = function (productCode) {
            var _this = this;
            this.getWishListId()
                .pipe(operators.distinctUntilChanged(), operators.withLatestFrom(this.userIdService.getUserId(), this.userService.get()), operators.tap(function (_a) {
                var _b = __read(_a, 3), wishListId = _b[0], userId = _b[1], user = _b[2];
                if (!Boolean(wishListId) &&
                    Boolean(user) &&
                    Boolean(user.customerId)) {
                    _this.loadWishList(userId, user.customerId);
                }
            }), operators.filter(function (_a) {
                var _b = __read(_a, 1), wishListId = _b[0];
                return Boolean(wishListId);
            }), operators.take(1))
                .subscribe(function (_a) {
                var _b = __read(_a, 2), wishListId = _b[0], userId = _b[1];
                return _this.multiCartService.addEntry(userId, wishListId, productCode, 1);
            });
        };
        WishListService.prototype.removeEntry = function (entry) {
            var _this = this;
            this.getWishListId()
                .pipe(operators.distinctUntilChanged(), operators.withLatestFrom(this.userIdService.getUserId(), this.userService.get()), operators.tap(function (_a) {
                var _b = __read(_a, 3), wishListId = _b[0], userId = _b[1], user = _b[2];
                if (!Boolean(wishListId) &&
                    Boolean(user) &&
                    Boolean(user.customerId)) {
                    _this.loadWishList(userId, user.customerId);
                }
            }), operators.filter(function (_a) {
                var _b = __read(_a, 1), wishListId = _b[0];
                return Boolean(wishListId);
            }), operators.take(1))
                .subscribe(function (_a) {
                var _b = __read(_a, 2), wishListId = _b[0], userId = _b[1];
                return _this.multiCartService.removeEntry(userId, wishListId, entry.entryNumber);
            });
        };
        WishListService.prototype.getWishListLoading = function () {
            var _this = this;
            return this.getWishListId().pipe(operators.switchMap(function (wishListId) { return _this.multiCartService
                .isStable(wishListId)
                .pipe(operators.map(function (stable) { return !stable; })); }));
        };
        WishListService.prototype.getWishListId = function () {
            return this.store.pipe(i1.select(getWishListId));
        };
        return WishListService;
    }());
    WishListService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: WishListService, deps: [{ token: i1__namespace$2.Store }, { token: UserService }, { token: MultiCartService }, { token: UserIdService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    WishListService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: WishListService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: WishListService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace$2.Store }, { type: UserService }, { type: MultiCartService }, { type: UserIdService }]; } });

    var Command = /** @class */ (function () {
        function Command() {
        }
        return Command;
    }());
    exports.CommandStrategy = void 0;
    (function (CommandStrategy) {
        CommandStrategy[CommandStrategy["Parallel"] = 0] = "Parallel";
        CommandStrategy[CommandStrategy["Queue"] = 1] = "Queue";
        CommandStrategy[CommandStrategy["CancelPrevious"] = 2] = "CancelPrevious";
        CommandStrategy[CommandStrategy["ErrorPrevious"] = 3] = "ErrorPrevious";
        // SkipIfOngoing,
        // ErrorIfOngoing
    })(exports.CommandStrategy || (exports.CommandStrategy = {}));
    var CommandService = /** @class */ (function () {
        function CommandService() {
            this.subscriptions = new rxjs.Subscription();
        }
        CommandService.prototype.create = function (commandFactory, options) {
            var commands$ = new rxjs.Subject();
            var results$ = new rxjs.Subject();
            var process$;
            switch (options === null || options === void 0 ? void 0 : options.strategy) {
                case exports.CommandStrategy.CancelPrevious:
                case exports.CommandStrategy.ErrorPrevious:
                    process$ = rxjs.zip(commands$, results$).pipe(operators.switchMap(function (_a) {
                        var _b = __read(_a, 2), cmd = _b[0], notifier$ = _b[1];
                        return commandFactory(cmd).pipe(operators.tap(notifier$), operators.finalize(function () { return options.strategy === exports.CommandStrategy.CancelPrevious
                            ? notifier$.complete()
                            : notifier$.error(new Error('Canceled by next command')); }));
                    }), operators.retry());
                    break;
                case exports.CommandStrategy.Parallel:
                    process$ = rxjs.zip(commands$, results$).pipe(operators.mergeMap(function (_a) {
                        var _b = __read(_a, 2), cmd = _b[0], notifier$ = _b[1];
                        return commandFactory(cmd).pipe(operators.tap(notifier$));
                    }), operators.retry());
                    break;
                case exports.CommandStrategy.Queue:
                default:
                    process$ = rxjs.zip(commands$, results$).pipe(operators.concatMap(function (_a) {
                        var _b = __read(_a, 2), cmd = _b[0], notifier$ = _b[1];
                        return commandFactory(cmd).pipe(operators.tap(notifier$));
                    }), operators.retry());
                    break;
            }
            this.subscriptions.add(process$.subscribe());
            var command = new (/** @class */ (function (_super) {
                __extends(class_1, _super);
                function class_1() {
                    var _this = _super.apply(this, __spreadArray([], __read(arguments))) || this;
                    _this.execute = function (parameters) {
                        var result$ = new rxjs.ReplaySubject();
                        results$.next(result$);
                        commands$.next(parameters);
                        return result$;
                    };
                    return _this;
                }
                return class_1;
            }(Command)))();
            return command;
        };
        CommandService.prototype.ngOnDestroy = function () {
            this.subscriptions.unsubscribe();
        };
        return CommandService;
    }());
    CommandService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CommandService, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    CommandService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CommandService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CommandService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return []; } });

    var CartValidationService = /** @class */ (function () {
        function CartValidationService(cartValidationConnector, command, userIdService, activeCartService) {
            var _this = this;
            this.cartValidationConnector = cartValidationConnector;
            this.command = command;
            this.userIdService = userIdService;
            this.activeCartService = activeCartService;
            this.validateCartCommand = this.command.create(function () { return rxjs.combineLatest([
                _this.activeCartService.getActiveCartId(),
                _this.userIdService.takeUserId(),
                _this.activeCartService.isStable(),
            ]).pipe(operators.filter(function (_a) {
                var _b = __read(_a, 3), _ = _b[0], __ = _b[1], loaded = _b[2];
                return loaded;
            }), operators.take(1), operators.switchMap(function (_a) {
                var _b = __read(_a, 2), cartId = _b[0], userId = _b[1];
                return _this.cartValidationConnector.validate(cartId, userId);
            })); }, {
                strategy: exports.CommandStrategy.CancelPrevious,
            });
        }
        /**
         * Returns cart modification list.
         *
         * @param cartId
         * @param userId
         */
        CartValidationService.prototype.validateCart = function () {
            return this.validateCartCommand.execute();
        };
        return CartValidationService;
    }());
    CartValidationService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartValidationService, deps: [{ token: CartValidationConnector }, { token: CommandService }, { token: UserIdService }, { token: ActiveCartService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    CartValidationService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartValidationService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartValidationService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: CartValidationConnector }, { type: CommandService }, { type: UserIdService }, { type: ActiveCartService }]; } });

    var ORDER_NORMALIZER = new i0.InjectionToken('OrderNormalizer');
    var POINT_OF_SERVICE_NORMALIZER = new i0.InjectionToken('PointOfServiceNormalizer');

    var PAYMENT_DETAILS_NORMALIZER = new i0.InjectionToken('PaymentDetailsNormalizer');

    var REPLENISHMENT_ORDER_NORMALIZER = new i0.InjectionToken('ReplenishmentOrderNormalizer');

    var defaultCmsModuleConfig = {
        backend: {
            occ: {
                endpoints: {
                    component: 'cms/components/${id}',
                    components: 'cms/components',
                    pages: 'cms/pages',
                    page: 'cms/pages/${id}',
                },
            },
        },
        cmsComponents: {},
    };

    var CMS_FEATURE = 'cms';
    var NAVIGATION_DETAIL_ENTITY = '[Cms] Navigation Entity';
    var COMPONENT_ENTITY = '[Cms] Component Entity';

    var LOAD_CMS_COMPONENT = '[Cms] Load Component';
    var LOAD_CMS_COMPONENT_FAIL = '[Cms] Load Component Fail';
    var LOAD_CMS_COMPONENT_SUCCESS = '[Cms] Load Component Success';
    var CMS_GET_COMPONENT_FROM_PAGE = '[Cms] Get Component from Page';
    var LoadCmsComponent = /** @class */ (function (_super) {
        __extends(LoadCmsComponent, _super);
        function LoadCmsComponent(payload) {
            var _this = _super.call(this, COMPONENT_ENTITY, payload.uid) || this;
            _this.payload = payload;
            _this.type = LOAD_CMS_COMPONENT;
            return _this;
        }
        return LoadCmsComponent;
    }(EntityLoadAction));
    var LoadCmsComponentFail = /** @class */ (function (_super) {
        __extends(LoadCmsComponentFail, _super);
        function LoadCmsComponentFail(payload) {
            var _this = _super.call(this, COMPONENT_ENTITY, payload.uid, payload.error) || this;
            _this.payload = payload;
            _this.type = LOAD_CMS_COMPONENT_FAIL;
            return _this;
        }
        return LoadCmsComponentFail;
    }(EntityFailAction));
    var LoadCmsComponentSuccess = /** @class */ (function (_super) {
        __extends(LoadCmsComponentSuccess, _super);
        function LoadCmsComponentSuccess(payload) {
            var _this = _super.call(this, COMPONENT_ENTITY, payload.uid || payload.component.uid || '') || this;
            _this.payload = payload;
            _this.type = LOAD_CMS_COMPONENT_SUCCESS;
            return _this;
        }
        return LoadCmsComponentSuccess;
    }(EntitySuccessAction));
    var CmsGetComponentFromPage = /** @class */ (function (_super) {
        __extends(CmsGetComponentFromPage, _super);
        function CmsGetComponentFromPage(payload) {
            var _this = _super.call(this, COMPONENT_ENTITY, [].concat(payload).map(function (cmp) { return cmp.component.uid; })) || this;
            _this.payload = payload;
            _this.type = CMS_GET_COMPONENT_FROM_PAGE;
            return _this;
        }
        return CmsGetComponentFromPage;
    }(EntitySuccessAction));

    var LOAD_CMS_NAVIGATION_ITEMS = '[Cms] Load NavigationEntry items';
    var LOAD_CMS_NAVIGATION_ITEMS_FAIL = '[Cms] Load NavigationEntry items Fail';
    var LOAD_CMS_NAVIGATION_ITEMS_SUCCESS = '[Cms] Load NavigationEntry items Success';
    var LoadCmsNavigationItems = /** @class */ (function (_super) {
        __extends(LoadCmsNavigationItems, _super);
        function LoadCmsNavigationItems(payload) {
            var _this = _super.call(this, NAVIGATION_DETAIL_ENTITY, payload.nodeId) || this;
            _this.payload = payload;
            _this.type = LOAD_CMS_NAVIGATION_ITEMS;
            return _this;
        }
        return LoadCmsNavigationItems;
    }(EntityLoadAction));
    var LoadCmsNavigationItemsFail = /** @class */ (function (_super) {
        __extends(LoadCmsNavigationItemsFail, _super);
        function LoadCmsNavigationItemsFail(nodeId, payload) {
            var _this = _super.call(this, NAVIGATION_DETAIL_ENTITY, nodeId, payload) || this;
            _this.payload = payload;
            _this.type = LOAD_CMS_NAVIGATION_ITEMS_FAIL;
            return _this;
        }
        return LoadCmsNavigationItemsFail;
    }(EntityFailAction));
    var LoadCmsNavigationItemsSuccess = /** @class */ (function (_super) {
        __extends(LoadCmsNavigationItemsSuccess, _super);
        function LoadCmsNavigationItemsSuccess(payload) {
            var _this = _super.call(this, NAVIGATION_DETAIL_ENTITY, payload.nodeId) || this;
            _this.payload = payload;
            _this.type = LOAD_CMS_NAVIGATION_ITEMS_SUCCESS;
            return _this;
        }
        return LoadCmsNavigationItemsSuccess;
    }(EntitySuccessAction));

    var LOAD_CMS_PAGE_DATA = '[Cms] Load Page Data';
    var LOAD_CMS_PAGE_DATA_FAIL = '[Cms] Load Page Data Fail';
    var LOAD_CMS_PAGE_DATA_SUCCESS = '[Cms] Load Page Data Success';
    var CMS_SET_PAGE_SUCCESS_INDEX = '[Cms] Set Page Success Index';
    var CMS_SET_PAGE_FAIL_INDEX = '[Cms] Set Page Fail Index';
    var LoadCmsPageData = /** @class */ (function (_super) {
        __extends(LoadCmsPageData, _super);
        function LoadCmsPageData(payload) {
            var _this = _super.call(this, payload.type, payload.id) || this;
            _this.payload = payload;
            _this.type = LOAD_CMS_PAGE_DATA;
            return _this;
        }
        return LoadCmsPageData;
    }(EntityLoadAction));
    var LoadCmsPageDataFail = /** @class */ (function (_super) {
        __extends(LoadCmsPageDataFail, _super);
        function LoadCmsPageDataFail(pageContext, error) {
            var _this = _super.call(this, pageContext.type, pageContext.id, error) || this;
            _this.type = LOAD_CMS_PAGE_DATA_FAIL;
            return _this;
        }
        return LoadCmsPageDataFail;
    }(EntityFailAction));
    var LoadCmsPageDataSuccess = /** @class */ (function (_super) {
        __extends(LoadCmsPageDataSuccess, _super);
        function LoadCmsPageDataSuccess(pageContext, payload) {
            var _this = _super.call(this, pageContext.type, pageContext.id, payload) || this;
            _this.type = LOAD_CMS_PAGE_DATA_SUCCESS;
            return _this;
        }
        return LoadCmsPageDataSuccess;
    }(EntitySuccessAction));
    var CmsSetPageSuccessIndex = /** @class */ (function (_super) {
        __extends(CmsSetPageSuccessIndex, _super);
        function CmsSetPageSuccessIndex(pageContext, payload) {
            var _this = _super.call(this, pageContext.type, pageContext.id, payload) || this;
            _this.type = CMS_SET_PAGE_SUCCESS_INDEX;
            return _this;
        }
        return CmsSetPageSuccessIndex;
    }(EntitySuccessAction));
    var CmsSetPageFailIndex = /** @class */ (function (_super) {
        __extends(CmsSetPageFailIndex, _super);
        function CmsSetPageFailIndex(pageContext, payload) {
            var _this = _super.call(this, pageContext.type, pageContext.id) || this;
            _this.payload = payload;
            _this.type = CMS_SET_PAGE_FAIL_INDEX;
            return _this;
        }
        return CmsSetPageFailIndex;
    }(EntityFailAction));

    var cmsGroup_actions = /*#__PURE__*/Object.freeze({
        __proto__: null,
        LOAD_CMS_COMPONENT: LOAD_CMS_COMPONENT,
        LOAD_CMS_COMPONENT_FAIL: LOAD_CMS_COMPONENT_FAIL,
        LOAD_CMS_COMPONENT_SUCCESS: LOAD_CMS_COMPONENT_SUCCESS,
        CMS_GET_COMPONENT_FROM_PAGE: CMS_GET_COMPONENT_FROM_PAGE,
        LoadCmsComponent: LoadCmsComponent,
        LoadCmsComponentFail: LoadCmsComponentFail,
        LoadCmsComponentSuccess: LoadCmsComponentSuccess,
        CmsGetComponentFromPage: CmsGetComponentFromPage,
        LOAD_CMS_NAVIGATION_ITEMS: LOAD_CMS_NAVIGATION_ITEMS,
        LOAD_CMS_NAVIGATION_ITEMS_FAIL: LOAD_CMS_NAVIGATION_ITEMS_FAIL,
        LOAD_CMS_NAVIGATION_ITEMS_SUCCESS: LOAD_CMS_NAVIGATION_ITEMS_SUCCESS,
        LoadCmsNavigationItems: LoadCmsNavigationItems,
        LoadCmsNavigationItemsFail: LoadCmsNavigationItemsFail,
        LoadCmsNavigationItemsSuccess: LoadCmsNavigationItemsSuccess,
        LOAD_CMS_PAGE_DATA: LOAD_CMS_PAGE_DATA,
        LOAD_CMS_PAGE_DATA_FAIL: LOAD_CMS_PAGE_DATA_FAIL,
        LOAD_CMS_PAGE_DATA_SUCCESS: LOAD_CMS_PAGE_DATA_SUCCESS,
        CMS_SET_PAGE_SUCCESS_INDEX: CMS_SET_PAGE_SUCCESS_INDEX,
        CMS_SET_PAGE_FAIL_INDEX: CMS_SET_PAGE_FAIL_INDEX,
        LoadCmsPageData: LoadCmsPageData,
        LoadCmsPageDataFail: LoadCmsPageDataFail,
        LoadCmsPageDataSuccess: LoadCmsPageDataSuccess,
        CmsSetPageSuccessIndex: CmsSetPageSuccessIndex,
        CmsSetPageFailIndex: CmsSetPageFailIndex
    });

    var getCmsState = i1.createFeatureSelector(CMS_FEATURE);

    var getComponentsState = i1.createSelector(getCmsState, function (state) { return state.components; });
    var componentsContextSelectorFactory = function (uid) {
        return i1.createSelector(getComponentsState, function (componentsState) { return entitySelector(componentsState, uid); });
    };
    var componentsLoaderStateSelectorFactory = function (uid, context) {
        return i1.createSelector(componentsContextSelectorFactory(uid), function (componentsContext) { return (componentsContext &&
            componentsContext.pageContext &&
            componentsContext.pageContext[context]) ||
            initialLoaderState; });
    };
    /**
     * This selector will return:
     *   - true: component for this context exists
     *   - false: component for this context doesn't exist
     *   - undefined: if the exists status for component is unknown
     *
     * @param uid
     * @param context
     */
    var componentsContextExistsSelectorFactory = function (uid, context) {
        return i1.createSelector(componentsLoaderStateSelectorFactory(uid, context), function (loaderState) { return loaderValueSelector(loaderState); });
    };
    var componentsDataSelectorFactory = function (uid) {
        return i1.createSelector(componentsContextSelectorFactory(uid), function (state) { return state ? state.component : undefined; });
    };
    /**
     * This selector will return:
     *   - CmsComponent instance: if we have component data for specified context
     *   - null: if there is no component data for specified context
     *   - undefined: if status of component data for specified context is unknown
     *
     * @param uid
     * @param context
     */
    var componentsSelectorFactory = function (uid, context) {
        return i1.createSelector(componentsDataSelectorFactory(uid), componentsContextExistsSelectorFactory(uid, context), function (componentState, exists) {
            switch (exists) {
                case true:
                    return componentState;
                case false:
                    return null;
                case undefined:
                    return undefined;
            }
        });
    };

    var getNavigationEntryItemState = i1.createSelector(getCmsState, function (state) { return state.navigation; });
    var getSelectedNavigationEntryItemState = function (nodeId) {
        return i1.createSelector(getNavigationEntryItemState, function (nodes) { return entityLoaderStateSelector(nodes, nodeId); });
    };
    var getNavigationEntryItems = function (nodeId) {
        return i1.createSelector(getSelectedNavigationEntryItemState(nodeId), function (itemState) { return loaderValueSelector(itemState); });
    };

    var getPageEntitiesSelector = function (state) { return state.pageData.entities; };
    var getIndexByType = function (index, type) {
        switch (type) {
            case exports.PageType.CONTENT_PAGE: {
                return index.content;
            }
            case exports.PageType.PRODUCT_PAGE: {
                return index.product;
            }
            case exports.PageType.CATEGORY_PAGE: {
                return index.category;
            }
            case exports.PageType.CATALOG_PAGE: {
                return index.catalog;
            }
        }
        return { entities: {} };
    };
    var getPageComponentTypesSelector = function (page) {
        var e_1, _a, e_2, _b;
        var componentTypes = new Set();
        if (page && page.slots) {
            try {
                for (var _c = __values(Object.keys(page.slots)), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var slot = _d.value;
                    try {
                        for (var _e = (e_2 = void 0, __values(page.slots[slot].components || [])), _f = _e.next(); !_f.done; _f = _e.next()) {
                            var component = _f.value;
                            componentTypes.add(component.flexType);
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        return Array.from(componentTypes);
    };
    var getPageState = i1.createSelector(getCmsState, function (state) { return state.page; });
    var getPageStateIndex = i1.createSelector(getPageState, function (page) { return page.index; });
    var getPageStateIndexEntityLoaderState = function (pageContext) { return i1.createSelector(getPageStateIndex, function (index) { return getIndexByType(index, pageContext.type); }); };
    var getPageStateIndexLoaderState = function (pageContext) { return i1.createSelector(getPageStateIndexEntityLoaderState(pageContext), function (indexState) { return entityLoaderStateSelector(indexState, pageContext.id); }); };
    var getPageStateIndexValue = function (pageContext) { return i1.createSelector(getPageStateIndexLoaderState(pageContext), function (entity) { return loaderValueSelector(entity); }); };
    var getPageEntities = i1.createSelector(getPageState, getPageEntitiesSelector);
    var getPageData = function (pageContext) { return i1.createSelector(getPageEntities, getPageStateIndexValue(pageContext), function (entities, indexValue) { return entities[indexValue]; }); };
    var getPageComponentTypes = function (pageContext) { return i1.createSelector(getPageData(pageContext), function (pageData) { return getPageComponentTypesSelector(pageData); }); };
    var getCurrentSlotSelectorFactory = function (pageContext, position) {
        return i1.createSelector(getPageData(pageContext), function (entity) {
            if (entity) {
                return entity.slots[position] || { components: [] };
            }
        });
    };

    var cmsGroup_selectors = /*#__PURE__*/Object.freeze({
        __proto__: null,
        getComponentsState: getComponentsState,
        componentsContextSelectorFactory: componentsContextSelectorFactory,
        componentsLoaderStateSelectorFactory: componentsLoaderStateSelectorFactory,
        componentsContextExistsSelectorFactory: componentsContextExistsSelectorFactory,
        componentsDataSelectorFactory: componentsDataSelectorFactory,
        componentsSelectorFactory: componentsSelectorFactory,
        getCmsState: getCmsState,
        getNavigationEntryItemState: getNavigationEntryItemState,
        getSelectedNavigationEntryItemState: getSelectedNavigationEntryItemState,
        getNavigationEntryItems: getNavigationEntryItems,
        getPageState: getPageState,
        getPageStateIndex: getPageStateIndex,
        getPageStateIndexEntityLoaderState: getPageStateIndexEntityLoaderState,
        getPageStateIndexLoaderState: getPageStateIndexLoaderState,
        getPageStateIndexValue: getPageStateIndexValue,
        getPageEntities: getPageEntities,
        getPageData: getPageData,
        getPageComponentTypes: getPageComponentTypes,
        getCurrentSlotSelectorFactory: getCurrentSlotSelectorFactory
    });

    var CURRENT_CONTEXT_KEY = 'current';
    /**
     *
     * Serializes the provided page context.
     * The pattern used for serialization is: `pageContext.type-pageContext.id`.
     *
     * @param pageContext to serialize
     * @param ignoreContentPageId if set to true, and the PageType is of type ContentPage, then the serialized page context will not contain the ID.
     * Otherwise, the page context if fully serialized.
     */
    function serializePageContext(pageContext, ignoreContentPageId) {
        if (!pageContext) {
            return CURRENT_CONTEXT_KEY;
        }
        if (ignoreContentPageId && pageContext.type === exports.PageType.CONTENT_PAGE) {
            return "" + pageContext.type;
        }
        return pageContext.type + "-" + pageContext.id;
    }

    var CmsService = /** @class */ (function () {
        function CmsService(store, routingService) {
            this.store = store;
            this.routingService = routingService;
            this.components = {};
        }
        /**
         * Get current CMS page data
         */
        CmsService.prototype.getCurrentPage = function () {
            var _this = this;
            return this.routingService
                .getPageContext()
                .pipe(operators.switchMap(function (pageContext) { return _this.store.select(getPageData(pageContext)); }));
        };
        /**
         * Get CMS component data by uid
         *
         * This method can be safely and optimally used to load multiple components data at the same time.
         * Calling getComponentData multiple times for different components will always result in optimized
         * back-end request: all components requested at the same time (in one event loop) will be loaded in one network call.
         *
         * In case the component data is not present, the method will load it.
         * Otherwise, if the page context is not provided, the current page context from the router state will be used instead.
         *
         * @param uid CMS component uid
         * @param pageContext if provided, it will be used to lookup the component data.
         */
        CmsService.prototype.getComponentData = function (uid, pageContext) {
            var context = serializePageContext(pageContext, true);
            if (!this.components[uid]) {
                // create the component data structure, if it doesn't already exist
                this.components[uid] = {};
            }
            var component = this.components[uid];
            if (!component[context]) {
                // create the component data and assign it to the component's context
                component[context] = this.createComponentData(uid, pageContext);
            }
            return component[context];
        };
        CmsService.prototype.createComponentData = function (uid, pageContext) {
            var _this = this;
            if (!pageContext) {
                return this.routingService.getPageContext().pipe(operators.filter(function (currentContext) { return !!currentContext; }), operators.switchMap(function (currentContext) { return _this.getComponentData(uid, currentContext); }));
            }
            var context = serializePageContext(pageContext, true);
            var loading$ = rxjs.combineLatest([
                this.routingService.getNextPageContext(),
                this.store.pipe(i1.select(componentsLoaderStateSelectorFactory(uid, context))),
            ]).pipe(operators.observeOn(rxjs.queueScheduler), operators.tap(function (_a) {
                var _b = __read(_a, 2), nextContext = _b[0], loadingState = _b[1];
                var attemptedLoad = loadingState.loading || loadingState.success || loadingState.error;
                // if the requested context is the same as the one that's currently being navigated to
                // (as it might already been triggered and might be available shortly from page data)
                // TODO(issue:3649), TODO(issue:3668) - this optimization could be removed
                var couldBeLoadedWithPageData = nextContext
                    ? serializePageContext(nextContext, true) === context
                    : false;
                if (!attemptedLoad && !couldBeLoadedWithPageData) {
                    _this.store.dispatch(new LoadCmsComponent({ uid: uid, pageContext: pageContext }));
                }
            }));
            var component$ = this.store.pipe(i1.select(componentsSelectorFactory(uid, context)), operators.filter(isNotUndefined));
            return rxjs.using(function () { return loading$.subscribe(); }, function () { return component$; }).pipe(operators.shareReplay({ bufferSize: 1, refCount: true }));
        };
        /**
         * Given the position, get the content slot data
         * @param position : content slot position
         */
        CmsService.prototype.getContentSlot = function (position) {
            var _this = this;
            return this.routingService
                .getPageContext()
                .pipe(operators.switchMap(function (pageContext) { return _this.store.pipe(i1.select(getCurrentSlotSelectorFactory(pageContext, position)), operators.filter(Boolean)); }));
        };
        /**
         * Given navigation node uid, get items (with id and type) inside the navigation entries
         * @param navigationNodeUid : uid of the navigation node
         */
        CmsService.prototype.getNavigationEntryItems = function (navigationNodeUid) {
            return this.store.pipe(i1.select(getNavigationEntryItems(navigationNodeUid)));
        };
        /**
         * Load navigation items data
         * @param rootUid : the uid of the root navigation node
         * @param itemList : list of items (with id and type)
         */
        CmsService.prototype.loadNavigationItems = function (rootUid, itemList) {
            this.store.dispatch(new LoadCmsNavigationItems({
                nodeId: rootUid,
                items: itemList,
            }));
        };
        /**
         * Refresh the content of the latest cms page
         */
        CmsService.prototype.refreshLatestPage = function () {
            var _this = this;
            this.routingService
                .getPageContext()
                .pipe(operators.take(1))
                .subscribe(function (pageContext) { return _this.store.dispatch(new LoadCmsPageData(pageContext)); });
        };
        /**
         * Refresh the cms page content by page Id
         * @param pageId
         */
        CmsService.prototype.refreshPageById = function (pageId) {
            var pageContext = { id: pageId };
            this.store.dispatch(new LoadCmsPageData(pageContext));
        };
        /**
         * Refresh cms component's content
         * @param uid component uid
         * @param pageContext an optional parameter that enables the caller to specify for which context the component should be refreshed.
         * If not specified, 'current' page context is used.
         */
        CmsService.prototype.refreshComponent = function (uid, pageContext) {
            this.store.dispatch(new LoadCmsComponent({ uid: uid, pageContext: pageContext }));
        };
        /**
         * Given pageContext, return the CMS page data
         * @param pageContext
         */
        CmsService.prototype.getPageState = function (pageContext) {
            return this.store.pipe(i1.select(getPageData(pageContext)));
        };
        /**
         * Given pageContext, return the CMS page data
         * @param pageContext
         */
        CmsService.prototype.getPageComponentTypes = function (pageContext) {
            return this.store.pipe(i1.select(getPageComponentTypes(pageContext)));
        };
        /**
         * Given pageContext, return whether the CMS page data exists or not
         * @param pageContext
         */
        CmsService.prototype.hasPage = function (pageContext, forceReload) {
            var _this = this;
            if (forceReload === void 0) { forceReload = false; }
            return this.store.pipe(i1.select(getPageStateIndexLoaderState(pageContext)), operators.tap(function (entity) {
                var attemptedLoad = entity.loading || entity.success || entity.error;
                var shouldReload = forceReload && !entity.loading;
                if (!attemptedLoad || shouldReload) {
                    _this.store.dispatch(new LoadCmsPageData(pageContext));
                    forceReload = false;
                }
            }), operators.filter(function (entity) {
                if (!entity.hasOwnProperty('value')) {
                    // if we have incomplete state from SSR failed load transfer state,
                    // we should wait for reload and actual value
                    return false;
                }
                return entity.success || (entity.error && !entity.loading);
            }), operators.pluck('success'), operators.catchError(function () { return rxjs.of(false); }));
        };
        /**
         * Given pageContext, return the CMS page data
         **/
        CmsService.prototype.getPage = function (pageContext, forceReload) {
            var _this = this;
            if (forceReload === void 0) { forceReload = false; }
            return this.hasPage(pageContext, forceReload).pipe(operators.switchMap(function (hasPage) { return hasPage ? _this.getPageState(pageContext) : rxjs.of(null); }));
        };
        CmsService.prototype.getPageIndex = function (pageContext) {
            return this.store.pipe(i1.select(getPageStateIndexValue(pageContext)));
        };
        CmsService.prototype.setPageFailIndex = function (pageContext, value) {
            this.store.dispatch(new CmsSetPageFailIndex(pageContext, value));
        };
        return CmsService;
    }());
    CmsService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CmsService, deps: [{ token: i1__namespace$2.Store }, { token: RoutingService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    CmsService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CmsService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CmsService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace$2.Store }, { type: RoutingService }]; } });

    var defaultPageMetaConfig = {
        pageMeta: {
            resolvers: [
                {
                    property: 'title',
                    method: 'resolveTitle',
                },
                {
                    property: 'heading',
                    method: 'resolveHeading',
                },
                {
                    property: 'breadcrumbs',
                    method: 'resolveBreadcrumbs',
                },
                {
                    property: 'description',
                    method: 'resolveDescription',
                    disabledInCsr: true,
                },
                {
                    property: 'image',
                    method: 'resolveImage',
                    disabledInCsr: true,
                },
                {
                    property: 'robots',
                    method: 'resolveRobots',
                    disabledInCsr: true,
                },
                {
                    property: 'canonicalUrl',
                    method: 'resolveCanonicalUrl',
                    disabledInCsr: true,
                },
            ],
            canonicalUrl: {
                forceHttps: true,
                forceWww: false,
                removeQueryParams: true,
                forceTrailingSlash: true,
            },
        },
    };

    /**
     * Abstract class that can be used to resolve meta data for specific pages.
     * The `getScore` method is used to select the right resolver for a specific
     * page, based on a score. The score is calculated by the (non)matching page
     * type and page template.
     */
    var PageMetaResolver = /** @class */ (function () {
        function PageMetaResolver() {
        }
        /**
         * Returns the matching score for a resolver class, based on
         * the page type and page template.
         */
        PageMetaResolver.prototype.getScore = function (page) {
            var score = 0;
            if (this.pageType) {
                score += page.type === this.pageType ? 1 : -1;
            }
            if (this.pageTemplate) {
                score += page.template === this.pageTemplate ? 1 : -1;
            }
            return score;
        };
        PageMetaResolver.prototype.hasMatch = function (page) {
            return this.getScore(page) > 0;
        };
        PageMetaResolver.prototype.getPriority = function (page) {
            return this.getScore(page);
        };
        return PageMetaResolver;
    }());

    var TranslationService = /** @class */ (function () {
        function TranslationService() {
        }
        return TranslationService;
    }());

    /**
     * Resolves the breadcrumb for the Angular ActivatedRouteSnapshot
     */
    var DefaultRoutePageMetaResolver = /** @class */ (function () {
        function DefaultRoutePageMetaResolver(translation) {
            this.translation = translation;
        }
        /**
         * Resolves breadcrumb based on the given url and the breadcrumb config.
         *
         * - When breadcrumb config is empty, it returns an empty breadcrumb.
         * - When breadcrumb config is a string or object with `i18n` property,
         *    it translates it and use as a label of the returned breadcrumb.
         * - When breadcrumb config is an object with property `raw`, then
         *    it's used as a label of the returned breadcrumb.
         */
        DefaultRoutePageMetaResolver.prototype.resolveBreadcrumbs = function (_a) {
            var url = _a.url, pageMetaConfig = _a.pageMetaConfig;
            var breadcrumbConfig = pageMetaConfig === null || pageMetaConfig === void 0 ? void 0 : pageMetaConfig.breadcrumb;
            if (!breadcrumbConfig) {
                return rxjs.of([]);
            }
            if (typeof breadcrumbConfig !== 'string' && breadcrumbConfig.raw) {
                return rxjs.of([{ link: url, label: breadcrumbConfig.raw }]);
            }
            return this.translateBreadcrumbLabel(breadcrumbConfig).pipe(operators.map(function (label) { return [{ label: label, link: url }]; }));
        };
        /**
         * Translates the configured breadcrumb label
         */
        DefaultRoutePageMetaResolver.prototype.translateBreadcrumbLabel = function (breadcrumbConfig) {
            var _this = this;
            var i18nKey = typeof breadcrumbConfig === 'string'
                ? breadcrumbConfig
                : breadcrumbConfig.i18n;
            return this.getParams().pipe(operators.switchMap(function (params) { return _this.translation.translate(i18nKey, params !== null && params !== void 0 ? params : {}); }));
        };
        /**
         * Resolves dynamic data for the whole resolver.
         */
        DefaultRoutePageMetaResolver.prototype.getParams = function () {
            return rxjs.of({});
        };
        return DefaultRoutePageMetaResolver;
    }());
    DefaultRoutePageMetaResolver.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: DefaultRoutePageMetaResolver, deps: [{ token: TranslationService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    DefaultRoutePageMetaResolver.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: DefaultRoutePageMetaResolver, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: DefaultRoutePageMetaResolver, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }], ctorParameters: function () { return [{ type: TranslationService }]; } });

    /**
     * Resolves the page meta based on the Angular Activated Routes
     */
    var RoutingPageMetaResolver = /** @class */ (function () {
        function RoutingPageMetaResolver(activatedRoutesService, injector) {
            var _this = this;
            this.activatedRoutesService = activatedRoutesService;
            this.injector = injector;
            /**
             * Array of activated routes, excluding the special Angular `root` route.
             */
            this.routes$ = this.activatedRoutesService.routes$.pipe(
            // drop the first route - the special `root` route:
            operators.map(function (routes) { return (routes = routes.slice(1, routes.length)); }));
            /**
             * Array of activated routes together with precalculated extras:
             *
             * - route's page meta resolver
             * - route's absolute string URL
             *
             * In case when there is no page meta resolver configured for a specific route,
             * it inherits its parent's resolver.
             *
             * When there is no page meta resolver configured for the highest parent in the hierarchy,
             * it uses the `DefaultRoutePageMetaResolver`.
             */
            this.routesWithExtras$ = this.routes$.pipe(operators.map(function (routes) { return routes.reduce(function (results, route) {
                var _a;
                var parent = results.length
                    ? results[results.length - 1]
                    : {
                        route: null,
                        resolver: _this.injector.get(DefaultRoutePageMetaResolver),
                        url: '',
                    };
                var resolver = (_a = _this.getResolver(route)) !== null && _a !== void 0 ? _a : parent.resolver; // fallback to parent's resolver
                var urlPart = _this.getUrlPart(route);
                var url = parent.url + (urlPart ? "/" + urlPart : ''); // don't add slash for a route with path '', to avoid double slash ...//...
                return results.concat({ route: route, resolver: resolver, url: url });
            }, []); }), operators.shareReplay({ bufferSize: 1, refCount: true }));
        }
        /**
         * Array of breadcrumbs defined for all the activated routes (from the root route to the leaf route).
         * It emits on every completed routing navigation.
         */
        RoutingPageMetaResolver.prototype.resolveBreadcrumbs = function (options) {
            var _this = this;
            return this.routesWithExtras$.pipe(operators.map(function (routesWithExtras) { return (options === null || options === void 0 ? void 0 : options.includeCurrentRoute)
                ? routesWithExtras
                : _this.trimCurrentRoute(routesWithExtras); }), operators.switchMap(function (routesWithExtras) { return routesWithExtras.length
                ? rxjs.combineLatest(routesWithExtras.map(function (routeWithExtras) { return _this.resolveRouteBreadcrumb(routeWithExtras); }))
                : rxjs.of([]); }), operators.map(function (breadcrumbArrays) { return breadcrumbArrays.flat(); }));
        };
        /**
         * Returns the instance of the RoutePageMetaResolver configured for the given activated route.
         * Returns null in case there the resolver can't be injected or is undefined.
         *
         * @param route route to resolve
         */
        RoutingPageMetaResolver.prototype.getResolver = function (route) {
            var pageMetaConfig = this.getPageMetaConfig(route);
            if (typeof pageMetaConfig !== 'string' && (pageMetaConfig === null || pageMetaConfig === void 0 ? void 0 : pageMetaConfig.resolver)) {
                return this.injector.get(pageMetaConfig.resolver, null);
            }
            return null;
        };
        /**
         * Resolvers breadcrumb for a specific route
         */
        RoutingPageMetaResolver.prototype.resolveRouteBreadcrumb = function (_c) {
            var route = _c.route, resolver = _c.resolver, url = _c.url;
            var breadcrumbResolver = resolver;
            if (typeof breadcrumbResolver.resolveBreadcrumbs === 'function') {
                return breadcrumbResolver.resolveBreadcrumbs({
                    route: route,
                    url: url,
                    pageMetaConfig: this.getPageMetaConfig(route),
                });
            }
            return rxjs.of([]);
        };
        /**
         * By default in breadcrumbs list we don't want to show a link to the current page, so this function
         * trims the last breadcrumb (the breadcrumb of the current route).
         *
         * This function also handles special case when the current route has a configured empty path ('' route).
         * The '' routes are often a _technical_ routes to organize other routes, assign common guards for its children, etc.
         * It shouldn't happen that '' route has a defined breadcrumb config.
         *
         * In that case, we trim not only the last route ('' route), but also its parent route with non-empty path
         * (which likely defines the breadcrumb config).
         */
        RoutingPageMetaResolver.prototype.trimCurrentRoute = function (routesWithExtras) {
            // If the last route is '', we trim:
            // - the '' route
            // - all parent '' routes (until we meet route with non-empty path)
            var _a, _b;
            var i = routesWithExtras.length - 1;
            while (((_b = (_a = routesWithExtras[i]) === null || _a === void 0 ? void 0 : _a.route) === null || _b === void 0 ? void 0 : _b.url.length) === 0 && i >= 0) {
                i--;
            }
            // Finally we trim the last route (the one with non-empty path)
            return routesWithExtras.slice(0, i);
        };
        /**
         * Returns the URL path for the given activated route in a string format.
         * (ActivatedRouteSnapshot#url contains an array of `UrlSegment`s, not a string)
         */
        RoutingPageMetaResolver.prototype.getUrlPart = function (route) {
            return route.url.map(function (urlSegment) { return urlSegment.path; }).join('/');
        };
        /**
         * Returns the breadcrumb config placed in the route's `data` configuration.
         */
        RoutingPageMetaResolver.prototype.getPageMetaConfig = function (route) {
            var _a, _b;
            // Note: we use `route.routeConfig.data` (not `route.data`) to save us from
            // an edge case bug. In Angular, by design the `data` of ActivatedRoute is inherited
            // from the parent route, if only the child has an empty path ''.
            // But in any case we don't want the page meta configs to be inherited, so we
            // read data from the original `routeConfig` which is static.
            //
            // Note: we may inherit the parent's page meta resolver in case we don't define it,
            // but we don't want to inherit parent's page meta config!
            return (_b = (_a = route === null || route === void 0 ? void 0 : route.routeConfig) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.cxPageMeta;
        };
        return RoutingPageMetaResolver;
    }());
    RoutingPageMetaResolver.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: RoutingPageMetaResolver, deps: [{ token: ActivatedRoutesService }, { token: i0__namespace.Injector }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    RoutingPageMetaResolver.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: RoutingPageMetaResolver, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: RoutingPageMetaResolver, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }], ctorParameters: function () { return [{ type: ActivatedRoutesService }, { type: i0__namespace.Injector }]; } });

    var PageMetaConfig = /** @class */ (function () {
        function PageMetaConfig() {
        }
        return PageMetaConfig;
    }());
    PageMetaConfig.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PageMetaConfig, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    PageMetaConfig.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PageMetaConfig, providedIn: 'root', useExisting: Config });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PageMetaConfig, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                        useExisting: Config,
                    }]
            }] });

    /**
     * Service to add links to the page meta data, such canonical URLs.
     */
    var PageLinkService = /** @class */ (function () {
        function PageLinkService(pageMetaConfig, winRef) {
            this.pageMetaConfig = pageMetaConfig;
            this.winRef = winRef;
        }
        /**
         * Returns the canonical for the page.
         *
         * The canonical url is created by the help of the default `CanonicalUrlOptions` from
         * the pageMeta options. The options can be further adjusted by the options argument.
         */
        PageLinkService.prototype.getCanonicalUrl = function (options, url) {
            var _a, _b, _c;
            var config = Object.assign(Object.assign({}, (_b = (_a = this.pageMetaConfig) === null || _a === void 0 ? void 0 : _a.pageMeta) === null || _b === void 0 ? void 0 : _b.canonicalUrl), options);
            return this.buildCanonicalUrl((_c = url !== null && url !== void 0 ? url : this.winRef.location.href) !== null && _c !== void 0 ? _c : '', config);
        };
        PageLinkService.prototype.buildCanonicalUrl = function (url, options) {
            if (options.forceHttps) {
                url = url.replace(/^http(?!s):/i, 'https:');
            }
            if (options.forceWww) {
                // this will not allow for not adding wwww. in case of a subdomain
                url = url.replace(/^(https?:\/\/)(?!www\.)(.*)/i, '$1www.$2');
            }
            if (options.removeQueryParams) {
                url = this.removeQueryParams(url, options);
            }
            if (options.forceTrailingSlash) {
                url = url.replace(/^([^\?]+[^\/\?]$)$/i, '$1/');
            }
            return url;
        };
        PageLinkService.prototype.removeQueryParams = function (url, config) {
            var queryPos = url.indexOf('?');
            if (queryPos > -1) {
                var urlBeforeQueryParam = url.substr(0, queryPos);
                var params_1 = new URLSearchParams(url.substr(queryPos));
                url = urlBeforeQueryParam;
                if (Array.isArray(config.removeQueryParams)) {
                    config.removeQueryParams.forEach(function (param) {
                        params_1.delete(param);
                    });
                    if (params_1.toString().length > 0) {
                        url = urlBeforeQueryParam + "?" + params_1.toString();
                    }
                }
            }
            return url;
        };
        return PageLinkService;
    }());
    PageLinkService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PageLinkService, deps: [{ token: PageMetaConfig }, { token: WindowRef }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    PageLinkService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PageLinkService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PageLinkService, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }], ctorParameters: function () { return [{ type: PageMetaConfig }, { type: WindowRef }]; } });

    var BasePageMetaResolver = /** @class */ (function () {
        function BasePageMetaResolver(cmsService, translation, routingPageMetaResolver, router, pageLinkService) {
            var _this = this;
            this.cmsService = cmsService;
            this.translation = translation;
            this.routingPageMetaResolver = routingPageMetaResolver;
            this.router = router;
            this.pageLinkService = pageLinkService;
            /**
             * Helper to provide access to the current CMS page
             */
            this.page$ = rxjs.defer(function () { return _this.cmsService.getCurrentPage(); }).pipe(operators.filter(function (p) { return Boolean(p); }));
            this.title$ = this.page$.pipe(operators.map(function (p) { return p.title; }));
            this.description$ = this.page$.pipe(operators.map(function (p) { return p.description; }));
            this.robots$ = this.page$.pipe(operators.map(function (page) { return page.robots || []; }));
            /**
             * Breadcrumb for the home page.
             */
            this.homeBreadcrumb$ = this.translation
                .translate('common.home')
                .pipe(operators.map(function (label) { return [{ label: label, link: '/' }]; }));
            /**
             * All the resolved breadcrumbs (including those from Angular child routes).
             */
            this.breadcrumb$ = rxjs.combineLatest([
                this.homeBreadcrumb$,
                rxjs.defer(function () { var _a; return (_a = _this.routingPageMetaResolver) === null || _a === void 0 ? void 0 : _a.resolveBreadcrumbs(); }),
            ]).pipe(operators.map(function (breadcrumbs) { return breadcrumbs.flat(); }), operators.shareReplay({ bufferSize: 1, refCount: true }));
        }
        BasePageMetaResolver.prototype.resolveTitle = function () {
            return this.title$;
        };
        BasePageMetaResolver.prototype.resolveDescription = function () {
            return this.description$;
        };
        /**
         * Resolves a single breadcrumb item to the home page for each `ContentPage`.
         * The home page label is resolved from the translation service.
         */
        BasePageMetaResolver.prototype.resolveBreadcrumbs = function () {
            return this.breadcrumb$;
        };
        BasePageMetaResolver.prototype.resolveRobots = function () {
            return this.robots$;
        };
        BasePageMetaResolver.prototype.resolveCanonicalUrl = function (options) {
            var _this = this;
            return this.router.events.pipe(operators.filter(function (ev) { return ev instanceof i1$2.NavigationEnd; }), operators.startWith(null), operators.map(function () { return _this.pageLinkService.getCanonicalUrl(options); }));
        };
        return BasePageMetaResolver;
    }());
    BasePageMetaResolver.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: BasePageMetaResolver, deps: [{ token: CmsService }, { token: TranslationService }, { token: RoutingPageMetaResolver }, { token: i1__namespace$1.Router }, { token: PageLinkService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    BasePageMetaResolver.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: BasePageMetaResolver, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: BasePageMetaResolver, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: CmsService }, { type: TranslationService }, { type: RoutingPageMetaResolver }, { type: i1__namespace$1.Router }, { type: PageLinkService }]; } });

    /**
     * Resolves the page data for all Content Pages based on the `PageType.CONTENT_PAGE`.
     * More specific resolvers for content pages can be implemented by making them more
     * specific, for example by using the page template (see `CartPageMetaResolver`).
     *
     * The page title, description, breadcrumbs and robot information are resolved from the
     * content page data. The canonical URL is resolved from the URL.
     */
    var ContentPageMetaResolver = /** @class */ (function (_super) {
        __extends(ContentPageMetaResolver, _super);
        function ContentPageMetaResolver(basePageMetaResolver) {
            var _this = _super.call(this) || this;
            _this.basePageMetaResolver = basePageMetaResolver;
            _this.pageType = exports.PageType.CONTENT_PAGE;
            return _this;
        }
        ContentPageMetaResolver.prototype.resolveTitle = function () {
            return this.basePageMetaResolver.resolveTitle();
        };
        ContentPageMetaResolver.prototype.resolveDescription = function () {
            return this.basePageMetaResolver.resolveDescription();
        };
        ContentPageMetaResolver.prototype.resolveBreadcrumbs = function () {
            return this.basePageMetaResolver.resolveBreadcrumbs();
        };
        ContentPageMetaResolver.prototype.resolveRobots = function () {
            return this.basePageMetaResolver.resolveRobots();
        };
        ContentPageMetaResolver.prototype.resolveCanonicalUrl = function () {
            return this.basePageMetaResolver.resolveCanonicalUrl();
        };
        return ContentPageMetaResolver;
    }(PageMetaResolver));
    ContentPageMetaResolver.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ContentPageMetaResolver, deps: [{ token: BasePageMetaResolver }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ContentPageMetaResolver.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ContentPageMetaResolver, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ContentPageMetaResolver, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: BasePageMetaResolver }]; } });

    var PageMetaModule = /** @class */ (function () {
        function PageMetaModule() {
        }
        PageMetaModule.forRoot = function () {
            return {
                ngModule: PageMetaModule,
                providers: [provideDefaultConfig(defaultPageMetaConfig)],
            };
        };
        return PageMetaModule;
    }());
    PageMetaModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PageMetaModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    PageMetaModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PageMetaModule });
    PageMetaModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PageMetaModule, providers: [
            {
                provide: PageMetaResolver,
                useExisting: ContentPageMetaResolver,
                multi: true,
            },
        ] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PageMetaModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        providers: [
                            {
                                provide: PageMetaResolver,
                                useExisting: ContentPageMetaResolver,
                                multi: true,
                            },
                        ],
                    }]
            }] });

    function bufferDebounceTime(time, scheduler) {
        if (time === void 0) { time = 0; }
        return function (source) {
            var bufferedValues = [];
            return source.pipe(operators.tap(function (value) { return bufferedValues.push(value); }), operators.debounceTime(time, scheduler), operators.map(function () { return bufferedValues; }), operators.tap(function () { return (bufferedValues = []); }));
        };
    }

    var JSP_INCLUDE_CMS_COMPONENT_TYPE = 'JspIncludeComponent';
    var CMS_FLEX_COMPONENT_TYPE = 'CMSFlexComponent';
    /** Strategy to control the loading strategy of DOM elements. */
    exports.DeferLoadingStrategy = void 0;
    (function (DeferLoadingStrategy) {
        /** Defers loading of DOM elements until element is near/in the users view port */
        DeferLoadingStrategy["DEFER"] = "DEFERRED-LOADING";
        /** Renders the DOM instantly without being concerned with the view port */
        DeferLoadingStrategy["INSTANT"] = "INSTANT-LOADING";
    })(exports.DeferLoadingStrategy || (exports.DeferLoadingStrategy = {}));
    var CmsConfig = /** @class */ (function (_super) {
        __extends(CmsConfig, _super);
        function CmsConfig() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return CmsConfig;
    }(OccConfig));
    CmsConfig.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CmsConfig, deps: null, target: i0__namespace.ɵɵFactoryTarget.Injectable });
    CmsConfig.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CmsConfig, providedIn: 'root', useExisting: Config });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CmsConfig, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                        useExisting: Config,
                    }]
            }] });

    /**
     * The `CmsStructureConfig` is used to build pages in Spartacus by configuration
     * instead of using a backend CMS system. The configuration can be used to build
     * complete pages or parts of a page. The `CmsStructureConfig` is optimized to
     * only require the necessary properties. Adapter logic is applied to serialize
     * the `CmsStructureConfig` into the required UI model.
     */
    var CmsStructureConfig = /** @class */ (function (_super) {
        __extends(CmsStructureConfig, _super);
        function CmsStructureConfig() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return CmsStructureConfig;
    }(CmsConfig));
    CmsStructureConfig.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CmsStructureConfig, deps: null, target: i0__namespace.ɵɵFactoryTarget.Injectable });
    CmsStructureConfig.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CmsStructureConfig, providedIn: 'root', useExisting: Config });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CmsStructureConfig, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                        useExisting: Config,
                    }]
            }] });

    /**
     * Service that provides access to CMS structure from a static
     * configuration or configuration file. This class uses static
     * configuration is designed in async fashion so that configurations
     * can be loaded from a file or stream.
     *
     * The intent of the `CmsStructureConfigService` however is to provide
     * fast loading pages and default cms structure for commodity commerce.
     */
    var CmsStructureConfigService = /** @class */ (function () {
        function CmsStructureConfigService(cmsDataConfig) {
            this.cmsDataConfig = cmsDataConfig;
        }
        /**
         * Merge the cms structure to the pageStructure. The page structure
         * can either hold complete page structures or global structures that
         * might apply to all pages (such has header coponents).
         */
        CmsStructureConfigService.prototype.mergePageStructure = function (pageId, pageStructure) {
            var _this = this;
            return this.mergePage(pageId, pageStructure).pipe(operators.switchMap(function (page) { return _this.mergeSlots(page); }));
        };
        /**
         *
         * Returns boolean observable to indicate whether the page should not be
         * loaded from the backend. This is useful for pages which are comoditized
         * and follow best practice.
         *
         * By default, configurable pages are driven by static configuration,
         * in order to allow for fast loading pages (preventing network delays).
         */
        CmsStructureConfigService.prototype.shouldIgnoreBackend = function (pageId) {
            return this.getPageFromConfig(pageId).pipe(operators.map(function (page) { return !!page && !!page.ignoreBackend; }));
        };
        /**
         * returns an Observable component data from the static configuration.
         */
        CmsStructureConfigService.prototype.getComponentFromConfig = function (componentId) {
            return rxjs.of(this.getComponentById(componentId));
        };
        /**
         * returns an Observable components data from the static configuration.
         */
        CmsStructureConfigService.prototype.getComponentsFromConfig = function (ids) {
            var _this = this;
            return rxjs.of(ids.map(function (id) { return _this.getComponentById(id); }));
        };
        /**
         * returns an observable with the `PageConfig`.
         */
        CmsStructureConfigService.prototype.getPageFromConfig = function (pageId) {
            return rxjs.of(this.cmsDataConfig.cmsStructure && this.cmsDataConfig.cmsStructure.pages
                ? this.cmsDataConfig.cmsStructure.pages.find(function (p) { return p.pageId === pageId; })
                : null);
        };
        /**
         * Merge page data from the configuration into the given structure, if any.
         * If the given page structure is empty, a page is created and the page slots are
         * are merged into the page.
         */
        CmsStructureConfigService.prototype.mergePage = function (pageId, pageStructure) {
            var _this = this;
            return this.getPageFromConfig(pageId).pipe(operators.switchMap(function (page) {
                if (page) {
                    // serialize page data
                    if (!pageStructure.page) {
                        pageStructure.page = Object.assign({}, page);
                        pageStructure.page.slots = {};
                    }
                    if (!pageStructure.page.slots) {
                        pageStructure.page.slots = {};
                    }
                    return _this.mergeSlots(pageStructure, page.slots);
                }
                else {
                    return rxjs.of(pageStructure);
                }
            }));
        };
        /**
         * Adds any pre-configured slots for pages that do not use them.
         * If pages have a slot for the given position, the configiuration
         * is ingored. Even if the slot does not have inner structure (such as
         * components), so that the cms structure is able to override the (static)
         * configuration.
         */
        CmsStructureConfigService.prototype.mergeSlots = function (pageStructure, slots) {
            var e_1, _a, e_2, _b;
            // if no slots have been given, we use the global configured slots
            if (!slots &&
                this.cmsDataConfig.cmsStructure &&
                this.cmsDataConfig.cmsStructure.slots) {
                slots = this.cmsDataConfig.cmsStructure.slots;
            }
            if (!slots) {
                return rxjs.of(pageStructure);
            }
            try {
                for (var _c = __values(Object.keys(slots)), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var position = _d.value;
                    if (!Object.keys(pageStructure.page.slots).includes(position)) {
                        // the global slot isn't yet part of the page structure
                        pageStructure.page.slots[position] = {};
                        try {
                            for (var _e = (e_2 = void 0, __values(this.getComponentsByPosition(slots, position))), _f = _e.next(); !_f.done; _f = _e.next()) {
                                var component = _f.value;
                                if (!pageStructure.page.slots[position].components) {
                                    pageStructure.page.slots[position].components = [];
                                }
                                pageStructure.page.slots[position].components.push({
                                    uid: component.uid,
                                    flexType: component.flexType,
                                    typeCode: component.typeCode,
                                });
                                if (!pageStructure.components) {
                                    pageStructure.components = [];
                                }
                                pageStructure.components.push(component);
                            }
                        }
                        catch (e_2_1) { e_2 = { error: e_2_1 }; }
                        finally {
                            try {
                                if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                            }
                            finally { if (e_2) throw e_2.error; }
                        }
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return rxjs.of(pageStructure);
        };
        CmsStructureConfigService.prototype.getComponentsByPosition = function (slots, position) {
            var e_3, _a;
            var components = [];
            if (slots[position] && slots[position].componentIds) {
                try {
                    for (var _b = __values(slots[position].componentIds), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var componentId = _c.value;
                        if (this.cmsDataConfig.cmsStructure &&
                            this.cmsDataConfig.cmsStructure.components) {
                            var component = this.cmsDataConfig.cmsStructure.components[componentId];
                            if (component) {
                                components.push(Object.assign({ uid: componentId }, component));
                            }
                        }
                    }
                }
                catch (e_3_1) { e_3 = { error: e_3_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_3) throw e_3.error; }
                }
            }
            return components;
        };
        CmsStructureConfigService.prototype.getComponentById = function (componentId) {
            return this.cmsDataConfig.cmsStructure &&
                this.cmsDataConfig.cmsStructure.components
                ? this.cmsDataConfig.cmsStructure.components[componentId]
                : undefined;
        };
        return CmsStructureConfigService;
    }());
    CmsStructureConfigService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CmsStructureConfigService, deps: [{ token: CmsStructureConfig }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    CmsStructureConfigService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CmsStructureConfigService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CmsStructureConfigService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: CmsStructureConfig }]; } });

    var CmsComponentAdapter = /** @class */ (function () {
        function CmsComponentAdapter() {
        }
        return CmsComponentAdapter;
    }());

    var CmsComponentConnector = /** @class */ (function () {
        function CmsComponentConnector(cmsStructureConfigService, cmsComponentAdapter, config) {
            this.cmsStructureConfigService = cmsStructureConfigService;
            this.cmsComponentAdapter = cmsComponentAdapter;
            this.config = config;
        }
        CmsComponentConnector.prototype.get = function (id, pageContext) {
            var _this = this;
            return this.cmsStructureConfigService
                .getComponentFromConfig(id)
                .pipe(operators.switchMap(function (configuredComponent) { return configuredComponent
                ? rxjs.of(configuredComponent)
                : _this.cmsComponentAdapter.load(id, pageContext); }));
        };
        CmsComponentConnector.prototype.getList = function (ids, pageContext) {
            var _this = this;
            return this.cmsStructureConfigService.getComponentsFromConfig(ids).pipe(operators.switchMap(function (configuredComponents) {
                // check if we have some components that are not loaded from configuration
                var missingIds = configuredComponents.reduce(function (acc, component, index) {
                    if (component === undefined) {
                        acc.push(ids[index]);
                    }
                    return acc;
                }, []);
                if (missingIds.length > 0) {
                    return _this.cmsComponentAdapter
                        .findComponentsByIds(missingIds, pageContext)
                        .pipe(operators.map(function (loadedComponents) { return __spreadArray(__spreadArray([], __read(configuredComponents.filter(Boolean))), __read(loadedComponents)); }));
                }
                else {
                    return rxjs.of(configuredComponents);
                }
            }));
        };
        return CmsComponentConnector;
    }());
    CmsComponentConnector.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CmsComponentConnector, deps: [{ token: CmsStructureConfigService }, { token: CmsComponentAdapter }, { token: OccConfig }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    CmsComponentConnector.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CmsComponentConnector, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CmsComponentConnector, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: CmsStructureConfigService }, { type: CmsComponentAdapter }, { type: OccConfig }]; } });

    var ComponentsEffects = /** @class */ (function () {
        function ComponentsEffects(actions$, cmsComponentConnector) {
            var _this = this;
            this.actions$ = actions$;
            this.cmsComponentConnector = cmsComponentConnector;
            this.contextChange$ = this.actions$.pipe(i1$4.ofType(LANGUAGE_CHANGE, LOGOUT, LOGIN));
            this.loadComponent$ = i1$4.createEffect(function () { return function (_a) {
                var _b = _a === void 0 ? {} : _a, scheduler = _b.scheduler, _c = _b.debounce, debounce = _c === void 0 ? 0 : _c;
                return _this.actions$.pipe(i1$4.ofType(LOAD_CMS_COMPONENT), operators.groupBy(function (actions) { return serializePageContext(actions.payload.pageContext); }), operators.mergeMap(function (actionGroup) { return actionGroup.pipe(bufferDebounceTime(debounce, scheduler), operators.mergeMap(function (actions) { return _this.loadComponentsEffect(actions.map(function (action) { return action.payload.uid; }), actions[0].payload.pageContext); })); }), withdrawOn(_this.contextChange$));
            }; });
        }
        ComponentsEffects.prototype.loadComponentsEffect = function (componentUids, pageContext) {
            return this.cmsComponentConnector.getList(componentUids, pageContext).pipe(operators.switchMap(function (components) {
                var e_1, _a;
                var actions = [];
                var uidsLeft = new Set(componentUids);
                try {
                    for (var components_1 = __values(components), components_1_1 = components_1.next(); !components_1_1.done; components_1_1 = components_1.next()) {
                        var component = components_1_1.value;
                        actions.push(new LoadCmsComponentSuccess({
                            component: component,
                            uid: component.uid,
                            pageContext: pageContext,
                        }));
                        uidsLeft.delete(component.uid);
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (components_1_1 && !components_1_1.done && (_a = components_1.return)) _a.call(components_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                // we have to emit LoadCmsComponentFail for all component's uids that
                // are missing from the response
                uidsLeft.forEach(function (uid) {
                    actions.push(new LoadCmsComponentFail({
                        uid: uid,
                        pageContext: pageContext,
                    }));
                });
                return rxjs.from(actions);
            }), operators.catchError(function (error) { return rxjs.from(componentUids.map(function (uid) { return new LoadCmsComponentFail({
                uid: uid,
                error: normalizeHttpError(error),
                pageContext: pageContext,
            }); })); }));
        };
        return ComponentsEffects;
    }());
    ComponentsEffects.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ComponentsEffects, deps: [{ token: i1__namespace$4.Actions }, { token: CmsComponentConnector }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ComponentsEffects.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ComponentsEffects });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ComponentsEffects, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: i1__namespace$4.Actions }, { type: CmsComponentConnector }]; } });

    /**
     * @license
     * The MIT License
     * Copyright (c) 2010-2019 Google LLC. http://angular.io/license
     *
     * See:
     * - https://github.com/angular/angular/blob/6f5f481fdae03f1d8db36284b64c7b82d9519d85/packages/service-worker/config/src/glob.ts
     * - https://github.com/angular/angular/blob/6f5f481fdae03f1d8db36284b64c7b82d9519d85/aio/tests/deployment/shared/helpers.ts#L17
     * - https://github.com/angular/angular/blob/6f5f481fdae03f1d8db36284b64c7b82d9519d85/packages/service-worker/config/src/generator.ts#L86
     */
    var QUESTION_MARK = '[^/]';
    var WILD_SINGLE = '[^/]*';
    var WILD_OPEN = '(?:.+\\/)?';
    var TO_ESCAPE_BASE = [
        { replace: /\./g, with: '\\.' },
        { replace: /\+/g, with: '\\+' },
        { replace: /\*/g, with: WILD_SINGLE },
    ];
    var TO_ESCAPE_WILDCARD_QM = __spreadArray(__spreadArray([], __read(TO_ESCAPE_BASE)), [
        { replace: /\?/g, with: QUESTION_MARK },
    ]);
    var TO_ESCAPE_LITERAL_QM = __spreadArray(__spreadArray([], __read(TO_ESCAPE_BASE)), [
        { replace: /\?/g, with: '\\?' },
    ]);
    /**
     * Converts the glob-like pattern into regex string.
     *
     * Patterns use a limited glob format:
     * `**` matches 0 or more path segments
     * `*` matches 0 or more characters excluding `/`
     * `?` matches exactly one character excluding `/` (but when @param literalQuestionMark is true, `?` is treated as normal character)
     * The `!` prefix marks the pattern as being negative, meaning that only URLs that don't match the pattern will be included
     *
     * @param glob glob-like pattern
     * @param literalQuestionMark when true, it tells that `?` is treated as a normal character
     */
    function globToRegex(glob, literalQuestionMark) {
        if (literalQuestionMark === void 0) { literalQuestionMark = false; }
        var toEscape = literalQuestionMark
            ? TO_ESCAPE_LITERAL_QM
            : TO_ESCAPE_WILDCARD_QM;
        var segments = glob.split('/').reverse();
        var regex = '';
        while (segments.length > 0) {
            var segment = segments.pop();
            if (segment === '**') {
                if (segments.length > 0) {
                    regex += WILD_OPEN;
                }
                else {
                    regex += '.*';
                }
            }
            else {
                var processed = toEscape.reduce(function (seg, escape) { return seg.replace(escape.replace, escape.with); }, segment);
                regex += processed;
                if (segments.length > 0) {
                    regex += '\\/';
                }
            }
        }
        return regex;
    }
    /**
     * For given list of glob-like patterns, returns a matcher function.
     *
     * The matcher returns true for given URL only when ANY of the positive patterns is matched and NONE of the negative ones.
     */
    function getGlobMatcher(patterns) {
        var processedPatterns = processGlobPatterns(patterns).map(function (_a) {
            var positive = _a.positive, regex = _a.regex;
            return ({
                positive: positive,
                regex: new RegExp(regex),
            });
        });
        var includePatterns = processedPatterns.filter(function (spec) { return spec.positive; });
        var excludePatterns = processedPatterns.filter(function (spec) { return !spec.positive; });
        return function (url) { return includePatterns.some(function (pattern) { return pattern.regex.test(url); }) &&
            !excludePatterns.some(function (pattern) { return pattern.regex.test(url); }); };
    }
    /**
     * Converts list of glob-like patterns into list of RegExps with information whether the glob pattern is positive or negative
     */
    function processGlobPatterns(urls) {
        return urls.map(function (url) {
            var positive = !url.startsWith('!');
            url = positive ? url : url.substr(1);
            return { positive: positive, regex: "^" + globToRegex(url) + "$" };
        });
    }

    var GlobService = /** @class */ (function () {
        function GlobService() {
        }
        /**
         * For given list of glob-like patterns, returns a validator function.
         *
         * The validator returns true for given URL only when ANY of the positive patterns is matched and NONE of the negative ones.
         */
        GlobService.prototype.getValidator = function (patterns) {
            var processedPatterns = processGlobPatterns(patterns).map(function (_a) {
                var positive = _a.positive, regex = _a.regex;
                return ({
                    positive: positive,
                    regex: new RegExp(regex),
                });
            });
            var includePatterns = processedPatterns.filter(function (spec) { return spec.positive; });
            var excludePatterns = processedPatterns.filter(function (spec) { return !spec.positive; });
            return function (url) { return includePatterns.some(function (pattern) { return pattern.regex.test(url); }) &&
                !excludePatterns.some(function (pattern) { return pattern.regex.test(url); }); };
        };
        return GlobService;
    }());
    GlobService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: GlobService, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    GlobService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: GlobService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: GlobService, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }] });

    var UrlMatcherService = /** @class */ (function () {
        function UrlMatcherService(globService) {
            this.globService = globService;
        }
        /**
         * Returns a matcher that is always fails
         */
        UrlMatcherService.prototype.getFalsy = function () {
            return function falsyUrlMatcher() {
                return null;
            };
        };
        /**
         * Returns a matcher for given list of paths
         */
        UrlMatcherService.prototype.getFromPaths = function (paths) {
            var _this = this;
            var matchers = paths.map(function (path) { return _this.getFromPath(path); });
            var matcher = this.getCombined(matchers);
            if (i0.isDevMode()) {
                matcher['_paths'] = paths; // property added for easier debugging of routes
            }
            return matcher;
        };
        /**
         * Returns a matcher that combines the given matchers
         * */
        UrlMatcherService.prototype.getCombined = function (matchers) {
            var matcher = function combinedUrlMatchers(segments, segmentGroup, route) {
                for (var i = 0; i < matchers.length; i++) {
                    var result = matchers[i](segments, segmentGroup, route);
                    if (result) {
                        return result;
                    }
                }
                return null;
            };
            if (i0.isDevMode()) {
                matcher['_matchers'] = matchers; // property added for easier debugging of routes
            }
            return matcher;
        };
        /**
         * Similar to Angular's defaultUrlMatcher. Differences:
         * - the `path` comes from function's argument, not from `route.path`
         * - the empty path `''` is handled here, but in Angular is handled one level higher in the match() function
         */
        UrlMatcherService.prototype.getFromPath = function (path) {
            if (path === void 0) { path = ''; }
            var matcher = function pathUrlMatcher(segments, segmentGroup, route) {
                /**
                 * @license
                 * The MIT License
                 * Copyright (c) 2010-2019 Google LLC. http://angular.io/license
                 *
                 * See:
                 * - https://github.com/angular/angular/blob/6f5f481fdae03f1d8db36284b64c7b82d9519d85/packages/router/src/shared.ts#L121
                 */
                // use function's argument, not the `route.path`
                if (path === '') {
                    if (route.pathMatch === 'full' &&
                        (segmentGroup.hasChildren() || segments.length > 0)) {
                        return null;
                    }
                    return { consumed: [], posParams: {} };
                }
                var parts = path.split('/'); // use function's argument, not the `route.path`
                if (parts.length > segments.length) {
                    // The actual URL is shorter than the config, no match
                    return null;
                }
                if (route.pathMatch === 'full' &&
                    (segmentGroup.hasChildren() || parts.length < segments.length)) {
                    // The config is longer than the actual URL but we are looking for a full match, return null
                    return null;
                }
                var posParams = {};
                // Check each config part against the actual URL
                for (var index = 0; index < parts.length; index++) {
                    var part = parts[index];
                    var segment = segments[index];
                    var isParameter = part.startsWith(':');
                    if (isParameter) {
                        posParams[part.substring(1)] = segment;
                    }
                    else if (part !== segment.path) {
                        // The actual URL part does not match the config, no match
                        return null;
                    }
                }
                return { consumed: segments.slice(0, parts.length), posParams: posParams };
            };
            if (i0.isDevMode()) {
                matcher['_path'] = path; // property added for easier debugging of routes
            }
            return matcher;
        };
        /**
         * Returns URL matcher that accepts almost everything (like `**` route), but not paths accepted by the given matcher
         */
        UrlMatcherService.prototype.getOpposite = function (originalMatcher) {
            var matcher = function oppositeUrlMatcher(segments, group, route) {
                return originalMatcher(segments, group, route)
                    ? null
                    : { consumed: segments, posParams: {} };
            };
            if (i0.isDevMode()) {
                matcher['_originalMatcher'] = originalMatcher; // property added for easier debugging of routes
            }
            return matcher;
        };
        /**
         * Returns URL matcher for the given list of glob-like patterns. Each pattern must start with `/` or `!/`.
         */
        UrlMatcherService.prototype.getFromGlob = function (globPatterns) {
            var globValidator = this.globService.getValidator(globPatterns);
            var matcher = function globUrlMatcher(segments) {
                var fullPath = "/" + segments.map(function (s) { return s.path; }).join('/');
                return globValidator(fullPath)
                    ? { consumed: segments, posParams: {} }
                    : null;
            };
            if (i0.isDevMode()) {
                matcher['_globPatterns'] = globPatterns; // property added for easier debugging of routes
            }
            return matcher;
        };
        return UrlMatcherService;
    }());
    UrlMatcherService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UrlMatcherService, deps: [{ token: GlobService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    UrlMatcherService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UrlMatcherService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UrlMatcherService, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }], ctorParameters: function () { return [{ type: GlobService }]; } });

    var ConfigurableRoutesService = /** @class */ (function () {
        function ConfigurableRoutesService(injector, routingConfigService, urlMatcherService) {
            this.injector = injector;
            this.routingConfigService = routingConfigService;
            this.urlMatcherService = urlMatcherService;
            this.initCalled = false; // guard not to call init() more than once
        }
        /**
         * Enhances existing Angular routes using the routing config of Spartacus.
         * Can be called only once.
         */
        ConfigurableRoutesService.prototype.init = function () {
            if (!this.initCalled) {
                this.initCalled = true;
                this.configure();
            }
        };
        /**
         * Enhances existing Angular routes using the routing config of Spartacus.
         */
        ConfigurableRoutesService.prototype.configure = function () {
            // Router could not be injected in constructor due to cyclic dependency with APP_INITIALIZER:
            var router = this.injector.get(i1$2.Router);
            router.resetConfig(this.configureRoutes(router.config));
        };
        /**
         * Sets the property `path` or `matcher` for the given routes, based on the Spartacus' routing configuration.
         *
         * @param routes list of Angular `Route` objects
         */
        ConfigurableRoutesService.prototype.configureRoutes = function (routes) {
            var _this = this;
            return routes.map(function (route) {
                var configuredRoute = _this.configureRoute(route);
                if (route.children && route.children.length) {
                    configuredRoute.children = _this.configureRoutes(route.children);
                }
                return configuredRoute;
            });
        };
        /**
         * Sets the property `path` or `matcher` of the `Route`, based on the Spartacus' routing configuration.
         * Uses the property `data.cxRoute` to determine the name of the route.
         * It's the same name used as a key in the routing configuration: `routing.routes[ROUTE NAME]`.
         *
         * @param route Angular `Route` object
         */
        ConfigurableRoutesService.prototype.configureRoute = function (route) {
            var _a;
            var routeName = this.getRouteName(route);
            if (routeName) {
                var routeConfig = this.routingConfigService.getRouteConfig(routeName);
                this.validateRouteConfig(routeConfig, routeName, route);
                if (routeConfig === null || routeConfig === void 0 ? void 0 : routeConfig.disabled) {
                    delete route.path;
                    return Object.assign(Object.assign({}, route), { matcher: this.urlMatcherService.getFalsy() });
                }
                else if (routeConfig === null || routeConfig === void 0 ? void 0 : routeConfig.matchers) {
                    delete route.path;
                    return Object.assign(Object.assign({}, route), { matcher: this.resolveUrlMatchers(route, routeConfig === null || routeConfig === void 0 ? void 0 : routeConfig.matchers) });
                }
                else if (((_a = routeConfig === null || routeConfig === void 0 ? void 0 : routeConfig.paths) === null || _a === void 0 ? void 0 : _a.length) === 1) {
                    delete route.matcher;
                    return Object.assign(Object.assign({}, route), { path: routeConfig === null || routeConfig === void 0 ? void 0 : routeConfig.paths[0] });
                }
                else {
                    delete route.path;
                    return Object.assign(Object.assign({}, route), { matcher: this.urlMatcherService.getFromPaths((routeConfig === null || routeConfig === void 0 ? void 0 : routeConfig.paths) || []) });
                }
            }
            return route; // if route doesn't have a name, just pass the original route
        };
        /**
         * Creates a single `UrlMatcher` based on given matchers and factories of matchers.
         *
         * @param route Route object
         * @param matchersOrFactories `UrlMatcher`s or injection tokens with a factory functions
         *  that create UrlMatchers based on the given route.
         */
        ConfigurableRoutesService.prototype.resolveUrlMatchers = function (route, matchersOrFactories) {
            var _this = this;
            var matchers = matchersOrFactories.map(function (matcherOrFactory) {
                return typeof matcherOrFactory === 'function'
                    ? matcherOrFactory // matcher
                    : _this.resolveUrlMatcherFactory(route, matcherOrFactory); // factory injection token
            });
            return this.urlMatcherService.getCombined(matchers);
        };
        /**
         * Creates an `UrlMatcher` based on the given route, using the factory function coming from the given injection token.
         *
         * @param route Route object
         * @param factoryToken injection token with a factory function that will create an UrlMatcher using given route
         */
        ConfigurableRoutesService.prototype.resolveUrlMatcherFactory = function (route, factoryToken) {
            var factory = this.injector.get(factoryToken);
            return factory(route);
        };
        /**
         * Returns the name of the Route stored in its property `data.cxRoute`
         * @param route
         */
        ConfigurableRoutesService.prototype.getRouteName = function (route) {
            return route.data && route.data.cxRoute;
        };
        ConfigurableRoutesService.prototype.validateRouteConfig = function (routeConfig, routeName, route) {
            if (i0.isDevMode()) {
                // - null value of routeConfig or routeConfig.paths means explicit switching off the route - it's valid config
                // - routeConfig with defined `matchers` is valid, even if `paths` are undefined
                if (routeConfig === null ||
                    (routeConfig === null || routeConfig === void 0 ? void 0 : routeConfig.paths) === null ||
                    (routeConfig === null || routeConfig === void 0 ? void 0 : routeConfig.matchers)) {
                    return;
                }
                // undefined value of routeConfig or routeConfig.paths is a misconfiguration
                if (!(routeConfig === null || routeConfig === void 0 ? void 0 : routeConfig.paths)) {
                    this.warn("Could not configure the named route '" + routeName + "'", route, "due to undefined config or undefined 'paths' property for this route");
                    return;
                }
            }
        };
        ConfigurableRoutesService.prototype.warn = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            if (i0.isDevMode()) {
                console.warn.apply(console, __spreadArray([], __read(args)));
            }
        };
        return ConfigurableRoutesService;
    }());
    ConfigurableRoutesService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ConfigurableRoutesService, deps: [{ token: i0__namespace.Injector }, { token: RoutingConfigService }, { token: UrlMatcherService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ConfigurableRoutesService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ConfigurableRoutesService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ConfigurableRoutesService, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }], ctorParameters: function () { return [{ type: i0__namespace.Injector }, { type: RoutingConfigService }, { type: UrlMatcherService }]; } });

    var ProductURLPipe = /** @class */ (function () {
        function ProductURLPipe(semanticPath) {
            this.semanticPath = semanticPath;
        }
        ProductURLPipe.prototype.transform = function (product) {
            return this.semanticPath.transform({ cxRoute: 'product', params: product });
        };
        return ProductURLPipe;
    }());
    ProductURLPipe.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductURLPipe, deps: [{ token: SemanticPathService }], target: i0__namespace.ɵɵFactoryTarget.Pipe });
    ProductURLPipe.ɵpipe = i0__namespace.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductURLPipe, name: "cxProductUrl" });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductURLPipe, decorators: [{
                type: i0.Pipe,
                args: [{
                        name: 'cxProductUrl',
                    }]
            }], ctorParameters: function () { return [{ type: SemanticPathService }]; } });

    var UrlPipe = /** @class */ (function () {
        function UrlPipe(urlService) {
            this.urlService = urlService;
        }
        UrlPipe.prototype.transform = function (commands) {
            return this.urlService.transform(commands);
        };
        return UrlPipe;
    }());
    UrlPipe.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UrlPipe, deps: [{ token: SemanticPathService }], target: i0__namespace.ɵɵFactoryTarget.Pipe });
    UrlPipe.ɵpipe = i0__namespace.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UrlPipe, name: "cxUrl" });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UrlPipe, decorators: [{
                type: i0.Pipe,
                args: [{
                        name: 'cxUrl',
                    }]
            }], ctorParameters: function () { return [{ type: SemanticPathService }]; } });

    var UrlModule = /** @class */ (function () {
        function UrlModule() {
        }
        return UrlModule;
    }());
    UrlModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UrlModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    UrlModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UrlModule, declarations: [UrlPipe, ProductURLPipe], imports: [i6.CommonModule], exports: [UrlPipe, ProductURLPipe] });
    UrlModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UrlModule, imports: [[i6.CommonModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UrlModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [i6.CommonModule],
                        declarations: [UrlPipe, ProductURLPipe],
                        exports: [UrlPipe, ProductURLPipe],
                    }]
            }] });

    var ExternalRoutesConfig = /** @class */ (function () {
        function ExternalRoutesConfig() {
        }
        return ExternalRoutesConfig;
    }());
    ExternalRoutesConfig.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ExternalRoutesConfig, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ExternalRoutesConfig.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ExternalRoutesConfig, providedIn: 'root', useExisting: Config });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ExternalRoutesConfig, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                        useExisting: Config,
                    }]
            }] });

    var ExternalRoutesGuard = /** @class */ (function () {
        function ExternalRoutesGuard(winRef, platformId) {
            this.winRef = winRef;
            this.platformId = platformId;
        }
        /**
         * Redirects to different storefront system for anticipated URL
         */
        ExternalRoutesGuard.prototype.canActivate = function (route, state) {
            if (i6.isPlatformBrowser(this.platformId)) {
                this.redirect(route, state);
            }
            return false;
        };
        /**
         * Redirects to anticipated URL using full page reload, not Angular routing
         */
        ExternalRoutesGuard.prototype.redirect = function (_, state) {
            var window = this.winRef.nativeWindow;
            if (window && window.location) {
                window.location.href = state.url;
            }
        };
        return ExternalRoutesGuard;
    }());
    ExternalRoutesGuard.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ExternalRoutesGuard, deps: [{ token: WindowRef }, { token: i0.PLATFORM_ID }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ExternalRoutesGuard.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ExternalRoutesGuard, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ExternalRoutesGuard, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }], ctorParameters: function () {
            return [{ type: WindowRef }, { type: Object, decorators: [{
                            type: i0.Inject,
                            args: [i0.PLATFORM_ID]
                        }] }];
        } });

    function addExternalRoutesFactory(service) {
        var result = function () {
            service.addRoutes();
        };
        return result;
    }

    /**
     * Service that helps redirecting to different storefront systems for configured URLs
     */
    var ExternalRoutesService = /** @class */ (function () {
        function ExternalRoutesService(config, urlMatcherService, injector) {
            this.config = config;
            this.urlMatcherService = urlMatcherService;
            this.injector = injector;
        }
        Object.defineProperty(ExternalRoutesService.prototype, "internalUrlPatterns", {
            get: function () {
                return ((this.config && this.config.routing && this.config.routing.internal) || []);
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Prepends routes (to the Router.config) that are responsible for redirecting to a different storefront system
         */
        ExternalRoutesService.prototype.addRoutes = function () {
            var router = this.injector.get(i1$2.Router);
            var newRoutes = this.getRoutes();
            if (newRoutes.length) {
                router.resetConfig(__spreadArray(__spreadArray([], __read(newRoutes)), __read(router.config)));
            }
        };
        /**
         * Returns routes that are responsible for redirection to different storefront systems
         */
        ExternalRoutesService.prototype.getRoutes = function () {
            if (!this.internalUrlPatterns.length) {
                return [];
            }
            var routes = [];
            routes.push({
                pathMatch: 'full',
                matcher: this.getUrlMatcher(),
                canActivate: [ExternalRoutesGuard],
                component: {},
            });
            return routes;
        };
        /**
         * Returns the URL matcher for the external route
         */
        ExternalRoutesService.prototype.getUrlMatcher = function () {
            var matcher = this.urlMatcherService.getFromGlob(this.internalUrlPatterns);
            return this.urlMatcherService.getOpposite(matcher); // the external route should be activated only when it's NOT an internal route
        };
        return ExternalRoutesService;
    }());
    ExternalRoutesService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ExternalRoutesService, deps: [{ token: ExternalRoutesConfig }, { token: UrlMatcherService }, { token: i0__namespace.Injector }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ExternalRoutesService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ExternalRoutesService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ExternalRoutesService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: ExternalRoutesConfig }, { type: UrlMatcherService }, { type: i0__namespace.Injector }]; } });

    /**
     * Prepends the external route that redirects to a different storefront system for configured URLs
     */
    var ExternalRoutesModule = /** @class */ (function () {
        function ExternalRoutesModule() {
        }
        ExternalRoutesModule.forRoot = function () {
            return {
                ngModule: ExternalRoutesModule,
                providers: [
                    {
                        provide: i0.APP_INITIALIZER,
                        multi: true,
                        useFactory: addExternalRoutesFactory,
                        deps: [ExternalRoutesService],
                    },
                ],
            };
        };
        return ExternalRoutesModule;
    }());
    ExternalRoutesModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ExternalRoutesModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    ExternalRoutesModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ExternalRoutesModule });
    ExternalRoutesModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ExternalRoutesModule });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ExternalRoutesModule, decorators: [{
                type: i0.NgModule
            }] });

    /**
     * The homepage id for the CMS homepage is not required when we query the backend.
     * CMS business users can have multiple pages, that they might switch quickly without
     * changing the page id. Therefore, we use a constant to keep track of the page in the
     * store, but are able to ignore the id while querying the backend.
     */
    var HOME_PAGE_CONTEXT = '__HOMEPAGE__';
    /**
     * SmartEdit preview page is loaded by previewToken which is added by interceptor
     */
    var SMART_EDIT_CONTEXT = 'smartedit-preview';
    var PageContext = /** @class */ (function () {
        function PageContext(id, type) {
            this.id = id;
            this.type = type;
        }
        return PageContext;
    }());

    var ProtectedRoutesService = /** @class */ (function () {
        function ProtectedRoutesService(config, urlParsingService) {
            var _this = this;
            this.config = config;
            this.urlParsingService = urlParsingService;
            this.nonProtectedPaths = []; // arrays of paths' segments list
            if (this.shouldProtect) {
                // pre-process config for performance:
                this.nonProtectedPaths = this.getNonProtectedPaths().map(function (path) { return _this.getSegments(path); });
            }
        }
        Object.defineProperty(ProtectedRoutesService.prototype, "routingConfig", {
            get: function () {
                return this.config && this.config.routing;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ProtectedRoutesService.prototype, "shouldProtect", {
            /**
             * Returns 'protected' property (boolean) from routing config
             *
             * @returns boolean
             */
            get: function () {
                var _a;
                return !!((_a = this.routingConfig) === null || _a === void 0 ? void 0 : _a.protected);
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Tells if the url is protected
         */
        ProtectedRoutesService.prototype.isUrlProtected = function (urlSegments) {
            return (this.shouldProtect &&
                !this.matchAnyPath(urlSegments, this.nonProtectedPaths));
        };
        /**
         * Tells whether the url matches at least one of the paths
         */
        ProtectedRoutesService.prototype.matchAnyPath = function (urlSegments, pathsSegments) {
            var _this = this;
            return pathsSegments.some(function (pathSegments) { return _this.matchPath(urlSegments, pathSegments); });
        };
        /**
         * Tells whether the url matches the path
         */
        ProtectedRoutesService.prototype.matchPath = function (urlSegments, pathSegments) {
            return this.urlParsingService.matchPath(urlSegments, pathSegments);
        };
        /**
         * Returns a list of paths that are not protected
         */
        ProtectedRoutesService.prototype.getNonProtectedPaths = function () {
            var _a, _b;
            return Object.values((_b = (_a = this.routingConfig) === null || _a === void 0 ? void 0 : _a.routes) !== null && _b !== void 0 ? _b : {}).reduce(function (acc, routeConfig) {
                var _a;
                return routeConfig.protected === false && // must be explicitly false, ignore undefined
                    routeConfig.paths &&
                    routeConfig.paths.length
                    ? acc.concat((_a = routeConfig === null || routeConfig === void 0 ? void 0 : routeConfig.paths) !== null && _a !== void 0 ? _a : [])
                    : acc;
            }, []);
        };
        /**
         * Splits the url by slashes
         */
        ProtectedRoutesService.prototype.getSegments = function (url) {
            return (url || '').split('/');
        };
        return ProtectedRoutesService;
    }());
    ProtectedRoutesService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProtectedRoutesService, deps: [{ token: RoutingConfig }, { token: UrlParsingService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ProtectedRoutesService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProtectedRoutesService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProtectedRoutesService, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }], ctorParameters: function () { return [{ type: RoutingConfig }, { type: UrlParsingService }]; } });

    var ProtectedRoutesGuard = /** @class */ (function () {
        function ProtectedRoutesGuard(service, authGuard) {
            this.service = service;
            this.authGuard = authGuard;
        }
        /**
         * When the anticipated url is protected, it switches to the AuthGuard. Otherwise emits true.
         */
        ProtectedRoutesGuard.prototype.canActivate = function (route) {
            var urlSegments = route.url.map(function (seg) { return seg.path; });
            // For the root path `/` ActivatedRoute contains an empty array of segments:
            urlSegments = urlSegments.length ? urlSegments : [''];
            if (this.service.isUrlProtected(urlSegments)) {
                return this.authGuard.canActivate();
            }
            return rxjs.of(true);
        };
        return ProtectedRoutesGuard;
    }());
    ProtectedRoutesGuard.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProtectedRoutesGuard, deps: [{ token: ProtectedRoutesService }, { token: AuthGuard }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ProtectedRoutesGuard.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProtectedRoutesGuard, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProtectedRoutesGuard, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }], ctorParameters: function () { return [{ type: ProtectedRoutesService }, { type: AuthGuard }]; } });

    var RouterEffects = /** @class */ (function () {
        function RouterEffects(actions$, router) {
            var _this = this;
            this.actions$ = actions$;
            this.router = router;
            this.clearCmsRoutes$ = this.actions$.pipe(i1$4.ofType(LANGUAGE_CHANGE, LOGOUT, LOGIN), operators.tap(function () {
                var filteredConfig = _this.router.config.filter(function (route) { return !(route.data && route.data.cxCmsRouteContext); });
                if (filteredConfig.length !== _this.router.config.length) {
                    _this.router.resetConfig(filteredConfig);
                }
            }));
        }
        return RouterEffects;
    }());
    RouterEffects.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: RouterEffects, deps: [{ token: i1__namespace$4.Actions }, { token: i1__namespace$1.Router }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    RouterEffects.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: RouterEffects });
    __decorate([
        i1$4.Effect({ dispatch: false })
    ], RouterEffects.prototype, "clearCmsRoutes$", void 0);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: RouterEffects, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: i1__namespace$4.Actions }, { type: i1__namespace$1.Router }]; }, propDecorators: { clearCmsRoutes$: [] } });

    var effects$2 = [RouterEffects];

    var initialState$o = {
        navigationId: 0,
        state: {
            url: '',
            queryParams: {},
            params: {},
            context: {
                id: '',
            },
            cmsRequired: false,
            semanticRoute: undefined,
        },
        nextState: undefined,
    };
    function getReducers$5() {
        return {
            router: reducer$o,
        };
    }
    function reducer$o(state, action) {
        if (state === void 0) { state = initialState$o; }
        var _a, _b;
        switch (action.type) {
            case fromNgrxRouter__namespace.ROUTER_NAVIGATION: {
                return Object.assign(Object.assign({}, state), { nextState: action.payload.routerState, navigationId: action.payload.event.id });
            }
            case fromNgrxRouter__namespace.ROUTER_ERROR:
            case fromNgrxRouter__namespace.ROUTER_CANCEL: {
                return Object.assign(Object.assign({}, state), { nextState: undefined });
            }
            case CHANGE_NEXT_PAGE_CONTEXT: {
                return state.nextState
                    ? Object.assign(Object.assign({}, state), { nextState: Object.assign(Object.assign({}, state.nextState), { context: action.payload }) }) : state;
            }
            case fromNgrxRouter__namespace.ROUTER_NAVIGATED: {
                return {
                    state: Object.assign(Object.assign({}, action.payload.routerState), { context: 
                        // we want to preserve already resolved context,
                        // in case it was changed while navigating
                        (_b = (_a = state.nextState) === null || _a === void 0 ? void 0 : _a.context) !== null && _b !== void 0 ? _b : action.payload.routerState.context }),
                    navigationId: action.payload.event.id,
                    nextState: undefined,
                };
            }
            default: {
                return state;
            }
        }
    }
    var reducerToken$5 = new i0.InjectionToken('RouterReducers');
    var reducerProvider$5 = {
        provide: reducerToken$5,
        useFactory: getReducers$5,
    };
    /* The serializer is there to parse the RouterStateSnapshot,
    and to reduce the amount of properties to be passed to the reducer.
     */
    var CustomSerializer = /** @class */ (function () {
        function CustomSerializer(routingConfig) {
            this.routingConfig = routingConfig;
        }
        CustomSerializer.prototype.serialize = function (routerState) {
            var _a, _b;
            var state = routerState.root;
            var cmsRequired = false;
            var context;
            var semanticRoute;
            var urlString = '';
            while (state.firstChild) {
                state = state.firstChild;
                urlString +=
                    '/' + state.url.map(function (urlSegment) { return urlSegment.path; }).join('/');
                // we use semantic route information embedded from any parent route
                if ((_a = state.data) === null || _a === void 0 ? void 0 : _a.cxRoute) {
                    semanticRoute = (_b = state.data) === null || _b === void 0 ? void 0 : _b.cxRoute;
                }
                // we use context information embedded in Cms driven routes from any parent route
                if (state.data && state.data.cxCmsRouteContext) {
                    context = state.data.cxCmsRouteContext;
                }
                // we assume, that any route that has CmsPageGuard or it's child
                // is cmsRequired
                if (!cmsRequired &&
                    (context ||
                        (state.routeConfig &&
                            state.routeConfig.canActivate &&
                            state.routeConfig.canActivate.find(function (x) { return x && x.guardName === 'CmsPageGuard'; })))) {
                    cmsRequired = true;
                }
            }
            // If `semanticRoute` couldn't be already recognized using `data.cxRoute` property
            // let's lookup the routing configuration to find the semantic route that has exactly the same configured path as the current URL.
            // This will work only for simple URLs without any dynamic routing parameters.
            semanticRoute = semanticRoute || this.lookupSemanticRoute(urlString);
            var params = state.params;
            // we give smartedit preview page a PageContext
            if (state.url.length > 0 && state.url[0].path === 'cx-preview') {
                context = {
                    id: SMART_EDIT_CONTEXT,
                    type: exports.PageType.CONTENT_PAGE,
                };
            }
            else {
                if (params['productCode']) {
                    context = { id: params['productCode'], type: exports.PageType.PRODUCT_PAGE };
                }
                else if (params['categoryCode']) {
                    context = { id: params['categoryCode'], type: exports.PageType.CATEGORY_PAGE };
                }
                else if (params['brandCode']) {
                    context = { id: params['brandCode'], type: exports.PageType.CATEGORY_PAGE };
                }
                else if (state.data.pageLabel !== undefined) {
                    context = { id: state.data.pageLabel, type: exports.PageType.CONTENT_PAGE };
                }
                else if (!context) {
                    if (state.url.length > 0) {
                        var pageLabel = '/' + state.url.map(function (urlSegment) { return urlSegment.path; }).join('/');
                        context = {
                            id: pageLabel,
                            type: exports.PageType.CONTENT_PAGE,
                        };
                    }
                    else {
                        context = {
                            // We like URLs to be driven by the backend, the CMS actually returns the homepage
                            // if no page label is given. Our logic however requires an id. undefined doesn't work.
                            id: HOME_PAGE_CONTEXT,
                            // We currently need to support a hardcoded page type, since the internal store uses the page
                            // type to store the content.
                            type: exports.PageType.CONTENT_PAGE,
                        };
                    }
                }
            }
            return {
                url: routerState.url,
                queryParams: routerState.root.queryParams,
                params: params,
                context: context,
                cmsRequired: cmsRequired,
                semanticRoute: semanticRoute,
            };
        };
        /**
         * Returns the semantic route name for given page label.
         *
         * *NOTE*: It works only for simple static urls that are equal to the page label
         * of cms-driven content page. For example: `/my-account/address-book`.
         *
         * It doesn't work for URLs with dynamic parameters. But such case can be handled
         * by reading the defined `data.cxRoute` from the Angular Routes.
         *
         * @param path path to be found in the routing config
         */
        CustomSerializer.prototype.lookupSemanticRoute = function (path) {
            // Page label is assumed to start with `/`, but Spartacus configured paths
            // don't start with slash. So we remove the leading slash:
            return this.routingConfig.getRouteName(path.substr(1));
        };
        return CustomSerializer;
    }());
    CustomSerializer.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CustomSerializer, deps: [{ token: RoutingConfigService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    CustomSerializer.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CustomSerializer });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CustomSerializer, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: RoutingConfigService }]; } });

    function initConfigurableRoutes(service) {
        var result = function () { return service.init(); }; // workaround for AOT compilation (see https://stackoverflow.com/a/51977115)
        return result;
    }
    var RoutingModule = /** @class */ (function () {
        function RoutingModule() {
        }
        RoutingModule.forRoot = function () {
            return {
                ngModule: RoutingModule,
                providers: [
                    reducerProvider$5,
                    {
                        provide: fromNgrxRouter.RouterStateSerializer,
                        useClass: CustomSerializer,
                    },
                    {
                        provide: i0.APP_INITIALIZER,
                        useFactory: initConfigurableRoutes,
                        deps: [ConfigurableRoutesService],
                        multi: true,
                    },
                ],
            };
        };
        return RoutingModule;
    }());
    RoutingModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: RoutingModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    RoutingModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: RoutingModule, imports: [i1__namespace$2.StoreFeatureModule, i1__namespace$4.EffectsFeatureModule, fromNgrxRouter__namespace.StoreRouterConnectingModule] });
    RoutingModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: RoutingModule, imports: [[
                i1.StoreModule.forFeature(ROUTING_FEATURE, reducerToken$5),
                i1$4.EffectsModule.forFeature(effects$2),
                fromNgrxRouter.StoreRouterConnectingModule.forRoot({
                    routerState: 1 /* Minimal */,
                    stateKey: ROUTING_FEATURE, // name of reducer key
                }),
            ]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: RoutingModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [
                            i1.StoreModule.forFeature(ROUTING_FEATURE, reducerToken$5),
                            i1$4.EffectsModule.forFeature(effects$2),
                            fromNgrxRouter.StoreRouterConnectingModule.forRoot({
                                routerState: 1 /* Minimal */,
                                stateKey: ROUTING_FEATURE, // name of reducer key
                            }),
                        ],
                    }]
            }] });

    function getDefaultUrlMatcherFactory(routingConfigService, urlMatcherService) {
        var factory = function (route) {
            var routeName = route.data && route.data['cxRoute'];
            var routeConfig = routingConfigService.getRouteConfig(routeName);
            var paths = (routeConfig && routeConfig.paths) || [];
            return urlMatcherService.getFromPaths(paths);
        };
        return factory;
    }
    /**
     * Injection token with url matcher factory for spartacus routes containing property `data.cxRoute`.
     * The provided url matcher matches the configured `paths` from routing config.
     *
     * If this matcher doesn't fit the requirements, it can be replaced with custom matcher
     * or additional matchers can be added for a specific route. See for example PRODUCT_DETAILS_URL_MATCHER.
     *
     * Note: Matchers will "match" a route, but do not contribute to the creation of the route, nor do they guard routes.
     */
    var DEFAULT_URL_MATCHER = new i0.InjectionToken('DEFAULT_URL_MATCHER', {
        providedIn: 'root',
        factory: function () { return getDefaultUrlMatcherFactory(i0.inject(RoutingConfigService), i0.inject(UrlMatcherService)); },
    });

    var NavigationEntryItemEffects = /** @class */ (function () {
        function NavigationEntryItemEffects(actions$, cmsComponentConnector, routingService) {
            var _this = this;
            this.actions$ = actions$;
            this.cmsComponentConnector = cmsComponentConnector;
            this.routingService = routingService;
            this.loadNavigationItems$ = this.actions$.pipe(i1$4.ofType(LOAD_CMS_NAVIGATION_ITEMS), operators.map(function (action) { return action.payload; }), operators.map(function (payload) {
                return {
                    ids: _this.getIdListByItemType(payload.items),
                    nodeId: payload.nodeId,
                };
            }), operators.mergeMap(function (data) {
                if (data.ids.componentIds.length > 0) {
                    return _this.routingService.getRouterState().pipe(operators.filter(isNotUndefined), operators.map(function (routerState) { return routerState.state.context; }), operators.take(1), operators.mergeMap(function (pageContext) {
                        // download all items in one request
                        return _this.cmsComponentConnector
                            .getList(data.ids.componentIds, pageContext)
                            .pipe(operators.map(function (components) { return new LoadCmsNavigationItemsSuccess({
                            nodeId: data.nodeId,
                            components: components,
                        }); }), operators.catchError(function (error) { return rxjs.of(new LoadCmsNavigationItemsFail(data.nodeId, normalizeHttpError(error))); }));
                    }));
                }
                else if (data.ids.pageIds.length > 0) {
                    // TODO: future work
                    // dispatch action to load cms page one by one
                }
                else if (data.ids.mediaIds.length > 0) {
                    // TODO: future work
                    // send request to get list of media
                }
                else {
                    return rxjs.of(new LoadCmsNavigationItemsFail(data.nodeId, 'navigation nodes are empty'));
                }
            }));
        }
        // We only consider 3 item types: cms page, cms component, and media.
        NavigationEntryItemEffects.prototype.getIdListByItemType = function (itemList) {
            var pageIds = [];
            var componentIds = [];
            var mediaIds = [];
            itemList.forEach(function (item) {
                if (item.superType === 'AbstractCMSComponent') {
                    componentIds.push(item.id);
                }
                else if (item.superType === 'AbstractPage') {
                    pageIds.push(item.id);
                }
                else if (item.superType === 'AbstractMedia') {
                    mediaIds.push(item.id);
                }
            });
            return { pageIds: pageIds, componentIds: componentIds, mediaIds: mediaIds };
        };
        return NavigationEntryItemEffects;
    }());
    NavigationEntryItemEffects.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: NavigationEntryItemEffects, deps: [{ token: i1__namespace$4.Actions }, { token: CmsComponentConnector }, { token: RoutingService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    NavigationEntryItemEffects.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: NavigationEntryItemEffects });
    __decorate([
        i1$4.Effect()
    ], NavigationEntryItemEffects.prototype, "loadNavigationItems$", void 0);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: NavigationEntryItemEffects, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: i1__namespace$4.Actions }, { type: CmsComponentConnector }, { type: RoutingService }]; }, propDecorators: { loadNavigationItems$: [] } });

    /**
     * Abstract class that can be used to implement custom loader logic
     * in order to load CMS structure from third-party CMS system.
     */
    var CmsPageAdapter = /** @class */ (function () {
        function CmsPageAdapter() {
        }
        return CmsPageAdapter;
    }());

    var CmsPageConnector = /** @class */ (function () {
        function CmsPageConnector(cmsPageAdapter, cmsStructureConfigService) {
            this.cmsPageAdapter = cmsPageAdapter;
            this.cmsStructureConfigService = cmsStructureConfigService;
        }
        /**
         * Returns an observable with the page structure. The page structure is
         * typically loaded from a backend, but can also be returned from static
         * configuration (see `CmsStructureConfigService`).
         */
        CmsPageConnector.prototype.get = function (pageContext) {
            var _this = this;
            return this.cmsStructureConfigService
                .shouldIgnoreBackend(pageContext.id)
                .pipe(operators.switchMap(function (loadFromConfig) {
                if (!loadFromConfig) {
                    return _this.cmsPageAdapter.load(pageContext).pipe(operators.catchError(function (error) {
                        if (error instanceof i1$3.HttpErrorResponse &&
                            error.status === 400) {
                            return rxjs.of({});
                        }
                        else {
                            return rxjs.throwError(error);
                        }
                    }));
                }
                else {
                    return rxjs.of({});
                }
            }), operators.switchMap(function (page) { return _this.mergeDefaultPageStructure(pageContext, page); }));
        };
        /**
         *
         * Merge default page structure to the given `CmsStructureModel`.
         * This is beneficial for a fast setup of the UI without necessary
         * fine-grained CMS setup.
         */
        CmsPageConnector.prototype.mergeDefaultPageStructure = function (pageContext, pageStructure) {
            return this.cmsStructureConfigService.mergePageStructure(pageContext.id, pageStructure);
        };
        return CmsPageConnector;
    }());
    CmsPageConnector.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CmsPageConnector, deps: [{ token: CmsPageAdapter }, { token: CmsStructureConfigService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    CmsPageConnector.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CmsPageConnector, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CmsPageConnector, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: CmsPageAdapter }, { type: CmsStructureConfigService }]; } });

    var PageEffects = /** @class */ (function () {
        function PageEffects(actions$, cmsPageConnector, routingService) {
            var _this = this;
            this.actions$ = actions$;
            this.cmsPageConnector = cmsPageConnector;
            this.routingService = routingService;
            this.refreshPage$ = this.actions$.pipe(i1$4.ofType(LANGUAGE_CHANGE, LOGOUT, LOGIN), operators.switchMap(function () { return _this.routingService.getRouterState().pipe(operators.filter(function (routerState) { return routerState &&
                routerState.state &&
                routerState.state.cmsRequired &&
                !routerState.nextState; }), operators.take(1), operators.map(function (routerState) { return routerState.state.context; }), operators.mergeMap(function (context) { return rxjs.of(new LoadCmsPageData(context)); })); }));
            this.loadPageData$ = this.actions$.pipe(i1$4.ofType(LOAD_CMS_PAGE_DATA), operators.map(function (action) { return action.payload; }), operators.groupBy(function (pageContext) { return serializePageContext(pageContext); }), operators.mergeMap(function (group) { return group.pipe(operators.switchMap(function (pageContext) { return _this.cmsPageConnector.get(pageContext).pipe(operators.mergeMap(function (cmsStructure) {
                var actions = [
                    new CmsGetComponentFromPage(cmsStructure.components.map(function (component) { return ({
                        component: component,
                        pageContext: pageContext,
                    }); })),
                    new LoadCmsPageDataSuccess(pageContext, cmsStructure.page),
                ];
                var pageLabel = cmsStructure.page.label;
                // For content pages the page label returned from backend can be different than page ID initially assumed from route.
                // In such a case let's save the success response not only for initially assumed page ID, but also for correct page label.
                if (pageLabel && pageLabel !== pageContext.id) {
                    actions.unshift(new CmsSetPageSuccessIndex({ id: pageLabel, type: pageContext.type }, cmsStructure.page));
                }
                return actions;
            }), operators.catchError(function (error) { return rxjs.of(new LoadCmsPageDataFail(pageContext, normalizeHttpError(error))); })); })); }));
        }
        return PageEffects;
    }());
    PageEffects.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PageEffects, deps: [{ token: i1__namespace$4.Actions }, { token: CmsPageConnector }, { token: RoutingService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    PageEffects.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PageEffects });
    __decorate([
        i1$4.Effect()
    ], PageEffects.prototype, "refreshPage$", void 0);
    __decorate([
        i1$4.Effect()
    ], PageEffects.prototype, "loadPageData$", void 0);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PageEffects, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: i1__namespace$4.Actions }, { type: CmsPageConnector }, { type: RoutingService }]; }, propDecorators: { refreshPage$: [], loadPageData$: [] } });

    var effects$1 = [
        PageEffects,
        ComponentsEffects,
        NavigationEntryItemEffects,
    ];

    var initialState$n = {
        component: undefined,
        pageContext: {},
    };
    function componentExistsReducer(state, action) {
        switch (action.type) {
            case LOAD_CMS_COMPONENT_FAIL:
                return false;
            case CMS_GET_COMPONENT_FROM_PAGE:
            case LOAD_CMS_COMPONENT_SUCCESS:
                return true;
        }
        return state;
    }
    function reducer$n(state, action) {
        var _a, _b, _c, _d;
        if (state === void 0) { state = initialState$n; }
        switch (action.type) {
            case LOAD_CMS_COMPONENT: {
                var pageContextReducer = loaderReducer(action.meta.entityType, componentExistsReducer);
                var context = serializePageContext(action.payload.pageContext, true);
                return Object.assign(Object.assign({}, state), { pageContext: Object.assign(Object.assign({}, state.pageContext), (_a = {}, _a[context] = pageContextReducer(state.pageContext[context], action), _a)) });
            }
            case LOAD_CMS_COMPONENT_FAIL: {
                var pageContextReducer = loaderReducer(action.meta.entityType, componentExistsReducer);
                var context = serializePageContext(action.payload.pageContext, true);
                return Object.assign(Object.assign({}, state), { pageContext: Object.assign(Object.assign({}, state.pageContext), (_b = {}, _b[context] = pageContextReducer(state.pageContext[context], action), _b)) });
            }
            case LOAD_CMS_COMPONENT_SUCCESS: {
                var pageContextReducer = loaderReducer(action.meta.entityType, componentExistsReducer);
                var context = serializePageContext(action.payload.pageContext, true);
                return Object.assign(Object.assign({}, state), { component: action.payload.component, pageContext: Object.assign(Object.assign({}, state.pageContext), (_c = {}, _c[context] = pageContextReducer(state.pageContext[context], action), _c)) });
            }
            case CMS_GET_COMPONENT_FROM_PAGE: {
                var pageContextReducer = loaderReducer(action.meta.entityType, componentExistsReducer);
                if (!Array.isArray(action.payload)) {
                    var context = serializePageContext(action.payload.pageContext, true);
                    return Object.assign(Object.assign({}, state), { component: action.payload.component, pageContext: Object.assign(Object.assign({}, state.pageContext), (_d = {}, _d[context] = pageContextReducer(state.pageContext[context], action), _d)) });
                }
            }
        }
        return state;
    }

    var initialState$m = undefined;
    function reducer$m(state, action) {
        if (state === void 0) { state = initialState$m; }
        switch (action.type) {
            case LOAD_CMS_NAVIGATION_ITEMS_SUCCESS: {
                if (action.payload.components) {
                    var components = action.payload.components;
                    var newItem = components.reduce(function (compItems, component) {
                        var _a;
                        return Object.assign(Object.assign({}, compItems), (_a = {}, _a[component.uid + "_AbstractCMSComponent"] = component, _a));
                    }, Object.assign({}));
                    return Object.assign(Object.assign({}, state), newItem);
                }
            }
        }
        return state;
    }

    var initialState$l = { entities: {} };
    function reducer$l(state, action) {
        var _a;
        if (state === void 0) { state = initialState$l; }
        switch (action.type) {
            case LOAD_CMS_PAGE_DATA_SUCCESS: {
                var page = action.payload;
                return Object.assign(Object.assign({}, state), { entities: Object.assign(Object.assign({}, state.entities), (_a = {}, _a[page.pageId] = page, _a)) });
            }
        }
        return state;
    }

    var initialState$k = undefined;
    function reducer$k(entityType) {
        return function (state, action) {
            if (state === void 0) { state = initialState$k; }
            if (action.meta && action.meta.entityType === entityType) {
                switch (action.type) {
                    case LOAD_CMS_PAGE_DATA_SUCCESS: {
                        return action.payload.pageId;
                    }
                    case LOAD_CMS_PAGE_DATA_FAIL: {
                        return initialState$k;
                    }
                    case CMS_SET_PAGE_FAIL_INDEX: {
                        return action.payload;
                    }
                    case CMS_SET_PAGE_SUCCESS_INDEX: {
                        return action.payload.pageId;
                    }
                }
            }
            return state;
        };
    }

    function getReducers$4() {
        return {
            page: i1.combineReducers({
                pageData: reducer$l,
                index: i1.combineReducers({
                    content: entityLoaderReducer(exports.PageType.CONTENT_PAGE, reducer$k(exports.PageType.CONTENT_PAGE)),
                    product: entityLoaderReducer(exports.PageType.PRODUCT_PAGE, reducer$k(exports.PageType.PRODUCT_PAGE)),
                    category: entityLoaderReducer(exports.PageType.CATEGORY_PAGE, reducer$k(exports.PageType.CATEGORY_PAGE)),
                    catalog: entityLoaderReducer(exports.PageType.CATALOG_PAGE, reducer$k(exports.PageType.CATALOG_PAGE)),
                }),
            }),
            components: entityReducer(COMPONENT_ENTITY, reducer$n),
            navigation: entityLoaderReducer(NAVIGATION_DETAIL_ENTITY, reducer$m),
        };
    }
    var reducerToken$4 = new i0.InjectionToken('CmsReducers');
    var reducerProvider$4 = {
        provide: reducerToken$4,
        useFactory: getReducers$4,
    };
    function clearCmsState(reducer) {
        return function (state, action) {
            if (action.type === LANGUAGE_CHANGE ||
                action.type === LOGOUT ||
                action.type === LOGIN) {
                state = undefined;
            }
            return reducer(state, action);
        };
    }
    var metaReducers$2 = [clearCmsState];

    function cmsStoreConfigFactory() {
        var _a;
        // if we want to reuse CMS_FEATURE const in config, we have to use factory instead of plain object
        var config = {
            state: {
                ssrTransfer: {
                    keys: (_a = {}, _a[CMS_FEATURE] = exports.StateTransferType.TRANSFER_STATE, _a),
                },
            },
        };
        return config;
    }
    var CmsStoreModule = /** @class */ (function () {
        function CmsStoreModule() {
        }
        return CmsStoreModule;
    }());
    CmsStoreModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CmsStoreModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    CmsStoreModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CmsStoreModule, imports: [i6.CommonModule,
            StateModule, i1__namespace$2.StoreFeatureModule, i1__namespace$4.EffectsFeatureModule] });
    CmsStoreModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CmsStoreModule, providers: [
            provideDefaultConfigFactory(cmsStoreConfigFactory),
            reducerProvider$4,
        ], imports: [[
                i6.CommonModule,
                StateModule,
                i1.StoreModule.forFeature(CMS_FEATURE, reducerToken$4, { metaReducers: metaReducers$2 }),
                i1$4.EffectsModule.forFeature(effects$1),
            ]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CmsStoreModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [
                            i6.CommonModule,
                            StateModule,
                            i1.StoreModule.forFeature(CMS_FEATURE, reducerToken$4, { metaReducers: metaReducers$2 }),
                            i1$4.EffectsModule.forFeature(effects$1),
                        ],
                        providers: [
                            provideDefaultConfigFactory(cmsStoreConfigFactory),
                            reducerProvider$4,
                        ],
                    }]
            }] });

    var CmsModule = /** @class */ (function () {
        function CmsModule() {
        }
        CmsModule.forRoot = function () {
            return {
                ngModule: CmsModule,
                providers: [CmsService, provideDefaultConfig(defaultCmsModuleConfig)],
            };
        };
        return CmsModule;
    }());
    CmsModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CmsModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    CmsModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CmsModule, imports: [CmsStoreModule, PageMetaModule] });
    CmsModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CmsModule, imports: [[CmsStoreModule, PageMetaModule.forRoot()]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CmsModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [CmsStoreModule, PageMetaModule.forRoot()],
                    }]
            }] });

    var CMS_PAGE_NORMALIZER = new i0.InjectionToken('CmsPageNormalizer');

    var CMS_COMPONENT_NORMALIZER = new i0.InjectionToken('CmsComponentNormalizer');

    var ComponentDecorator = /** @class */ (function () {
        function ComponentDecorator() {
        }
        return ComponentDecorator;
    }());
    ComponentDecorator.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ComponentDecorator, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ComponentDecorator.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ComponentDecorator });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ComponentDecorator, decorators: [{
                type: i0.Injectable
            }] });

    var SlotDecorator = /** @class */ (function () {
        function SlotDecorator() {
        }
        return SlotDecorator;
    }());
    SlotDecorator.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SlotDecorator, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    SlotDecorator.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SlotDecorator });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SlotDecorator, decorators: [{
                type: i0.Injectable
            }] });

    /**
     * Helper logic to resolve best matching Applicable
     *
     * Finding best match is a two step process:
     * 1. Find all matching applicables
     *    - all applicables for which hasMatch(...matchParams) will return true
     *    - all applicables without hasMatch method (implicit always match)
     * 2. Find the applicable with highest priority
     *    - applicable with highest getPriority(...priorityParams) will win
     *    - applicable without getPriority method is treated as Priority.NORMAL or 0
     *    - applicables with the same priority are sorted by order of providers, the applicable that was provided later wins
     *
     * @param applicables - array or applicable-like instances
     * @param matchParams - array of parameters passed for hasMatch calls
     * @param priorityParams - array of parameters passed for getPriority calls
     */
    function resolveApplicable(applicables, matchParams, priorityParams) {
        if (matchParams === void 0) { matchParams = []; }
        if (priorityParams === void 0) { priorityParams = []; }
        var matchedApplicables = (applicables !== null && applicables !== void 0 ? applicables : []).filter(function (applicable) { return !applicable.hasMatch || applicable.hasMatch.apply(applicable, __spreadArray([], __read(matchParams))); });
        if (matchedApplicables.length < 2) {
            return matchedApplicables[0];
        }
        var lastPriority = -Infinity;
        return matchedApplicables.reduce(function (acc, curr) {
            var currPriority = curr.getPriority
                ? curr.getPriority.apply(curr, __spreadArray([], __read(priorityParams))) : 0 /* NORMAL */;
            if (lastPriority > currPriority) {
                return acc;
            }
            lastPriority = currPriority;
            return curr;
        }, undefined);
    }

    /**
     * uniteLatest is an alternative to combineLatest. The first emission is
     * emitted synchronously (just like combineLatest) and all following emissions
     * are audited and emitted using asapScheduler.
     *
     * It effectively smooths out emissions when multiple sources will emit at the
     * same time: uniteLatest will have only one emission, where combine latest will
     * have more than one (one per source changed).
     *
     * @param sources
     */
    function uniteLatest(sources) {
        return rxjs.defer(function () {
            var subNo = 0;
            var trigger = new rxjs.Observable(function (subscriber) {
                var action = function () {
                    subscriber.next();
                    subscriber.complete();
                };
                if (subNo) {
                    rxjs.asapScheduler.schedule(action);
                }
                else {
                    action();
                }
                subNo++;
            });
            return rxjs.combineLatest(sources).pipe(operators.audit(function () { return trigger; }));
        });
    }

    /**
     * Service that collects the page meta data by using injected page resolvers.
     */
    var PageMetaService = /** @class */ (function () {
        function PageMetaService(cms, unifiedInjector, pageMetaConfig, platformId) {
            var _this = this;
            this.cms = cms;
            this.unifiedInjector = unifiedInjector;
            this.pageMetaConfig = pageMetaConfig;
            this.platformId = platformId;
            this.resolvers$ = this.unifiedInjector
                .getMulti(PageMetaResolver)
                .pipe(operators.shareReplay({ bufferSize: 1, refCount: true }));
            this.meta$ = rxjs.defer(function () { return _this.cms.getCurrentPage(); }).pipe(operators.filter(function (page) { return Boolean(page); }), operators.switchMap(function (page) { return _this.getMetaResolver(page); }), operators.switchMap(function (metaResolver) { return metaResolver ? _this.resolve(metaResolver) : rxjs.of(null); }), operators.shareReplay({ bufferSize: 1, refCount: true }));
        }
        /**
         * Returns the observed page meta data for the current page.
         *
         * The data is resolved by various PageResolvers, which are configurable.
         */
        PageMetaService.prototype.getMeta = function () {
            return this.meta$;
        };
        /**
         * If a `PageResolver` has implemented a resolver interface, the resolved data
         * is merged into the `PageMeta` object.
         * @param metaResolver
         */
        PageMetaService.prototype.resolve = function (metaResolver) {
            var resolverMethods = this.getResolverMethods();
            var resolvedData = Object.keys(resolverMethods)
                // TODO: Revisit if typing is possible here with Template Literal Types when we update to TS >=4.1
                .filter(function (key) { return metaResolver[resolverMethods[key]]; })
                .map(function (key) {
                return metaResolver[resolverMethods[key]]()
                    .pipe(operators.map(function (data) {
                    var _d;
                    return (_d = {}, _d[key] = data, _d);
                }));
            });
            if (resolvedData.length === 0) {
                // uniteLatest will fail otherwise
                return rxjs.of({});
            }
            else {
                return uniteLatest(resolvedData).pipe(operators.map(function (data) { return Object.assign.apply(Object, __spreadArray([{}], __read(data))); }));
            }
        };
        /**
         * Returns an object with resolvers. The object properties represent the `PageMeta` property, i.e.:
         *
         * ```
         * {
         *   title: 'resolveTitle',
         *   robots: 'resolveRobots'
         * }
         * ```
         *
         * This list of resolvers is filtered for CSR vs SSR processing since not all resolvers are
         * relevant during browsing.
         */
        PageMetaService.prototype.getResolverMethods = function () {
            var _this = this;
            var _a, _b, _c;
            var resolverMethods = {};
            // filter the resolvers to avoid unnecessary processing in CSR
            (_c = (_b = (_a = this.pageMetaConfig) === null || _a === void 0 ? void 0 : _a.pageMeta) === null || _b === void 0 ? void 0 : _b.resolvers) === null || _c === void 0 ? void 0 : _c.filter(function (resolver) {
                var _a, _b, _c;
                return (
                // always resolve in SSR
                !i6.isPlatformBrowser((_a = _this.platformId) !== null && _a !== void 0 ? _a : '') ||
                    // resolve in CSR when it's not disabled
                    !resolver.disabledInCsr ||
                    // resolve in CSR when resolver is enabled in devMode
                    (i0.isDevMode() && ((_c = (_b = _this.pageMetaConfig) === null || _b === void 0 ? void 0 : _b.pageMeta) === null || _c === void 0 ? void 0 : _c.enableInDevMode)));
            }).forEach(function (resolver) { return (resolverMethods[resolver.property] = resolver.method); });
            return resolverMethods;
        };
        /**
         * Return the resolver with the best match, based on a score
         * generated by the resolver.
         *
         * Resolvers match by default on `PageType` and `page.template`.
         */
        PageMetaService.prototype.getMetaResolver = function (page) {
            return this.resolvers$.pipe(operators.map(function (resolvers) { return resolveApplicable(resolvers, [page], [page]); }));
        };
        return PageMetaService;
    }());
    PageMetaService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PageMetaService, deps: [{ token: CmsService }, { token: UnifiedInjector }, { token: PageMetaConfig }, { token: i0.PLATFORM_ID }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    PageMetaService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PageMetaService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: PageMetaService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () {
            return [{ type: CmsService }, { type: UnifiedInjector }, { type: PageMetaConfig }, { type: undefined, decorators: [{
                            type: i0.Inject,
                            args: [i0.PLATFORM_ID]
                        }] }];
        } });

    exports.PageRobotsMeta = void 0;
    (function (PageRobotsMeta) {
        PageRobotsMeta["INDEX"] = "INDEX";
        PageRobotsMeta["NOINDEX"] = "NOINDEX";
        PageRobotsMeta["FOLLOW"] = "FOLLOW";
        PageRobotsMeta["NOFOLLOW"] = "NOFOLLOW";
    })(exports.PageRobotsMeta || (exports.PageRobotsMeta = {}));

    /**
     * Will grab last synchronously available value from the observable stream
     * at the time of the call.
     *
     * Should be used with caution, as it's not a legitimate way for getting value
     * from the observable. Observable composition or standard subscribe method
     * should be used for most of the cases.
     *
     * @param source
     */
    function getLastValueSync(source) {
        var value;
        source.subscribe(function (emission) { return (value = emission); }).unsubscribe();
        return value;
    }

    /**
     * Service that used to add dynamic attributes to CMS component
     * and slot elements.
     */
    var DynamicAttributeService = /** @class */ (function () {
        function DynamicAttributeService(unifiedInjector) {
            this.unifiedInjector = unifiedInjector;
            this.componentDecorators$ = this.unifiedInjector
                .getMulti(ComponentDecorator)
                .pipe(operators.shareReplay(1));
            this.slotDecorators$ = this.unifiedInjector
                .getMulti(SlotDecorator)
                .pipe(operators.shareReplay(1));
        }
        /**
         * Add dynamic attributes to CMS component element
         * @param element: CMS component element
         * @param renderer
         * @param componentData: component data
         */
        DynamicAttributeService.prototype.addAttributesToComponent = function (element, renderer, componentData) {
            (getLastValueSync(this.componentDecorators$) || []).forEach(function (decorator) { return decorator.decorate(element, renderer, componentData); });
        };
        /**
         * Add dynamic attributes to CMS slot element
         * @param element: CMS slot element
         * @param renderer
         * @param slotData: slot data
         */
        DynamicAttributeService.prototype.addAttributesToSlot = function (element, renderer, slotData) {
            (getLastValueSync(this.slotDecorators$) || []).forEach(function (decorator) { return decorator.decorate(element, renderer, slotData); });
        };
        return DynamicAttributeService;
    }());
    DynamicAttributeService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: DynamicAttributeService, deps: [{ token: UnifiedInjector }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    DynamicAttributeService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: DynamicAttributeService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: DynamicAttributeService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: UnifiedInjector }]; } });

    var GlobalMessageConfig = /** @class */ (function () {
        function GlobalMessageConfig() {
        }
        return GlobalMessageConfig;
    }());
    GlobalMessageConfig.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: GlobalMessageConfig, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    GlobalMessageConfig.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: GlobalMessageConfig, providedIn: 'root', useExisting: Config });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: GlobalMessageConfig, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                        useExisting: Config,
                    }]
            }] });

    exports.HttpResponseStatus = void 0;
    (function (HttpResponseStatus) {
        HttpResponseStatus[HttpResponseStatus["UNKNOWN"] = -1] = "UNKNOWN";
        HttpResponseStatus[HttpResponseStatus["BAD_REQUEST"] = 400] = "BAD_REQUEST";
        HttpResponseStatus[HttpResponseStatus["UNAUTHORIZED"] = 401] = "UNAUTHORIZED";
        HttpResponseStatus[HttpResponseStatus["FORBIDDEN"] = 403] = "FORBIDDEN";
        HttpResponseStatus[HttpResponseStatus["NOT_FOUND"] = 404] = "NOT_FOUND";
        HttpResponseStatus[HttpResponseStatus["CONFLICT"] = 409] = "CONFLICT";
        HttpResponseStatus[HttpResponseStatus["BAD_GATEWAY"] = 502] = "BAD_GATEWAY";
        HttpResponseStatus[HttpResponseStatus["GATEWAY_TIMEOUT"] = 504] = "GATEWAY_TIMEOUT";
        HttpResponseStatus[HttpResponseStatus["INTERNAL_SERVER_ERROR"] = 500] = "INTERNAL_SERVER_ERROR";
    })(exports.HttpResponseStatus || (exports.HttpResponseStatus = {}));

    var HttpErrorHandler = /** @class */ (function () {
        function HttpErrorHandler(globalMessageService, platformId) {
            this.globalMessageService = globalMessageService;
            this.platformId = platformId;
        }
        /**
         * Error handlers are matched by the error `responseStatus` (i.e. 404). On top of the matching status
         * a priority can be added to distinguish multiple handles for the same response status.
         */
        HttpErrorHandler.prototype.hasMatch = function (errorResponse) {
            return errorResponse.status === this.responseStatus;
        };
        /**
         * Returns true when invoked on the server (SSR).
         *
         * Added in 3.2, depends on the injected `platformId`.
         */
        HttpErrorHandler.prototype.isSsr = function () {
            if (this.platformId) {
                return !i6.isPlatformBrowser(this.platformId);
            }
            return false;
        };
        return HttpErrorHandler;
    }());
    HttpErrorHandler.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: HttpErrorHandler, deps: [{ token: GlobalMessageService }, { token: i0.PLATFORM_ID }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    HttpErrorHandler.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: HttpErrorHandler, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: HttpErrorHandler, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () {
            return [{ type: GlobalMessageService }, { type: Object, decorators: [{
                            type: i0.Inject,
                            args: [i0.PLATFORM_ID]
                        }] }];
        } });

    var BadGatewayHandler = /** @class */ (function (_super) {
        __extends(BadGatewayHandler, _super);
        function BadGatewayHandler() {
            var _this = _super.apply(this, __spreadArray([], __read(arguments))) || this;
            _this.responseStatus = exports.HttpResponseStatus.BAD_GATEWAY;
            return _this;
        }
        BadGatewayHandler.prototype.handleError = function () {
            this.globalMessageService.add({ key: 'httpHandlers.badGateway' }, exports.GlobalMessageType.MSG_TYPE_ERROR);
        };
        BadGatewayHandler.prototype.getPriority = function () {
            return -10 /* LOW */;
        };
        return BadGatewayHandler;
    }(HttpErrorHandler));
    BadGatewayHandler.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: BadGatewayHandler, deps: null, target: i0__namespace.ɵɵFactoryTarget.Injectable });
    BadGatewayHandler.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: BadGatewayHandler, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: BadGatewayHandler, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }] });

    var OAUTH_ENDPOINT = '/authorizationserver/oauth/token';
    var BadRequestHandler = /** @class */ (function (_super) {
        __extends(BadRequestHandler, _super);
        function BadRequestHandler() {
            var _this = _super.apply(this, __spreadArray([], __read(arguments))) || this;
            _this.responseStatus = exports.HttpResponseStatus.BAD_REQUEST;
            return _this;
        }
        BadRequestHandler.prototype.handleError = function (request, response) {
            this.handleBadPassword(request, response);
            this.handleBadLoginResponse(request, response);
            this.handleBadCartRequest(request, response);
            this.handleValidationError(request, response);
            this.handleVoucherOperationError(request, response);
            this.handleGuestDuplicateEmail(request, response);
        };
        BadRequestHandler.prototype.handleBadPassword = function (request, response) {
            var _a, _b, _c;
            if (((_a = response.url) === null || _a === void 0 ? void 0 : _a.includes(OAUTH_ENDPOINT)) &&
                ((_b = response.error) === null || _b === void 0 ? void 0 : _b.error) === 'invalid_grant' &&
                ((_c = request.body) === null || _c === void 0 ? void 0 : _c.get('grant_type')) === 'password') {
                this.globalMessageService.add({
                    key: 'httpHandlers.badRequestPleaseLoginAgain',
                    params: {
                        errorMessage: response.error.error_description || response.message || '',
                    },
                }, exports.GlobalMessageType.MSG_TYPE_ERROR);
                this.globalMessageService.remove(exports.GlobalMessageType.MSG_TYPE_CONFIRMATION);
            }
        };
        BadRequestHandler.prototype.handleBadLoginResponse = function (_request, response) {
            var _this = this;
            this.getErrors(response)
                .filter(function (error) { return error.type === 'PasswordMismatchError'; })
                .forEach(function () {
                _this.globalMessageService.add({ key: 'httpHandlers.badRequestOldPasswordIncorrect' }, exports.GlobalMessageType.MSG_TYPE_ERROR);
            });
        };
        BadRequestHandler.prototype.handleValidationError = function (_request, response) {
            var _this = this;
            this.getErrors(response)
                .filter(function (e) { return e.type === 'ValidationError'; })
                .forEach(function (error) {
                _this.globalMessageService.add({
                    key: "httpHandlers.validationErrors." + error.reason + "." + error.subject,
                }, exports.GlobalMessageType.MSG_TYPE_ERROR);
            });
        };
        BadRequestHandler.prototype.handleBadCartRequest = function (_request, response) {
            var _this = this;
            this.getErrors(response)
                .filter(function (e) { return isCartNotFoundError(e); })
                .forEach(function () {
                _this.globalMessageService.add({ key: 'httpHandlers.cartNotFound' }, exports.GlobalMessageType.MSG_TYPE_ERROR);
            });
        };
        BadRequestHandler.prototype.handleVoucherOperationError = function (_request, response) {
            var _this = this;
            this.getErrors(response)
                .filter(function (e) { return e.message === 'coupon.invalid.code.provided' &&
                e.type === 'VoucherOperationError'; })
                .forEach(function () {
                _this.globalMessageService.add({ key: 'httpHandlers.invalidCodeProvided' }, exports.GlobalMessageType.MSG_TYPE_ERROR);
            });
        };
        BadRequestHandler.prototype.handleGuestDuplicateEmail = function (_request, response) {
            var _this = this;
            this.getErrors(response)
                .filter(function (e) { return e.type === 'DuplicateUidError'; })
                .forEach(function (error) {
                _this.globalMessageService.add({
                    key: 'httpHandlers.badRequestGuestDuplicateEmail',
                    params: {
                        errorMessage: error.message || '',
                    },
                }, exports.GlobalMessageType.MSG_TYPE_ERROR);
            });
        };
        BadRequestHandler.prototype.getErrors = function (response) {
            var _a;
            return (((_a = response.error) === null || _a === void 0 ? void 0 : _a.errors) || []).filter(function (error) { return error.type !== 'JaloObjectNoLongerValidError'; });
        };
        BadRequestHandler.prototype.getPriority = function () {
            return -10 /* LOW */;
        };
        return BadRequestHandler;
    }(HttpErrorHandler));
    BadRequestHandler.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: BadRequestHandler, deps: null, target: i0__namespace.ɵɵFactoryTarget.Injectable });
    BadRequestHandler.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: BadRequestHandler, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: BadRequestHandler, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }] });

    var ConflictHandler = /** @class */ (function (_super) {
        __extends(ConflictHandler, _super);
        function ConflictHandler() {
            var _this = _super.apply(this, __spreadArray([], __read(arguments))) || this;
            _this.responseStatus = exports.HttpResponseStatus.CONFLICT;
            return _this;
        }
        ConflictHandler.prototype.handleError = function () {
            this.globalMessageService.add({ key: 'httpHandlers.conflict' }, exports.GlobalMessageType.MSG_TYPE_ERROR);
        };
        ConflictHandler.prototype.getPriority = function () {
            return -10 /* LOW */;
        };
        return ConflictHandler;
    }(HttpErrorHandler));
    ConflictHandler.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ConflictHandler, deps: null, target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ConflictHandler.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ConflictHandler, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ConflictHandler, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }] });

    var ForbiddenHandler = /** @class */ (function (_super) {
        __extends(ForbiddenHandler, _super);
        function ForbiddenHandler(globalMessageService, authService, occEndpoints) {
            var _this = _super.call(this, globalMessageService) || this;
            _this.globalMessageService = globalMessageService;
            _this.authService = authService;
            _this.occEndpoints = occEndpoints;
            _this.responseStatus = exports.HttpResponseStatus.FORBIDDEN;
            return _this;
        }
        ForbiddenHandler.prototype.handleError = function (request) {
            if (request.url.endsWith(this.occEndpoints.buildUrl('user', {
                urlParams: { userId: 'current' },
            }))) {
                this.authService.logout();
            }
            this.globalMessageService.add({ key: 'httpHandlers.forbidden' }, exports.GlobalMessageType.MSG_TYPE_ERROR);
        };
        ForbiddenHandler.prototype.getPriority = function () {
            return -10 /* LOW */;
        };
        return ForbiddenHandler;
    }(HttpErrorHandler));
    ForbiddenHandler.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ForbiddenHandler, deps: [{ token: GlobalMessageService }, { token: AuthService }, { token: OccEndpointsService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ForbiddenHandler.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ForbiddenHandler, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ForbiddenHandler, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: GlobalMessageService }, { type: AuthService }, { type: OccEndpointsService }]; } });

    var GatewayTimeoutHandler = /** @class */ (function (_super) {
        __extends(GatewayTimeoutHandler, _super);
        function GatewayTimeoutHandler() {
            var _this = _super.apply(this, __spreadArray([], __read(arguments))) || this;
            _this.responseStatus = exports.HttpResponseStatus.GATEWAY_TIMEOUT;
            return _this;
        }
        GatewayTimeoutHandler.prototype.handleError = function () {
            this.globalMessageService.add({ key: 'httpHandlers.gatewayTimeout' }, exports.GlobalMessageType.MSG_TYPE_ERROR);
        };
        GatewayTimeoutHandler.prototype.getPriority = function () {
            return -10 /* LOW */;
        };
        return GatewayTimeoutHandler;
    }(HttpErrorHandler));
    GatewayTimeoutHandler.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: GatewayTimeoutHandler, deps: null, target: i0__namespace.ɵɵFactoryTarget.Injectable });
    GatewayTimeoutHandler.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: GatewayTimeoutHandler, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: GatewayTimeoutHandler, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }] });

    var InternalServerErrorHandler = /** @class */ (function (_super) {
        __extends(InternalServerErrorHandler, _super);
        function InternalServerErrorHandler() {
            var _this = _super.apply(this, __spreadArray([], __read(arguments))) || this;
            _this.responseStatus = exports.HttpResponseStatus.INTERNAL_SERVER_ERROR;
            return _this;
        }
        InternalServerErrorHandler.prototype.handleError = function () {
            this.globalMessageService.add({ key: 'httpHandlers.internalServerError' }, exports.GlobalMessageType.MSG_TYPE_ERROR);
        };
        InternalServerErrorHandler.prototype.getPriority = function () {
            return -10 /* LOW */;
        };
        return InternalServerErrorHandler;
    }(HttpErrorHandler));
    InternalServerErrorHandler.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: InternalServerErrorHandler, deps: null, target: i0__namespace.ɵɵFactoryTarget.Injectable });
    InternalServerErrorHandler.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: InternalServerErrorHandler, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: InternalServerErrorHandler, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }] });

    var NotFoundHandler = /** @class */ (function (_super) {
        __extends(NotFoundHandler, _super);
        function NotFoundHandler() {
            var _this = _super.apply(this, __spreadArray([], __read(arguments))) || this;
            _this.responseStatus = exports.HttpResponseStatus.NOT_FOUND;
            return _this;
        }
        // empty error handler to avoid we fallabck to the unknown error handler
        NotFoundHandler.prototype.handleError = function () { };
        NotFoundHandler.prototype.getPriority = function () {
            return -10 /* LOW */;
        };
        return NotFoundHandler;
    }(HttpErrorHandler));
    NotFoundHandler.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: NotFoundHandler, deps: null, target: i0__namespace.ɵɵFactoryTarget.Injectable });
    NotFoundHandler.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: NotFoundHandler, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: NotFoundHandler, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }] });

    /**
     * Unknown Error Handler works as an fallback, to handle errors that were
     * not handled by any other error handlers
     */
    var UnknownErrorHandler = /** @class */ (function (_super) {
        __extends(UnknownErrorHandler, _super);
        function UnknownErrorHandler() {
            var _this = _super.apply(this, __spreadArray([], __read(arguments))) || this;
            _this.responseStatus = exports.HttpResponseStatus.UNKNOWN;
            return _this;
        }
        /**
         * hasMatch always returns true, to mach all errors
         */
        UnknownErrorHandler.prototype.hasMatch = function (_errorResponse) {
            return true;
        };
        UnknownErrorHandler.prototype.handleError = function (_request, errorResponse) {
            if (i0.isDevMode() || this.isSsr()) {
                console.warn("An unknown http error occurred\n", errorResponse.message);
            }
        };
        /**
         * Fallback priority assures that the handler is used as a last resort
         */
        UnknownErrorHandler.prototype.getPriority = function () {
            return -50 /* FALLBACK */;
        };
        return UnknownErrorHandler;
    }(HttpErrorHandler));
    UnknownErrorHandler.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UnknownErrorHandler, deps: null, target: i0__namespace.ɵɵFactoryTarget.Injectable });
    UnknownErrorHandler.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UnknownErrorHandler, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UnknownErrorHandler, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }] });

    var HttpErrorInterceptor = /** @class */ (function () {
        function HttpErrorInterceptor(handlers) {
            this.handlers = handlers;
        }
        HttpErrorInterceptor.prototype.intercept = function (request, next) {
            var _this = this;
            return next.handle(request).pipe(operators.catchError(function (response) {
                if (response instanceof i1$3.HttpErrorResponse) {
                    _this.handleErrorResponse(request, response);
                    return rxjs.throwError(response);
                }
            }));
        };
        HttpErrorInterceptor.prototype.handleErrorResponse = function (request, response) {
            var handler = this.getResponseHandler(response);
            if (handler) {
                handler.handleError(request, response);
            }
        };
        /**
         * return the error handler that matches the `HttpResponseStatus` code.
         * If no handler is available, the UNKNOWN handler is returned.
         */
        HttpErrorInterceptor.prototype.getResponseHandler = function (response) {
            return resolveApplicable(this.handlers, [response]);
        };
        return HttpErrorInterceptor;
    }());
    HttpErrorInterceptor.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: HttpErrorInterceptor, deps: [{ token: HttpErrorHandler }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    HttpErrorInterceptor.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: HttpErrorInterceptor, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: HttpErrorInterceptor, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }], ctorParameters: function () {
            return [{ type: undefined, decorators: [{
                            type: i0.Inject,
                            args: [HttpErrorHandler]
                        }] }];
        } });

    var errorHandlers = [
        {
            provide: HttpErrorHandler,
            useExisting: UnknownErrorHandler,
            multi: true,
        },
        {
            provide: HttpErrorHandler,
            useExisting: BadGatewayHandler,
            multi: true,
        },
        {
            provide: HttpErrorHandler,
            useExisting: BadRequestHandler,
            multi: true,
        },
        {
            provide: HttpErrorHandler,
            useExisting: ConflictHandler,
            multi: true,
        },
        {
            provide: HttpErrorHandler,
            useExisting: ForbiddenHandler,
            multi: true,
        },
        {
            provide: HttpErrorHandler,
            useExisting: GatewayTimeoutHandler,
            multi: true,
        },
        {
            provide: HttpErrorHandler,
            useExisting: InternalServerErrorHandler,
            multi: true,
        },
        {
            provide: HttpErrorHandler,
            useExisting: NotFoundHandler,
            multi: true,
        },
    ];
    var httpErrorInterceptors = [
        {
            provide: i1$3.HTTP_INTERCEPTORS,
            useExisting: HttpErrorInterceptor,
            multi: true,
        },
    ];

    var initialState$j = {
        entities: {},
    };
    function reducer$j(state, action) {
        var _a, _b, _c, _d;
        if (state === void 0) { state = initialState$j; }
        switch (action.type) {
            case ADD_MESSAGE: {
                var message = action.payload;
                if (state.entities[message.type] === undefined) {
                    return Object.assign(Object.assign({}, state), { entities: Object.assign(Object.assign({}, state.entities), (_a = {}, _a[message.type] = [message.text], _a)) });
                }
                else {
                    var currentMessages = state.entities[message.type];
                    return Object.assign(Object.assign({}, state), { entities: Object.assign(Object.assign({}, state.entities), (_b = {}, _b[message.type] = __spreadArray(__spreadArray([], __read(currentMessages)), [message.text]), _b)) });
                }
            }
            case REMOVE_MESSAGE: {
                var msgType = action.payload.type;
                var msgIndex = action.payload.index;
                if (Object.keys(state.entities).length === 0 ||
                    !state.entities[msgType]) {
                    return state;
                }
                var messages = __spreadArray([], __read(state.entities[msgType]));
                messages.splice(msgIndex, 1);
                return Object.assign(Object.assign({}, state), { entities: Object.assign(Object.assign({}, state.entities), (_c = {}, _c[msgType] = messages, _c)) });
            }
            case REMOVE_MESSAGES_BY_TYPE: {
                var entities = Object.assign(Object.assign({}, state.entities), (_d = {}, _d[action.payload] = [], _d));
                return Object.assign(Object.assign({}, state), { entities: entities });
            }
        }
        return state;
    }

    function getReducers$3() {
        return reducer$j;
    }
    var reducerToken$3 = new i0.InjectionToken('GlobalMessageReducers');
    var reducerProvider$3 = {
        provide: reducerToken$3,
        useFactory: getReducers$3,
    };

    var GlobalMessageStoreModule = /** @class */ (function () {
        function GlobalMessageStoreModule() {
        }
        return GlobalMessageStoreModule;
    }());
    GlobalMessageStoreModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: GlobalMessageStoreModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    GlobalMessageStoreModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: GlobalMessageStoreModule, imports: [StateModule, i1__namespace$2.StoreFeatureModule] });
    GlobalMessageStoreModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: GlobalMessageStoreModule, providers: [reducerProvider$3], imports: [[
                StateModule,
                i1.StoreModule.forFeature(GLOBAL_MESSAGE_FEATURE, reducerToken$3),
            ]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: GlobalMessageStoreModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [
                            StateModule,
                            i1.StoreModule.forFeature(GLOBAL_MESSAGE_FEATURE, reducerToken$3),
                        ],
                        providers: [reducerProvider$3],
                    }]
            }] });

    function shallowEqualObjects(objA, objB) {
        if (objA === objB) {
            return true;
        }
        if (!objA || !objB) {
            return false;
        }
        var aKeys = Object.keys(objA);
        var bKeys = Object.keys(objB);
        var aKeysLen = aKeys.length;
        var bKeysLen = bKeys.length;
        if (aKeysLen !== bKeysLen) {
            return false;
        }
        for (var i = 0; i < aKeysLen; i++) {
            var key = aKeys[i];
            if (objA[key] !== objB[key]) {
                return false;
            }
        }
        return true;
    }
    function deepEqualObjects(objA, objB) {
        if (objA === objB) {
            return true; // if both objA and objB are null or undefined and exactly the same
        }
        else if (!(objA instanceof Object) || !(objB instanceof Object)) {
            return false; // if they are not strictly equal, they both need to be Objects
        }
        else if (objA.constructor !== objB.constructor) {
            // they must have the exact same prototype chain, the closest we can do is
            // test their constructor.
            return false;
        }
        else {
            for (var key in objA) {
                if (!objA.hasOwnProperty(key)) {
                    continue; // other properties were tested using objA.constructor === y.constructor
                }
                if (!objB.hasOwnProperty(key)) {
                    return false; // allows to compare objA[ key ] and objB[ key ] when set to undefined
                }
                if (objA[key] === objB[key]) {
                    continue; // if they have the same strict value or identity then they are equal
                }
                if (typeof objA[key] !== 'object') {
                    return false; // Numbers, Strings, Functions, Booleans must be strictly equal
                }
                if (!deepEqualObjects(objA[key], objB[key])) {
                    return false;
                }
            }
            for (var key in objB) {
                if (objB.hasOwnProperty(key) && !objA.hasOwnProperty(key)) {
                    return false;
                }
            }
            return true;
        }
    }
    function countOfDeepEqualObjects(obj, arr) {
        return arr.reduce(function (acc, curr) {
            if (deepEqualObjects(obj, curr)) {
                acc++;
            }
            return acc;
        }, 0);
    }
    function indexOfFirstOccurrence(obj, arr) {
        for (var index = 0; index < arr.length; index++) {
            if (deepEqualObjects(arr[index], obj)) {
                return index;
            }
        }
    }

    var GlobalMessageEffect = /** @class */ (function () {
        function GlobalMessageEffect(actions$, store, config, platformId) {
            var _this = this;
            this.actions$ = actions$;
            this.store = store;
            this.config = config;
            this.platformId = platformId;
            this.removeDuplicated$ = this.actions$.pipe(i1$4.ofType(ADD_MESSAGE), operators.pluck('payload'), operators.switchMap(function (message) { return rxjs.of(message.text).pipe(operators.withLatestFrom(_this.store.pipe(i1.select(getGlobalMessageEntitiesByType(message.type)))), operators.filter(function (_a) {
                var _b = __read(_a, 2), text = _b[0], messages = _b[1];
                return countOfDeepEqualObjects(text, messages) > 1;
            }), operators.map(function (_a) {
                var _b = __read(_a, 2), text = _b[0], messages = _b[1];
                return new RemoveMessage({
                    type: message.type,
                    index: indexOfFirstOccurrence(text, messages),
                });
            })); }));
            this.hideAfterDelay$ = i6.isPlatformBrowser(this.platformId) // we don't want to run this logic when doing SSR
                ? this.actions$.pipe(i1$4.ofType(ADD_MESSAGE), operators.pluck('payload'), operators.concatMap(function (message) {
                    var config = _this.config.globalMessages[message.type];
                    return _this.store.pipe(i1.select(getGlobalMessageCountByType(message.type)), operators.take(1), operators.filter(function (count) { return ((config && config.timeout !== undefined) || message.timeout) &&
                        count &&
                        count > 0; }), operators.delay(message.timeout || config.timeout), operators.switchMap(function () { return rxjs.of(new RemoveMessage({
                        type: message.type,
                        index: 0,
                    })); }));
                }))
                : rxjs.EMPTY;
        }
        return GlobalMessageEffect;
    }());
    GlobalMessageEffect.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: GlobalMessageEffect, deps: [{ token: i1__namespace$4.Actions }, { token: i1__namespace$2.Store }, { token: GlobalMessageConfig }, { token: i0.PLATFORM_ID }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    GlobalMessageEffect.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: GlobalMessageEffect });
    __decorate([
        i1$4.Effect()
    ], GlobalMessageEffect.prototype, "removeDuplicated$", void 0);
    __decorate([
        i1$4.Effect()
    ], GlobalMessageEffect.prototype, "hideAfterDelay$", void 0);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: GlobalMessageEffect, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () {
            return [{ type: i1__namespace$4.Actions }, { type: i1__namespace$2.Store }, { type: GlobalMessageConfig }, { type: undefined, decorators: [{
                            type: i0.Inject,
                            args: [i0.PLATFORM_ID]
                        }] }];
        }, propDecorators: { removeDuplicated$: [], hideAfterDelay$: [] } });

    function defaultGlobalMessageConfigFactory() {
        var _a;
        return {
            globalMessages: (_a = {},
                _a[exports.GlobalMessageType.MSG_TYPE_CONFIRMATION] = {
                    timeout: 3000,
                },
                _a[exports.GlobalMessageType.MSG_TYPE_INFO] = {
                    timeout: 3000,
                },
                _a[exports.GlobalMessageType.MSG_TYPE_ERROR] = {
                    timeout: 7000,
                },
                _a[exports.GlobalMessageType.MSG_TYPE_WARNING] = {
                    timeout: 7000,
                },
                _a),
        };
    }

    var GlobalMessageModule = /** @class */ (function () {
        function GlobalMessageModule() {
        }
        GlobalMessageModule.forRoot = function () {
            return {
                ngModule: GlobalMessageModule,
                providers: __spreadArray(__spreadArray([], __read(errorHandlers)), __read(httpErrorInterceptors)),
            };
        };
        return GlobalMessageModule;
    }());
    GlobalMessageModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: GlobalMessageModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    GlobalMessageModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: GlobalMessageModule, imports: [GlobalMessageStoreModule, i1__namespace$4.EffectsFeatureModule] });
    GlobalMessageModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: GlobalMessageModule, providers: [provideDefaultConfigFactory(defaultGlobalMessageConfigFactory)], imports: [[
                GlobalMessageStoreModule,
                i1$4.EffectsModule.forFeature([GlobalMessageEffect]),
            ]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: GlobalMessageModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [
                            GlobalMessageStoreModule,
                            i1$4.EffectsModule.forFeature([GlobalMessageEffect]),
                        ],
                        providers: [provideDefaultConfigFactory(defaultGlobalMessageConfigFactory)],
                    }]
            }] });

    var I18nConfig = /** @class */ (function () {
        function I18nConfig() {
        }
        return I18nConfig;
    }());
    I18nConfig.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: I18nConfig, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    I18nConfig.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: I18nConfig, providedIn: 'root', useExisting: Config });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: I18nConfig, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                        useExisting: Config,
                    }]
            }] });

    var I18nConfigInitializer = /** @class */ (function () {
        function I18nConfigInitializer(configInit) {
            var _this = this;
            this.configInit = configInit;
            this.scopes = ['i18n.fallbackLang'];
            this.configFactory = function () { return _this.resolveConfig().toPromise(); };
        }
        /**
         * Resolves the `fallbackLang` based on the default language from config `context.language` .
         */
        I18nConfigInitializer.prototype.resolveConfig = function () {
            return this.configInit.getStable('context.language').pipe(operators.map(function (config) {
                var _a, _b;
                return ({
                    i18n: {
                        // the first language in the array is the default one
                        fallbackLang: (_b = (_a = config === null || config === void 0 ? void 0 : config.context) === null || _a === void 0 ? void 0 : _a.language) === null || _b === void 0 ? void 0 : _b[0],
                    },
                });
            }));
        };
        return I18nConfigInitializer;
    }());
    I18nConfigInitializer.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: I18nConfigInitializer, deps: [{ token: ConfigInitializerService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    I18nConfigInitializer.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: I18nConfigInitializer, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: I18nConfigInitializer, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }], ctorParameters: function () { return [{ type: ConfigInitializerService }]; } });

    // type CxDatePipe, not DatePipe, due to conflict with Angular's DatePipe - problem occurs for the backward compatibility compiler of Ivy
    var CxDatePipe = /** @class */ (function (_super) {
        __extends(CxDatePipe, _super);
        function CxDatePipe(language) {
            var _this = _super.call(this, null) || this;
            _this.language = language;
            return _this;
        }
        CxDatePipe.prototype.transform = function (value, format, timezone) {
            return _super.prototype.transform.call(this, value, format, timezone, this.getLang());
        };
        CxDatePipe.prototype.getLang = function () {
            var lang = this.getActiveLang();
            try {
                i6.getLocaleId(lang);
                return lang;
            }
            catch (_a) {
                this.reportMissingLocaleData(lang);
                return 'en';
            }
        };
        CxDatePipe.prototype.getActiveLang = function () {
            var result;
            this.language
                .getActive()
                .subscribe(function (lang) { return (result = lang); })
                .unsubscribe();
            return result;
        };
        CxDatePipe.prototype.reportMissingLocaleData = function (lang) {
            if (i0.isDevMode()) {
                console.warn("cxDate pipe: No locale data registered for '" + lang + "' (see https://angular.io/api/common/registerLocaleData).");
            }
        };
        return CxDatePipe;
    }(i6.DatePipe));
    CxDatePipe.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CxDatePipe, deps: [{ token: LanguageService }], target: i0__namespace.ɵɵFactoryTarget.Pipe });
    CxDatePipe.ɵpipe = i0__namespace.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CxDatePipe, name: "cxDate" });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CxDatePipe, decorators: [{
                type: i0.Pipe,
                args: [{ name: 'cxDate' }]
            }], ctorParameters: function () { return [{ type: LanguageService }]; } });

    var CxNumericPipe = /** @class */ (function (_super) {
        __extends(CxNumericPipe, _super);
        function CxNumericPipe(language) {
            var _this = _super.call(this, null) || this;
            _this.language = language;
            return _this;
        }
        CxNumericPipe.prototype.transform = function (value, digitsInfo) {
            return _super.prototype.transform.call(this, value, digitsInfo, this.getLang());
        };
        CxNumericPipe.prototype.getLang = function () {
            var lang = this.getActiveLang();
            try {
                i6.getLocaleId(lang);
                return lang;
            }
            catch (_a) {
                this.reportMissingLocaleData(lang);
                return 'en';
            }
        };
        CxNumericPipe.prototype.getActiveLang = function () {
            var result;
            this.language
                .getActive()
                .subscribe(function (lang) { return (result = lang); })
                .unsubscribe();
            return result;
        };
        CxNumericPipe.prototype.reportMissingLocaleData = function (lang) {
            if (i0.isDevMode()) {
                console.warn("cxNumeric pipe: No locale data registered for '" + lang + "' (see https://angular.io/api/common/registerLocaleData).");
            }
        };
        return CxNumericPipe;
    }(i6.DecimalPipe));
    CxNumericPipe.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CxNumericPipe, deps: [{ token: LanguageService }], target: i0__namespace.ɵɵFactoryTarget.Pipe });
    CxNumericPipe.ɵpipe = i0__namespace.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CxNumericPipe, name: "cxNumeric" });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CxNumericPipe, decorators: [{
                type: i0.Pipe,
                args: [{ name: 'cxNumeric' }]
            }], ctorParameters: function () { return [{ type: LanguageService }]; } });

    var defaultI18nConfig = {
        i18n: {
            fallbackLang: undefined,
            debug: false,
        },
    };

    function i18nextInit(i18next, configInit, languageService, httpClient, serverRequestOrigin, siteContextI18nextSynchronizer) {
        return function () { return configInit
            .getStable('i18n')
            .pipe(operators.tap(function (config) {
            var _a, _b, _c, _d;
            var i18nextConfig = {
                ns: [],
                fallbackLng: (_a = config.i18n) === null || _a === void 0 ? void 0 : _a.fallbackLang,
                debug: (_b = config.i18n) === null || _b === void 0 ? void 0 : _b.debug,
                interpolation: {
                    escapeValue: false,
                },
            };
            if ((_d = (_c = config.i18n) === null || _c === void 0 ? void 0 : _c.backend) === null || _d === void 0 ? void 0 : _d.loadPath) {
                i18next = i18next.use(i18nextHttpBackend__default['default']);
                var loadPath = getLoadPath(config.i18n.backend.loadPath, serverRequestOrigin);
                var backend = {
                    loadPath: loadPath,
                    request: i18nextGetHttpClient(httpClient),
                    // Disable the periodical reloading. Otherwise SSR would not finish due to the pending task `setInterval()`
                    // See source code of `i18next-http-backend` : https://github.com/i18next/i18next-http-backend/blob/00b7e8f67abf8372af17529b51190a7e8b17e3d8/lib/index.js#L40-L41
                    reloadInterval: false,
                };
                i18nextConfig = Object.assign(Object.assign({}, i18nextConfig), { backend: backend });
            }
            return i18next.init(i18nextConfig, function () {
                var _a;
                // Don't use i18next's 'resources' config key for adding static translations,
                // because it will disable loading chunks from backend. We add resources here, in the init's callback.
                i18nextAddTranslations(i18next, (_a = config.i18n) === null || _a === void 0 ? void 0 : _a.resources);
                siteContextI18nextSynchronizer.init(i18next, languageService);
            });
        }))
            .toPromise(); };
    }
    function i18nextAddTranslations(i18next, resources) {
        if (resources === void 0) { resources = {}; }
        Object.keys(resources).forEach(function (lang) {
            Object.keys(resources[lang]).forEach(function (chunkName) {
                i18next.addResourceBundle(lang, chunkName, resources[lang][chunkName], true, true);
            });
        });
    }
    var SiteContextI18nextSynchronizer = /** @class */ (function () {
        function SiteContextI18nextSynchronizer() {
        }
        SiteContextI18nextSynchronizer.prototype.init = function (i18next, language) {
            var _a;
            // always update language of i18next on site context (language) change
            this.sub =
                (_a = this.sub) !== null && _a !== void 0 ? _a : language.getActive().subscribe(function (lang) { return i18next.changeLanguage(lang); });
        };
        SiteContextI18nextSynchronizer.prototype.ngOnDestroy = function () {
            var _a;
            (_a = this.sub) === null || _a === void 0 ? void 0 : _a.unsubscribe();
        };
        return SiteContextI18nextSynchronizer;
    }());
    SiteContextI18nextSynchronizer.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SiteContextI18nextSynchronizer, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    SiteContextI18nextSynchronizer.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SiteContextI18nextSynchronizer, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SiteContextI18nextSynchronizer, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }] });
    /**
     * Returns a function appropriate for i18next to make http calls for JSON files.
     * See docs for `i18next-http-backend`: https://github.com/i18next/i18next-http-backend#backend-options
     *
     * It uses Angular HttpClient under the hood, so it works in SSR.
     * @param httpClient Angular http client
     */
    function i18nextGetHttpClient(httpClient) {
        return function (_options, url, _payload, callback) {
            httpClient.get(url, { responseType: 'text' }).subscribe(function (data) { return callback(null, { status: 200, data: data }); }, function (error) { return callback(error, {
                // a workaround for https://github.com/i18next/i18next-http-backend/issues/82
                data: null,
                status: error.status,
            }); });
        };
    }
    /**
     * Resolves the relative path to the absolute one in SSR, using the server request's origin.
     * It's needed, because Angular Universal doesn't support relative URLs in HttpClient. See Angular issues:
     * - https://github.com/angular/angular/issues/19224
     * - https://github.com/angular/universal/issues/858
     */
    function getLoadPath(path, serverRequestOrigin) {
        if (serverRequestOrigin && !path.match(/^http(s)?:\/\//)) {
            if (path.startsWith('/')) {
                path = path.slice(1);
            }
            if (path.startsWith('./')) {
                path = path.slice(2);
            }
            var result = serverRequestOrigin + "/" + path;
            return result;
        }
        return path;
    }

    /**
     * The instance of i18next.
     *
     * Each SSR request gets its own instance of i18next.
     *
     * The reference to the static global instance of `i18next` (`import i18next from 'i18next`)
     * should not be used anywhere else, because otherwise it would be shared in between all SSR requests
     * and can cause concurrency issues.
     */
    var I18NEXT_INSTANCE = new i0.InjectionToken('I18NEXT_INSTANCE', {
        providedIn: 'root',
        factory: function () { return i18next__default['default'].createInstance(); },
    });

    var i18nextProviders = [
        {
            provide: i0.APP_INITIALIZER,
            useFactory: i18nextInit,
            deps: [
                I18NEXT_INSTANCE,
                ConfigInitializerService,
                LanguageService,
                i1$3.HttpClient,
                [new i0.Optional(), SERVER_REQUEST_ORIGIN],
                SiteContextI18nextSynchronizer,
            ],
            multi: true,
        },
    ];

    var TranslationChunkService = /** @class */ (function () {
        function TranslationChunkService(config) {
            var _this = this;
            this.config = config;
            this.duplicates = {};
            this.chunks = {};
            this.KEY_SEPARATOR = '.';
            var chunks = (config.i18n && config.i18n.chunks) || {};
            Object.keys(chunks).forEach(function (chunk) {
                chunks[chunk].forEach(function (key) {
                    if (_this.chunks.hasOwnProperty(key)) {
                        if (!_this.duplicates[key]) {
                            _this.duplicates[key] = [_this.chunks[key]];
                        }
                        _this.duplicates[key].push(chunk);
                    }
                    else {
                        _this.chunks[key] = chunk;
                    }
                });
            });
            if (Object.keys(this.duplicates).length > 0 && i0.isDevMode()) {
                this.warnDuplicates(this.duplicates);
            }
        }
        TranslationChunkService.prototype.getChunkNameForKey = function (key) {
            var mainKey = (key || '').split(this.KEY_SEPARATOR)[0];
            var chunk = this.chunks && this.chunks[mainKey];
            if (!chunk) {
                return mainKey; // fallback to main key as a chunk
            }
            return chunk;
        };
        TranslationChunkService.prototype.warnDuplicates = function (items) {
            var _this = this;
            var dupes = [];
            Object.keys(items).forEach(function (key) {
                dupes.push("* '" + key + "' found in chunks: " + items[key].join(', ') + ". Used '" + _this.chunks[key] + "." + key + "'.");
            });
            console.warn("Duplicated keys has been found in the config of i18n chunks:\n" + dupes.join('\n'));
        };
        return TranslationChunkService;
    }());
    TranslationChunkService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: TranslationChunkService, deps: [{ token: I18nConfig }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    TranslationChunkService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: TranslationChunkService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: TranslationChunkService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: I18nConfig }]; } });

    var I18nextTranslationService = /** @class */ (function () {
        function I18nextTranslationService(config, translationChunk, 
        // Required param added in 3.0.x as a critical bug fix, not subject to the breaking changes policy
        i18next) {
            this.config = config;
            this.translationChunk = translationChunk;
            this.i18next = i18next;
            this.NON_BREAKING_SPACE = String.fromCharCode(160);
            this.NAMESPACE_SEPARATOR = ':';
        }
        I18nextTranslationService.prototype.translate = function (key, options, whitespaceUntilLoaded) {
            var _this = this;
            if (options === void 0) { options = {}; }
            if (whitespaceUntilLoaded === void 0) { whitespaceUntilLoaded = false; }
            // If we've already loaded the chunk (or failed to load), we should immediately emit the value
            // (or the fallback value in case the key is missing).
            // Moreover, we SHOULD emit a value (or a fallback value) synchronously (not in a promise/setTimeout).
            // Otherwise, we the will trigger additional deferred change detection in a view that consumes the returned observable,
            // which together with `switchMap` operator may lead to an infinite loop.
            var chunkName = this.translationChunk.getChunkNameForKey(key);
            var namespacedKey = this.getNamespacedKey(key, chunkName);
            return new rxjs.Observable(function (subscriber) {
                var translate = function () {
                    if (!_this.i18next.isInitialized) {
                        return;
                    }
                    if (_this.i18next.exists(namespacedKey, options)) {
                        subscriber.next(_this.i18next.t(namespacedKey, options));
                    }
                    else {
                        if (whitespaceUntilLoaded) {
                            subscriber.next(_this.NON_BREAKING_SPACE);
                        }
                        _this.i18next.loadNamespaces(chunkName, function () {
                            if (!_this.i18next.exists(namespacedKey, options)) {
                                _this.reportMissingKey(key, chunkName);
                                subscriber.next(_this.getFallbackValue(namespacedKey));
                            }
                            else {
                                subscriber.next(_this.i18next.t(namespacedKey, options));
                            }
                        });
                    }
                };
                translate();
                _this.i18next.on('languageChanged', translate);
                return function () { return _this.i18next.off('languageChanged', translate); };
            });
        };
        I18nextTranslationService.prototype.loadChunks = function (chunkNames) {
            return this.i18next.loadNamespaces(chunkNames);
        };
        /**
         * Returns a fallback value in case when the given key is missing
         * @param key
         */
        I18nextTranslationService.prototype.getFallbackValue = function (key) {
            return i0.isDevMode() ? "[" + key + "]" : this.NON_BREAKING_SPACE;
        };
        I18nextTranslationService.prototype.reportMissingKey = function (key, chunkName) {
            if (i0.isDevMode()) {
                console.warn("Translation key missing '" + key + "' in the chunk '" + chunkName + "'");
            }
        };
        I18nextTranslationService.prototype.getNamespacedKey = function (key, chunk) {
            return chunk + this.NAMESPACE_SEPARATOR + key;
        };
        return I18nextTranslationService;
    }());
    I18nextTranslationService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: I18nextTranslationService, deps: [{ token: I18nConfig }, { token: TranslationChunkService }, { token: I18NEXT_INSTANCE }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    I18nextTranslationService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: I18nextTranslationService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: I18nextTranslationService, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }], ctorParameters: function () {
            return [{ type: I18nConfig }, { type: TranslationChunkService }, { type: undefined, decorators: [{
                            type: i0.Inject,
                            args: [I18NEXT_INSTANCE]
                        }] }];
        } });

    var TranslatePipe = /** @class */ (function () {
        function TranslatePipe(service, cd) {
            this.service = service;
            this.cd = cd;
        }
        TranslatePipe.prototype.transform = function (input, options) {
            if (options === void 0) { options = {}; }
            if (!input) {
                if (i0.isDevMode()) {
                    console.error("The given input for the cxTranslate pipe (" + input + ") is invalid and cannot be translated");
                }
                return;
            }
            if (input.raw) {
                return input.raw;
            }
            var key = typeof input === 'string' ? input : input.key;
            if (typeof input !== 'string') {
                options = Object.assign(Object.assign({}, options), input.params);
            }
            this.translate(key, options);
            return this.translatedValue;
        };
        TranslatePipe.prototype.translate = function (key, options) {
            var _this = this;
            if (key !== this.lastKey ||
                !shallowEqualObjects(options, this.lastOptions)) {
                this.lastKey = key;
                this.lastOptions = options;
                if (this.sub) {
                    this.sub.unsubscribe();
                }
                this.sub = this.service
                    .translate(key, options, true)
                    .subscribe(function (val) { return _this.markForCheck(val); });
            }
        };
        TranslatePipe.prototype.markForCheck = function (value) {
            this.translatedValue = value;
            this.cd.markForCheck();
        };
        TranslatePipe.prototype.ngOnDestroy = function () {
            if (this.sub) {
                this.sub.unsubscribe();
            }
        };
        return TranslatePipe;
    }());
    TranslatePipe.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: TranslatePipe, deps: [{ token: TranslationService }, { token: i0__namespace.ChangeDetectorRef }], target: i0__namespace.ɵɵFactoryTarget.Pipe });
    TranslatePipe.ɵpipe = i0__namespace.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: TranslatePipe, name: "cxTranslate", pure: false });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: TranslatePipe, decorators: [{
                type: i0.Pipe,
                args: [{ name: 'cxTranslate', pure: false }]
            }], ctorParameters: function () { return [{ type: TranslationService }, { type: i0__namespace.ChangeDetectorRef }]; } });

    function initI18nConfig(configInitializer, config) {
        var _a;
        /**
         * If `fallbackLang` was already configured statically
         */
        if (((_a = config === null || config === void 0 ? void 0 : config.i18n) === null || _a === void 0 ? void 0 : _a.fallbackLang) !== undefined) {
            return null;
        }
        return configInitializer;
    }
    var I18nModule = /** @class */ (function () {
        function I18nModule() {
        }
        I18nModule.forRoot = function () {
            return {
                ngModule: I18nModule,
                providers: __spreadArray(__spreadArray([
                    provideDefaultConfig(defaultI18nConfig),
                    { provide: TranslationService, useExisting: I18nextTranslationService }
                ], __read(i18nextProviders)), [
                    {
                        provide: CONFIG_INITIALIZER,
                        useFactory: initI18nConfig,
                        deps: [I18nConfigInitializer, I18nConfig],
                        multi: true,
                    },
                ]),
            };
        };
        return I18nModule;
    }());
    I18nModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: I18nModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    I18nModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: I18nModule, declarations: [TranslatePipe, CxDatePipe, CxNumericPipe], exports: [TranslatePipe, CxDatePipe, CxNumericPipe] });
    I18nModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: I18nModule });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: I18nModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        declarations: [TranslatePipe, CxDatePipe, CxNumericPipe],
                        exports: [TranslatePipe, CxDatePipe, CxNumericPipe],
                    }]
            }] });

    function mockTranslate(key, options) {
        if (options === void 0) { options = {}; }
        var optionsString = Object.keys(options)
            .sort()
            .map(function (optionName) { return optionName + ":" + options[optionName]; })
            .join(' ');
        return optionsString ? key + " " + optionsString : key;
    }

    var MockTranslatePipe = /** @class */ (function () {
        function MockTranslatePipe() {
        }
        MockTranslatePipe.prototype.transform = function (input, options) {
            if (options === void 0) { options = {}; }
            if (input.raw) {
                return input.raw;
            }
            var key = typeof input === 'string' ? input : input.key;
            if (typeof input !== 'string') {
                options = Object.assign(Object.assign({}, options), input.params);
            }
            return mockTranslate(key, options);
        };
        return MockTranslatePipe;
    }());
    MockTranslatePipe.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: MockTranslatePipe, deps: [], target: i0__namespace.ɵɵFactoryTarget.Pipe });
    MockTranslatePipe.ɵpipe = i0__namespace.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: MockTranslatePipe, name: "cxTranslate" });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: MockTranslatePipe, decorators: [{
                type: i0.Pipe,
                args: [{ name: 'cxTranslate' }]
            }] });

    var MockTranslationService = /** @class */ (function () {
        function MockTranslationService() {
        }
        MockTranslationService.prototype.translate = function (key, options, _whitespaceUntilLoaded) {
            if (options === void 0) { options = {}; }
            if (_whitespaceUntilLoaded === void 0) { _whitespaceUntilLoaded = false; }
            return new rxjs.Observable(function (subscriber) {
                var value = mockTranslate(key, options);
                subscriber.next(value);
                subscriber.complete();
            });
        };
        MockTranslationService.prototype.loadChunks = function (_chunks) {
            return Promise.resolve();
        };
        return MockTranslationService;
    }());
    MockTranslationService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: MockTranslationService, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    MockTranslationService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: MockTranslationService });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: MockTranslationService, decorators: [{
                type: i0.Injectable
            }] });

    var MockDatePipe = /** @class */ (function (_super) {
        __extends(MockDatePipe, _super);
        function MockDatePipe() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        // Overload to support stricter type check from angular 11 onwards
        MockDatePipe.prototype.transform = function (value, format, timezone, locale) {
            if (locale === void 0) { locale = 'en'; }
            return _super.prototype.transform.call(this, value, format, timezone, locale);
        };
        return MockDatePipe;
    }(i6.DatePipe));
    MockDatePipe.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: MockDatePipe, deps: null, target: i0__namespace.ɵɵFactoryTarget.Pipe });
    MockDatePipe.ɵpipe = i0__namespace.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: MockDatePipe, name: "cxDate" });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: MockDatePipe, decorators: [{
                type: i0.Pipe,
                args: [{ name: 'cxDate' }]
            }] });

    var I18nTestingModule = /** @class */ (function () {
        function I18nTestingModule() {
        }
        return I18nTestingModule;
    }());
    I18nTestingModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: I18nTestingModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    I18nTestingModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: I18nTestingModule, declarations: [MockTranslatePipe, MockDatePipe], exports: [MockTranslatePipe, MockDatePipe] });
    I18nTestingModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: I18nTestingModule, providers: [
            { provide: TranslationService, useClass: MockTranslationService },
        ] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: I18nTestingModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        declarations: [MockTranslatePipe, MockDatePipe],
                        exports: [MockTranslatePipe, MockDatePipe],
                        providers: [
                            { provide: TranslationService, useClass: MockTranslationService },
                        ],
                    }]
            }] });

    var COST_CENTER_NORMALIZER = new i0.InjectionToken('CostCenterNormalizer');
    var COST_CENTERS_NORMALIZER = new i0.InjectionToken('CostCentersListNormalizer');
    var COST_CENTER_SERIALIZER = new i0.InjectionToken('CostCenterSerializer');

    var CostCenterModule = /** @class */ (function () {
        function CostCenterModule() {
        }
        CostCenterModule.forRoot = function () {
            return {
                ngModule: CostCenterModule,
                providers: [],
            };
        };
        return CostCenterModule;
    }());
    CostCenterModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CostCenterModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    CostCenterModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CostCenterModule });
    CostCenterModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CostCenterModule });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CostCenterModule, decorators: [{
                type: i0.NgModule,
                args: [{}]
            }] });

    var PRODUCT_NORMALIZER = new i0.InjectionToken('ProductNormalizer');

    var ConverterService = /** @class */ (function () {
        function ConverterService(unifiedInjector) {
            var _this = this;
            this.unifiedInjector = unifiedInjector;
            this.subscriptions = new rxjs.Subscription();
            this.converters = new Map();
            // Clear cached converters when new injectors appear
            var cacheResetLogic = this.unifiedInjector.injectors$.pipe(operators.tap(function () { return _this.converters.clear(); }));
            this.subscriptions.add(cacheResetLogic.subscribe());
        }
        ConverterService.prototype.getConverters = function (injectionToken) {
            if (!this.converters.has(injectionToken)) {
                var converters = getLastValueSync(this.unifiedInjector.getMulti(injectionToken));
                this.converters.set(injectionToken, converters);
            }
            return this.converters.get(injectionToken);
        };
        /**
         * Will return true if converters for specified token were provided
         */
        ConverterService.prototype.hasConverters = function (injectionToken) {
            var converters = this.getConverters(injectionToken);
            return Array.isArray(converters) && converters.length > 0;
        };
        /**
         * Pipeable operator to apply converter logic in a observable stream
         */
        ConverterService.prototype.pipeable = function (injectionToken) {
            var _this = this;
            if (this.hasConverters(injectionToken)) {
                return operators.map(function (model) { return _this.convertSource(model, injectionToken); });
            }
            else {
                return function (observable) { return observable; };
            }
        };
        /**
         * Pipeable operator to apply converter logic in a observable stream to collection of items
         */
        ConverterService.prototype.pipeableMany = function (injectionToken) {
            var _this = this;
            if (this.hasConverters(injectionToken)) {
                return operators.map(function (model) { return _this.convertMany(model, injectionToken); });
            }
            else {
                return function (observable) { return observable; };
            }
        };
        /**
         * Apply converter logic specified by injection token to source data
         */
        ConverterService.prototype.convert = function (source, injectionToken) {
            if (this.hasConverters(injectionToken)) {
                return this.convertSource(source, injectionToken);
            }
            else {
                return source;
            }
        };
        /**
         * Apply converter logic specified by injection token to a collection
         */
        ConverterService.prototype.convertMany = function (sources, injectionToken) {
            var _this = this;
            if (this.hasConverters(injectionToken) && Array.isArray(sources)) {
                return sources.map(function (source) { return _this.convertSource(source, injectionToken); });
            }
            else {
                return sources;
            }
        };
        ConverterService.prototype.convertSource = function (source, injectionToken) {
            return this.getConverters(injectionToken).reduce(function (target, converter) {
                return converter.convert(source, target);
            }, undefined);
        };
        ConverterService.prototype.ngOnDestroy = function () {
            this.subscriptions.unsubscribe();
        };
        return ConverterService;
    }());
    ConverterService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ConverterService, deps: [{ token: UnifiedInjector }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ConverterService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ConverterService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ConverterService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: UnifiedInjector }]; } });

    var OrderEntryPromotionsService = /** @class */ (function () {
        function OrderEntryPromotionsService() {
        }
        /**
         * Get consumed promotions for the given order entry
         *
         * @param item
         * @param promotions
         * @returns consumed promotions for this entry
         */
        OrderEntryPromotionsService.prototype.getProductPromotion = function (item, promotions) {
            var e_1, _a, e_2, _b;
            var entryPromotions = [];
            if (promotions && promotions.length > 0) {
                try {
                    for (var promotions_1 = __values(promotions), promotions_1_1 = promotions_1.next(); !promotions_1_1.done; promotions_1_1 = promotions_1.next()) {
                        var promotion = promotions_1_1.value;
                        if (promotion.description &&
                            promotion.consumedEntries &&
                            promotion.consumedEntries.length > 0) {
                            try {
                                for (var _c = (e_2 = void 0, __values(promotion.consumedEntries)), _d = _c.next(); !_d.done; _d = _c.next()) {
                                    var consumedEntry = _d.value;
                                    if (this.isConsumedByEntry(consumedEntry, item)) {
                                        entryPromotions.push(promotion);
                                    }
                                }
                            }
                            catch (e_2_1) { e_2 = { error: e_2_1 }; }
                            finally {
                                try {
                                    if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
                                }
                                finally { if (e_2) throw e_2.error; }
                            }
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (promotions_1_1 && !promotions_1_1.done && (_a = promotions_1.return)) _a.call(promotions_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
            return entryPromotions;
        };
        OrderEntryPromotionsService.prototype.isConsumedByEntry = function (consumedEntry, entry) {
            var e_3, _a;
            var consumedEntryNumber = consumedEntry.orderEntryNumber;
            if (entry && entry.entries && entry.entries.length > 0) {
                try {
                    for (var _b = __values(entry.entries), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var subEntry = _c.value;
                        if (subEntry.entryNumber === consumedEntryNumber) {
                            return true;
                        }
                    }
                }
                catch (e_3_1) { e_3 = { error: e_3_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_3) throw e_3.error; }
                }
                return false;
            }
            else {
                return consumedEntryNumber === (entry === null || entry === void 0 ? void 0 : entry.entryNumber);
            }
        };
        return OrderEntryPromotionsService;
    }());
    OrderEntryPromotionsService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OrderEntryPromotionsService, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    OrderEntryPromotionsService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OrderEntryPromotionsService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OrderEntryPromotionsService, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }] });

    var OccCartNormalizer = /** @class */ (function () {
        function OccCartNormalizer(converter, entryPromotionService) {
            this.converter = converter;
            this.entryPromotionService = entryPromotionService;
        }
        OccCartNormalizer.prototype.convert = function (source, target) {
            var _this = this;
            if (target === undefined) {
                target = Object.assign({}, source);
            }
            this.removeDuplicatePromotions(source, target);
            if (source.entries) {
                target.entries = source.entries.map(function (entry) { return (Object.assign(Object.assign({}, entry), { product: _this.converter.convert(entry.product, PRODUCT_NORMALIZER), promotions: _this.entryPromotionService
                        ? _this.entryPromotionService.getProductPromotion(entry, target === null || target === void 0 ? void 0 : target.appliedProductPromotions)
                        : [] })); });
            }
            return target;
        };
        /**
         * Remove all duplicate promotions
         */
        OccCartNormalizer.prototype.removeDuplicatePromotions = function (source, target) {
            if (source && source.potentialOrderPromotions) {
                target.potentialOrderPromotions = this.removeDuplicateItems(source.potentialOrderPromotions);
            }
            if (source && source.potentialProductPromotions) {
                target.potentialProductPromotions = this.removeDuplicateItems(source.potentialProductPromotions);
            }
            if (source && source.appliedOrderPromotions) {
                target.appliedOrderPromotions = this.removeDuplicateItems(source.appliedOrderPromotions);
            }
            if (source && source.appliedProductPromotions) {
                target.appliedProductPromotions = this.removeDuplicateItems(source.appliedProductPromotions);
            }
        };
        OccCartNormalizer.prototype.removeDuplicateItems = function (itemList) {
            return itemList.filter(function (p, i, a) {
                var b = a.map(function (el) { return JSON.stringify(el); });
                return i === b.indexOf(JSON.stringify(p));
            });
        };
        return OccCartNormalizer;
    }());
    OccCartNormalizer.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccCartNormalizer, deps: [{ token: ConverterService }, { token: OrderEntryPromotionsService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    OccCartNormalizer.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccCartNormalizer, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccCartNormalizer, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }], ctorParameters: function () { return [{ type: ConverterService }, { type: OrderEntryPromotionsService }]; } });

    var defaultOccCartConfig = {
        backend: {
            occ: {
                endpoints: {
                    /* eslint-disable max-len */
                    carts: 'users/${userId}/carts?fields=carts(DEFAULT,potentialProductPromotions,appliedProductPromotions,potentialOrderPromotions,appliedOrderPromotions,entries(totalPrice(formattedValue),product(images(FULL),stock(FULL)),basePrice(formattedValue,value),updateable),totalPrice(formattedValue),totalItems,totalPriceWithTax(formattedValue),totalDiscounts(value,formattedValue),subTotal(formattedValue),deliveryItemsQuantity,deliveryCost(formattedValue),totalTax(formattedValue, value),pickupItemsQuantity,net,appliedVouchers,productDiscounts(formattedValue),user,saveTime,name,description)',
                    cart: 'users/${userId}/carts/${cartId}?fields=DEFAULT,potentialProductPromotions,appliedProductPromotions,potentialOrderPromotions,appliedOrderPromotions,entries(totalPrice(formattedValue),product(images(FULL),stock(FULL)),basePrice(formattedValue,value),updateable),totalPrice(formattedValue),totalItems,totalPriceWithTax(formattedValue),totalDiscounts(value,formattedValue),subTotal(formattedValue),deliveryItemsQuantity,deliveryCost(formattedValue),totalTax(formattedValue, value),pickupItemsQuantity,net,appliedVouchers,productDiscounts(formattedValue),user,saveTime,name,description',
                    createCart: 'users/${userId}/carts?fields=DEFAULT,potentialProductPromotions,appliedProductPromotions,potentialOrderPromotions,appliedOrderPromotions,entries(totalPrice(formattedValue),product(images(FULL),stock(FULL)),basePrice(formattedValue,value),updateable),totalPrice(formattedValue),totalItems,totalPriceWithTax(formattedValue),totalDiscounts(value,formattedValue),subTotal(formattedValue),deliveryItemsQuantity,deliveryCost(formattedValue),totalTax(formattedValue, value),pickupItemsQuantity,net,appliedVouchers,productDiscounts(formattedValue),user',
                    addEntries: 'users/${userId}/carts/${cartId}/entries',
                    updateEntries: 'users/${userId}/carts/${cartId}/entries/${entryNumber}',
                    removeEntries: 'users/${userId}/carts/${cartId}/entries/${entryNumber}',
                    addEmail: 'users/${userId}/carts/${cartId}/email',
                    deleteCart: 'users/${userId}/carts/${cartId}',
                    cartVoucher: 'users/${userId}/carts/${cartId}/vouchers',
                    saveCart: 'users/${userId}/carts/${cartId}/save',
                    validate: 'users/${userId}/carts/${cartId}/validate?fields=DEFAULT',
                    /* eslint-enable */
                },
            },
        },
    };

    var OccCartEntryAdapter = /** @class */ (function () {
        function OccCartEntryAdapter(http, occEndpointsService, converterService) {
            this.http = http;
            this.occEndpointsService = occEndpointsService;
            this.converterService = converterService;
        }
        OccCartEntryAdapter.prototype.add = function (userId, cartId, productCode, quantity) {
            if (quantity === void 0) { quantity = 1; }
            var url = this.occEndpointsService.buildUrl('addEntries', {
                urlParams: { userId: userId, cartId: cartId, quantity: quantity },
            });
            // Handle b2b case where the x-www-form-urlencoded is still used
            if (url.includes("quantity=" + quantity)) {
                var headers_1 = new i1$3.HttpHeaders({
                    'Content-Type': 'application/x-www-form-urlencoded',
                });
                return this.http
                    .post(url, {}, { headers: headers_1, params: { code: productCode } })
                    .pipe(this.converterService.pipeable(CART_MODIFICATION_NORMALIZER));
            }
            var toAdd = {
                quantity: quantity,
                product: { code: productCode },
            };
            var headers = new i1$3.HttpHeaders({
                'Content-Type': 'application/json',
            });
            return this.http
                .post(url, toAdd, { headers: headers })
                .pipe(this.converterService.pipeable(CART_MODIFICATION_NORMALIZER));
        };
        OccCartEntryAdapter.prototype.update = function (userId, cartId, entryNumber, qty, pickupStore) {
            var params = {};
            if (pickupStore) {
                params = {
                    deliveryPointOfService: {
                        name: pickupStore,
                    },
                };
            }
            var headers = new i1$3.HttpHeaders({
                'Content-Type': 'application/json',
            });
            var url = this.occEndpointsService.buildUrl('updateEntries', {
                urlParams: {
                    userId: userId,
                    cartId: cartId,
                    entryNumber: entryNumber,
                },
            });
            return this.http
                .patch(url, Object.assign({ quantity: qty }, params), { headers: headers })
                .pipe(this.converterService.pipeable(CART_MODIFICATION_NORMALIZER));
        };
        OccCartEntryAdapter.prototype.remove = function (userId, cartId, entryNumber) {
            var headers = new i1$3.HttpHeaders({
                'Content-Type': 'application/x-www-form-urlencoded',
            });
            var url = this.occEndpointsService.buildUrl('removeEntries', {
                urlParams: {
                    userId: userId,
                    cartId: cartId,
                    entryNumber: entryNumber,
                },
            });
            return this.http.delete(url, { headers: headers });
        };
        return OccCartEntryAdapter;
    }());
    OccCartEntryAdapter.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccCartEntryAdapter, deps: [{ token: i1__namespace$3.HttpClient }, { token: OccEndpointsService }, { token: ConverterService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    OccCartEntryAdapter.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccCartEntryAdapter });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccCartEntryAdapter, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: i1__namespace$3.HttpClient }, { type: OccEndpointsService }, { type: ConverterService }]; } });

    var OccCartVoucherAdapter = /** @class */ (function () {
        function OccCartVoucherAdapter(http, occEndpoints, converter) {
            this.http = http;
            this.occEndpoints = occEndpoints;
            this.converter = converter;
        }
        OccCartVoucherAdapter.prototype.getCartVoucherEndpoint = function (userId, cartId) {
            return this.occEndpoints.buildUrl('cartVoucher', {
                urlParams: { userId: userId, cartId: cartId },
            });
        };
        OccCartVoucherAdapter.prototype.getHeaders = function (userId) {
            var headers = new i1$3.HttpHeaders({
                'Content-Type': 'application/json',
            });
            if (userId === OCC_USER_ID_ANONYMOUS) {
                headers = InterceptorUtil.createHeader(USE_CLIENT_TOKEN, true, headers);
            }
            return headers;
        };
        OccCartVoucherAdapter.prototype.add = function (userId, cartId, voucherId) {
            var url = this.getCartVoucherEndpoint(userId, cartId);
            var toAdd = JSON.stringify({});
            var params = new i1$3.HttpParams().set('voucherId', voucherId);
            var headers = this.getHeaders(userId);
            return this.http.post(url, toAdd, { headers: headers, params: params }).pipe(operators.catchError(function (error) { return rxjs.throwError(error); }), this.converter.pipeable(CART_VOUCHER_NORMALIZER));
        };
        OccCartVoucherAdapter.prototype.remove = function (userId, cartId, voucherId) {
            var url = this.getCartVoucherEndpoint(userId, cartId) +
                '/' +
                encodeURIComponent(voucherId);
            var headers = this.getHeaders(userId);
            return this.http
                .delete(url, { headers: headers })
                .pipe(operators.catchError(function (error) { return rxjs.throwError(error); }));
        };
        return OccCartVoucherAdapter;
    }());
    OccCartVoucherAdapter.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccCartVoucherAdapter, deps: [{ token: i1__namespace$3.HttpClient }, { token: OccEndpointsService }, { token: ConverterService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    OccCartVoucherAdapter.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccCartVoucherAdapter });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccCartVoucherAdapter, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: i1__namespace$3.HttpClient }, { type: OccEndpointsService }, { type: ConverterService }]; } });

    var OccCartAdapter = /** @class */ (function () {
        function OccCartAdapter(http, occEndpointsService, converterService) {
            this.http = http;
            this.occEndpointsService = occEndpointsService;
            this.converterService = converterService;
        }
        OccCartAdapter.prototype.loadAll = function (userId) {
            return this.http
                .get(this.occEndpointsService.buildUrl('carts', { urlParams: { userId: userId } }))
                .pipe(operators.pluck('carts'), this.converterService.pipeableMany(CART_NORMALIZER));
        };
        OccCartAdapter.prototype.load = function (userId, cartId) {
            if (cartId === OCC_CART_ID_CURRENT) {
                return this.loadAll(userId).pipe(operators.map(function (carts) {
                    if (carts) {
                        var activeCart = carts.find(function (cart) {
                            return cart['saveTime'] === undefined;
                        });
                        return activeCart;
                    }
                    else {
                        return null;
                    }
                }));
            }
            else {
                return this.http
                    .get(this.occEndpointsService.buildUrl('cart', {
                    urlParams: { userId: userId, cartId: cartId },
                }))
                    .pipe(this.converterService.pipeable(CART_NORMALIZER));
            }
        };
        OccCartAdapter.prototype.create = function (userId, oldCartId, toMergeCartGuid) {
            var toAdd = JSON.stringify({});
            var params = {};
            if (oldCartId) {
                params = { oldCartId: oldCartId };
            }
            if (toMergeCartGuid) {
                params['toMergeCartGuid'] = toMergeCartGuid;
            }
            return this.http
                .post(this.occEndpointsService.buildUrl('createCart', {
                urlParams: { userId: userId },
                queryParams: params,
            }), toAdd)
                .pipe(this.converterService.pipeable(CART_NORMALIZER));
        };
        OccCartAdapter.prototype.delete = function (userId, cartId) {
            var headers = new i1$3.HttpHeaders();
            if (userId === OCC_USER_ID_ANONYMOUS) {
                headers = InterceptorUtil.createHeader(USE_CLIENT_TOKEN, true, headers);
            }
            return this.http.delete(this.occEndpointsService.buildUrl('deleteCart', {
                urlParams: { userId: userId, cartId: cartId },
            }), { headers: headers });
        };
        OccCartAdapter.prototype.addEmail = function (userId, cartId, email) {
            var headers = new i1$3.HttpHeaders({
                'Content-Type': 'application/x-www-form-urlencoded',
            });
            headers = InterceptorUtil.createHeader(USE_CLIENT_TOKEN, true, headers);
            var httpParams = new i1$3.HttpParams().set('email', email);
            var url = this.occEndpointsService.buildUrl('addEmail', {
                urlParams: {
                    userId: userId,
                    cartId: cartId,
                },
            });
            return this.http.put(url, httpParams, { headers: headers });
        };
        return OccCartAdapter;
    }());
    OccCartAdapter.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccCartAdapter, deps: [{ token: i1__namespace$3.HttpClient }, { token: OccEndpointsService }, { token: ConverterService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    OccCartAdapter.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccCartAdapter });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccCartAdapter, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: i1__namespace$3.HttpClient }, { type: OccEndpointsService }, { type: ConverterService }]; } });

    /**
     * TODO(#11938): 4.0: use OccSavedCartAdapter instead from saved-cart feature-lib of cart
     *
     * When the saved cart feature module exist, there exist a race condition between the 'saveCart' key for the default occ config
     * Allows wishlist to function when the key value is pulled from the saved-cart feature-lib
     *
     * Keep in mind that this adapter will be removed in 4.0 as we will delegate this functionality to the saved-cart feature-lib
     **/
    var OccSaveCartAdapter = /** @class */ (function () {
        function OccSaveCartAdapter(http, occEndpointsService, converterService) {
            this.http = http;
            this.occEndpointsService = occEndpointsService;
            this.converterService = converterService;
        }
        OccSaveCartAdapter.prototype.saveCart = function (userId, cartId, saveCartName, saveCartDescription) {
            var httpParams = new i1$3.HttpParams();
            if (Boolean(saveCartName)) {
                httpParams = httpParams.set('saveCartName', saveCartName);
            }
            if (Boolean(saveCartDescription)) {
                httpParams = httpParams.set('saveCartDescription', saveCartDescription);
            }
            var headers = new i1$3.HttpHeaders({
                'Content-Type': 'application/x-www-form-urlencoded',
            });
            return !this.occEndpointsService
                .buildUrl('saveCart', { urlParams: { userId: userId, cartId: cartId } })
                .includes('saveCartName')
                ? this.http
                    .patch(this.occEndpointsService.buildUrl('saveCart', {
                    urlParams: { userId: userId, cartId: cartId },
                }), httpParams, { headers: headers })
                    .pipe(this.converterService.pipeable(SAVE_CART_NORMALIZER))
                : this.http
                    .patch(this.occEndpointsService.buildUrl('saveCart', {
                    urlParams: {
                        userId: userId,
                        cartId: cartId,
                        saveCartName: saveCartName,
                        saveCartDescription: saveCartDescription,
                    },
                }), cartId)
                    .pipe(this.converterService.pipeable(SAVE_CART_NORMALIZER));
        };
        return OccSaveCartAdapter;
    }());
    OccSaveCartAdapter.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccSaveCartAdapter, deps: [{ token: i1__namespace$3.HttpClient }, { token: OccEndpointsService }, { token: ConverterService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    OccSaveCartAdapter.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccSaveCartAdapter });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccSaveCartAdapter, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: i1__namespace$3.HttpClient }, { type: OccEndpointsService }, { type: ConverterService }]; } });

    var OccCartValidationAdapter = /** @class */ (function () {
        function OccCartValidationAdapter(http, occEndpoints, converter) {
            this.http = http;
            this.occEndpoints = occEndpoints;
            this.converter = converter;
        }
        OccCartValidationAdapter.prototype.validate = function (cartId, userId) {
            var url = this.occEndpoints.buildUrl('validate', {
                urlParams: { cartId: cartId, userId: userId },
            });
            return this.http.post(url, null).pipe(operators.catchError(function (error) { return rxjs.throwError(normalizeHttpError(error)); }), this.converter.pipeable(CART_VALIDATION_NORMALIZER));
        };
        return OccCartValidationAdapter;
    }());
    OccCartValidationAdapter.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccCartValidationAdapter, deps: [{ token: i1__namespace$3.HttpClient }, { token: OccEndpointsService }, { token: ConverterService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    OccCartValidationAdapter.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccCartValidationAdapter });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccCartValidationAdapter, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: i1__namespace$3.HttpClient }, { type: OccEndpointsService }, { type: ConverterService }]; } });

    var CartOccModule = /** @class */ (function () {
        function CartOccModule() {
        }
        return CartOccModule;
    }());
    CartOccModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartOccModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    CartOccModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartOccModule, imports: [i6.CommonModule] });
    CartOccModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartOccModule, providers: [
            provideDefaultConfig(defaultOccCartConfig),
            {
                provide: CartAdapter,
                useClass: OccCartAdapter,
            },
            {
                provide: CART_NORMALIZER,
                useExisting: OccCartNormalizer,
                multi: true,
            },
            {
                provide: CartEntryAdapter,
                useClass: OccCartEntryAdapter,
            },
            {
                provide: CartVoucherAdapter,
                useClass: OccCartVoucherAdapter,
            },
            {
                provide: SaveCartAdapter,
                useClass: OccSaveCartAdapter,
            },
            {
                provide: CartValidationAdapter,
                useClass: OccCartValidationAdapter,
            },
        ], imports: [[i6.CommonModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CartOccModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [i6.CommonModule],
                        providers: [
                            provideDefaultConfig(defaultOccCartConfig),
                            {
                                provide: CartAdapter,
                                useClass: OccCartAdapter,
                            },
                            {
                                provide: CART_NORMALIZER,
                                useExisting: OccCartNormalizer,
                                multi: true,
                            },
                            {
                                provide: CartEntryAdapter,
                                useClass: OccCartEntryAdapter,
                            },
                            {
                                provide: CartVoucherAdapter,
                                useClass: OccCartVoucherAdapter,
                            },
                            {
                                provide: SaveCartAdapter,
                                useClass: OccSaveCartAdapter,
                            },
                            {
                                provide: CartValidationAdapter,
                                useClass: OccCartValidationAdapter,
                            },
                        ],
                    }]
            }] });

    var OccCmsComponentAdapter = /** @class */ (function () {
        function OccCmsComponentAdapter(http, occEndpoints, converter) {
            this.http = http;
            this.occEndpoints = occEndpoints;
            this.converter = converter;
            this.headers = new i1$3.HttpHeaders().set('Content-Type', 'application/json');
        }
        OccCmsComponentAdapter.prototype.load = function (id, pageContext) {
            return this.http
                .get(this.getComponentEndPoint(id, pageContext), {
                headers: this.headers,
            })
                .pipe(this.converter.pipeable(CMS_COMPONENT_NORMALIZER));
        };
        OccCmsComponentAdapter.prototype.findComponentsByIds = function (ids, pageContext, fields, currentPage, pageSize, sort) {
            if (fields === void 0) { fields = 'DEFAULT'; }
            if (currentPage === void 0) { currentPage = 0; }
            if (pageSize === void 0) { pageSize = ids.length; }
            var requestParams = Object.assign(Object.assign({}, this.getContextParams(pageContext)), this.getPaginationParams(currentPage, pageSize, sort));
            requestParams['componentIds'] = ids.toString();
            return this.http
                .get(this.getComponentsEndpoint(requestParams, fields), {
                headers: this.headers,
            })
                .pipe(operators.pluck('component'), this.converter.pipeableMany(CMS_COMPONENT_NORMALIZER));
        };
        OccCmsComponentAdapter.prototype.getComponentEndPoint = function (id, pageContext) {
            return this.occEndpoints.buildUrl('component', {
                urlParams: { id: id },
                queryParams: this.getContextParams(pageContext),
            });
        };
        OccCmsComponentAdapter.prototype.getComponentsEndpoint = function (requestParams, fields) {
            return this.occEndpoints.buildUrl('components', {
                queryParams: Object.assign({ fields: fields }, requestParams),
            });
        };
        OccCmsComponentAdapter.prototype.getPaginationParams = function (currentPage, pageSize, sort) {
            var requestParams = {};
            if (currentPage !== undefined) {
                requestParams['currentPage'] = currentPage.toString();
            }
            if (pageSize !== undefined) {
                requestParams['pageSize'] = pageSize.toString();
            }
            if (sort !== undefined) {
                requestParams['sort'] = sort;
            }
            return requestParams;
        };
        OccCmsComponentAdapter.prototype.getContextParams = function (pageContext) {
            var requestParams = {};
            switch (pageContext.type) {
                case exports.PageType.PRODUCT_PAGE: {
                    requestParams = { productCode: pageContext.id };
                    break;
                }
                case exports.PageType.CATEGORY_PAGE: {
                    requestParams = { categoryCode: pageContext.id };
                    break;
                }
                case exports.PageType.CATALOG_PAGE: {
                    requestParams = { catalogCode: pageContext.id };
                    break;
                }
            }
            return requestParams;
        };
        return OccCmsComponentAdapter;
    }());
    OccCmsComponentAdapter.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccCmsComponentAdapter, deps: [{ token: i1__namespace$3.HttpClient }, { token: OccEndpointsService }, { token: ConverterService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    OccCmsComponentAdapter.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccCmsComponentAdapter, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccCmsComponentAdapter, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace$3.HttpClient }, { type: OccEndpointsService }, { type: ConverterService }]; } });

    exports.Occ = void 0;
    (function (Occ) {
        /**
         * The page robot information is exposed with 4 string values.
         */
        var PageRobots;
        (function (PageRobots) {
            PageRobots["INDEX_FOLLOW"] = "INDEX_FOLLOW";
            PageRobots["NOINDEX_FOLLOW"] = "NOINDEX_FOLLOW";
            PageRobots["INDEX_NOFOLLOW"] = "INDEX_NOFOLLOW";
            PageRobots["NOINDEX_NOFOLLOW"] = "NOINDEX_NOFOLLOW";
        })(PageRobots = Occ.PageRobots || (Occ.PageRobots = {}));
        /**
         * Possible order entry statuses
         */
        var OrderEntryStatus;
        (function (OrderEntryStatus) {
            OrderEntryStatus["Success"] = "SUCCESS";
            OrderEntryStatus["Info"] = "INFO";
            OrderEntryStatus["Warning"] = "WARNING";
            OrderEntryStatus["Error"] = "ERROR";
        })(OrderEntryStatus = Occ.OrderEntryStatus || (Occ.OrderEntryStatus = {}));
        /**
         * Defines values for PriceType.
         * Possible values include: 'BUY', 'FROM'
         * There could be more values for this enum apart from the ones defined here.If
         * you want to set a value that is not from the known values then you can do
         * the following:
         * let param: PriceType = <PriceType>"someUnknownValueThatWillStillBeValid";
         * @readonly
         * @enum {string}
         */
        var PriceType;
        (function (PriceType) {
            PriceType["BUY"] = "BUY";
            PriceType["FROM"] = "FROM";
        })(PriceType = Occ.PriceType || (Occ.PriceType = {}));
        /**
         * Defines values for ImageType.
         * Possible values include: 'PRIMARY', 'GALLERY'
         * There could be more values for this enum apart from the ones defined here.If
         * you want to set a value that is not from the known values then you can do
         * the following:
         * let param: ImageType = <ImageType>"someUnknownValueThatWillStillBeValid";
         * @readonly
         * @enum {string}
         */
        var ImageType;
        (function (ImageType) {
            ImageType["PRIMARY"] = "PRIMARY";
            ImageType["GALLERY"] = "GALLERY";
        })(ImageType = Occ.ImageType || (Occ.ImageType = {}));
        /**
         * Defines values for Fields.
         * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
         * There could be more values for this enum apart from the ones defined here.If
         * you want to set a value that is not from the known values then you can do
         * the following:
         * let param: Fields = <Fields>"someUnknownValueThatWillStillBeValid";
         * @readonly
         * @enum {string}
         */
        var Fields;
        (function (Fields) {
            Fields["BASIC"] = "BASIC";
            Fields["DEFAULT"] = "DEFAULT";
            Fields["FULL"] = "FULL";
        })(Fields = Occ.Fields || (Occ.Fields = {}));
        /**
         * Defines values for Fields1.
         * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
         * There could be more values for this enum apart from the ones defined here.If
         * you want to set a value that is not from the known values then you can do
         * the following:
         * let param: Fields1 = <Fields1>"someUnknownValueThatWillStillBeValid";
         * @readonly
         * @enum {string}
         */
        var Fields1;
        (function (Fields1) {
            Fields1["BASIC"] = "BASIC";
            Fields1["DEFAULT"] = "DEFAULT";
            Fields1["FULL"] = "FULL";
        })(Fields1 = Occ.Fields1 || (Occ.Fields1 = {}));
        /**
         * Defines values for Fields2.
         * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
         * There could be more values for this enum apart from the ones defined here.If
         * you want to set a value that is not from the known values then you can do
         * the following:
         * let param: Fields2 = <Fields2>"someUnknownValueThatWillStillBeValid";
         * @readonly
         * @enum {string}
         */
        var Fields2;
        (function (Fields2) {
            Fields2["BASIC"] = "BASIC";
            Fields2["DEFAULT"] = "DEFAULT";
            Fields2["FULL"] = "FULL";
        })(Fields2 = Occ.Fields2 || (Occ.Fields2 = {}));
        /**
         * Defines values for Fields3.
         * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
         * There could be more values for this enum apart from the ones defined here.If
         * you want to set a value that is not from the known values then you can do
         * the following:
         * let param: Fields3 = <Fields3>"someUnknownValueThatWillStillBeValid";
         * @readonly
         * @enum {string}
         */
        var Fields3;
        (function (Fields3) {
            Fields3["BASIC"] = "BASIC";
            Fields3["DEFAULT"] = "DEFAULT";
            Fields3["FULL"] = "FULL";
        })(Fields3 = Occ.Fields3 || (Occ.Fields3 = {}));
        /**
         * Defines values for Fields4.
         * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
         * There could be more values for this enum apart from the ones defined here.If
         * you want to set a value that is not from the known values then you can do
         * the following:
         * let param: Fields4 = <Fields4>"someUnknownValueThatWillStillBeValid";
         * @readonly
         * @enum {string}
         */
        var Fields4;
        (function (Fields4) {
            Fields4["BASIC"] = "BASIC";
            Fields4["DEFAULT"] = "DEFAULT";
            Fields4["FULL"] = "FULL";
        })(Fields4 = Occ.Fields4 || (Occ.Fields4 = {}));
        /**
         * Defines values for Fields5.
         * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
         * There could be more values for this enum apart from the ones defined here.If
         * you want to set a value that is not from the known values then you can do
         * the following:
         * let param: Fields5 = <Fields5>"someUnknownValueThatWillStillBeValid";
         * @readonly
         * @enum {string}
         */
        var Fields5;
        (function (Fields5) {
            Fields5["BASIC"] = "BASIC";
            Fields5["DEFAULT"] = "DEFAULT";
            Fields5["FULL"] = "FULL";
        })(Fields5 = Occ.Fields5 || (Occ.Fields5 = {}));
        /**
         * Defines values for Fields6.
         * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
         * There could be more values for this enum apart from the ones defined here.If
         * you want to set a value that is not from the known values then you can do
         * the following:
         * let param: Fields6 = <Fields6>"someUnknownValueThatWillStillBeValid";
         * @readonly
         * @enum {string}
         */
        var Fields6;
        (function (Fields6) {
            Fields6["BASIC"] = "BASIC";
            Fields6["DEFAULT"] = "DEFAULT";
            Fields6["FULL"] = "FULL";
        })(Fields6 = Occ.Fields6 || (Occ.Fields6 = {}));
        /**
         * Defines values for PageType.
         * Possible values include: 'ContentPage', 'ProductPage', 'CategoryPage',
         * 'CatalogPage'
         * There could be more values for this enum apart from the ones defined here.If
         * you want to set a value that is not from the known values then you can do
         * the following:
         * let param: PageType = <PageType>"someUnknownValueThatWillStillBeValid";
         * @readonly
         * @enum {string}
         */
        var PageType;
        (function (PageType) {
            PageType["CONTENT_PAGE"] = "ContentPage";
            PageType["PRODUCT_PAGE"] = "ProductPage";
            PageType["CATEGORY_PAGE"] = "CategoryPage";
            PageType["CATALOG_PAGE"] = "CatalogPage";
        })(PageType = Occ.PageType || (Occ.PageType = {}));
        /**
         * Defines values for Fields7.
         * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
         * There could be more values for this enum apart from the ones defined here.If
         * you want to set a value that is not from the known values then you can do
         * the following:
         * let param: Fields7 = <Fields7>"someUnknownValueThatWillStillBeValid";
         * @readonly
         * @enum {string}
         */
        var Fields7;
        (function (Fields7) {
            Fields7["BASIC"] = "BASIC";
            Fields7["DEFAULT"] = "DEFAULT";
            Fields7["FULL"] = "FULL";
        })(Fields7 = Occ.Fields7 || (Occ.Fields7 = {}));
        /**
         * Defines values for Fields8.
         * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
         * There could be more values for this enum apart from the ones defined here.If
         * you want to set a value that is not from the known values then you can do
         * the following:
         * let param: Fields8 = <Fields8>"someUnknownValueThatWillStillBeValid";
         * @readonly
         * @enum {string}
         */
        var Fields8;
        (function (Fields8) {
            Fields8["BASIC"] = "BASIC";
            Fields8["DEFAULT"] = "DEFAULT";
            Fields8["FULL"] = "FULL";
        })(Fields8 = Occ.Fields8 || (Occ.Fields8 = {}));
        /**
         * Defines values for Fields9.
         * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
         * There could be more values for this enum apart from the ones defined here.If
         * you want to set a value that is not from the known values then you can do
         * the following:
         * let param: Fields9 = <Fields9>"someUnknownValueThatWillStillBeValid";
         * @readonly
         * @enum {string}
         */
        var Fields9;
        (function (Fields9) {
            Fields9["BASIC"] = "BASIC";
            Fields9["DEFAULT"] = "DEFAULT";
            Fields9["FULL"] = "FULL";
        })(Fields9 = Occ.Fields9 || (Occ.Fields9 = {}));
        /**
         * Defines values for Fields10.
         * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
         * There could be more values for this enum apart from the ones defined here.If
         * you want to set a value that is not from the known values then you can do
         * the following:
         * let param: Fields10 = <Fields10>"someUnknownValueThatWillStillBeValid";
         * @readonly
         * @enum {string}
         */
        var Fields10;
        (function (Fields10) {
            Fields10["BASIC"] = "BASIC";
            Fields10["DEFAULT"] = "DEFAULT";
            Fields10["FULL"] = "FULL";
        })(Fields10 = Occ.Fields10 || (Occ.Fields10 = {}));
        /**
         * Defines values for Fields11.
         * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
         * There could be more values for this enum apart from the ones defined here.If
         * you want to set a value that is not from the known values then you can do
         * the following:
         * let param: Fields11 = <Fields11>"someUnknownValueThatWillStillBeValid";
         * @readonly
         * @enum {string}
         */
        var Fields11;
        (function (Fields11) {
            Fields11["BASIC"] = "BASIC";
            Fields11["DEFAULT"] = "DEFAULT";
            Fields11["FULL"] = "FULL";
        })(Fields11 = Occ.Fields11 || (Occ.Fields11 = {}));
        /**
         * Defines values for Fields12.
         * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
         * There could be more values for this enum apart from the ones defined here.If
         * you want to set a value that is not from the known values then you can do
         * the following:
         * let param: Fields12 = <Fields12>"someUnknownValueThatWillStillBeValid";
         * @readonly
         * @enum {string}
         */
        var Fields12;
        (function (Fields12) {
            Fields12["BASIC"] = "BASIC";
            Fields12["DEFAULT"] = "DEFAULT";
            Fields12["FULL"] = "FULL";
        })(Fields12 = Occ.Fields12 || (Occ.Fields12 = {}));
        /**
         * Defines values for Fields13.
         * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
         * There could be more values for this enum apart from the ones defined here.If
         * you want to set a value that is not from the known values then you can do
         * the following:
         * let param: Fields13 = <Fields13>"someUnknownValueThatWillStillBeValid";
         * @readonly
         * @enum {string}
         */
        var Fields13;
        (function (Fields13) {
            Fields13["BASIC"] = "BASIC";
            Fields13["DEFAULT"] = "DEFAULT";
            Fields13["FULL"] = "FULL";
        })(Fields13 = Occ.Fields13 || (Occ.Fields13 = {}));
        /**
         * Defines values for Fields14.
         * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
         * There could be more values for this enum apart from the ones defined here.If
         * you want to set a value that is not from the known values then you can do
         * the following:
         * let param: Fields14 = <Fields14>"someUnknownValueThatWillStillBeValid";
         * @readonly
         * @enum {string}
         */
        var Fields14;
        (function (Fields14) {
            Fields14["BASIC"] = "BASIC";
            Fields14["DEFAULT"] = "DEFAULT";
            Fields14["FULL"] = "FULL";
        })(Fields14 = Occ.Fields14 || (Occ.Fields14 = {}));
        /**
         * Defines values for Fields15.
         * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
         * There could be more values for this enum apart from the ones defined here.If
         * you want to set a value that is not from the known values then you can do
         * the following:
         * let param: Fields15 = <Fields15>"someUnknownValueThatWillStillBeValid";
         * @readonly
         * @enum {string}
         */
        var Fields15;
        (function (Fields15) {
            Fields15["BASIC"] = "BASIC";
            Fields15["DEFAULT"] = "DEFAULT";
            Fields15["FULL"] = "FULL";
        })(Fields15 = Occ.Fields15 || (Occ.Fields15 = {}));
        /**
         * Defines values for Fields16.
         * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
         * There could be more values for this enum apart from the ones defined here.If
         * you want to set a value that is not from the known values then you can do
         * the following:
         * let param: Fields16 = <Fields16>"someUnknownValueThatWillStillBeValid";
         * @readonly
         * @enum {string}
         */
        var Fields16;
        (function (Fields16) {
            Fields16["BASIC"] = "BASIC";
            Fields16["DEFAULT"] = "DEFAULT";
            Fields16["FULL"] = "FULL";
        })(Fields16 = Occ.Fields16 || (Occ.Fields16 = {}));
        /**
         * Defines values for SortEnum.
         * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
         * There could be more values for this enum apart from the ones defined here.If
         * you want to set a value that is not from the known values then you can do
         * the following:
         * let param: SortEnum = <SortEnum>"someUnknownValueThatWillStillBeValid";
         * @readonly
         * @enum {string}
         */
        var SortEnum;
        (function (SortEnum) {
            SortEnum["BASIC"] = "BASIC";
            SortEnum["DEFAULT"] = "DEFAULT";
            SortEnum["FULL"] = "FULL";
        })(SortEnum = Occ.SortEnum || (Occ.SortEnum = {}));
        /**
         * Defines values for Fields17.
         * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
         * There could be more values for this enum apart from the ones defined here.If
         * you want to set a value that is not from the known values then you can do
         * the following:
         * let param: Fields17 = <Fields17>"someUnknownValueThatWillStillBeValid";
         * @readonly
         * @enum {string}
         */
        var Fields17;
        (function (Fields17) {
            Fields17["BASIC"] = "BASIC";
            Fields17["DEFAULT"] = "DEFAULT";
            Fields17["FULL"] = "FULL";
        })(Fields17 = Occ.Fields17 || (Occ.Fields17 = {}));
        /**
         * Defines values for Fields18.
         * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
         * There could be more values for this enum apart from the ones defined here.If
         * you want to set a value that is not from the known values then you can do
         * the following:
         * let param: Fields18 = <Fields18>"someUnknownValueThatWillStillBeValid";
         * @readonly
         * @enum {string}
         */
        var Fields18;
        (function (Fields18) {
            Fields18["BASIC"] = "BASIC";
            Fields18["DEFAULT"] = "DEFAULT";
            Fields18["FULL"] = "FULL";
        })(Fields18 = Occ.Fields18 || (Occ.Fields18 = {}));
        /**
         * Defines values for Fields19.
         * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
         * There could be more values for this enum apart from the ones defined here.If
         * you want to set a value that is not from the known values then you can do
         * the following:
         * let param: Fields19 = <Fields19>"someUnknownValueThatWillStillBeValid";
         * @readonly
         * @enum {string}
         */
        var Fields19;
        (function (Fields19) {
            Fields19["BASIC"] = "BASIC";
            Fields19["DEFAULT"] = "DEFAULT";
            Fields19["FULL"] = "FULL";
        })(Fields19 = Occ.Fields19 || (Occ.Fields19 = {}));
        /**
         * Defines values for Fields20.
         * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
         * There could be more values for this enum apart from the ones defined here.If
         * you want to set a value that is not from the known values then you can do
         * the following:
         * let param: Fields20 = <Fields20>"someUnknownValueThatWillStillBeValid";
         * @readonly
         * @enum {string}
         */
        var Fields20;
        (function (Fields20) {
            Fields20["BASIC"] = "BASIC";
            Fields20["DEFAULT"] = "DEFAULT";
            Fields20["FULL"] = "FULL";
        })(Fields20 = Occ.Fields20 || (Occ.Fields20 = {}));
        /**
         * Defines values for Fields21.
         * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
         * There could be more values for this enum apart from the ones defined here.If
         * you want to set a value that is not from the known values then you can do
         * the following:
         * let param: Fields21 = <Fields21>"someUnknownValueThatWillStillBeValid";
         * @readonly
         * @enum {string}
         */
        var Fields21;
        (function (Fields21) {
            Fields21["BASIC"] = "BASIC";
            Fields21["DEFAULT"] = "DEFAULT";
            Fields21["FULL"] = "FULL";
        })(Fields21 = Occ.Fields21 || (Occ.Fields21 = {}));
        /**
         * Defines values for Fields22.
         * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
         * There could be more values for this enum apart from the ones defined here.If
         * you want to set a value that is not from the known values then you can do
         * the following:
         * let param: Fields22 = <Fields22>"someUnknownValueThatWillStillBeValid";
         * @readonly
         * @enum {string}
         */
        var Fields22;
        (function (Fields22) {
            Fields22["BASIC"] = "BASIC";
            Fields22["DEFAULT"] = "DEFAULT";
            Fields22["FULL"] = "FULL";
        })(Fields22 = Occ.Fields22 || (Occ.Fields22 = {}));
        /**
         * Defines values for Fields23.
         * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
         * There could be more values for this enum apart from the ones defined here.If
         * you want to set a value that is not from the known values then you can do
         * the following:
         * let param: Fields23 = <Fields23>"someUnknownValueThatWillStillBeValid";
         * @readonly
         * @enum {string}
         */
        var Fields23;
        (function (Fields23) {
            Fields23["BASIC"] = "BASIC";
            Fields23["DEFAULT"] = "DEFAULT";
            Fields23["FULL"] = "FULL";
        })(Fields23 = Occ.Fields23 || (Occ.Fields23 = {}));
        /**
         * Defines values for Fields24.
         * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
         * There could be more values for this enum apart from the ones defined here.If
         * you want to set a value that is not from the known values then you can do
         * the following:
         * let param: Fields24 = <Fields24>"someUnknownValueThatWillStillBeValid";
         * @readonly
         * @enum {string}
         */
        var Fields24;
        (function (Fields24) {
            Fields24["BASIC"] = "BASIC";
            Fields24["DEFAULT"] = "DEFAULT";
            Fields24["FULL"] = "FULL";
        })(Fields24 = Occ.Fields24 || (Occ.Fields24 = {}));
        /**
         * Defines values for Fields25.
         * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
         * There could be more values for this enum apart from the ones defined here.If
         * you want to set a value that is not from the known values then you can do
         * the following:
         * let param: Fields25 = <Fields25>"someUnknownValueThatWillStillBeValid";
         * @readonly
         * @enum {string}
         */
        var Fields25;
        (function (Fields25) {
            Fields25["BASIC"] = "BASIC";
            Fields25["DEFAULT"] = "DEFAULT";
            Fields25["FULL"] = "FULL";
        })(Fields25 = Occ.Fields25 || (Occ.Fields25 = {}));
        /**
         * Defines values for Fields26.
         * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
         * There could be more values for this enum apart from the ones defined here.If
         * you want to set a value that is not from the known values then you can do
         * the following:
         * let param: Fields26 = <Fields26>"someUnknownValueThatWillStillBeValid";
         * @readonly
         * @enum {string}
         */
        var Fields26;
        (function (Fields26) {
            Fields26["BASIC"] = "BASIC";
            Fields26["DEFAULT"] = "DEFAULT";
            Fields26["FULL"] = "FULL";
        })(Fields26 = Occ.Fields26 || (Occ.Fields26 = {}));
        /**
         * Defines values for Fields27.
         * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
         * There could be more values for this enum apart from the ones defined here.If
         * you want to set a value that is not from the known values then you can do
         * the following:
         * let param: Fields27 = <Fields27>"someUnknownValueThatWillStillBeValid";
         * @readonly
         * @enum {string}
         */
        var Fields27;
        (function (Fields27) {
            Fields27["BASIC"] = "BASIC";
            Fields27["DEFAULT"] = "DEFAULT";
            Fields27["FULL"] = "FULL";
        })(Fields27 = Occ.Fields27 || (Occ.Fields27 = {}));
        /**
         * Defines values for Fields28.
         * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
         * There could be more values for this enum apart from the ones defined here.If
         * you want to set a value that is not from the known values then you can do
         * the following:
         * let param: Fields28 = <Fields28>"someUnknownValueThatWillStillBeValid";
         * @readonly
         * @enum {string}
         */
        var Fields28;
        (function (Fields28) {
            Fields28["BASIC"] = "BASIC";
            Fields28["DEFAULT"] = "DEFAULT";
            Fields28["FULL"] = "FULL";
        })(Fields28 = Occ.Fields28 || (Occ.Fields28 = {}));
        /**
         * Defines values for Fields29.
         * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
         * There could be more values for this enum apart from the ones defined here.If
         * you want to set a value that is not from the known values then you can do
         * the following:
         * let param: Fields29 = <Fields29>"someUnknownValueThatWillStillBeValid";
         * @readonly
         * @enum {string}
         */
        var Fields29;
        (function (Fields29) {
            Fields29["BASIC"] = "BASIC";
            Fields29["DEFAULT"] = "DEFAULT";
            Fields29["FULL"] = "FULL";
        })(Fields29 = Occ.Fields29 || (Occ.Fields29 = {}));
        /**
         * Defines values for Fields30.
         * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
         * There could be more values for this enum apart from the ones defined here.If
         * you want to set a value that is not from the known values then you can do
         * the following:
         * let param: Fields30 = <Fields30>"someUnknownValueThatWillStillBeValid";
         * @readonly
         * @enum {string}
         */
        var Fields30;
        (function (Fields30) {
            Fields30["BASIC"] = "BASIC";
            Fields30["DEFAULT"] = "DEFAULT";
            Fields30["FULL"] = "FULL";
        })(Fields30 = Occ.Fields30 || (Occ.Fields30 = {}));
        /**
         * Defines values for Fields31.
         * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
         * There could be more values for this enum apart from the ones defined here.If
         * you want to set a value that is not from the known values then you can do
         * the following:
         * let param: Fields31 = <Fields31>"someUnknownValueThatWillStillBeValid";
         * @readonly
         * @enum {string}
         */
        var Fields31;
        (function (Fields31) {
            Fields31["BASIC"] = "BASIC";
            Fields31["DEFAULT"] = "DEFAULT";
            Fields31["FULL"] = "FULL";
        })(Fields31 = Occ.Fields31 || (Occ.Fields31 = {}));
        /**
         * Defines values for Fields32.
         * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
         * There could be more values for this enum apart from the ones defined here.If
         * you want to set a value that is not from the known values then you can do
         * the following:
         * let param: Fields32 = <Fields32>"someUnknownValueThatWillStillBeValid";
         * @readonly
         * @enum {string}
         */
        var Fields32;
        (function (Fields32) {
            Fields32["BASIC"] = "BASIC";
            Fields32["DEFAULT"] = "DEFAULT";
            Fields32["FULL"] = "FULL";
        })(Fields32 = Occ.Fields32 || (Occ.Fields32 = {}));
        /**
         * Defines values for Fields33.
         * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
         * There could be more values for this enum apart from the ones defined here.If
         * you want to set a value that is not from the known values then you can do
         * the following:
         * let param: Fields33 = <Fields33>"someUnknownValueThatWillStillBeValid";
         * @readonly
         * @enum {string}
         */
        var Fields33;
        (function (Fields33) {
            Fields33["BASIC"] = "BASIC";
            Fields33["DEFAULT"] = "DEFAULT";
            Fields33["FULL"] = "FULL";
        })(Fields33 = Occ.Fields33 || (Occ.Fields33 = {}));
        /**
         * Defines values for Fields34.
         * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
         * There could be more values for this enum apart from the ones defined here.If
         * you want to set a value that is not from the known values then you can do
         * the following:
         * let param: Fields34 = <Fields34>"someUnknownValueThatWillStillBeValid";
         * @readonly
         * @enum {string}
         */
        var Fields34;
        (function (Fields34) {
            Fields34["BASIC"] = "BASIC";
            Fields34["DEFAULT"] = "DEFAULT";
            Fields34["FULL"] = "FULL";
        })(Fields34 = Occ.Fields34 || (Occ.Fields34 = {}));
        /**
         * Defines values for Fields35.
         * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
         * There could be more values for this enum apart from the ones defined here.If
         * you want to set a value that is not from the known values then you can do
         * the following:
         * let param: Fields35 = <Fields35>"someUnknownValueThatWillStillBeValid";
         * @readonly
         * @enum {string}
         */
        var Fields35;
        (function (Fields35) {
            Fields35["BASIC"] = "BASIC";
            Fields35["DEFAULT"] = "DEFAULT";
            Fields35["FULL"] = "FULL";
        })(Fields35 = Occ.Fields35 || (Occ.Fields35 = {}));
        /**
         * Defines values for Fields36.
         * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
         * There could be more values for this enum apart from the ones defined here.If
         * you want to set a value that is not from the known values then you can do
         * the following:
         * let param: Fields36 = <Fields36>"someUnknownValueThatWillStillBeValid";
         * @readonly
         * @enum {string}
         */
        var Fields36;
        (function (Fields36) {
            Fields36["BASIC"] = "BASIC";
            Fields36["DEFAULT"] = "DEFAULT";
            Fields36["FULL"] = "FULL";
        })(Fields36 = Occ.Fields36 || (Occ.Fields36 = {}));
        /**
         * Defines values for Fields37.
         * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
         * There could be more values for this enum apart from the ones defined here.If
         * you want to set a value that is not from the known values then you can do
         * the following:
         * let param: Fields37 = <Fields37>"someUnknownValueThatWillStillBeValid";
         * @readonly
         * @enum {string}
         */
        var Fields37;
        (function (Fields37) {
            Fields37["BASIC"] = "BASIC";
            Fields37["DEFAULT"] = "DEFAULT";
            Fields37["FULL"] = "FULL";
        })(Fields37 = Occ.Fields37 || (Occ.Fields37 = {}));
        /**
         * Defines values for Fields38.
         * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
         * There could be more values for this enum apart from the ones defined here.If
         * you want to set a value that is not from the known values then you can do
         * the following:
         * let param: Fields38 = <Fields38>"someUnknownValueThatWillStillBeValid";
         * @readonly
         * @enum {string}
         */
        var Fields38;
        (function (Fields38) {
            Fields38["BASIC"] = "BASIC";
            Fields38["DEFAULT"] = "DEFAULT";
            Fields38["FULL"] = "FULL";
        })(Fields38 = Occ.Fields38 || (Occ.Fields38 = {}));
        /**
         * Defines values for Fields39.
         * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
         * There could be more values for this enum apart from the ones defined here.If
         * you want to set a value that is not from the known values then you can do
         * the following:
         * let param: Fields39 = <Fields39>"someUnknownValueThatWillStillBeValid";
         * @readonly
         * @enum {string}
         */
        var Fields39;
        (function (Fields39) {
            Fields39["BASIC"] = "BASIC";
            Fields39["DEFAULT"] = "DEFAULT";
            Fields39["FULL"] = "FULL";
        })(Fields39 = Occ.Fields39 || (Occ.Fields39 = {}));
        /**
         * Defines values for Fields40.
         * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
         * There could be more values for this enum apart from the ones defined here.If
         * you want to set a value that is not from the known values then you can do
         * the following:
         * let param: Fields40 = <Fields40>"someUnknownValueThatWillStillBeValid";
         * @readonly
         * @enum {string}
         */
        var Fields40;
        (function (Fields40) {
            Fields40["BASIC"] = "BASIC";
            Fields40["DEFAULT"] = "DEFAULT";
            Fields40["FULL"] = "FULL";
        })(Fields40 = Occ.Fields40 || (Occ.Fields40 = {}));
        /**
         * Defines values for Fields41.
         * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
         * There could be more values for this enum apart from the ones defined here.If
         * you want to set a value that is not from the known values then you can do
         * the following:
         * let param: Fields41 = <Fields41>"someUnknownValueThatWillStillBeValid";
         * @readonly
         * @enum {string}
         */
        var Fields41;
        (function (Fields41) {
            Fields41["BASIC"] = "BASIC";
            Fields41["DEFAULT"] = "DEFAULT";
            Fields41["FULL"] = "FULL";
        })(Fields41 = Occ.Fields41 || (Occ.Fields41 = {}));
        /**
         * Defines values for Fields42.
         * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
         * There could be more values for this enum apart from the ones defined here.If
         * you want to set a value that is not from the known values then you can do
         * the following:
         * let param: Fields42 = <Fields42>"someUnknownValueThatWillStillBeValid";
         * @readonly
         * @enum {string}
         */
        var Fields42;
        (function (Fields42) {
            Fields42["BASIC"] = "BASIC";
            Fields42["DEFAULT"] = "DEFAULT";
            Fields42["FULL"] = "FULL";
        })(Fields42 = Occ.Fields42 || (Occ.Fields42 = {}));
        /**
         * Defines values for Fields43.
         * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
         * There could be more values for this enum apart from the ones defined here.If
         * you want to set a value that is not from the known values then you can do
         * the following:
         * let param: Fields43 = <Fields43>"someUnknownValueThatWillStillBeValid";
         * @readonly
         * @enum {string}
         */
        var Fields43;
        (function (Fields43) {
            Fields43["BASIC"] = "BASIC";
            Fields43["DEFAULT"] = "DEFAULT";
            Fields43["FULL"] = "FULL";
        })(Fields43 = Occ.Fields43 || (Occ.Fields43 = {}));
        /**
         * Defines values for Fields44.
         * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
         * There could be more values for this enum apart from the ones defined here.If
         * you want to set a value that is not from the known values then you can do
         * the following:
         * let param: Fields44 = <Fields44>"someUnknownValueThatWillStillBeValid";
         * @readonly
         * @enum {string}
         */
        var Fields44;
        (function (Fields44) {
            Fields44["BASIC"] = "BASIC";
            Fields44["DEFAULT"] = "DEFAULT";
            Fields44["FULL"] = "FULL";
        })(Fields44 = Occ.Fields44 || (Occ.Fields44 = {}));
        /**
         * Defines values for Fields45.
         * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
         * There could be more values for this enum apart from the ones defined here.If
         * you want to set a value that is not from the known values then you can do
         * the following:
         * let param: Fields45 = <Fields45>"someUnknownValueThatWillStillBeValid";
         * @readonly
         * @enum {string}
         */
        var Fields45;
        (function (Fields45) {
            Fields45["BASIC"] = "BASIC";
            Fields45["DEFAULT"] = "DEFAULT";
            Fields45["FULL"] = "FULL";
        })(Fields45 = Occ.Fields45 || (Occ.Fields45 = {}));
        /**
         * Defines values for Fields46.
         * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
         * There could be more values for this enum apart from the ones defined here.If
         * you want to set a value that is not from the known values then you can do
         * the following:
         * let param: Fields46 = <Fields46>"someUnknownValueThatWillStillBeValid";
         * @readonly
         * @enum {string}
         */
        var Fields46;
        (function (Fields46) {
            Fields46["BASIC"] = "BASIC";
            Fields46["DEFAULT"] = "DEFAULT";
            Fields46["FULL"] = "FULL";
        })(Fields46 = Occ.Fields46 || (Occ.Fields46 = {}));
        /**
         * Defines values for Fields47.
         * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
         * There could be more values for this enum apart from the ones defined here.If
         * you want to set a value that is not from the known values then you can do
         * the following:
         * let param: Fields47 = <Fields47>"someUnknownValueThatWillStillBeValid";
         * @readonly
         * @enum {string}
         */
        var Fields47;
        (function (Fields47) {
            Fields47["BASIC"] = "BASIC";
            Fields47["DEFAULT"] = "DEFAULT";
            Fields47["FULL"] = "FULL";
        })(Fields47 = Occ.Fields47 || (Occ.Fields47 = {}));
        /**
         * Defines values for Fields48.
         * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
         * There could be more values for this enum apart from the ones defined here.If
         * you want to set a value that is not from the known values then you can do
         * the following:
         * let param: Fields48 = <Fields48>"someUnknownValueThatWillStillBeValid";
         * @readonly
         * @enum {string}
         */
        var Fields48;
        (function (Fields48) {
            Fields48["BASIC"] = "BASIC";
            Fields48["DEFAULT"] = "DEFAULT";
            Fields48["FULL"] = "FULL";
        })(Fields48 = Occ.Fields48 || (Occ.Fields48 = {}));
        /**
         * Defines values for Fields49.
         * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
         * There could be more values for this enum apart from the ones defined here.If
         * you want to set a value that is not from the known values then you can do
         * the following:
         * let param: Fields49 = <Fields49>"someUnknownValueThatWillStillBeValid";
         * @readonly
         * @enum {string}
         */
        var Fields49;
        (function (Fields49) {
            Fields49["BASIC"] = "BASIC";
            Fields49["DEFAULT"] = "DEFAULT";
            Fields49["FULL"] = "FULL";
        })(Fields49 = Occ.Fields49 || (Occ.Fields49 = {}));
        /**
         * Defines values for Fields50.
         * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
         * There could be more values for this enum apart from the ones defined here.If
         * you want to set a value that is not from the known values then you can do
         * the following:
         * let param: Fields50 = <Fields50>"someUnknownValueThatWillStillBeValid";
         * @readonly
         * @enum {string}
         */
        var Fields50;
        (function (Fields50) {
            Fields50["BASIC"] = "BASIC";
            Fields50["DEFAULT"] = "DEFAULT";
            Fields50["FULL"] = "FULL";
        })(Fields50 = Occ.Fields50 || (Occ.Fields50 = {}));
        /**
         * Defines values for Fields51.
         * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
         * There could be more values for this enum apart from the ones defined here.If
         * you want to set a value that is not from the known values then you can do
         * the following:
         * let param: Fields51 = <Fields51>"someUnknownValueThatWillStillBeValid";
         * @readonly
         * @enum {string}
         */
        var Fields51;
        (function (Fields51) {
            Fields51["BASIC"] = "BASIC";
            Fields51["DEFAULT"] = "DEFAULT";
            Fields51["FULL"] = "FULL";
        })(Fields51 = Occ.Fields51 || (Occ.Fields51 = {}));
        /**
         * Defines values for Fields52.
         * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
         * There could be more values for this enum apart from the ones defined here.If
         * you want to set a value that is not from the known values then you can do
         * the following:
         * let param: Fields52 = <Fields52>"someUnknownValueThatWillStillBeValid";
         * @readonly
         * @enum {string}
         */
        var Fields52;
        (function (Fields52) {
            Fields52["BASIC"] = "BASIC";
            Fields52["DEFAULT"] = "DEFAULT";
            Fields52["FULL"] = "FULL";
        })(Fields52 = Occ.Fields52 || (Occ.Fields52 = {}));
        /**
         * Defines values for Fields53.
         * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
         * There could be more values for this enum apart from the ones defined here.If
         * you want to set a value that is not from the known values then you can do
         * the following:
         * let param: Fields53 = <Fields53>"someUnknownValueThatWillStillBeValid";
         * @readonly
         * @enum {string}
         */
        var Fields53;
        (function (Fields53) {
            Fields53["BASIC"] = "BASIC";
            Fields53["DEFAULT"] = "DEFAULT";
            Fields53["FULL"] = "FULL";
        })(Fields53 = Occ.Fields53 || (Occ.Fields53 = {}));
        /**
         * Defines values for Fields54.
         * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
         * There could be more values for this enum apart from the ones defined here.If
         * you want to set a value that is not from the known values then you can do
         * the following:
         * let param: Fields54 = <Fields54>"someUnknownValueThatWillStillBeValid";
         * @readonly
         * @enum {string}
         */
        var Fields54;
        (function (Fields54) {
            Fields54["BASIC"] = "BASIC";
            Fields54["DEFAULT"] = "DEFAULT";
            Fields54["FULL"] = "FULL";
        })(Fields54 = Occ.Fields54 || (Occ.Fields54 = {}));
        /**
         * Defines values for Fields55.
         * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
         * There could be more values for this enum apart from the ones defined here.If
         * you want to set a value that is not from the known values then you can do
         * the following:
         * let param: Fields55 = <Fields55>"someUnknownValueThatWillStillBeValid";
         * @readonly
         * @enum {string}
         */
        var Fields55;
        (function (Fields55) {
            Fields55["BASIC"] = "BASIC";
            Fields55["DEFAULT"] = "DEFAULT";
            Fields55["FULL"] = "FULL";
        })(Fields55 = Occ.Fields55 || (Occ.Fields55 = {}));
        /**
         * Defines values for Fields56.
         * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
         * There could be more values for this enum apart from the ones defined here.If
         * you want to set a value that is not from the known values then you can do
         * the following:
         * let param: Fields56 = <Fields56>"someUnknownValueThatWillStillBeValid";
         * @readonly
         * @enum {string}
         */
        var Fields56;
        (function (Fields56) {
            Fields56["BASIC"] = "BASIC";
            Fields56["DEFAULT"] = "DEFAULT";
            Fields56["FULL"] = "FULL";
        })(Fields56 = Occ.Fields56 || (Occ.Fields56 = {}));
        /**
         * Defines values for Fields57.
         * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
         * There could be more values for this enum apart from the ones defined here.If
         * you want to set a value that is not from the known values then you can do
         * the following:
         * let param: Fields57 = <Fields57>"someUnknownValueThatWillStillBeValid";
         * @readonly
         * @enum {string}
         */
        var Fields57;
        (function (Fields57) {
            Fields57["BASIC"] = "BASIC";
            Fields57["DEFAULT"] = "DEFAULT";
            Fields57["FULL"] = "FULL";
        })(Fields57 = Occ.Fields57 || (Occ.Fields57 = {}));
        /**
         * Defines values for Fields58.
         * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
         * There could be more values for this enum apart from the ones defined here.If
         * you want to set a value that is not from the known values then you can do
         * the following:
         * let param: Fields58 = <Fields58>"someUnknownValueThatWillStillBeValid";
         * @readonly
         * @enum {string}
         */
        var Fields58;
        (function (Fields58) {
            Fields58["BASIC"] = "BASIC";
            Fields58["DEFAULT"] = "DEFAULT";
            Fields58["FULL"] = "FULL";
        })(Fields58 = Occ.Fields58 || (Occ.Fields58 = {}));
        /**
         * Defines values for Fields59.
         * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
         * There could be more values for this enum apart from the ones defined here.If
         * you want to set a value that is not from the known values then you can do
         * the following:
         * let param: Fields59 = <Fields59>"someUnknownValueThatWillStillBeValid";
         * @readonly
         * @enum {string}
         */
        var Fields59;
        (function (Fields59) {
            Fields59["BASIC"] = "BASIC";
            Fields59["DEFAULT"] = "DEFAULT";
            Fields59["FULL"] = "FULL";
        })(Fields59 = Occ.Fields59 || (Occ.Fields59 = {}));
        /**
         * Defines values for Fields60.
         * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
         * There could be more values for this enum apart from the ones defined here.If
         * you want to set a value that is not from the known values then you can do
         * the following:
         * let param: Fields60 = <Fields60>"someUnknownValueThatWillStillBeValid";
         * @readonly
         * @enum {string}
         */
        var Fields60;
        (function (Fields60) {
            Fields60["BASIC"] = "BASIC";
            Fields60["DEFAULT"] = "DEFAULT";
            Fields60["FULL"] = "FULL";
        })(Fields60 = Occ.Fields60 || (Occ.Fields60 = {}));
        /**
         * Defines values for Fields61.
         * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
         * There could be more values for this enum apart from the ones defined here.If
         * you want to set a value that is not from the known values then you can do
         * the following:
         * let param: Fields61 = <Fields61>"someUnknownValueThatWillStillBeValid";
         * @readonly
         * @enum {string}
         */
        var Fields61;
        (function (Fields61) {
            Fields61["BASIC"] = "BASIC";
            Fields61["DEFAULT"] = "DEFAULT";
            Fields61["FULL"] = "FULL";
        })(Fields61 = Occ.Fields61 || (Occ.Fields61 = {}));
        /**
         * Defines values for Type.
         * Possible values include: 'all', 'product', 'order'
         * There could be more values for this enum apart from the ones defined here.If
         * you want to set a value that is not from the known values then you can do
         * the following:
         * let param: Type = <Type>"someUnknownValueThatWillStillBeValid";
         * @readonly
         * @enum {string}
         */
        var Type;
        (function (Type) {
            Type["All"] = "all";
            Type["Product"] = "product";
            Type["Order"] = "order";
        })(Type = Occ.Type || (Occ.Type = {}));
        var CONSENT_STATUS;
        (function (CONSENT_STATUS) {
            CONSENT_STATUS["ANONYMOUS_CONSENT_GIVEN"] = "GIVEN";
            CONSENT_STATUS["ANONYMOUS_CONSENT_WITHDRAWN"] = "WITHDRAWN";
        })(CONSENT_STATUS = Occ.CONSENT_STATUS || (Occ.CONSENT_STATUS = {}));
        var NotificationType;
        (function (NotificationType) {
            NotificationType["BACK_IN_STOCK"] = "BACK_IN_STOCK";
        })(NotificationType = Occ.NotificationType || (Occ.NotificationType = {}));
        var Period;
        (function (Period) {
            Period["DAY"] = "DAY";
            Period["WEEK"] = "WEEK";
            Period["MONTH"] = "MONTH";
            Period["QUARTER"] = "QUARTER";
            Period["YEAR"] = "YEAR";
        })(Period = Occ.Period || (Occ.Period = {}));
        var DaysOfWeek;
        (function (DaysOfWeek) {
            DaysOfWeek["MONDAY"] = "MONDAY";
            DaysOfWeek["TUESDAY"] = "TUESDAY";
            DaysOfWeek["WEDNESDAY"] = "WEDNESDAY";
            DaysOfWeek["THURSDAY"] = "THURSDAY";
            DaysOfWeek["FRIDAY"] = "FRIDAY";
            DaysOfWeek["SATURDAY"] = "SATURDAY";
            DaysOfWeek["SUNDAY"] = "SUNDAY";
        })(DaysOfWeek = Occ.DaysOfWeek || (Occ.DaysOfWeek = {}));
        var OrderApprovalDecisionValue;
        (function (OrderApprovalDecisionValue) {
            OrderApprovalDecisionValue["APPROVE"] = "APPROVE";
            OrderApprovalDecisionValue["REJECT"] = "REJECT";
        })(OrderApprovalDecisionValue = Occ.OrderApprovalDecisionValue || (Occ.OrderApprovalDecisionValue = {}));
    })(exports.Occ || (exports.Occ = {}));

    var OccCmsPageNormalizer = /** @class */ (function () {
        function OccCmsPageNormalizer() {
        }
        OccCmsPageNormalizer.prototype.convert = function (source, target) {
            if (target === void 0) { target = {}; }
            this.normalizePageData(source, target);
            this.normalizePageSlotData(source, target);
            this.normalizePageComponentData(source, target);
            this.normalizeComponentData(source, target);
            return target;
        };
        /**
         * Converts the OCC cms page model to the `Page` in the `CmsStructureModel`.
         */
        OccCmsPageNormalizer.prototype.normalizePageData = function (source, target) {
            if (!source) {
                return;
            }
            var page = {};
            if (source.name) {
                page.name = source.name;
            }
            if (source.typeCode) {
                page.type = source.typeCode;
            }
            if (source.label) {
                page.label = source.label;
            }
            if (source.template) {
                page.template = source.template;
            }
            if (source.uid) {
                page.pageId = source.uid;
            }
            if (source.title) {
                page.title = source.title;
            }
            if (source.description) {
                page.description = source.description;
            }
            if (source.properties) {
                page.properties = source.properties;
            }
            this.normalizeRobots(source, page);
            target.page = page;
        };
        /**
         * Adds a ContentSlotData for each page slot in the `CmsStructureModel`.
         */
        OccCmsPageNormalizer.prototype.normalizePageSlotData = function (source, target) {
            var e_1, _c;
            if (!(source === null || source === void 0 ? void 0 : source.contentSlots)) {
                return;
            }
            if (!Array.isArray(source.contentSlots.contentSlot)) {
                source.contentSlots.contentSlot = [source.contentSlots.contentSlot];
            }
            target.page.slots = {};
            try {
                for (var _d = __values(source.contentSlots.contentSlot), _e = _d.next(); !_e.done; _e = _d.next()) {
                    var slot = _e.value;
                    target.page.slots[slot.position] = {};
                    if (slot.properties) {
                        target.page.slots[slot.position].properties = slot.properties;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_e && !_e.done && (_c = _d.return)) _c.call(_d);
                }
                finally { if (e_1) throw e_1.error; }
            }
        };
        /**
         * Registers the `ContentSlotComponentData` for each component.
         */
        OccCmsPageNormalizer.prototype.normalizePageComponentData = function (source, target) {
            var e_2, _c, e_3, _d;
            var _a, _b;
            if (!((_a = source === null || source === void 0 ? void 0 : source.contentSlots) === null || _a === void 0 ? void 0 : _a.contentSlot)) {
                return;
            }
            try {
                for (var _e = __values(source.contentSlots.contentSlot), _f = _e.next(); !_f.done; _f = _e.next()) {
                    var slot = _f.value;
                    if (Array.isArray((_b = slot.components) === null || _b === void 0 ? void 0 : _b.component)) {
                        try {
                            for (var _g = (e_3 = void 0, __values(slot.components.component)), _h = _g.next(); !_h.done; _h = _g.next()) {
                                var component = _h.value;
                                var comp = {
                                    uid: component.uid,
                                    typeCode: component.typeCode,
                                };
                                if (component.properties) {
                                    comp.properties = component.properties;
                                }
                                if (component.typeCode === CMS_FLEX_COMPONENT_TYPE) {
                                    comp.flexType = component.flexType;
                                }
                                else if (component.typeCode === JSP_INCLUDE_CMS_COMPONENT_TYPE) {
                                    comp.flexType = component.uid;
                                }
                                else {
                                    comp.flexType = component.typeCode;
                                }
                                if (!target.page.slots[slot.position].components) {
                                    target.page.slots[slot.position].components = [];
                                }
                                target.page.slots[slot.position].components.push(comp);
                            }
                        }
                        catch (e_3_1) { e_3 = { error: e_3_1 }; }
                        finally {
                            try {
                                if (_h && !_h.done && (_d = _g.return)) _d.call(_g);
                            }
                            finally { if (e_3) throw e_3.error; }
                        }
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_f && !_f.done && (_c = _e.return)) _c.call(_e);
                }
                finally { if (e_2) throw e_2.error; }
            }
        };
        /**
         * Adds the actual component data whenever available in the CMS page data.
         *
         * If the data is not populated in this payload, it is loaded separately
         * (`OccCmsComponentAdapter`).
         */
        OccCmsPageNormalizer.prototype.normalizeComponentData = function (source, target) {
            var e_4, _c, e_5, _d;
            var _a, _b;
            if (!((_a = source === null || source === void 0 ? void 0 : source.contentSlots) === null || _a === void 0 ? void 0 : _a.contentSlot)) {
                return;
            }
            try {
                for (var _e = __values(source.contentSlots.contentSlot), _f = _e.next(); !_f.done; _f = _e.next()) {
                    var slot = _f.value;
                    if (Array.isArray((_b = slot.components) === null || _b === void 0 ? void 0 : _b.component)) {
                        try {
                            for (var _g = (e_5 = void 0, __values(slot.components.component)), _h = _g.next(); !_h.done; _h = _g.next()) {
                                var component = _h.value;
                                // while we're hoping to get this right from the backend api,
                                // the OCC api stills seems out of sync with the right model.
                                if (component.modifiedtime) {
                                    component.modifiedTime = component.modifiedtime;
                                    delete component.modifiedtime;
                                }
                                // we don't put properties into component state
                                if (component.properties) {
                                    component.properties = undefined;
                                }
                                if (!target.components) {
                                    target.components = [];
                                }
                                target.components.push(component);
                            }
                        }
                        catch (e_5_1) { e_5 = { error: e_5_1 }; }
                        finally {
                            try {
                                if (_h && !_h.done && (_d = _g.return)) _d.call(_g);
                            }
                            finally { if (e_5) throw e_5.error; }
                        }
                    }
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_f && !_f.done && (_c = _e.return)) _c.call(_e);
                }
                finally { if (e_4) throw e_4.error; }
            }
        };
        /**
         * Normalizes the page robot string to an array of `PageRobotsMeta` items.
         */
        OccCmsPageNormalizer.prototype.normalizeRobots = function (source, target) {
            var robots = [];
            if (source.robotTag) {
                switch (source.robotTag) {
                    case exports.Occ.PageRobots.INDEX_FOLLOW:
                        robots.push(exports.PageRobotsMeta.INDEX);
                        robots.push(exports.PageRobotsMeta.FOLLOW);
                        break;
                    case exports.Occ.PageRobots.NOINDEX_FOLLOW:
                        robots.push(exports.PageRobotsMeta.NOINDEX);
                        robots.push(exports.PageRobotsMeta.FOLLOW);
                        break;
                    case exports.Occ.PageRobots.INDEX_NOFOLLOW:
                        robots.push(exports.PageRobotsMeta.INDEX);
                        robots.push(exports.PageRobotsMeta.NOFOLLOW);
                        break;
                    case exports.Occ.PageRobots.NOINDEX_NOFOLLOW:
                        robots.push(exports.PageRobotsMeta.NOINDEX);
                        robots.push(exports.PageRobotsMeta.NOFOLLOW);
                        break;
                }
            }
            target.robots = robots;
        };
        return OccCmsPageNormalizer;
    }());
    OccCmsPageNormalizer.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccCmsPageNormalizer, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    OccCmsPageNormalizer.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccCmsPageNormalizer, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccCmsPageNormalizer, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }] });

    var OccCmsPageAdapter = /** @class */ (function () {
        function OccCmsPageAdapter(http, occEndpoints, converter) {
            this.http = http;
            this.occEndpoints = occEndpoints;
            this.converter = converter;
            this.headers = new i1$3.HttpHeaders().set('Content-Type', 'application/json');
        }
        /**
         * @override returns the OCC CMS page data for the given context and converts
         * the data by any configured `CMS_PAGE_NORMALIZER`.
         */
        OccCmsPageAdapter.prototype.load = function (pageContext) {
            var params = this.getPagesRequestParams(pageContext);
            var endpoint = !pageContext.type
                ? this.occEndpoints.buildUrl('page', {
                    urlParams: { id: pageContext.id },
                })
                : this.occEndpoints.buildUrl('pages', { queryParams: params });
            return this.http
                .get(endpoint, { headers: this.headers })
                .pipe(this.converter.pipeable(CMS_PAGE_NORMALIZER));
        };
        /**
         * The OCC CMS API allows to query pages by a combination of pageType, label and code.
         *
         * When a `ContentPage` is requested, we use the `pageLabelOrId`:
         *
         * ```
         * "/pages?pageLabelOrId=/my-page&pageType=ContentPage"
         * ```
         *
         * Other pages are queried by code:
         *
         * ```
         * "/pages?code=1234&pageType=ProductPage"
         * ```
         *
         * The page context is ignored for a home page request or in case of a
         * `smartedit-preview` request.
         */
        OccCmsPageAdapter.prototype.getPagesRequestParams = function (context) {
            if (context.id === HOME_PAGE_CONTEXT || context.id === SMART_EDIT_CONTEXT) {
                return {};
            }
            var httpParams = {};
            if (context.type) {
                httpParams.pageType = context.type;
            }
            if (context.type === exports.PageType.CONTENT_PAGE) {
                httpParams.pageLabelOrId = context.id;
            }
            else {
                httpParams.code = context.id;
            }
            return httpParams;
        };
        return OccCmsPageAdapter;
    }());
    OccCmsPageAdapter.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccCmsPageAdapter, deps: [{ token: i1__namespace$3.HttpClient }, { token: OccEndpointsService }, { token: ConverterService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    OccCmsPageAdapter.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccCmsPageAdapter, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccCmsPageAdapter, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace$3.HttpClient }, { type: OccEndpointsService }, { type: ConverterService }]; } });

    var CmsOccModule = /** @class */ (function () {
        function CmsOccModule() {
        }
        return CmsOccModule;
    }());
    CmsOccModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CmsOccModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    CmsOccModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CmsOccModule, imports: [i6.CommonModule] });
    CmsOccModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CmsOccModule, providers: [
            {
                provide: CmsPageAdapter,
                useClass: OccCmsPageAdapter,
            },
            {
                provide: CMS_PAGE_NORMALIZER,
                useExisting: OccCmsPageNormalizer,
                multi: true,
            },
            {
                provide: CmsComponentAdapter,
                useClass: OccCmsComponentAdapter,
            },
        ], imports: [[i6.CommonModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CmsOccModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [i6.CommonModule],
                        providers: [
                            {
                                provide: CmsPageAdapter,
                                useClass: OccCmsPageAdapter,
                            },
                            {
                                provide: CMS_PAGE_NORMALIZER,
                                useExisting: OccCmsPageNormalizer,
                                multi: true,
                            },
                            {
                                provide: CmsComponentAdapter,
                                useClass: OccCmsComponentAdapter,
                            },
                        ],
                    }]
            }] });

    /**
     * Before 1905, the OCC CMS component API required was using POST method
     * to load a (potentially large) number of components. With 1905, the endpoint
     * evaluated to use GET. Switching from POST to GET has been initially implemented
     * with the `legacy` flag, but from version 3.0 onwards, we're moving the
     * implementation to this optional Adapter.
     *
     * If you like to connect to a pre 1905 version, you can provide this adapter for the
     * `CmsComponentAdapter` injection token.
     */
    var LegacyOccCmsComponentAdapter = /** @class */ (function (_super) {
        __extends(LegacyOccCmsComponentAdapter, _super);
        function LegacyOccCmsComponentAdapter() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        LegacyOccCmsComponentAdapter.prototype.findComponentsByIds = function (ids, pageContext, fields, currentPage, pageSize, sort) {
            if (fields === void 0) { fields = 'DEFAULT'; }
            if (currentPage === void 0) { currentPage = 0; }
            if (pageSize === void 0) { pageSize = ids.length; }
            var idList = { idList: ids };
            var requestParams = Object.assign(Object.assign({}, this.getContextParams(pageContext)), this.getPaginationParams(currentPage, pageSize, sort));
            return this.http
                .post(this.getComponentsEndpoint(requestParams, fields), idList, {
                headers: this.headers,
            })
                .pipe(operators.pluck('component'), this.converter.pipeableMany(CMS_COMPONENT_NORMALIZER));
        };
        return LegacyOccCmsComponentAdapter;
    }(OccCmsComponentAdapter));
    LegacyOccCmsComponentAdapter.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: LegacyOccCmsComponentAdapter, deps: null, target: i0__namespace.ɵɵFactoryTarget.Injectable });
    LegacyOccCmsComponentAdapter.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: LegacyOccCmsComponentAdapter, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: LegacyOccCmsComponentAdapter, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }] });

    var OccCostCenterNormalizer = /** @class */ (function () {
        function OccCostCenterNormalizer() {
        }
        OccCostCenterNormalizer.prototype.convert = function (source, target) {
            if (target === undefined) {
                target = Object.assign({}, source);
            }
            target.active = this.normalizeBoolean(source.active);
            return target;
        };
        /**
         * Returns the boolean value for a string property that is supposed
         * to be of type boolean.
         */
        OccCostCenterNormalizer.prototype.normalizeBoolean = function (property) {
            return typeof property === 'string' ? property === 'true' : property;
        };
        return OccCostCenterNormalizer;
    }());
    OccCostCenterNormalizer.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccCostCenterNormalizer, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    OccCostCenterNormalizer.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccCostCenterNormalizer, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccCostCenterNormalizer, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }] });

    var OccCostCenterSerializer = /** @class */ (function () {
        function OccCostCenterSerializer() {
        }
        OccCostCenterSerializer.prototype.convert = function (source, target) {
            if (target === undefined) {
                target = Object.assign({}, source);
            }
            target.activeFlag = source.active;
            delete target.active;
            return target;
        };
        return OccCostCenterSerializer;
    }());
    OccCostCenterSerializer.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccCostCenterSerializer, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    OccCostCenterSerializer.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccCostCenterSerializer, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccCostCenterSerializer, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }] });

    var OccCostCenterListNormalizer = /** @class */ (function () {
        function OccCostCenterListNormalizer(converter) {
            this.converter = converter;
        }
        OccCostCenterListNormalizer.prototype.convert = function (source, target) {
            var _this = this;
            if (target === undefined) {
                target = Object.assign({}, source);
            }
            target.values = source.costCenters.map(function (costCenter) { return (Object.assign({}, _this.converter.convert(costCenter, COST_CENTER_NORMALIZER))); });
            return target;
        };
        return OccCostCenterListNormalizer;
    }());
    OccCostCenterListNormalizer.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccCostCenterListNormalizer, deps: [{ token: ConverterService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    OccCostCenterListNormalizer.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccCostCenterListNormalizer, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccCostCenterListNormalizer, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: ConverterService }]; } });

    var defaultOccCostCentersConfig = {
        backend: {
            occ: {
                endpoints: {
                    getActiveCostCenters: '/costcenters?fields=DEFAULT,unit(BASIC,addresses(DEFAULT))',
                },
            },
        },
    };

    var CostCenterOccModule = /** @class */ (function () {
        function CostCenterOccModule() {
        }
        return CostCenterOccModule;
    }());
    CostCenterOccModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CostCenterOccModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    CostCenterOccModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CostCenterOccModule, imports: [i6.CommonModule, ConfigModule] });
    CostCenterOccModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CostCenterOccModule, providers: [
            {
                provide: COST_CENTERS_NORMALIZER,
                useExisting: OccCostCenterListNormalizer,
                multi: true,
            },
            {
                provide: COST_CENTER_NORMALIZER,
                useExisting: OccCostCenterNormalizer,
                multi: true,
            },
            {
                provide: COST_CENTER_SERIALIZER,
                useExisting: OccCostCenterSerializer,
                multi: true,
            },
        ], imports: [[i6.CommonModule, ConfigModule.withConfig(defaultOccCostCentersConfig)]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CostCenterOccModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [i6.CommonModule, ConfigModule.withConfig(defaultOccCostCentersConfig)],
                        providers: [
                            {
                                provide: COST_CENTERS_NORMALIZER,
                                useExisting: OccCostCenterListNormalizer,
                                multi: true,
                            },
                            {
                                provide: COST_CENTER_NORMALIZER,
                                useExisting: OccCostCenterNormalizer,
                                multi: true,
                            },
                            {
                                provide: COST_CENTER_SERIALIZER,
                                useExisting: OccCostCenterSerializer,
                                multi: true,
                            },
                        ],
                    }]
            }] });

    var OccOrderNormalizer = /** @class */ (function () {
        function OccOrderNormalizer(converter, entryPromotionService) {
            this.converter = converter;
            this.entryPromotionService = entryPromotionService;
        }
        OccOrderNormalizer.prototype.convert = function (source, target) {
            var _this = this;
            if (target === undefined) {
                target = Object.assign({}, source);
            }
            if (source.entries) {
                target.entries = source.entries.map(function (entry) { return _this.convertOrderEntry(entry, source.code, source.appliedProductPromotions); });
            }
            if (source.consignments) {
                target.consignments = source.consignments.map(function (consignment) {
                    var _a;
                    return (Object.assign(Object.assign({}, consignment), { entries: (_a = consignment.entries) === null || _a === void 0 ? void 0 : _a.map(function (entry) { return (Object.assign(Object.assign({}, entry), { orderEntry: _this.convertOrderEntry(entry.orderEntry, source.code, source.appliedProductPromotions) })); }) }));
                });
            }
            if (source.unconsignedEntries) {
                target.unconsignedEntries = source.unconsignedEntries.map(function (entry) { return _this.convertOrderEntry(entry, source.code, source.appliedProductPromotions); });
            }
            return target;
        };
        OccOrderNormalizer.prototype.convertOrderEntry = function (source, code, promotions) {
            return Object.assign(Object.assign({}, source), { product: this.converter.convert(source === null || source === void 0 ? void 0 : source.product, PRODUCT_NORMALIZER), orderCode: code, promotions: this.entryPromotionService
                    ? this.entryPromotionService.getProductPromotion(source, promotions)
                    : [] });
        };
        return OccOrderNormalizer;
    }());
    OccOrderNormalizer.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccOrderNormalizer, deps: [{ token: ConverterService }, { token: OrderEntryPromotionsService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    OccOrderNormalizer.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccOrderNormalizer, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccOrderNormalizer, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }], ctorParameters: function () { return [{ type: ConverterService }, { type: OrderEntryPromotionsService }]; } });

    var OccReplenishmentOrderNormalizer = /** @class */ (function () {
        function OccReplenishmentOrderNormalizer(converter, entryPromotionService) {
            this.converter = converter;
            this.entryPromotionService = entryPromotionService;
        }
        OccReplenishmentOrderNormalizer.prototype.convert = function (source, target) {
            var _this = this;
            if (target === undefined) {
                target = Object.assign({}, source);
            }
            if (source.entries) {
                target.entries = source.entries.map(function (entry) { return (Object.assign(Object.assign({}, entry), { product: _this.converter.convert(entry.product, PRODUCT_NORMALIZER), promotions: _this.entryPromotionService
                        ? _this.entryPromotionService.getProductPromotion(entry, source.appliedProductPromotions)
                        : [] })); });
            }
            return target;
        };
        return OccReplenishmentOrderNormalizer;
    }());
    OccReplenishmentOrderNormalizer.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccReplenishmentOrderNormalizer, deps: [{ token: ConverterService }, { token: OrderEntryPromotionsService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    OccReplenishmentOrderNormalizer.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccReplenishmentOrderNormalizer, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccReplenishmentOrderNormalizer, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }], ctorParameters: function () { return [{ type: ConverterService }, { type: OrderEntryPromotionsService }]; } });

    var OrderOccModule = /** @class */ (function () {
        function OrderOccModule() {
        }
        return OrderOccModule;
    }());
    OrderOccModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OrderOccModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    OrderOccModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OrderOccModule, imports: [i6.CommonModule] });
    OrderOccModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OrderOccModule, providers: [
            {
                provide: ORDER_NORMALIZER,
                useExisting: OccOrderNormalizer,
                multi: true,
            },
            {
                provide: REPLENISHMENT_ORDER_NORMALIZER,
                useExisting: OccReplenishmentOrderNormalizer,
                multi: true,
            },
        ], imports: [[i6.CommonModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OrderOccModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [i6.CommonModule],
                        providers: [
                            {
                                provide: ORDER_NORMALIZER,
                                useExisting: OccOrderNormalizer,
                                multi: true,
                            },
                            {
                                provide: REPLENISHMENT_ORDER_NORMALIZER,
                                useExisting: OccReplenishmentOrderNormalizer,
                                multi: true,
                            },
                        ],
                    }]
            }] });

    var ProductImageNormalizer = /** @class */ (function () {
        function ProductImageNormalizer(config) {
            this.config = config;
        }
        ProductImageNormalizer.prototype.convert = function (source, target) {
            if (target === undefined) {
                target = Object.assign({}, source);
            }
            if (source.images) {
                target.images = this.normalize(source.images);
            }
            return target;
        };
        /**
         * @desc
         * Creates the image structure we'd like to have. Instead of
         * having a single list with all images despite type and format
         * we create a proper structure. With that we can do:
         * - images.primary.thumnail.url
         * - images.GALLERY[0].thumnail.url
         */
        ProductImageNormalizer.prototype.normalize = function (source) {
            var e_1, _a;
            var images = {};
            if (source) {
                try {
                    for (var source_1 = __values(source), source_1_1 = source_1.next(); !source_1_1.done; source_1_1 = source_1.next()) {
                        var image = source_1_1.value;
                        var isList = image.hasOwnProperty('galleryIndex');
                        if (!images.hasOwnProperty(image.imageType)) {
                            images[image.imageType] = isList ? [] : {};
                        }
                        var imageContainer = void 0;
                        if (isList && !images[image.imageType][image.galleryIndex]) {
                            images[image.imageType][image.galleryIndex] = {};
                        }
                        if (isList) {
                            imageContainer = images[image.imageType][image.galleryIndex];
                        }
                        else {
                            imageContainer = images[image.imageType];
                        }
                        var targetImage = Object.assign({}, image);
                        targetImage.url = this.normalizeImageUrl(targetImage.url);
                        imageContainer[image.format] = targetImage;
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (source_1_1 && !source_1_1.done && (_a = source_1.return)) _a.call(source_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
            return images;
        };
        /**
         * Traditionally, in an on-prem world, medias and other backend related calls
         * are hosted at the same platform, but in a cloud setup, applications are are
         * typically distributed cross different environments. For media, we use the
         * `backend.media.baseUrl` by default, but fallback to `backend.occ.baseUrl`
         * if none provided.
         */
        ProductImageNormalizer.prototype.normalizeImageUrl = function (url) {
            if (new RegExp(/^(http|data:image|\/\/)/i).test(url)) {
                return url;
            }
            return ((this.config.backend.media.baseUrl ||
                this.config.backend.occ.baseUrl ||
                '') + url);
        };
        return ProductImageNormalizer;
    }());
    ProductImageNormalizer.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductImageNormalizer, deps: [{ token: OccConfig }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ProductImageNormalizer.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductImageNormalizer, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductImageNormalizer, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }], ctorParameters: function () { return [{ type: OccConfig }]; } });

    var ProductReferenceNormalizer = /** @class */ (function () {
        function ProductReferenceNormalizer() {
        }
        ProductReferenceNormalizer.prototype.convert = function (source, target) {
            if (target === undefined) {
                target = Object.assign({}, source);
            }
            if (source.productReferences) {
                target.productReferences = this.normalize(source.productReferences);
            }
            return target;
        };
        /**
         * @desc
         * Creates the reference structure we'd like to have. Instead of
         * having a single list with all references we create a proper structure.
         * With that we have a semantic API for the clients
         * - product.references.SIMILAR[0].code
         */
        ProductReferenceNormalizer.prototype.normalize = function (source) {
            var e_1, _a;
            var references = {};
            if (source) {
                try {
                    for (var source_1 = __values(source), source_1_1 = source_1.next(); !source_1_1.done; source_1_1 = source_1.next()) {
                        var reference = source_1_1.value;
                        if (!references.hasOwnProperty(reference.referenceType)) {
                            references[reference.referenceType] = [];
                        }
                        references[reference.referenceType].push(reference);
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (source_1_1 && !source_1_1.done && (_a = source_1.return)) _a.call(source_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
            return references;
        };
        return ProductReferenceNormalizer;
    }());
    ProductReferenceNormalizer.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductReferenceNormalizer, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ProductReferenceNormalizer.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductReferenceNormalizer });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductReferenceNormalizer, decorators: [{
                type: i0.Injectable
            }] });

    var OccProductSearchPageNormalizer = /** @class */ (function () {
        function OccProductSearchPageNormalizer(converterService) {
            this.converterService = converterService;
            /**
             * Specifies the minimal number of top values in case
             * non have been setup by the business.
             */
            this.DEFAULT_TOP_VALUES = 6;
        }
        OccProductSearchPageNormalizer.prototype.convert = function (source, target) {
            var _this = this;
            if (target === void 0) { target = {}; }
            target = Object.assign(Object.assign({}, target), source);
            this.normalizeFacets(target);
            if (source.products) {
                target.products = source.products.map(function (product) { return _this.converterService.convert(product, PRODUCT_NORMALIZER); });
            }
            return target;
        };
        OccProductSearchPageNormalizer.prototype.normalizeFacets = function (target) {
            this.normalizeFacetValues(target);
            this.normalizeUselessFacets(target);
        };
        /**
         * The (current) backend returns facets with values that do not contribute
         * to the facet navigation much, as the number in the result list will not get
         * behavior, see https://jira.hybris.com/browse/CS-427.
         *
         * As long as this is not in place, we manually filter the facet from the list;
         * any facet that does not have a count < the total results will be dropped from
         * the facets.
         */
        OccProductSearchPageNormalizer.prototype.normalizeUselessFacets = function (target) {
            if (target.facets) {
                target.facets = target.facets.filter(function (facet) {
                    return (!target.pagination ||
                        !target.pagination.totalResults ||
                        ((!facet.hasOwnProperty('visible') || facet.visible) &&
                            facet.values &&
                            facet.values.find(function (value) {
                                return (value.selected || value.count < target.pagination.totalResults);
                            })));
                });
            }
        };
        /*
         * In case there are so-called `topValues` given for the facet values,
         * values are obsolete.
         *
         * `topValues` is a feature in Adaptive Search which can limit a large
         * amount of facet values to a small set (5 by default). As long as the backend
         * provides all facet values AND topValues, we normalize the data to not bother
         * the UI with this specific feature.
         */
        OccProductSearchPageNormalizer.prototype.normalizeFacetValues = function (target) {
            var _this = this;
            if (target.facets) {
                target.facets = target.facets.map(function (facetSource) {
                    var topValues = facetSource.topValues, facetTarget = __rest(facetSource, ["topValues"]);
                    facetTarget.topValueCount =
                        (topValues === null || topValues === void 0 ? void 0 : topValues.length) > 0 ? topValues.length : _this.DEFAULT_TOP_VALUES;
                    return facetTarget;
                });
            }
        };
        return OccProductSearchPageNormalizer;
    }());
    OccProductSearchPageNormalizer.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccProductSearchPageNormalizer, deps: [{ token: ConverterService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    OccProductSearchPageNormalizer.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccProductSearchPageNormalizer, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccProductSearchPageNormalizer, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }], ctorParameters: function () { return [{ type: ConverterService }]; } });

    var OccProductReferencesListNormalizer = /** @class */ (function () {
        function OccProductReferencesListNormalizer(converter) {
            this.converter = converter;
        }
        OccProductReferencesListNormalizer.prototype.convert = function (source, target) {
            var _this = this;
            if (target === void 0) { target = []; }
            if (target === undefined) {
                target = Object.assign({}, source);
            }
            if (source && source.references) {
                target = source.references.map(function (reference) { return (Object.assign(Object.assign({}, reference), { target: _this.converter.convert(reference.target, PRODUCT_NORMALIZER) })); });
                return target;
            }
        };
        return OccProductReferencesListNormalizer;
    }());
    OccProductReferencesListNormalizer.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccProductReferencesListNormalizer, deps: [{ token: ConverterService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    OccProductReferencesListNormalizer.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccProductReferencesListNormalizer, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccProductReferencesListNormalizer, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }], ctorParameters: function () { return [{ type: ConverterService }]; } });

    var ProductNameNormalizer = /** @class */ (function () {
        function ProductNameNormalizer(config) {
            this.config = config;
            /**
             * A pretty url should not have any encoded characters, which is why we replace
             * the following character in the product title.
             *
             * See https://developers.google.com/maps/documentation/urls/url-encoding for more
             * information on the characters.
             */
            this.reservedSlugCharacters = " !*'();:@&=+$,/?%#[]";
            this.slugChar = '-';
            // created the regex only once
            this.slugRegex = new RegExp("[" + this.reservedSlugCharacters.split('').join('\\') + "]", 'g');
            this.sanitizeMultipleSlugChars = new RegExp(this.slugChar + "+", 'g');
        }
        ProductNameNormalizer.prototype.convert = function (source, target) {
            target = target !== null && target !== void 0 ? target : Object.assign({}, source);
            if (source.name) {
                target.name = this.normalize(source.name);
                target.slug = this.normalizeSlug(source.name);
                target.nameHtml = source.name;
            }
            return target;
        };
        /**
         * Sanitizes the name so that the name doesn't contain html elements.
         */
        ProductNameNormalizer.prototype.normalize = function (name) {
            return name.replace(/<[^>]*>/g, '');
        };
        /**
         * Provides a title slug for the pretty URL.
         *
         * The name is sanitized from html, trimmed, converted to lowercase and special characters
         * which are encoded are replaced by the slug char (dash by default).
         */
        ProductNameNormalizer.prototype.normalizeSlug = function (name) {
            return this.normalize(name)
                .trim()
                .toLowerCase()
                .replace(this.slugRegex, this.slugChar)
                .replace(this.sanitizeMultipleSlugChars, this.slugChar);
        };
        return ProductNameNormalizer;
    }());
    ProductNameNormalizer.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductNameNormalizer, deps: [{ token: OccConfig }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ProductNameNormalizer.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductNameNormalizer, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductNameNormalizer, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }], ctorParameters: function () { return [{ type: OccConfig }]; } });

    var PRODUCT_REFERENCES_NORMALIZER = new i0.InjectionToken('ProductReferencesListNormalizer');

    var OccProductReferencesAdapter = /** @class */ (function () {
        function OccProductReferencesAdapter(http, occEndpoints, converter) {
            this.http = http;
            this.occEndpoints = occEndpoints;
            this.converter = converter;
        }
        OccProductReferencesAdapter.prototype.load = function (productCode, referenceType, pageSize) {
            return this.http
                .get(this.getEndpoint(productCode, referenceType, pageSize))
                .pipe(this.converter.pipeable(PRODUCT_REFERENCES_NORMALIZER));
        };
        OccProductReferencesAdapter.prototype.getEndpoint = function (code, reference, pageSize) {
            return this.occEndpoints.buildUrl('productReferences', {
                urlParams: { productCode: code },
                queryParams: { referenceType: reference, pageSize: pageSize },
            });
        };
        return OccProductReferencesAdapter;
    }());
    OccProductReferencesAdapter.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccProductReferencesAdapter, deps: [{ token: i1__namespace$3.HttpClient }, { token: OccEndpointsService }, { token: ConverterService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    OccProductReferencesAdapter.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccProductReferencesAdapter });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccProductReferencesAdapter, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: i1__namespace$3.HttpClient }, { type: OccEndpointsService }, { type: ConverterService }]; } });

    var PRODUCT_REVIEW_NORMALIZER = new i0.InjectionToken('ProductReviewNormalizer');
    var PRODUCT_REVIEW_SERIALIZER = new i0.InjectionToken('ProductReviewSerializer');

    var OccProductReviewsAdapter = /** @class */ (function () {
        function OccProductReviewsAdapter(http, occEndpoints, converter) {
            this.http = http;
            this.occEndpoints = occEndpoints;
            this.converter = converter;
        }
        OccProductReviewsAdapter.prototype.load = function (productCode, maxCount) {
            return this.http
                .get(this.getEndpoint(productCode, maxCount))
                .pipe(operators.pluck('reviews'), this.converter.pipeableMany(PRODUCT_REVIEW_NORMALIZER));
        };
        OccProductReviewsAdapter.prototype.post = function (productCode, review) {
            review = this.converter.convert(review, PRODUCT_REVIEW_SERIALIZER);
            var headers = new i1$3.HttpHeaders({
                'Content-Type': 'application/x-www-form-urlencoded',
            });
            var body = new URLSearchParams();
            body.append('headline', review.headline);
            body.append('comment', review.comment);
            body.append('rating', review.rating.toString());
            body.append('alias', review.alias);
            return this.http.post(this.getEndpoint(productCode), body.toString(), {
                headers: headers,
            });
        };
        OccProductReviewsAdapter.prototype.getEndpoint = function (code, maxCount) {
            return this.occEndpoints.buildUrl('productReviews', {
                urlParams: { productCode: code },
                queryParams: { maxCount: maxCount },
            });
        };
        return OccProductReviewsAdapter;
    }());
    OccProductReviewsAdapter.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccProductReviewsAdapter, deps: [{ token: i1__namespace$3.HttpClient }, { token: OccEndpointsService }, { token: ConverterService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    OccProductReviewsAdapter.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccProductReviewsAdapter });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccProductReviewsAdapter, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: i1__namespace$3.HttpClient }, { type: OccEndpointsService }, { type: ConverterService }]; } });

    var PRODUCT_SEARCH_PAGE_NORMALIZER = new i0.InjectionToken('ProductSearchPageNormalizer');
    var PRODUCT_SUGGESTION_NORMALIZER = new i0.InjectionToken('ProductSuggestionNormalizer');

    var DEFAULT_SEARCH_CONFIG = {
        pageSize: 20,
    };
    var OccProductSearchAdapter = /** @class */ (function () {
        function OccProductSearchAdapter(http, occEndpoints, converter) {
            this.http = http;
            this.occEndpoints = occEndpoints;
            this.converter = converter;
        }
        OccProductSearchAdapter.prototype.search = function (query, searchConfig) {
            if (searchConfig === void 0) { searchConfig = DEFAULT_SEARCH_CONFIG; }
            return this.http
                .get(this.getSearchEndpoint(query, searchConfig))
                .pipe(this.converter.pipeable(PRODUCT_SEARCH_PAGE_NORMALIZER));
        };
        OccProductSearchAdapter.prototype.loadSuggestions = function (term, pageSize) {
            if (pageSize === void 0) { pageSize = 3; }
            return this.http
                .get(this.getSuggestionEndpoint(term, pageSize.toString()))
                .pipe(operators.pluck('suggestions'), this.converter.pipeableMany(PRODUCT_SUGGESTION_NORMALIZER));
        };
        OccProductSearchAdapter.prototype.getSearchEndpoint = function (query, searchConfig) {
            return this.occEndpoints.buildUrl('productSearch', {
                queryParams: Object.assign({ query: query }, searchConfig),
            });
        };
        OccProductSearchAdapter.prototype.getSuggestionEndpoint = function (term, max) {
            return this.occEndpoints.buildUrl('productSuggestions', {
                queryParams: { term: term, max: max },
            });
        };
        return OccProductSearchAdapter;
    }());
    OccProductSearchAdapter.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccProductSearchAdapter, deps: [{ token: i1__namespace$3.HttpClient }, { token: OccEndpointsService }, { token: ConverterService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    OccProductSearchAdapter.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccProductSearchAdapter });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccProductSearchAdapter, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: i1__namespace$3.HttpClient }, { type: OccEndpointsService }, { type: ConverterService }]; } });

    /**
     * Merge occ fields parameters
     *
     * @param fields Fields definition as string or object
     */
    function mergeFields(fields) {
        var parsedFields = fields.map(function (f) { return typeof f === 'string' ? parseFields(f) : f; });
        var mergedFields = optimizeFields(deepMerge.apply(void 0, __spreadArray([{}], __read(parsedFields))));
        return stringifyFields(mergedFields);
    }
    /**
     * Optimize fields definition by removing not needed groups
     *
     * @param fields
     */
    function optimizeFields(fields) {
        if (fields === void 0) { fields = {}; }
        var keys = Object.keys(fields);
        if (keys.includes('FULL')) {
            delete fields['DEFAULT'];
            delete fields['BASIC'];
        }
        else if (keys.includes('DEFAULT')) {
            delete fields['BASIC'];
        }
        Object.keys(fields).forEach(function (key) {
            fields[key] = optimizeFields(fields[key]);
        });
        return fields;
    }
    /**
     * Parse string field definition to an AST object
     *
     * @param fields Fields string definition
     * @param startIndex Used for recurrence
     */
    function parseFields(fields, startIndex) {
        if (startIndex === void 0) { startIndex = 0; }
        var parsedFields = {};
        var i = startIndex;
        while (i < fields.length) {
            if (fields[i] === ',') {
                if (i > startIndex) {
                    parsedFields[fields.substr(startIndex, i - startIndex)] = {};
                }
                startIndex = i + 1;
            }
            else if (fields[i] === '(') {
                var subFields = parseFields(fields, i + 1);
                if (Array.isArray(subFields)) {
                    parsedFields[fields.substr(startIndex, i - startIndex)] = subFields[0];
                    startIndex = subFields[1];
                    i = startIndex - 1;
                }
                else {
                    return parsedFields;
                }
            }
            else if (fields[i] === ')') {
                if (i > startIndex) {
                    parsedFields[fields.substr(startIndex, i - startIndex)] = {};
                }
                return [parsedFields, i + 1];
            }
            i++;
        }
        if (startIndex < fields.length) {
            parsedFields[fields.substr(startIndex, i - startIndex)] = {};
        }
        return parsedFields;
    }
    /**
     * Convert AST object fields definition to string representation
     *
     * @param fields
     */
    function stringifyFields(fields) {
        return Object.keys(fields)
            .map(function (key) {
            var subFields = stringifyFields(fields[key]);
            return subFields ? key + "(" + subFields + ")" : key;
        })
            .join(',');
    }
    /**
     * Extract part of the object described by fields definition
     *
     * @param data
     * @param fields
     */
    function extractFields(data, fields) {
        var parsedFields = typeof fields === 'string' ? parseFields(fields) : fields;
        return getObjectPart(data, parsedFields);
    }
    function getObjectPart(data, fields) {
        if (!isObject(data)) {
            return data;
        }
        var keys = Object.keys(fields);
        if (keys.length === 0 ||
            // we should not extract parts of the object with ambiguous fields definitions
            keys.find(function (el) { return el === 'BASIC' || el === 'DEFAULT' || el === 'FULL'; })) {
            return data;
        }
        var result = {};
        keys.forEach(function (key) {
            if (data.hasOwnProperty(key)) {
                result[key] = getObjectPart(data[key], fields[key]);
            }
        });
        return result;
    }

    /**
     * Helper service for optimizing endpoint calls to occ backend
     */
    var OccFieldsService = /** @class */ (function () {
        function OccFieldsService(http) {
            this.http = http;
            this.FIELDS_PARAM = 'fields';
        }
        /**
         * Merge similar occ endpoints calls by merging fields parameter
         *
         * We assume that different scopes are defined by different fields parameters,
         * so we are grouping all requests with the same urls (except fields definition)
         * and merging into one request with fields that will satisfy all separate ones.
         *
         * @param models
         */
        OccFieldsService.prototype.getOptimalUrlGroups = function (models) {
            var e_1, _a, e_2, _b;
            var groupedByUrls = {};
            try {
                for (var models_1 = __values(models), models_1_1 = models_1.next(); !models_1_1.done; models_1_1 = models_1.next()) {
                    var model = models_1_1.value;
                    var _c = __read(this.splitFields(model.url), 2), urlPart = _c[0], fields = _c[1];
                    if (!groupedByUrls[urlPart]) {
                        groupedByUrls[urlPart] = {};
                    }
                    model.fields = fields ? parseFields(fields) : {};
                    groupedByUrls[urlPart][model.scopedData.scope] = model;
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (models_1_1 && !models_1_1.done && (_a = models_1.return)) _a.call(models_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            var mergedUrls = {};
            try {
                for (var _d = __values(Object.entries(groupedByUrls)), _e = _d.next(); !_e.done; _e = _d.next()) {
                    var _f = __read(_e.value, 2), url = _f[0], group = _f[1];
                    var urlWithFields = this.getUrlWithFields(url, Object.values(group).map(function (lo) { return lo.fields; }));
                    mergedUrls[urlWithFields] = group;
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_e && !_e.done && (_b = _d.return)) _b.call(_d);
                }
                finally { if (e_2) throw e_2.error; }
            }
            return mergedUrls;
        };
        /**
         * Extract fields parameter from occ endpoint url
         *
         * @param urlWithFields
         */
        OccFieldsService.prototype.splitFields = function (urlWithFields) {
            var _this = this;
            var _a = __read(urlWithFields.split('?'), 2), url = _a[0], params = _a[1];
            var paramsMap = {};
            if (params) {
                params.split('&').forEach(function (param) {
                    var keyValue = param.split('=');
                    paramsMap[keyValue[0]] = keyValue[1];
                });
            }
            var nonFieldsParams = Object.keys(paramsMap)
                .sort()
                .reduce(function (id, par) {
                if (par !== _this.FIELDS_PARAM) {
                    id.push(paramsMap[par] ? par + "=" + paramsMap[par] : par);
                }
                return id;
            }, []);
            var nonFields = nonFieldsParams.join('&');
            return [
                nonFields ? url + "?" + nonFields : url,
                paramsMap[this.FIELDS_PARAM],
            ];
        };
        /**
         * Combine url with field parameters
         *
         * @param url
         * @param fields
         */
        OccFieldsService.prototype.getUrlWithFields = function (url, fields) {
            var mergedFields = mergeFields(fields);
            if (mergedFields) {
                url += url.includes('?') ? '&' : '?';
                url += this.FIELDS_PARAM + "=" + mergedFields;
            }
            return url;
        };
        return OccFieldsService;
    }());
    OccFieldsService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccFieldsService, deps: [{ token: i1__namespace$3.HttpClient }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    OccFieldsService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccFieldsService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccFieldsService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace$3.HttpClient }]; } });

    var OccRequestsOptimizerService = /** @class */ (function () {
        function OccRequestsOptimizerService(http, occFields) {
            this.http = http;
            this.occFields = occFields;
        }
        /**
         * Optimize occ endpoint calls merging requests to the same url by merging field parameters
         *
         * @param scopedDataWithUrls
         * @param dataFactory
         */
        OccRequestsOptimizerService.prototype.scopedDataLoad = function (scopedDataWithUrls, dataFactory) {
            var _this = this;
            var result = [];
            if (!dataFactory) {
                dataFactory = function (url) { return _this.http.get(url); };
            }
            var mergedUrls = this.occFields.getOptimalUrlGroups(scopedDataWithUrls);
            Object.entries(mergedUrls).forEach(function (_a) {
                var _b = __read(_a, 2), url = _b[0], groupedModelsSet = _b[1];
                var groupedModels = Object.values(groupedModelsSet);
                if (groupedModels.length === 1) {
                    // only one scope for url, we can pass the data straightaway
                    result.push(Object.assign(Object.assign({}, groupedModels[0].scopedData), { data$: dataFactory(url) }));
                }
                else {
                    // multiple scopes per url
                    // we have to split the model per each scope
                    var data$_1 = dataFactory(url).pipe(operators.shareReplay(1));
                    groupedModels.forEach(function (modelData) {
                        result.push(Object.assign(Object.assign({}, modelData.scopedData), { data$: data$_1.pipe(operators.map(function (data) { return extractFields(data, modelData.fields); })) }));
                    });
                }
            });
            return result;
        };
        return OccRequestsOptimizerService;
    }());
    OccRequestsOptimizerService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccRequestsOptimizerService, deps: [{ token: i1__namespace$3.HttpClient }, { token: OccFieldsService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    OccRequestsOptimizerService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccRequestsOptimizerService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccRequestsOptimizerService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace$3.HttpClient }, { type: OccFieldsService }]; } });

    var OccProductAdapter = /** @class */ (function () {
        function OccProductAdapter(http, occEndpoints, converter, requestsOptimizer) {
            this.http = http;
            this.occEndpoints = occEndpoints;
            this.converter = converter;
            this.requestsOptimizer = requestsOptimizer;
        }
        OccProductAdapter.prototype.load = function (productCode, scope) {
            return this.http
                .get(this.getEndpoint(productCode, scope))
                .pipe(this.converter.pipeable(PRODUCT_NORMALIZER));
        };
        OccProductAdapter.prototype.loadMany = function (products) {
            var _this = this;
            var scopedDataWithUrls = products.map(function (model) { return ({
                scopedData: model,
                url: _this.getEndpoint(model.code, model.scope),
            }); });
            return this.requestsOptimizer
                .scopedDataLoad(scopedDataWithUrls)
                .map(function (scopedProduct) { return (Object.assign(Object.assign({}, scopedProduct), { data$: scopedProduct.data$.pipe(_this.converter.pipeable(PRODUCT_NORMALIZER)) })); });
        };
        OccProductAdapter.prototype.getEndpoint = function (code, scope) {
            return this.occEndpoints.buildUrl('product', {
                urlParams: { productCode: code },
                scope: scope,
            });
        };
        return OccProductAdapter;
    }());
    OccProductAdapter.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccProductAdapter, deps: [{ token: i1__namespace$3.HttpClient }, { token: OccEndpointsService }, { token: ConverterService }, { token: OccRequestsOptimizerService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    OccProductAdapter.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccProductAdapter });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccProductAdapter, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: i1__namespace$3.HttpClient }, { type: OccEndpointsService }, { type: ConverterService }, { type: OccRequestsOptimizerService }]; } });

    var ProductAdapter = /** @class */ (function () {
        function ProductAdapter() {
        }
        return ProductAdapter;
    }());

    var ProductReferencesAdapter = /** @class */ (function () {
        function ProductReferencesAdapter() {
        }
        return ProductReferencesAdapter;
    }());

    var ProductReviewsAdapter = /** @class */ (function () {
        function ProductReviewsAdapter() {
        }
        return ProductReviewsAdapter;
    }());

    var ProductSearchAdapter = /** @class */ (function () {
        function ProductSearchAdapter() {
        }
        return ProductSearchAdapter;
    }());

    var defaultOccProductConfig = {
        backend: {
            occ: {
                endpoints: {
                    product: {
                        default: 'products/${productCode}?fields=DEFAULT,averageRating,images(FULL),classifications,manufacturer,numberOfReviews,categories(FULL),baseOptions,baseProduct,variantOptions,variantType',
                        list: 'products/${productCode}?fields=code,name,summary,price(formattedValue),images(DEFAULT,galleryIndex),baseProduct',
                        details: 'products/${productCode}?fields=averageRating,stock(DEFAULT),description,availableForPickup,code,url,price(DEFAULT),numberOfReviews,manufacturer,categories(FULL),priceRange,multidimensional,tags,images(FULL)',
                        attributes: 'products/${productCode}?fields=classifications',
                        price: 'products/${productCode}?fields=price(formattedValue)',
                    },
                    productReviews: 'products/${productCode}/reviews',
                    // Uncomment this when occ gets configured
                    // productReferences:
                    //   'products/${productCode}/references?fields=DEFAULT,references(target(images(FULL)))&referenceType=${referenceType}',
                    productReferences: 'products/${productCode}/references?fields=DEFAULT,references(target(images(FULL)))',
                    /* eslint-disable max-len */
                    productSearch: 'products/search?fields=products(code,name,summary,configurable,configuratorType,multidimensional,price(FULL),images(DEFAULT),stock(FULL),averageRating,variantOptions),facets,breadcrumbs,pagination(DEFAULT),sorts(DEFAULT),freeTextSearch,currentQuery',
                    /* eslint-enable */
                    productSuggestions: 'products/suggestions',
                },
            },
            loadingScopes: {
                product: {
                    details: {
                        include: ["list" /* LIST */, "variants" /* VARIANTS */],
                    },
                },
            },
        },
    };

    var ProductOccModule = /** @class */ (function () {
        function ProductOccModule() {
        }
        return ProductOccModule;
    }());
    ProductOccModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductOccModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    ProductOccModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductOccModule, imports: [i6.CommonModule] });
    ProductOccModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductOccModule, providers: [
            provideDefaultConfig(defaultOccProductConfig),
            {
                provide: ProductAdapter,
                useClass: OccProductAdapter,
            },
            {
                provide: PRODUCT_NORMALIZER,
                useExisting: ProductImageNormalizer,
                multi: true,
            },
            {
                provide: PRODUCT_NORMALIZER,
                useExisting: ProductNameNormalizer,
                multi: true,
            },
            {
                provide: ProductReferencesAdapter,
                useClass: OccProductReferencesAdapter,
            },
            {
                provide: PRODUCT_REFERENCES_NORMALIZER,
                useExisting: OccProductReferencesListNormalizer,
                multi: true,
            },
            {
                provide: ProductSearchAdapter,
                useClass: OccProductSearchAdapter,
            },
            {
                provide: PRODUCT_SEARCH_PAGE_NORMALIZER,
                useExisting: OccProductSearchPageNormalizer,
                multi: true,
            },
            {
                provide: ProductReviewsAdapter,
                useClass: OccProductReviewsAdapter,
            },
        ], imports: [[i6.CommonModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductOccModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [i6.CommonModule],
                        providers: [
                            provideDefaultConfig(defaultOccProductConfig),
                            {
                                provide: ProductAdapter,
                                useClass: OccProductAdapter,
                            },
                            {
                                provide: PRODUCT_NORMALIZER,
                                useExisting: ProductImageNormalizer,
                                multi: true,
                            },
                            {
                                provide: PRODUCT_NORMALIZER,
                                useExisting: ProductNameNormalizer,
                                multi: true,
                            },
                            {
                                provide: ProductReferencesAdapter,
                                useClass: OccProductReferencesAdapter,
                            },
                            {
                                provide: PRODUCT_REFERENCES_NORMALIZER,
                                useExisting: OccProductReferencesListNormalizer,
                                multi: true,
                            },
                            {
                                provide: ProductSearchAdapter,
                                useClass: OccProductSearchAdapter,
                            },
                            {
                                provide: PRODUCT_SEARCH_PAGE_NORMALIZER,
                                useExisting: OccProductSearchPageNormalizer,
                                multi: true,
                            },
                            {
                                provide: ProductReviewsAdapter,
                                useClass: OccProductReviewsAdapter,
                            },
                        ],
                    }]
            }] });

    var BaseSiteNormalizer = /** @class */ (function () {
        function BaseSiteNormalizer() {
        }
        BaseSiteNormalizer.prototype.convert = function (source, target) {
            var _a;
            if (target === undefined) {
                target = Object.assign({}, source);
            }
            // We take the first store as the base store.
            target.baseStore = (_a = source.stores) === null || _a === void 0 ? void 0 : _a[0];
            delete target.stores;
            return target;
        };
        return BaseSiteNormalizer;
    }());
    BaseSiteNormalizer.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: BaseSiteNormalizer, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    BaseSiteNormalizer.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: BaseSiteNormalizer, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: BaseSiteNormalizer, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }], ctorParameters: function () { return []; } });

    var OccSiteAdapter = /** @class */ (function () {
        function OccSiteAdapter(http, occEndpointsService, converterService) {
            this.http = http;
            this.occEndpointsService = occEndpointsService;
            this.converterService = converterService;
        }
        OccSiteAdapter.prototype.loadLanguages = function () {
            return this.http
                .get(this.occEndpointsService.buildUrl('languages'))
                .pipe(operators.map(function (languageList) { return languageList.languages; }), this.converterService.pipeableMany(LANGUAGE_NORMALIZER));
        };
        OccSiteAdapter.prototype.loadCurrencies = function () {
            return this.http
                .get(this.occEndpointsService.buildUrl('currencies'))
                .pipe(operators.map(function (currencyList) { return currencyList.currencies; }), this.converterService.pipeableMany(CURRENCY_NORMALIZER));
        };
        OccSiteAdapter.prototype.loadCountries = function (type) {
            return this.http
                .get(this.occEndpointsService.buildUrl('countries', {
                queryParams: type ? { type: type } : undefined,
            }))
                .pipe(operators.map(function (countryList) { return countryList.countries; }), this.converterService.pipeableMany(COUNTRY_NORMALIZER));
        };
        OccSiteAdapter.prototype.loadRegions = function (countryIsoCode) {
            return this.http
                .get(this.occEndpointsService.buildUrl('regions', {
                urlParams: { isoCode: countryIsoCode },
            }))
                .pipe(operators.map(function (regionList) { return regionList.regions; }), this.converterService.pipeableMany(REGION_NORMALIZER));
        };
        /**
         * There is no OCC API to load one site based on Uid.
         * So, we have to load all sites, and find the one from the list.
         */
        OccSiteAdapter.prototype.loadBaseSite = function (siteUid) {
            if (!siteUid) {
                var baseUrl = this.occEndpointsService.getBaseUrl();
                var urlSplits = baseUrl.split('/');
                siteUid = urlSplits.pop();
            }
            return this.http
                .get(this.occEndpointsService.buildUrl('baseSites', {}, { baseSite: false }))
                .pipe(operators.map(function (siteList) {
                return siteList.baseSites.find(function (site) { return site.uid === siteUid; });
            }));
        };
        OccSiteAdapter.prototype.loadBaseSites = function () {
            return this.http
                .get(this.occEndpointsService.buildUrl('baseSites', {}, { baseSite: false }))
                .pipe(operators.map(function (baseSiteList) { return baseSiteList.baseSites; }), this.converterService.pipeableMany(BASE_SITE_NORMALIZER));
        };
        return OccSiteAdapter;
    }());
    OccSiteAdapter.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccSiteAdapter, deps: [{ token: i1__namespace$3.HttpClient }, { token: OccEndpointsService }, { token: ConverterService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    OccSiteAdapter.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccSiteAdapter });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccSiteAdapter, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: i1__namespace$3.HttpClient }, { type: OccEndpointsService }, { type: ConverterService }]; } });

    var defaultOccSiteContextConfig = {
        backend: {
            occ: {
                endpoints: {
                    languages: 'languages',
                    currencies: 'currencies',
                    countries: 'countries',
                    regions: 'countries/${isoCode}/regions?fields=regions(name,isocode,isocodeShort)',
                    baseSites: 'basesites?fields=baseSites(uid,defaultLanguage(isocode),urlEncodingAttributes,urlPatterns,stores(currencies(isocode),defaultCurrency(isocode),languages(isocode),defaultLanguage(isocode)),theme,defaultPreviewCatalogId,defaultPreviewCategoryCode,defaultPreviewProductCode)',
                },
            },
        },
    };

    var SiteContextInterceptor = /** @class */ (function () {
        function SiteContextInterceptor(languageService, currencyService, occEndpoints, config) {
            var _this = this;
            this.languageService = languageService;
            this.currencyService = currencyService;
            this.occEndpoints = occEndpoints;
            this.config = config;
            this.activeLang = getContextParameterDefault(this.config, LANGUAGE_CONTEXT_ID);
            this.activeCurr = getContextParameterDefault(this.config, CURRENCY_CONTEXT_ID);
            this.languageService
                .getActive()
                .subscribe(function (data) { return (_this.activeLang = data); });
            this.currencyService.getActive().subscribe(function (data) {
                _this.activeCurr = data;
            });
        }
        SiteContextInterceptor.prototype.intercept = function (request, next) {
            if (request.url.includes(this.occEndpoints.getBaseUrl())) {
                request = request.clone({
                    setParams: {
                        lang: this.activeLang,
                        curr: this.activeCurr,
                    },
                });
            }
            return next.handle(request);
        };
        return SiteContextInterceptor;
    }());
    SiteContextInterceptor.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SiteContextInterceptor, deps: [{ token: LanguageService }, { token: CurrencyService }, { token: OccEndpointsService }, { token: SiteContextConfig }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    SiteContextInterceptor.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SiteContextInterceptor, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SiteContextInterceptor, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }], ctorParameters: function () { return [{ type: LanguageService }, { type: CurrencyService }, { type: OccEndpointsService }, { type: SiteContextConfig }]; } });

    var SiteContextOccModule = /** @class */ (function () {
        function SiteContextOccModule() {
        }
        return SiteContextOccModule;
    }());
    SiteContextOccModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SiteContextOccModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    SiteContextOccModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SiteContextOccModule, imports: [i6.CommonModule] });
    SiteContextOccModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SiteContextOccModule, providers: [
            provideDefaultConfig(defaultOccSiteContextConfig),
            {
                provide: SiteAdapter,
                useClass: OccSiteAdapter,
            },
            {
                provide: i1$3.HTTP_INTERCEPTORS,
                useExisting: SiteContextInterceptor,
                multi: true,
            },
            {
                provide: BASE_SITE_NORMALIZER,
                useExisting: BaseSiteNormalizer,
                multi: true,
            },
        ], imports: [[i6.CommonModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SiteContextOccModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [i6.CommonModule],
                        providers: [
                            provideDefaultConfig(defaultOccSiteContextConfig),
                            {
                                provide: SiteAdapter,
                                useClass: OccSiteAdapter,
                            },
                            {
                                provide: i1$3.HTTP_INTERCEPTORS,
                                useExisting: SiteContextInterceptor,
                                multi: true,
                            },
                            {
                                provide: BASE_SITE_NORMALIZER,
                                useExisting: BaseSiteNormalizer,
                                multi: true,
                            },
                        ],
                    }]
            }] });

    var AnonymousConsentNormalizer = /** @class */ (function () {
        function AnonymousConsentNormalizer(anonymousConsentsService) {
            this.anonymousConsentsService = anonymousConsentsService;
        }
        AnonymousConsentNormalizer.prototype.convert = function (source) {
            return this.anonymousConsentsService.decodeAndDeserialize(source);
        };
        return AnonymousConsentNormalizer;
    }());
    AnonymousConsentNormalizer.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AnonymousConsentNormalizer, deps: [{ token: AnonymousConsentsService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    AnonymousConsentNormalizer.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AnonymousConsentNormalizer, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AnonymousConsentNormalizer, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }], ctorParameters: function () { return [{ type: AnonymousConsentsService }]; } });

    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var OccReturnRequestNormalizer = /** @class */ (function () {
        function OccReturnRequestNormalizer(converter) {
            this.converter = converter;
        }
        OccReturnRequestNormalizer.prototype.convert = function (source, target) {
            var _this = this;
            if (target === undefined) {
                target = Object.assign({}, source);
            }
            if (source.returnEntries) {
                target.returnEntries = source.returnEntries.map(function (entry) { return (Object.assign(Object.assign({}, entry), { orderEntry: _this.convertOrderEntry(entry.orderEntry) })); });
            }
            return target;
        };
        OccReturnRequestNormalizer.prototype.convertOrderEntry = function (source) {
            return Object.assign(Object.assign({}, source), { product: this.converter.convert(source.product, PRODUCT_NORMALIZER) });
        };
        return OccReturnRequestNormalizer;
    }());
    OccReturnRequestNormalizer.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccReturnRequestNormalizer, deps: [{ token: ConverterService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    OccReturnRequestNormalizer.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccReturnRequestNormalizer, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccReturnRequestNormalizer, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }], ctorParameters: function () { return [{ type: ConverterService }]; } });

    var OccUserInterestsNormalizer = /** @class */ (function () {
        function OccUserInterestsNormalizer(converter) {
            this.converter = converter;
        }
        OccUserInterestsNormalizer.prototype.convert = function (source, target) {
            var _this = this;
            if (target === undefined) {
                target = Object.assign({}, source);
            }
            if (source && source.results) {
                target.results = source.results.map(function (result) { return (Object.assign(Object.assign({}, result), { product: _this.converter.convert(result.product, PRODUCT_NORMALIZER) })); });
            }
            return target;
        };
        return OccUserInterestsNormalizer;
    }());
    OccUserInterestsNormalizer.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccUserInterestsNormalizer, deps: [{ token: ConverterService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    OccUserInterestsNormalizer.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccUserInterestsNormalizer, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccUserInterestsNormalizer, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }], ctorParameters: function () { return [{ type: ConverterService }]; } });

    var CONSENT_TEMPLATE_NORMALIZER = new i0.InjectionToken('ConsentTemplateNormalizer');

    var OccAnonymousConsentTemplatesAdapter = /** @class */ (function () {
        function OccAnonymousConsentTemplatesAdapter(http, occEndpoints, converter) {
            this.http = http;
            this.occEndpoints = occEndpoints;
            this.converter = converter;
        }
        OccAnonymousConsentTemplatesAdapter.prototype.loadAnonymousConsentTemplates = function () {
            var url = this.occEndpoints.buildUrl('anonymousConsentTemplates');
            return this.http.get(url).pipe(operators.catchError(function (error) { return rxjs.throwError(error); }), operators.map(function (consentList) { return consentList.consentTemplates; }), this.converter.pipeableMany(CONSENT_TEMPLATE_NORMALIZER));
        };
        OccAnonymousConsentTemplatesAdapter.prototype.loadAnonymousConsents = function () {
            // using the endpoint that doesn't set caching headers
            var url = this.occEndpoints.buildUrl('anonymousConsentTemplates');
            return this.http
                .head(url, { observe: 'response' })
                .pipe(operators.catchError(function (error) { return rxjs.throwError(error); }), operators.map(function (response) { return response.headers.get(ANONYMOUS_CONSENTS_HEADER); }), this.converter.pipeable(ANONYMOUS_CONSENT_NORMALIZER));
        };
        return OccAnonymousConsentTemplatesAdapter;
    }());
    OccAnonymousConsentTemplatesAdapter.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccAnonymousConsentTemplatesAdapter, deps: [{ token: i1__namespace$3.HttpClient }, { token: OccEndpointsService }, { token: ConverterService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    OccAnonymousConsentTemplatesAdapter.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccAnonymousConsentTemplatesAdapter });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccAnonymousConsentTemplatesAdapter, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: i1__namespace$3.HttpClient }, { type: OccEndpointsService }, { type: ConverterService }]; } });

    var CUSTOMER_COUPON_SEARCH_RESULT_NORMALIZER = new i0.InjectionToken('CustomerCouponSearchResultNormalizer');

    var OccCustomerCouponAdapter = /** @class */ (function () {
        function OccCustomerCouponAdapter(http, occEndpoints, converter) {
            this.http = http;
            this.occEndpoints = occEndpoints;
            this.converter = converter;
        }
        OccCustomerCouponAdapter.prototype.getCustomerCoupons = function (userId, pageSize, currentPage, sort) {
            // Currently OCC only supports calls for customer coupons in case of logged users
            if (userId === OCC_USER_ID_ANONYMOUS) {
                return rxjs.of({});
            }
            var url = this.occEndpoints.buildUrl('customerCoupons', {
                urlParams: { userId: userId },
            });
            var params = new i1$3.HttpParams().set('sort', sort ? sort : 'startDate:asc');
            if (pageSize) {
                params = params.set('pageSize', pageSize.toString());
            }
            if (currentPage) {
                params = params.set('currentPage', currentPage.toString());
            }
            var headers = this.newHttpHeader();
            return this.http
                .get(url, { headers: headers, params: params })
                .pipe(this.converter.pipeable(CUSTOMER_COUPON_SEARCH_RESULT_NORMALIZER));
        };
        OccCustomerCouponAdapter.prototype.turnOffNotification = function (userId, couponCode) {
            var url = this.occEndpoints.buildUrl('couponNotification', {
                urlParams: { userId: userId, couponCode: couponCode },
            });
            var headers = this.newHttpHeader();
            return this.http.delete(url, { headers: headers });
        };
        OccCustomerCouponAdapter.prototype.turnOnNotification = function (userId, couponCode) {
            var url = this.occEndpoints.buildUrl('couponNotification', {
                urlParams: { userId: userId, couponCode: couponCode },
            });
            var headers = this.newHttpHeader();
            return this.http.post(url, { headers: headers });
        };
        OccCustomerCouponAdapter.prototype.claimCustomerCoupon = function (userId, couponCode) {
            var url = this.occEndpoints.buildUrl('claimCoupon', {
                urlParams: { userId: userId, couponCode: couponCode },
            });
            var headers = this.newHttpHeader();
            return this.http.post(url, { headers: headers });
        };
        OccCustomerCouponAdapter.prototype.newHttpHeader = function () {
            return new i1$3.HttpHeaders({
                'Content-Type': 'application/json',
            });
        };
        return OccCustomerCouponAdapter;
    }());
    OccCustomerCouponAdapter.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccCustomerCouponAdapter, deps: [{ token: i1__namespace$3.HttpClient }, { token: OccEndpointsService }, { token: ConverterService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    OccCustomerCouponAdapter.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccCustomerCouponAdapter });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccCustomerCouponAdapter, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: i1__namespace$3.HttpClient }, { type: OccEndpointsService }, { type: ConverterService }]; } });

    var ADDRESS_NORMALIZER = new i0.InjectionToken('AddressNormalizer');
    var ADDRESS_LIST_NORMALIZER = new i0.InjectionToken('AddressesNormalizer');
    var ADDRESS_SERIALIZER = new i0.InjectionToken('AddressSerializer');
    var ADDRESS_VALIDATION_NORMALIZER = new i0.InjectionToken('AddressValidationNormalizer');

    var OccUserAddressAdapter = /** @class */ (function () {
        function OccUserAddressAdapter(http, occEndpoints, converter) {
            this.http = http;
            this.occEndpoints = occEndpoints;
            this.converter = converter;
        }
        OccUserAddressAdapter.prototype.loadAll = function (userId) {
            var url = this.occEndpoints.buildUrl('addresses', {
                urlParams: { userId: userId },
            });
            var headers = new i1$3.HttpHeaders({
                'Content-Type': 'application/json',
            });
            return this.http.get(url, { headers: headers }).pipe(operators.catchError(function (error) { return rxjs.throwError(error); }), operators.map(function (addressList) { return addressList.addresses; }), this.converter.pipeableMany(ADDRESS_NORMALIZER));
        };
        OccUserAddressAdapter.prototype.add = function (userId, address) {
            var url = this.occEndpoints.buildUrl('addresses', {
                urlParams: { userId: userId },
            });
            var headers = new i1$3.HttpHeaders({
                'Content-Type': 'application/json',
            });
            address = this.converter.convert(address, ADDRESS_SERIALIZER);
            return this.http
                .post(url, address, { headers: headers })
                .pipe(operators.catchError(function (error) { return rxjs.throwError(error); }));
        };
        OccUserAddressAdapter.prototype.update = function (userId, addressId, address) {
            var url = this.occEndpoints.buildUrl('addressDetail', {
                urlParams: { userId: userId, addressId: addressId },
            });
            var headers = new i1$3.HttpHeaders({
                'Content-Type': 'application/json',
            });
            address = this.converter.convert(address, ADDRESS_SERIALIZER);
            return this.http
                .patch(url, address, { headers: headers })
                .pipe(operators.catchError(function (error) { return rxjs.throwError(error); }));
        };
        OccUserAddressAdapter.prototype.verify = function (userId, address) {
            var url = this.occEndpoints.buildUrl('addressVerification', {
                urlParams: { userId: userId },
            });
            var headers = new i1$3.HttpHeaders({
                'Content-Type': 'application/json',
            });
            if (userId === OCC_USER_ID_ANONYMOUS) {
                headers = InterceptorUtil.createHeader(USE_CLIENT_TOKEN, true, headers);
            }
            address = this.converter.convert(address, ADDRESS_SERIALIZER);
            return this.http.post(url, address, { headers: headers }).pipe(operators.catchError(function (error) { return rxjs.throwError(error); }), this.converter.pipeable(ADDRESS_VALIDATION_NORMALIZER));
        };
        OccUserAddressAdapter.prototype.delete = function (userId, addressId) {
            var url = this.occEndpoints.buildUrl('addressDetail', {
                urlParams: { userId: userId, addressId: addressId },
            });
            var headers = new i1$3.HttpHeaders({
                'Content-Type': 'application/json',
            });
            return this.http
                .delete(url, { headers: headers })
                .pipe(operators.catchError(function (error) { return rxjs.throwError(error); }));
        };
        return OccUserAddressAdapter;
    }());
    OccUserAddressAdapter.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccUserAddressAdapter, deps: [{ token: i1__namespace$3.HttpClient }, { token: OccEndpointsService }, { token: ConverterService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    OccUserAddressAdapter.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccUserAddressAdapter });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccUserAddressAdapter, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: i1__namespace$3.HttpClient }, { type: OccEndpointsService }, { type: ConverterService }]; } });

    var OccUserConsentAdapter = /** @class */ (function () {
        function OccUserConsentAdapter(http, occEndpoints, converter) {
            this.http = http;
            this.occEndpoints = occEndpoints;
            this.converter = converter;
        }
        OccUserConsentAdapter.prototype.loadConsents = function (userId) {
            var url = this.occEndpoints.buildUrl('consentTemplates', {
                urlParams: { userId: userId },
            });
            var headers = new i1$3.HttpHeaders({ 'Cache-Control': 'no-cache' });
            return this.http.get(url, { headers: headers }).pipe(operators.catchError(function (error) { return rxjs.throwError(error); }), operators.map(function (consentList) { return consentList.consentTemplates; }), this.converter.pipeableMany(CONSENT_TEMPLATE_NORMALIZER));
        };
        OccUserConsentAdapter.prototype.giveConsent = function (userId, consentTemplateId, consentTemplateVersion) {
            var url = this.occEndpoints.buildUrl('consents', {
                urlParams: { userId: userId },
            });
            var httpParams = new i1$3.HttpParams()
                .set('consentTemplateId', consentTemplateId)
                .set('consentTemplateVersion', consentTemplateVersion.toString());
            var headers = new i1$3.HttpHeaders({
                'Content-Type': 'application/x-www-form-urlencoded',
                'Cache-Control': 'no-cache',
            });
            return this.http
                .post(url, httpParams, { headers: headers })
                .pipe(operators.catchError(function (error) { return rxjs.throwError(error); }), this.converter.pipeable(CONSENT_TEMPLATE_NORMALIZER));
        };
        OccUserConsentAdapter.prototype.withdrawConsent = function (userId, consentCode) {
            var headers = new i1$3.HttpHeaders({
                'Cache-Control': 'no-cache',
            });
            var url = this.occEndpoints.buildUrl('consentDetail', {
                urlParams: { userId: userId, consentId: consentCode },
            });
            return this.http.delete(url, { headers: headers });
        };
        return OccUserConsentAdapter;
    }());
    OccUserConsentAdapter.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccUserConsentAdapter, deps: [{ token: i1__namespace$3.HttpClient }, { token: OccEndpointsService }, { token: ConverterService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    OccUserConsentAdapter.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccUserConsentAdapter });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccUserConsentAdapter, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: i1__namespace$3.HttpClient }, { type: OccEndpointsService }, { type: ConverterService }]; } });

    var PRODUCT_INTERESTS_NORMALIZER = new i0.InjectionToken('ProductInterestsNormalizer');

    var headers$1 = new i1$3.HttpHeaders({
        'Content-Type': 'application/json',
    });
    var OccUserInterestsAdapter = /** @class */ (function () {
        function OccUserInterestsAdapter(http, occEndpoints, config, converter) {
            this.http = http;
            this.occEndpoints = occEndpoints;
            this.config = config;
            this.converter = converter;
        }
        OccUserInterestsAdapter.prototype.getInterests = function (userId, pageSize, currentPage, sort, productCode, notificationType) {
            var params = new i1$3.HttpParams().set('sort', sort ? sort : 'name:asc');
            if (pageSize) {
                params = params.set('pageSize', pageSize.toString());
            }
            if (currentPage) {
                params = params.set('currentPage', currentPage.toString());
            }
            if (productCode) {
                params = params.set('productCode', productCode);
            }
            if (notificationType) {
                params = params.set('notificationType', notificationType.toString());
            }
            return this.http
                .get(this.occEndpoints.buildUrl('getProductInterests', {
                urlParams: { userId: userId },
            }), {
                headers: headers$1,
                params: params,
            })
                .pipe(this.converter.pipeable(PRODUCT_INTERESTS_NORMALIZER), operators.catchError(function (error) { return rxjs.throwError(error); }));
        };
        OccUserInterestsAdapter.prototype.removeInterest = function (userId, item) {
            var _this = this;
            var r = [];
            item.productInterestEntry.forEach(function (entry) {
                var params = new i1$3.HttpParams()
                    .set('productCode', item.product.code)
                    .set('notificationType', entry.interestType);
                r.push(_this.http
                    .delete(_this.occEndpoints.buildUrl('productInterests', {
                    urlParams: { userId: userId },
                }), {
                    params: params,
                })
                    .pipe(operators.catchError(function (error) { return rxjs.throwError(error); })));
            });
            return rxjs.forkJoin(r);
        };
        OccUserInterestsAdapter.prototype.addInterest = function (userId, productCode, notificationType) {
            var params = new i1$3.HttpParams()
                .set('productCode', productCode)
                .set('notificationType', notificationType.toString());
            return this.http
                .post(this.occEndpoints.buildUrl('productInterests', {
                urlParams: { userId: userId },
            }), {}, {
                headers: headers$1,
                params: params,
            })
                .pipe(operators.catchError(function (error) { return rxjs.throwError(error); }));
        };
        return OccUserInterestsAdapter;
    }());
    OccUserInterestsAdapter.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccUserInterestsAdapter, deps: [{ token: i1__namespace$3.HttpClient }, { token: OccEndpointsService }, { token: OccConfig }, { token: ConverterService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    OccUserInterestsAdapter.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccUserInterestsAdapter });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccUserInterestsAdapter, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: i1__namespace$3.HttpClient }, { type: OccEndpointsService }, { type: OccConfig }, { type: ConverterService }]; } });

    var NOTIFICATION_PREFERENCE_SERIALIZER = new i0.InjectionToken('NotificationPreferenceSerializer');
    var NOTIFICATION_PREFERENCE_NORMALIZER = new i0.InjectionToken('NotificationPreferenceNormalizer');

    var UserNotificationPreferenceAdapter = /** @class */ (function () {
        function UserNotificationPreferenceAdapter() {
        }
        return UserNotificationPreferenceAdapter;
    }());

    var UserNotificationPreferenceConnector = /** @class */ (function () {
        function UserNotificationPreferenceConnector(adapter) {
            this.adapter = adapter;
        }
        UserNotificationPreferenceConnector.prototype.loadAll = function (userId) {
            return this.adapter.loadAll(userId);
        };
        UserNotificationPreferenceConnector.prototype.update = function (userId, preferences) {
            return this.adapter.update(userId, preferences);
        };
        return UserNotificationPreferenceConnector;
    }());
    UserNotificationPreferenceConnector.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserNotificationPreferenceConnector, deps: [{ token: UserNotificationPreferenceAdapter }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    UserNotificationPreferenceConnector.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserNotificationPreferenceConnector, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserNotificationPreferenceConnector, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: UserNotificationPreferenceAdapter }]; } });

    var headers = new i1$3.HttpHeaders({
        'Content-Type': 'application/json',
    });
    var OccUserNotificationPreferenceAdapter = /** @class */ (function () {
        function OccUserNotificationPreferenceAdapter(http, converter, occEndpoints) {
            this.http = http;
            this.converter = converter;
            this.occEndpoints = occEndpoints;
        }
        OccUserNotificationPreferenceAdapter.prototype.loadAll = function (userId) {
            return this.http
                .get(this.occEndpoints.buildUrl('notificationPreference', {
                urlParams: { userId: userId },
            }), {
                headers: headers,
            })
                .pipe(operators.map(function (list) { return list.preferences; }), this.converter.pipeableMany(NOTIFICATION_PREFERENCE_NORMALIZER), operators.catchError(function (error) { return rxjs.throwError(error); }));
        };
        OccUserNotificationPreferenceAdapter.prototype.update = function (userId, preferences) {
            preferences = this.converter.convert(preferences, NOTIFICATION_PREFERENCE_SERIALIZER);
            return this.http
                .patch(this.occEndpoints.buildUrl('notificationPreference', {
                urlParams: { userId: userId },
            }), { preferences: preferences }, { headers: headers })
                .pipe(operators.catchError(function (error) { return rxjs.throwError(error); }));
        };
        return OccUserNotificationPreferenceAdapter;
    }());
    OccUserNotificationPreferenceAdapter.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccUserNotificationPreferenceAdapter, deps: [{ token: i1__namespace$3.HttpClient }, { token: ConverterService }, { token: OccEndpointsService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    OccUserNotificationPreferenceAdapter.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccUserNotificationPreferenceAdapter });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccUserNotificationPreferenceAdapter, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: i1__namespace$3.HttpClient }, { type: ConverterService }, { type: OccEndpointsService }]; } });

    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var ORDER_HISTORY_NORMALIZER = new i0.InjectionToken('OrderHistoryNormalizer');
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var CONSIGNMENT_TRACKING_NORMALIZER = new i0.InjectionToken('ConsignmentTrackingNormalizer');
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var ORDER_RETURN_REQUEST_NORMALIZER = new i0.InjectionToken('OrderReturnRequestNormalizer');
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var ORDER_RETURN_REQUEST_INPUT_SERIALIZER = new i0.InjectionToken('OrderReturnRequestInputSerializer');
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var ORDER_RETURNS_NORMALIZER = new i0.InjectionToken('OrderReturnsNormalizer');

    /**
     * @deprecated since 4.2 - use OccOrderAdapter in @spartacus/order/occ instead
     */
    var OccUserOrderAdapter = /** @class */ (function () {
        function OccUserOrderAdapter(http, occEndpoints, converter) {
            this.http = http;
            this.occEndpoints = occEndpoints;
            this.converter = converter;
        }
        OccUserOrderAdapter.prototype.load = function (userId, orderCode) {
            var url = this.occEndpoints.buildUrl('orderDetail', {
                urlParams: { userId: userId, orderId: orderCode },
            });
            var headers = new i1$3.HttpHeaders();
            if (userId === OCC_USER_ID_ANONYMOUS) {
                headers = InterceptorUtil.createHeader(USE_CLIENT_TOKEN, true, headers);
            }
            return this.http
                .get(url, { headers: headers })
                .pipe(this.converter.pipeable(ORDER_NORMALIZER));
        };
        OccUserOrderAdapter.prototype.loadHistory = function (userId, pageSize, currentPage, sort) {
            var params = {};
            if (pageSize) {
                params['pageSize'] = pageSize.toString();
            }
            if (currentPage) {
                params['currentPage'] = currentPage.toString();
            }
            if (sort) {
                params['sort'] = sort.toString();
            }
            var url = this.occEndpoints.buildUrl('orderHistory', {
                urlParams: { userId: userId },
                queryParams: params,
            });
            return this.http
                .get(url)
                .pipe(this.converter.pipeable(ORDER_HISTORY_NORMALIZER));
        };
        OccUserOrderAdapter.prototype.getConsignmentTracking = function (orderCode, consignmentCode, userId) {
            if (userId === void 0) { userId = OCC_USER_ID_CURRENT; }
            var url = this.occEndpoints.buildUrl('consignmentTracking', {
                urlParams: { userId: userId, orderCode: orderCode, consignmentCode: consignmentCode },
            });
            return this.http
                .get(url)
                .pipe(this.converter.pipeable(CONSIGNMENT_TRACKING_NORMALIZER));
        };
        OccUserOrderAdapter.prototype.cancel = function (userId, orderCode, cancelRequestInput) {
            var url = this.occEndpoints.buildUrl('cancelOrder', {
                urlParams: { userId: userId, orderId: orderCode },
            });
            var headers = new i1$3.HttpHeaders({
                'Content-Type': 'application/json',
            });
            return this.http
                .post(url, cancelRequestInput, { headers: headers })
                .pipe(operators.catchError(function (error) { return rxjs.throwError(error); }));
        };
        OccUserOrderAdapter.prototype.createReturnRequest = function (userId, returnRequestInput) {
            var url = this.occEndpoints.buildUrl('returnOrder', {
                urlParams: { userId: userId },
            });
            var headers = new i1$3.HttpHeaders({
                'Content-Type': 'application/json',
            });
            returnRequestInput = this.converter.convert(returnRequestInput, ORDER_RETURN_REQUEST_INPUT_SERIALIZER);
            return this.http.post(url, returnRequestInput, { headers: headers }).pipe(operators.catchError(function (error) { return rxjs.throwError(error); }), this.converter.pipeable(ORDER_RETURN_REQUEST_NORMALIZER));
        };
        OccUserOrderAdapter.prototype.loadReturnRequestList = function (userId, pageSize, currentPage, sort) {
            var params = {};
            if (pageSize) {
                params['pageSize'] = pageSize.toString();
            }
            if (currentPage) {
                params['currentPage'] = currentPage.toString();
            }
            if (sort) {
                params['sort'] = sort.toString();
            }
            var url = this.occEndpoints.buildUrl('orderReturns', {
                urlParams: { userId: userId },
                queryParams: params,
            });
            return this.http
                .get(url)
                .pipe(this.converter.pipeable(ORDER_RETURNS_NORMALIZER));
        };
        OccUserOrderAdapter.prototype.loadReturnRequestDetail = function (userId, returnRequestCode) {
            var url = this.occEndpoints.buildUrl('orderReturnDetail', {
                urlParams: { userId: userId, returnRequestCode: returnRequestCode },
            });
            return this.http
                .get(url)
                .pipe(this.converter.pipeable(ORDER_RETURN_REQUEST_NORMALIZER));
        };
        OccUserOrderAdapter.prototype.cancelReturnRequest = function (userId, returnRequestCode, returnRequestModification) {
            var url = this.occEndpoints.buildUrl('cancelReturn', {
                urlParams: { userId: userId, returnRequestCode: returnRequestCode },
            });
            var headers = new i1$3.HttpHeaders({
                'Content-Type': 'application/json',
            });
            return this.http
                .patch(url, returnRequestModification, { headers: headers })
                .pipe(operators.catchError(function (error) { return rxjs.throwError(error); }));
        };
        return OccUserOrderAdapter;
    }());
    OccUserOrderAdapter.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccUserOrderAdapter, deps: [{ token: i1__namespace$3.HttpClient }, { token: OccEndpointsService }, { token: ConverterService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    OccUserOrderAdapter.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccUserOrderAdapter });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccUserOrderAdapter, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: i1__namespace$3.HttpClient }, { type: OccEndpointsService }, { type: ConverterService }]; } });

    var OccUserPaymentAdapter = /** @class */ (function () {
        function OccUserPaymentAdapter(http, occEndpoints, converter) {
            this.http = http;
            this.occEndpoints = occEndpoints;
            this.converter = converter;
        }
        OccUserPaymentAdapter.prototype.loadAll = function (userId) {
            var url = this.occEndpoints.buildUrl('paymentDetailsAll', {
                urlParams: { userId: userId },
            }) + '?saved=true';
            var headers = new i1$3.HttpHeaders({
                'Content-Type': 'application/json',
            });
            return this.http.get(url, { headers: headers }).pipe(operators.catchError(function (error) { return rxjs.throwError(error); }), operators.map(function (methodList) { return methodList.payments; }), this.converter.pipeableMany(PAYMENT_DETAILS_NORMALIZER));
        };
        OccUserPaymentAdapter.prototype.delete = function (userId, paymentMethodID) {
            var url = this.occEndpoints.buildUrl('paymentDetail', {
                urlParams: { userId: userId, paymentDetailId: paymentMethodID },
            });
            var headers = new i1$3.HttpHeaders({
                'Content-Type': 'application/json',
            });
            return this.http
                .delete(url, { headers: headers })
                .pipe(operators.catchError(function (error) { return rxjs.throwError(error); }));
        };
        OccUserPaymentAdapter.prototype.setDefault = function (userId, paymentMethodID) {
            var url = this.occEndpoints.buildUrl('paymentDetail', {
                urlParams: { userId: userId, paymentDetailId: paymentMethodID },
            });
            var headers = new i1$3.HttpHeaders({
                'Content-Type': 'application/json',
            });
            return this.http
                .patch(url, 
            // TODO: Remove billingAddress property
            { billingAddress: { titleCode: 'mr' }, defaultPayment: true }, { headers: headers })
                .pipe(operators.catchError(function (error) { return rxjs.throwError(error); }));
        };
        return OccUserPaymentAdapter;
    }());
    OccUserPaymentAdapter.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccUserPaymentAdapter, deps: [{ token: i1__namespace$3.HttpClient }, { token: OccEndpointsService }, { token: ConverterService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    OccUserPaymentAdapter.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccUserPaymentAdapter });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccUserPaymentAdapter, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: i1__namespace$3.HttpClient }, { type: OccEndpointsService }, { type: ConverterService }]; } });

    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var REPLENISHMENT_ORDER_HISTORY_NORMALIZER = new i0.InjectionToken('ReplenishmentOrderHistoryNormalizer');

    /**
     * @deprecated since 4.2 - use OccReplenishmentOrderAdapter in @spartacus/order/occ instead
     */
    var OccUserReplenishmentOrderAdapter = /** @class */ (function () {
        function OccUserReplenishmentOrderAdapter(http, occEndpoints, converter) {
            this.http = http;
            this.occEndpoints = occEndpoints;
            this.converter = converter;
        }
        OccUserReplenishmentOrderAdapter.prototype.load = function (userId, replenishmentOrderCode) {
            return this.http
                .get(this.occEndpoints.buildUrl('replenishmentOrderDetails', {
                urlParams: { userId: userId, replenishmentOrderCode: replenishmentOrderCode },
            }))
                .pipe(this.converter.pipeable(REPLENISHMENT_ORDER_NORMALIZER));
        };
        OccUserReplenishmentOrderAdapter.prototype.loadReplenishmentDetailsHistory = function (userId, replenishmentOrderCode, pageSize, currentPage, sort) {
            var params = {};
            if (pageSize) {
                params['pageSize'] = pageSize.toString();
            }
            if (currentPage) {
                params['currentPage'] = currentPage.toString();
            }
            if (sort) {
                params['sort'] = sort.toString();
            }
            return this.http
                .get(this.occEndpoints.buildUrl('replenishmentOrderDetailsHistory', {
                urlParams: { userId: userId, replenishmentOrderCode: replenishmentOrderCode },
                queryParams: params,
            }))
                .pipe(this.converter.pipeable(ORDER_HISTORY_NORMALIZER));
        };
        OccUserReplenishmentOrderAdapter.prototype.cancelReplenishmentOrder = function (userId, replenishmentOrderCode) {
            var headers = new i1$3.HttpHeaders().set('Content-Type', 'application/json');
            return this.http
                .patch(this.occEndpoints.buildUrl('cancelReplenishmentOrder', {
                urlParams: { userId: userId, replenishmentOrderCode: replenishmentOrderCode },
            }), {}, { headers: headers })
                .pipe(this.converter.pipeable(REPLENISHMENT_ORDER_NORMALIZER));
        };
        OccUserReplenishmentOrderAdapter.prototype.loadHistory = function (userId, pageSize, currentPage, sort) {
            var params = {};
            if (pageSize) {
                params['pageSize'] = pageSize.toString();
            }
            if (currentPage) {
                params['currentPage'] = currentPage.toString();
            }
            if (sort) {
                params['sort'] = sort.toString();
            }
            var url = this.occEndpoints.buildUrl('replenishmentOrderHistory', {
                urlParams: { userId: userId },
                queryParams: params,
            });
            return this.http
                .get(url)
                .pipe(this.converter.pipeable(REPLENISHMENT_ORDER_HISTORY_NORMALIZER));
        };
        return OccUserReplenishmentOrderAdapter;
    }());
    OccUserReplenishmentOrderAdapter.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccUserReplenishmentOrderAdapter, deps: [{ token: i1__namespace$3.HttpClient }, { token: OccEndpointsService }, { token: ConverterService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    OccUserReplenishmentOrderAdapter.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccUserReplenishmentOrderAdapter });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccUserReplenishmentOrderAdapter, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: i1__namespace$3.HttpClient }, { type: OccEndpointsService }, { type: ConverterService }]; } });

    var UserAddressAdapter = /** @class */ (function () {
        function UserAddressAdapter() {
        }
        return UserAddressAdapter;
    }());

    var UserConsentAdapter = /** @class */ (function () {
        function UserConsentAdapter() {
        }
        return UserConsentAdapter;
    }());

    var UserCostCenterAdapter = /** @class */ (function () {
        function UserCostCenterAdapter() {
        }
        return UserCostCenterAdapter;
    }());

    var CustomerCouponAdapter = /** @class */ (function () {
        function CustomerCouponAdapter() {
        }
        return CustomerCouponAdapter;
    }());

    var UserInterestsAdapter = /** @class */ (function () {
        function UserInterestsAdapter() {
        }
        return UserInterestsAdapter;
    }());

    /**
     * @deprecated since 4.2 - use OrderAdapter in @spartacus/order/core
     */
    var UserOrderAdapter = /** @class */ (function () {
        function UserOrderAdapter() {
        }
        return UserOrderAdapter;
    }());

    var UserPaymentAdapter = /** @class */ (function () {
        function UserPaymentAdapter() {
        }
        return UserPaymentAdapter;
    }());

    /**
     * @deprecated since 4.2 - use ReplenishmentOrderAdapter in @spartacus/order/core
     */
    var UserReplenishmentOrderAdapter = /** @class */ (function () {
        function UserReplenishmentOrderAdapter() {
        }
        return UserReplenishmentOrderAdapter;
    }());

    /**
     * @deprecated since 4.2 - use ReplenishmentOrderConnector in @spartacus/order/core
     */
    var UserReplenishmentOrderConnector = /** @class */ (function () {
        function UserReplenishmentOrderConnector(adapter) {
            this.adapter = adapter;
        }
        UserReplenishmentOrderConnector.prototype.load = function (userId, replenishmentOrderCode) {
            return this.adapter.load(userId, replenishmentOrderCode);
        };
        UserReplenishmentOrderConnector.prototype.loadReplenishmentDetailsHistory = function (userId, replenishmentOrderCode, pageSize, currentPage, sort) {
            return this.adapter.loadReplenishmentDetailsHistory(userId, replenishmentOrderCode, pageSize, currentPage, sort);
        };
        UserReplenishmentOrderConnector.prototype.cancelReplenishmentOrder = function (userId, replenishmentOrderCode) {
            return this.adapter.cancelReplenishmentOrder(userId, replenishmentOrderCode);
        };
        UserReplenishmentOrderConnector.prototype.loadHistory = function (userId, pageSize, currentPage, sort) {
            return this.adapter.loadHistory(userId, pageSize, currentPage, sort);
        };
        return UserReplenishmentOrderConnector;
    }());
    UserReplenishmentOrderConnector.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserReplenishmentOrderConnector, deps: [{ token: UserReplenishmentOrderAdapter }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    UserReplenishmentOrderConnector.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserReplenishmentOrderConnector, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserReplenishmentOrderConnector, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: UserReplenishmentOrderAdapter }]; } });

    var OccAddressListNormalizer = /** @class */ (function () {
        function OccAddressListNormalizer(converter) {
            this.converter = converter;
        }
        OccAddressListNormalizer.prototype.convert = function (source, target) {
            var _this = this;
            if (target === undefined) {
                target = Object.assign({}, source);
            }
            target.values = source.addresses.map(function (address) { return (Object.assign({}, _this.converter.convert(address, ADDRESS_NORMALIZER))); });
            return target;
        };
        return OccAddressListNormalizer;
    }());
    OccAddressListNormalizer.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccAddressListNormalizer, deps: [{ token: ConverterService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    OccAddressListNormalizer.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccAddressListNormalizer, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccAddressListNormalizer, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: ConverterService }]; } });

    var defaultOccUserConfig = {
        backend: {
            occ: {
                endpoints: {
                    /* eslint-disable max-len */
                    paymentDetailsAll: 'users/${userId}/paymentdetails',
                    paymentDetail: 'users/${userId}/paymentdetails/${paymentDetailId}',
                    /** @deprecated since 4.2, use order lib instead */
                    orderHistory: 'users/${userId}/orders',
                    /** @deprecated since 4.2, use order lib instead */
                    orderDetail: 'users/${userId}/orders/${orderId}?fields=FULL',
                    anonymousConsentTemplates: 'users/anonymous/consenttemplates',
                    consentTemplates: 'users/${userId}/consenttemplates',
                    consents: 'users/${userId}/consents',
                    consentDetail: 'users/${userId}/consents/${consentId}',
                    addresses: 'users/${userId}/addresses',
                    addressDetail: 'users/${userId}/addresses/${addressId}',
                    addressVerification: 'users/${userId}/addresses/verification',
                    /** @deprecated since 4.2, use order lib instead */
                    consignmentTracking: 'users/${userId}/orders/${orderCode}/consignments/${consignmentCode}/tracking',
                    customerCoupons: 'users/${userId}/customercoupons',
                    claimCoupon: 'users/${userId}/customercoupons/${couponCode}/claim',
                    couponNotification: 'users/${userId}/customercoupons/${couponCode}/notification',
                    notificationPreference: 'users/${userId}/notificationpreferences',
                    productInterests: 'users/${userId}/productinterests',
                    getProductInterests: 'users/${userId}/productinterests?fields=sorts,pagination,results(productInterestEntry,product(code))',
                    /** @deprecated since 4.2, use order lib instead */
                    cancelOrder: 'users/${userId}/orders/${orderId}/cancellation',
                    /** @deprecated since 4.2, use order lib instead */
                    returnOrder: 'users/${userId}/orderReturns?fields=BASIC,returnEntries(BASIC,refundAmount(formattedValue),orderEntry(basePrice(formattedValue),product(name,code,baseOptions,images(DEFAULT,galleryIndex)))),deliveryCost(formattedValue),totalPrice(formattedValue),subTotal(formattedValue)',
                    /** @deprecated since 4.2, use order lib instead */
                    orderReturns: 'users/${userId}/orderReturns?fields=BASIC',
                    /** @deprecated since 4.2, use order lib instead */
                    orderReturnDetail: 'users/${userId}/orderReturns/${returnRequestCode}?fields=BASIC,returnEntries(BASIC,refundAmount(formattedValue),orderEntry(basePrice(formattedValue),product(name,code,baseOptions,images(DEFAULT,galleryIndex)))),deliveryCost(formattedValue),totalPrice(formattedValue),subTotal(formattedValue)',
                    /** @deprecated since 4.2, use order lib instead */
                    cancelReturn: 'users/${userId}/orderReturns/${returnRequestCode}',
                    /* eslint-enable */
                },
            },
        },
    };

    var OccUserCostCenterAdapter = /** @class */ (function () {
        function OccUserCostCenterAdapter(http, occEndpoints, converter) {
            this.http = http;
            this.occEndpoints = occEndpoints;
            this.converter = converter;
        }
        OccUserCostCenterAdapter.prototype.loadActiveList = function (userId) {
            return this.http
                .get(this.getCostCentersEndpoint(userId))
                .pipe(this.converter.pipeable(COST_CENTERS_NORMALIZER));
        };
        OccUserCostCenterAdapter.prototype.getCostCentersEndpoint = function (userId, params) {
            return this.occEndpoints.buildUrl('getActiveCostCenters', {
                urlParams: { userId: userId },
                queryParams: params,
            });
        };
        return OccUserCostCenterAdapter;
    }());
    OccUserCostCenterAdapter.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccUserCostCenterAdapter, deps: [{ token: i1__namespace$3.HttpClient }, { token: OccEndpointsService }, { token: ConverterService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    OccUserCostCenterAdapter.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccUserCostCenterAdapter });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OccUserCostCenterAdapter, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: i1__namespace$3.HttpClient }, { type: OccEndpointsService }, { type: ConverterService }]; } });

    /**
     * @deprecated since 4.2 - use UserOccTransitional_4_2_Module wiith order lib instead
     */
    var UserOccTransitionalModule = /** @class */ (function () {
        function UserOccTransitionalModule() {
        }
        return UserOccTransitionalModule;
    }());
    UserOccTransitionalModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserOccTransitionalModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    UserOccTransitionalModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserOccTransitionalModule, imports: [i6.CommonModule] });
    UserOccTransitionalModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserOccTransitionalModule, providers: [
            provideDefaultConfig(defaultOccUserConfig),
            { provide: UserAddressAdapter, useClass: OccUserAddressAdapter },
            { provide: UserConsentAdapter, useClass: OccUserConsentAdapter },
            {
                provide: AnonymousConsentTemplatesAdapter,
                useClass: OccAnonymousConsentTemplatesAdapter,
            },
            {
                provide: UserPaymentAdapter,
                useClass: OccUserPaymentAdapter,
            },
            { provide: UserOrderAdapter, useClass: OccUserOrderAdapter },
            { provide: CustomerCouponAdapter, useClass: OccCustomerCouponAdapter },
            {
                provide: UserNotificationPreferenceAdapter,
                useClass: OccUserNotificationPreferenceAdapter,
            },
            { provide: UserInterestsAdapter, useClass: OccUserInterestsAdapter },
            { provide: UserCostCenterAdapter, useClass: OccUserCostCenterAdapter },
            {
                provide: PRODUCT_INTERESTS_NORMALIZER,
                useExisting: OccUserInterestsNormalizer,
                multi: true,
            },
            {
                provide: ORDER_RETURN_REQUEST_NORMALIZER,
                useExisting: OccReturnRequestNormalizer,
                multi: true,
            },
            {
                provide: ANONYMOUS_CONSENT_NORMALIZER,
                useExisting: AnonymousConsentNormalizer,
                multi: true,
            },
            {
                provide: ADDRESS_LIST_NORMALIZER,
                useExisting: OccAddressListNormalizer,
                multi: true,
            },
            {
                provide: UserReplenishmentOrderAdapter,
                useClass: OccUserReplenishmentOrderAdapter,
            },
        ], imports: [[i6.CommonModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserOccTransitionalModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [i6.CommonModule],
                        providers: [
                            provideDefaultConfig(defaultOccUserConfig),
                            { provide: UserAddressAdapter, useClass: OccUserAddressAdapter },
                            { provide: UserConsentAdapter, useClass: OccUserConsentAdapter },
                            {
                                provide: AnonymousConsentTemplatesAdapter,
                                useClass: OccAnonymousConsentTemplatesAdapter,
                            },
                            {
                                provide: UserPaymentAdapter,
                                useClass: OccUserPaymentAdapter,
                            },
                            { provide: UserOrderAdapter, useClass: OccUserOrderAdapter },
                            { provide: CustomerCouponAdapter, useClass: OccCustomerCouponAdapter },
                            {
                                provide: UserNotificationPreferenceAdapter,
                                useClass: OccUserNotificationPreferenceAdapter,
                            },
                            { provide: UserInterestsAdapter, useClass: OccUserInterestsAdapter },
                            { provide: UserCostCenterAdapter, useClass: OccUserCostCenterAdapter },
                            {
                                provide: PRODUCT_INTERESTS_NORMALIZER,
                                useExisting: OccUserInterestsNormalizer,
                                multi: true,
                            },
                            {
                                provide: ORDER_RETURN_REQUEST_NORMALIZER,
                                useExisting: OccReturnRequestNormalizer,
                                multi: true,
                            },
                            {
                                provide: ANONYMOUS_CONSENT_NORMALIZER,
                                useExisting: AnonymousConsentNormalizer,
                                multi: true,
                            },
                            {
                                provide: ADDRESS_LIST_NORMALIZER,
                                useExisting: OccAddressListNormalizer,
                                multi: true,
                            },
                            {
                                provide: UserReplenishmentOrderAdapter,
                                useClass: OccUserReplenishmentOrderAdapter,
                            },
                        ],
                    }]
            }] });

    var UserOccTransitional_4_2_Module = /** @class */ (function () {
        function UserOccTransitional_4_2_Module() {
        }
        return UserOccTransitional_4_2_Module;
    }());
    UserOccTransitional_4_2_Module.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserOccTransitional_4_2_Module, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    UserOccTransitional_4_2_Module.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserOccTransitional_4_2_Module, imports: [i6.CommonModule] });
    UserOccTransitional_4_2_Module.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserOccTransitional_4_2_Module, providers: [
            provideDefaultConfig(defaultOccUserConfig),
            { provide: UserAddressAdapter, useClass: OccUserAddressAdapter },
            { provide: UserConsentAdapter, useClass: OccUserConsentAdapter },
            {
                provide: AnonymousConsentTemplatesAdapter,
                useClass: OccAnonymousConsentTemplatesAdapter,
            },
            {
                provide: UserPaymentAdapter,
                useClass: OccUserPaymentAdapter,
            },
            { provide: CustomerCouponAdapter, useClass: OccCustomerCouponAdapter },
            {
                provide: UserNotificationPreferenceAdapter,
                useClass: OccUserNotificationPreferenceAdapter,
            },
            { provide: UserInterestsAdapter, useClass: OccUserInterestsAdapter },
            { provide: UserCostCenterAdapter, useClass: OccUserCostCenterAdapter },
            {
                provide: PRODUCT_INTERESTS_NORMALIZER,
                useExisting: OccUserInterestsNormalizer,
                multi: true,
            },
            {
                provide: ANONYMOUS_CONSENT_NORMALIZER,
                useExisting: AnonymousConsentNormalizer,
                multi: true,
            },
            {
                provide: ADDRESS_LIST_NORMALIZER,
                useExisting: OccAddressListNormalizer,
                multi: true,
            },
        ], imports: [[i6.CommonModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserOccTransitional_4_2_Module, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [i6.CommonModule],
                        providers: [
                            provideDefaultConfig(defaultOccUserConfig),
                            { provide: UserAddressAdapter, useClass: OccUserAddressAdapter },
                            { provide: UserConsentAdapter, useClass: OccUserConsentAdapter },
                            {
                                provide: AnonymousConsentTemplatesAdapter,
                                useClass: OccAnonymousConsentTemplatesAdapter,
                            },
                            {
                                provide: UserPaymentAdapter,
                                useClass: OccUserPaymentAdapter,
                            },
                            { provide: CustomerCouponAdapter, useClass: OccCustomerCouponAdapter },
                            {
                                provide: UserNotificationPreferenceAdapter,
                                useClass: OccUserNotificationPreferenceAdapter,
                            },
                            { provide: UserInterestsAdapter, useClass: OccUserInterestsAdapter },
                            { provide: UserCostCenterAdapter, useClass: OccUserCostCenterAdapter },
                            {
                                provide: PRODUCT_INTERESTS_NORMALIZER,
                                useExisting: OccUserInterestsNormalizer,
                                multi: true,
                            },
                            {
                                provide: ANONYMOUS_CONSENT_NORMALIZER,
                                useExisting: AnonymousConsentNormalizer,
                                multi: true,
                            },
                            {
                                provide: ADDRESS_LIST_NORMALIZER,
                                useExisting: OccAddressListNormalizer,
                                multi: true,
                            },
                        ],
                    }]
            }] });

    var UserOccModule = /** @class */ (function () {
        function UserOccModule() {
        }
        return UserOccModule;
    }());
    UserOccModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserOccModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    UserOccModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserOccModule, imports: [i6.CommonModule] });
    UserOccModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserOccModule, providers: [
            provideDefaultConfig(defaultOccUserConfig),
            { provide: UserAddressAdapter, useClass: OccUserAddressAdapter },
            { provide: UserConsentAdapter, useClass: OccUserConsentAdapter },
            {
                provide: AnonymousConsentTemplatesAdapter,
                useClass: OccAnonymousConsentTemplatesAdapter,
            },
            {
                provide: UserPaymentAdapter,
                useClass: OccUserPaymentAdapter,
            },
            { provide: UserOrderAdapter, useClass: OccUserOrderAdapter },
            { provide: CustomerCouponAdapter, useClass: OccCustomerCouponAdapter },
            {
                provide: UserNotificationPreferenceAdapter,
                useClass: OccUserNotificationPreferenceAdapter,
            },
            { provide: UserInterestsAdapter, useClass: OccUserInterestsAdapter },
            { provide: UserCostCenterAdapter, useClass: OccUserCostCenterAdapter },
            {
                provide: PRODUCT_INTERESTS_NORMALIZER,
                useExisting: OccUserInterestsNormalizer,
                multi: true,
            },
            {
                provide: ORDER_RETURN_REQUEST_NORMALIZER,
                useExisting: OccReturnRequestNormalizer,
                multi: true,
            },
            {
                provide: ANONYMOUS_CONSENT_NORMALIZER,
                useExisting: AnonymousConsentNormalizer,
                multi: true,
            },
            {
                provide: ADDRESS_LIST_NORMALIZER,
                useExisting: OccAddressListNormalizer,
                multi: true,
            },
            {
                provide: UserReplenishmentOrderAdapter,
                useClass: OccUserReplenishmentOrderAdapter,
            },
        ], imports: [[i6.CommonModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserOccModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [i6.CommonModule],
                        providers: [
                            provideDefaultConfig(defaultOccUserConfig),
                            { provide: UserAddressAdapter, useClass: OccUserAddressAdapter },
                            { provide: UserConsentAdapter, useClass: OccUserConsentAdapter },
                            {
                                provide: AnonymousConsentTemplatesAdapter,
                                useClass: OccAnonymousConsentTemplatesAdapter,
                            },
                            {
                                provide: UserPaymentAdapter,
                                useClass: OccUserPaymentAdapter,
                            },
                            { provide: UserOrderAdapter, useClass: OccUserOrderAdapter },
                            { provide: CustomerCouponAdapter, useClass: OccCustomerCouponAdapter },
                            {
                                provide: UserNotificationPreferenceAdapter,
                                useClass: OccUserNotificationPreferenceAdapter,
                            },
                            { provide: UserInterestsAdapter, useClass: OccUserInterestsAdapter },
                            { provide: UserCostCenterAdapter, useClass: OccUserCostCenterAdapter },
                            {
                                provide: PRODUCT_INTERESTS_NORMALIZER,
                                useExisting: OccUserInterestsNormalizer,
                                multi: true,
                            },
                            {
                                provide: ORDER_RETURN_REQUEST_NORMALIZER,
                                useExisting: OccReturnRequestNormalizer,
                                multi: true,
                            },
                            {
                                provide: ANONYMOUS_CONSENT_NORMALIZER,
                                useExisting: AnonymousConsentNormalizer,
                                multi: true,
                            },
                            {
                                provide: ADDRESS_LIST_NORMALIZER,
                                useExisting: OccAddressListNormalizer,
                                multi: true,
                            },
                            {
                                provide: UserReplenishmentOrderAdapter,
                                useClass: OccUserReplenishmentOrderAdapter,
                            },
                        ],
                    }]
            }] });

    var defaultOccConfig = {
        backend: {
            occ: {
                prefix: '/occ/v2/',
            },
            media: {},
        },
    };

    function occConfigValidator(config) {
        if (config.backend === undefined ||
            config.backend.occ === undefined ||
            config.backend.occ.baseUrl === undefined) {
            return 'Please configure backend.occ.baseUrl before using storefront library!';
        }
    }

    /**
     * Http interceptor to add cookies to all cross-site requests.
     */
    var WithCredentialsInterceptor = /** @class */ (function () {
        function WithCredentialsInterceptor(config) {
            this.config = config;
        }
        /**
         * Intercepts each request and adds the `withCredential` flag to it
         * if it hasn't been added already.
         */
        WithCredentialsInterceptor.prototype.intercept = function (request, next) {
            if (this.requiresWithCredentials(request)) {
                request = request.clone({
                    withCredentials: true,
                });
            }
            return next.handle(request);
        };
        /**
         * indicates whether the request should use the WithCredentials flag.
         */
        WithCredentialsInterceptor.prototype.requiresWithCredentials = function (request) {
            var _a, _b;
            return (((_a = this.occConfig) === null || _a === void 0 ? void 0 : _a.useWithCredentials) &&
                request.url.indexOf((_b = this.occConfig) === null || _b === void 0 ? void 0 : _b.prefix) > -1);
        };
        Object.defineProperty(WithCredentialsInterceptor.prototype, "occConfig", {
            get: function () {
                return this.config.backend.occ;
            },
            enumerable: false,
            configurable: true
        });
        return WithCredentialsInterceptor;
    }());
    WithCredentialsInterceptor.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: WithCredentialsInterceptor, deps: [{ token: OccConfig }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    WithCredentialsInterceptor.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: WithCredentialsInterceptor, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: WithCredentialsInterceptor, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }], ctorParameters: function () { return [{ type: OccConfig }]; } });

    var BaseOccModule = /** @class */ (function () {
        function BaseOccModule() {
        }
        BaseOccModule.forRoot = function () {
            return {
                ngModule: BaseOccModule,
                providers: [
                    {
                        provide: i1$3.HTTP_INTERCEPTORS,
                        useExisting: WithCredentialsInterceptor,
                        multi: true,
                    },
                    provideDefaultConfig(defaultOccConfig),
                    provideConfigValidator(occConfigValidator),
                ],
            };
        };
        return BaseOccModule;
    }());
    BaseOccModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: BaseOccModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    BaseOccModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: BaseOccModule, imports: [CmsOccModule, SiteContextOccModule] });
    BaseOccModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: BaseOccModule, imports: [[CmsOccModule, SiteContextOccModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: BaseOccModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [CmsOccModule, SiteContextOccModule],
                    }]
            }] });

    var OCC_BASE_URL_META_TAG_NAME = 'occ-backend-base-url';
    var OCC_BASE_URL_META_TAG_PLACEHOLDER = 'OCC_BACKEND_BASE_URL_VALUE';
    var MEDIA_BASE_URL_META_TAG_NAME = 'media-backend-base-url';
    var MEDIA_BASE_URL_META_TAG_PLACEHOLDER = 'MEDIA_BACKEND_BASE_URL_VALUE';
    function occServerConfigFromMetaTagFactory(meta) {
        var baseUrl = getMetaTagContent(OCC_BASE_URL_META_TAG_NAME, meta);
        return baseUrl && baseUrl !== OCC_BASE_URL_META_TAG_PLACEHOLDER
            ? { backend: { occ: { baseUrl: baseUrl } } }
            : {};
    }
    function mediaServerConfigFromMetaTagFactory(meta) {
        var baseUrl = getMetaTagContent(MEDIA_BASE_URL_META_TAG_NAME, meta);
        return baseUrl && baseUrl !== MEDIA_BASE_URL_META_TAG_PLACEHOLDER
            ? { backend: { media: { baseUrl: baseUrl } } }
            : {};
    }
    function getMetaTagContent(name, meta) {
        var metaTag = meta.getTag("name=\"" + name + "\"");
        return metaTag && metaTag.content;
    }
    function provideConfigFromMetaTags() {
        return [
            provideConfigFactory(occServerConfigFromMetaTagFactory, [platformBrowser.Meta]),
            provideConfigFactory(mediaServerConfigFromMetaTagFactory, [platformBrowser.Meta]),
        ];
    }

    var MetaTagConfigModule = /** @class */ (function () {
        function MetaTagConfigModule() {
        }
        MetaTagConfigModule.forRoot = function () {
            return {
                ngModule: MetaTagConfigModule,
                providers: __spreadArray([], __read(provideConfigFromMetaTags())),
            };
        };
        return MetaTagConfigModule;
    }());
    MetaTagConfigModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: MetaTagConfigModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    MetaTagConfigModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: MetaTagConfigModule });
    MetaTagConfigModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: MetaTagConfigModule });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: MetaTagConfigModule, decorators: [{
                type: i0.NgModule,
                args: [{}]
            }] });

    var LoadingScopesService = /** @class */ (function () {
        function LoadingScopesService(config) {
            this.config = config;
        }
        /**
         * Aims to expand scopes based on loading scopes config.
         *
         * I.e. if 'details' scope includes 'list' scope by configuration, it'll return ['details', 'list']
         *
         * If scope data overlaps with each other, the data should be merged in the order of scopes provided,
         * i.e. the last scope is merged last, overwriting parts of the data already provided by preceding scope.
         * It should apply also to implicit scopes (that are included by configuration).
         *
         * @param model
         * @param scopes
         */
        LoadingScopesService.prototype.expand = function (model, scopes) {
            var e_1, _f;
            var _a, _b, _c, _d;
            var scopesConfig = (_c = (_b = (_a = this.config) === null || _a === void 0 ? void 0 : _a.backend) === null || _b === void 0 ? void 0 : _b.loadingScopes) === null || _c === void 0 ? void 0 : _c[model];
            if (scopesConfig) {
                var expandedScopes = __spreadArray([], __read(scopes));
                var i = expandedScopes.length;
                while (i > 0) {
                    i--;
                    var includedScopes = (_d = scopesConfig[expandedScopes[i]]) === null || _d === void 0 ? void 0 : _d.include;
                    if (includedScopes) {
                        try {
                            for (var includedScopes_1 = (e_1 = void 0, __values(includedScopes)), includedScopes_1_1 = includedScopes_1.next(); !includedScopes_1_1.done; includedScopes_1_1 = includedScopes_1.next()) {
                                var includedScope = includedScopes_1_1.value;
                                if (!expandedScopes.includes(includedScope)) {
                                    expandedScopes.splice(i, 0, includedScope);
                                    i++;
                                }
                            }
                        }
                        catch (e_1_1) { e_1 = { error: e_1_1 }; }
                        finally {
                            try {
                                if (includedScopes_1_1 && !includedScopes_1_1.done && (_f = includedScopes_1.return)) _f.call(includedScopes_1);
                            }
                            finally { if (e_1) throw e_1.error; }
                        }
                    }
                }
                return expandedScopes;
            }
            return scopes;
        };
        /**
         * Return maxAge for product scope in milliseconds
         *
         * @param model
         * @param scope
         */
        LoadingScopesService.prototype.getMaxAge = function (model, scope) {
            var _a, _b, _c, _d, _e;
            var configuredMaxAge = (_e = (_d = (_c = (_b = (_a = this.config.backend) === null || _a === void 0 ? void 0 : _a.loadingScopes) === null || _b === void 0 ? void 0 : _b[model]) === null || _c === void 0 ? void 0 : _c[scope]) === null || _d === void 0 ? void 0 : _d.maxAge) !== null && _e !== void 0 ? _e : 0;
            return configuredMaxAge * 1000;
        };
        /**
         *
         * Returns the configured triggers for which to reload the product.
         *
         * @param model for which to look up the scopes (usually a 'product')
         * @param scope for which to look up the config
         * @returns the configured triggers, or an empty array if not configured
         */
        LoadingScopesService.prototype.getReloadTriggers = function (model, scope) {
            var _a, _b, _c, _d, _e;
            return (_e = (_d = (_c = (_b = (_a = this.config.backend) === null || _a === void 0 ? void 0 : _a.loadingScopes) === null || _b === void 0 ? void 0 : _b[model]) === null || _c === void 0 ? void 0 : _c[scope]) === null || _d === void 0 ? void 0 : _d.reloadOn) !== null && _e !== void 0 ? _e : [];
        };
        return LoadingScopesService;
    }());
    LoadingScopesService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: LoadingScopesService, deps: [{ token: OccConfig }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    LoadingScopesService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: LoadingScopesService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: LoadingScopesService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: OccConfig }]; } });

    function getReducers$2() {
        return entityLoaderReducer(PROCESS_FEATURE);
    }
    var reducerToken$2 = new i0.InjectionToken('ProcessReducers');
    var reducerProvider$2 = {
        provide: reducerToken$2,
        useFactory: getReducers$2,
    };

    var ProcessStoreModule = /** @class */ (function () {
        function ProcessStoreModule() {
        }
        return ProcessStoreModule;
    }());
    ProcessStoreModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProcessStoreModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    ProcessStoreModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProcessStoreModule, imports: [StateModule, i1__namespace$2.StoreFeatureModule] });
    ProcessStoreModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProcessStoreModule, providers: [reducerProvider$2], imports: [[StateModule, i1.StoreModule.forFeature(PROCESS_FEATURE, reducerToken$2)]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProcessStoreModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [StateModule, i1.StoreModule.forFeature(PROCESS_FEATURE, reducerToken$2)],
                        providers: [reducerProvider$2],
                    }]
            }] });

    var ProcessModule = /** @class */ (function () {
        function ProcessModule() {
        }
        ProcessModule.forRoot = function () {
            return {
                ngModule: ProcessModule,
                providers: [],
            };
        };
        return ProcessModule;
    }());
    ProcessModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProcessModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    ProcessModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProcessModule, imports: [ProcessStoreModule] });
    ProcessModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProcessModule, imports: [[ProcessStoreModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProcessModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [ProcessStoreModule],
                    }]
            }] });

    var ProductConnector = /** @class */ (function () {
        function ProductConnector(adapter) {
            this.adapter = adapter;
        }
        ProductConnector.prototype.get = function (productCode, scope) {
            if (scope === void 0) { scope = ''; }
            return this.adapter.load(productCode, scope);
        };
        ProductConnector.prototype.getMany = function (products) {
            var _this = this;
            if (!this.adapter.loadMany) {
                return products.map(function (product) { return (Object.assign(Object.assign({}, product), { data$: _this.adapter.load(product.code, product.scope) })); });
            }
            return this.adapter.loadMany(products);
        };
        return ProductConnector;
    }());
    ProductConnector.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductConnector, deps: [{ token: ProductAdapter }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ProductConnector.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductConnector, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductConnector, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: ProductAdapter }]; } });

    var ProductReferencesConnector = /** @class */ (function () {
        function ProductReferencesConnector(adapter) {
            this.adapter = adapter;
        }
        ProductReferencesConnector.prototype.get = function (productCode, referenceType, pageSize) {
            return this.adapter.load(productCode, referenceType, pageSize);
        };
        return ProductReferencesConnector;
    }());
    ProductReferencesConnector.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductReferencesConnector, deps: [{ token: ProductReferencesAdapter }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ProductReferencesConnector.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductReferencesConnector, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductReferencesConnector, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: ProductReferencesAdapter }]; } });

    var ProductReviewsConnector = /** @class */ (function () {
        function ProductReviewsConnector(adapter) {
            this.adapter = adapter;
        }
        ProductReviewsConnector.prototype.get = function (productCode, maxCount) {
            return this.adapter.load(productCode, maxCount);
        };
        ProductReviewsConnector.prototype.add = function (productCode, review) {
            return this.adapter.post(productCode, review);
        };
        return ProductReviewsConnector;
    }());
    ProductReviewsConnector.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductReviewsConnector, deps: [{ token: ProductReviewsAdapter }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ProductReviewsConnector.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductReviewsConnector, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductReviewsConnector, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: ProductReviewsAdapter }]; } });

    var ProductSearchConnector = /** @class */ (function () {
        function ProductSearchConnector(adapter) {
            this.adapter = adapter;
        }
        ProductSearchConnector.prototype.search = function (query, searchConfig) {
            return this.adapter.search(query, searchConfig);
        };
        ProductSearchConnector.prototype.getSuggestions = function (term, pageSize) {
            return this.adapter.loadSuggestions(term, pageSize);
        };
        return ProductSearchConnector;
    }());
    ProductSearchConnector.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductSearchConnector, deps: [{ token: ProductSearchAdapter }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ProductSearchConnector.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductSearchConnector, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductSearchConnector, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: ProductSearchAdapter }]; } });

    /**
     * Indicates that a user select or unselect a facet value
     */
    var FacetChangedEvent = /** @class */ (function (_super) {
        __extends(FacetChangedEvent, _super);
        function FacetChangedEvent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return FacetChangedEvent;
    }(CxEvent));
    /**
     * Event's type
     */
    FacetChangedEvent.type = 'FacetChangedEvent';

    var LOAD_PRODUCT_REFERENCES = '[Product] Load Product References Data';
    var LOAD_PRODUCT_REFERENCES_FAIL = '[Product] Load Product References Data Fail';
    var LOAD_PRODUCT_REFERENCES_SUCCESS = '[Product] Load Product References Data Success';
    var CLEAN_PRODUCT_REFERENCES = '[Product] Clean Product References';
    var LoadProductReferences = /** @class */ (function () {
        function LoadProductReferences(payload) {
            this.payload = payload;
            this.type = LOAD_PRODUCT_REFERENCES;
        }
        return LoadProductReferences;
    }());
    var LoadProductReferencesFail = /** @class */ (function () {
        function LoadProductReferencesFail(payload) {
            this.payload = payload;
            this.type = LOAD_PRODUCT_REFERENCES_FAIL;
        }
        return LoadProductReferencesFail;
    }());
    var LoadProductReferencesSuccess = /** @class */ (function () {
        function LoadProductReferencesSuccess(payload) {
            this.payload = payload;
            this.type = LOAD_PRODUCT_REFERENCES_SUCCESS;
        }
        return LoadProductReferencesSuccess;
    }());
    var CleanProductReferences = /** @class */ (function () {
        function CleanProductReferences() {
            this.type = CLEAN_PRODUCT_REFERENCES;
        }
        return CleanProductReferences;
    }());

    var LOAD_PRODUCT_REVIEWS = '[Product] Load Product Reviews Data';
    var LOAD_PRODUCT_REVIEWS_FAIL = '[Product] Load Product Reviews Data Fail';
    var LOAD_PRODUCT_REVIEWS_SUCCESS = '[Product] Load Product Reviews Data Success';
    var POST_PRODUCT_REVIEW = '[Product] Post Product Review';
    var POST_PRODUCT_REVIEW_FAIL = '[Product] Post Product Review Fail';
    var POST_PRODUCT_REVIEW_SUCCESS = '[Product] Post Product Review Success';
    var LoadProductReviews = /** @class */ (function () {
        function LoadProductReviews(payload) {
            this.payload = payload;
            this.type = LOAD_PRODUCT_REVIEWS;
        }
        return LoadProductReviews;
    }());
    var LoadProductReviewsFail = /** @class */ (function () {
        function LoadProductReviewsFail(payload) {
            this.payload = payload;
            this.type = LOAD_PRODUCT_REVIEWS_FAIL;
        }
        return LoadProductReviewsFail;
    }());
    var LoadProductReviewsSuccess = /** @class */ (function () {
        function LoadProductReviewsSuccess(payload) {
            this.payload = payload;
            this.type = LOAD_PRODUCT_REVIEWS_SUCCESS;
        }
        return LoadProductReviewsSuccess;
    }());
    var PostProductReview = /** @class */ (function () {
        function PostProductReview(payload) {
            this.payload = payload;
            this.type = POST_PRODUCT_REVIEW;
        }
        return PostProductReview;
    }());
    var PostProductReviewFail = /** @class */ (function () {
        function PostProductReviewFail(payload) {
            this.payload = payload;
            this.type = POST_PRODUCT_REVIEW_FAIL;
        }
        return PostProductReviewFail;
    }());
    var PostProductReviewSuccess = /** @class */ (function () {
        function PostProductReviewSuccess(payload) {
            this.payload = payload;
            this.type = POST_PRODUCT_REVIEW_SUCCESS;
        }
        return PostProductReviewSuccess;
    }());

    var SEARCH_PRODUCTS = '[Product] Search Products';
    var SEARCH_PRODUCTS_FAIL = '[Product] Search Products Fail';
    var SEARCH_PRODUCTS_SUCCESS = '[Product] Search Products Success';
    var GET_PRODUCT_SUGGESTIONS = '[Product] Get Product Suggestions';
    var GET_PRODUCT_SUGGESTIONS_SUCCESS = '[Product] Get Product Suggestions Success';
    var GET_PRODUCT_SUGGESTIONS_FAIL = '[Product] Get Product Suggestions Fail';
    var CLEAR_PRODUCT_SEARCH_RESULT = '[Product] Clear Product Search Result';
    var SearchProducts = /** @class */ (function () {
        function SearchProducts(payload, auxiliary) {
            this.payload = payload;
            this.auxiliary = auxiliary;
            this.type = SEARCH_PRODUCTS;
        }
        return SearchProducts;
    }());
    var SearchProductsFail = /** @class */ (function () {
        function SearchProductsFail(payload, auxiliary) {
            this.payload = payload;
            this.auxiliary = auxiliary;
            this.type = SEARCH_PRODUCTS_FAIL;
        }
        return SearchProductsFail;
    }());
    var SearchProductsSuccess = /** @class */ (function () {
        function SearchProductsSuccess(payload, auxiliary) {
            this.payload = payload;
            this.auxiliary = auxiliary;
            this.type = SEARCH_PRODUCTS_SUCCESS;
        }
        return SearchProductsSuccess;
    }());
    var GetProductSuggestions = /** @class */ (function () {
        function GetProductSuggestions(payload) {
            this.payload = payload;
            this.type = GET_PRODUCT_SUGGESTIONS;
        }
        return GetProductSuggestions;
    }());
    var GetProductSuggestionsSuccess = /** @class */ (function () {
        function GetProductSuggestionsSuccess(payload) {
            this.payload = payload;
            this.type = GET_PRODUCT_SUGGESTIONS_SUCCESS;
        }
        return GetProductSuggestionsSuccess;
    }());
    var GetProductSuggestionsFail = /** @class */ (function () {
        function GetProductSuggestionsFail(payload) {
            this.payload = payload;
            this.type = GET_PRODUCT_SUGGESTIONS_FAIL;
        }
        return GetProductSuggestionsFail;
    }());
    var ClearProductSearchResult = /** @class */ (function () {
        function ClearProductSearchResult(payload) {
            if (payload === void 0) { payload = {
                clearPageResults: false,
                clearSearchboxResults: false,
            }; }
            this.payload = payload;
            this.type = CLEAR_PRODUCT_SEARCH_RESULT;
        }
        return ClearProductSearchResult;
    }());

    var EntityScopedLoaderActions;
    (function (EntityScopedLoaderActions) {
        function entityScopedLoadMeta(entityType, id, scope) {
            return Object.assign(Object.assign({}, entityLoadMeta(entityType, id)), { scope: scope });
        }
        EntityScopedLoaderActions.entityScopedLoadMeta = entityScopedLoadMeta;
        function entityScopedFailMeta(entityType, id, scope, error) {
            return Object.assign(Object.assign({}, entityFailMeta(entityType, id, error)), { scope: scope });
        }
        EntityScopedLoaderActions.entityScopedFailMeta = entityScopedFailMeta;
        function entityScopedSuccessMeta(entityType, id, scope) {
            return Object.assign(Object.assign({}, entitySuccessMeta(entityType, id)), { scope: scope });
        }
        EntityScopedLoaderActions.entityScopedSuccessMeta = entityScopedSuccessMeta;
        function entityScopedResetMeta(entityType, id, scope) {
            return Object.assign(Object.assign({}, entityResetMeta(entityType, id)), { scope: scope });
        }
        EntityScopedLoaderActions.entityScopedResetMeta = entityScopedResetMeta;
        var EntityScopedLoadAction = /** @class */ (function () {
            function EntityScopedLoadAction(entityType, id, scope) {
                this.type = ENTITY_LOAD_ACTION;
                this.meta = entityScopedLoadMeta(entityType, id, scope);
            }
            return EntityScopedLoadAction;
        }());
        EntityScopedLoaderActions.EntityScopedLoadAction = EntityScopedLoadAction;
        var EntityScopedFailAction = /** @class */ (function () {
            function EntityScopedFailAction(entityType, id, scope, error) {
                this.type = ENTITY_FAIL_ACTION;
                this.meta = entityScopedFailMeta(entityType, id, scope, error);
            }
            return EntityScopedFailAction;
        }());
        EntityScopedLoaderActions.EntityScopedFailAction = EntityScopedFailAction;
        var EntityScopedSuccessAction = /** @class */ (function () {
            function EntityScopedSuccessAction(entityType, id, scope, payload) {
                this.payload = payload;
                this.type = ENTITY_SUCCESS_ACTION;
                this.meta = entityScopedSuccessMeta(entityType, id, scope);
            }
            return EntityScopedSuccessAction;
        }());
        EntityScopedLoaderActions.EntityScopedSuccessAction = EntityScopedSuccessAction;
        var EntityScopedResetAction = /** @class */ (function () {
            function EntityScopedResetAction(entityType, id, scope) {
                this.type = ENTITY_RESET_ACTION;
                this.meta = entityScopedResetMeta(entityType, id, scope);
            }
            return EntityScopedResetAction;
        }());
        EntityScopedLoaderActions.EntityScopedResetAction = EntityScopedResetAction;
    })(EntityScopedLoaderActions || (EntityScopedLoaderActions = {}));

    var PRODUCT_FEATURE = 'product';
    var PRODUCT_DETAIL_ENTITY = '[Product] Detail Entity';

    var LOAD_PRODUCT = '[Product] Load Product Data';
    var LOAD_PRODUCT_FAIL = '[Product] Load Product Data Fail';
    var LOAD_PRODUCT_SUCCESS = '[Product] Load Product Data Success';
    var CLEAR_PRODUCT_PRICE = '[Product] Clear Product PRICE';
    var LoadProduct = /** @class */ (function (_super) {
        __extends(LoadProduct, _super);
        function LoadProduct(payload, scope) {
            if (scope === void 0) { scope = ''; }
            var _this = _super.call(this, PRODUCT_DETAIL_ENTITY, payload, scope) || this;
            _this.payload = payload;
            _this.type = LOAD_PRODUCT;
            return _this;
        }
        return LoadProduct;
    }(EntityScopedLoaderActions.EntityScopedLoadAction));
    var LoadProductFail = /** @class */ (function (_super) {
        __extends(LoadProductFail, _super);
        function LoadProductFail(productCode, payload, scope) {
            if (scope === void 0) { scope = ''; }
            var _this = _super.call(this, PRODUCT_DETAIL_ENTITY, productCode, scope, payload) || this;
            _this.payload = payload;
            _this.type = LOAD_PRODUCT_FAIL;
            return _this;
        }
        return LoadProductFail;
    }(EntityScopedLoaderActions.EntityScopedFailAction));
    var LoadProductSuccess = /** @class */ (function (_super) {
        __extends(LoadProductSuccess, _super);
        function LoadProductSuccess(payload, scope) {
            if (scope === void 0) { scope = ''; }
            var _this = _super.call(this, PRODUCT_DETAIL_ENTITY, payload.code, scope) || this;
            _this.payload = payload;
            _this.type = LOAD_PRODUCT_SUCCESS;
            return _this;
        }
        return LoadProductSuccess;
    }(EntityScopedLoaderActions.EntityScopedSuccessAction));
    var ClearProductPrice = /** @class */ (function (_super) {
        __extends(ClearProductPrice, _super);
        function ClearProductPrice() {
            var _this = _super.call(this, PRODUCT_DETAIL_ENTITY, undefined, "price" /* PRICE */) || this;
            _this.type = CLEAR_PRODUCT_PRICE;
            return _this;
        }
        return ClearProductPrice;
    }(EntityScopedLoaderActions.EntityScopedResetAction));

    var productGroup_actions = /*#__PURE__*/Object.freeze({
        __proto__: null,
        LOAD_PRODUCT_REFERENCES: LOAD_PRODUCT_REFERENCES,
        LOAD_PRODUCT_REFERENCES_FAIL: LOAD_PRODUCT_REFERENCES_FAIL,
        LOAD_PRODUCT_REFERENCES_SUCCESS: LOAD_PRODUCT_REFERENCES_SUCCESS,
        CLEAN_PRODUCT_REFERENCES: CLEAN_PRODUCT_REFERENCES,
        LoadProductReferences: LoadProductReferences,
        LoadProductReferencesFail: LoadProductReferencesFail,
        LoadProductReferencesSuccess: LoadProductReferencesSuccess,
        CleanProductReferences: CleanProductReferences,
        LOAD_PRODUCT_REVIEWS: LOAD_PRODUCT_REVIEWS,
        LOAD_PRODUCT_REVIEWS_FAIL: LOAD_PRODUCT_REVIEWS_FAIL,
        LOAD_PRODUCT_REVIEWS_SUCCESS: LOAD_PRODUCT_REVIEWS_SUCCESS,
        POST_PRODUCT_REVIEW: POST_PRODUCT_REVIEW,
        POST_PRODUCT_REVIEW_FAIL: POST_PRODUCT_REVIEW_FAIL,
        POST_PRODUCT_REVIEW_SUCCESS: POST_PRODUCT_REVIEW_SUCCESS,
        LoadProductReviews: LoadProductReviews,
        LoadProductReviewsFail: LoadProductReviewsFail,
        LoadProductReviewsSuccess: LoadProductReviewsSuccess,
        PostProductReview: PostProductReview,
        PostProductReviewFail: PostProductReviewFail,
        PostProductReviewSuccess: PostProductReviewSuccess,
        SEARCH_PRODUCTS: SEARCH_PRODUCTS,
        SEARCH_PRODUCTS_FAIL: SEARCH_PRODUCTS_FAIL,
        SEARCH_PRODUCTS_SUCCESS: SEARCH_PRODUCTS_SUCCESS,
        GET_PRODUCT_SUGGESTIONS: GET_PRODUCT_SUGGESTIONS,
        GET_PRODUCT_SUGGESTIONS_SUCCESS: GET_PRODUCT_SUGGESTIONS_SUCCESS,
        GET_PRODUCT_SUGGESTIONS_FAIL: GET_PRODUCT_SUGGESTIONS_FAIL,
        CLEAR_PRODUCT_SEARCH_RESULT: CLEAR_PRODUCT_SEARCH_RESULT,
        SearchProducts: SearchProducts,
        SearchProductsFail: SearchProductsFail,
        SearchProductsSuccess: SearchProductsSuccess,
        GetProductSuggestions: GetProductSuggestions,
        GetProductSuggestionsSuccess: GetProductSuggestionsSuccess,
        GetProductSuggestionsFail: GetProductSuggestionsFail,
        ClearProductSearchResult: ClearProductSearchResult,
        LOAD_PRODUCT: LOAD_PRODUCT,
        LOAD_PRODUCT_FAIL: LOAD_PRODUCT_FAIL,
        LOAD_PRODUCT_SUCCESS: LOAD_PRODUCT_SUCCESS,
        CLEAR_PRODUCT_PRICE: CLEAR_PRODUCT_PRICE,
        LoadProduct: LoadProduct,
        LoadProductFail: LoadProductFail,
        LoadProductSuccess: LoadProductSuccess,
        ClearProductPrice: ClearProductPrice
    });

    var getProductsState = i1.createFeatureSelector(PRODUCT_FEATURE);

    var getProductReferencesState = i1.createSelector(getProductsState, function (state) { return state.references; });
    var getSelectedProductReferencesFactory = function (productCode, referenceType) {
        return i1.createSelector(getProductReferencesState, function (referenceTypeData) {
            if (referenceTypeData.productCode === productCode) {
                if (!!referenceTypeData.list) {
                    if (referenceType) {
                        return referenceTypeData.list.filter(function (item) { return item.referenceType === referenceType; });
                    }
                    return referenceTypeData.list;
                }
                else {
                    return [];
                }
            }
        });
    };

    var getProductReviewsState = i1.createSelector(getProductsState, function (state) { return state.reviews; });
    var getSelectedProductReviewsFactory = function (productCode) {
        return i1.createSelector(getProductReviewsState, function (reviewData) {
            if (reviewData.productCode === productCode) {
                return reviewData.list;
            }
        });
    };

    var initialState$i = {
        results: {},
        suggestions: [],
        auxResults: {},
    };
    function reducer$i(state, action) {
        if (state === void 0) { state = initialState$i; }
        switch (action.type) {
            case SEARCH_PRODUCTS_SUCCESS: {
                var results = action.payload;
                var res = action.auxiliary ? { auxResults: results } : { results: results };
                return Object.assign(Object.assign({}, state), res);
            }
            case GET_PRODUCT_SUGGESTIONS_SUCCESS: {
                var suggestions = action.payload;
                return Object.assign(Object.assign({}, state), { suggestions: suggestions });
            }
            case CLEAR_PRODUCT_SEARCH_RESULT: {
                return Object.assign(Object.assign({}, state), { results: action.payload.clearPageResults ? {} : state.results, suggestions: action.payload.clearSearchboxResults
                        ? []
                        : state.suggestions, auxResults: action.payload.clearSearchboxResults
                        ? {}
                        : state.auxResults });
            }
        }
        return state;
    }
    var getSearchResults$1 = function (state) { return state.results; };
    var getAuxSearchResults$1 = function (state) { return state.auxResults; };
    var getProductSuggestions$1 = function (state) { return state.suggestions; };

    var getProductsSearchState = i1.createSelector(getProductsState, function (state) { return state.search; });
    var getSearchResults = i1.createSelector(getProductsSearchState, getSearchResults$1);
    var getAuxSearchResults = i1.createSelector(getProductsSearchState, getAuxSearchResults$1);
    var getProductSuggestions = i1.createSelector(getProductsSearchState, getProductSuggestions$1);

    var getProductState = i1.createSelector(getProductsState, function (state) { return state.details; });
    var getSelectedProductStateFactory = function (code, scope) {
        if (scope === void 0) { scope = ''; }
        return i1.createSelector(getProductState, function (details) { return entityLoaderStateSelector(details, code)[scope] ||
            initialLoaderState; });
    };
    var getSelectedProductFactory = function (code, scope) {
        if (scope === void 0) { scope = ''; }
        return i1.createSelector(getSelectedProductStateFactory(code, scope), function (productState) { return loaderValueSelector(productState); });
    };
    var getSelectedProductLoadingFactory = function (code, scope) {
        if (scope === void 0) { scope = ''; }
        return i1.createSelector(getSelectedProductStateFactory(code, scope), function (productState) { return loaderLoadingSelector(productState); });
    };
    var getSelectedProductSuccessFactory = function (code, scope) {
        if (scope === void 0) { scope = ''; }
        return i1.createSelector(getSelectedProductStateFactory(code, scope), function (productState) { return loaderSuccessSelector(productState); });
    };
    var getSelectedProductErrorFactory = function (code, scope) {
        if (scope === void 0) { scope = ''; }
        return i1.createSelector(getSelectedProductStateFactory(code, scope), function (productState) { return loaderErrorSelector(productState); });
    };
    var getAllProductCodes = i1.createSelector(getProductState, function (details) {
        return Object.keys(details.entities);
    });

    var productGroup_selectors = /*#__PURE__*/Object.freeze({
        __proto__: null,
        getProductsState: getProductsState,
        getProductReferencesState: getProductReferencesState,
        getSelectedProductReferencesFactory: getSelectedProductReferencesFactory,
        getProductReviewsState: getProductReviewsState,
        getSelectedProductReviewsFactory: getSelectedProductReviewsFactory,
        getProductsSearchState: getProductsSearchState,
        getSearchResults: getSearchResults,
        getAuxSearchResults: getAuxSearchResults,
        getProductSuggestions: getProductSuggestions,
        getProductState: getProductState,
        getSelectedProductStateFactory: getSelectedProductStateFactory,
        getSelectedProductFactory: getSelectedProductFactory,
        getSelectedProductLoadingFactory: getSelectedProductLoadingFactory,
        getSelectedProductSuccessFactory: getSelectedProductSuccessFactory,
        getSelectedProductErrorFactory: getSelectedProductErrorFactory,
        getAllProductCodes: getAllProductCodes
    });

    var ProductSearchService = /** @class */ (function () {
        function ProductSearchService(store) {
            this.store = store;
        }
        ProductSearchService.prototype.search = function (query, searchConfig) {
            this.store.dispatch(new SearchProducts({
                queryText: query,
                searchConfig: searchConfig,
            }));
        };
        ProductSearchService.prototype.getResults = function () {
            return this.store.pipe(i1.select(getSearchResults));
        };
        ProductSearchService.prototype.clearResults = function () {
            this.store.dispatch(new ClearProductSearchResult({
                clearPageResults: true,
            }));
        };
        return ProductSearchService;
    }());
    ProductSearchService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductSearchService, deps: [{ token: i1__namespace$2.Store }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ProductSearchService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductSearchService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductSearchService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace$2.Store }]; } });

    var ProductEventBuilder = /** @class */ (function () {
        function ProductEventBuilder(eventService, productSearchService) {
            this.eventService = eventService;
            this.productSearchService = productSearchService;
            this.register();
        }
        ProductEventBuilder.prototype.register = function () {
            this.eventService.register(FacetChangedEvent, this.buildFacetChangedEvent());
        };
        /**
         * To get the changed facet, we need to compare the product search results
         * got before and after toggling the facet value. These 2 product searches must
         * have the same search queries except one different solr filter term. That means
         * these 2 searches must have the same 'freeTextSearch'; and if they are category
         * searches, they must have the same root (in the same category or brand).
         */
        ProductEventBuilder.prototype.buildFacetChangedEvent = function () {
            var _this = this;
            return this.productSearchService.getResults().pipe(operators.pairwise(), operators.filter(function (_d) {
                var _e = __read(_d, 2), prev = _e[0], curr = _e[1];
                return _this.compareSearchResults(prev, curr);
            }), operators.map(function (_d) {
                var _e = __read(_d, 2), prev = _e[0], curr = _e[1];
                var toggled = _this.getToggledBreadcrumb(curr.breadcrumbs, prev.breadcrumbs) ||
                    _this.getToggledBreadcrumb(prev.breadcrumbs, curr.breadcrumbs);
                if (toggled) {
                    return createFrom(FacetChangedEvent, {
                        code: toggled.facetCode,
                        name: toggled.facetName,
                        valueCode: toggled.facetValueCode,
                        valueName: toggled.facetValueName,
                        selected: curr.breadcrumbs.length > prev.breadcrumbs.length,
                    });
                }
            }));
        };
        /**
         * The 2 product searches (before and after facet changed) must have the same
         * search queries; and if they are category searches, they also must have the
         * same root (in the same category or brand).
         */
        ProductEventBuilder.prototype.compareSearchResults = function (prev, curr) {
            var _a, _b, _c;
            if (prev && Object.keys(prev).length !== 0) {
                // for text searches, they must have the same freeTextSearch
                var sameFreeTextSearch = prev.freeTextSearch !== '' &&
                    prev.freeTextSearch === curr.freeTextSearch;
                // for category searches, they must have the same root
                var sameCategoryRoot = ((_a = curr.breadcrumbs[0]) === null || _a === void 0 ? void 0 : _a.facetCode) === 'allCategories' &&
                    ((_b = prev.breadcrumbs[0]) === null || _b === void 0 ? void 0 : _b.facetCode) === ((_c = curr.breadcrumbs[0]) === null || _c === void 0 ? void 0 : _c.facetCode) &&
                    // same category or brand
                    prev.breadcrumbs[0].facetValueCode ===
                        curr.breadcrumbs[0].facetValueCode;
                return sameFreeTextSearch || sameCategoryRoot;
            }
        };
        /**
         * Get the toggled breadcrumb. The 2 breadcrumb lists got from the 2 search results
         * only can have one different solr filter term.
         */
        ProductEventBuilder.prototype.getToggledBreadcrumb = function (bc1, bc2) {
            if (bc1.length - bc2.length === 1) {
                return bc1.find(function (x) { return !bc2.find(function (y) { return y.facetCode === x.facetCode &&
                    y.facetValueCode === x.facetValueCode; }); });
            }
        };
        return ProductEventBuilder;
    }());
    ProductEventBuilder.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductEventBuilder, deps: [{ token: EventService }, { token: ProductSearchService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ProductEventBuilder.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductEventBuilder, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductEventBuilder, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: EventService }, { type: ProductSearchService }]; } });

    var ProductEventModule = /** @class */ (function () {
        function ProductEventModule(_productEventBuilder) {
        }
        return ProductEventModule;
    }());
    ProductEventModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductEventModule, deps: [{ token: ProductEventBuilder }], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    ProductEventModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductEventModule });
    ProductEventModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductEventModule });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductEventModule, decorators: [{
                type: i0.NgModule,
                args: [{}]
            }], ctorParameters: function () { return [{ type: ProductEventBuilder }]; } });

    var ProductReferencesEffects = /** @class */ (function () {
        function ProductReferencesEffects(actions$, productReferencesConnector) {
            var _this = this;
            this.actions$ = actions$;
            this.productReferencesConnector = productReferencesConnector;
            this.loadProductReferences$ = this.actions$.pipe(i1$4.ofType(LOAD_PRODUCT_REFERENCES), operators.map(function (action) { return action.payload; }), operators.mergeMap(function (payload) {
                return _this.productReferencesConnector
                    .get(payload.productCode, payload.referenceType, payload.pageSize)
                    .pipe(operators.map(function (data) {
                    return new LoadProductReferencesSuccess({
                        productCode: payload.productCode,
                        list: data,
                    });
                }), operators.catchError(function (_error) { return rxjs.of(new LoadProductReferencesFail({
                    message: payload.productCode,
                })); }));
            }));
        }
        return ProductReferencesEffects;
    }());
    ProductReferencesEffects.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductReferencesEffects, deps: [{ token: i1__namespace$4.Actions }, { token: ProductReferencesConnector }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ProductReferencesEffects.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductReferencesEffects });
    __decorate([
        i1$4.Effect()
    ], ProductReferencesEffects.prototype, "loadProductReferences$", void 0);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductReferencesEffects, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: i1__namespace$4.Actions }, { type: ProductReferencesConnector }]; }, propDecorators: { loadProductReferences$: [] } });

    var ProductReviewsEffects = /** @class */ (function () {
        function ProductReviewsEffects(actions$, productReviewsConnector, globalMessageService) {
            var _this = this;
            this.actions$ = actions$;
            this.productReviewsConnector = productReviewsConnector;
            this.globalMessageService = globalMessageService;
            this.loadProductReviews$ = this.actions$.pipe(i1$4.ofType(LOAD_PRODUCT_REVIEWS), operators.map(function (action) { return action.payload; }), operators.mergeMap(function (productCode) {
                return _this.productReviewsConnector.get(productCode).pipe(operators.map(function (data) {
                    return new LoadProductReviewsSuccess({
                        productCode: productCode,
                        list: data,
                    });
                }), operators.catchError(function (_error) { return rxjs.of(new LoadProductReviewsFail({
                    message: productCode,
                })); }));
            }));
            this.postProductReview = this.actions$.pipe(i1$4.ofType(POST_PRODUCT_REVIEW), operators.map(function (action) { return action.payload; }), operators.mergeMap(function (payload) {
                return _this.productReviewsConnector
                    .add(payload.productCode, payload.review)
                    .pipe(operators.map(function (reviewResponse) {
                    return new PostProductReviewSuccess(reviewResponse);
                }), operators.catchError(function (_error) { return rxjs.of(new PostProductReviewFail(payload.productCode)); }));
            }));
            this.showGlobalMessageOnPostProductReviewSuccess$ = this.actions$.pipe(i1$4.ofType(POST_PRODUCT_REVIEW_SUCCESS), operators.tap(function () {
                _this.globalMessageService.add({ key: 'productReview.thankYouForReview' }, exports.GlobalMessageType.MSG_TYPE_CONFIRMATION);
            }));
        }
        return ProductReviewsEffects;
    }());
    ProductReviewsEffects.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductReviewsEffects, deps: [{ token: i1__namespace$4.Actions }, { token: ProductReviewsConnector }, { token: GlobalMessageService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ProductReviewsEffects.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductReviewsEffects });
    __decorate([
        i1$4.Effect()
    ], ProductReviewsEffects.prototype, "loadProductReviews$", void 0);
    __decorate([
        i1$4.Effect()
    ], ProductReviewsEffects.prototype, "postProductReview", void 0);
    __decorate([
        i1$4.Effect({ dispatch: false })
    ], ProductReviewsEffects.prototype, "showGlobalMessageOnPostProductReviewSuccess$", void 0);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductReviewsEffects, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: i1__namespace$4.Actions }, { type: ProductReviewsConnector }, { type: GlobalMessageService }]; }, propDecorators: { loadProductReviews$: [], postProductReview: [], showGlobalMessageOnPostProductReviewSuccess$: [] } });

    var ProductsSearchEffects = /** @class */ (function () {
        function ProductsSearchEffects(actions$, productSearchConnector) {
            var _this = this;
            this.actions$ = actions$;
            this.productSearchConnector = productSearchConnector;
            this.searchProducts$ = this.actions$.pipe(i1$4.ofType(SEARCH_PRODUCTS), operators.groupBy(function (action) { return action.auxiliary; }), operators.mergeMap(function (group) { return group.pipe(operators.switchMap(function (action) {
                return _this.productSearchConnector
                    .search(action.payload.queryText, action.payload.searchConfig)
                    .pipe(operators.map(function (data) {
                    return new SearchProductsSuccess(data, action.auxiliary);
                }), operators.catchError(function (error) { return rxjs.of(new SearchProductsFail(normalizeHttpError(error), action.auxiliary)); }));
            })); }));
            this.getProductSuggestions$ = this.actions$.pipe(i1$4.ofType(GET_PRODUCT_SUGGESTIONS), operators.map(function (action) { return action.payload; }), operators.switchMap(function (payload) {
                return _this.productSearchConnector
                    .getSuggestions(payload.term, payload.searchConfig.pageSize)
                    .pipe(operators.map(function (suggestions) {
                    if (suggestions === undefined) {
                        return new GetProductSuggestionsSuccess([]);
                    }
                    return new GetProductSuggestionsSuccess(suggestions);
                }), operators.catchError(function (error) { return rxjs.of(new GetProductSuggestionsFail(normalizeHttpError(error))); }));
            }));
        }
        return ProductsSearchEffects;
    }());
    ProductsSearchEffects.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductsSearchEffects, deps: [{ token: i1__namespace$4.Actions }, { token: ProductSearchConnector }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ProductsSearchEffects.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductsSearchEffects });
    __decorate([
        i1$4.Effect()
    ], ProductsSearchEffects.prototype, "searchProducts$", void 0);
    __decorate([
        i1$4.Effect()
    ], ProductsSearchEffects.prototype, "getProductSuggestions$", void 0);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductsSearchEffects, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: i1__namespace$4.Actions }, { type: ProductSearchConnector }]; }, propDecorators: { searchProducts$: [], getProductSuggestions$: [] } });

    var ProductEffects = /** @class */ (function () {
        function ProductEffects(actions$, productConnector) {
            var _this = this;
            this.actions$ = actions$;
            this.productConnector = productConnector;
            // we want to cancel all ongoing requests when currency or language changes,
            this.contextChange$ = this.actions$.pipe(i1$4.ofType(CURRENCY_CHANGE, LANGUAGE_CHANGE));
            this.loadProduct$ = i1$4.createEffect(function () { return function (_a) {
                var _b = _a === void 0 ? {} : _a, scheduler = _b.scheduler, _c = _b.debounce, debounce = _c === void 0 ? 0 : _c;
                return _this.actions$.pipe(i1$4.ofType(LOAD_PRODUCT), operators.map(function (action) { return ({
                    code: action.payload,
                    scope: action.meta.scope,
                }); }), 
                // we are grouping all load actions that happens at the same time
                // to optimize loading and pass them all to productConnector.getMany
                bufferDebounceTime(debounce, scheduler), operators.mergeMap(function (products) { return rxjs.merge.apply(void 0, __spreadArray([], __read(_this.productConnector
                    .getMany(products)
                    .map(_this.productLoadEffect)))); }), withdrawOn(_this.contextChange$));
            }; });
            this.clearProductPrice$ = this.actions$.pipe(i1$4.ofType(LOGOUT, LOGIN), operators.map(function () { return new ClearProductPrice(); }));
        }
        ProductEffects.prototype.productLoadEffect = function (productLoad) {
            return productLoad.data$.pipe(operators.map(function (data) { return new LoadProductSuccess(Object.assign({ code: productLoad.code }, data), productLoad.scope); }), operators.catchError(function (error) {
                return rxjs.of(new LoadProductFail(productLoad.code, normalizeHttpError(error), productLoad.scope));
            }));
        };
        return ProductEffects;
    }());
    ProductEffects.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductEffects, deps: [{ token: i1__namespace$4.Actions }, { token: ProductConnector }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ProductEffects.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductEffects });
    __decorate([
        i1$4.Effect()
    ], ProductEffects.prototype, "clearProductPrice$", void 0);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductEffects, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: i1__namespace$4.Actions }, { type: ProductConnector }]; }, propDecorators: { clearProductPrice$: [] } });

    var effects = [
        ProductsSearchEffects,
        ProductEffects,
        ProductReviewsEffects,
        ProductReferencesEffects,
    ];

    var initialState$h = {
        productCode: '',
        list: [],
    };
    function reducer$h(state, action) {
        if (state === void 0) { state = initialState$h; }
        switch (action.type) {
            case LOAD_PRODUCT_REFERENCES_SUCCESS: {
                var productCode = action.payload.productCode;
                var list = action.payload.list;
                return Object.assign(Object.assign({}, state), { list: __spreadArray(__spreadArray([], __read(state.list)), __read((list ? list : []))).reduce(function (productReferences, productReference) {
                        if (!productReferences.some(function (obj) { return obj.referenceType === productReference.referenceType &&
                            obj.target.code === productReference.target.code; })) {
                            productReferences.push(productReference);
                        }
                        return productReferences;
                    }, []), productCode: productCode });
            }
            case CLEAN_PRODUCT_REFERENCES: {
                return initialState$h;
            }
        }
        return state;
    }
    var getProductReferenceList = function (state) { return state.list; };
    var getProductReferenceProductCode = function (state) { return state.productCode; };

    var initialState$g = {
        productCode: '',
        list: [],
    };
    function reducer$g(state, action) {
        if (state === void 0) { state = initialState$g; }
        switch (action.type) {
            case LOAD_PRODUCT_REVIEWS_SUCCESS: {
                var productCode = action.payload.productCode;
                var list = action.payload.list;
                return Object.assign(Object.assign({}, state), { productCode: productCode,
                    list: list });
            }
        }
        return state;
    }
    var getReviewList = function (state) { return state.list; };
    var getReviewProductCode = function (state) { return state.productCode; };

    var initialScopedLoaderState = {};
    /**
     * Higher order reducer designed to add scope support for loader reducer
     *
     * @param entityType
     * @param reducer
     */
    function scopedLoaderReducer(entityType, reducer) {
        var loader = loaderReducer(entityType, reducer);
        return function (state, action) {
            var _b;
            if (state === void 0) { state = initialScopedLoaderState; }
            var _a;
            if (action && action.meta && action.meta.entityType === entityType) {
                return Object.assign(Object.assign({}, state), (_b = {}, _b[(_a = action.meta.scope) !== null && _a !== void 0 ? _a : ''] = loader(state[action.meta.scope], action), _b));
            }
            return state;
        };
    }

    /**
     * Higher order reducer that wraps scopedLoaderReducer and EntityReducer enhancing
     * single state reducer to support multiple entities with generic loading flags and scopes
     */
    function entityScopedLoaderReducer(entityType, reducer) {
        return entityReducer(entityType, scopedLoaderReducer(entityType, reducer));
    }

    function getReducers$1() {
        return {
            search: reducer$i,
            details: entityScopedLoaderReducer(PRODUCT_DETAIL_ENTITY),
            reviews: reducer$g,
            references: reducer$h,
        };
    }
    var reducerToken$1 = new i0.InjectionToken('ProductReducers');
    var reducerProvider$1 = {
        provide: reducerToken$1,
        useFactory: getReducers$1,
    };
    function clearProductsState(reducer) {
        return function (state, action) {
            if (action.type === CURRENCY_CHANGE ||
                action.type === LANGUAGE_CHANGE) {
                state = undefined;
            }
            return reducer(state, action);
        };
    }
    var metaReducers$1 = [clearProductsState];

    var ProductReferenceService = /** @class */ (function () {
        function ProductReferenceService(store) {
            this.store = store;
        }
        ProductReferenceService.prototype.loadProductReferences = function (productCode, referenceType, pageSize) {
            this.store.dispatch(new LoadProductReferences({
                productCode: productCode,
                referenceType: referenceType,
                pageSize: pageSize,
            }));
        };
        ProductReferenceService.prototype.getProductReferences = function (productCode, referenceType) {
            return this.store.pipe(i1.select(getSelectedProductReferencesFactory(productCode, referenceType)));
        };
        ProductReferenceService.prototype.cleanReferences = function () {
            this.store.dispatch(new CleanProductReferences());
        };
        return ProductReferenceService;
    }());
    ProductReferenceService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductReferenceService, deps: [{ token: i1__namespace$2.Store }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ProductReferenceService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductReferenceService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductReferenceService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace$2.Store }]; } });

    var ProductReviewService = /** @class */ (function () {
        function ProductReviewService(store) {
            this.store = store;
        }
        ProductReviewService.prototype.getByProductCode = function (productCode) {
            var _this = this;
            return this.store.pipe(i1.select(getSelectedProductReviewsFactory(productCode)), operators.tap(function (reviews) {
                if (reviews === undefined && productCode !== undefined) {
                    _this.store.dispatch(new LoadProductReviews(productCode));
                }
            }));
        };
        ProductReviewService.prototype.add = function (productCode, review) {
            this.store.dispatch(new PostProductReview({
                productCode: productCode,
                review: review,
            }));
        };
        return ProductReviewService;
    }());
    ProductReviewService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductReviewService, deps: [{ token: i1__namespace$2.Store }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ProductReviewService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductReviewService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductReviewService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace$2.Store }]; } });

    var ProductLoadingService = /** @class */ (function () {
        function ProductLoadingService(store, loadingScopes, actions$, platformId, eventService) {
            this.store = store;
            this.loadingScopes = loadingScopes;
            this.actions$ = actions$;
            this.platformId = platformId;
            this.eventService = eventService;
            this.products = {};
        }
        ProductLoadingService.prototype.get = function (productCode, scopes) {
            scopes = this.loadingScopes.expand('product', scopes);
            this.initProductScopes(productCode, scopes);
            return this.products[productCode][this.getScopesIndex(scopes)];
        };
        ProductLoadingService.prototype.initProductScopes = function (productCode, scopes) {
            var e_1, _a;
            var _this = this;
            if (!this.products[productCode]) {
                this.products[productCode] = {};
            }
            try {
                for (var scopes_1 = __values(scopes), scopes_1_1 = scopes_1.next(); !scopes_1_1.done; scopes_1_1 = scopes_1.next()) {
                    var scope = scopes_1_1.value;
                    if (!this.products[productCode][scope]) {
                        this.products[productCode][scope] = this.getProductForScope(productCode, scope);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (scopes_1_1 && !scopes_1_1.done && (_a = scopes_1.return)) _a.call(scopes_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            if (scopes.length > 1) {
                this.products[productCode][this.getScopesIndex(scopes)] = uniteLatest(scopes.map(function (scope) { return _this.products[productCode][scope]; })).pipe(operators.map(function (productParts) { return productParts.every(Boolean)
                    ? deepMerge.apply(void 0, __spreadArray([{}], __read(productParts))) : undefined; }), operators.distinctUntilChanged());
            }
        };
        ProductLoadingService.prototype.getScopesIndex = function (scopes) {
            return scopes.join('ɵ');
        };
        /**
         * Creates observable for providing specified product data for the scope
         *
         * @param productCode
         * @param scope
         */
        ProductLoadingService.prototype.getProductForScope = function (productCode, scope) {
            var _this = this;
            var shouldLoad$ = this.store.pipe(i1.select(getSelectedProductStateFactory(productCode, scope)), operators.map(function (productState) { return !productState.loading && !productState.success && !productState.error; }), operators.distinctUntilChanged(), operators.filter(function (x) { return x; }));
            var isLoading$ = this.store.pipe(i1.select(getSelectedProductLoadingFactory(productCode, scope)));
            var productLoadLogic$ = rxjs.merge.apply(void 0, __spreadArray([shouldLoad$], __read(this.getProductReloadTriggers(productCode, scope)))).pipe(operators.debounceTime(0), operators.withLatestFrom(isLoading$), operators.tap(function (_a) {
                var _b = __read(_a, 2), isLoading = _b[1];
                if (!isLoading) {
                    _this.store.dispatch(new LoadProduct(productCode, scope));
                }
            }));
            var productData$ = this.store.pipe(i1.select(getSelectedProductFactory(productCode, scope)));
            return rxjs.using(function () { return productLoadLogic$.subscribe(); }, function () { return productData$; }).pipe(operators.shareReplay({ bufferSize: 1, refCount: true }));
        };
        /**
         * Returns reload triggers for product per scope
         *
         * @param productCode
         * @param scope
         */
        ProductLoadingService.prototype.getProductReloadTriggers = function (productCode, scope) {
            var triggers = [];
            // max age trigger add
            var maxAge = this.loadingScopes.getMaxAge('product', scope);
            if (maxAge && i6.isPlatformBrowser(this.platformId)) {
                // we want to grab load product success and load product fail for this product and scope
                var loadFinish$ = this.actions$.pipe(operators.filter(function (action) { return (action.type === LOAD_PRODUCT_SUCCESS ||
                    action.type === LOAD_PRODUCT_FAIL) &&
                    action.meta.entityId === productCode &&
                    action.meta.scope === scope; }));
                var loadStart$ = this.actions$.pipe(i1$4.ofType(LOAD_PRODUCT), operators.filter(function (action) { return action.payload === productCode && action.meta.scope === scope; }));
                triggers.push(this.getMaxAgeTrigger(loadStart$, loadFinish$, maxAge));
            }
            var reloadTriggers$ = this.loadingScopes
                .getReloadTriggers('product', scope)
                .map(this.eventService.get);
            return triggers.concat(reloadTriggers$);
        };
        /**
         * Generic method that returns stream triggering reload by maxAge
         *
         * Could be refactored to separate service in future to use in other
         * max age reload implementations
         *
         * @param loadStart$ Stream that emits on load start
         * @param loadFinish$ Stream that emits on load finish
         * @param maxAge max age
         */
        ProductLoadingService.prototype.getMaxAgeTrigger = function (loadStart$, loadFinish$, maxAge, scheduler) {
            var timestamp = 0;
            var now = function () { return (scheduler ? scheduler.now() : Date.now()); };
            var timestamp$ = loadFinish$.pipe(operators.tap(function () { return (timestamp = now()); }));
            var shouldReload$ = rxjs.defer(function () {
                var age = now() - timestamp;
                var timestampRefresh$ = timestamp$.pipe(operators.delay(maxAge, scheduler), operators.mapTo(true), withdrawOn(loadStart$));
                if (age > maxAge) {
                    // we should emit first value immediately
                    return rxjs.merge(rxjs.of(true), timestampRefresh$);
                }
                else if (age === 0) {
                    // edge case, we should emit max age timeout after next load success
                    // could happen with artificial schedulers
                    return timestampRefresh$;
                }
                else {
                    // we should emit first value when age will expire
                    return rxjs.merge(rxjs.of(true).pipe(operators.delay(maxAge - age, scheduler)), timestampRefresh$);
                }
            });
            return shouldReload$;
        };
        return ProductLoadingService;
    }());
    ProductLoadingService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductLoadingService, deps: [{ token: i1__namespace$2.Store }, { token: LoadingScopesService }, { token: i1__namespace$4.Actions }, { token: i0.PLATFORM_ID }, { token: EventService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ProductLoadingService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductLoadingService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductLoadingService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () {
            return [{ type: i1__namespace$2.Store }, { type: LoadingScopesService }, { type: i1__namespace$4.Actions }, { type: undefined, decorators: [{
                            type: i0.Inject,
                            args: [i0.PLATFORM_ID]
                        }] }, { type: EventService }];
        } });

    var ProductService = /** @class */ (function () {
        function ProductService(store, productLoading) {
            this.store = store;
            this.productLoading = productLoading;
        }
        /**
         * Returns the product observable. The product will be loaded
         * whenever there's no value observed.
         *
         * The underlying product loader ensures that the product is
         * only loaded once, even in case of parallel observers.
         *
         * You should provide product data scope you are interested in to not load all
         * the data if not needed. You can provide more than one scope.
         *
         * @param productCode Product code to load
         * @param scopes Scope or scopes of the product data
         */
        ProductService.prototype.get = function (productCode, scopes) {
            if (scopes === void 0) { scopes = DEFAULT_SCOPE; }
            return productCode
                ? this.productLoading.get(productCode, [].concat(scopes))
                : rxjs.of(undefined);
        };
        /**
         * Returns boolean observable for product's loading state
         */
        ProductService.prototype.isLoading = function (productCode, scope) {
            if (scope === void 0) { scope = ''; }
            return this.store.pipe(i1.select(getSelectedProductLoadingFactory(productCode, scope)));
        };
        /**
         * Returns boolean observable for product's load success state
         */
        ProductService.prototype.isSuccess = function (productCode, scope) {
            if (scope === void 0) { scope = ''; }
            return this.store.pipe(i1.select(getSelectedProductSuccessFactory(productCode, scope)));
        };
        /**
         * Returns boolean observable for product's load error state
         */
        ProductService.prototype.hasError = function (productCode, scope) {
            if (scope === void 0) { scope = ''; }
            return this.store.pipe(i1.select(getSelectedProductErrorFactory(productCode, scope)));
        };
        return ProductService;
    }());
    ProductService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductService, deps: [{ token: i1__namespace$2.Store }, { token: ProductLoadingService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ProductService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace$2.Store }, { type: ProductLoadingService }]; } });

    var SearchboxService = /** @class */ (function (_super) {
        __extends(SearchboxService, _super);
        function SearchboxService() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * dispatch the search for the search box
         */
        SearchboxService.prototype.search = function (query, searchConfig) {
            this.store.dispatch(new SearchProducts({
                queryText: query,
                searchConfig: searchConfig,
            }, true));
        };
        SearchboxService.prototype.getResults = function () {
            return this.store.pipe(i1.select(getAuxSearchResults));
        };
        /**
         * clears the products and suggestions
         */
        SearchboxService.prototype.clearResults = function () {
            this.store.dispatch(new ClearProductSearchResult({
                clearSearchboxResults: true,
            }));
        };
        SearchboxService.prototype.getSuggestionResults = function () {
            return this.store.pipe(i1.select(getProductSuggestions));
        };
        SearchboxService.prototype.searchSuggestions = function (query, searchConfig) {
            this.store.dispatch(new GetProductSuggestions({
                term: query,
                searchConfig: searchConfig,
            }));
        };
        return SearchboxService;
    }(ProductSearchService));
    SearchboxService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SearchboxService, deps: null, target: i0__namespace.ɵɵFactoryTarget.Injectable });
    SearchboxService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SearchboxService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SearchboxService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }] });

    /**
     * Resolves the page data for the Product Listing Page.
     *
     * The page title, and breadcrumbs are resolved in this implementation only.
     */
    var CategoryPageMetaResolver = /** @class */ (function (_super) {
        __extends(CategoryPageMetaResolver, _super);
        function CategoryPageMetaResolver(productSearchService, cms, translation, basePageMetaResolver) {
            var _this = _super.call(this) || this;
            _this.productSearchService = productSearchService;
            _this.cms = cms;
            _this.translation = translation;
            _this.basePageMetaResolver = basePageMetaResolver;
            // reusable observable for search page data
            _this.searchPage$ = _this.cms
                .getCurrentPage()
                .pipe(operators.filter(function (page) { return Boolean(page); }), operators.switchMap(function (page) {
                // only the existence of a plp component tells us if products
                // are rendered or if this is an ordinary content page
                return _this.hasProductListComponent(page)
                    ? _this.productSearchService
                        .getResults()
                        .pipe(operators.filter(function (result) { return Boolean(result); }))
                    : rxjs.of(page);
            }));
            _this.pageType = exports.PageType.CATEGORY_PAGE;
            return _this;
        }
        CategoryPageMetaResolver.prototype.resolveTitle = function () {
            var _this = this;
            return this.searchPage$.pipe(operators.filter(function (page) { return !!page.pagination; }), operators.switchMap(function (p) {
                var _a, _b;
                return _this.translation.translate('pageMetaResolver.category.title', {
                    count: (_a = p.pagination) === null || _a === void 0 ? void 0 : _a.totalResults,
                    query: ((_b = p.breadcrumbs) === null || _b === void 0 ? void 0 : _b.length)
                        ? p.breadcrumbs[0].facetValueName
                        : undefined,
                });
            }));
        };
        CategoryPageMetaResolver.prototype.resolveBreadcrumbs = function () {
            var _this = this;
            return rxjs.combineLatest([
                this.searchPage$.pipe(),
                this.translation.translate('common.home'),
            ]).pipe(operators.map(function (_c) {
                var _d = __read(_c, 2), page = _d[0], label = _d[1];
                return page.breadcrumbs
                    ? _this.resolveBreadcrumbData(page, label)
                    : [];
            }));
        };
        CategoryPageMetaResolver.prototype.resolveBreadcrumbData = function (page, label) {
            var e_1, _c;
            var _a;
            var breadcrumbs = [];
            breadcrumbs.push({ label: label, link: '/' });
            try {
                for (var _d = __values((_a = page.breadcrumbs) !== null && _a !== void 0 ? _a : []), _e = _d.next(); !_e.done; _e = _d.next()) {
                    var br = _e.value;
                    if (br.facetValueName) {
                        if (br.facetCode === 'category' || br.facetCode === 'allCategories') {
                            breadcrumbs.push({
                                label: br.facetValueName,
                                link: "/c/" + br.facetValueCode,
                            });
                        }
                        if (br.facetCode === 'brand') {
                            breadcrumbs.push({
                                label: br.facetValueName,
                                link: "/Brands/" + br.facetValueName + "/c/" + br.facetValueCode,
                            });
                        }
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_e && !_e.done && (_c = _d.return)) _c.call(_d);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return breadcrumbs;
        };
        CategoryPageMetaResolver.prototype.hasProductListComponent = function (page) {
            return !!Object.keys(page.slots || {}).find(function (key) {
                var _a, _b;
                return !!((_b = (_a = page.slots) === null || _a === void 0 ? void 0 : _a[key].components) === null || _b === void 0 ? void 0 : _b.find(function (comp) { return comp.typeCode === 'CMSProductListComponent' ||
                    comp.typeCode === 'ProductGridComponent'; }));
            });
        };
        CategoryPageMetaResolver.prototype.resolveRobots = function () {
            return this.basePageMetaResolver.resolveRobots();
        };
        /**
         * Resolves the canonical url for the category listing page.
         *
         * The default options will be used to resolve the url, which means that
         * all query parameters are removed and https and www are added explicitly.
         */
        CategoryPageMetaResolver.prototype.resolveCanonicalUrl = function () {
            return this.basePageMetaResolver.resolveCanonicalUrl();
        };
        return CategoryPageMetaResolver;
    }(PageMetaResolver));
    CategoryPageMetaResolver.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CategoryPageMetaResolver, deps: [{ token: ProductSearchService }, { token: CmsService }, { token: TranslationService }, { token: BasePageMetaResolver }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    CategoryPageMetaResolver.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CategoryPageMetaResolver, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CategoryPageMetaResolver, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: ProductSearchService }, { type: CmsService }, { type: TranslationService }, { type: BasePageMetaResolver }]; } });

    /**
     * Resolves page meta data for the search result page, in case it's used
     * to query coupons. This is done by adding a `couponcode` query parameter
     * to the search page route.
     *
     * The page resolves an alternative page title and breadcrumb.
     */
    var CouponSearchPageResolver = /** @class */ (function (_super) {
        __extends(CouponSearchPageResolver, _super);
        function CouponSearchPageResolver(productSearchService, translation, authService, route, semanticPathService) {
            var _this = _super.call(this) || this;
            _this.productSearchService = productSearchService;
            _this.translation = translation;
            _this.authService = authService;
            _this.route = route;
            _this.semanticPathService = semanticPathService;
            _this.total$ = _this.productSearchService
                .getResults()
                .pipe(operators.filter(function (data) { return !!(data === null || data === void 0 ? void 0 : data.pagination); }), operators.map(function (results) { return results.pagination.totalResults; }));
            _this.pageType = exports.PageType.CONTENT_PAGE;
            _this.pageTemplate = 'SearchResultsListPageTemplate';
            return _this;
        }
        CouponSearchPageResolver.prototype.resolveBreadcrumbs = function () {
            var _this = this;
            return rxjs.combineLatest([
                this.translation.translate('common.home'),
                this.translation.translate('myCoupons.myCoupons'),
                this.authService.isUserLoggedIn(),
            ]).pipe(operators.map(function (_c) {
                var _d = __read(_c, 3), homeLabel = _d[0], couponLabel = _d[1], isLoggedIn = _d[2];
                var breadcrumbs = [];
                breadcrumbs.push({ label: homeLabel, link: '/' });
                if (isLoggedIn) {
                    breadcrumbs.push({
                        label: couponLabel,
                        link: _this.semanticPathService.transform({
                            cxRoute: 'coupons',
                        }),
                    });
                }
                return breadcrumbs;
            }));
        };
        CouponSearchPageResolver.prototype.resolveTitle = function () {
            var _this = this;
            return this.total$.pipe(operators.switchMap(function (total) { return _this.translation.translate('pageMetaResolver.search.findProductTitle', {
                count: total,
                coupon: _this.couponCode,
            }); }));
        };
        CouponSearchPageResolver.prototype.getScore = function (page) {
            return _super.prototype.getScore.call(this, page) + (this.couponCode ? 1 : -1);
        };
        Object.defineProperty(CouponSearchPageResolver.prototype, "couponCode", {
            get: function () {
                var _a, _b;
                return (_b = (_a = this.route.snapshot) === null || _a === void 0 ? void 0 : _a.queryParams) === null || _b === void 0 ? void 0 : _b.couponcode;
            },
            enumerable: false,
            configurable: true
        });
        return CouponSearchPageResolver;
    }(PageMetaResolver));
    CouponSearchPageResolver.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CouponSearchPageResolver, deps: [{ token: ProductSearchService }, { token: TranslationService }, { token: AuthService }, { token: i1__namespace$1.ActivatedRoute }, { token: SemanticPathService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    CouponSearchPageResolver.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CouponSearchPageResolver, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CouponSearchPageResolver, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: ProductSearchService }, { type: TranslationService }, { type: AuthService }, { type: i1__namespace$1.ActivatedRoute }, { type: SemanticPathService }]; } });

    /**
     * Resolves the page data for the Product Detail Page
     * based on the `PageType.PRODUCT_PAGE`.
     *
     * The page title, heading, description, breadcrumbs and
     * first GALLERY image are resolved if available in the data.
     */
    var ProductPageMetaResolver = /** @class */ (function (_super) {
        __extends(ProductPageMetaResolver, _super);
        function ProductPageMetaResolver(routingService, productService, translation, basePageMetaResolver, pageLinkService) {
            var _this = _super.call(this) || this;
            _this.routingService = routingService;
            _this.productService = productService;
            _this.translation = translation;
            _this.basePageMetaResolver = basePageMetaResolver;
            _this.pageLinkService = pageLinkService;
            // reusable observable for product data based on the current page
            _this.product$ = _this.routingService
                .getRouterState()
                .pipe(operators.map(function (state) { return state.state.params['productCode']; }), operators.filter(function (code) { return !!code; }), operators.switchMap(function (code) { return _this.productService.get(code, "details" /* DETAILS */); }), operators.filter(function (p) { return Boolean(p); }));
            _this.pageType = exports.PageType.PRODUCT_PAGE;
            return _this;
        }
        /**
         * Resolves the page heading for the Product Detail Page.
         * The page heading is used in the UI (`<h1>`), where as the page
         * title is used by the browser and crawlers.
         */
        ProductPageMetaResolver.prototype.resolveHeading = function () {
            var _this = this;
            return this.product$.pipe(operators.switchMap(function (p) { return _this.translation.translate('pageMetaResolver.product.heading', {
                heading: p.name,
            }); }));
        };
        /**
         * Resolves the page title for the Product Detail Page. The page title
         * is resolved with the product name, the first category and the manufacturer.
         * The page title used by the browser (history, tabs) and crawlers.
         */
        ProductPageMetaResolver.prototype.resolveTitle = function () {
            var _this = this;
            return this.product$.pipe(operators.switchMap(function (product) {
                var title = product.name;
                title += _this.resolveFirstCategory(product);
                title += _this.resolveManufacturer(product);
                return _this.translation.translate('pageMetaResolver.product.title', {
                    title: title,
                });
            }));
        };
        /**
         * Resolves the page description for the Product Detail Page. The description
         * is based on the `product.summary`.
         */
        ProductPageMetaResolver.prototype.resolveDescription = function () {
            var _this = this;
            return this.product$.pipe(operators.switchMap(function (product) { return _this.translation.translate('pageMetaResolver.product.description', {
                description: product.summary,
            }); }));
        };
        /**
         * Resolves breadcrumbs for the Product Detail Page. The breadcrumbs are driven by
         * a static home page crumb and a crumb for each category.
         */
        ProductPageMetaResolver.prototype.resolveBreadcrumbs = function () {
            return rxjs.combineLatest([
                this.product$.pipe(),
                this.translation.translate('common.home'),
            ]).pipe(operators.map(function (_e) {
                var e_1, _f;
                var _g = __read(_e, 2), product = _g[0], label = _g[1];
                var breadcrumbs = [];
                breadcrumbs.push({ label: label, link: '/' });
                try {
                    for (var _h = __values(product.categories || []), _j = _h.next(); !_j.done; _j = _h.next()) {
                        var _k = _j.value, name = _k.name, code = _k.code, url = _k.url;
                        breadcrumbs.push({
                            label: name || code,
                            link: url,
                        });
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_j && !_j.done && (_f = _h.return)) _f.call(_h);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                return breadcrumbs;
            }));
        };
        /**
         * Resolves the main page image for the Product Detail Page. The product image
         * is based on the PRIMARY product image. The zoom format is used by default.
         */
        ProductPageMetaResolver.prototype.resolveImage = function () {
            return this.product$.pipe(operators.map(function (product) { var _a, _b, _c, _d; return (_d = (_c = (_b = (_a = product.images) === null || _a === void 0 ? void 0 : _a.PRIMARY) === null || _b === void 0 ? void 0 : _b.zoom) === null || _c === void 0 ? void 0 : _c.url) !== null && _d !== void 0 ? _d : null; }));
        };
        ProductPageMetaResolver.prototype.resolveFirstCategory = function (product) {
            var _a;
            var firstCategory = (_a = product === null || product === void 0 ? void 0 : product.categories) === null || _a === void 0 ? void 0 : _a[0];
            return firstCategory
                ? " | " + (firstCategory.name || firstCategory.code)
                : '';
        };
        ProductPageMetaResolver.prototype.resolveManufacturer = function (product) {
            return product.manufacturer ? " | " + product.manufacturer : '';
        };
        ProductPageMetaResolver.prototype.resolveRobots = function () {
            return this.basePageMetaResolver.resolveRobots();
        };
        /**
         * Resolves the canonical url for the product page using the default canonical url
         * configuration.
         *
         * In case of a variant product, the baseProduct code is used to resolve the url. It's important
         * to know that this has a few limitations:
         * - We're not always able to get the super baseProduct, in case of multi-level variants.
         *   OCC only exposes the direct baseProduct, which might still not resolve in the correct
         *   canonical URL. This is business driven and subject to change in a customization.
         * - The url resolved for the variant doesn't contain any content other then the product code.
         *   This means that we do not provide any product data to resolve pretty URLs (for example
         *   the product title).
         */
        ProductPageMetaResolver.prototype.resolveCanonicalUrl = function () {
            var _this = this;
            return this.product$.pipe(operators.switchMap(function (product) { return _this.findBaseProduct(product); }), operators.map(function (product) {
                var url = _this.routingService.getFullUrl({
                    cxRoute: 'product',
                    params: product,
                });
                return _this.pageLinkService.getCanonicalUrl({}, url);
            }));
        };
        /**
         * Resolves the base product whenever the given product is a variant product.
         *
         * Since product variants can be multi-layered, we recursively try to find the base product
         * this might be too opinionated for your business though.
         */
        ProductPageMetaResolver.prototype.findBaseProduct = function (product) {
            var _this = this;
            if (product === null || product === void 0 ? void 0 : product.baseProduct) {
                return this.productService
                    .get(product.baseProduct, "list" /* LIST */)
                    .pipe(operators.filter(function (product) { return Boolean(product); }), operators.switchMap(function (baseProduct) { return _this.findBaseProduct(baseProduct); }));
            }
            return rxjs.of(product);
        };
        return ProductPageMetaResolver;
    }(PageMetaResolver));
    ProductPageMetaResolver.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductPageMetaResolver, deps: [{ token: RoutingService }, { token: ProductService }, { token: TranslationService }, { token: BasePageMetaResolver }, { token: PageLinkService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ProductPageMetaResolver.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductPageMetaResolver, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductPageMetaResolver, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: RoutingService }, { type: ProductService }, { type: TranslationService }, { type: BasePageMetaResolver }, { type: PageLinkService }]; } });

    /**
     * Resolves the page data for the Search Result Page based on the
     * `PageType.CATEGORY_PAGE` and the `SearchResultsListPageTemplate` template.
     *
     * Only the page title is resolved in the standard implementation.
     */
    var SearchPageMetaResolver = /** @class */ (function (_super) {
        __extends(SearchPageMetaResolver, _super);
        function SearchPageMetaResolver(routingService, productSearchService, translation, basePageMetaResolver) {
            var _this = _super.call(this) || this;
            _this.routingService = routingService;
            _this.productSearchService = productSearchService;
            _this.translation = translation;
            _this.basePageMetaResolver = basePageMetaResolver;
            _this.total$ = _this.productSearchService
                .getResults()
                .pipe(operators.filter(function (data) { return !!(data === null || data === void 0 ? void 0 : data.pagination); }), operators.map(function (results) { var _a; return (_a = results.pagination) === null || _a === void 0 ? void 0 : _a.totalResults; }));
            _this.query$ = _this.routingService
                .getRouterState()
                .pipe(operators.map(function (state) { return state.state.params['query']; }));
            _this.pageType = exports.PageType.CONTENT_PAGE;
            _this.pageTemplate = 'SearchResultsListPageTemplate';
            return _this;
        }
        SearchPageMetaResolver.prototype.resolveTitle = function () {
            var _this = this;
            var sources = [this.total$, this.query$];
            return rxjs.combineLatest(sources).pipe(operators.switchMap(function (_b) {
                var _c = __read(_b, 2), count = _c[0], query = _c[1];
                return _this.translation
                    .translate('pageMetaResolver.search.default_title')
                    .pipe(operators.mergeMap(function (defaultQuery) { return _this.translation.translate('pageMetaResolver.search.title', {
                    count: count,
                    query: query || defaultQuery,
                }); }));
            }));
        };
        SearchPageMetaResolver.prototype.resolveRobots = function () {
            return this.basePageMetaResolver.resolveRobots();
        };
        /**
         * Resolves the canonical page for the search page.
         *
         * The default options will be used to resolve the url, which means that
         * the all query parameters are removed and https and www are added explicitly.
         */
        SearchPageMetaResolver.prototype.resolveCanonicalUrl = function () {
            return this.basePageMetaResolver.resolveCanonicalUrl();
        };
        return SearchPageMetaResolver;
    }(PageMetaResolver));
    SearchPageMetaResolver.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SearchPageMetaResolver, deps: [{ token: RoutingService }, { token: ProductSearchService }, { token: TranslationService }, { token: BasePageMetaResolver }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    SearchPageMetaResolver.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SearchPageMetaResolver, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: SearchPageMetaResolver, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: RoutingService }, { type: ProductSearchService }, { type: TranslationService }, { type: BasePageMetaResolver }]; } });

    function productStoreConfigFactory() {
        var _a;
        // if we want to reuse PRODUCT_FEATURE const in config, we have to use factory instead of plain object
        var config = {
            state: {
                ssrTransfer: {
                    keys: (_a = {}, _a[PRODUCT_FEATURE] = exports.StateTransferType.TRANSFER_STATE, _a),
                },
            },
        };
        return config;
    }
    var ProductStoreModule = /** @class */ (function () {
        function ProductStoreModule() {
        }
        return ProductStoreModule;
    }());
    ProductStoreModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductStoreModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    ProductStoreModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductStoreModule, imports: [i6.CommonModule, i1__namespace$2.StoreFeatureModule, i1__namespace$4.EffectsFeatureModule] });
    ProductStoreModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductStoreModule, providers: [
            provideDefaultConfigFactory(productStoreConfigFactory),
            reducerProvider$1,
        ], imports: [[
                i6.CommonModule,
                i1.StoreModule.forFeature(PRODUCT_FEATURE, reducerToken$1, { metaReducers: metaReducers$1 }),
                i1$4.EffectsModule.forFeature(effects),
            ]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductStoreModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [
                            i6.CommonModule,
                            i1.StoreModule.forFeature(PRODUCT_FEATURE, reducerToken$1, { metaReducers: metaReducers$1 }),
                            i1$4.EffectsModule.forFeature(effects),
                        ],
                        providers: [
                            provideDefaultConfigFactory(productStoreConfigFactory),
                            reducerProvider$1,
                        ],
                    }]
            }] });

    var pageTitleResolvers = [
        {
            provide: PageMetaResolver,
            useExisting: ProductPageMetaResolver,
            multi: true,
        },
        {
            provide: PageMetaResolver,
            useExisting: CategoryPageMetaResolver,
            multi: true,
        },
        {
            provide: PageMetaResolver,
            useExisting: SearchPageMetaResolver,
            multi: true,
        },
        {
            provide: PageMetaResolver,
            useExisting: CouponSearchPageResolver,
            multi: true,
        },
    ];
    var ProductModule = /** @class */ (function () {
        function ProductModule() {
        }
        ProductModule.forRoot = function () {
            return {
                ngModule: ProductModule,
                providers: __spreadArray([], __read(pageTitleResolvers)),
            };
        };
        return ProductModule;
    }());
    ProductModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    ProductModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductModule, imports: [ProductStoreModule, ProductEventModule] });
    ProductModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductModule, imports: [[ProductStoreModule, ProductEventModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [ProductStoreModule, ProductEventModule],
                    }]
            }] });

    var UserAddressConnector = /** @class */ (function () {
        function UserAddressConnector(adapter) {
            this.adapter = adapter;
        }
        UserAddressConnector.prototype.getAll = function (userId) {
            return this.adapter.loadAll(userId);
        };
        UserAddressConnector.prototype.add = function (userId, address) {
            return this.adapter.add(userId, address);
        };
        UserAddressConnector.prototype.update = function (userId, addressId, address) {
            return this.adapter.update(userId, addressId, address);
        };
        UserAddressConnector.prototype.verify = function (userId, address) {
            return this.adapter.verify(userId, address);
        };
        UserAddressConnector.prototype.delete = function (userId, addressId) {
            return this.adapter.delete(userId, addressId);
        };
        return UserAddressConnector;
    }());
    UserAddressConnector.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserAddressConnector, deps: [{ token: UserAddressAdapter }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    UserAddressConnector.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserAddressConnector, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserAddressConnector, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: UserAddressAdapter }]; } });

    var UserConsentConnector = /** @class */ (function () {
        function UserConsentConnector(adapter) {
            this.adapter = adapter;
        }
        UserConsentConnector.prototype.loadConsents = function (userId) {
            return this.adapter.loadConsents(userId);
        };
        UserConsentConnector.prototype.giveConsent = function (userId, consentTemplateId, consentTemplateVersion) {
            return this.adapter.giveConsent(userId, consentTemplateId, consentTemplateVersion);
        };
        UserConsentConnector.prototype.withdrawConsent = function (userId, consentCode) {
            return this.adapter.withdrawConsent(userId, consentCode);
        };
        return UserConsentConnector;
    }());
    UserConsentConnector.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserConsentConnector, deps: [{ token: UserConsentAdapter }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    UserConsentConnector.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserConsentConnector, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserConsentConnector, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: UserConsentAdapter }]; } });

    var UserCostCenterConnector = /** @class */ (function () {
        function UserCostCenterConnector(adapter) {
            this.adapter = adapter;
        }
        UserCostCenterConnector.prototype.getActiveList = function (userId) {
            return this.adapter.loadActiveList(userId);
        };
        return UserCostCenterConnector;
    }());
    UserCostCenterConnector.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserCostCenterConnector, deps: [{ token: UserCostCenterAdapter }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    UserCostCenterConnector.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserCostCenterConnector, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserCostCenterConnector, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: UserCostCenterAdapter }]; } });

    var CustomerCouponConnector = /** @class */ (function () {
        function CustomerCouponConnector(adapter) {
            this.adapter = adapter;
        }
        CustomerCouponConnector.prototype.getCustomerCoupons = function (userId, pageSize, currentPage, sort) {
            return this.adapter.getCustomerCoupons(userId, pageSize, currentPage, sort);
        };
        CustomerCouponConnector.prototype.turnOnNotification = function (userId, couponCode) {
            return this.adapter.turnOnNotification(userId, couponCode);
        };
        CustomerCouponConnector.prototype.turnOffNotification = function (userId, couponCode) {
            return this.adapter.turnOffNotification(userId, couponCode);
        };
        CustomerCouponConnector.prototype.claimCustomerCoupon = function (userId, couponCode) {
            return this.adapter.claimCustomerCoupon(userId, couponCode);
        };
        return CustomerCouponConnector;
    }());
    CustomerCouponConnector.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CustomerCouponConnector, deps: [{ token: CustomerCouponAdapter }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    CustomerCouponConnector.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CustomerCouponConnector, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CustomerCouponConnector, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: CustomerCouponAdapter }]; } });

    var UserInterestsConnector = /** @class */ (function () {
        function UserInterestsConnector(adapter) {
            this.adapter = adapter;
        }
        UserInterestsConnector.prototype.getInterests = function (userId, pageSize, currentPage, sort, productCode, notificationType) {
            return this.adapter.getInterests(userId, pageSize, currentPage, sort, productCode, notificationType);
        };
        UserInterestsConnector.prototype.removeInterest = function (userId, item) {
            return this.adapter.removeInterest(userId, item);
        };
        UserInterestsConnector.prototype.addInterest = function (userId, productCode, notificationType) {
            return this.adapter.addInterest(userId, productCode, notificationType);
        };
        return UserInterestsConnector;
    }());
    UserInterestsConnector.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserInterestsConnector, deps: [{ token: UserInterestsAdapter }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    UserInterestsConnector.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserInterestsConnector, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserInterestsConnector, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: UserInterestsAdapter }]; } });

    /**
     * @deprecated since 4.2 - use OrderConnector in @spartacus/order/core
     */
    var UserOrderConnector = /** @class */ (function () {
        function UserOrderConnector(adapter) {
            this.adapter = adapter;
        }
        UserOrderConnector.prototype.get = function (userId, orderCode) {
            return this.adapter.load(userId, orderCode);
        };
        UserOrderConnector.prototype.getHistory = function (userId, pageSize, currentPage, sort) {
            return this.adapter.loadHistory(userId, pageSize, currentPage, sort);
        };
        UserOrderConnector.prototype.getConsignmentTracking = function (orderCode, consignmentCode, userId) {
            return this.adapter.getConsignmentTracking(orderCode, consignmentCode, userId);
        };
        UserOrderConnector.prototype.cancel = function (userId, orderCode, cancelRequestInput) {
            return this.adapter.cancel(userId, orderCode, cancelRequestInput);
        };
        UserOrderConnector.prototype.return = function (userId, returnRequestInput) {
            return this.adapter.createReturnRequest(userId, returnRequestInput);
        };
        UserOrderConnector.prototype.getReturnRequestDetail = function (userId, returnRequestCode) {
            return this.adapter.loadReturnRequestDetail(userId, returnRequestCode);
        };
        UserOrderConnector.prototype.getReturnRequestList = function (userId, pageSize, currentPage, sort) {
            return this.adapter.loadReturnRequestList(userId, pageSize, currentPage, sort);
        };
        UserOrderConnector.prototype.cancelReturnRequest = function (userId, returnRequestCode, returnRequestModification) {
            return this.adapter.cancelReturnRequest(userId, returnRequestCode, returnRequestModification);
        };
        return UserOrderConnector;
    }());
    UserOrderConnector.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserOrderConnector, deps: [{ token: UserOrderAdapter }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    UserOrderConnector.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserOrderConnector, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserOrderConnector, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: UserOrderAdapter }]; } });

    var UserPaymentConnector = /** @class */ (function () {
        function UserPaymentConnector(adapter) {
            this.adapter = adapter;
        }
        UserPaymentConnector.prototype.getAll = function (userId) {
            return this.adapter.loadAll(userId);
        };
        UserPaymentConnector.prototype.delete = function (userId, paymentMethodID) {
            return this.adapter.delete(userId, paymentMethodID);
        };
        UserPaymentConnector.prototype.setDefault = function (userId, paymentMethodID) {
            return this.adapter.setDefault(userId, paymentMethodID);
        };
        return UserPaymentConnector;
    }());
    UserPaymentConnector.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserPaymentConnector, deps: [{ token: UserPaymentAdapter }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    UserPaymentConnector.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserPaymentConnector, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserPaymentConnector, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: UserPaymentAdapter }]; } });

    var UserAddressEvent = /** @class */ (function (_super) {
        __extends(UserAddressEvent, _super);
        function UserAddressEvent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return UserAddressEvent;
    }(CxEvent));
    var UpdateUserAddressEvent = /** @class */ (function (_super) {
        __extends(UpdateUserAddressEvent, _super);
        function UpdateUserAddressEvent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return UpdateUserAddressEvent;
    }(UserAddressEvent));
    UpdateUserAddressEvent.type = 'UpdateUserAddressEvent';
    var DeleteUserAddressEvent = /** @class */ (function (_super) {
        __extends(DeleteUserAddressEvent, _super);
        function DeleteUserAddressEvent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return DeleteUserAddressEvent;
    }(UserAddressEvent));
    DeleteUserAddressEvent.type = 'DeleteUserAddressEvent';
    var AddUserAddressEvent = /** @class */ (function (_super) {
        __extends(AddUserAddressEvent, _super);
        function AddUserAddressEvent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return AddUserAddressEvent;
    }(UserAddressEvent));
    AddUserAddressEvent.type = 'AddUserAddressEvent';

    var UserEventBuilder = /** @class */ (function () {
        function UserEventBuilder(stateEventService) {
            this.stateEventService = stateEventService;
            this.register();
        }
        /**
         * Registers user events
         */
        UserEventBuilder.prototype.register = function () {
            this.updateUserAddressEvent();
            this.deleteUserAddressEvent();
            this.addUserAddressEvent();
        };
        /**
         * Register an address successfully updated event
         */
        UserEventBuilder.prototype.updateUserAddressEvent = function () {
            this.stateEventService.register({
                action: UPDATE_USER_ADDRESS,
                event: UpdateUserAddressEvent,
            });
        };
        UserEventBuilder.prototype.addUserAddressEvent = function () {
            this.stateEventService.register({
                action: ADD_USER_ADDRESS,
                event: AddUserAddressEvent,
            });
        };
        UserEventBuilder.prototype.deleteUserAddressEvent = function () {
            this.stateEventService.register({
                action: DELETE_USER_ADDRESS,
                event: DeleteUserAddressEvent,
            });
        };
        return UserEventBuilder;
    }());
    UserEventBuilder.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserEventBuilder, deps: [{ token: StateEventService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    UserEventBuilder.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserEventBuilder });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserEventBuilder, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: StateEventService }]; } });

    var UserEventModule = /** @class */ (function () {
        function UserEventModule(_userEventBuilder) {
        }
        return UserEventModule;
    }());
    UserEventModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserEventModule, deps: [{ token: UserEventBuilder }], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    UserEventModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserEventModule });
    UserEventModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserEventModule });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserEventModule, decorators: [{
                type: i0.NgModule,
                args: [{}]
            }], ctorParameters: function () { return [{ type: UserEventBuilder }]; } });

    /**
     * Unified facade for both anonymous and registered user consents.
     */
    var ConsentService = /** @class */ (function () {
        function ConsentService(anonymousConsentsService, userConsentService) {
            this.anonymousConsentsService = anonymousConsentsService;
            this.userConsentService = userConsentService;
        }
        /**
         * Returns either anonymous consent or registered consent as they are emmited.
         * @param templateCode for which to return either anonymous or registered consent.
         */
        ConsentService.prototype.getConsent = function (templateCode) {
            return rxjs.merge(this.userConsentService.getConsent(templateCode), this.anonymousConsentsService.getConsent(templateCode));
        };
        /**
         * Checks if the `templateId`'s template has a given consent.
         * The method returns `false` if the consent doesn't exist or if it's withdrawn. Otherwise, `true` is returned.
         *
         * @param templateId of a template which's consent should be checked
         */
        ConsentService.prototype.checkConsentGivenByTemplateId = function (templateId) {
            var _this = this;
            return this.getConsent(templateId).pipe(operators.map(function (consent) {
                if (!consent) {
                    return false;
                }
                return _this.isAnonymousConsentType(consent)
                    ? _this.anonymousConsentsService.isConsentGiven(consent)
                    : _this.userConsentService.isConsentGiven(consent);
            }), operators.distinctUntilChanged());
        };
        /**
         * Checks if the `templateId`'s template has a withdrawn consent.
         * The method returns `true` if the consent doesn't exist or if it's withdrawn. Otherwise, `false` is returned.
         *
         * @param templateId of a template which's consent should be checked
         */
        ConsentService.prototype.checkConsentWithdrawnByTemplateId = function (templateId) {
            var _this = this;
            return this.getConsent(templateId).pipe(operators.map(function (consent) {
                if (!consent) {
                    return true;
                }
                return _this.isAnonymousConsentType(consent)
                    ? _this.anonymousConsentsService.isConsentWithdrawn(consent)
                    : _this.userConsentService.isConsentWithdrawn(consent);
            }), operators.distinctUntilChanged());
        };
        /**
         *
         * Checks the provided `consent`'s type and delegates to an appropriate method - `anonymousConsentsService.isConsentGiven(consent)` or `this.userConsentService.isConsentGiven`
         *
         * @param consent a consent to check
         */
        ConsentService.prototype.isConsentGiven = function (consent) {
            return this.isAnonymousConsentType(consent)
                ? this.anonymousConsentsService.isConsentGiven(consent)
                : this.userConsentService.isConsentGiven(consent);
        };
        /**
         *
         * Checks the provided `consent`'s type and delegates to an appropriate method - `anonymousConsentsService.isConsentWithdrawn(consent)` or `this.userConsentService.isConsentWithdrawn`
         *
         * @param consent a consent to check
         */
        ConsentService.prototype.isConsentWithdrawn = function (consent) {
            return this.isAnonymousConsentType(consent)
                ? this.anonymousConsentsService.isConsentWithdrawn(consent)
                : this.userConsentService.isConsentWithdrawn(consent);
        };
        /**
         * Returns `true` if the provided consent is of type `AnonymousConsent`. Otherwise, `false` is returned.
         */
        ConsentService.prototype.isAnonymousConsentType = function (consent) {
            if (!consent) {
                return false;
            }
            return consent.templateCode !== undefined;
        };
        /**
         * Returns `true` if the provided consent is of type `Consent`. Otherwise, `false` is returned.
         */
        ConsentService.prototype.isConsentType = function (consent) {
            if (!consent) {
                return false;
            }
            return consent.code !== undefined;
        };
        return ConsentService;
    }());
    ConsentService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ConsentService, deps: [{ token: AnonymousConsentsService }, { token: UserConsentService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ConsentService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ConsentService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ConsentService, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }], ctorParameters: function () { return [{ type: AnonymousConsentsService }, { type: UserConsentService }]; } });

    var CustomerCouponService = /** @class */ (function () {
        function CustomerCouponService(store, userIdService) {
            this.store = store;
            this.userIdService = userIdService;
        }
        /**
         * Retrieves customer's coupons
         * @param pageSize page size
         * @param currentPage current page
         * @param sort sort
         */
        CustomerCouponService.prototype.loadCustomerCoupons = function (pageSize, currentPage, sort) {
            var _this = this;
            this.userIdService.takeUserId().subscribe(function (userId) {
                _this.store.dispatch(new LoadCustomerCoupons({
                    userId: userId,
                    pageSize: pageSize,
                    currentPage: currentPage,
                    sort: sort,
                }));
            });
        };
        /**
         * Returns customer coupon search result
         * @param pageSize page size
         */
        CustomerCouponService.prototype.getCustomerCoupons = function (pageSize) {
            var _this = this;
            return rxjs.combineLatest([
                this.store.pipe(i1.select(getCustomerCouponsState)),
                this.getClaimCustomerCouponResultLoading(),
            ]).pipe(operators.filter(function (_a) {
                var _b = __read(_a, 2), loading = _b[1];
                return !loading;
            }), operators.tap(function (_a) {
                var _b = __read(_a, 1), customerCouponsState = _b[0];
                var attemptedLoad = customerCouponsState.loading ||
                    customerCouponsState.success ||
                    customerCouponsState.error;
                if (!attemptedLoad) {
                    _this.loadCustomerCoupons(pageSize);
                }
            }), operators.map(function (_a) {
                var _b = __read(_a, 1), customerCouponsState = _b[0];
                return customerCouponsState.value;
            }));
        };
        /**
         * Returns a loaded flag for customer coupons
         */
        CustomerCouponService.prototype.getCustomerCouponsLoaded = function () {
            return this.store.pipe(i1.select(getCustomerCouponsLoaded));
        };
        /**
         * Returns a loading flag for customer coupons
         */
        CustomerCouponService.prototype.getCustomerCouponsLoading = function () {
            return this.store.pipe(i1.select(getCustomerCouponsLoading));
        };
        /**
         * Subscribe a CustomerCoupon Notification
         * @param couponCode a customer coupon code
         */
        CustomerCouponService.prototype.subscribeCustomerCoupon = function (couponCode) {
            var _this = this;
            this.userIdService.takeUserId().subscribe(function (userId) {
                _this.store.dispatch(new SubscribeCustomerCoupon({
                    userId: userId,
                    couponCode: couponCode,
                }));
            });
        };
        /**
         * Returns the subscribe customer coupon notification process loading flag
         */
        CustomerCouponService.prototype.getSubscribeCustomerCouponResultLoading = function () {
            return this.store.pipe(i1.select(getProcessLoadingFactory(SUBSCRIBE_CUSTOMER_COUPON_PROCESS_ID)));
        };
        /**
         * Returns the subscribe customer coupon notification process success flag
         */
        CustomerCouponService.prototype.getSubscribeCustomerCouponResultSuccess = function () {
            return this.store.pipe(i1.select(getProcessSuccessFactory(SUBSCRIBE_CUSTOMER_COUPON_PROCESS_ID)));
        };
        /**
         * Returns the subscribe customer coupon notification process error flag
         */
        CustomerCouponService.prototype.getSubscribeCustomerCouponResultError = function () {
            return this.store.pipe(i1.select(getProcessErrorFactory(SUBSCRIBE_CUSTOMER_COUPON_PROCESS_ID)));
        };
        /**
         * Unsubscribe a CustomerCoupon Notification
         * @param couponCode a customer coupon code
         */
        CustomerCouponService.prototype.unsubscribeCustomerCoupon = function (couponCode) {
            var _this = this;
            this.userIdService.takeUserId().subscribe(function (userId) {
                _this.store.dispatch(new UnsubscribeCustomerCoupon({
                    userId: userId,
                    couponCode: couponCode,
                }));
            });
        };
        /**
         * Returns the unsubscribe customer coupon notification process loading flag
         */
        CustomerCouponService.prototype.getUnsubscribeCustomerCouponResultLoading = function () {
            return this.store.pipe(i1.select(getProcessLoadingFactory(UNSUBSCRIBE_CUSTOMER_COUPON_PROCESS_ID)));
        };
        /**
         * Returns the unsubscribe customer coupon notification process success flag
         */
        CustomerCouponService.prototype.getUnsubscribeCustomerCouponResultSuccess = function () {
            return this.store.pipe(i1.select(getProcessSuccessFactory(UNSUBSCRIBE_CUSTOMER_COUPON_PROCESS_ID)));
        };
        /**
         * Returns the unsubscribe customer coupon notification process error flag
         */
        CustomerCouponService.prototype.getUnsubscribeCustomerCouponResultError = function () {
            return this.store.pipe(i1.select(getProcessErrorFactory(UNSUBSCRIBE_CUSTOMER_COUPON_PROCESS_ID)));
        };
        /**
         * Claim a CustomerCoupon
         * @param couponCode a customer coupon code
         */
        CustomerCouponService.prototype.claimCustomerCoupon = function (couponCode) {
            var _this = this;
            this.userIdService.takeUserId().subscribe(function (userId) {
                _this.store.dispatch(new ClaimCustomerCoupon({
                    userId: userId,
                    couponCode: couponCode,
                }));
            });
        };
        /**
         * Returns the claim customer coupon notification process success flag
         */
        CustomerCouponService.prototype.getClaimCustomerCouponResultSuccess = function () {
            return this.store.pipe(i1.select(getProcessSuccessFactory(CLAIM_CUSTOMER_COUPON_PROCESS_ID)));
        };
        /**
         * Returns the claim customer coupon notification process loading flag
         */
        CustomerCouponService.prototype.getClaimCustomerCouponResultLoading = function () {
            return this.store.pipe(i1.select(getProcessLoadingFactory(CLAIM_CUSTOMER_COUPON_PROCESS_ID)));
        };
        return CustomerCouponService;
    }());
    CustomerCouponService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CustomerCouponService, deps: [{ token: i1__namespace$2.Store }, { token: UserIdService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    CustomerCouponService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CustomerCouponService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CustomerCouponService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace$2.Store }, { type: UserIdService }]; } });

    /**
     * @deprecated since 4.2 - use OrderReturnRequestFacade in @spartacus/order/root instead
     * TODO: In order lib, processStateStore is added in OrderReturnService's constructor,
     * need to update it in 5.0 migration doc.
     */
    var OrderReturnRequestService = /** @class */ (function () {
        function OrderReturnRequestService(store, userIdService) {
            this.store = store;
            this.userIdService = userIdService;
        }
        /**
         * Create order return request
         * @param orderCode an order code
         * @param returnRequestInput order return request entry input
         */
        OrderReturnRequestService.prototype.createOrderReturnRequest = function (returnRequestInput) {
            var _this = this;
            this.userIdService.takeUserId().subscribe(function (userId) {
                _this.store.dispatch(new CreateOrderReturnRequest({
                    userId: userId,
                    returnRequestInput: returnRequestInput,
                }));
            });
        };
        /**
         * Return an order return request
         */
        OrderReturnRequestService.prototype.getOrderReturnRequest = function () {
            return this.store.pipe(i1.select(getOrderReturnRequest));
        };
        /**
         * Gets order return request list
         */
        OrderReturnRequestService.prototype.getOrderReturnRequestList = function (pageSize) {
            var _this = this;
            return this.store.pipe(i1.select(getOrderReturnRequestListState), operators.tap(function (returnListState) {
                var attemptedLoad = returnListState.loading ||
                    returnListState.success ||
                    returnListState.error;
                if (!attemptedLoad) {
                    _this.loadOrderReturnRequestList(pageSize);
                }
            }), operators.map(function (returnListState) { return returnListState.value; }));
        };
        /**
         * Loads order return request detail
         * @param returnRequestCode
         */
        OrderReturnRequestService.prototype.loadOrderReturnRequestDetail = function (returnRequestCode) {
            var _this = this;
            this.userIdService.takeUserId().subscribe(function (userId) {
                _this.store.dispatch(new LoadOrderReturnRequest({
                    userId: userId,
                    returnRequestCode: returnRequestCode,
                }));
            });
        };
        /**
         * Loads order return request list
         * @param pageSize page size
         * @param currentPage current page
         * @param sort sort
         */
        OrderReturnRequestService.prototype.loadOrderReturnRequestList = function (pageSize, currentPage, sort) {
            var _this = this;
            this.userIdService.takeUserId(true).subscribe(function (userId) {
                _this.store.dispatch(new LoadOrderReturnRequestList({
                    userId: userId,
                    pageSize: pageSize,
                    currentPage: currentPage,
                    sort: sort,
                }));
            }, function () {
                // TODO: for future releases, refactor this part to thrown errors
            });
        };
        /**
         * Cleaning order return request list
         */
        OrderReturnRequestService.prototype.clearOrderReturnRequestList = function () {
            this.store.dispatch(new ClearOrderReturnRequestList());
        };
        /**
         * Get the order return request loading flag
         */
        OrderReturnRequestService.prototype.getReturnRequestLoading = function () {
            return this.store.pipe(i1.select(getOrderReturnRequestLoading));
        };
        /**
         * Get the order return request success flag
         */
        OrderReturnRequestService.prototype.getReturnRequestSuccess = function () {
            return this.store.pipe(i1.select(getOrderReturnRequestSuccess));
        };
        /**
         * Cleaning order return request details
         */
        OrderReturnRequestService.prototype.clearOrderReturnRequestDetail = function () {
            this.store.dispatch(new ClearOrderReturnRequest());
        };
        /*
         * Cancel order return request
         */
        OrderReturnRequestService.prototype.cancelOrderReturnRequest = function (returnRequestCode, returnRequestModification) {
            var _this = this;
            this.userIdService.takeUserId().subscribe(function (userId) {
                _this.store.dispatch(new CancelOrderReturnRequest({
                    userId: userId,
                    returnRequestCode: returnRequestCode,
                    returnRequestModification: returnRequestModification,
                }));
            });
        };
        /**
         * Returns the cancel return request loading flag
         */
        OrderReturnRequestService.prototype.getCancelReturnRequestLoading = function () {
            return this.store.pipe(i1.select(getProcessLoadingFactory(CANCEL_RETURN_PROCESS_ID)));
        };
        /**
         * Returns the cancel return request success flag
         */
        OrderReturnRequestService.prototype.getCancelReturnRequestSuccess = function () {
            return this.store.pipe(i1.select(getProcessSuccessFactory(CANCEL_RETURN_PROCESS_ID)));
        };
        /**
         * Resets the cancel return request process flags
         */
        OrderReturnRequestService.prototype.resetCancelReturnRequestProcessState = function () {
            return this.store.dispatch(new ResetCancelReturnProcess());
        };
        return OrderReturnRequestService;
    }());
    OrderReturnRequestService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OrderReturnRequestService, deps: [{ token: i1__namespace$2.Store }, { token: UserIdService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    OrderReturnRequestService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OrderReturnRequestService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OrderReturnRequestService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace$2.Store }, { type: UserIdService }]; } });

    var UserAddressService = /** @class */ (function () {
        function UserAddressService(store, userIdService, userAddressConnector, command) {
            var _this = this;
            this.store = store;
            this.userIdService = userIdService;
            this.userAddressConnector = userAddressConnector;
            this.command = command;
            this.userAddressVerificationCommand = this.command.create(function (payload) { return _this.userIdService
                .takeUserId(false)
                .pipe(operators.switchMap(function (userId) { return _this.userAddressConnector.verify(userId, payload.address); })); });
        }
        /**
         * Retrieves user's addresses
         */
        UserAddressService.prototype.loadAddresses = function () {
            var _this = this;
            this.userIdService.takeUserId().subscribe(function (userId) {
                _this.store.dispatch(new LoadUserAddresses(userId));
            });
        };
        /**
         * Adds user address
         * @param address a user address
         */
        UserAddressService.prototype.addUserAddress = function (address) {
            var _this = this;
            this.userIdService.takeUserId().subscribe(function (userId) {
                _this.store.dispatch(new AddUserAddress({
                    userId: userId,
                    address: address,
                }));
            });
        };
        /**
         * Sets user address as default
         * @param addressId a user address ID
         */
        UserAddressService.prototype.setAddressAsDefault = function (addressId) {
            var _this = this;
            this.userIdService.takeUserId().subscribe(function (userId) {
                _this.store.dispatch(new UpdateUserAddress({
                    userId: userId,
                    addressId: addressId,
                    address: { defaultAddress: true },
                }));
            });
        };
        /**
         * Updates existing user address
         * @param addressId a user address ID
         * @param address a user address
         */
        UserAddressService.prototype.updateUserAddress = function (addressId, address) {
            var _this = this;
            this.userIdService.takeUserId().subscribe(function (userId) {
                _this.store.dispatch(new UpdateUserAddress({
                    userId: userId,
                    addressId: addressId,
                    address: address,
                }));
            });
        };
        /**
         * Deletes existing user address
         * @param addressId a user address ID
         */
        UserAddressService.prototype.deleteUserAddress = function (addressId) {
            var _this = this;
            this.userIdService.takeUserId().subscribe(function (userId) {
                _this.store.dispatch(new DeleteUserAddress({
                    userId: userId,
                    addressId: addressId,
                }));
            });
        };
        /**
         * Returns addresses
         */
        UserAddressService.prototype.getAddresses = function () {
            return this.store.pipe(i1.select(getAddresses));
        };
        /**
         * Returns a loading flag for addresses
         */
        UserAddressService.prototype.getAddressesLoading = function () {
            return this.store.pipe(i1.select(getAddressesLoading));
        };
        UserAddressService.prototype.getAddressesLoadedSuccess = function () {
            return this.store.pipe(i1.select(getAddressesLoadedSuccess));
        };
        /**
         * Retrieves delivery countries
         */
        UserAddressService.prototype.loadDeliveryCountries = function () {
            this.store.dispatch(new LoadDeliveryCountries());
        };
        /**
         * Returns all delivery countries
         */
        UserAddressService.prototype.getDeliveryCountries = function () {
            return this.store.pipe(i1.select(getAllDeliveryCountries));
        };
        /**
         * Returns a country based on the provided `isocode`
         * @param isocode an isocode for a country
         */
        UserAddressService.prototype.getCountry = function (isocode) {
            return this.store.pipe(i1.select(countrySelectorFactory(isocode)));
        };
        /**
         * Retrieves regions for specified country by `countryIsoCode`
         * @param countryIsoCode
         */
        UserAddressService.prototype.loadRegions = function (countryIsoCode) {
            this.store.dispatch(new LoadRegions(countryIsoCode));
        };
        /**
         * Clear regions in store - useful when changing country
         */
        UserAddressService.prototype.clearRegions = function () {
            this.store.dispatch(new ClearRegions());
        };
        /**
         * Returns all regions
         */
        UserAddressService.prototype.getRegions = function (countryIsoCode) {
            var _this = this;
            return this.store.pipe(i1.select(getRegionsDataAndLoading), operators.map(function (_a) {
                var regions = _a.regions, country = _a.country, loading = _a.loading, loaded = _a.loaded;
                if (!countryIsoCode && (loading || loaded)) {
                    _this.clearRegions();
                    return [];
                }
                else if (loading && !loaded) {
                    // don't interrupt loading
                    return [];
                }
                else if (!loading && countryIsoCode !== country && countryIsoCode) {
                    // country changed - clear store and load new regions
                    if (country) {
                        _this.clearRegions();
                    }
                    _this.loadRegions(countryIsoCode);
                    return [];
                }
                return regions;
            }));
        };
        /**
         * Verifies the address
         * @param address : the address to be verified
         */
        UserAddressService.prototype.verifyAddress = function (address) {
            return this.userAddressVerificationCommand.execute({ address: address });
        };
        return UserAddressService;
    }());
    UserAddressService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserAddressService, deps: [{ token: i1__namespace$2.Store }, { token: UserIdService }, { token: UserAddressConnector }, { token: CommandService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    UserAddressService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserAddressService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserAddressService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace$2.Store }, { type: UserIdService }, { type: UserAddressConnector }, { type: CommandService }]; } });

    var UserCostCenterService = /** @class */ (function () {
        function UserCostCenterService(store, userIdService) {
            this.store = store;
            this.userIdService = userIdService;
        }
        /**
         * Load all visible active cost centers for the currently login user
         */
        UserCostCenterService.prototype.loadActiveCostCenters = function () {
            var _this = this;
            this.userIdService.takeUserId(true).subscribe(function (userId) {
                _this.store.dispatch(new LoadActiveCostCenters(userId));
            }, function () {
                // TODO: for future releases, refactor this part to thrown errors
            });
        };
        UserCostCenterService.prototype.getCostCentersState = function () {
            return this.store.select(getCostCentersState);
        };
        /**
         * Get all visible active cost centers
         */
        UserCostCenterService.prototype.getActiveCostCenters = function () {
            var _this = this;
            return this.getCostCentersState().pipe(operators.observeOn(rxjs.queueScheduler), operators.tap(function (process) {
                if (!(process.loading || process.success || process.error)) {
                    _this.loadActiveCostCenters();
                }
            }), operators.filter(function (process) { return process.success || process.error; }), operators.map(function (result) { return result.value; }));
        };
        /**
         * Get the addresses of the cost center's unit based on cost center id
         * @param costCenterId cost center id
         */
        UserCostCenterService.prototype.getCostCenterAddresses = function (costCenterId) {
            return this.getActiveCostCenters().pipe(operators.map(function (costCenters) {
                var costCenter = costCenters.find(function (cc) { return cc.code === costCenterId; });
                if (costCenter && costCenter.unit) {
                    return costCenter.unit.addresses;
                }
                else {
                    return [];
                }
            }));
        };
        return UserCostCenterService;
    }());
    UserCostCenterService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserCostCenterService, deps: [{ token: i1__namespace$2.Store }, { token: UserIdService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    UserCostCenterService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserCostCenterService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserCostCenterService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace$2.Store }, { type: UserIdService }]; } });

    var UserInterestsService = /** @class */ (function () {
        function UserInterestsService(store, userIdService) {
            this.store = store;
            this.userIdService = userIdService;
        }
        /**
         * Retrieves an product interest list
         * @param pageSize page size
         * @param currentPage current page
         * @param sort sort
         */
        UserInterestsService.prototype.loadProductInterests = function (pageSize, currentPage, sort, productCode, notificationType) {
            var _this = this;
            this.userIdService.takeUserId().subscribe(function (userId) {
                _this.store.dispatch(new LoadProductInterests({
                    userId: userId,
                    pageSize: pageSize,
                    currentPage: currentPage,
                    sort: sort,
                    productCode: productCode,
                    notificationType: notificationType,
                }));
            });
        };
        /**
         * Returns product interests
         */
        UserInterestsService.prototype.getProductInterests = function () {
            return this.store.pipe(i1.select(getInterests));
        };
        /**
         * Returns product interests
         * @param pageSize the page size
         */
        UserInterestsService.prototype.getAndLoadProductInterests = function (pageSize) {
            var _this = this;
            return this.store.pipe(i1.select(getInterestsState), operators.tap(function (interestListState) {
                var attemptedLoad = interestListState.loading ||
                    interestListState.success ||
                    interestListState.error;
                if (!attemptedLoad) {
                    _this.loadProductInterests(pageSize);
                }
            }), operators.map(function (interestListState) { return interestListState.value; }));
        };
        /**
         * Returns a loading flag for product interests
         */
        UserInterestsService.prototype.getProdutInterestsLoading = function () {
            return this.store.pipe(i1.select(getInterestsLoading));
        };
        /**
         * Removes a ProductInterestRelation
         * @param item product interest relation item
         * @param singleDelete flag to delete only one interest
         */
        UserInterestsService.prototype.removeProdutInterest = function (item, singleDelete) {
            var _this = this;
            this.userIdService.takeUserId().subscribe(function (userId) {
                _this.store.dispatch(new RemoveProductInterest({
                    userId: userId,
                    item: item,
                    singleDelete: singleDelete,
                }));
            });
        };
        /**
         * Returns a loading flag for removing product interests.
         */
        UserInterestsService.prototype.getRemoveProdutInterestLoading = function () {
            return this.store.pipe(i1.select(getProcessLoadingFactory(REMOVE_PRODUCT_INTERESTS_PROCESS_ID)));
        };
        /**
         * Returns a success flag for removing a product interests.
         */
        UserInterestsService.prototype.getRemoveProdutInterestSuccess = function () {
            return this.store.pipe(i1.select(getProcessSuccessFactory(REMOVE_PRODUCT_INTERESTS_PROCESS_ID)));
        };
        /**
         * Add a new product interest.
         *
         * @param productCode the product code
         * @param notificationType the notification type
         */
        UserInterestsService.prototype.addProductInterest = function (productCode, notificationType) {
            var _this = this;
            this.userIdService.takeUserId().subscribe(function (userId) {
                _this.store.dispatch(new AddProductInterest({
                    userId: userId,
                    productCode: productCode,
                    notificationType: notificationType,
                }));
            });
        };
        /**
         * Returns a success flag for adding a product interest.
         */
        UserInterestsService.prototype.getAddProductInterestSuccess = function () {
            return this.store.pipe(i1.select(getProcessSuccessFactory(ADD_PRODUCT_INTEREST_PROCESS_ID)));
        };
        /**
         * Returns a error flag for adding a product interest.
         */
        UserInterestsService.prototype.getAddProductInterestError = function () {
            return this.store.pipe(i1.select(getProcessErrorFactory(ADD_PRODUCT_INTEREST_PROCESS_ID)));
        };
        /**
         * Reset product interest adding state.
         */
        UserInterestsService.prototype.resetAddInterestState = function () {
            this.store.dispatch(new ResetAddInterestState());
        };
        /**
         * Reset product interest removing state.
         */
        UserInterestsService.prototype.resetRemoveInterestState = function () {
            this.store.dispatch(new ResetRemoveInterestState());
        };
        /**
         * Clears product interests
         */
        UserInterestsService.prototype.clearProductInterests = function () {
            this.store.dispatch(new ClearProductInterests());
        };
        return UserInterestsService;
    }());
    UserInterestsService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserInterestsService, deps: [{ token: i1__namespace$2.Store }, { token: UserIdService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    UserInterestsService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserInterestsService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserInterestsService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace$2.Store }, { type: UserIdService }]; } });

    var UserNotificationPreferenceService = /** @class */ (function () {
        function UserNotificationPreferenceService(store, userIdService) {
            this.store = store;
            this.userIdService = userIdService;
        }
        /**
         * Returns all notification preferences.
         */
        UserNotificationPreferenceService.prototype.getPreferences = function () {
            return this.store.pipe(i1.select(getPreferences));
        };
        /**
         * Returns all enabled notification preferences.
         */
        UserNotificationPreferenceService.prototype.getEnabledPreferences = function () {
            return this.store.pipe(i1.select(getEnabledPreferences));
        };
        /**
         * Loads all notification preferences.
         */
        UserNotificationPreferenceService.prototype.loadPreferences = function () {
            var _this = this;
            this.userIdService.takeUserId().subscribe(function (userId) {
                _this.store.dispatch(new LoadNotificationPreferences(userId));
            });
        };
        /**
         * Clear all notification preferences.
         */
        UserNotificationPreferenceService.prototype.clearPreferences = function () {
            this.store.dispatch(new ClearNotificationPreferences());
        };
        /**
         * Returns a loading flag for notification preferences.
         */
        UserNotificationPreferenceService.prototype.getPreferencesLoading = function () {
            return this.store.pipe(i1.select(getPreferencesLoading));
        };
        /**
         * Updating notification preferences.
         * @param preferences a preference list
         */
        UserNotificationPreferenceService.prototype.updatePreferences = function (preferences) {
            var _this = this;
            this.userIdService.takeUserId().subscribe(function (userId) {
                _this.store.dispatch(new UpdateNotificationPreferences({
                    userId: userId,
                    preferences: preferences,
                }));
            });
        };
        /**
         * Returns a loading flag for updating preferences.
         */
        UserNotificationPreferenceService.prototype.getUpdatePreferencesResultLoading = function () {
            return this.store.select(getProcessLoadingFactory(UPDATE_NOTIFICATION_PREFERENCES_PROCESS_ID));
        };
        /**
         * Resets the update notification preferences process state. The state needs to be
         * reset after the process concludes, regardless if it's a success or an error.
         */
        UserNotificationPreferenceService.prototype.resetNotificationPreferences = function () {
            this.store.dispatch(new ResetNotificationPreferences());
        };
        return UserNotificationPreferenceService;
    }());
    UserNotificationPreferenceService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserNotificationPreferenceService, deps: [{ token: i1__namespace$2.Store }, { token: UserIdService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    UserNotificationPreferenceService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserNotificationPreferenceService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserNotificationPreferenceService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace$2.Store }, { type: UserIdService }]; } });

    /**
     * @deprecated since 4.2 - use OrderFacade in @spartacus/order/root instead
     * TODO: In order lib, processStateStore is added in OrderService's constructor,
     * need to update it in 5.0 migration doc.
     */
    var UserOrderService = /** @class */ (function () {
        function UserOrderService(store, userIdService, routingService) {
            this.store = store;
            this.userIdService = userIdService;
            this.routingService = routingService;
        }
        /**
         * Returns an order's detail
         */
        UserOrderService.prototype.getOrderDetails = function () {
            return this.store.pipe(i1.select(getOrderDetails));
        };
        /**
         * Retrieves order's details
         *
         * @param orderCode an order code
         */
        UserOrderService.prototype.loadOrderDetails = function (orderCode) {
            var _this = this;
            this.userIdService.takeUserId().subscribe(function (userId) {
                _this.store.dispatch(new LoadOrderDetails({
                    userId: userId,
                    orderCode: orderCode,
                }));
            });
        };
        /**
         * Clears order's details
         */
        UserOrderService.prototype.clearOrderDetails = function () {
            this.store.dispatch(new ClearOrderDetails());
        };
        /**
         * Returns order history list
         */
        UserOrderService.prototype.getOrderHistoryList = function (pageSize) {
            var _this = this;
            return this.store.pipe(i1.select(getOrdersState), operators.tap(function (orderListState) {
                var attemptedLoad = orderListState.loading ||
                    orderListState.success ||
                    orderListState.error;
                if (!attemptedLoad) {
                    _this.loadOrderList(pageSize);
                }
            }), operators.map(function (orderListState) { return orderListState.value; }));
        };
        /**
         * Returns a loaded flag for order history list
         */
        UserOrderService.prototype.getOrderHistoryListLoaded = function () {
            return this.store.pipe(i1.select(getOrdersLoaded));
        };
        /**
         * Retrieves an order list
         * @param pageSize page size
         * @param currentPage current page
         * @param sort sort
         */
        UserOrderService.prototype.loadOrderList = function (pageSize, currentPage, sort) {
            var _this = this;
            this.userIdService.takeUserId(true).subscribe(function (userId) {
                var replenishmentOrderCode;
                _this.routingService
                    .getRouterState()
                    .pipe(operators.take(1))
                    .subscribe(function (data) {
                    var _a, _b;
                    replenishmentOrderCode =
                        (_b = (_a = data === null || data === void 0 ? void 0 : data.state) === null || _a === void 0 ? void 0 : _a.params) === null || _b === void 0 ? void 0 : _b.replenishmentOrderCode;
                })
                    .unsubscribe();
                _this.store.dispatch(new LoadUserOrders({
                    userId: userId,
                    pageSize: pageSize,
                    currentPage: currentPage,
                    sort: sort,
                    replenishmentOrderCode: replenishmentOrderCode,
                }));
            }, function () {
                // TODO: for future releases, refactor this part to thrown errors
            });
        };
        /**
         * Cleaning order list
         */
        UserOrderService.prototype.clearOrderList = function () {
            this.store.dispatch(new ClearUserOrders());
        };
        /**
         *  Returns a consignment tracking detail
         */
        UserOrderService.prototype.getConsignmentTracking = function () {
            return this.store.pipe(i1.select(getConsignmentTracking));
        };
        /**
         * Retrieves consignment tracking details
         * @param orderCode an order code
         * @param consignmentCode a consignment code
         */
        UserOrderService.prototype.loadConsignmentTracking = function (orderCode, consignmentCode) {
            var _this = this;
            this.userIdService.takeUserId().subscribe(function (userId) {
                _this.store.dispatch(new LoadConsignmentTracking({
                    userId: userId,
                    orderCode: orderCode,
                    consignmentCode: consignmentCode,
                }));
            });
        };
        /**
         * Cleaning consignment tracking
         */
        UserOrderService.prototype.clearConsignmentTracking = function () {
            this.store.dispatch(new ClearConsignmentTracking());
        };
        /*
         * Cancel an order
         */
        UserOrderService.prototype.cancelOrder = function (orderCode, cancelRequestInput) {
            var _this = this;
            this.userIdService.takeUserId().subscribe(function (userId) {
                _this.store.dispatch(new CancelOrder({
                    userId: userId,
                    orderCode: orderCode,
                    cancelRequestInput: cancelRequestInput,
                }));
            });
        };
        /**
         * Returns the cancel order loading flag
         */
        UserOrderService.prototype.getCancelOrderLoading = function () {
            return this.store.pipe(i1.select(getProcessLoadingFactory(CANCEL_ORDER_PROCESS_ID)));
        };
        /**
         * Returns the cancel order success flag
         */
        UserOrderService.prototype.getCancelOrderSuccess = function () {
            return this.store.pipe(i1.select(getProcessSuccessFactory(CANCEL_ORDER_PROCESS_ID)));
        };
        /**
         * Resets the cancel order process flags
         */
        UserOrderService.prototype.resetCancelOrderProcessState = function () {
            return this.store.dispatch(new ResetCancelOrderProcess());
        };
        return UserOrderService;
    }());
    UserOrderService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserOrderService, deps: [{ token: i1__namespace$2.Store }, { token: UserIdService }, { token: RoutingService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    UserOrderService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserOrderService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserOrderService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace$2.Store }, { type: UserIdService }, { type: RoutingService }]; } });

    var UserPaymentService = /** @class */ (function () {
        function UserPaymentService(store, userIdService) {
            this.store = store;
            this.userIdService = userIdService;
        }
        /**
         * Loads all user's payment methods.
         */
        UserPaymentService.prototype.loadPaymentMethods = function () {
            var _this = this;
            this.userIdService.takeUserId().subscribe(function (userId) {
                _this.store.dispatch(new LoadUserPaymentMethods(userId));
            });
        };
        /**
         * Returns all user's payment methods
         */
        UserPaymentService.prototype.getPaymentMethods = function () {
            return this.store.pipe(i1.select(getPaymentMethods));
        };
        /**
         * Returns a loading flag for payment methods
         */
        UserPaymentService.prototype.getPaymentMethodsLoading = function () {
            return this.store.pipe(i1.select(getPaymentMethodsLoading));
        };
        UserPaymentService.prototype.getPaymentMethodsLoadedSuccess = function () {
            return this.store.pipe(i1.select(getPaymentMethodsLoadedSuccess));
        };
        /**
         * Sets the payment as a default one
         * @param paymentMethodId a payment method ID
         */
        UserPaymentService.prototype.setPaymentMethodAsDefault = function (paymentMethodId) {
            var _this = this;
            this.userIdService.takeUserId().subscribe(function (userId) {
                _this.store.dispatch(new SetDefaultUserPaymentMethod({
                    userId: userId,
                    paymentMethodId: paymentMethodId,
                }));
            });
        };
        /**
         * Deletes the payment method
         *
         * @param paymentMethodId a payment method ID
         */
        UserPaymentService.prototype.deletePaymentMethod = function (paymentMethodId) {
            var _this = this;
            this.userIdService.takeUserId().subscribe(function (userId) {
                _this.store.dispatch(new DeleteUserPaymentMethod({
                    userId: userId,
                    paymentMethodId: paymentMethodId,
                }));
            });
        };
        /**
         * Returns all billing countries
         */
        UserPaymentService.prototype.getAllBillingCountries = function () {
            return this.store.pipe(i1.select(getAllBillingCountries));
        };
        /**
         * Retrieves billing countries
         */
        UserPaymentService.prototype.loadBillingCountries = function () {
            this.store.dispatch(new LoadBillingCountries());
        };
        return UserPaymentService;
    }());
    UserPaymentService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserPaymentService, deps: [{ token: i1__namespace$2.Store }, { token: UserIdService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    UserPaymentService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserPaymentService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserPaymentService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace$2.Store }, { type: UserIdService }]; } });

    /**
     * @deprecated since 4.2 - use ReplenishmentOrderFacade in @spartacus/order/root instead
     * TODO: In order lib, processStateStore is added in ReplenishmentOrderService's constructor,
     * need to update it in 5.0 migration doc.
     */
    var UserReplenishmentOrderService = /** @class */ (function () {
        function UserReplenishmentOrderService(store, userIdService) {
            this.store = store;
            this.userIdService = userIdService;
        }
        /**
         * Returns replenishment order details for a given 'current' user
         *
         * @param replenishmentOrderCode a replenishment order code
         */
        UserReplenishmentOrderService.prototype.loadReplenishmentOrderDetails = function (replenishmentOrderCode) {
            var _this = this;
            this.userIdService.takeUserId(true).subscribe(function (userId) {
                _this.store.dispatch(new LoadReplenishmentOrderDetails({
                    userId: userId,
                    replenishmentOrderCode: replenishmentOrderCode,
                }));
            }, function () {
                // TODO: for future releases, refactor this part to thrown errors
            });
        };
        /**
         * Returns a replenishment order details
         */
        UserReplenishmentOrderService.prototype.getReplenishmentOrderDetails = function () {
            return this.store.pipe(i1.select(getReplenishmentOrderDetailsValue));
        };
        /**
         * Returns a replenishment order details loading flag
         */
        UserReplenishmentOrderService.prototype.getReplenishmentOrderDetailsLoading = function () {
            return this.store.pipe(i1.select(getReplenishmentOrderDetailsLoading));
        };
        /**
         * Returns a replenishment order details success flag
         */
        UserReplenishmentOrderService.prototype.getReplenishmentOrderDetailsSuccess = function () {
            return this.store.pipe(i1.select(getReplenishmentOrderDetailsSuccess));
        };
        /**
         * Returns a replenishment order details error flag
         */
        UserReplenishmentOrderService.prototype.getReplenishmentOrderDetailsError = function () {
            return this.store.pipe(i1.select(getReplenishmentOrderDetailsError));
        };
        /**
         * Clears the replenishment orders details state
         */
        UserReplenishmentOrderService.prototype.clearReplenishmentOrderDetails = function () {
            this.store.dispatch(new ClearReplenishmentOrderDetails());
        };
        /**
         * Cancels a specific replenishment order for a given 'current' user
         *
         * @param replenishmentOrderCode a replenishment order code
         */
        UserReplenishmentOrderService.prototype.cancelReplenishmentOrder = function (replenishmentOrderCode) {
            var _this = this;
            this.userIdService.takeUserId(true).subscribe(function (userId) {
                _this.store.dispatch(new CancelReplenishmentOrder({
                    userId: userId,
                    replenishmentOrderCode: replenishmentOrderCode,
                }));
            }, function () {
                // TODO: for future releases, refactor this part to thrown errors
            });
        };
        /**
         * Returns the cancel replenishment order loading flag
         */
        UserReplenishmentOrderService.prototype.getCancelReplenishmentOrderLoading = function () {
            return this.store.pipe(i1.select(getProcessLoadingFactory(CANCEL_REPLENISHMENT_ORDER_PROCESS_ID)));
        };
        /**
         * Returns the cancel replenishment order success flag
         */
        UserReplenishmentOrderService.prototype.getCancelReplenishmentOrderSuccess = function () {
            return this.store.pipe(i1.select(getProcessSuccessFactory(CANCEL_REPLENISHMENT_ORDER_PROCESS_ID)));
        };
        /**
         * Returns the cancel replenishment order error flag
         */
        UserReplenishmentOrderService.prototype.getCancelReplenishmentOrderError = function () {
            return this.store.pipe(i1.select(getProcessErrorFactory(CANCEL_REPLENISHMENT_ORDER_PROCESS_ID)));
        };
        /**
         * Clears the cancel replenishment order processing state
         */
        UserReplenishmentOrderService.prototype.clearCancelReplenishmentOrderProcessState = function () {
            this.store.dispatch(new ClearCancelReplenishmentOrder());
        };
        /**
         * Returns replenishment order history list
         */
        UserReplenishmentOrderService.prototype.getReplenishmentOrderHistoryList = function (pageSize) {
            var _this = this;
            return this.store.pipe(i1.select(getReplenishmentOrdersState), operators.tap(function (replenishmentOrderListState) {
                var attemptedLoad = replenishmentOrderListState.loading ||
                    replenishmentOrderListState.success ||
                    replenishmentOrderListState.error;
                if (!attemptedLoad) {
                    _this.loadReplenishmentOrderList(pageSize);
                }
            }), operators.map(function (replenishmentOrderListState) { return replenishmentOrderListState.value; }));
        };
        /**
         * Returns a loading flag for replenishment order history list
         */
        UserReplenishmentOrderService.prototype.getReplenishmentOrderHistoryListLoading = function () {
            return this.store.pipe(i1.select(getReplenishmentOrdersLoading));
        };
        /**
         * Returns a error flag for replenishment order history list
         */
        UserReplenishmentOrderService.prototype.getReplenishmentOrderHistoryListError = function () {
            return this.store.pipe(i1.select(getReplenishmentOrdersError));
        };
        /**
         * Returns a success flag for replenishment order history list
         */
        UserReplenishmentOrderService.prototype.getReplenishmentOrderHistoryListSuccess = function () {
            return this.store.pipe(i1.select(getReplenishmentOrdersSuccess));
        };
        /**
         * Retrieves a replenishment order list
         * @param pageSize page size
         * @param currentPage current page
         * @param sort sort
         */
        UserReplenishmentOrderService.prototype.loadReplenishmentOrderList = function (pageSize, currentPage, sort) {
            var _this = this;
            this.userIdService.takeUserId(true).subscribe(function (userId) {
                _this.store.dispatch(new LoadUserReplenishmentOrders({
                    userId: userId,
                    pageSize: pageSize,
                    currentPage: currentPage,
                    sort: sort,
                }));
            }, function () {
                // TODO: for future releases, refactor this part to thrown errors
            });
        };
        /**
         * Cleaning replenishment order list
         */
        UserReplenishmentOrderService.prototype.clearReplenishmentOrderList = function () {
            this.store.dispatch(new ClearUserReplenishmentOrders());
        };
        return UserReplenishmentOrderService;
    }());
    UserReplenishmentOrderService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserReplenishmentOrderService, deps: [{ token: i1__namespace$2.Store }, { token: UserIdService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    UserReplenishmentOrderService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserReplenishmentOrderService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserReplenishmentOrderService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace$2.Store }, { type: UserIdService }]; } });

    var BillingCountriesEffect = /** @class */ (function () {
        function BillingCountriesEffect(actions$, siteConnector) {
            var _this = this;
            this.actions$ = actions$;
            this.siteConnector = siteConnector;
            this.loadBillingCountries$ = this.actions$.pipe(i1$4.ofType(LOAD_BILLING_COUNTRIES), operators.switchMap(function () {
                return _this.siteConnector.getCountries(exports.CountryType.BILLING).pipe(operators.map(function (countries) { return new LoadBillingCountriesSuccess(countries); }), operators.catchError(function (error) { return rxjs.of(new LoadBillingCountriesFail(normalizeHttpError(error))); }));
            }));
        }
        return BillingCountriesEffect;
    }());
    BillingCountriesEffect.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: BillingCountriesEffect, deps: [{ token: i1__namespace$4.Actions }, { token: SiteConnector }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    BillingCountriesEffect.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: BillingCountriesEffect });
    __decorate([
        i1$4.Effect()
    ], BillingCountriesEffect.prototype, "loadBillingCountries$", void 0);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: BillingCountriesEffect, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: i1__namespace$4.Actions }, { type: SiteConnector }]; }, propDecorators: { loadBillingCountries$: [] } });

    var ClearMiscsDataEffect = /** @class */ (function () {
        function ClearMiscsDataEffect(actions$) {
            this.actions$ = actions$;
            this.clearMiscsData$ = this.actions$.pipe(i1$4.ofType(LANGUAGE_CHANGE, CURRENCY_CHANGE), operators.map(function () {
                return new ClearUserMiscsData();
            }));
        }
        return ClearMiscsDataEffect;
    }());
    ClearMiscsDataEffect.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ClearMiscsDataEffect, deps: [{ token: i1__namespace$4.Actions }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ClearMiscsDataEffect.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ClearMiscsDataEffect });
    __decorate([
        i1$4.Effect()
    ], ClearMiscsDataEffect.prototype, "clearMiscsData$", void 0);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ClearMiscsDataEffect, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: i1__namespace$4.Actions }]; }, propDecorators: { clearMiscsData$: [] } });

    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var ConsignmentTrackingEffects = /** @class */ (function () {
        function ConsignmentTrackingEffects(actions$, userOrderConnector) {
            var _this = this;
            this.actions$ = actions$;
            this.userOrderConnector = userOrderConnector;
            this.loadConsignmentTracking$ = this.actions$.pipe(i1$4.ofType(LOAD_CONSIGNMENT_TRACKING), operators.map(function (action) { return action.payload; }), operators.switchMap(function (payload) {
                return _this.userOrderConnector
                    .getConsignmentTracking(payload.orderCode, payload.consignmentCode, payload.userId)
                    .pipe(operators.map(function (tracking) { return new LoadConsignmentTrackingSuccess(tracking); }), operators.catchError(function (error) { return rxjs.of(new LoadConsignmentTrackingFail(normalizeHttpError(error))); }));
            }));
        }
        return ConsignmentTrackingEffects;
    }());
    ConsignmentTrackingEffects.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ConsignmentTrackingEffects, deps: [{ token: i1__namespace$4.Actions }, { token: UserOrderConnector }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ConsignmentTrackingEffects.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ConsignmentTrackingEffects });
    __decorate([
        i1$4.Effect()
    ], ConsignmentTrackingEffects.prototype, "loadConsignmentTracking$", void 0);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ConsignmentTrackingEffects, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: i1__namespace$4.Actions }, { type: UserOrderConnector }]; }, propDecorators: { loadConsignmentTracking$: [] } });

    var CustomerCouponEffects = /** @class */ (function () {
        function CustomerCouponEffects(actions$, customerCouponConnector) {
            var _this = this;
            this.actions$ = actions$;
            this.customerCouponConnector = customerCouponConnector;
            this.loadCustomerCoupons$ = this.actions$.pipe(i1$4.ofType(LOAD_CUSTOMER_COUPONS), operators.map(function (action) { return action.payload; }), operators.mergeMap(function (payload) {
                return _this.customerCouponConnector
                    .getCustomerCoupons(payload.userId, payload.pageSize, payload.currentPage, payload.sort)
                    .pipe(operators.map(function (coupons) {
                    return new LoadCustomerCouponsSuccess(coupons);
                }), operators.catchError(function (error) { return rxjs.of(new LoadCustomerCouponsFail(normalizeHttpError(error))); }));
            }));
            this.subscribeCustomerCoupon$ = this.actions$.pipe(i1$4.ofType(SUBSCRIBE_CUSTOMER_COUPON), operators.map(function (action) { return action.payload; }), operators.mergeMap(function (payload) {
                return _this.customerCouponConnector
                    .turnOnNotification(payload.userId, payload.couponCode)
                    .pipe(operators.map(function (data) {
                    return new SubscribeCustomerCouponSuccess(data);
                }), operators.catchError(function (error) { return rxjs.of(new SubscribeCustomerCouponFail(normalizeHttpError(error))); }));
            }));
            this.unsubscribeCustomerCoupon$ = this.actions$.pipe(i1$4.ofType(UNSUBSCRIBE_CUSTOMER_COUPON), operators.map(function (action) { return action.payload; }), operators.mergeMap(function (payload) {
                return _this.customerCouponConnector
                    .turnOffNotification(payload.userId, payload.couponCode)
                    .pipe(operators.map(function () {
                    return new UnsubscribeCustomerCouponSuccess(payload.couponCode);
                }), operators.catchError(function (error) { return rxjs.of(new UnsubscribeCustomerCouponFail(normalizeHttpError(error))); }));
            }));
            this.claimCustomerCoupon$ = this.actions$.pipe(i1$4.ofType(CLAIM_CUSTOMER_COUPON), operators.map(function (action) { return action.payload; }), operators.mergeMap(function (payload) {
                return _this.customerCouponConnector
                    .claimCustomerCoupon(payload.userId, payload.couponCode)
                    .pipe(operators.map(function (data) {
                    return new ClaimCustomerCouponSuccess(data);
                }), operators.catchError(function (error) { return rxjs.of(new ClaimCustomerCouponFail(normalizeHttpError(error))); }));
            }));
        }
        return CustomerCouponEffects;
    }());
    CustomerCouponEffects.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CustomerCouponEffects, deps: [{ token: i1__namespace$4.Actions }, { token: CustomerCouponConnector }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    CustomerCouponEffects.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CustomerCouponEffects });
    __decorate([
        i1$4.Effect()
    ], CustomerCouponEffects.prototype, "loadCustomerCoupons$", void 0);
    __decorate([
        i1$4.Effect()
    ], CustomerCouponEffects.prototype, "subscribeCustomerCoupon$", void 0);
    __decorate([
        i1$4.Effect()
    ], CustomerCouponEffects.prototype, "unsubscribeCustomerCoupon$", void 0);
    __decorate([
        i1$4.Effect()
    ], CustomerCouponEffects.prototype, "claimCustomerCoupon$", void 0);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CustomerCouponEffects, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: i1__namespace$4.Actions }, { type: CustomerCouponConnector }]; }, propDecorators: { loadCustomerCoupons$: [], subscribeCustomerCoupon$: [], unsubscribeCustomerCoupon$: [], claimCustomerCoupon$: [] } });

    var DeliveryCountriesEffects = /** @class */ (function () {
        function DeliveryCountriesEffects(actions$, siteConnector) {
            var _this = this;
            this.actions$ = actions$;
            this.siteConnector = siteConnector;
            this.loadDeliveryCountries$ = this.actions$.pipe(i1$4.ofType(LOAD_DELIVERY_COUNTRIES), operators.switchMap(function () {
                return _this.siteConnector.getCountries(exports.CountryType.SHIPPING).pipe(operators.map(function (countries) { return new LoadDeliveryCountriesSuccess(countries); }), operators.catchError(function (error) { return rxjs.of(new LoadDeliveryCountriesFail(normalizeHttpError(error))); }));
            }));
        }
        return DeliveryCountriesEffects;
    }());
    DeliveryCountriesEffects.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: DeliveryCountriesEffects, deps: [{ token: i1__namespace$4.Actions }, { token: SiteConnector }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    DeliveryCountriesEffects.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: DeliveryCountriesEffects });
    __decorate([
        i1$4.Effect()
    ], DeliveryCountriesEffects.prototype, "loadDeliveryCountries$", void 0);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: DeliveryCountriesEffects, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: i1__namespace$4.Actions }, { type: SiteConnector }]; }, propDecorators: { loadDeliveryCountries$: [] } });

    var NotificationPreferenceEffects = /** @class */ (function () {
        function NotificationPreferenceEffects(actions$, connector) {
            var _this = this;
            this.actions$ = actions$;
            this.connector = connector;
            this.loadPreferences$ = this.actions$.pipe(i1$4.ofType(LOAD_NOTIFICATION_PREFERENCES), operators.map(function (action) { return action.payload; }), operators.switchMap(function (payload) { return _this.connector.loadAll(payload).pipe(operators.map(function (preferences) { return new LoadNotificationPreferencesSuccess(preferences); }), operators.catchError(function (error) { return rxjs.of(new LoadNotificationPreferencesFail(normalizeHttpError(error))); })); }));
            this.updatePreferences$ = this.actions$.pipe(i1$4.ofType(UPDATE_NOTIFICATION_PREFERENCES), operators.map(function (action) { return action.payload; }), operators.mergeMap(function (payload) { return _this.connector.update(payload.userId, payload.preferences).pipe(operators.map(function () { return new UpdateNotificationPreferencesSuccess(payload.preferences); }), operators.catchError(function (error) { return rxjs.of(new UpdateNotificationPreferencesFail(normalizeHttpError(error))); })); }));
        }
        return NotificationPreferenceEffects;
    }());
    NotificationPreferenceEffects.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: NotificationPreferenceEffects, deps: [{ token: i1__namespace$4.Actions }, { token: UserNotificationPreferenceConnector }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    NotificationPreferenceEffects.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: NotificationPreferenceEffects });
    __decorate([
        i1$4.Effect()
    ], NotificationPreferenceEffects.prototype, "loadPreferences$", void 0);
    __decorate([
        i1$4.Effect()
    ], NotificationPreferenceEffects.prototype, "updatePreferences$", void 0);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: NotificationPreferenceEffects, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: i1__namespace$4.Actions }, { type: UserNotificationPreferenceConnector }]; }, propDecorators: { loadPreferences$: [], updatePreferences$: [] } });

    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var OrderDetailsEffect = /** @class */ (function () {
        function OrderDetailsEffect(actions$, orderConnector, globalMessageService) {
            var _this = this;
            this.actions$ = actions$;
            this.orderConnector = orderConnector;
            this.globalMessageService = globalMessageService;
            this.loadOrderDetails$ = this.actions$.pipe(i1$4.ofType(LOAD_ORDER_DETAILS), operators.map(function (action) { return action.payload; }), operators.switchMap(function (payload) {
                return _this.orderConnector.get(payload.userId, payload.orderCode).pipe(operators.map(function (order) {
                    return new LoadOrderDetailsSuccess(order);
                }), operators.catchError(function (error) { return rxjs.of(new LoadOrderDetailsFail(normalizeHttpError(error))); }));
            }));
            this.cancelOrder$ = this.actions$.pipe(i1$4.ofType(CANCEL_ORDER), operators.map(function (action) { return action.payload; }), operators.switchMap(function (payload) {
                return _this.orderConnector
                    .cancel(payload.userId, payload.orderCode, payload.cancelRequestInput)
                    .pipe(operators.map(function () { return new CancelOrderSuccess(); }), operators.catchError(function (error) {
                    var _a;
                    (_a = error.error) === null || _a === void 0 ? void 0 : _a.errors.forEach(function (err) { return _this.globalMessageService.add(err.message, exports.GlobalMessageType.MSG_TYPE_ERROR); });
                    return rxjs.of(new CancelOrderFail(normalizeHttpError(error)));
                }));
            }));
        }
        return OrderDetailsEffect;
    }());
    OrderDetailsEffect.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OrderDetailsEffect, deps: [{ token: i1__namespace$4.Actions }, { token: UserOrderConnector }, { token: GlobalMessageService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    OrderDetailsEffect.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OrderDetailsEffect });
    __decorate([
        i1$4.Effect()
    ], OrderDetailsEffect.prototype, "loadOrderDetails$", void 0);
    __decorate([
        i1$4.Effect()
    ], OrderDetailsEffect.prototype, "cancelOrder$", void 0);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OrderDetailsEffect, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: i1__namespace$4.Actions }, { type: UserOrderConnector }, { type: GlobalMessageService }]; }, propDecorators: { loadOrderDetails$: [], cancelOrder$: [] } });

    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var OrderReturnRequestEffect = /** @class */ (function () {
        function OrderReturnRequestEffect(actions$, orderConnector) {
            var _this = this;
            this.actions$ = actions$;
            this.orderConnector = orderConnector;
            this.createReturnRequest$ = this.actions$.pipe(i1$4.ofType(CREATE_ORDER_RETURN_REQUEST), operators.map(function (action) { return action.payload; }), operators.switchMap(function (payload) {
                return _this.orderConnector
                    .return(payload.userId, payload.returnRequestInput)
                    .pipe(operators.map(function (returnRequest) { return new CreateOrderReturnRequestSuccess(returnRequest); }), operators.catchError(function (error) { return rxjs.of(new CreateOrderReturnRequestFail(normalizeHttpError(error))); }));
            }));
            this.loadReturnRequest$ = this.actions$.pipe(i1$4.ofType(LOAD_ORDER_RETURN_REQUEST), operators.map(function (action) { return action.payload; }), operators.switchMap(function (payload) {
                return _this.orderConnector
                    .getReturnRequestDetail(payload.userId, payload.returnRequestCode)
                    .pipe(operators.map(function (returnRequest) { return new LoadOrderReturnRequestSuccess(returnRequest); }), operators.catchError(function (error) { return rxjs.of(new LoadOrderReturnRequestFail(normalizeHttpError(error))); }));
            }));
            this.cancelReturnRequest$ = this.actions$.pipe(i1$4.ofType(CANCEL_ORDER_RETURN_REQUEST), operators.map(function (action) { return action.payload; }), operators.switchMap(function (payload) {
                return _this.orderConnector
                    .cancelReturnRequest(payload.userId, payload.returnRequestCode, payload.returnRequestModification)
                    .pipe(operators.map(function () { return new CancelOrderReturnRequestSuccess(); }), operators.catchError(function (error) { return rxjs.of(new CancelOrderReturnRequestFail(normalizeHttpError(error))); }));
            }));
            this.loadReturnRequestList$ = this.actions$.pipe(i1$4.ofType(LOAD_ORDER_RETURN_REQUEST_LIST), operators.map(function (action) { return action.payload; }), operators.switchMap(function (payload) {
                return _this.orderConnector
                    .getReturnRequestList(payload.userId, payload.pageSize, payload.currentPage, payload.sort)
                    .pipe(operators.map(function (returnRequestList) { return new LoadOrderReturnRequestListSuccess(returnRequestList); }), operators.catchError(function (error) { return rxjs.of(new LoadOrderReturnRequestListFail(normalizeHttpError(error))); }));
            }));
        }
        return OrderReturnRequestEffect;
    }());
    OrderReturnRequestEffect.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OrderReturnRequestEffect, deps: [{ token: i1__namespace$4.Actions }, { token: UserOrderConnector }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    OrderReturnRequestEffect.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OrderReturnRequestEffect });
    __decorate([
        i1$4.Effect()
    ], OrderReturnRequestEffect.prototype, "createReturnRequest$", void 0);
    __decorate([
        i1$4.Effect()
    ], OrderReturnRequestEffect.prototype, "loadReturnRequest$", void 0);
    __decorate([
        i1$4.Effect()
    ], OrderReturnRequestEffect.prototype, "cancelReturnRequest$", void 0);
    __decorate([
        i1$4.Effect()
    ], OrderReturnRequestEffect.prototype, "loadReturnRequestList$", void 0);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: OrderReturnRequestEffect, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: i1__namespace$4.Actions }, { type: UserOrderConnector }]; }, propDecorators: { createReturnRequest$: [], loadReturnRequest$: [], cancelReturnRequest$: [], loadReturnRequestList$: [] } });

    var UserPaymentMethodsEffects = /** @class */ (function () {
        function UserPaymentMethodsEffects(actions$, userPaymentMethodConnector) {
            var _this = this;
            this.actions$ = actions$;
            this.userPaymentMethodConnector = userPaymentMethodConnector;
            this.loadUserPaymentMethods$ = this.actions$.pipe(i1$4.ofType(LOAD_USER_PAYMENT_METHODS), operators.map(function (action) { return action.payload; }), operators.mergeMap(function (payload) {
                return _this.userPaymentMethodConnector.getAll(payload).pipe(operators.map(function (payments) {
                    return new LoadUserPaymentMethodsSuccess(payments);
                }), operators.catchError(function (error) { return rxjs.of(new LoadUserPaymentMethodsFail(normalizeHttpError(error))); }));
            }));
            this.setDefaultUserPaymentMethod$ = this.actions$.pipe(i1$4.ofType(SET_DEFAULT_USER_PAYMENT_METHOD), operators.map(function (action) { return action.payload; }), operators.mergeMap(function (payload) {
                return _this.userPaymentMethodConnector
                    .setDefault(payload.userId, payload.paymentMethodId)
                    .pipe(operators.switchMap(function (data) { return [
                    new SetDefaultUserPaymentMethodSuccess(data),
                    new LoadUserPaymentMethods(payload.userId),
                ]; }), operators.catchError(function (error) { return rxjs.of(new SetDefaultUserPaymentMethodFail(normalizeHttpError(error))); }));
            }));
            this.deleteUserPaymentMethod$ = this.actions$.pipe(i1$4.ofType(DELETE_USER_PAYMENT_METHOD), operators.map(function (action) { return action.payload; }), operators.mergeMap(function (payload) {
                return _this.userPaymentMethodConnector
                    .delete(payload.userId, payload.paymentMethodId)
                    .pipe(operators.switchMap(function (data) { return [
                    new DeleteUserPaymentMethodSuccess(data),
                    new LoadUserPaymentMethods(payload.userId),
                ]; }), operators.catchError(function (error) { return rxjs.of(new DeleteUserPaymentMethodFail(normalizeHttpError(error))); }));
            }));
        }
        return UserPaymentMethodsEffects;
    }());
    UserPaymentMethodsEffects.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserPaymentMethodsEffects, deps: [{ token: i1__namespace$4.Actions }, { token: UserPaymentConnector }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    UserPaymentMethodsEffects.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserPaymentMethodsEffects });
    __decorate([
        i1$4.Effect()
    ], UserPaymentMethodsEffects.prototype, "loadUserPaymentMethods$", void 0);
    __decorate([
        i1$4.Effect()
    ], UserPaymentMethodsEffects.prototype, "setDefaultUserPaymentMethod$", void 0);
    __decorate([
        i1$4.Effect()
    ], UserPaymentMethodsEffects.prototype, "deleteUserPaymentMethod$", void 0);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserPaymentMethodsEffects, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: i1__namespace$4.Actions }, { type: UserPaymentConnector }]; }, propDecorators: { loadUserPaymentMethods$: [], setDefaultUserPaymentMethod$: [], deleteUserPaymentMethod$: [] } });

    var ProductInterestsEffect = /** @class */ (function () {
        function ProductInterestsEffect(actions$, userInterestsConnector) {
            var _this = this;
            this.actions$ = actions$;
            this.userInterestsConnector = userInterestsConnector;
            this.loadProductInteres$ = this.actions$.pipe(i1$4.ofType(LOAD_PRODUCT_INTERESTS), operators.map(function (action) { return action.payload; }), operators.switchMap(function (payload) {
                return _this.userInterestsConnector
                    .getInterests(payload.userId, payload.pageSize, payload.currentPage, payload.sort, payload.productCode, payload.notificationType)
                    .pipe(operators.map(function (interests) {
                    return new LoadProductInterestsSuccess(interests);
                }), operators.catchError(function (error) { return rxjs.of(new LoadProductInterestsFail(normalizeHttpError(error))); }));
            }));
            this.removeProductInterest$ = this.actions$.pipe(i1$4.ofType(REMOVE_PRODUCT_INTEREST), operators.map(function (action) { return action.payload; }), operators.switchMap(function (payload) { return _this.userInterestsConnector
                .removeInterest(payload.userId, payload.item)
                .pipe(operators.switchMap(function (data) { return [
                new LoadProductInterests(payload.singleDelete
                    ? {
                        userId: payload.userId,
                        productCode: payload.item.product.code,
                        notificationType: payload.item.productInterestEntry[0].interestType,
                    }
                    : { userId: payload.userId }),
                new RemoveProductInterestSuccess(data),
            ]; }), operators.catchError(function (error) { return rxjs.of(new RemoveProductInterestFail(normalizeHttpError(error))); })); }));
            this.addProductInterest$ = this.actions$.pipe(i1$4.ofType(ADD_PRODUCT_INTEREST), operators.map(function (action) { return action.payload; }), operators.switchMap(function (payload) { return _this.userInterestsConnector
                .addInterest(payload.userId, payload.productCode, payload.notificationType)
                .pipe(operators.switchMap(function (res) { return [
                new LoadProductInterests({
                    userId: payload.userId,
                    productCode: payload.productCode,
                    notificationType: payload.notificationType,
                }),
                new AddProductInterestSuccess(res),
            ]; }), operators.catchError(function (error) { return rxjs.of(new AddProductInterestFail(normalizeHttpError(error))); })); }));
        }
        return ProductInterestsEffect;
    }());
    ProductInterestsEffect.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductInterestsEffect, deps: [{ token: i1__namespace$4.Actions }, { token: UserInterestsConnector }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ProductInterestsEffect.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductInterestsEffect });
    __decorate([
        i1$4.Effect()
    ], ProductInterestsEffect.prototype, "loadProductInteres$", void 0);
    __decorate([
        i1$4.Effect()
    ], ProductInterestsEffect.prototype, "removeProductInterest$", void 0);
    __decorate([
        i1$4.Effect()
    ], ProductInterestsEffect.prototype, "addProductInterest$", void 0);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ProductInterestsEffect, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: i1__namespace$4.Actions }, { type: UserInterestsConnector }]; }, propDecorators: { loadProductInteres$: [], removeProductInterest$: [], addProductInterest$: [] } });

    var RegionsEffects = /** @class */ (function () {
        function RegionsEffects(actions$, siteConnector) {
            var _this = this;
            this.actions$ = actions$;
            this.siteConnector = siteConnector;
            this.loadRegions$ = this.actions$.pipe(i1$4.ofType(LOAD_REGIONS), operators.map(function (action) {
                return action.payload;
            }), operators.switchMap(function (countryCode) {
                return _this.siteConnector.getRegions(countryCode).pipe(operators.map(function (regions) { return new LoadRegionsSuccess({
                    entities: regions,
                    country: countryCode,
                }); }), operators.catchError(function (error) { return rxjs.of(new LoadRegionsFail(normalizeHttpError(error))); }));
            }));
            this.resetRegions$ = this.actions$.pipe(i1$4.ofType(CLEAR_USER_MISCS_DATA, CLEAR_REGIONS), operators.map(function () {
                return new LoaderResetAction(REGIONS);
            }));
        }
        return RegionsEffects;
    }());
    RegionsEffects.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: RegionsEffects, deps: [{ token: i1__namespace$4.Actions }, { token: SiteConnector }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    RegionsEffects.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: RegionsEffects });
    __decorate([
        i1$4.Effect()
    ], RegionsEffects.prototype, "loadRegions$", void 0);
    __decorate([
        i1$4.Effect()
    ], RegionsEffects.prototype, "resetRegions$", void 0);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: RegionsEffects, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: i1__namespace$4.Actions }, { type: SiteConnector }]; }, propDecorators: { loadRegions$: [], resetRegions$: [] } });

    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var ReplenishmentOrderDetailsEffect = /** @class */ (function () {
        function ReplenishmentOrderDetailsEffect(actions$, replenishmentOrderConnector, globalMessageService) {
            var _this = this;
            this.actions$ = actions$;
            this.replenishmentOrderConnector = replenishmentOrderConnector;
            this.globalMessageService = globalMessageService;
            this.loadReplenishmentOrderDetails$ = this.actions$.pipe(i1$4.ofType(LOAD_REPLENISHMENT_ORDER_DETAILS), operators.map(function (action) { return action.payload; }), operators.switchMap(function (payload) {
                return _this.replenishmentOrderConnector
                    .load(payload.userId, payload.replenishmentOrderCode)
                    .pipe(operators.map(function (replenishmentOrder) {
                    return new LoadReplenishmentOrderDetailsSuccess(replenishmentOrder);
                }), operators.catchError(function (error) { return rxjs.of(new LoadReplenishmentOrderDetailsFail(normalizeHttpError(error))); }));
            }));
            this.cancelReplenishmentOrder$ = this.actions$.pipe(i1$4.ofType(CANCEL_REPLENISHMENT_ORDER), operators.map(function (action) { return action.payload; }), operators.switchMap(function (payload) {
                return _this.replenishmentOrderConnector
                    .cancelReplenishmentOrder(payload.userId, payload.replenishmentOrderCode)
                    .pipe(operators.map(function (replenishmentOrder) { return new CancelReplenishmentOrderSuccess(replenishmentOrder); }), operators.catchError(function (error) {
                    var _a;
                    (_a = error === null || error === void 0 ? void 0 : error.error) === null || _a === void 0 ? void 0 : _a.errors.forEach(function (err) { return _this.globalMessageService.add(err.message, exports.GlobalMessageType.MSG_TYPE_ERROR); });
                    return rxjs.of(new CancelReplenishmentOrderFail(normalizeHttpError(error)));
                }));
            }));
        }
        return ReplenishmentOrderDetailsEffect;
    }());
    ReplenishmentOrderDetailsEffect.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ReplenishmentOrderDetailsEffect, deps: [{ token: i1__namespace$4.Actions }, { token: UserReplenishmentOrderConnector }, { token: GlobalMessageService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ReplenishmentOrderDetailsEffect.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ReplenishmentOrderDetailsEffect });
    __decorate([
        i1$4.Effect()
    ], ReplenishmentOrderDetailsEffect.prototype, "loadReplenishmentOrderDetails$", void 0);
    __decorate([
        i1$4.Effect()
    ], ReplenishmentOrderDetailsEffect.prototype, "cancelReplenishmentOrder$", void 0);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ReplenishmentOrderDetailsEffect, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: i1__namespace$4.Actions }, { type: UserReplenishmentOrderConnector }, { type: GlobalMessageService }]; }, propDecorators: { loadReplenishmentOrderDetails$: [], cancelReplenishmentOrder$: [] } });

    var UserAddressesEffects = /** @class */ (function () {
        function UserAddressesEffects(actions$, userAddressConnector, userAddressService, messageService) {
            var _this = this;
            this.actions$ = actions$;
            this.userAddressConnector = userAddressConnector;
            this.userAddressService = userAddressService;
            this.messageService = messageService;
            this.loadUserAddresses$ = this.actions$.pipe(i1$4.ofType(LOAD_USER_ADDRESSES), operators.map(function (action) { return action.payload; }), operators.mergeMap(function (payload) {
                return _this.userAddressConnector.getAll(payload).pipe(operators.map(function (addresses) {
                    return new LoadUserAddressesSuccess(addresses);
                }), operators.catchError(function (error) { return rxjs.of(new LoadUserAddressesFail(normalizeHttpError(error))); }));
            }));
            this.addUserAddress$ = this.actions$.pipe(i1$4.ofType(ADD_USER_ADDRESS), operators.map(function (action) { return action.payload; }), operators.mergeMap(function (payload) {
                return _this.userAddressConnector
                    .add(payload.userId, payload.address)
                    .pipe(operators.map(function (data) {
                    return new AddUserAddressSuccess(data);
                }), operators.catchError(function (error) { return rxjs.of(new AddUserAddressFail(normalizeHttpError(error))); }));
            }));
            this.updateUserAddress$ = this.actions$.pipe(i1$4.ofType(UPDATE_USER_ADDRESS), operators.map(function (action) { return action.payload; }), operators.mergeMap(function (payload) {
                return _this.userAddressConnector
                    .update(payload.userId, payload.addressId, payload.address)
                    .pipe(operators.map(function (data) {
                    // don't show the message if just setting address as default
                    if (payload.address &&
                        Object.keys(payload.address).length === 1 &&
                        payload.address.defaultAddress) {
                        return new LoadUserAddresses(payload.userId);
                    }
                    else {
                        return new UpdateUserAddressSuccess(data);
                    }
                }), operators.catchError(function (error) { return rxjs.of(new UpdateUserAddressFail(normalizeHttpError(error))); }));
            }));
            this.deleteUserAddress$ = this.actions$.pipe(i1$4.ofType(DELETE_USER_ADDRESS), operators.map(function (action) { return action.payload; }), operators.mergeMap(function (payload) {
                return _this.userAddressConnector
                    .delete(payload.userId, payload.addressId)
                    .pipe(operators.map(function (data) {
                    return new DeleteUserAddressSuccess(data);
                }), operators.catchError(function (error) { return rxjs.of(new DeleteUserAddressFail(normalizeHttpError(error))); }));
            }));
            /**
             *  Reload addresses and notify about add success
             */
            this.showGlobalMessageOnAddSuccess$ = this.actions$.pipe(i1$4.ofType(ADD_USER_ADDRESS_SUCCESS), operators.tap(function () {
                _this.loadAddresses();
                _this.showGlobalMessage('addressForm.userAddressAddSuccess');
            }));
            /**
             *  Reload addresses and notify about update success
             */
            this.showGlobalMessageOnUpdateSuccess$ = this.actions$.pipe(i1$4.ofType(UPDATE_USER_ADDRESS_SUCCESS), operators.tap(function () {
                _this.loadAddresses();
                _this.showGlobalMessage('addressForm.userAddressUpdateSuccess');
            }));
            /**
             *  Reload addresses and notify about delete success
             */
            this.showGlobalMessageOnDeleteSuccess$ = this.actions$.pipe(i1$4.ofType(DELETE_USER_ADDRESS_SUCCESS), operators.tap(function () {
                _this.loadAddresses();
                _this.showGlobalMessage('addressForm.userAddressDeleteSuccess');
            }));
        }
        /**
         * Show global confirmation message with provided text
         */
        UserAddressesEffects.prototype.showGlobalMessage = function (text) {
            this.messageService.add({ key: text }, exports.GlobalMessageType.MSG_TYPE_CONFIRMATION);
        };
        UserAddressesEffects.prototype.loadAddresses = function () {
            this.userAddressService.loadAddresses();
        };
        return UserAddressesEffects;
    }());
    UserAddressesEffects.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserAddressesEffects, deps: [{ token: i1__namespace$4.Actions }, { token: UserAddressConnector }, { token: UserAddressService }, { token: GlobalMessageService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    UserAddressesEffects.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserAddressesEffects });
    __decorate([
        i1$4.Effect()
    ], UserAddressesEffects.prototype, "loadUserAddresses$", void 0);
    __decorate([
        i1$4.Effect()
    ], UserAddressesEffects.prototype, "addUserAddress$", void 0);
    __decorate([
        i1$4.Effect()
    ], UserAddressesEffects.prototype, "updateUserAddress$", void 0);
    __decorate([
        i1$4.Effect()
    ], UserAddressesEffects.prototype, "deleteUserAddress$", void 0);
    __decorate([
        i1$4.Effect({ dispatch: false })
    ], UserAddressesEffects.prototype, "showGlobalMessageOnAddSuccess$", void 0);
    __decorate([
        i1$4.Effect({ dispatch: false })
    ], UserAddressesEffects.prototype, "showGlobalMessageOnUpdateSuccess$", void 0);
    __decorate([
        i1$4.Effect({ dispatch: false })
    ], UserAddressesEffects.prototype, "showGlobalMessageOnDeleteSuccess$", void 0);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserAddressesEffects, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: i1__namespace$4.Actions }, { type: UserAddressConnector }, { type: UserAddressService }, { type: GlobalMessageService }]; }, propDecorators: { loadUserAddresses$: [], addUserAddress$: [], updateUserAddress$: [], deleteUserAddress$: [], showGlobalMessageOnAddSuccess$: [], showGlobalMessageOnUpdateSuccess$: [], showGlobalMessageOnDeleteSuccess$: [] } });

    var UserConsentsEffect = /** @class */ (function () {
        function UserConsentsEffect(actions$, userConsentConnector) {
            var _this = this;
            this.actions$ = actions$;
            this.userConsentConnector = userConsentConnector;
            this.resetConsents$ = this.actions$.pipe(i1$4.ofType(LANGUAGE_CHANGE), operators.map(function () { return new ResetLoadUserConsents(); }));
            this.getConsents$ = this.actions$.pipe(i1$4.ofType(LOAD_USER_CONSENTS), operators.map(function (action) { return action.payload; }), operators.concatMap(function (userId) { return _this.userConsentConnector.loadConsents(userId).pipe(operators.map(function (consents) { return new LoadUserConsentsSuccess(consents); }), operators.catchError(function (error) { return rxjs.of(new LoadUserConsentsFail(normalizeHttpError(error))); })); }));
            this.giveConsent$ = this.actions$.pipe(i1$4.ofType(GIVE_USER_CONSENT, TRANSFER_ANONYMOUS_CONSENT), operators.concatMap(function (action) { return _this.userConsentConnector
                .giveConsent(action.payload.userId, action.payload.consentTemplateId, action.payload.consentTemplateVersion)
                .pipe(operators.map(function (consent) { return new GiveUserConsentSuccess(consent); }), operators.catchError(function (error) {
                var errors = [
                    new GiveUserConsentFail(normalizeHttpError(error)),
                ];
                if (action.type === TRANSFER_ANONYMOUS_CONSENT &&
                    error.status === 409) {
                    errors.push(new RemoveMessagesByType(exports.GlobalMessageType.MSG_TYPE_ERROR));
                }
                return rxjs.of.apply(void 0, __spreadArray([], __read(errors)));
            })); }));
            this.withdrawConsent$ = this.actions$.pipe(i1$4.ofType(WITHDRAW_USER_CONSENT), operators.map(function (action) { return action.payload; }), operators.concatMap(function (_a) {
                var userId = _a.userId, consentCode = _a.consentCode;
                return _this.userConsentConnector.withdrawConsent(userId, consentCode).pipe(operators.map(function () { return new WithdrawUserConsentSuccess(); }), operators.catchError(function (error) { return rxjs.of(new WithdrawUserConsentFail(normalizeHttpError(error))); }));
            }));
        }
        return UserConsentsEffect;
    }());
    UserConsentsEffect.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserConsentsEffect, deps: [{ token: i1__namespace$4.Actions }, { token: UserConsentConnector }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    UserConsentsEffect.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserConsentsEffect });
    __decorate([
        i1$4.Effect()
    ], UserConsentsEffect.prototype, "resetConsents$", void 0);
    __decorate([
        i1$4.Effect()
    ], UserConsentsEffect.prototype, "getConsents$", void 0);
    __decorate([
        i1$4.Effect()
    ], UserConsentsEffect.prototype, "giveConsent$", void 0);
    __decorate([
        i1$4.Effect()
    ], UserConsentsEffect.prototype, "withdrawConsent$", void 0);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserConsentsEffect, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: i1__namespace$4.Actions }, { type: UserConsentConnector }]; }, propDecorators: { resetConsents$: [], getConsents$: [], giveConsent$: [], withdrawConsent$: [] } });

    var UserCostCenterEffects = /** @class */ (function () {
        function UserCostCenterEffects(actions$, userCostCenterConnector) {
            var _this = this;
            this.actions$ = actions$;
            this.userCostCenterConnector = userCostCenterConnector;
            this.loadActiveCostCenters$ = this.actions$.pipe(i1$4.ofType(LOAD_ACTIVE_COST_CENTERS), operators.map(function (action) { return action.payload; }), operators.switchMap(function (payload) { return _this.userCostCenterConnector.getActiveList(payload).pipe(
            // TODO(#8875): Should we use here serialize utils?
            operators.map(function (data) { return new LoadActiveCostCentersSuccess(data.values); }), operators.catchError(function (error) { return rxjs.of(new LoadActiveCostCentersFail(normalizeHttpError(error))); })); }));
        }
        return UserCostCenterEffects;
    }());
    UserCostCenterEffects.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserCostCenterEffects, deps: [{ token: i1__namespace$4.Actions }, { token: UserCostCenterConnector }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    UserCostCenterEffects.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserCostCenterEffects });
    __decorate([
        i1$4.Effect()
    ], UserCostCenterEffects.prototype, "loadActiveCostCenters$", void 0);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserCostCenterEffects, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: i1__namespace$4.Actions }, { type: UserCostCenterConnector }]; }, propDecorators: { loadActiveCostCenters$: [] } });

    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var UserOrdersEffect = /** @class */ (function () {
        function UserOrdersEffect(actions$, orderConnector, replenishmentOrderConnector) {
            var _this = this;
            this.actions$ = actions$;
            this.orderConnector = orderConnector;
            this.replenishmentOrderConnector = replenishmentOrderConnector;
            this.loadUserOrders$ = this.actions$.pipe(i1$4.ofType(LOAD_USER_ORDERS), operators.map(function (action) { return action.payload; }), operators.switchMap(function (payload) {
                return (Boolean(payload.replenishmentOrderCode)
                    ? _this.replenishmentOrderConnector.loadReplenishmentDetailsHistory(payload.userId, payload.replenishmentOrderCode, payload.pageSize, payload.currentPage, payload.sort)
                    : _this.orderConnector.getHistory(payload.userId, payload.pageSize, payload.currentPage, payload.sort)).pipe(operators.map(function (orders) {
                    return new LoadUserOrdersSuccess(orders);
                }), operators.catchError(function (error) { return rxjs.of(new LoadUserOrdersFail(normalizeHttpError(error))); }));
            }));
            this.resetUserOrders$ = this.actions$.pipe(i1$4.ofType(LANGUAGE_CHANGE), operators.map(function () {
                return new ClearUserOrders();
            }));
        }
        return UserOrdersEffect;
    }());
    UserOrdersEffect.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserOrdersEffect, deps: [{ token: i1__namespace$4.Actions }, { token: UserOrderConnector }, { token: UserReplenishmentOrderConnector }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    UserOrdersEffect.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserOrdersEffect });
    __decorate([
        i1$4.Effect()
    ], UserOrdersEffect.prototype, "loadUserOrders$", void 0);
    __decorate([
        i1$4.Effect()
    ], UserOrdersEffect.prototype, "resetUserOrders$", void 0);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserOrdersEffect, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: i1__namespace$4.Actions }, { type: UserOrderConnector }, { type: UserReplenishmentOrderConnector }]; }, propDecorators: { loadUserOrders$: [], resetUserOrders$: [] } });

    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var UserReplenishmentOrdersEffect = /** @class */ (function () {
        function UserReplenishmentOrdersEffect(actions$, replenishmentOrderConnector) {
            var _this = this;
            this.actions$ = actions$;
            this.replenishmentOrderConnector = replenishmentOrderConnector;
            this.loadUserReplenishmentOrders$ = this.actions$.pipe(i1$4.ofType(LOAD_USER_REPLENISHMENT_ORDERS), operators.map(function (action) { return action.payload; }), operators.switchMap(function (payload) {
                return _this.replenishmentOrderConnector
                    .loadHistory(payload.userId, payload.pageSize, payload.currentPage, payload.sort)
                    .pipe(operators.map(function (orders) {
                    return new LoadUserReplenishmentOrdersSuccess(orders);
                }), operators.catchError(function (error) { return rxjs.of(new LoadUserReplenishmentOrdersFail(normalizeHttpError(error))); }));
            }));
        }
        return UserReplenishmentOrdersEffect;
    }());
    UserReplenishmentOrdersEffect.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserReplenishmentOrdersEffect, deps: [{ token: i1__namespace$4.Actions }, { token: UserReplenishmentOrderConnector }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    UserReplenishmentOrdersEffect.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserReplenishmentOrdersEffect });
    __decorate([
        i1$4.Effect()
    ], UserReplenishmentOrdersEffect.prototype, "loadUserReplenishmentOrders$", void 0);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserReplenishmentOrdersEffect, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: i1__namespace$4.Actions }, { type: UserReplenishmentOrderConnector }]; }, propDecorators: { loadUserReplenishmentOrders$: [] } });

    /**
     * @deprecated since 4.2 - use effectsTransitional_4_2 with order lib instead
     */
    var effectsTransitional = [
        ClearMiscsDataEffect,
        DeliveryCountriesEffects,
        RegionsEffects,
        UserAddressesEffects,
        UserPaymentMethodsEffects,
        UserOrdersEffect,
        OrderDetailsEffect,
        BillingCountriesEffect,
        UserConsentsEffect,
        ConsignmentTrackingEffects,
        CustomerCouponEffects,
        NotificationPreferenceEffects,
        ProductInterestsEffect,
        OrderReturnRequestEffect,
        UserCostCenterEffects,
        ReplenishmentOrderDetailsEffect,
        UserReplenishmentOrdersEffect,
    ];

    var initialState$f = {
        entities: {},
    };
    function reducer$f(state, action) {
        if (state === void 0) { state = initialState$f; }
        switch (action.type) {
            case LOAD_BILLING_COUNTRIES_SUCCESS: {
                var billingCountries = action.payload;
                var entities = billingCountries.reduce(function (countryEntities, name) {
                    var _a;
                    return Object.assign(Object.assign({}, countryEntities), (_a = {}, _a[name.isocode] = name, _a));
                }, Object.assign({}, state.entities));
                return Object.assign(Object.assign({}, state), { entities: entities });
            }
            case CLEAR_USER_MISCS_DATA: {
                return initialState$f;
            }
        }
        return state;
    }

    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var initialState$e = {};
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    function reducer$e(state, action) {
        if (state === void 0) { state = initialState$e; }
        switch (action.type) {
            case LOAD_CONSIGNMENT_TRACKING_SUCCESS: {
                var tracking = action.payload;
                return {
                    tracking: tracking,
                };
            }
            case CLEAR_CONSIGNMENT_TRACKING: {
                return initialState$e;
            }
        }
        return state;
    }

    var initialState$d = {
        coupons: [],
        sorts: [],
        pagination: {},
    };
    function reducer$d(state, action) {
        if (state === void 0) { state = initialState$d; }
        switch (action.type) {
            case LOAD_CUSTOMER_COUPONS_SUCCESS: {
                return action.payload;
            }
            case SUBSCRIBE_CUSTOMER_COUPON_SUCCESS: {
                var updatedCustomerCoupon_1 = action.payload.coupon;
                var customerCoupons_1 = new Array(state.coupons.length);
                state.coupons.forEach(function (customerCoupon, index) { return customerCoupon.couponId === updatedCustomerCoupon_1.couponId
                    ? (customerCoupons_1[index] = updatedCustomerCoupon_1)
                    : (customerCoupons_1[index] = customerCoupon); });
                return Object.assign(Object.assign({}, state), { coupons: customerCoupons_1 });
            }
            case UNSUBSCRIBE_CUSTOMER_COUPON_SUCCESS: {
                var updatedCouponCode_1 = action.payload;
                var customerCoupons_2 = new Array(state.coupons.length);
                state.coupons.forEach(function (customerCoupon, index) { return customerCoupon.couponId === updatedCouponCode_1
                    ? (customerCoupons_2[index] = Object.assign(Object.assign({}, customerCoupon), { notificationOn: false }))
                    : (customerCoupons_2[index] = customerCoupon); });
                return Object.assign(Object.assign({}, state), { coupons: customerCoupons_2 });
            }
        }
        return state;
    }

    var initialState$c = {
        entities: {},
    };
    function reducer$c(state, action) {
        if (state === void 0) { state = initialState$c; }
        switch (action.type) {
            case LOAD_DELIVERY_COUNTRIES_SUCCESS: {
                var deliveryCountries = action.payload;
                var entities = deliveryCountries.reduce(function (countryEntities, country) {
                    var _a;
                    return Object.assign(Object.assign({}, countryEntities), (_a = {}, _a[country.isocode] = country, _a));
                }, Object.assign({}, state.entities));
                return Object.assign(Object.assign({}, state), { entities: entities });
            }
            case CLEAR_USER_MISCS_DATA: {
                return initialState$c;
            }
        }
        return state;
    }

    var initialState$b = [];
    function reducer$b(state, action) {
        if (state === void 0) { state = initialState$b; }
        switch (action.type) {
            case LOAD_NOTIFICATION_PREFERENCES_FAIL: {
                return initialState$b;
            }
            case LOAD_NOTIFICATION_PREFERENCES_SUCCESS:
            case UPDATE_NOTIFICATION_PREFERENCES_SUCCESS: {
                return action.payload ? action.payload : initialState$b;
            }
        }
        return state;
    }

    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var initialState$a = {};
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    function reducer$a(state, action) {
        if (state === void 0) { state = initialState$a; }
        switch (action.type) {
            case LOAD_ORDER_DETAILS_SUCCESS: {
                var order = action.payload;
                return order;
            }
        }
        return state;
    }

    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var initialState$9 = {
        returnRequests: [],
        pagination: {},
        sorts: [],
    };
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    function reducer$9(state, action) {
        if (state === void 0) { state = initialState$9; }
        switch (action.type) {
            case LOAD_ORDER_RETURN_REQUEST_LIST_SUCCESS: {
                return action.payload ? action.payload : initialState$9;
            }
        }
        return state;
    }

    var initialState$8 = [];
    function reducer$8(state, action) {
        if (state === void 0) { state = initialState$8; }
        switch (action.type) {
            case LOAD_USER_PAYMENT_METHODS_SUCCESS: {
                return action.payload ? action.payload : initialState$8;
            }
            case LOAD_USER_PAYMENT_METHODS_FAIL: {
                return initialState$8;
            }
        }
        return state;
    }

    var initialState$7 = {
        results: [],
        pagination: {},
        sorts: [],
    };
    function reducer$7(state, action) {
        if (state === void 0) { state = initialState$7; }
        switch (action.type) {
            case LOAD_PRODUCT_INTERESTS_SUCCESS: {
                return action.payload ? action.payload : initialState$7;
            }
            case LOAD_PRODUCT_INTERESTS_FAIL: {
                return initialState$7;
            }
        }
        return state;
    }

    var initialState$6 = {
        entities: [],
        country: null,
    };
    function reducer$6(state, action) {
        if (state === void 0) { state = initialState$6; }
        switch (action.type) {
            case LOAD_REGIONS_SUCCESS: {
                var entities = action.payload.entities;
                var country = action.payload.country;
                if (entities || country) {
                    return Object.assign(Object.assign({}, state), { entities: entities,
                        country: country });
                }
                return initialState$6;
            }
        }
        return state;
    }

    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var initialState$5 = {};
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    function reducer$5(state, action) {
        if (state === void 0) { state = initialState$5; }
        switch (action.type) {
            case LOAD_REPLENISHMENT_ORDER_DETAILS_SUCCESS:
            case CANCEL_REPLENISHMENT_ORDER_SUCCESS: {
                return action.payload ? action.payload : initialState$5;
            }
            default: {
                return state;
            }
        }
    }

    var initialState$4 = [];
    function reducer$4(state, action) {
        if (state === void 0) { state = initialState$4; }
        switch (action.type) {
            case LOAD_USER_ADDRESSES_FAIL: {
                return initialState$4;
            }
            case LOAD_USER_ADDRESSES_SUCCESS: {
                return action.payload ? action.payload : initialState$4;
            }
        }
        return state;
    }

    var initialState$3 = [];
    function reducer$3(state, action) {
        if (state === void 0) { state = initialState$3; }
        switch (action.type) {
            case LOAD_USER_CONSENTS_SUCCESS: {
                var consents = action.payload;
                return consents ? consents : initialState$3;
            }
            case GIVE_USER_CONSENT_SUCCESS: {
                var updatedConsentTemplate_1 = action.consentTemplate;
                return state.map(function (consentTemplate) { return consentTemplate.id === updatedConsentTemplate_1.id
                    ? updatedConsentTemplate_1
                    : consentTemplate; });
            }
        }
        return state;
    }

    var initialState$2 = [];
    function reducer$2(state, action) {
        if (state === void 0) { state = initialState$2; }
        switch (action.type) {
            case LOAD_ACTIVE_COST_CENTERS_FAIL: {
                return initialState$2;
            }
            case LOAD_ACTIVE_COST_CENTERS_SUCCESS: {
                return action.payload ? action.payload : initialState$2;
            }
        }
        return state;
    }

    /**
     * @deprecated since 4.2 - use order lib instead
     */
    var initialState$1 = {
        orders: [],
        pagination: {},
        sorts: [],
    };
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    function reducer$1(state, action) {
        if (state === void 0) { state = initialState$1; }
        switch (action.type) {
            case LOAD_USER_ORDERS_SUCCESS: {
                return action.payload ? action.payload : initialState$1;
            }
            case LOAD_USER_ORDERS_FAIL: {
                return initialState$1;
            }
        }
        return state;
    }

    var initialState = {
        replenishmentOrders: [],
        pagination: {},
        sorts: [],
    };
    /**
     * @deprecated since 4.2 - use order lib instead
     */
    function reducer(state, action) {
        if (state === void 0) { state = initialState; }
        switch (action.type) {
            case LOAD_USER_REPLENISHMENT_ORDERS_SUCCESS: {
                return action.payload ? action.payload : initialState;
            }
            case CANCEL_REPLENISHMENT_ORDER_SUCCESS: {
                var cancelledReplenishmentOrder_1 = action.payload;
                var userReplenishmentOrders = __spreadArray([], __read(state.replenishmentOrders));
                var index = userReplenishmentOrders.findIndex(function (replenishmentOrder) { return replenishmentOrder.replenishmentOrderCode ===
                    cancelledReplenishmentOrder_1.replenishmentOrderCode; });
                if (index === -1) {
                    return initialState;
                }
                else {
                    userReplenishmentOrders[index] = Object.assign({}, cancelledReplenishmentOrder_1);
                }
                return Object.assign(Object.assign({}, state), { replenishmentOrders: userReplenishmentOrders });
            }
        }
        return state;
    }

    function getReducers() {
        return {
            addresses: loaderReducer(USER_ADDRESSES, reducer$4),
            billingCountries: reducer$f,
            consents: loaderReducer(USER_CONSENTS, reducer$3),
            payments: loaderReducer(USER_PAYMENT_METHODS, reducer$8),
            orders: loaderReducer(USER_ORDERS, reducer$1),
            order: loaderReducer(USER_ORDER_DETAILS, reducer$a),
            replenishmentOrders: loaderReducer(USER_REPLENISHMENT_ORDERS, reducer),
            orderReturn: loaderReducer(USER_RETURN_REQUEST_DETAILS),
            orderReturnList: loaderReducer(USER_RETURN_REQUESTS, reducer$9),
            countries: reducer$c,
            regions: loaderReducer(REGIONS, reducer$6),
            consignmentTracking: reducer$e,
            customerCoupons: loaderReducer(CUSTOMER_COUPONS, reducer$d),
            notificationPreferences: loaderReducer(NOTIFICATION_PREFERENCES, reducer$b),
            productInterests: loaderReducer(PRODUCT_INTERESTS, reducer$7),
            costCenters: loaderReducer(USER_COST_CENTERS, reducer$2),
            replenishmentOrder: loaderReducer(USER_REPLENISHMENT_ORDER_DETAILS, reducer$5),
        };
    }
    var reducerToken = new i0.InjectionToken('UserReducers');
    var reducerProvider = {
        provide: reducerToken,
        useFactory: getReducers,
    };
    function clearUserState(reducer) {
        return function (state, action) {
            if (action.type === LOGOUT) {
                state = undefined;
            }
            return reducer(state, action);
        };
    }
    var metaReducers = [clearUserState];

    /**
     * @deprecated since 4.2 - use getReducersTransitional_4_2 with order lib instead
     */
    function getReducersTransitional() {
        return {
            addresses: loaderReducer(USER_ADDRESSES, reducer$4),
            billingCountries: reducer$f,
            consents: loaderReducer(USER_CONSENTS, reducer$3),
            payments: loaderReducer(USER_PAYMENT_METHODS, reducer$8),
            orders: loaderReducer(USER_ORDERS, reducer$1),
            order: loaderReducer(USER_ORDER_DETAILS, reducer$a),
            replenishmentOrders: loaderReducer(USER_REPLENISHMENT_ORDERS, reducer),
            orderReturn: loaderReducer(USER_RETURN_REQUEST_DETAILS),
            orderReturnList: loaderReducer(USER_RETURN_REQUESTS, reducer$9),
            countries: reducer$c,
            regions: loaderReducer(REGIONS, reducer$6),
            consignmentTracking: reducer$e,
            customerCoupons: loaderReducer(CUSTOMER_COUPONS, reducer$d),
            notificationPreferences: loaderReducer(NOTIFICATION_PREFERENCES, reducer$b),
            productInterests: loaderReducer(PRODUCT_INTERESTS, reducer$7),
            costCenters: loaderReducer(USER_COST_CENTERS, reducer$2),
            replenishmentOrder: loaderReducer(USER_REPLENISHMENT_ORDER_DETAILS, reducer$5),
        };
    }
    /**
     * @deprecated since 4.2 - use reducerTransitional_4_2_Provider with order lib instead
     */
    var reducerTransitionalProvider = {
        provide: reducerToken,
        useFactory: getReducersTransitional,
    };

    /**
     * @deprecated since 4.2 - use UserStoreTransitional_4_2_Module with order lib instead
     */
    var UserStoreTransitionalModule = /** @class */ (function () {
        function UserStoreTransitionalModule() {
        }
        return UserStoreTransitionalModule;
    }());
    UserStoreTransitionalModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserStoreTransitionalModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    UserStoreTransitionalModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserStoreTransitionalModule, imports: [i6.CommonModule,
            StateModule, i1__namespace$2.StoreFeatureModule, i1__namespace$4.EffectsFeatureModule, i1$2.RouterModule] });
    UserStoreTransitionalModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserStoreTransitionalModule, providers: [reducerTransitionalProvider], imports: [[
                i6.CommonModule,
                StateModule,
                i1.StoreModule.forFeature(USER_FEATURE, reducerToken, { metaReducers: metaReducers }),
                i1$4.EffectsModule.forFeature(effectsTransitional),
                i1$2.RouterModule,
            ]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserStoreTransitionalModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [
                            i6.CommonModule,
                            StateModule,
                            i1.StoreModule.forFeature(USER_FEATURE, reducerToken, { metaReducers: metaReducers }),
                            i1$4.EffectsModule.forFeature(effectsTransitional),
                            i1$2.RouterModule,
                        ],
                        providers: [reducerTransitionalProvider],
                    }]
            }] });

    /**
     * @deprecated since 4.2 - use UserTransitional_4_2_Module with order lib instead
     */
    var UserTransitionalModule = /** @class */ (function () {
        function UserTransitionalModule() {
        }
        UserTransitionalModule.forRoot = function () {
            return {
                ngModule: UserTransitionalModule,
            };
        };
        return UserTransitionalModule;
    }());
    UserTransitionalModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserTransitionalModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    UserTransitionalModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserTransitionalModule, imports: [UserStoreTransitionalModule, UserEventModule] });
    UserTransitionalModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserTransitionalModule, providers: [UserEventBuilder], imports: [[UserStoreTransitionalModule, UserEventModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserTransitionalModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [UserStoreTransitionalModule, UserEventModule],
                        providers: [UserEventBuilder],
                    }]
            }] });

    var effectsTransitional_4_2 = [
        ClearMiscsDataEffect,
        DeliveryCountriesEffects,
        RegionsEffects,
        UserAddressesEffects,
        UserPaymentMethodsEffects,
        BillingCountriesEffect,
        UserConsentsEffect,
        CustomerCouponEffects,
        NotificationPreferenceEffects,
        ProductInterestsEffect,
        UserCostCenterEffects,
    ];

    function getReducersTransitional_4_2() {
        return {
            addresses: loaderReducer(USER_ADDRESSES, reducer$4),
            billingCountries: reducer$f,
            consents: loaderReducer(USER_CONSENTS, reducer$3),
            payments: loaderReducer(USER_PAYMENT_METHODS, reducer$8),
            countries: reducer$c,
            regions: loaderReducer(REGIONS, reducer$6),
            customerCoupons: loaderReducer(CUSTOMER_COUPONS, reducer$d),
            notificationPreferences: loaderReducer(NOTIFICATION_PREFERENCES, reducer$b),
            productInterests: loaderReducer(PRODUCT_INTERESTS, reducer$7),
            costCenters: loaderReducer(USER_COST_CENTERS, reducer$2),
        };
    }
    var reducerTransitional_4_2_Provider = {
        provide: reducerToken,
        useFactory: getReducersTransitional_4_2,
    };

    var UserStoreTransitional_4_2_Module = /** @class */ (function () {
        function UserStoreTransitional_4_2_Module() {
        }
        return UserStoreTransitional_4_2_Module;
    }());
    UserStoreTransitional_4_2_Module.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserStoreTransitional_4_2_Module, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    UserStoreTransitional_4_2_Module.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserStoreTransitional_4_2_Module, imports: [i6.CommonModule,
            StateModule, i1__namespace$2.StoreFeatureModule, i1__namespace$4.EffectsFeatureModule, i1$2.RouterModule] });
    UserStoreTransitional_4_2_Module.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserStoreTransitional_4_2_Module, providers: [reducerTransitional_4_2_Provider], imports: [[
                i6.CommonModule,
                StateModule,
                i1.StoreModule.forFeature(USER_FEATURE, reducerToken, { metaReducers: metaReducers }),
                i1$4.EffectsModule.forFeature(effectsTransitional_4_2),
                i1$2.RouterModule,
            ]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserStoreTransitional_4_2_Module, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [
                            i6.CommonModule,
                            StateModule,
                            i1.StoreModule.forFeature(USER_FEATURE, reducerToken, { metaReducers: metaReducers }),
                            i1$4.EffectsModule.forFeature(effectsTransitional_4_2),
                            i1$2.RouterModule,
                        ],
                        providers: [reducerTransitional_4_2_Provider],
                    }]
            }] });

    var UserTransitional_4_2_Module = /** @class */ (function () {
        function UserTransitional_4_2_Module() {
        }
        UserTransitional_4_2_Module.forRoot = function () {
            return {
                ngModule: UserTransitional_4_2_Module,
            };
        };
        return UserTransitional_4_2_Module;
    }());
    UserTransitional_4_2_Module.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserTransitional_4_2_Module, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    UserTransitional_4_2_Module.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserTransitional_4_2_Module, imports: [UserStoreTransitional_4_2_Module, UserEventModule] });
    UserTransitional_4_2_Module.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserTransitional_4_2_Module, providers: [UserEventBuilder], imports: [[UserStoreTransitional_4_2_Module, UserEventModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: UserTransitional_4_2_Module, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [UserStoreTransitional_4_2_Module, UserEventModule],
                        providers: [UserEventBuilder],
                    }]
            }] });

    var QueryService = /** @class */ (function () {
        function QueryService(eventService) {
            this.eventService = eventService;
            this.subscriptions = new rxjs.Subscription();
        }
        QueryService.prototype.create = function (loaderFactory, options) {
            var _a, _b, _c, _d, _e, _f;
            var initialState = {
                data: undefined,
                error: false,
                loading: true,
            };
            var state$ = new rxjs.BehaviorSubject(initialState);
            // if the query will be unsubscribed from while the data is being loaded, we will end up with the loading flag set to true
            // we want to retry this load on next subscription
            var onSubscribeLoad$ = rxjs.iif(function () { return state$.value.loading; }, rxjs.of(undefined));
            var loadTrigger$ = this.getTriggersStream(__spreadArray(__spreadArray([
                onSubscribeLoad$
            ], __read(((_a = options === null || options === void 0 ? void 0 : options.reloadOn) !== null && _a !== void 0 ? _a : []))), __read(((_b = options === null || options === void 0 ? void 0 : options.resetOn) !== null && _b !== void 0 ? _b : []))));
            var resetTrigger$ = this.getTriggersStream((_c = options === null || options === void 0 ? void 0 : options.resetOn) !== null && _c !== void 0 ? _c : []);
            var reloadTrigger$ = this.getTriggersStream((_d = options === null || options === void 0 ? void 0 : options.reloadOn) !== null && _d !== void 0 ? _d : []);
            var load$ = loadTrigger$.pipe(operators.tap(function () {
                if (!state$.value.loading) {
                    state$.next(Object.assign(Object.assign({}, state$.value), { loading: true }));
                }
            }), operators.switchMapTo(loaderFactory().pipe(operators.takeUntil(resetTrigger$))), operators.tap(function (data) {
                state$.next({ loading: false, error: false, data: data });
            }), operators.catchError(function (error, retryStream$) {
                state$.next({ loading: false, error: error, data: undefined });
                return retryStream$;
            }), operators.share());
            // reload logic
            if ((_e = options === null || options === void 0 ? void 0 : options.reloadOn) === null || _e === void 0 ? void 0 : _e.length) {
                this.subscriptions.add(reloadTrigger$.subscribe(function () {
                    if (!state$.value.loading) {
                        state$.next(Object.assign(Object.assign({}, state$.value), { loading: true }));
                    }
                }));
            }
            // reset logic
            if ((_f = options === null || options === void 0 ? void 0 : options.resetOn) === null || _f === void 0 ? void 0 : _f.length) {
                this.subscriptions.add(resetTrigger$.subscribe(function () {
                    if (state$.value.data !== undefined ||
                        state$.value.error !== false ||
                        state$.value.loading !== false) {
                        state$.next(initialState);
                    }
                }));
            }
            var query$ = rxjs.using(function () { return load$.subscribe(); }, function () { return state$; });
            var data$ = query$.pipe(operators.pluck('data'), operators.distinctUntilChanged());
            return { get: function () { return data$; }, getState: function () { return query$; } };
        };
        QueryService.prototype.getTriggersStream = function (triggers) {
            var _this = this;
            if (!triggers.length) {
                return rxjs.EMPTY;
            }
            var observables = triggers.map(function (trigger) {
                if (rxjs.isObservable(trigger)) {
                    return trigger;
                }
                return _this.eventService.get(trigger);
            });
            return rxjs.merge.apply(void 0, __spreadArray([], __read(observables)));
        };
        QueryService.prototype.ngOnDestroy = function () {
            this.subscriptions.unsubscribe();
        };
        return QueryService;
    }());
    QueryService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: QueryService, deps: [{ token: EventService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    QueryService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: QueryService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: QueryService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: EventService }]; } });

    exports.ScriptPlacement = void 0;
    (function (ScriptPlacement) {
        ScriptPlacement["HEAD"] = "head";
        ScriptPlacement["BODY"] = "body";
    })(exports.ScriptPlacement || (exports.ScriptPlacement = {}));
    var ScriptLoader = /** @class */ (function () {
        function ScriptLoader(document, platformId) {
            this.document = document;
            this.platformId = platformId;
        }
        /**
         * Embeds a javascript from an external URL.
         *
         * @param embedOptions
         * src: URL for the script to be loaded
         * params: additional parameters to be attached to the given URL
         * attributes: the attributes of HTML script tag (exclude src)
         * callback: a function to be invoked after the script has been loaded
         * errorCallback: function to be invoked after error during script loading
         * placement: HTML body or head where script will be placed
         */
        ScriptLoader.prototype.embedScript = function (embedOptions) {
            var src = embedOptions.src, params = embedOptions.params, attributes = embedOptions.attributes, callback = embedOptions.callback, errorCallback = embedOptions.errorCallback, _a = embedOptions.placement, placement = _a === void 0 ? exports.ScriptPlacement.HEAD : _a;
            var isSSR = i6.isPlatformServer(this.platformId);
            if ((callback || errorCallback) && isSSR) {
                return;
            }
            var source = params ? src + this.parseParams(params) : src;
            if (!isSSR && this.hasScript(source)) {
                return;
            }
            var script = this.document.createElement('script');
            script.src = source;
            script.async = true;
            script.defer = true;
            if (attributes) {
                Object.keys(attributes).forEach(function (key) {
                    // custom attributes
                    if (key.startsWith('data-')) {
                        script.setAttribute(key, attributes[key]);
                    }
                    else {
                        script[key] = attributes[key];
                    }
                });
            }
            if (callback) {
                script.addEventListener('load', callback);
            }
            if (errorCallback) {
                script.addEventListener('error', errorCallback);
            }
            placement === exports.ScriptPlacement.HEAD
                ? this.document.head.appendChild(script)
                : this.document.body.appendChild(script);
        };
        /**
         * Indicates if the script is already added to the DOM.
         */
        ScriptLoader.prototype.hasScript = function (src) {
            return !!this.document.querySelector("script[src=\"" + src + "\"]");
        };
        /**
         * Parses the given object with parameters to a string "param1=value1&param2=value2"
         * @param params object containing parameters
         */
        ScriptLoader.prototype.parseParams = function (params) {
            var result = '';
            var keysArray = Object.keys(params);
            if (keysArray.length > 0) {
                result =
                    '?' +
                        keysArray
                            .map(function (key) { return encodeURI(key) + '=' + encodeURI(params[key]); })
                            .join('&');
            }
            return result;
        };
        return ScriptLoader;
    }());
    ScriptLoader.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ScriptLoader, deps: [{ token: i6.DOCUMENT }, { token: i0.PLATFORM_ID }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ScriptLoader.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ScriptLoader, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: ScriptLoader, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () {
            return [{ type: undefined, decorators: [{
                            type: i0.Inject,
                            args: [i6.DOCUMENT]
                        }] }, { type: Object, decorators: [{
                            type: i0.Inject,
                            args: [i0.PLATFORM_ID]
                        }] }];
        } });

    var TimeUtils = /** @class */ (function () {
        function TimeUtils() {
        }
        /**
         * Returns the local timezone in a format that can be appended to a date-like string.
         * @param invert (default: false): returns the opposite operator relative to the local timezone
         *
         * @example
         * When locale is set to a CEST timezone, `getLocalTimezoneOffset()` returns '+02:00'
         * and `getLocalTimezoneOffset(true)` returns '-02:00'
         */
        TimeUtils.getLocalTimezoneOffset = function (invert) {
            var offset = new Date().getTimezoneOffset() * -1;
            var hours = Math.abs(Math.floor(offset / 60))
                .toString()
                .padStart(2, '0');
            var minutes = (offset % 60).toString().padStart(2, '0');
            var sign = offset >= 0 ? (invert ? "-" : "+") : invert ? "+" : "-";
            return "" + sign + hours + ":" + minutes;
        };
        TimeUtils.convertDateToDatetime = function (date, endOfDay) {
            return date + "T" + (!endOfDay ? '00:00:00' : '23:59:59') + TimeUtils.getLocalTimezoneOffset();
        };
        TimeUtils.convertDatetimeToDate = function (datetime) {
            return new Date("" + datetime.substring(0, 19) + TimeUtils.getLocalTimezoneOffset(true))
                .toISOString()
                .substring(0, 10);
        };
        return TimeUtils;
    }());

    var FeatureModulesService = /** @class */ (function () {
        function FeatureModulesService(cmsConfig, lazyModules) {
            this.cmsConfig = cmsConfig;
            this.lazyModules = lazyModules;
            /*
             * Contains resolvers for features.
             * Each resolver runs only once and caches the result.
             */
            this.features = new Map();
        }
        /**
         * Check if feature is configured properly by providing module the shell app
         *
         * @param featureName
         */
        FeatureModulesService.prototype.isConfigured = function (featureName) {
            var _a;
            return !!((_a = this.getFeatureConfig(featureName)) === null || _a === void 0 ? void 0 : _a.module);
        };
        /**
         * Resolve feature based on feature name, if feature was not yet resolved
         *
         * It will first resolve all module dependencies if defined
         */
        FeatureModulesService.prototype.resolveFeature = function (featureName) {
            var _this = this;
            featureName = this.resolveFeatureAlias(featureName);
            return rxjs.defer(function () {
                if (!_this.features.has(featureName)) {
                    if (!_this.isConfigured(featureName)) {
                        return rxjs.throwError(new Error('No module defined for Feature Module ' + featureName));
                    }
                    var featureConfig_1 = _this.getFeatureConfig(featureName);
                    _this.features.set(featureName, _this.resolveDependencies(featureConfig_1.dependencies).pipe(operators.switchMap(function (deps) { return _this.lazyModules.resolveModuleInstance(featureConfig_1.module, featureName, deps); }), operators.shareReplay()));
                }
                return _this.features.get(featureName);
            });
        };
        /**
         * Resolve
         * @param featureName
         * @protected
         */
        FeatureModulesService.prototype.getFeatureConfig = function (featureName) {
            var _a;
            return (_a = this.cmsConfig.featureModules) === null || _a === void 0 ? void 0 : _a[this.resolveFeatureAlias(featureName)];
        };
        /**
         * Will return target feature name, resolving optional feature to feature
         * string mapping
         *
         * @param featureName
         * @protected
         */
        FeatureModulesService.prototype.resolveFeatureAlias = function (featureName) {
            var _a, _b;
            while (typeof ((_a = this.cmsConfig.featureModules) === null || _a === void 0 ? void 0 : _a[featureName]) === 'string') {
                featureName = (_b = this.cmsConfig.featureModules) === null || _b === void 0 ? void 0 : _b[featureName];
            }
            return featureName;
        };
        /**
         * Resolve dependency modules for the feature
         *
         * @param dependencies
         * @protected
         */
        FeatureModulesService.prototype.resolveDependencies = function (dependencies) {
            var _this = this;
            if (dependencies === void 0) { dependencies = []; }
            return (dependencies === null || dependencies === void 0 ? void 0 : dependencies.length)
                ? rxjs.forkJoin(dependencies.map(function (dependency) {
                    if (typeof dependency === 'string') {
                        // dependency is a feature, referenced by a feature name
                        return _this.resolveFeature(dependency);
                    }
                    // resolve dependency from a module function
                    return _this.lazyModules.resolveDependencyModuleInstance(dependency);
                }))
                : rxjs.of(undefined);
        };
        return FeatureModulesService;
    }());
    FeatureModulesService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: FeatureModulesService, deps: [{ token: CmsConfig }, { token: LazyModulesService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    FeatureModulesService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: FeatureModulesService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: FeatureModulesService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: CmsConfig }, { type: LazyModulesService }]; } });

    /**
     * Service that can create proxy facade, which is a service that will expose
     * methods and properties from a facade implemented in the lazy loaded module.
     *
     * Returned proxy facade will lazy load the feature and facade implementation
     * at first method call or when first property observable will be subscribed.
     */
    var FacadeFactoryService = /** @class */ (function () {
        function FacadeFactoryService(featureModules, injector) {
            this.featureModules = featureModules;
            this.injector = injector;
        }
        FacadeFactoryService.prototype.getResolver = function (feature, facadeClass, async) {
            if (async === void 0) { async = false; }
            if (!this.featureModules.isConfigured(feature)) {
                return rxjs.throwError(new Error("Feature " + feature + " is not configured properly"));
            }
            var facadeService$ = this.featureModules.resolveFeature(feature).pipe(operators.map(function (moduleRef) { return moduleRef.injector; }), operators.map(function (injector) { return injector.get(facadeClass); }));
            if (async) {
                facadeService$ = facadeService$.pipe(operators.delay(0));
            }
            return facadeService$.pipe(operators.shareReplay());
        };
        /**
         * Calls a method on a facade
         *
         * Method should either return an observable or void. Any other return type
         * than observable is ignored.
         *
         * @param resolver$
         * @param method
         * @param args
         * @protected
         */
        FacadeFactoryService.prototype.call = function (resolver$, method, args) {
            var callResult$ = resolver$.pipe(operators.map(function (service) { return service[method].apply(service, __spreadArray([], __read(args))); }), operators.publishReplay());
            callResult$.connect();
            return callResult$.pipe(operators.switchMap(function (result) {
                if (rxjs.isObservable(result)) {
                    return result;
                }
                return rxjs.EMPTY;
            }));
        };
        /**
         * Get the property value from the facade
         *
         * Property has to be an aobservable
         *
         * @param resolver$
         * @param property
         * @protected
         */
        FacadeFactoryService.prototype.get = function (resolver$, property) {
            return resolver$.pipe(operators.switchMap(function (service) { return service[property]; }));
        };
        FacadeFactoryService.prototype.create = function (_a) {
            var _this = this;
            var facade = _a.facade, feature = _a.feature, methods = _a.methods, properties = _a.properties, async = _a.async;
            var resolver$ = this.getResolver(feature, facade, async);
            var result = new (/** @class */ (function (_super) {
                __extends(class_1, _super);
                function class_1() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                return class_1;
            }(facade)))();
            (methods !== null && methods !== void 0 ? methods : []).forEach(function (method) {
                result[method] = function () {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i] = arguments[_i];
                    }
                    return _this.call(resolver$, method, args);
                };
            });
            (properties !== null && properties !== void 0 ? properties : []).forEach(function (property) {
                result[property] = _this.get(resolver$, property);
            });
            return result;
        };
        return FacadeFactoryService;
    }());
    FacadeFactoryService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: FacadeFactoryService, deps: [{ token: FeatureModulesService }, { token: i0__namespace.Injector }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    FacadeFactoryService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: FacadeFactoryService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: FacadeFactoryService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: FeatureModulesService }, { type: i0__namespace.Injector }]; } });

    /**
     * Factory that will create proxy facade, which is a service that will expose
     * methods and properties from a facade implemented in the lazy loaded module.
     *
     * Returned proxy facade will lazy load the feature and facade implementation
     * at first method call or when first property observable will be subscribed.
     *
     * @param descriptor
     */
    function facadeFactory(descriptor) {
        return i0.inject(FacadeFactoryService).create(descriptor);
    }

    function moduleInitializersFactory(lazyModuleService, moduleInitializerFunctions) {
        var factoryFunction = function () {
            return Promise.all(lazyModuleService.runModuleInitializerFunctions(moduleInitializerFunctions)).catch(function (error) {
                console.error('MODULE_INITIALIZER promise was rejected during app initialization.', error);
                throw error;
            });
        };
        return factoryFunction;
    }
    var LazyLoadingModule = /** @class */ (function () {
        function LazyLoadingModule() {
        }
        LazyLoadingModule.forRoot = function () {
            return {
                ngModule: LazyLoadingModule,
                providers: [
                    {
                        provide: i0.APP_INITIALIZER,
                        useFactory: moduleInitializersFactory,
                        deps: [LazyModulesService, [new i0.Optional(), MODULE_INITIALIZER]],
                        multi: true,
                    },
                ],
            };
        };
        return LazyLoadingModule;
    }());
    LazyLoadingModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: LazyLoadingModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    LazyLoadingModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: LazyLoadingModule });
    LazyLoadingModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: LazyLoadingModule });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: LazyLoadingModule, decorators: [{
                type: i0.NgModule,
                args: [{}]
            }] });

    var BaseCoreModule = /** @class */ (function () {
        function BaseCoreModule() {
        }
        BaseCoreModule.forRoot = function () {
            return {
                ngModule: BaseCoreModule,
            };
        };
        return BaseCoreModule;
    }());
    BaseCoreModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: BaseCoreModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    BaseCoreModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: BaseCoreModule, imports: [StateModule, ConfigModule, ConfigInitializerModule, ConfigValidatorModule, I18nModule, CmsModule, GlobalMessageModule, ProcessModule, FeaturesConfigModule, SiteContextModule, MetaTagConfigModule, BaseOccModule, LazyLoadingModule] });
    BaseCoreModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: BaseCoreModule, imports: [[
                StateModule.forRoot(),
                ConfigModule.forRoot(),
                ConfigInitializerModule.forRoot(),
                ConfigValidatorModule.forRoot(),
                I18nModule.forRoot(),
                CmsModule.forRoot(),
                GlobalMessageModule.forRoot(),
                ProcessModule.forRoot(),
                FeaturesConfigModule.forRoot(),
                SiteContextModule.forRoot(),
                MetaTagConfigModule.forRoot(),
                BaseOccModule.forRoot(),
                LazyLoadingModule.forRoot(),
            ]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: BaseCoreModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [
                            StateModule.forRoot(),
                            ConfigModule.forRoot(),
                            ConfigInitializerModule.forRoot(),
                            ConfigValidatorModule.forRoot(),
                            I18nModule.forRoot(),
                            CmsModule.forRoot(),
                            GlobalMessageModule.forRoot(),
                            ProcessModule.forRoot(),
                            FeaturesConfigModule.forRoot(),
                            SiteContextModule.forRoot(),
                            MetaTagConfigModule.forRoot(),
                            BaseOccModule.forRoot(),
                            LazyLoadingModule.forRoot(),
                        ],
                    }]
            }] });

    /*
     * Public API Surface of core
     */
    /** AUGMENTABLE_TYPES_END */

    /**
     * Generated bundle index. Do not edit.
     */

    exports.ADDRESS_LIST_NORMALIZER = ADDRESS_LIST_NORMALIZER;
    exports.ADDRESS_NORMALIZER = ADDRESS_NORMALIZER;
    exports.ADDRESS_SERIALIZER = ADDRESS_SERIALIZER;
    exports.ADDRESS_VALIDATION_NORMALIZER = ADDRESS_VALIDATION_NORMALIZER;
    exports.ADD_PRODUCT_INTEREST_PROCESS_ID = ADD_PRODUCT_INTEREST_PROCESS_ID;
    exports.ADD_VOUCHER_PROCESS_ID = ADD_VOUCHER_PROCESS_ID;
    exports.ANONYMOUS_CONSENTS = ANONYMOUS_CONSENTS;
    exports.ANONYMOUS_CONSENTS_HEADER = ANONYMOUS_CONSENTS_HEADER;
    exports.ANONYMOUS_CONSENTS_STORE_FEATURE = ANONYMOUS_CONSENTS_STORE_FEATURE;
    exports.ANONYMOUS_CONSENT_NORMALIZER = ANONYMOUS_CONSENT_NORMALIZER;
    exports.ActivatedRoutesService = ActivatedRoutesService;
    exports.ActiveCartService = ActiveCartService;
    exports.AddUserAddressEvent = AddUserAddressEvent;
    exports.AnonymousConsentNormalizer = AnonymousConsentNormalizer;
    exports.AnonymousConsentTemplatesAdapter = AnonymousConsentTemplatesAdapter;
    exports.AnonymousConsentTemplatesConnector = AnonymousConsentTemplatesConnector;
    exports.AnonymousConsentsActions = anonymousConsentsGroup;
    exports.AnonymousConsentsConfig = AnonymousConsentsConfig;
    exports.AnonymousConsentsInterceptor = AnonymousConsentsInterceptor;
    exports.AnonymousConsentsModule = AnonymousConsentsModule;
    exports.AnonymousConsentsSelectors = anonymousConsentsGroup_selectors;
    exports.AnonymousConsentsService = AnonymousConsentsService;
    exports.AnonymousConsentsStatePersistenceService = AnonymousConsentsStatePersistenceService;
    exports.AuthActions = authGroup_actions;
    exports.AuthConfig = AuthConfig;
    exports.AuthConfigService = AuthConfigService;
    exports.AuthFlowRoutesService = AuthFlowRoutesService;
    exports.AuthGuard = AuthGuard;
    exports.AuthHttpHeaderService = AuthHttpHeaderService;
    exports.AuthInterceptor = AuthInterceptor;
    exports.AuthModule = AuthModule;
    exports.AuthRedirectService = AuthRedirectService;
    exports.AuthRedirectStorageService = AuthRedirectStorageService;
    exports.AuthService = AuthService;
    exports.AuthStatePersistenceService = AuthStatePersistenceService;
    exports.AuthStorageService = AuthStorageService;
    exports.BASE_SITE_CONTEXT_ID = BASE_SITE_CONTEXT_ID;
    exports.BASE_SITE_NORMALIZER = BASE_SITE_NORMALIZER;
    exports.BadGatewayHandler = BadGatewayHandler;
    exports.BadRequestHandler = BadRequestHandler;
    exports.BaseCoreModule = BaseCoreModule;
    exports.BaseOccModule = BaseOccModule;
    exports.BasePageMetaResolver = BasePageMetaResolver;
    exports.BaseSiteInitializer = BaseSiteInitializer;
    exports.BaseSiteNormalizer = BaseSiteNormalizer;
    exports.BaseSiteService = BaseSiteService;
    exports.CANCEL_ORDER_PROCESS_ID = CANCEL_ORDER_PROCESS_ID;
    exports.CANCEL_REPLENISHMENT_ORDER_PROCESS_ID = CANCEL_REPLENISHMENT_ORDER_PROCESS_ID;
    exports.CANCEL_RETURN_PROCESS_ID = CANCEL_RETURN_PROCESS_ID;
    exports.CART_MODIFICATION_NORMALIZER = CART_MODIFICATION_NORMALIZER;
    exports.CART_NORMALIZER = CART_NORMALIZER;
    exports.CART_VALIDATION_NORMALIZER = CART_VALIDATION_NORMALIZER;
    exports.CART_VOUCHER_NORMALIZER = CART_VOUCHER_NORMALIZER;
    exports.CLAIM_CUSTOMER_COUPON_PROCESS_ID = CLAIM_CUSTOMER_COUPON_PROCESS_ID;
    exports.CLIENT_AUTH_FEATURE = CLIENT_AUTH_FEATURE;
    exports.CLIENT_TOKEN_DATA = CLIENT_TOKEN_DATA;
    exports.CMS_COMPONENT_NORMALIZER = CMS_COMPONENT_NORMALIZER;
    exports.CMS_FEATURE = CMS_FEATURE;
    exports.CMS_FLEX_COMPONENT_TYPE = CMS_FLEX_COMPONENT_TYPE;
    exports.CMS_PAGE_NORMALIZER = CMS_PAGE_NORMALIZER;
    exports.COMPONENT_ENTITY = COMPONENT_ENTITY;
    exports.CONFIG_INITIALIZER = CONFIG_INITIALIZER;
    exports.CONSENT_TEMPLATE_NORMALIZER = CONSENT_TEMPLATE_NORMALIZER;
    exports.CONSIGNMENT_TRACKING_NORMALIZER = CONSIGNMENT_TRACKING_NORMALIZER;
    exports.COST_CENTERS_NORMALIZER = COST_CENTERS_NORMALIZER;
    exports.COST_CENTER_NORMALIZER = COST_CENTER_NORMALIZER;
    exports.COST_CENTER_SERIALIZER = COST_CENTER_SERIALIZER;
    exports.COUNTRY_NORMALIZER = COUNTRY_NORMALIZER;
    exports.CURRENCY_CONTEXT_ID = CURRENCY_CONTEXT_ID;
    exports.CURRENCY_NORMALIZER = CURRENCY_NORMALIZER;
    exports.CUSTOMER_COUPONS = CUSTOMER_COUPONS;
    exports.CUSTOMER_COUPON_SEARCH_RESULT_NORMALIZER = CUSTOMER_COUPON_SEARCH_RESULT_NORMALIZER;
    exports.CartActions = cartGroup_actions;
    exports.CartAdapter = CartAdapter;
    exports.CartAddEntryEvent = CartAddEntryEvent;
    exports.CartAddEntryFailEvent = CartAddEntryFailEvent;
    exports.CartAddEntrySuccessEvent = CartAddEntrySuccessEvent;
    exports.CartConfig = CartConfig;
    exports.CartConfigService = CartConfigService;
    exports.CartConnector = CartConnector;
    exports.CartEntryAdapter = CartEntryAdapter;
    exports.CartEntryConnector = CartEntryConnector;
    exports.CartEvent = CartEvent;
    exports.CartEventBuilder = CartEventBuilder;
    exports.CartEventModule = CartEventModule;
    exports.CartModule = CartModule;
    exports.CartOccModule = CartOccModule;
    exports.CartPersistenceModule = CartPersistenceModule;
    exports.CartRemoveEntryFailEvent = CartRemoveEntryFailEvent;
    exports.CartRemoveEntrySuccessEvent = CartRemoveEntrySuccessEvent;
    exports.CartUpdateEntryFailEvent = CartUpdateEntryFailEvent;
    exports.CartUpdateEntrySuccessEvent = CartUpdateEntrySuccessEvent;
    exports.CartValidationAdapter = CartValidationAdapter;
    exports.CartValidationConnector = CartValidationConnector;
    exports.CartValidationService = CartValidationService;
    exports.CartVoucherAdapter = CartVoucherAdapter;
    exports.CartVoucherConnector = CartVoucherConnector;
    exports.CartVoucherService = CartVoucherService;
    exports.CategoryPageMetaResolver = CategoryPageMetaResolver;
    exports.ClientAuthActions = clientTokenGroup_actions;
    exports.ClientAuthModule = ClientAuthModule;
    exports.ClientAuthSelectors = clientTokenGroup_selectors;
    exports.ClientAuthenticationTokenService = ClientAuthenticationTokenService;
    exports.ClientErrorHandlingService = ClientErrorHandlingService;
    exports.ClientTokenInterceptor = ClientTokenInterceptor;
    exports.ClientTokenService = ClientTokenService;
    exports.CmsActions = cmsGroup_actions;
    exports.CmsComponentAdapter = CmsComponentAdapter;
    exports.CmsComponentConnector = CmsComponentConnector;
    exports.CmsConfig = CmsConfig;
    exports.CmsModule = CmsModule;
    exports.CmsOccModule = CmsOccModule;
    exports.CmsPageAdapter = CmsPageAdapter;
    exports.CmsPageConnector = CmsPageConnector;
    exports.CmsSelectors = cmsGroup_selectors;
    exports.CmsService = CmsService;
    exports.CmsStructureConfig = CmsStructureConfig;
    exports.CmsStructureConfigService = CmsStructureConfigService;
    exports.Command = Command;
    exports.CommandService = CommandService;
    exports.ComponentDecorator = ComponentDecorator;
    exports.Config = Config;
    exports.ConfigChunk = ConfigChunk;
    exports.ConfigInitializerModule = ConfigInitializerModule;
    exports.ConfigInitializerService = ConfigInitializerService;
    exports.ConfigModule = ConfigModule;
    exports.ConfigValidatorModule = ConfigValidatorModule;
    exports.ConfigValidatorToken = ConfigValidatorToken;
    exports.ConfigurableRoutesService = ConfigurableRoutesService;
    exports.ConfigurationService = ConfigurationService;
    exports.ConflictHandler = ConflictHandler;
    exports.ConsentService = ConsentService;
    exports.ContentPageMetaResolver = ContentPageMetaResolver;
    exports.ContextServiceMap = ContextServiceMap;
    exports.ConverterService = ConverterService;
    exports.CostCenterModule = CostCenterModule;
    exports.CostCenterOccModule = CostCenterOccModule;
    exports.CurrencyInitializer = CurrencyInitializer;
    exports.CurrencyService = CurrencyService;
    exports.CurrencySetEvent = CurrencySetEvent;
    exports.CurrencyStatePersistenceService = CurrencyStatePersistenceService;
    exports.CustomerCouponAdapter = CustomerCouponAdapter;
    exports.CustomerCouponConnector = CustomerCouponConnector;
    exports.CustomerCouponService = CustomerCouponService;
    exports.CxDatePipe = CxDatePipe;
    exports.CxEvent = CxEvent;
    exports.CxNumericPipe = CxNumericPipe;
    exports.DEFAULT_SCOPE = DEFAULT_SCOPE;
    exports.DEFAULT_URL_MATCHER = DEFAULT_URL_MATCHER;
    exports.DefaultConfig = DefaultConfig;
    exports.DefaultConfigChunk = DefaultConfigChunk;
    exports.DefaultRoutePageMetaResolver = DefaultRoutePageMetaResolver;
    exports.DeleteUserAddressEvent = DeleteUserAddressEvent;
    exports.DynamicAttributeService = DynamicAttributeService;
    exports.EMAIL_PATTERN = EMAIL_PATTERN;
    exports.EventService = EventService;
    exports.ExternalRoutesConfig = ExternalRoutesConfig;
    exports.ExternalRoutesGuard = ExternalRoutesGuard;
    exports.ExternalRoutesModule = ExternalRoutesModule;
    exports.ExternalRoutesService = ExternalRoutesService;
    exports.FacadeFactoryService = FacadeFactoryService;
    exports.FacetChangedEvent = FacetChangedEvent;
    exports.FeatureConfigService = FeatureConfigService;
    exports.FeatureDirective = FeatureDirective;
    exports.FeatureLevelDirective = FeatureLevelDirective;
    exports.FeatureModulesService = FeatureModulesService;
    exports.FeaturesConfig = FeaturesConfig;
    exports.FeaturesConfigModule = FeaturesConfigModule;
    exports.ForbiddenHandler = ForbiddenHandler;
    exports.GIVE_CONSENT_PROCESS_ID = GIVE_CONSENT_PROCESS_ID;
    exports.GLOBAL_MESSAGE_FEATURE = GLOBAL_MESSAGE_FEATURE;
    exports.GatewayTimeoutHandler = GatewayTimeoutHandler;
    exports.GlobService = GlobService;
    exports.GlobalMessageActions = globalMessageGroup_actions;
    exports.GlobalMessageConfig = GlobalMessageConfig;
    exports.GlobalMessageModule = GlobalMessageModule;
    exports.GlobalMessageSelectors = globalMessageGroup_selectors;
    exports.GlobalMessageService = GlobalMessageService;
    exports.HOME_PAGE_CONTEXT = HOME_PAGE_CONTEXT;
    exports.HttpErrorHandler = HttpErrorHandler;
    exports.HttpErrorModel = HttpErrorModel;
    exports.HttpParamsURIEncoder = HttpParamsURIEncoder;
    exports.I18nConfig = I18nConfig;
    exports.I18nConfigInitializer = I18nConfigInitializer;
    exports.I18nModule = I18nModule;
    exports.I18nTestingModule = I18nTestingModule;
    exports.I18nextTranslationService = I18nextTranslationService;
    exports.InterceptorUtil = InterceptorUtil;
    exports.InternalServerErrorHandler = InternalServerErrorHandler;
    exports.JSP_INCLUDE_CMS_COMPONENT_TYPE = JSP_INCLUDE_CMS_COMPONENT_TYPE;
    exports.JavaRegExpConverter = JavaRegExpConverter;
    exports.LANGUAGE_CONTEXT_ID = LANGUAGE_CONTEXT_ID;
    exports.LANGUAGE_NORMALIZER = LANGUAGE_NORMALIZER;
    exports.LanguageInitializer = LanguageInitializer;
    exports.LanguageService = LanguageService;
    exports.LanguageSetEvent = LanguageSetEvent;
    exports.LanguageStatePersistenceService = LanguageStatePersistenceService;
    exports.LazyModulesService = LazyModulesService;
    exports.LegacyOccCmsComponentAdapter = LegacyOccCmsComponentAdapter;
    exports.LoadingScopesService = LoadingScopesService;
    exports.LoginEvent = LoginEvent;
    exports.LogoutEvent = LogoutEvent;
    exports.MEDIA_BASE_URL_META_TAG_NAME = MEDIA_BASE_URL_META_TAG_NAME;
    exports.MEDIA_BASE_URL_META_TAG_PLACEHOLDER = MEDIA_BASE_URL_META_TAG_PLACEHOLDER;
    exports.MODULE_INITIALIZER = MODULE_INITIALIZER;
    exports.MULTI_CART_DATA = MULTI_CART_DATA;
    exports.MULTI_CART_FEATURE = MULTI_CART_FEATURE;
    exports.MergeCartSuccessEvent = MergeCartSuccessEvent;
    exports.MetaTagConfigModule = MetaTagConfigModule;
    exports.MockDatePipe = MockDatePipe;
    exports.MockTranslatePipe = MockTranslatePipe;
    exports.ModuleInitializedEvent = ModuleInitializedEvent;
    exports.MultiCartSelectors = multiCartGroup_selectors;
    exports.MultiCartService = MultiCartService;
    exports.MultiCartStatePersistenceService = MultiCartStatePersistenceService;
    exports.NAVIGATION_DETAIL_ENTITY = NAVIGATION_DETAIL_ENTITY;
    exports.NOTIFICATION_PREFERENCES = NOTIFICATION_PREFERENCES;
    exports.NotAuthGuard = NotAuthGuard;
    exports.NotFoundHandler = NotFoundHandler;
    exports.OAuthLibWrapperService = OAuthLibWrapperService;
    exports.OCC_BASE_URL_META_TAG_NAME = OCC_BASE_URL_META_TAG_NAME;
    exports.OCC_BASE_URL_META_TAG_PLACEHOLDER = OCC_BASE_URL_META_TAG_PLACEHOLDER;
    exports.OCC_CART_ID_CURRENT = OCC_CART_ID_CURRENT;
    exports.OCC_USER_ID_ANONYMOUS = OCC_USER_ID_ANONYMOUS;
    exports.OCC_USER_ID_CURRENT = OCC_USER_ID_CURRENT;
    exports.OCC_USER_ID_GUEST = OCC_USER_ID_GUEST;
    exports.ORDER_HISTORY_NORMALIZER = ORDER_HISTORY_NORMALIZER;
    exports.ORDER_NORMALIZER = ORDER_NORMALIZER;
    exports.ORDER_RETURNS_NORMALIZER = ORDER_RETURNS_NORMALIZER;
    exports.ORDER_RETURN_REQUEST_INPUT_SERIALIZER = ORDER_RETURN_REQUEST_INPUT_SERIALIZER;
    exports.ORDER_RETURN_REQUEST_NORMALIZER = ORDER_RETURN_REQUEST_NORMALIZER;
    exports.OccAnonymousConsentTemplatesAdapter = OccAnonymousConsentTemplatesAdapter;
    exports.OccCartAdapter = OccCartAdapter;
    exports.OccCartEntryAdapter = OccCartEntryAdapter;
    exports.OccCartNormalizer = OccCartNormalizer;
    exports.OccCartValidationAdapter = OccCartValidationAdapter;
    exports.OccCartVoucherAdapter = OccCartVoucherAdapter;
    exports.OccCmsComponentAdapter = OccCmsComponentAdapter;
    exports.OccCmsPageAdapter = OccCmsPageAdapter;
    exports.OccCmsPageNormalizer = OccCmsPageNormalizer;
    exports.OccConfig = OccConfig;
    exports.OccCostCenterListNormalizer = OccCostCenterListNormalizer;
    exports.OccCostCenterNormalizer = OccCostCenterNormalizer;
    exports.OccCostCenterSerializer = OccCostCenterSerializer;
    exports.OccCustomerCouponAdapter = OccCustomerCouponAdapter;
    exports.OccEndpointsService = OccEndpointsService;
    exports.OccFieldsService = OccFieldsService;
    exports.OccOrderNormalizer = OccOrderNormalizer;
    exports.OccProductAdapter = OccProductAdapter;
    exports.OccProductReferencesAdapter = OccProductReferencesAdapter;
    exports.OccProductReferencesListNormalizer = OccProductReferencesListNormalizer;
    exports.OccProductReviewsAdapter = OccProductReviewsAdapter;
    exports.OccProductSearchAdapter = OccProductSearchAdapter;
    exports.OccProductSearchPageNormalizer = OccProductSearchPageNormalizer;
    exports.OccReplenishmentOrderNormalizer = OccReplenishmentOrderNormalizer;
    exports.OccRequestsOptimizerService = OccRequestsOptimizerService;
    exports.OccReturnRequestNormalizer = OccReturnRequestNormalizer;
    exports.OccSiteAdapter = OccSiteAdapter;
    exports.OccUserAddressAdapter = OccUserAddressAdapter;
    exports.OccUserConsentAdapter = OccUserConsentAdapter;
    exports.OccUserInterestsAdapter = OccUserInterestsAdapter;
    exports.OccUserInterestsNormalizer = OccUserInterestsNormalizer;
    exports.OccUserNotificationPreferenceAdapter = OccUserNotificationPreferenceAdapter;
    exports.OccUserOrderAdapter = OccUserOrderAdapter;
    exports.OccUserPaymentAdapter = OccUserPaymentAdapter;
    exports.OccUserReplenishmentOrderAdapter = OccUserReplenishmentOrderAdapter;
    exports.OrderEntryPromotionsService = OrderEntryPromotionsService;
    exports.OrderOccModule = OrderOccModule;
    exports.OrderReturnRequestService = OrderReturnRequestService;
    exports.PASSWORD_PATTERN = PASSWORD_PATTERN;
    exports.PAYMENT_DETAILS_NORMALIZER = PAYMENT_DETAILS_NORMALIZER;
    exports.POINT_OF_SERVICE_NORMALIZER = POINT_OF_SERVICE_NORMALIZER;
    exports.PROCESS_FEATURE = PROCESS_FEATURE;
    exports.PRODUCT_DETAIL_ENTITY = PRODUCT_DETAIL_ENTITY;
    exports.PRODUCT_FEATURE = PRODUCT_FEATURE;
    exports.PRODUCT_INTERESTS = PRODUCT_INTERESTS;
    exports.PRODUCT_INTERESTS_NORMALIZER = PRODUCT_INTERESTS_NORMALIZER;
    exports.PRODUCT_NORMALIZER = PRODUCT_NORMALIZER;
    exports.PRODUCT_REFERENCES_NORMALIZER = PRODUCT_REFERENCES_NORMALIZER;
    exports.PRODUCT_REVIEW_NORMALIZER = PRODUCT_REVIEW_NORMALIZER;
    exports.PRODUCT_REVIEW_SERIALIZER = PRODUCT_REVIEW_SERIALIZER;
    exports.PRODUCT_SEARCH_PAGE_NORMALIZER = PRODUCT_SEARCH_PAGE_NORMALIZER;
    exports.PRODUCT_SUGGESTION_NORMALIZER = PRODUCT_SUGGESTION_NORMALIZER;
    exports.PageContext = PageContext;
    exports.PageLinkService = PageLinkService;
    exports.PageMetaConfig = PageMetaConfig;
    exports.PageMetaModule = PageMetaModule;
    exports.PageMetaResolver = PageMetaResolver;
    exports.PageMetaService = PageMetaService;
    exports.ProcessModule = ProcessModule;
    exports.ProcessSelectors = process_selectors;
    exports.ProductActions = productGroup_actions;
    exports.ProductAdapter = ProductAdapter;
    exports.ProductConnector = ProductConnector;
    exports.ProductEventBuilder = ProductEventBuilder;
    exports.ProductEventModule = ProductEventModule;
    exports.ProductImageNormalizer = ProductImageNormalizer;
    exports.ProductLoadingService = ProductLoadingService;
    exports.ProductModule = ProductModule;
    exports.ProductNameNormalizer = ProductNameNormalizer;
    exports.ProductOccModule = ProductOccModule;
    exports.ProductPageMetaResolver = ProductPageMetaResolver;
    exports.ProductReferenceNormalizer = ProductReferenceNormalizer;
    exports.ProductReferenceService = ProductReferenceService;
    exports.ProductReferencesAdapter = ProductReferencesAdapter;
    exports.ProductReferencesConnector = ProductReferencesConnector;
    exports.ProductReviewService = ProductReviewService;
    exports.ProductReviewsAdapter = ProductReviewsAdapter;
    exports.ProductReviewsConnector = ProductReviewsConnector;
    exports.ProductSearchAdapter = ProductSearchAdapter;
    exports.ProductSearchConnector = ProductSearchConnector;
    exports.ProductSearchService = ProductSearchService;
    exports.ProductSelectors = productGroup_selectors;
    exports.ProductService = ProductService;
    exports.ProductURLPipe = ProductURLPipe;
    exports.ProtectedRoutesGuard = ProtectedRoutesGuard;
    exports.ProtectedRoutesService = ProtectedRoutesService;
    exports.QueryService = QueryService;
    exports.REGIONS = REGIONS;
    exports.REGION_NORMALIZER = REGION_NORMALIZER;
    exports.REGISTER_USER_PROCESS_ID = REGISTER_USER_PROCESS_ID;
    exports.REMOVE_PRODUCT_INTERESTS_PROCESS_ID = REMOVE_PRODUCT_INTERESTS_PROCESS_ID;
    exports.REPLENISHMENT_ORDER_HISTORY_NORMALIZER = REPLENISHMENT_ORDER_HISTORY_NORMALIZER;
    exports.REPLENISHMENT_ORDER_NORMALIZER = REPLENISHMENT_ORDER_NORMALIZER;
    exports.ROUTING_FEATURE = ROUTING_FEATURE;
    exports.RootConfig = RootConfig;
    exports.RoutingActions = routingGroup_actions;
    exports.RoutingConfig = RoutingConfig;
    exports.RoutingConfigService = RoutingConfigService;
    exports.RoutingModule = RoutingModule;
    exports.RoutingPageMetaResolver = RoutingPageMetaResolver;
    exports.RoutingParamsService = RoutingParamsService;
    exports.RoutingSelector = routingGroup_selectors;
    exports.RoutingService = RoutingService;
    exports.SAVE_CART_NORMALIZER = SAVE_CART_NORMALIZER;
    exports.SERVER_REQUEST_ORIGIN = SERVER_REQUEST_ORIGIN;
    exports.SERVER_REQUEST_URL = SERVER_REQUEST_URL;
    exports.SITE_CONTEXT_FEATURE = SITE_CONTEXT_FEATURE;
    exports.SMART_EDIT_CONTEXT = SMART_EDIT_CONTEXT;
    exports.SUBSCRIBE_CUSTOMER_COUPON_PROCESS_ID = SUBSCRIBE_CUSTOMER_COUPON_PROCESS_ID;
    exports.SaveCartAdapter = SaveCartAdapter;
    exports.SaveCartConnector = SaveCartConnector;
    exports.ScriptLoader = ScriptLoader;
    exports.SearchPageMetaResolver = SearchPageMetaResolver;
    exports.SearchboxService = SearchboxService;
    exports.SelectiveCartService = SelectiveCartService;
    exports.SemanticPathService = SemanticPathService;
    exports.SiteAdapter = SiteAdapter;
    exports.SiteConnector = SiteConnector;
    exports.SiteContextActions = siteContextGroup_actions;
    exports.SiteContextConfig = SiteContextConfig;
    exports.SiteContextConfigInitializer = SiteContextConfigInitializer;
    exports.SiteContextEventBuilder = SiteContextEventBuilder;
    exports.SiteContextEventModule = SiteContextEventModule;
    exports.SiteContextInterceptor = SiteContextInterceptor;
    exports.SiteContextModule = SiteContextModule;
    exports.SiteContextOccModule = SiteContextOccModule;
    exports.SiteContextParamsService = SiteContextParamsService;
    exports.SiteContextSelectors = siteContextGroup_selectors;
    exports.SiteContextUrlSerializer = SiteContextUrlSerializer;
    exports.SlotDecorator = SlotDecorator;
    exports.StateConfig = StateConfig;
    exports.StateEventService = StateEventService;
    exports.StateModule = StateModule;
    exports.StatePersistenceService = StatePersistenceService;
    exports.StateUtils = utilsGroup;
    exports.StringTemplate = StringTemplate;
    exports.THEME_CONTEXT_ID = THEME_CONTEXT_ID;
    exports.TestConfigModule = TestConfigModule;
    exports.TimeUtils = TimeUtils;
    exports.TokenRevocationInterceptor = TokenRevocationInterceptor;
    exports.TranslatePipe = TranslatePipe;
    exports.TranslationChunkService = TranslationChunkService;
    exports.TranslationService = TranslationService;
    exports.UNSUBSCRIBE_CUSTOMER_COUPON_PROCESS_ID = UNSUBSCRIBE_CUSTOMER_COUPON_PROCESS_ID;
    exports.UPDATE_NOTIFICATION_PREFERENCES_PROCESS_ID = UPDATE_NOTIFICATION_PREFERENCES_PROCESS_ID;
    exports.USER_ADDRESSES = USER_ADDRESSES;
    exports.USER_CONSENTS = USER_CONSENTS;
    exports.USER_COST_CENTERS = USER_COST_CENTERS;
    exports.USER_FEATURE = USER_FEATURE;
    exports.USER_ORDERS = USER_ORDERS;
    exports.USER_ORDER_DETAILS = USER_ORDER_DETAILS;
    exports.USER_PAYMENT_METHODS = USER_PAYMENT_METHODS;
    exports.USER_REPLENISHMENT_ORDERS = USER_REPLENISHMENT_ORDERS;
    exports.USER_REPLENISHMENT_ORDER_DETAILS = USER_REPLENISHMENT_ORDER_DETAILS;
    exports.USER_RETURN_REQUESTS = USER_RETURN_REQUESTS;
    exports.USER_RETURN_REQUEST_DETAILS = USER_RETURN_REQUEST_DETAILS;
    exports.USE_CLIENT_TOKEN = USE_CLIENT_TOKEN;
    exports.USE_CUSTOMER_SUPPORT_AGENT_TOKEN = USE_CUSTOMER_SUPPORT_AGENT_TOKEN;
    exports.UnifiedInjector = UnifiedInjector;
    exports.UnknownErrorHandler = UnknownErrorHandler;
    exports.UpdateUserAddressEvent = UpdateUserAddressEvent;
    exports.UrlMatcherService = UrlMatcherService;
    exports.UrlModule = UrlModule;
    exports.UrlParsingService = UrlParsingService;
    exports.UrlPipe = UrlPipe;
    exports.UserAccountFacadeTransitionalToken = UserAccountFacadeTransitionalToken;
    exports.UserActions = userGroup_actions;
    exports.UserAddressAdapter = UserAddressAdapter;
    exports.UserAddressConnector = UserAddressConnector;
    exports.UserAddressEvent = UserAddressEvent;
    exports.UserAddressService = UserAddressService;
    exports.UserAuthEventBuilder = UserAuthEventBuilder;
    exports.UserAuthEventModule = UserAuthEventModule;
    exports.UserAuthModule = UserAuthModule;
    exports.UserConsentAdapter = UserConsentAdapter;
    exports.UserConsentConnector = UserConsentConnector;
    exports.UserConsentService = UserConsentService;
    exports.UserCostCenterAdapter = UserCostCenterAdapter;
    exports.UserCostCenterConnector = UserCostCenterConnector;
    exports.UserCostCenterService = UserCostCenterService;
    exports.UserEventBuilder = UserEventBuilder;
    exports.UserEventModule = UserEventModule;
    exports.UserIdService = UserIdService;
    exports.UserInterestsAdapter = UserInterestsAdapter;
    exports.UserInterestsConnector = UserInterestsConnector;
    exports.UserInterestsService = UserInterestsService;
    exports.UserNotificationPreferenceService = UserNotificationPreferenceService;
    exports.UserOccModule = UserOccModule;
    exports.UserOccTransitionalModule = UserOccTransitionalModule;
    exports.UserOccTransitional_4_2_Module = UserOccTransitional_4_2_Module;
    exports.UserOrderAdapter = UserOrderAdapter;
    exports.UserOrderConnector = UserOrderConnector;
    exports.UserOrderService = UserOrderService;
    exports.UserPaymentAdapter = UserPaymentAdapter;
    exports.UserPaymentConnector = UserPaymentConnector;
    exports.UserPaymentService = UserPaymentService;
    exports.UserProfileFacadeTransitionalToken = UserProfileFacadeTransitionalToken;
    exports.UserReplenishmentOrderAdapter = UserReplenishmentOrderAdapter;
    exports.UserReplenishmentOrderConnector = UserReplenishmentOrderConnector;
    exports.UserReplenishmentOrderService = UserReplenishmentOrderService;
    exports.UserService = UserService;
    exports.UserTransitionalModule = UserTransitionalModule;
    exports.UserTransitional_4_2_Module = UserTransitional_4_2_Module;
    exports.UsersSelectors = usersGroup_selectors;
    exports.WITHDRAW_CONSENT_PROCESS_ID = WITHDRAW_CONSENT_PROCESS_ID;
    exports.WindowRef = WindowRef;
    exports.WishListService = WishListService;
    exports.WithCredentialsInterceptor = WithCredentialsInterceptor;
    exports.configInitializerFactory = configInitializerFactory;
    exports.configValidatorFactory = configValidatorFactory;
    exports.contextServiceMapProvider = contextServiceMapProvider;
    exports.createFrom = createFrom;
    exports.deepMerge = deepMerge;
    exports.defaultAnonymousConsentsConfig = defaultAnonymousConsentsConfig;
    exports.defaultCmsModuleConfig = defaultCmsModuleConfig;
    exports.defaultOccConfig = defaultOccConfig;
    exports.defaultPageMetaConfig = defaultPageMetaConfig;
    exports.errorHandlers = errorHandlers;
    exports.facadeFactory = facadeFactory;
    exports.getCartIdByUserId = getCartIdByUserId;
    exports.getContextParameterDefault = getContextParameterDefault;
    exports.getContextParameterValues = getContextParameterValues;
    exports.getLastValueSync = getLastValueSync;
    exports.getWishlistName = getWishlistName;
    exports.httpErrorInterceptors = httpErrorInterceptors;
    exports.initConfigurableRoutes = initConfigurableRoutes;
    exports.isCartNotFoundError = isCartNotFoundError;
    exports.isFeatureEnabled = isFeatureEnabled;
    exports.isFeatureLevel = isFeatureLevel;
    exports.isNotNullable = isNotNullable;
    exports.isNotUndefined = isNotUndefined;
    exports.isObject = isObject;
    exports.isSelectiveCart = isSelectiveCart;
    exports.isTempCartId = isTempCartId;
    exports.locationInitializedFactory = locationInitializedFactory;
    exports.mediaServerConfigFromMetaTagFactory = mediaServerConfigFromMetaTagFactory;
    exports.normalizeHttpError = normalizeHttpError;
    exports.occConfigValidator = occConfigValidator;
    exports.occServerConfigFromMetaTagFactory = occServerConfigFromMetaTagFactory;
    exports.provideConfig = provideConfig;
    exports.provideConfigFactory = provideConfigFactory;
    exports.provideConfigFromMetaTags = provideConfigFromMetaTags;
    exports.provideConfigValidator = provideConfigValidator;
    exports.provideDefaultConfig = provideDefaultConfig;
    exports.provideDefaultConfigFactory = provideDefaultConfigFactory;
    exports.recurrencePeriod = recurrencePeriod;
    exports.resolveApplicable = resolveApplicable;
    exports.serviceMapFactory = serviceMapFactory;
    exports.uniteLatest = uniteLatest;
    exports.urlPathJoin = urlPathJoin;
    exports.validateConfig = validateConfig;
    exports.withdrawOn = withdrawOn;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=spartacus-core.umd.js.map
