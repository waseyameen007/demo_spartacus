"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.migrateComponentMigration = void 0;
const ast_utils_1 = require("@schematics/angular/utility/ast-utils");
const change_1 = require("@schematics/angular/utility/change");
const constants_1 = require("../../../shared/constants");
const file_utils_1 = require("../../../shared/utils/file-utils");
const module_file_utils_1 = require("../../../shared/utils/module-file-utils");
const workspace_utils_1 = require("../../../shared/utils/workspace-utils");
function migrateComponentMigration(tree, context, componentData) {
    context.logger.info('Checking component selectors...');
    const project = workspace_utils_1.getSourceRoot(tree, {});
    const sourceFiles = file_utils_1.getAllTsSourceFiles(tree, project);
    for (const originalSource of sourceFiles) {
        const nodes = ast_utils_1.getSourceNodes(originalSource);
        const sourcePath = originalSource.fileName;
        for (const deprecatedComponent of componentData) {
            // check for usages of inputs / outputs of the deprecated component
            const sourceRoot = workspace_utils_1.getSourceRoot(tree);
            const allHtmlFiles = file_utils_1.getHtmlFiles(tree, '.html', sourceRoot);
            for (const htmlFile of allHtmlFiles) {
                for (const removedProperty of deprecatedComponent.removedInputOutputProperties ||
                    []) {
                    const buffer = tree.read(htmlFile);
                    if (!buffer) {
                        context.logger.warn(`Could not read file (${htmlFile}).`);
                        continue;
                    }
                    const content = buffer.toString(constants_1.UTF_8);
                    const contentChange = file_utils_1.insertComponentSelectorComment(content, deprecatedComponent.selector, removedProperty);
                    if (contentChange) {
                        tree.overwrite(htmlFile, contentChange);
                    }
                }
            }
            // check for usages of the deprecated component properties in the .ts and the corresponding template (.html) files
            if (file_utils_1.isInheriting(nodes, deprecatedComponent.componentClassName)) {
                for (const removedProperty of deprecatedComponent.removedProperties ||
                    []) {
                    // 'source' has to be reloaded after each committed change
                    const source = file_utils_1.getTsSourceFile(tree, sourcePath);
                    const changes = file_utils_1.insertCommentAboveIdentifier(sourcePath, source, removedProperty.name, file_utils_1.buildSpartacusComment(removedProperty.comment));
                    const templateInfo = module_file_utils_1.getTemplateInfo(source);
                    if (!templateInfo) {
                        file_utils_1.commitChanges(tree, sourcePath, changes, file_utils_1.InsertDirection.RIGHT);
                        continue;
                    }
                    const htmlFileName = templateInfo.templateUrl;
                    if (htmlFileName) {
                        const htmlFilePath = file_utils_1.getHtmlFiles(tree, htmlFileName, sourceRoot)[0];
                        const buffer = tree.read(htmlFilePath);
                        if (!buffer) {
                            context.logger.warn(`Could not read file (${htmlFilePath}).`);
                            file_utils_1.commitChanges(tree, sourcePath, changes, file_utils_1.InsertDirection.RIGHT);
                            continue;
                        }
                        const content = buffer.toString(constants_1.UTF_8);
                        const contentChange = file_utils_1.insertHtmlComment(content, removedProperty);
                        if (contentChange) {
                            tree.overwrite(htmlFilePath, contentChange);
                        }
                    }
                    else if (templateInfo.inlineTemplateContent) {
                        const oldContent = templateInfo.inlineTemplateContent;
                        const contentChange = file_utils_1.insertHtmlComment(oldContent, removedProperty);
                        if (contentChange) {
                            const replaceChange = new change_1.ReplaceChange(sourcePath, templateInfo.inlineTemplateStart || 0, oldContent, contentChange);
                            changes.push(replaceChange);
                        }
                    }
                    file_utils_1.commitChanges(tree, sourcePath, changes, file_utils_1.InsertDirection.RIGHT);
                }
            }
        }
    }
    return tree;
}
exports.migrateComponentMigration = migrateComponentMigration;
//# sourceMappingURL=component-deprecations.js.map