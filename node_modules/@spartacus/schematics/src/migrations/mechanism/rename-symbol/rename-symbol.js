"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.migrateRenamedSymbols = void 0;
const program_1 = require("../../../shared/utils/program");
const project_tsconfig_paths_1 = require("../../../shared/utils/project-tsconfig-paths");
const workspace_utils_1 = require("../../../shared/utils/workspace-utils");
function migrateRenamedSymbols(tree, renamedSymbols) {
    const project = workspace_utils_1.getDefaultProjectNameFromWorkspace(tree);
    const { buildPaths } = project_tsconfig_paths_1.getProjectTsConfigPaths(tree, project);
    const basePath = process.cwd();
    for (const tsconfigPath of buildPaths) {
        const { appSourceFiles } = program_1.createProgram(tree, basePath, tsconfigPath);
        appSourceFiles.forEach((sourceFile) => {
            const importDeclarationStructures = [];
            sourceFile.getImportDeclarations().forEach((id) => {
                var _a;
                (_a = id.getImportClause()) === null || _a === void 0 ? void 0 : _a.getNamedImports().forEach((namedImport) => {
                    var _a, _b, _c;
                    const importName = namedImport.getName();
                    const renamedSymbol = renamedSymbols.find((symbol) => symbol.previousNode === importName &&
                        symbol.previousImportPath === id.getModuleSpecifierValue());
                    if (renamedSymbol) {
                        const newNodeName = renamedSymbol.newNode
                            ? renamedSymbol.newNode
                            : importName;
                        const oldAlias = (_a = namedImport.getAliasNode()) === null || _a === void 0 ? void 0 : _a.getText();
                        let importPath = renamedSymbol.previousImportPath;
                        if (renamedSymbol.newImportPath) {
                            importPath = renamedSymbol.newImportPath;
                        }
                        if (!oldAlias && renamedSymbol.newNode) {
                            namedImport.renameAlias(newNodeName);
                        }
                        importDeclarationStructures.push({
                            namedImports: [
                                {
                                    name: newNodeName,
                                    alias: oldAlias,
                                },
                            ],
                            moduleSpecifier: importPath,
                        });
                        if ((((_c = (_b = id.getImportClause()) === null || _b === void 0 ? void 0 : _b.getNamedImports()) === null || _c === void 0 ? void 0 : _c.length) || 0) > 1) {
                            namedImport.remove();
                        }
                        else {
                            id.remove();
                        }
                    }
                });
            });
            if (importDeclarationStructures.length) {
                sourceFile.addImportDeclarations(importDeclarationStructures);
                // organizeImports will remove unused imports
                program_1.saveAndFormat(sourceFile);
            }
        });
    }
    return tree;
}
exports.migrateRenamedSymbols = migrateRenamedSymbols;
//# sourceMappingURL=rename-symbol.js.map