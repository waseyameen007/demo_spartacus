"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.migrateDependencies = void 0;
const schematics_1 = require("@angular-devkit/schematics");
const dependencies_1 = require("@schematics/angular/utility/dependencies");
const semver_1 = __importDefault(require("semver"));
const dependencies_json_1 = __importDefault(require("../../../dependencies.json"));
const constants_1 = require("../../../shared/constants");
const lib_utils_1 = require("../../../shared/utils/lib-utils");
const package_utils_1 = require("../../../shared/utils/package-utils");
function migrateDependencies(tree, context, removedDependencies) {
    const packageJson = package_utils_1.readPackageJson(tree);
    const { spartacusPeerDeps, installedLibs } = collectSpartacusLibraryDependencies(packageJson);
    const allSpartacusDeps = installedLibs.concat(spartacusPeerDeps);
    checkAndLogRemovedDependencies(packageJson, allSpartacusDeps, removedDependencies, context.logger);
    const dependencies = createSpartacusLibraryDependencies(allSpartacusDeps, installedLibs)
        .filter((d) => d.name !== constants_1.SPARTACUS_SCHEMATICS)
        .sort((d1, d2) => d1.name.localeCompare(d2.name));
    return schematics_1.chain([
        updatePackageJsonDependencies(dependencies, packageJson),
        lib_utils_1.installPackageJsonDependencies(),
    ]);
}
exports.migrateDependencies = migrateDependencies;
function collectSpartacusLibraryDependencies(packageJson) {
    var _a;
    const dependencies = (_a = packageJson.dependencies) !== null && _a !== void 0 ? _a : {};
    const installedLibs = Object.keys(dependencies).filter((dep) => dep.startsWith(constants_1.SPARTACUS_SCOPE));
    let spartacusPeerDeps = [];
    for (const spartacusLib of installedLibs) {
        spartacusPeerDeps = collectSpartacusPeerDeps(spartacusPeerDeps, spartacusLib);
    }
    // remove the duplicates
    spartacusPeerDeps = Array.from(new Set(spartacusPeerDeps));
    return {
        installedLibs,
        spartacusPeerDeps,
    };
}
function collectSpartacusPeerDeps(collectedDeps, name) {
    const peerDepsWithVersions = dependencies_json_1.default[name];
    const peerDeps = Object.keys(peerDepsWithVersions)
        .filter((d) => d.startsWith(constants_1.SPARTACUS_SCOPE))
        .filter((d) => !package_utils_1.CORE_SPARTACUS_SCOPES.includes(d))
        .filter((d) => !collectedDeps.includes(d));
    collectedDeps = collectedDeps.concat(peerDeps);
    for (const peerDep of peerDeps) {
        collectedDeps = collectSpartacusPeerDeps(collectedDeps, peerDep);
    }
    return collectedDeps;
}
function createSpartacusLibraryDependencies(allSpartacusLibraries, skipScopes) {
    const dependenciesToAdd = [];
    for (const libraryName of allSpartacusLibraries) {
        const spartacusLibrary = dependencies_json_1.default[libraryName];
        const newDependencies = package_utils_1.createDependencies(spartacusLibrary, {
            skipScopes,
            overwrite: true,
        });
        // ensure no duplicates are created
        newDependencies.forEach((newDependency) => {
            if (!dependenciesToAdd.some((existingDependency) => existingDependency.name === newDependency.name)) {
                dependenciesToAdd.push(newDependency);
            }
        });
    }
    return dependenciesToAdd;
}
function checkAndLogRemovedDependencies(packageJson, installedSpartacusLibs, removedDependencies, logger) {
    var _a;
    const dependencies = (_a = packageJson.dependencies) !== null && _a !== void 0 ? _a : {};
    let allSpartacusDeps = [];
    for (const libraryName of installedSpartacusLibs) {
        const spartacusLibrary = dependencies_json_1.default[libraryName];
        allSpartacusDeps = allSpartacusDeps.concat(Object.keys(spartacusLibrary));
    }
    const removed = [];
    for (const removedDependency of removedDependencies) {
        if (!dependencies[removedDependency]) {
            continue;
        }
        if (!allSpartacusDeps.includes(removedDependency)) {
            removed.push(removedDependency);
        }
    }
    if (removed.length) {
        logger.warn(`Spartacus libraries no longer require the following dependencies: ${removed.join(',')}. If you don't use these dependencies in your application, you might want to consider removing them from your dependencies list.`);
    }
}
function updatePackageJsonDependencies(dependencies, packageJson) {
    return (tree, context) => {
        const dependenciesToAdd = [];
        for (const dependency of dependencies) {
            const currentVersion = getCurrentDependencyVersion(dependency, packageJson);
            if (!currentVersion) {
                dependenciesToAdd.push(dependency);
                continue;
            }
            if (semver_1.default.satisfies(currentVersion, dependency.version)) {
                continue;
            }
            const versionToUpdate = semver_1.default.parse(package_utils_1.cleanSemverVersion(dependency.version));
            if (!versionToUpdate || semver_1.default.eq(versionToUpdate, currentVersion)) {
                continue;
            }
            dependencies_1.addPackageJsonDependency(tree, dependency);
            const change = semver_1.default.gt(versionToUpdate, currentVersion)
                ? 'Upgrading'
                : 'Downgrading';
            context.logger.info(`ðŸ©¹ ${change} '${dependency.name}' to ${dependency.version} (was ${currentVersion.raw})`);
        }
        return lib_utils_1.addPackageJsonDependencies(dependenciesToAdd, packageJson);
    };
}
function getCurrentDependencyVersion(dependency, packageJson) {
    if (!lib_utils_1.dependencyExists(dependency, packageJson)) {
        return null;
    }
    const dependencies = packageJson[dependency.type];
    const currentVersion = dependencies[dependency.name];
    return semver_1.default.parse(package_utils_1.cleanSemverVersion(currentVersion));
}
//# sourceMappingURL=dependency-management.js.map