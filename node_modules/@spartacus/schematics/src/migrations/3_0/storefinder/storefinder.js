"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.migrate = void 0;
const schematics_1 = require("@angular-devkit/schematics");
const ast_utils_1 = require("@schematics/angular/utility/ast-utils");
const change_1 = require("@schematics/angular/utility/change");
const dependencies_1 = require("@schematics/angular/utility/dependencies");
const ng_ast_utils_1 = require("@schematics/angular/utility/ng-ast-utils");
const index_1 = require("../../../shared/index");
const workspace_utils_1 = require("../../../shared/utils/workspace-utils");
function migrate() {
    return (tree) => __awaiter(this, void 0, void 0, function* () {
        var _a, _b, _c, _d;
        const packageJson = index_1.readPackageJson(tree);
        const projectName = index_1.getDefaultProjectNameFromWorkspace(tree);
        const angularJson = workspace_utils_1.getAngularJsonFile(tree);
        const mainPath = (_d = (_c = (_b = (_a = angularJson.projects[projectName]) === null || _a === void 0 ? void 0 : _a.architect) === null || _b === void 0 ? void 0 : _b.build) === null || _c === void 0 ? void 0 : _c.options) === null || _d === void 0 ? void 0 : _d.main;
        if (!mainPath) {
            throw new schematics_1.SchematicsException(`No main path specified in angular.json.`);
        }
        const appModulePath = ng_ast_utils_1.getAppModulePath(tree, mainPath);
        return (yield isStorefinderPresent(tree, packageJson, appModulePath))
            ? schematics_1.chain([
                removeOldSetup(appModulePath),
                addStorefinderPackageJsonDependencies(packageJson),
                // TODO: Re-enable once we have migration to new app structure
                // newStructureMigration(),
                // addStorefinderFeature(),
                index_1.installPackageJsonDependencies(),
            ])
            : schematics_1.noop();
    });
}
exports.migrate = migrate;
function isStorefinderPresent(tree, packageJson, appModulePath) {
    return __awaiter(this, void 0, void 0, function* () {
        workspace_utils_1.validateSpartacusInstallation(packageJson);
        const appModuleSource = index_1.getTsSourceFile(tree, appModulePath);
        return (ast_utils_1.isImported(appModuleSource, index_1.STOREFINDER_MODULE, index_1.SPARTACUS_STOREFRONTLIB) ||
            ast_utils_1.isImported(appModuleSource, index_1.STOREFRONT_MODULE, index_1.SPARTACUS_STOREFRONTLIB));
    });
}
function removeOldSetup(appModulePath) {
    return (tree, _context) => {
        const appModuleSource = index_1.getTsSourceFile(tree, appModulePath);
        const changes = [];
        if (ast_utils_1.isImported(appModuleSource, index_1.STOREFINDER_MODULE, index_1.SPARTACUS_STOREFRONTLIB)) {
            const importRemovalChanges = index_1.removeImport(appModuleSource, {
                className: index_1.STOREFINDER_MODULE,
                importPath: index_1.SPARTACUS_STOREFRONTLIB,
            });
            changes.push(importRemovalChanges);
            const node = ast_utils_1.getDecoratorMetadata(appModuleSource, 'NgModule', index_1.ANGULAR_CORE)[0];
            const assignment = ast_utils_1.getMetadataField(node, 'imports')[0];
            const arrLiteral = assignment.initializer;
            if (arrLiteral.elements.length !== 0) {
                arrLiteral.elements.every((el) => {
                    if (el.getText() === index_1.STOREFINDER_MODULE) {
                        const removeFromModulesArrayChange = new change_1.RemoveChange(appModulePath, el.getStart(), `${index_1.STOREFINDER_MODULE},`);
                        changes.push(removeFromModulesArrayChange);
                        return false;
                    }
                    return el;
                });
            }
        }
        index_1.commitChanges(tree, appModulePath, changes);
    };
}
function addStorefinderPackageJsonDependencies(packageJson) {
    const spartacusVersion = `^${index_1.getSpartacusSchematicsVersion()}`;
    const dependencies = [
        {
            type: dependencies_1.NodeDependencyType.Default,
            version: spartacusVersion,
            name: index_1.SPARTACUS_STOREFINDER,
        },
    ];
    return index_1.addPackageJsonDependencies(dependencies, packageJson);
}
// function addStorefinderFeature(): Rule {
//   return addLibraryFeature(
//     { lazy: false, project: '', features: [CLI_STOREFINDER_FEATURE] },
//     {
//       name: STOREFINDER_FEATURE_NAME,
//       featureModule: {
//         name: STOREFINDER_MODULE,
//         importPath: SPARTACUS_STOREFINDER,
//       },
//       rootModule: {
//         name: STOREFINDER_ROOT_MODULE,
//         importPath: SPARTACUS_STOREFINDER_ROOT,
//       },
//       i18n: {
//         resources: STOREFINDER_TRANSLATIONS,
//         chunks: STOREFINDER_TRANSLATION_CHUNKS_CONFIG,
//         importPath: SPARTACUS_STOREFINDER_ASSETS,
//       },
//       styles: {
//         scssFileName: STORE_FINDER_SCSS_FILE_NAME,
//         importStyle: SPARTACUS_STOREFINDER,
//       },
//     }
//   );
// }
//# sourceMappingURL=storefinder.js.map