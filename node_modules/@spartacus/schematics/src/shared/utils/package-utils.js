"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.prepare3rdPartyDependencies = exports.prepareSpartacusDependencies = exports.checkIfSSRIsUsed = exports.getSpartacusCurrentFeatureLevel = exports.getPrefixedSpartacusSchematicsVersion = exports.getSpartacusSchematicsVersion = exports.getMajorVersionNumber = exports.cleanSemverVersion = exports.readPackageJson = exports.mapPackageToNodeDependencies = exports.createDependencies = exports.createSpartacusDependencies = exports.FEATURES_LIBS_SKIP_SCOPES = exports.CORE_SPARTACUS_SCOPES = void 0;
const schematics_1 = require("@angular-devkit/schematics");
const dependencies_1 = require("@schematics/angular/utility/dependencies");
const package_json_1 = require("../../../package.json");
const dependencies_json_1 = __importDefault(require("../../dependencies.json"));
const constants_1 = require("../constants");
const file_utils_1 = require("./file-utils");
const workspace_utils_1 = require("./workspace-utils");
exports.CORE_SPARTACUS_SCOPES = [
    constants_1.SPARTACUS_CORE,
    constants_1.SPARTACUS_ASSETS,
    constants_1.SPARTACUS_SCHEMATICS,
    constants_1.SPARTACUS_STOREFRONTLIB,
    constants_1.SPARTACUS_STYLES,
    constants_1.SPARTACUS_SETUP,
];
exports.FEATURES_LIBS_SKIP_SCOPES = [constants_1.SPARTACUS_SCOPE];
function createSpartacusDependencies(dependencyObject) {
    const spartacusVersion = getPrefixedSpartacusSchematicsVersion();
    return createDependencies(dependencyObject, {
        skipScopes: exports.CORE_SPARTACUS_SCOPES,
        onlyIncludeScopes: exports.FEATURES_LIBS_SKIP_SCOPES,
        version: spartacusVersion,
    });
}
exports.createSpartacusDependencies = createSpartacusDependencies;
function createDependencies(dependencyObject, options = {
    skipScopes: exports.FEATURES_LIBS_SKIP_SCOPES,
}) {
    var _a;
    const dependencies = [];
    for (const dependencyName in dependencyObject) {
        if (!dependencyObject.hasOwnProperty(dependencyName)) {
            continue;
        }
        if (options.skipScopes.some((scope) => dependencyName.startsWith(scope))) {
            continue;
        }
        if (
        // if `onlyIncludeScopes` is not defined, always include the dependency
        !options.onlyIncludeScopes ||
            // if defined, check if the current dependency is in the given array
            options.onlyIncludeScopes.some((scope) => dependencyName.startsWith(scope))) {
            dependencies.push(mapPackageToNodeDependencies(dependencyName, (_a = options.version) !== null && _a !== void 0 ? _a : dependencyObject[dependencyName], options.overwrite));
        }
    }
    return dependencies;
}
exports.createDependencies = createDependencies;
function mapPackageToNodeDependencies(packageName, version, overwrite = false) {
    return {
        type: packageName.includes('schematics')
            ? dependencies_1.NodeDependencyType.Dev
            : dependencies_1.NodeDependencyType.Default,
        name: packageName,
        version,
        overwrite,
    };
}
exports.mapPackageToNodeDependencies = mapPackageToNodeDependencies;
function readPackageJson(tree) {
    const pkgPath = '/package.json';
    const buffer = tree.read(pkgPath);
    if (!buffer) {
        throw new schematics_1.SchematicsException('Could not find package.json');
    }
    return JSON.parse(buffer.toString(constants_1.UTF_8));
}
exports.readPackageJson = readPackageJson;
function cleanSemverVersion(versionString) {
    if (isNaN(Number(versionString.charAt(0)))) {
        return versionString.substr(1, versionString.length - 1);
    }
    return versionString;
}
exports.cleanSemverVersion = cleanSemverVersion;
function getMajorVersionNumber(versionString) {
    const cleanVersion = cleanSemverVersion(versionString);
    return Number(cleanVersion.charAt(0));
}
exports.getMajorVersionNumber = getMajorVersionNumber;
function getSpartacusSchematicsVersion() {
    return package_json_1.version;
}
exports.getSpartacusSchematicsVersion = getSpartacusSchematicsVersion;
function getPrefixedSpartacusSchematicsVersion() {
    return `~${getSpartacusSchematicsVersion()}`;
}
exports.getPrefixedSpartacusSchematicsVersion = getPrefixedSpartacusSchematicsVersion;
function getSpartacusCurrentFeatureLevel() {
    return package_json_1.version.split('.').slice(0, 2).join('.');
}
exports.getSpartacusCurrentFeatureLevel = getSpartacusCurrentFeatureLevel;
function checkIfSSRIsUsed(tree) {
    const projectName = workspace_utils_1.getDefaultProjectNameFromWorkspace(tree);
    const buffer = tree.read('angular.json');
    if (!buffer) {
        throw new schematics_1.SchematicsException('Could not find angular.json');
    }
    const angularFileBuffer = buffer.toString(constants_1.UTF_8);
    const angularJson = JSON.parse(angularFileBuffer);
    const isServerConfiguration = !!angularJson.projects[projectName].architect['server'];
    const serverFileLocation = file_utils_1.getServerTsPath(tree);
    if (!serverFileLocation) {
        return false;
    }
    const serverBuffer = tree.read(serverFileLocation);
    const serverFileBuffer = serverBuffer === null || serverBuffer === void 0 ? void 0 : serverBuffer.toString(constants_1.UTF_8);
    const isServerSideAvailable = serverFileBuffer && !!serverFileBuffer.length;
    return !!(isServerConfiguration && isServerSideAvailable);
}
exports.checkIfSSRIsUsed = checkIfSSRIsUsed;
function prepareSpartacusDependencies() {
    const spartacusVersion = getPrefixedSpartacusSchematicsVersion();
    const spartacusDependencies = [
        {
            type: dependencies_1.NodeDependencyType.Default,
            version: spartacusVersion,
            name: constants_1.SPARTACUS_CORE,
        },
        {
            type: dependencies_1.NodeDependencyType.Default,
            version: spartacusVersion,
            name: constants_1.SPARTACUS_STOREFRONTLIB,
        },
        {
            type: dependencies_1.NodeDependencyType.Default,
            version: spartacusVersion,
            name: constants_1.SPARTACUS_ASSETS,
        },
        {
            type: dependencies_1.NodeDependencyType.Default,
            version: spartacusVersion,
            name: constants_1.SPARTACUS_STYLES,
        },
    ];
    return spartacusDependencies;
}
exports.prepareSpartacusDependencies = prepareSpartacusDependencies;
function prepare3rdPartyDependencies() {
    const thirdPartyDependencies = createDependencies(Object.assign(Object.assign(Object.assign(Object.assign({}, dependencies_json_1.default[constants_1.SPARTACUS_CORE]), dependencies_json_1.default[constants_1.SPARTACUS_STOREFRONTLIB]), dependencies_json_1.default[constants_1.SPARTACUS_STYLES]), dependencies_json_1.default[constants_1.SPARTACUS_ASSETS]));
    return thirdPartyDependencies;
}
exports.prepare3rdPartyDependencies = prepare3rdPartyDependencies;
//# sourceMappingURL=package-utils.js.map