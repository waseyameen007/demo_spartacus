"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getParams = exports.getSuperNode = exports.getConstructor = exports.runMigration = exports.writeFile = void 0;
const core_1 = require("@angular-devkit/core");
const ast_utils_1 = require("@schematics/angular/utility/ast-utils");
const typescript_1 = __importDefault(require("typescript"));
const file_utils_1 = require("./file-utils");
function writeFile(host, filePath, contents) {
    host.sync.write(core_1.normalize(filePath), core_1.virtualFs.stringToFileBuffer(contents));
}
exports.writeFile = writeFile;
function runMigration(appTree, schematicRunner, migrationScript, options = {}) {
    return schematicRunner
        .runSchematicAsync(migrationScript, options, appTree)
        .toPromise();
}
exports.runMigration = runMigration;
function getConstructor(nodes) {
    const constructorNode = file_utils_1.findConstructor(nodes);
    if (!constructorNode) {
        throw new Error('No constructor node found');
    }
    return constructorNode;
}
exports.getConstructor = getConstructor;
function getSuperNode(constructorNode) {
    const superNodes = ast_utils_1.findNodes(constructorNode, typescript_1.default.SyntaxKind.SuperKeyword);
    if (!superNodes || superNodes.length === 0) {
        return undefined;
    }
    return superNodes[0];
}
exports.getSuperNode = getSuperNode;
function getParams(constructorNode, camelizedParamNames) {
    const superNode = getSuperNode(constructorNode);
    if (!superNode) {
        throw new Error('No super() node found');
    }
    const callExpressions = ast_utils_1.findNodes(constructorNode, typescript_1.default.SyntaxKind.CallExpression);
    if (!callExpressions || callExpressions.length === 0) {
        throw new Error('No call expressions found in constructor');
    }
    const params = ast_utils_1.findNodes(callExpressions[0], typescript_1.default.SyntaxKind.Identifier);
    camelizedParamNames = camelizedParamNames.map((param) => core_1.strings.camelize(param));
    return params
        .filter((n) => n.kind === typescript_1.default.SyntaxKind.Identifier)
        .map((n) => n.getText())
        .filter((text) => camelizedParamNames.includes(text));
}
exports.getParams = getParams;
//# sourceMappingURL=test-utils.js.map