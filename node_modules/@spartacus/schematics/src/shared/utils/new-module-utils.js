"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getModule = exports.addModuleProvider = exports.addModuleDeclaration = exports.addModuleExport = exports.addModuleImport = exports.ensureModuleExists = void 0;
const strings_1 = require("@angular-devkit/core/src/utils/strings");
const schematics_1 = require("@angular-devkit/schematics");
const ast_utils_1 = require("@schematics/angular/utility/ast-utils");
const ts_morph_1 = require("ts-morph");
const constants_1 = require("../constants");
const config_utils_1 = require("./config-utils");
const file_utils_1 = require("./file-utils");
const import_utils_1 = require("./import-utils");
const workspace_utils_1 = require("./workspace-utils");
function ensureModuleExists(options) {
    return (host) => {
        const modulePath = `${workspace_utils_1.getSourceRoot(host, { project: options.project })}/${options.path}`;
        const filePath = `${modulePath}/${strings_1.dasherize(options.name)}.module.ts`;
        if (host.exists(filePath)) {
            const module = file_utils_1.getTsSourceFile(host, filePath);
            const metadata = ast_utils_1.getDecoratorMetadata(module, 'NgModule', constants_1.ANGULAR_CORE)[0];
            if (metadata) {
                return schematics_1.noop();
            }
        }
        return schematics_1.externalSchematic(constants_1.ANGULAR_SCHEMATICS, 'module', {
            name: strings_1.dasherize(options.name),
            flat: true,
            commonModule: false,
            path: modulePath,
            module: options.module,
        });
    };
}
exports.ensureModuleExists = ensureModuleExists;
function addModuleImport(sourceFile, insertOptions, createIfMissing = true) {
    return addToModuleInternal(sourceFile, 'imports', insertOptions, createIfMissing);
}
exports.addModuleImport = addModuleImport;
function addModuleExport(sourceFile, insertOptions, createIfMissing = true) {
    return addToModuleInternal(sourceFile, 'exports', insertOptions, createIfMissing);
}
exports.addModuleExport = addModuleExport;
function addModuleDeclaration(sourceFile, insertOptions, createIfMissing = true) {
    return addToModuleInternal(sourceFile, 'declarations', insertOptions, createIfMissing);
}
exports.addModuleDeclaration = addModuleDeclaration;
function addModuleProvider(sourceFile, insertOptions, createIfMissing = true) {
    return addToModuleInternal(sourceFile, 'providers', insertOptions, createIfMissing);
}
exports.addModuleProvider = addModuleProvider;
function addToModuleInternal(sourceFile, propertyName, insertOptions, createIfMissing = true) {
    let createdNode;
    const module = getModule(sourceFile);
    if (module) {
        const args = module.getArguments();
        if (args.length > 0) {
            const arg = args[0];
            if (ts_morph_1.Node.isObjectLiteralExpression(arg)) {
                if (!arg.getProperty(propertyName) && createIfMissing) {
                    arg.addPropertyAssignment({
                        name: propertyName,
                        initializer: '[]',
                    });
                }
                const property = arg.getProperty(propertyName);
                if (property && ts_morph_1.Node.isPropertyAssignment(property)) {
                    const initializer = property.getInitializerIfKind(ts_morph_1.ts.SyntaxKind.ArrayLiteralExpression);
                    if (!initializer) {
                        return;
                    }
                    if (isDuplication(initializer, propertyName, insertOptions.content)) {
                        return;
                    }
                    const imports = [].concat(insertOptions.import);
                    imports.forEach((specifiedImport) => sourceFile.addImportDeclaration({
                        moduleSpecifier: specifiedImport.moduleSpecifier,
                        namedImports: specifiedImport.namedImports,
                    }));
                    if (insertOptions.order || insertOptions.order === 0) {
                        initializer.insertElement(insertOptions.order, insertOptions.content);
                    }
                    else {
                        createdNode = initializer.addElement(insertOptions.content);
                    }
                }
            }
        }
    }
    return createdNode;
}
function isDuplication(initializer, propertyName, content) {
    if (propertyName === 'providers') {
        const normalizedContent = config_utils_1.normalizeConfiguration(content);
        const configs = config_utils_1.getSpartacusProviders(initializer.getSourceFile());
        for (const config of configs) {
            const normalizedConfig = config_utils_1.normalizeConfiguration(config);
            if (normalizedContent === normalizedConfig) {
                return true;
            }
        }
        return false;
    }
    return isTypeTokenDuplicate(initializer, content);
}
function isTypeTokenDuplicate(initializer, typeToken) {
    typeToken = normalizeTypeToken(typeToken);
    for (const element of initializer.getElements()) {
        const elementText = normalizeTypeToken(element.getText());
        if (elementText === typeToken) {
            return true;
        }
    }
    return false;
}
function getModule(sourceFile) {
    let moduleNode;
    function visitor(node) {
        if (ts_morph_1.Node.isCallExpression(node)) {
            const expression = node.getExpression();
            if (ts_morph_1.Node.isIdentifier(expression) &&
                expression.getText() === 'NgModule' &&
                import_utils_1.isImportedFrom(expression, constants_1.ANGULAR_CORE)) {
                moduleNode = node;
            }
        }
        node.forEachChild(visitor);
    }
    sourceFile.forEachChild(visitor);
    return moduleNode;
}
exports.getModule = getModule;
const COMMENT_REG_EXP = /\/\/.+/gm;
function normalizeTypeToken(token) {
    let newToken = token;
    newToken = newToken.replace(COMMENT_REG_EXP, '');
    newToken = newToken.trim();
    // strip down the trailing comma
    if (newToken.charAt(newToken.length - 1) === ',') {
        newToken = newToken.substring(0, newToken.length - 1);
    }
    return newToken;
}
//# sourceMappingURL=new-module-utils.js.map