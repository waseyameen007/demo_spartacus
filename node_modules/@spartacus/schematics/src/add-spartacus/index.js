"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addSpartacus = void 0;
const schematics_1 = require("@angular-devkit/schematics");
const constants_1 = require("../shared/constants");
const file_utils_1 = require("../shared/utils/file-utils");
const html_utils_1 = require("../shared/utils/html-utils");
const lib_utils_1 = require("../shared/utils/lib-utils");
const new_module_utils_1 = require("../shared/utils/new-module-utils");
const package_utils_1 = require("../shared/utils/package-utils");
const program_1 = require("../shared/utils/program");
const project_tsconfig_paths_1 = require("../shared/utils/project-tsconfig-paths");
const workspace_utils_1 = require("../shared/utils/workspace-utils");
const configuration_1 = require("./configuration");
const spartacus_1 = require("./spartacus");
const spartacus_features_1 = require("./spartacus-features");
const store_1 = require("./store");
function installStyles(options) {
    return (tree, context) => {
        var _a, _b, _c, _d, _e;
        const project = workspace_utils_1.getProjectFromWorkspace(tree, options);
        const rootStyles = (_d = (_c = (_b = (_a = workspace_utils_1.getProjectTargets(project)) === null || _a === void 0 ? void 0 : _a.build) === null || _b === void 0 ? void 0 : _b.options) === null || _c === void 0 ? void 0 : _c.styles) === null || _d === void 0 ? void 0 : _d[0];
        const styleFilePath = typeof rootStyles === 'object'
            ? (_e = rootStyles) === null || _e === void 0 ? void 0 : _e.input
            : rootStyles;
        if (!styleFilePath) {
            context.logger.warn(`Could not find the default style file for this project.`);
            context.logger.warn(`Please consider manually setting up spartacus styles`);
            return;
        }
        if (styleFilePath.split('.').pop() !== 'scss') {
            context.logger.warn(`Could not find the default SCSS style file for this project. `);
            context.logger.warn(`Please make sure your project is configured with SCSS and consider manually setting up spartacus styles.`);
            return;
        }
        const buffer = tree.read(styleFilePath);
        if (!buffer) {
            context.logger.warn(`Could not read the default style file within the project ${styleFilePath}`);
            context.logger.warn(`Please consider manually importing spartacus styles.`);
            return;
        }
        const htmlContent = buffer.toString();
        let insertion = '\n' +
            `$styleVersion: ${options.featureLevel || package_utils_1.getSpartacusCurrentFeatureLevel()};\n@import '~@spartacus/styles/index';\n`;
        if (options === null || options === void 0 ? void 0 : options.theme) {
            insertion += `\n@import '~@spartacus/styles/scss/theme/${options.theme}';\n`;
        }
        if (htmlContent.includes(insertion)) {
            return;
        }
        const recorder = tree.beginUpdate(styleFilePath);
        recorder.insertLeft(htmlContent.length, insertion);
        tree.commitUpdate(recorder);
    };
}
function updateMainComponent(project, options) {
    return (host, context) => {
        const filePath = project.sourceRoot + '/app/app.component.html';
        const buffer = host.read(filePath);
        if (!buffer) {
            context.logger.warn(`Could not read app.component.html file.`);
            return;
        }
        const htmlContent = buffer.toString();
        const insertion = `<cx-storefront></cx-storefront>\n`;
        if (htmlContent.includes(insertion)) {
            return;
        }
        const recorder = host.beginUpdate(filePath);
        if (options && options.overwriteAppComponent) {
            recorder.remove(0, htmlContent.length);
            recorder.insertLeft(0, insertion);
        }
        else {
            recorder.insertLeft(htmlContent.length, `\n${insertion}`);
        }
        host.commitUpdate(recorder);
        return host;
    };
}
function updateIndexFile(tree, options) {
    return (host) => {
        const projectIndexHtmlPath = file_utils_1.getIndexHtmlPath(tree);
        const baseUrl = options.baseUrl || 'OCC_BACKEND_BASE_URL_VALUE';
        const metaTags = [
            `<meta name="occ-backend-base-url" content="${baseUrl}" />`,
            `<meta name="media-backend-base-url" content="MEDIA_BACKEND_BASE_URL_VALUE" />`,
        ];
        metaTags.forEach((metaTag) => {
            html_utils_1.appendHtmlElementToHead(host, projectIndexHtmlPath, metaTag);
        });
        return host;
    };
}
function increaseBudgets() {
    return (tree) => {
        var _a;
        const { path, workspace: angularJson } = workspace_utils_1.getWorkspace(tree);
        const projectName = workspace_utils_1.getDefaultProjectNameFromWorkspace(tree);
        const project = angularJson.projects[projectName];
        const architect = project.architect;
        const build = architect === null || architect === void 0 ? void 0 : architect.build;
        const configurations = build === null || build === void 0 ? void 0 : build.configurations;
        const productionConfiguration = configurations === null || configurations === void 0 ? void 0 : configurations.production;
        const productionBudgets = ((_a = productionConfiguration.budgets) !== null && _a !== void 0 ? _a : []).map((budget) => {
            if (budget.type === 'initial') {
                return Object.assign(Object.assign({}, budget), { maximumError: '2.5mb' });
            }
            return budget;
        });
        const updatedAngularJson = Object.assign(Object.assign({}, angularJson), { projects: Object.assign(Object.assign({}, angularJson.projects), { [projectName]: Object.assign(Object.assign({}, project), { architect: Object.assign(Object.assign({}, architect), { build: Object.assign(Object.assign({}, build), { configurations: Object.assign(Object.assign({}, configurations), { production: Object.assign(Object.assign({}, productionConfiguration), { budgets: productionBudgets }) }) }) }) }) }) });
        tree.overwrite(path, JSON.stringify(updatedAngularJson, null, 2));
        return tree;
    };
}
function prepareDependencies() {
    const spartacusDependencies = package_utils_1.prepareSpartacusDependencies();
    return spartacusDependencies.concat(package_utils_1.prepare3rdPartyDependencies());
}
function updateAppModule(project) {
    return (tree) => {
        const { buildPaths } = project_tsconfig_paths_1.getProjectTsConfigPaths(tree, project);
        if (!buildPaths.length) {
            throw new schematics_1.SchematicsException('Could not find any tsconfig file. Cannot configure AppModule.');
        }
        const basePath = process.cwd();
        for (const tsconfigPath of buildPaths) {
            const { appSourceFiles } = program_1.createProgram(tree, basePath, tsconfigPath);
            for (const sourceFile of appSourceFiles) {
                if (sourceFile.getFilePath().includes(`app.module.ts`)) {
                    new_module_utils_1.addModuleImport(sourceFile, {
                        order: 1,
                        import: {
                            moduleSpecifier: constants_1.ANGULAR_HTTP,
                            namedImports: ['HttpClientModule'],
                        },
                        content: 'HttpClientModule',
                    });
                    new_module_utils_1.addModuleImport(sourceFile, {
                        order: 2,
                        import: {
                            moduleSpecifier: constants_1.SPARTACUS_STOREFRONTLIB,
                            namedImports: ['AppRoutingModule'],
                        },
                        content: 'AppRoutingModule',
                    });
                    program_1.saveAndFormat(sourceFile);
                    break;
                }
            }
        }
        return tree;
    };
}
function addSpartacusFeatures(options) {
    return (tree, context) => {
        var _a;
        const cliFeatures = lib_utils_1.prepareCliPackageAndSubFeature((_a = options.features) !== null && _a !== void 0 ? _a : []);
        const libraryOptions = {
            project: options.project,
            lazy: options.lazy,
        };
        const featureOptions = lib_utils_1.createSpartacusFeatureOptionsForLibrary(libraryOptions, cliFeatures);
        lib_utils_1.addSchematicsTasks(featureOptions, context);
        const packageJson = package_utils_1.readPackageJson(tree);
        const spartacusVersion = package_utils_1.getPrefixedSpartacusSchematicsVersion();
        const dependencies = Object.keys(cliFeatures).map((feature) => package_utils_1.mapPackageToNodeDependencies(feature, spartacusVersion));
        return lib_utils_1.addPackageJsonDependencies(dependencies, packageJson)(tree, context);
    };
}
function addSpartacus(options) {
    return (tree, context) => {
        const project = workspace_utils_1.getProjectFromWorkspace(tree, options);
        return schematics_1.chain([
            lib_utils_1.addPackageJsonDependencies(prepareDependencies(), package_utils_1.readPackageJson(tree)),
            store_1.setupStoreModules(options.project),
            workspace_utils_1.scaffoldStructure(options),
            spartacus_1.setupSpartacusModule(options.project),
            spartacus_features_1.setupSpartacusFeaturesModule(options.project),
            configuration_1.addSpartacusConfiguration(options),
            updateAppModule(options.project),
            installStyles(options),
            updateMainComponent(project, options),
            options.useMetaTags ? updateIndexFile(tree, options) : schematics_1.noop(),
            increaseBudgets(),
            addSpartacusFeatures(options),
        ])(tree, context);
    };
}
exports.addSpartacus = addSpartacus;
//# sourceMappingURL=index.js.map