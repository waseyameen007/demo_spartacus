import { Component } from '@angular/core';
import * as i0 from "@angular/core";
import * as i1 from "@spartacus/storefinder/core";
import * as i2 from "@spartacus/storefront";
import * as i3 from "@angular/common";
import * as i4 from "@angular/router";
import * as i5 from "@spartacus/core";
export class StoreFinderStoresCountComponent {
    constructor(storeFinderService) {
        this.storeFinderService = storeFinderService;
    }
    ngOnInit() {
        this.storeFinderService.viewAllStores();
        this.locations$ = this.storeFinderService.getViewAllStoresEntities();
        this.isLoading$ = this.storeFinderService.getViewAllStoresLoading();
    }
}
StoreFinderStoresCountComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: StoreFinderStoresCountComponent, deps: [{ token: i1.StoreFinderService }], target: i0.ɵɵFactoryTarget.Component });
StoreFinderStoresCountComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: StoreFinderStoresCountComponent, selector: "cx-store-finder-stores-count", ngImport: i0, template: "<ng-container\n  *ngIf=\"\n    !(isLoading$ | async) && (locations$ | async) as locations;\n    else loading\n  \"\n>\n  <div class=\"cx-count container\">\n    <div class=\"row\" *ngIf=\"locations?.length\">\n      <div\n        *ngFor=\"let country of locations\"\n        class=\"cx-set col-sm-6 col-md-4 col-lg-4 col-xl-3\"\n      >\n        <a [routerLink]=\"['../country', country.isoCode]\" class=\"btn-link\">\n          <h2 class=\"cx-title\">\n            <span\n              [ngClass]=\"\n                country?.storeCountDataList\n                  ? 'country-header'\n                  : 'country-header-link'\n              \"\n              class=\"cx-name\"\n              >{{ country.name }}</span\n            >\n            <span\n              [ngClass]=\"\n                country?.storeCountDataList\n                  ? 'country-header'\n                  : 'country-header-link'\n              \"\n              *ngIf=\"!country?.storeCountDataList\"\n              class=\"cx-country-count\"\n              >({{ country.count }})</span\n            >\n          </h2>\n        </a>\n      </div>\n    </div>\n    <div class=\"row\" *ngIf=\"!locations?.length\">\n      <span class=\"cx-no-stores\" role=\"alert\">\n        {{ 'storeFinder.noStoresMessage' | cxTranslate }}\n      </span>\n    </div>\n  </div>\n</ng-container>\n<ng-template #loading>\n  <div class=\"cx-count-spinner\"><cx-spinner></cx-spinner></div>\n</ng-template>\n", components: [{ type: i2.SpinnerComponent, selector: "cx-spinner" }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i4.RouterLinkWithHref, selector: "a[routerLink],area[routerLink]", inputs: ["routerLink", "target", "queryParams", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange", "replaceUrl", "state", "relativeTo"] }, { type: i3.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }], pipes: { "async": i3.AsyncPipe, "cxTranslate": i5.TranslatePipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: StoreFinderStoresCountComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-store-finder-stores-count',
                    templateUrl: './store-finder-stores-count.component.html',
                }]
        }], ctorParameters: function () { return [{ type: i1.StoreFinderService }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RvcmUtZmluZGVyLXN0b3Jlcy1jb3VudC5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9mZWF0dXJlLWxpYnMvc3RvcmVmaW5kZXIvY29tcG9uZW50cy9zdG9yZS1maW5kZXItc3RvcmVzLWNvdW50L3N0b3JlLWZpbmRlci1zdG9yZXMtY291bnQuY29tcG9uZW50LnRzIiwiLi4vLi4vLi4vLi4vLi4vZmVhdHVyZS1saWJzL3N0b3JlZmluZGVyL2NvbXBvbmVudHMvc3RvcmUtZmluZGVyLXN0b3Jlcy1jb3VudC9zdG9yZS1maW5kZXItc3RvcmVzLWNvdW50LmNvbXBvbmVudC5odG1sIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQVUsTUFBTSxlQUFlLENBQUM7Ozs7Ozs7QUFRbEQsTUFBTSxPQUFPLCtCQUErQjtJQUkxQyxZQUFvQixrQkFBc0M7UUFBdEMsdUJBQWtCLEdBQWxCLGtCQUFrQixDQUFvQjtJQUFHLENBQUM7SUFFOUQsUUFBUTtRQUNOLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxhQUFhLEVBQUUsQ0FBQztRQUN4QyxJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyx3QkFBd0IsRUFBRSxDQUFDO1FBQ3JFLElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDLGtCQUFrQixDQUFDLHVCQUF1QixFQUFFLENBQUM7SUFDdEUsQ0FBQzs7NEhBVlUsK0JBQStCO2dIQUEvQiwrQkFBK0Isb0VDUjVDLHk3Q0ErQ0E7MkZEdkNhLCtCQUErQjtrQkFKM0MsU0FBUzttQkFBQztvQkFDVCxRQUFRLEVBQUUsOEJBQThCO29CQUN4QyxXQUFXLEVBQUUsNENBQTRDO2lCQUMxRCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudCwgT25Jbml0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBTdG9yZUZpbmRlclNlcnZpY2UgfSBmcm9tICdAc3BhcnRhY3VzL3N0b3JlZmluZGVyL2NvcmUnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjeC1zdG9yZS1maW5kZXItc3RvcmVzLWNvdW50JyxcbiAgdGVtcGxhdGVVcmw6ICcuL3N0b3JlLWZpbmRlci1zdG9yZXMtY291bnQuY29tcG9uZW50Lmh0bWwnLFxufSlcbmV4cG9ydCBjbGFzcyBTdG9yZUZpbmRlclN0b3Jlc0NvdW50Q29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0IHtcbiAgbG9jYXRpb25zJDogT2JzZXJ2YWJsZTxhbnk+O1xuICBpc0xvYWRpbmckOiBPYnNlcnZhYmxlPGJvb2xlYW4+O1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgc3RvcmVGaW5kZXJTZXJ2aWNlOiBTdG9yZUZpbmRlclNlcnZpY2UpIHt9XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgdGhpcy5zdG9yZUZpbmRlclNlcnZpY2Uudmlld0FsbFN0b3JlcygpO1xuICAgIHRoaXMubG9jYXRpb25zJCA9IHRoaXMuc3RvcmVGaW5kZXJTZXJ2aWNlLmdldFZpZXdBbGxTdG9yZXNFbnRpdGllcygpO1xuICAgIHRoaXMuaXNMb2FkaW5nJCA9IHRoaXMuc3RvcmVGaW5kZXJTZXJ2aWNlLmdldFZpZXdBbGxTdG9yZXNMb2FkaW5nKCk7XG4gIH1cbn1cbiIsIjxuZy1jb250YWluZXJcbiAgKm5nSWY9XCJcbiAgICAhKGlzTG9hZGluZyQgfCBhc3luYykgJiYgKGxvY2F0aW9ucyQgfCBhc3luYykgYXMgbG9jYXRpb25zO1xuICAgIGVsc2UgbG9hZGluZ1xuICBcIlxuPlxuICA8ZGl2IGNsYXNzPVwiY3gtY291bnQgY29udGFpbmVyXCI+XG4gICAgPGRpdiBjbGFzcz1cInJvd1wiICpuZ0lmPVwibG9jYXRpb25zPy5sZW5ndGhcIj5cbiAgICAgIDxkaXZcbiAgICAgICAgKm5nRm9yPVwibGV0IGNvdW50cnkgb2YgbG9jYXRpb25zXCJcbiAgICAgICAgY2xhc3M9XCJjeC1zZXQgY29sLXNtLTYgY29sLW1kLTQgY29sLWxnLTQgY29sLXhsLTNcIlxuICAgICAgPlxuICAgICAgICA8YSBbcm91dGVyTGlua109XCJbJy4uL2NvdW50cnknLCBjb3VudHJ5Lmlzb0NvZGVdXCIgY2xhc3M9XCJidG4tbGlua1wiPlxuICAgICAgICAgIDxoMiBjbGFzcz1cImN4LXRpdGxlXCI+XG4gICAgICAgICAgICA8c3BhblxuICAgICAgICAgICAgICBbbmdDbGFzc109XCJcbiAgICAgICAgICAgICAgICBjb3VudHJ5Py5zdG9yZUNvdW50RGF0YUxpc3RcbiAgICAgICAgICAgICAgICAgID8gJ2NvdW50cnktaGVhZGVyJ1xuICAgICAgICAgICAgICAgICAgOiAnY291bnRyeS1oZWFkZXItbGluaydcbiAgICAgICAgICAgICAgXCJcbiAgICAgICAgICAgICAgY2xhc3M9XCJjeC1uYW1lXCJcbiAgICAgICAgICAgICAgPnt7IGNvdW50cnkubmFtZSB9fTwvc3BhblxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgPHNwYW5cbiAgICAgICAgICAgICAgW25nQ2xhc3NdPVwiXG4gICAgICAgICAgICAgICAgY291bnRyeT8uc3RvcmVDb3VudERhdGFMaXN0XG4gICAgICAgICAgICAgICAgICA/ICdjb3VudHJ5LWhlYWRlcidcbiAgICAgICAgICAgICAgICAgIDogJ2NvdW50cnktaGVhZGVyLWxpbmsnXG4gICAgICAgICAgICAgIFwiXG4gICAgICAgICAgICAgICpuZ0lmPVwiIWNvdW50cnk/LnN0b3JlQ291bnREYXRhTGlzdFwiXG4gICAgICAgICAgICAgIGNsYXNzPVwiY3gtY291bnRyeS1jb3VudFwiXG4gICAgICAgICAgICAgID4oe3sgY291bnRyeS5jb3VudCB9fSk8L3NwYW5cbiAgICAgICAgICAgID5cbiAgICAgICAgICA8L2gyPlxuICAgICAgICA8L2E+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwicm93XCIgKm5nSWY9XCIhbG9jYXRpb25zPy5sZW5ndGhcIj5cbiAgICAgIDxzcGFuIGNsYXNzPVwiY3gtbm8tc3RvcmVzXCIgcm9sZT1cImFsZXJ0XCI+XG4gICAgICAgIHt7ICdzdG9yZUZpbmRlci5ub1N0b3Jlc01lc3NhZ2UnIHwgY3hUcmFuc2xhdGUgfX1cbiAgICAgIDwvc3Bhbj5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG48L25nLWNvbnRhaW5lcj5cbjxuZy10ZW1wbGF0ZSAjbG9hZGluZz5cbiAgPGRpdiBjbGFzcz1cImN4LWNvdW50LXNwaW5uZXJcIj48Y3gtc3Bpbm5lcj48L2N4LXNwaW5uZXI+PC9kaXY+XG48L25nLXRlbXBsYXRlPlxuIl19