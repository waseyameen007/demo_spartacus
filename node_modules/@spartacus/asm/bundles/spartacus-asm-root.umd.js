(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/common'), require('@angular/core'), require('@spartacus/storefront'), require('@spartacus/core'), require('rxjs/operators'), require('rxjs'), require('@ngrx/store')) :
    typeof define === 'function' && define.amd ? define('@spartacus/asm/root', ['exports', '@angular/common', '@angular/core', '@spartacus/storefront', '@spartacus/core', 'rxjs/operators', 'rxjs', '@ngrx/store'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.spartacus = global.spartacus || {}, global.spartacus.asm = global.spartacus.asm || {}, global.spartacus.asm.root = {}), global.ng.common, global.ng.core, global.storefront, global.core, global.rxjs.operators, global.rxjs, global.store));
}(this, (function (exports, i1, i0, i3, i1$1, operators, rxjs, i3$1) { 'use strict';

    function _interopNamespace(e) {
        if (e && e.__esModule) return e;
        var n = Object.create(null);
        if (e) {
            Object.keys(e).forEach(function (k) {
                if (k !== 'default') {
                    var d = Object.getOwnPropertyDescriptor(e, k);
                    Object.defineProperty(n, k, d.get ? d : {
                        enumerable: true,
                        get: function () {
                            return e[k];
                        }
                    });
                }
            });
        }
        n['default'] = e;
        return Object.freeze(n);
    }

    var i1__namespace = /*#__PURE__*/_interopNamespace(i1);
    var i0__namespace = /*#__PURE__*/_interopNamespace(i0);
    var i3__namespace = /*#__PURE__*/_interopNamespace(i3);
    var i1__namespace$1 = /*#__PURE__*/_interopNamespace(i1$1);
    var i3__namespace$1 = /*#__PURE__*/_interopNamespace(i3$1);

    var ASM_ENABLED_LOCAL_STORAGE_KEY = 'asm_enabled';

    /**
     * The AsmEnablerService is used to enable ASM for those scenario's
     * where it's actually used. This service is added to avoid any polution
     * of the UI and runtime performance for the ordinary production user.
     */
    var AsmEnablerService = /** @class */ (function () {
        function AsmEnablerService(location, winRef, launchDialogService, featureModules) {
            this.location = location;
            this.winRef = winRef;
            this.launchDialogService = launchDialogService;
            this.featureModules = featureModules;
        }
        /**
         * Loads the ASM UI if needed. The ASM UI will be added based on the
         * existence of a URL parameter or previous usage given by local storage.
         */
        AsmEnablerService.prototype.load = function () {
            if (this.isEnabled()) {
                this.addUi();
            }
        };
        /**
         * Indicates whether the ASM module is enabled.
         */
        AsmEnablerService.prototype.isEnabled = function () {
            if (this.isLaunched() && !this.isUsedBefore()) {
                if (this.winRef.localStorage) {
                    this.winRef.localStorage.setItem(ASM_ENABLED_LOCAL_STORAGE_KEY, 'true');
                }
            }
            return this.isLaunched() || this.isUsedBefore();
        };
        /**
         * Indicates whether ASM is launched through the URL,
         * using the asm flag in the URL.
         */
        AsmEnablerService.prototype.isLaunched = function () {
            var params = this.location.path().split('?')[1];
            return !!params && params.split('&').includes('asm=true');
        };
        /**
         * Evaluates local storage where we persist the usage of ASM.
         */
        AsmEnablerService.prototype.isUsedBefore = function () {
            if (this.winRef.localStorage) {
                return (this.winRef.localStorage.getItem(ASM_ENABLED_LOCAL_STORAGE_KEY) ===
                    'true');
            }
            else {
                return false;
            }
        };
        /**
         * Adds the ASM UI by using the `cx-storefront` outlet.
         */
        AsmEnablerService.prototype.addUi = function () {
            var _this = this;
            this.featureModules
                .resolveFeature('asm')
                .subscribe(function () { return _this.launchDialogService.launch("ASM" /* ASM */); });
        };
        return AsmEnablerService;
    }());
    AsmEnablerService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AsmEnablerService, deps: [{ token: i1__namespace.Location }, { token: i1__namespace$1.WindowRef }, { token: i3__namespace.LaunchDialogService }, { token: i1__namespace$1.FeatureModulesService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    AsmEnablerService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AsmEnablerService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AsmEnablerService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace.Location }, { type: i1__namespace$1.WindowRef }, { type: i3__namespace.LaunchDialogService }, { type: i1__namespace$1.FeatureModulesService }]; } });

    /**
     * The ASM loader module takes care of loading the ASM UI
     * only in case there's a reason to do so.
     */
    var AsmLoaderModule = /** @class */ (function () {
        function AsmLoaderModule() {
        }
        return AsmLoaderModule;
    }());
    AsmLoaderModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AsmLoaderModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    AsmLoaderModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AsmLoaderModule, imports: [i1.CommonModule, i3.PageComponentModule] });
    AsmLoaderModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AsmLoaderModule, providers: [
            {
                provide: i0.APP_INITIALIZER,
                useFactory: asmFactory,
                deps: [AsmEnablerService],
                multi: true,
            },
        ], imports: [[i1.CommonModule, i3.PageComponentModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AsmLoaderModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [i1.CommonModule, i3.PageComponentModule],
                        providers: [
                            {
                                provide: i0.APP_INITIALIZER,
                                useFactory: asmFactory,
                                deps: [AsmEnablerService],
                                multi: true,
                            },
                        ],
                    }]
            }] });
    /**
     *
     * We do not like to block the UI, which is why we delgate loading of ASM
     * to a real component; the router and state aren't available in an optimized
     * way during the APP_INITIALIZER.
     */
    function asmFactory(asmEnablerService) {
        var isReady = function () {
            asmEnablerService.load();
        };
        return isReady;
    }

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (Object.prototype.hasOwnProperty.call(b, p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
        var t = {};
        for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); };
    }
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
    }
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    var __createBinding = Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    });
    function __exportStar(m, o) {
        for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
                __createBinding(o, m, p);
    }
    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
            return m.call(o);
        if (o && typeof o.length === "number")
            return {
                next: function () {
                    if (o && i >= o.length)
                        o = void 0;
                    return { value: o && o[i++], done: !o };
                }
            };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    /** @deprecated */
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }
    /** @deprecated */
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    function __spreadArray(to, from, pack) {
        if (pack || arguments.length === 2)
            for (var i = 0, l = from.length, ar; i < l; i++) {
                if (ar || !(i in from)) {
                    if (!ar)
                        ar = Array.prototype.slice.call(from, 0, i);
                    ar[i] = from[i];
                }
            }
        return to.concat(ar || from);
    }
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n])
            i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try {
            step(g[n](v));
        }
        catch (e) {
            settle(q[0][3], e);
        } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]); }
    }
    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }
    function __asyncValues(o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    }
    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
        }
        else {
            cooked.raw = raw;
        }
        return cooked;
    }
    ;
    var __setModuleDefault = Object.create ? (function (o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function (o, v) {
        o["default"] = v;
    };
    function __importStar(mod) {
        if (mod && mod.__esModule)
            return mod;
        var result = {};
        if (mod != null)
            for (var k in mod)
                if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                    __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    }
    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }
    function __classPrivateFieldGet(receiver, state, kind, f) {
        if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    }
    function __classPrivateFieldSet(receiver, state, value, kind, f) {
        if (kind === "m")
            throw new TypeError("Private method is not writable");
        if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    }

    /**
     * Indicates if auth token is for regular user or CS Agent.
     */
    exports.TokenTarget = void 0;
    (function (TokenTarget) {
        TokenTarget["CSAgent"] = "CSAgent";
        TokenTarget["User"] = "User";
    })(exports.TokenTarget || (exports.TokenTarget = {}));
    /**
     * With AsmAuthStorageService apart from storing the token we also need to store
     * information for which user is the token (regular user or CS Agent).
     *
     * Overrides `AuthStorageService`.
     */
    var AsmAuthStorageService = /** @class */ (function (_super) {
        __extends(AsmAuthStorageService, _super);
        function AsmAuthStorageService() {
            var _this = _super.apply(this, __spreadArray([], __read(arguments))) || this;
            _this._tokenTarget$ = new rxjs.BehaviorSubject(exports.TokenTarget.User);
            return _this;
        }
        /**
         * Get target user for current auth token.
         *
         * @return observable with TokenTarget
         */
        AsmAuthStorageService.prototype.getTokenTarget = function () {
            return this._tokenTarget$;
        };
        /**
         * Set new token target.
         *
         * @param tokenTarget
         */
        AsmAuthStorageService.prototype.setTokenTarget = function (tokenTarget) {
            this._tokenTarget$.next(tokenTarget);
        };
        /**
         * Get token for previously user session, when it was interrupted by CS agent login.
         *
         * @return previously logged in user token.
         */
        AsmAuthStorageService.prototype.getEmulatedUserToken = function () {
            return this.emulatedUserToken;
        };
        /**
         * Save user token on CS agent login.
         *
         * @param token
         */
        AsmAuthStorageService.prototype.setEmulatedUserToken = function (token) {
            this.emulatedUserToken = token;
        };
        /**
         * Change token target to CS Agent.
         */
        AsmAuthStorageService.prototype.switchTokenTargetToCSAgent = function () {
            this._tokenTarget$.next(exports.TokenTarget.CSAgent);
        };
        /**
         * Change token target to user.
         */
        AsmAuthStorageService.prototype.switchTokenTargetToUser = function () {
            this._tokenTarget$.next(exports.TokenTarget.User);
        };
        /**
         * When we start emulation from the UI (not by ASM login) we can't restore user session on cs agent logout.
         * Only available solution is to drop session we could restore, to avoid account hijack.
         */
        AsmAuthStorageService.prototype.clearEmulatedUserToken = function () {
            this.emulatedUserToken = undefined;
        };
        return AsmAuthStorageService;
    }(i1$1.AuthStorageService));
    AsmAuthStorageService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AsmAuthStorageService, deps: null, target: i0__namespace.ɵɵFactoryTarget.Injectable });
    AsmAuthStorageService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AsmAuthStorageService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AsmAuthStorageService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }] });

    /**
     * Auth service for CS agent. Useful to login/logout agent, start emulation
     * or get information about the status of emulation.
     */
    var CsAgentAuthService = /** @class */ (function () {
        function CsAgentAuthService(authService, authStorageService, userIdService, oAuthLibWrapperService, store, userService) {
            this.authService = authService;
            this.authStorageService = authStorageService;
            this.userIdService = userIdService;
            this.oAuthLibWrapperService = oAuthLibWrapperService;
            this.store = store;
            this.userService = userService;
        }
        /**
         * Loads access token for a customer support agent.
         * @param userId
         * @param password
         */
        CsAgentAuthService.prototype.authorizeCustomerSupportAgent = function (userId, password) {
            return __awaiter(this, void 0, void 0, function () {
                var userToken, customerId_1, _a_1;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            this.authStorageService
                                .getToken()
                                .subscribe(function (token) { return (userToken = token); })
                                .unsubscribe();
                            this.authStorageService.switchTokenTargetToCSAgent();
                            _b.label = 1;
                        case 1:
                            _b.trys.push([1, 3, , 4]);
                            return [4 /*yield*/, this.oAuthLibWrapperService.authorizeWithPasswordFlow(userId, password)];
                        case 2:
                            _b.sent();
                            this.userService
                                .get()
                                .subscribe(function (user) { return (customerId_1 = user === null || user === void 0 ? void 0 : user.customerId); })
                                .unsubscribe();
                            this.store.dispatch(new i1$1.AuthActions.Logout());
                            if (customerId_1 !== undefined && userToken !== undefined) {
                                // OCC specific user id handling. Customize when implementing different backend
                                this.userIdService.setUserId(customerId_1);
                                this.authStorageService.setEmulatedUserToken(userToken);
                                this.store.dispatch(new i1$1.AuthActions.Login());
                            }
                            else {
                                // When we can't get the customerId just end all current sessions
                                this.userIdService.setUserId(i1$1.OCC_USER_ID_ANONYMOUS);
                                this.authStorageService.clearEmulatedUserToken();
                            }
                            return [3 /*break*/, 4];
                        case 3:
                            _a_1 = _b.sent();
                            this.authStorageService.switchTokenTargetToUser();
                            return [3 /*break*/, 4];
                        case 4: return [2 /*return*/];
                    }
                });
            });
        };
        /**
         * Starts an ASM customer emulation session.
         * A customer emulation session is stopped by calling logout().
         * @param customerId
         */
        CsAgentAuthService.prototype.startCustomerEmulationSession = function (customerId) {
            this.authStorageService.clearEmulatedUserToken();
            // OCC specific user id handling. Customize when implementing different backend
            this.store.dispatch(new i1$1.AuthActions.Logout());
            this.userIdService.setUserId(customerId);
            this.store.dispatch(new i1$1.AuthActions.Login());
        };
        /**
         * Check if CS agent is currently logged in.
         *
         * @returns observable emitting true when CS agent is logged in or false when not.
         */
        CsAgentAuthService.prototype.isCustomerSupportAgentLoggedIn = function () {
            return rxjs.combineLatest([
                this.authStorageService.getToken(),
                this.authStorageService.getTokenTarget(),
            ]).pipe(operators.map(function (_b) {
                var _c = __read(_b, 2), token = _c[0], tokenTarget = _c[1];
                return Boolean((token === null || token === void 0 ? void 0 : token.access_token) && tokenTarget === exports.TokenTarget.CSAgent);
            }));
        };
        /**
         * Utility function to determine if customer is emulated.
         *
         * @returns observable emitting true when there is active emulation session or false when not.
         */
        CsAgentAuthService.prototype.isCustomerEmulated = function () {
            return this.userIdService.isEmulated();
        };
        /**
         * Returns the customer support agent's token loading status
         */
        CsAgentAuthService.prototype.getCustomerSupportAgentTokenLoading = function () {
            // TODO(#8248): Create new loading state outside of store
            return rxjs.of(false);
        };
        /**
         * Logout a customer support agent.
         */
        CsAgentAuthService.prototype.logoutCustomerSupportAgent = function () {
            return __awaiter(this, void 0, void 0, function () {
                var emulatedToken, isCustomerEmulated;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            emulatedToken = this.authStorageService.getEmulatedUserToken();
                            this.userIdService
                                .isEmulated()
                                .subscribe(function (emulated) { return (isCustomerEmulated = emulated); })
                                .unsubscribe();
                            return [4 /*yield*/, this.oAuthLibWrapperService.revokeAndLogout()];
                        case 1:
                            _b.sent();
                            this.store.dispatch({ type: '[Auth] Logout Customer Support Agent' });
                            this.authStorageService.setTokenTarget(exports.TokenTarget.User);
                            if (isCustomerEmulated && emulatedToken) {
                                this.store.dispatch(new i1$1.AuthActions.Logout());
                                this.authStorageService.setToken(emulatedToken);
                                this.userIdService.setUserId(i1$1.OCC_USER_ID_CURRENT);
                                this.authStorageService.clearEmulatedUserToken();
                                this.store.dispatch(new i1$1.AuthActions.Login());
                            }
                            else {
                                this.authService.logout();
                            }
                            return [2 /*return*/];
                    }
                });
            });
        };
        return CsAgentAuthService;
    }());
    CsAgentAuthService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CsAgentAuthService, deps: [{ token: i1__namespace$1.AuthService }, { token: AsmAuthStorageService }, { token: i1__namespace$1.UserIdService }, { token: i1__namespace$1.OAuthLibWrapperService }, { token: i3__namespace$1.Store }, { token: i1__namespace$1.UserService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    CsAgentAuthService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CsAgentAuthService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: CsAgentAuthService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace$1.AuthService }, { type: AsmAuthStorageService }, { type: i1__namespace$1.UserIdService }, { type: i1__namespace$1.OAuthLibWrapperService }, { type: i3__namespace$1.Store }, { type: i1__namespace$1.UserService }]; } });

    /**
     * Overrides `AuthHttpHeaderService` to handle asm calls as well (not only OCC)
     * in cases of normal user session and on customer emulation.
     */
    var AsmAuthHttpHeaderService = /** @class */ (function (_super) {
        __extends(AsmAuthHttpHeaderService, _super);
        function AsmAuthHttpHeaderService(authService, authStorageService, csAgentAuthService, oAuthLibWrapperService, routingService, globalMessageService, occEndpointsService, authRedirectService) {
            var _this = _super.call(this, authService, authStorageService, oAuthLibWrapperService, routingService, occEndpointsService, globalMessageService, authRedirectService) || this;
            _this.authService = authService;
            _this.authStorageService = authStorageService;
            _this.csAgentAuthService = csAgentAuthService;
            _this.oAuthLibWrapperService = oAuthLibWrapperService;
            _this.routingService = routingService;
            _this.globalMessageService = globalMessageService;
            _this.occEndpointsService = occEndpointsService;
            _this.authRedirectService = authRedirectService;
            return _this;
        }
        /**
         * Checks if the authorization header should be added to the request
         *
         *  @override
         */
        AsmAuthHttpHeaderService.prototype.shouldAddAuthorizationHeader = function (request) {
            return (_super.prototype.shouldAddAuthorizationHeader.call(this, request) ||
                this.isCSAgentTokenRequest(request));
        };
        /**
         * @override
         *
         * Checks if particular request should be handled by this service.
         */
        AsmAuthHttpHeaderService.prototype.shouldCatchError = function (request) {
            return (_super.prototype.shouldCatchError.call(this, request) || this.isCSAgentTokenRequest(request));
        };
        /**
         * @override
         *
         * Adds `Authorization` header to occ and CS agent requests.
         * For CS agent requests also removes the `cx-use-csagent-token` header (to avoid problems with CORS).
         */
        AsmAuthHttpHeaderService.prototype.alterRequest = function (request, token) {
            var hasAuthorizationHeader = !!this.getAuthorizationHeader(request);
            var isCSAgentRequest = this.isCSAgentTokenRequest(request);
            var req = _super.prototype.alterRequest.call(this, request, token);
            if (!hasAuthorizationHeader && isCSAgentRequest) {
                req = request.clone({
                    setHeaders: Object.assign({}, this.createAuthorizationHeader(token)),
                });
                return i1$1.InterceptorUtil.removeHeader(i1$1.USE_CUSTOMER_SUPPORT_AGENT_TOKEN, req);
            }
            return req;
        };
        AsmAuthHttpHeaderService.prototype.isCSAgentTokenRequest = function (request) {
            var isRequestWithCSAgentToken = i1$1.InterceptorUtil.getInterceptorParam(i1$1.USE_CUSTOMER_SUPPORT_AGENT_TOKEN, request.headers);
            return Boolean(isRequestWithCSAgentToken);
        };
        /**
         * @override
         *
         * On backend errors indicating expired `refresh_token` we need to logout
         * currently logged in user and CS agent.
         */
        AsmAuthHttpHeaderService.prototype.handleExpiredRefreshToken = function () {
            var _this = this;
            this.csAgentAuthService
                .isCustomerSupportAgentLoggedIn()
                .pipe(operators.take(1))
                .subscribe(function (csAgentLoggedIn) {
                if (csAgentLoggedIn) {
                    _this.authService.setLogoutProgress(true);
                    _this.csAgentAuthService.logoutCustomerSupportAgent();
                    _this.globalMessageService.add({
                        key: 'asm.csagentTokenExpired',
                    }, i1$1.GlobalMessageType.MSG_TYPE_ERROR);
                }
                else {
                    _super.prototype.handleExpiredRefreshToken.call(_this);
                }
            });
        };
        return AsmAuthHttpHeaderService;
    }(i1$1.AuthHttpHeaderService));
    AsmAuthHttpHeaderService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AsmAuthHttpHeaderService, deps: [{ token: i1__namespace$1.AuthService }, { token: i1__namespace$1.AuthStorageService }, { token: CsAgentAuthService }, { token: i1__namespace$1.OAuthLibWrapperService }, { token: i1__namespace$1.RoutingService }, { token: i1__namespace$1.GlobalMessageService }, { token: i1__namespace$1.OccEndpointsService }, { token: i1__namespace$1.AuthRedirectService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    AsmAuthHttpHeaderService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AsmAuthHttpHeaderService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AsmAuthHttpHeaderService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace$1.AuthService }, { type: i1__namespace$1.AuthStorageService }, { type: CsAgentAuthService }, { type: i1__namespace$1.OAuthLibWrapperService }, { type: i1__namespace$1.RoutingService }, { type: i1__namespace$1.GlobalMessageService }, { type: i1__namespace$1.OccEndpointsService }, { type: i1__namespace$1.AuthRedirectService }]; } });

    /**
     * Version of AuthService that is working for both user na CS agent.
     * Overrides AuthService when ASM module is enabled.
     */
    var AsmAuthService = /** @class */ (function (_super_1) {
        __extends(AsmAuthService, _super_1);
        function AsmAuthService(store, userIdService, oAuthLibWrapperService, authStorageService, authRedirectService, globalMessageService, routingService) {
            var _this = _super_1.call(this, store, userIdService, oAuthLibWrapperService, authStorageService, authRedirectService, routingService) || this;
            _this.store = store;
            _this.userIdService = userIdService;
            _this.oAuthLibWrapperService = oAuthLibWrapperService;
            _this.authStorageService = authStorageService;
            _this.authRedirectService = authRedirectService;
            _this.globalMessageService = globalMessageService;
            _this.routingService = routingService;
            return _this;
        }
        AsmAuthService.prototype.canUserLogin = function () {
            var tokenTarget;
            var token;
            this.authStorageService
                .getToken()
                .subscribe(function (tok) { return (token = tok); })
                .unsubscribe();
            this.authStorageService
                .getTokenTarget()
                .subscribe(function (tokTarget) { return (tokenTarget = tokTarget); })
                .unsubscribe();
            return !(Boolean(token === null || token === void 0 ? void 0 : token.access_token) && tokenTarget === exports.TokenTarget.CSAgent);
        };
        AsmAuthService.prototype.warnAboutLoggedCSAgent = function () {
            this.globalMessageService.add({
                key: 'asm.auth.agentLoggedInError',
            }, i1$1.GlobalMessageType.MSG_TYPE_ERROR);
        };
        /**
         * Loads a new user token with Resource Owner Password Flow when CS agent is not logged in.
         * @param userId
         * @param password
         */
        AsmAuthService.prototype.loginWithCredentials = function (userId, password) {
            var _super = Object.create(null, {
                loginWithCredentials: { get: function () { return _super_1.prototype.loginWithCredentials; } }
            });
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!this.canUserLogin()) return [3 /*break*/, 2];
                            return [4 /*yield*/, _super.loginWithCredentials.call(this, userId, password)];
                        case 1:
                            _a.sent();
                            return [3 /*break*/, 3];
                        case 2:
                            this.warnAboutLoggedCSAgent();
                            _a.label = 3;
                        case 3: return [2 /*return*/];
                    }
                });
            });
        };
        /**
         * Initialize Implicit/Authorization Code flow by redirecting to OAuth server when CS agent is not logged in.
         */
        AsmAuthService.prototype.loginWithRedirect = function () {
            if (this.canUserLogin()) {
                _super_1.prototype.loginWithRedirect.call(this);
                return true;
            }
            else {
                this.warnAboutLoggedCSAgent();
                return false;
            }
        };
        /**
         * Revokes tokens and clears state for logged user (tokens, userId).
         * To perform logout it is best to use `logout` method. Use this method with caution.
         */
        AsmAuthService.prototype.coreLogout = function () {
            var _this = this;
            return this.userIdService
                .isEmulated()
                .pipe(operators.take(1), operators.switchMap(function (isEmulated) {
                if (isEmulated) {
                    _this.authStorageService.clearEmulatedUserToken();
                    _this.userIdService.clearUserId();
                    _this.store.dispatch(new i1$1.AuthActions.Logout());
                    return rxjs.of(true);
                }
                else {
                    return rxjs.from(_super_1.prototype.coreLogout.call(_this));
                }
            }))
                .toPromise();
        };
        /**
         * Returns `true` if user is logged in or being emulated.
         */
        AsmAuthService.prototype.isUserLoggedIn = function () {
            return rxjs.combineLatest([
                this.authStorageService.getToken(),
                this.userIdService.isEmulated(),
                this.authStorageService.getTokenTarget(),
            ]).pipe(operators.map(function (_a) {
                var _b = __read(_a, 3), token = _b[0], isEmulated = _b[1], tokenTarget = _b[2];
                return Boolean(token === null || token === void 0 ? void 0 : token.access_token) &&
                    (tokenTarget === exports.TokenTarget.User ||
                        (tokenTarget === exports.TokenTarget.CSAgent && isEmulated));
            }));
        };
        return AsmAuthService;
    }(i1$1.AuthService));
    AsmAuthService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AsmAuthService, deps: [{ token: i3__namespace$1.Store }, { token: i1__namespace$1.UserIdService }, { token: i1__namespace$1.OAuthLibWrapperService }, { token: AsmAuthStorageService }, { token: i1__namespace$1.AuthRedirectService }, { token: i1__namespace$1.GlobalMessageService }, { token: i1__namespace$1.RoutingService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    AsmAuthService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AsmAuthService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AsmAuthService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: i3__namespace$1.Store }, { type: i1__namespace$1.UserIdService }, { type: i1__namespace$1.OAuthLibWrapperService }, { type: AsmAuthStorageService }, { type: i1__namespace$1.AuthRedirectService }, { type: i1__namespace$1.GlobalMessageService }, { type: i1__namespace$1.RoutingService }]; } });

    var AsmRootModule = /** @class */ (function () {
        function AsmRootModule() {
        }
        return AsmRootModule;
    }());
    AsmRootModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AsmRootModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    AsmRootModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AsmRootModule, imports: [AsmLoaderModule] });
    AsmRootModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AsmRootModule, providers: [
            {
                provide: i1$1.AuthStorageService,
                useExisting: AsmAuthStorageService,
            },
            {
                provide: i1$1.AuthService,
                useExisting: AsmAuthService,
            },
            {
                provide: i1$1.AuthHttpHeaderService,
                useExisting: AsmAuthHttpHeaderService,
            },
        ], imports: [[AsmLoaderModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0__namespace, type: AsmRootModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [AsmLoaderModule],
                        providers: [
                            {
                                provide: i1$1.AuthStorageService,
                                useExisting: AsmAuthStorageService,
                            },
                            {
                                provide: i1$1.AuthService,
                                useExisting: AsmAuthService,
                            },
                            {
                                provide: i1$1.AuthHttpHeaderService,
                                useExisting: AsmAuthHttpHeaderService,
                            },
                        ],
                    }]
            }] });

    var ASM_FEATURE = 'asm';

    /**
     * Generated bundle index. Do not edit.
     */

    exports.ASM_ENABLED_LOCAL_STORAGE_KEY = ASM_ENABLED_LOCAL_STORAGE_KEY;
    exports.ASM_FEATURE = ASM_FEATURE;
    exports.AsmAuthHttpHeaderService = AsmAuthHttpHeaderService;
    exports.AsmAuthService = AsmAuthService;
    exports.AsmAuthStorageService = AsmAuthStorageService;
    exports.AsmEnablerService = AsmEnablerService;
    exports.AsmLoaderModule = AsmLoaderModule;
    exports.AsmRootModule = AsmRootModule;
    exports.CsAgentAuthService = CsAgentAuthService;
    exports.asmFactory = asmFactory;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=spartacus-asm-root.umd.js.map
