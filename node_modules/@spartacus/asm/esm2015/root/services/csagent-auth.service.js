import { __awaiter } from "tslib";
import { Injectable } from '@angular/core';
import { AuthActions, OCC_USER_ID_ANONYMOUS, OCC_USER_ID_CURRENT, } from '@spartacus/core';
import { combineLatest, of } from 'rxjs';
import { map } from 'rxjs/operators';
import { TokenTarget } from './asm-auth-storage.service';
import * as i0 from "@angular/core";
import * as i1 from "@spartacus/core";
import * as i2 from "./asm-auth-storage.service";
import * as i3 from "@ngrx/store";
/**
 * Auth service for CS agent. Useful to login/logout agent, start emulation
 * or get information about the status of emulation.
 */
export class CsAgentAuthService {
    constructor(authService, authStorageService, userIdService, oAuthLibWrapperService, store, userService) {
        this.authService = authService;
        this.authStorageService = authStorageService;
        this.userIdService = userIdService;
        this.oAuthLibWrapperService = oAuthLibWrapperService;
        this.store = store;
        this.userService = userService;
    }
    /**
     * Loads access token for a customer support agent.
     * @param userId
     * @param password
     */
    authorizeCustomerSupportAgent(userId, password) {
        return __awaiter(this, void 0, void 0, function* () {
            let userToken;
            this.authStorageService
                .getToken()
                .subscribe((token) => (userToken = token))
                .unsubscribe();
            this.authStorageService.switchTokenTargetToCSAgent();
            try {
                yield this.oAuthLibWrapperService.authorizeWithPasswordFlow(userId, password);
                // Start emulation for currently logged in user
                let customerId;
                this.userService
                    .get()
                    .subscribe((user) => (customerId = user === null || user === void 0 ? void 0 : user.customerId))
                    .unsubscribe();
                this.store.dispatch(new AuthActions.Logout());
                if (customerId !== undefined && userToken !== undefined) {
                    // OCC specific user id handling. Customize when implementing different backend
                    this.userIdService.setUserId(customerId);
                    this.authStorageService.setEmulatedUserToken(userToken);
                    this.store.dispatch(new AuthActions.Login());
                }
                else {
                    // When we can't get the customerId just end all current sessions
                    this.userIdService.setUserId(OCC_USER_ID_ANONYMOUS);
                    this.authStorageService.clearEmulatedUserToken();
                }
            }
            catch (_a) {
                this.authStorageService.switchTokenTargetToUser();
            }
        });
    }
    /**
     * Starts an ASM customer emulation session.
     * A customer emulation session is stopped by calling logout().
     * @param customerId
     */
    startCustomerEmulationSession(customerId) {
        this.authStorageService.clearEmulatedUserToken();
        // OCC specific user id handling. Customize when implementing different backend
        this.store.dispatch(new AuthActions.Logout());
        this.userIdService.setUserId(customerId);
        this.store.dispatch(new AuthActions.Login());
    }
    /**
     * Check if CS agent is currently logged in.
     *
     * @returns observable emitting true when CS agent is logged in or false when not.
     */
    isCustomerSupportAgentLoggedIn() {
        return combineLatest([
            this.authStorageService.getToken(),
            this.authStorageService.getTokenTarget(),
        ]).pipe(map(([token, tokenTarget]) => Boolean((token === null || token === void 0 ? void 0 : token.access_token) && tokenTarget === TokenTarget.CSAgent)));
    }
    /**
     * Utility function to determine if customer is emulated.
     *
     * @returns observable emitting true when there is active emulation session or false when not.
     */
    isCustomerEmulated() {
        return this.userIdService.isEmulated();
    }
    /**
     * Returns the customer support agent's token loading status
     */
    getCustomerSupportAgentTokenLoading() {
        // TODO(#8248): Create new loading state outside of store
        return of(false);
    }
    /**
     * Logout a customer support agent.
     */
    logoutCustomerSupportAgent() {
        return __awaiter(this, void 0, void 0, function* () {
            const emulatedToken = this.authStorageService.getEmulatedUserToken();
            let isCustomerEmulated;
            this.userIdService
                .isEmulated()
                .subscribe((emulated) => (isCustomerEmulated = emulated))
                .unsubscribe();
            yield this.oAuthLibWrapperService.revokeAndLogout();
            this.store.dispatch({ type: '[Auth] Logout Customer Support Agent' });
            this.authStorageService.setTokenTarget(TokenTarget.User);
            if (isCustomerEmulated && emulatedToken) {
                this.store.dispatch(new AuthActions.Logout());
                this.authStorageService.setToken(emulatedToken);
                this.userIdService.setUserId(OCC_USER_ID_CURRENT);
                this.authStorageService.clearEmulatedUserToken();
                this.store.dispatch(new AuthActions.Login());
            }
            else {
                this.authService.logout();
            }
        });
    }
}
CsAgentAuthService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CsAgentAuthService, deps: [{ token: i1.AuthService }, { token: i2.AsmAuthStorageService }, { token: i1.UserIdService }, { token: i1.OAuthLibWrapperService }, { token: i3.Store }, { token: i1.UserService }], target: i0.ɵɵFactoryTarget.Injectable });
CsAgentAuthService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CsAgentAuthService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: CsAgentAuthService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.AuthService }, { type: i2.AsmAuthStorageService }, { type: i1.UserIdService }, { type: i1.OAuthLibWrapperService }, { type: i3.Store }, { type: i1.UserService }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY3NhZ2VudC1hdXRoLnNlcnZpY2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9mZWF0dXJlLWxpYnMvYXNtL3Jvb3Qvc2VydmljZXMvY3NhZ2VudC1hdXRoLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFFM0MsT0FBTyxFQUNMLFdBQVcsRUFJWCxxQkFBcUIsRUFDckIsbUJBQW1CLEdBR3BCLE1BQU0saUJBQWlCLENBQUM7QUFDekIsT0FBTyxFQUFFLGFBQWEsRUFBYyxFQUFFLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDckQsT0FBTyxFQUFFLEdBQUcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3JDLE9BQU8sRUFBeUIsV0FBVyxFQUFFLE1BQU0sNEJBQTRCLENBQUM7Ozs7O0FBRWhGOzs7R0FHRztBQUlILE1BQU0sT0FBTyxrQkFBa0I7SUFDN0IsWUFDWSxXQUF3QixFQUN4QixrQkFBeUMsRUFDekMsYUFBNEIsRUFDNUIsc0JBQThDLEVBQzlDLEtBQVksRUFDWixXQUF3QjtRQUx4QixnQkFBVyxHQUFYLFdBQVcsQ0FBYTtRQUN4Qix1QkFBa0IsR0FBbEIsa0JBQWtCLENBQXVCO1FBQ3pDLGtCQUFhLEdBQWIsYUFBYSxDQUFlO1FBQzVCLDJCQUFzQixHQUF0QixzQkFBc0IsQ0FBd0I7UUFDOUMsVUFBSyxHQUFMLEtBQUssQ0FBTztRQUNaLGdCQUFXLEdBQVgsV0FBVyxDQUFhO0lBQ2pDLENBQUM7SUFFSjs7OztPQUlHO0lBQ0csNkJBQTZCLENBQ2pDLE1BQWMsRUFDZCxRQUFnQjs7WUFFaEIsSUFBSSxTQUFnQyxDQUFDO1lBQ3JDLElBQUksQ0FBQyxrQkFBa0I7aUJBQ3BCLFFBQVEsRUFBRTtpQkFDVixTQUFTLENBQUMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLENBQUMsU0FBUyxHQUFHLEtBQUssQ0FBQyxDQUFDO2lCQUN6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Q1osU0FBUyxDQUFDLENBQUMsUUFBUSxFQUFFLEVBQUUsQ0FBQyxDQUFDLGtCQUFrQixHQUFHLFFBQVEsQ0FBQyxDQUFDO2lCQUN4RCxXQUFXLEVBQUUsQ0FBQztZQUVqQixNQUFNLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxlQUFlLEVBQUUsQ0FBQztZQUVwRCxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxFQUFFLElBQUksRUFBRSxzQ0FBc0MsRUFBRSxDQUFDLENBQUM7WUFDdEUsSUFBSSxDQUFDLGtCQUFrQixDQUFDLGNBQWMsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUM7WUFFekQsSUFBSSxrQkFBa0IsSUFBSSxhQUFhLEVBQUU7Z0JBQ3ZDLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLElBQUksV0FBVyxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUM7Z0JBQzlDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxRQUFRLENBQUMsYUFBYSxDQUFDLENBQUM7Z0JBQ2hELElBQUksQ0FBQyxhQUFhLENBQUMsU0FBUyxDQUFDLG1CQUFtQixDQUFDLENBQUM7Z0JBQ2xELElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxzQkFBc0IsRUFBRSxDQUFDO2dCQUNqRCxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxJQUFJLFdBQVcsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDO2FBQzlDO2lCQUFNO2dCQUNMLElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxFQUFFLENBQUM7YUFDM0I7UUFDSCxDQUFDO0tBQUE7OytHQS9IVSxrQkFBa0I7bUhBQWxCLGtCQUFrQixjQUZqQixNQUFNOzJGQUVQLGtCQUFrQjtrQkFIOUIsVUFBVTttQkFBQztvQkFDVixVQUFVLEVBQUUsTUFBTTtpQkFDbkIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdG9yZSB9IGZyb20gJ0BuZ3J4L3N0b3JlJztcbmltcG9ydCB7XG4gIEF1dGhBY3Rpb25zLFxuICBBdXRoU2VydmljZSxcbiAgQXV0aFRva2VuLFxuICBPQXV0aExpYldyYXBwZXJTZXJ2aWNlLFxuICBPQ0NfVVNFUl9JRF9BTk9OWU1PVVMsXG4gIE9DQ19VU0VSX0lEX0NVUlJFTlQsXG4gIFVzZXJJZFNlcnZpY2UsXG4gIFVzZXJTZXJ2aWNlLFxufSBmcm9tICdAc3BhcnRhY3VzL2NvcmUnO1xuaW1wb3J0IHsgY29tYmluZUxhdGVzdCwgT2JzZXJ2YWJsZSwgb2YgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IG1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IEFzbUF1dGhTdG9yYWdlU2VydmljZSwgVG9rZW5UYXJnZXQgfSBmcm9tICcuL2FzbS1hdXRoLXN0b3JhZ2Uuc2VydmljZSc7XG5cbi8qKlxuICogQXV0aCBzZXJ2aWNlIGZvciBDUyBhZ2VudC4gVXNlZnVsIHRvIGxvZ2luL2xvZ291dCBhZ2VudCwgc3RhcnQgZW11bGF0aW9uXG4gKiBvciBnZXQgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHN0YXR1cyBvZiBlbXVsYXRpb24uXG4gKi9cbkBJbmplY3RhYmxlKHtcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnLFxufSlcbmV4cG9ydCBjbGFzcyBDc0FnZW50QXV0aFNlcnZpY2Uge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcm90ZWN0ZWQgYXV0aFNlcnZpY2U6IEF1dGhTZXJ2aWNlLFxuICAgIHByb3RlY3RlZCBhdXRoU3RvcmFnZVNlcnZpY2U6IEFzbUF1dGhTdG9yYWdlU2VydmljZSxcbiAgICBwcm90ZWN0ZWQgdXNlcklkU2VydmljZTogVXNlcklkU2VydmljZSxcbiAgICBwcm90ZWN0ZWQgb0F1dGhMaWJXcmFwcGVyU2VydmljZTogT0F1dGhMaWJXcmFwcGVyU2VydmljZSxcbiAgICBwcm90ZWN0ZWQgc3RvcmU6IFN0b3JlLFxuICAgIHByb3RlY3RlZCB1c2VyU2VydmljZTogVXNlclNlcnZpY2VcbiAgKSB7fVxuXG4gIC8qKlxuICAgKiBMb2FkcyBhY2Nlc3MgdG9rZW4gZm9yIGEgY3VzdG9tZXIgc3VwcG9ydCBhZ2VudC5cbiAgICogQHBhcmFtIHVzZXJJZFxuICAgKiBAcGFyYW0gcGFzc3dvcmRcbiAgICovXG4gIGFzeW5jIGF1dGhvcml6ZUN1c3RvbWVyU3VwcG9ydEFnZW50KFxuICAgIHVzZXJJZDogc3RyaW5nLFxuICAgIHBhc3N3b3JkOiBzdHJpbmdcbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgbGV0IHVzZXJUb2tlbjogQXV0aFRva2VuIHwgdW5kZWZpbmVkO1xuICAgIHRoaXMuYXV0aFN0b3JhZ2VTZXJ2aWNlXG4gICAgICAuZ2V0VG9rZW4oKVxuICAgICAgLnN1YnNjcmliZSgodG9rZW4pID0+ICh1c2VyVG9rZW4gPSB0b2tlbikpXG4gICAgICAudW5zdWJzY3JpYmUoKTtcblxuICAgIHRoaXMuYXV0aFN0b3JhZ2VTZXJ2aWNlLnN3aXRjaFRva2VuVGFyZ2V0VG9DU0FnZW50KCk7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMub0F1dGhMaWJXcmFwcGVyU2VydmljZS5hdXRob3JpemVXaXRoUGFzc3dvcmRGbG93KFxuICAgICAgICB1c2VySWQsXG4gICAgICAgIHBhc3N3b3JkXG4gICAgICApO1xuICAgICAgLy8gU3RhcnQgZW11bGF0aW9uIGZvciBjdXJyZW50bHkgbG9nZ2VkIGluIHVzZXJcbiAgICAgIGxldCBjdXN0b21lcklkOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgICB0aGlzLnVzZXJTZXJ2aWNlXG4gICAgICAgIC5nZXQoKVxuICAgICAgICAuc3Vic2NyaWJlKCh1c2VyKSA9PiAoY3VzdG9tZXJJZCA9IHVzZXI/LmN1c3RvbWVySWQpKVxuICAgICAgICAudW5zdWJzY3JpYmUoKTtcbiAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2gobmV3IEF1dGhBY3Rpb25zLkxvZ291dCgpKTtcblxuICAgICAgaWYgKGN1c3RvbWVySWQgIT09IHVuZGVmaW5lZCAmJiB1c2VyVG9rZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBPQ0Mgc3BlY2lmaWMgdXNlciBpZCBoYW5kbGluZy4gQ3VzdG9taXplIHdoZW4gaW1wbGVtZW50aW5nIGRpZmZlcmVudCBiYWNrZW5kXG4gICAgICAgIHRoaXMudXNlcklkU2VydmljZS5zZXRVc2VySWQoY3VzdG9tZXJJZCk7XG4gICAgICAgIHRoaXMuYXV0aFN0b3JhZ2VTZXJ2aWNlLnNldEVtdWxhdGVkVXNlclRva2VuKHVzZXJUb2tlbik7XG4gICAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2gobmV3IEF1dGhBY3Rpb25zLkxvZ2luKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gV2hlbiB3ZSBjYW4ndCBnZXQgdGhlIGN1c3RvbWVySWQganVzdCBlbmQgYWxsIGN1cnJlbnQgc2Vzc2lvbnNcbiAgICAgICAgdGhpcy51c2VySWRTZXJ2aWNlLnNldFVzZXJJZChPQ0NfVVNFUl9JRF9BTk9OWU1PVVMpO1xuICAgICAgICB0aGlzLmF1dGhTdG9yYWdlU2VydmljZS5jbGVhckVtdWxhdGVkVXNlclRva2VuKCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCB7XG4gICAgICB0aGlzLmF1dGhTdG9yYWdlU2VydmljZS5zd2l0Y2hUb2tlblRhcmdldFRvVXNlcigpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydHMgYW4gQVNNIGN1c3RvbWVyIGVtdWxhdGlvbiBzZXNzaW9uLlxuICAgKiBBIGN1c3RvbWVyIGVtdWxhdGlvbiBzZXNzaW9uIGlzIHN0b3BwZWQgYnkgY2FsbGluZyBsb2dvdXQoKS5cbiAgICogQHBhcmFtIGN1c3RvbWVySWRcbiAgICovXG4gIHB1YmxpYyBzdGFydEN1c3RvbWVyRW11bGF0aW9uU2Vzc2lvbihjdXN0b21lcklkOiBzdHJpbmcpOiB2b2lkIHtcbiAgICB0aGlzLmF1dGhTdG9yYWdlU2VydmljZS5jbGVhckVtdWxhdGVkVXNlclRva2VuKCk7XG5cbiAgICAvLyBPQ0Mgc3BlY2lmaWMgdXNlciBpZCBoYW5kbGluZy4gQ3VzdG9taXplIHdoZW4gaW1wbGVtZW50aW5nIGRpZmZlcmVudCBiYWNrZW5kXG4gICAgdGhpcy5zdG9yZS5kaXNwYXRjaChuZXcgQXV0aEFjdGlvbnMuTG9nb3V0KCkpO1xuICAgIHRoaXMudXNlcklkU2VydmljZS5zZXRVc2VySWQoY3VzdG9tZXJJZCk7XG4gICAgdGhpcy5zdG9yZS5kaXNwYXRjaChuZXcgQXV0aEFjdGlvbnMuTG9naW4oKSk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgQ1MgYWdlbnQgaXMgY3VycmVudGx5IGxvZ2dlZCBpbi5cbiAgICpcbiAgICogQHJldHVybnMgb2JzZXJ2YWJsZSBlbWl0dGluZyB0cnVlIHdoZW4gQ1MgYWdlbnQgaXMgbG9nZ2VkIGluIG9yIGZhbHNlIHdoZW4gbm90LlxuICAgKi9cbiAgcHVibGljIGlzQ3VzdG9tZXJTdXBwb3J0QWdlbnRMb2dnZWRJbigpOiBPYnNlcnZhYmxlPGJvb2xlYW4+IHtcbiAgICByZXR1cm4gY29tYmluZUxhdGVzdChbXG4gICAgICB0aGlzLmF1dGhTdG9yYWdlU2VydmljZS5nZXRUb2tlbigpLFxuICAgICAgdGhpcy5hdXRoU3RvcmFnZVNlcnZpY2UuZ2V0VG9rZW5UYXJnZXQoKSxcbiAgICBdKS5waXBlKFxuICAgICAgbWFwKChbdG9rZW4sIHRva2VuVGFyZ2V0XSkgPT5cbiAgICAgICAgQm9vbGVhbih0b2tlbj8uYWNjZXNzX3Rva2VuICYmIHRva2VuVGFyZ2V0ID09PSBUb2tlblRhcmdldC5DU0FnZW50KVxuICAgICAgKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogVXRpbGl0eSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgaWYgY3VzdG9tZXIgaXMgZW11bGF0ZWQuXG4gICAqXG4gICAqIEByZXR1cm5zIG9ic2VydmFibGUgZW1pdHRpbmcgdHJ1ZSB3aGVuIHRoZXJlIGlzIGFjdGl2ZSBlbXVsYXRpb24gc2Vzc2lvbiBvciBmYWxzZSB3aGVuIG5vdC5cbiAgICovXG4gIHB1YmxpYyBpc0N1c3RvbWVyRW11bGF0ZWQoKTogT2JzZXJ2YWJsZTxib29sZWFuPiB7XG4gICAgcmV0dXJuIHRoaXMudXNlcklkU2VydmljZS5pc0VtdWxhdGVkKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VzdG9tZXIgc3VwcG9ydCBhZ2VudCdzIHRva2VuIGxvYWRpbmcgc3RhdHVzXG4gICAqL1xuICBwdWJsaWMgZ2V0Q3VzdG9tZXJTdXBwb3J0QWdlbnRUb2tlbkxvYWRpbmcoKTogT2JzZXJ2YWJsZTxib29sZWFuPiB7XG4gICAgLy8gVE9ETygjODI0OCk6IENyZWF0ZSBuZXcgbG9hZGluZyBzdGF0ZSBvdXRzaWRlIG9mIHN0b3JlXG4gICAgcmV0dXJuIG9mKGZhbHNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2dvdXQgYSBjdXN0b21lciBzdXBwb3J0IGFnZW50LlxuICAgKi9cbiAgYXN5bmMgbG9nb3V0Q3VzdG9tZXJTdXBwb3J0QWdlbnQoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgZW11bGF0ZWRUb2tlbiA9IHRoaXMuYXV0aFN0b3JhZ2VTZXJ2aWNlLmdldEVtdWxhdGVkVXNlclRva2VuKCk7XG5cbiAgICBsZXQgaXNDdXN0b21lckVtdWxhdGVkO1xuICAgIHRoaXMudXNlcklkU2VydmljZVxuICAgICAgLmlzRW11bGF0ZWQoKVxuICAgICAgLnN1YnNjcmliZSgoZW11bGF0ZWQpID0+IChpc0N1c3RvbWVyRW11bGF0ZWQgPSBlbXVsYXRlZCkpXG4gICAgICAudW5zdWJzY3JpYmUoKTtcblxuICAgIGF3YWl0IHRoaXMub0F1dGhMaWJXcmFwcGVyU2VydmljZS5yZXZva2VBbmRMb2dvdXQoKTtcblxuICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goeyB0eXBlOiAnW0F1dGhdIExvZ291dCBDdXN0b21lciBTdXBwb3J0IEFnZW50JyB9KTtcbiAgICB0aGlzLmF1dGhTdG9yYWdlU2VydmljZS5zZXRUb2tlblRhcmdldChUb2tlblRhcmdldC5Vc2VyKTtcblxuICAgIGlmIChpc0N1c3RvbWVyRW11bGF0ZWQgJiYgZW11bGF0ZWRUb2tlbikge1xuICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaChuZXcgQXV0aEFjdGlvbnMuTG9nb3V0KCkpO1xuICAgICAgdGhpcy5hdXRoU3RvcmFnZVNlcnZpY2Uuc2V0VG9rZW4oZW11bGF0ZWRUb2tlbik7XG4gICAgICB0aGlzLnVzZXJJZFNlcnZpY2Uuc2V0VXNlcklkKE9DQ19VU0VSX0lEX0NVUlJFTlQpO1xuICAgICAgdGhpcy5hdXRoU3RvcmFnZVNlcnZpY2UuY2xlYXJFbXVsYXRlZFVzZXJUb2tlbigpO1xuICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaChuZXcgQXV0aEFjdGlvbnMuTG9naW4oKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXV0aFNlcnZpY2UubG9nb3V0KCk7XG4gICAgfVxuICB9XG59XG4iXX0=