import { Injectable } from '@angular/core';
import { select } from '@ngrx/store';
import { combineLatest, of, Subscription } from 'rxjs';
import { filter, map } from 'rxjs/operators';
import { AsmActions, AsmSelectors } from '../store';
import * as i0 from "@angular/core";
import * as i1 from "@spartacus/core";
import * as i2 from "@ngrx/store";
import * as i3 from "@spartacus/asm/root";
/**
 * Responsible for storing ASM state in the browser storage.
 * Uses `StatePersistenceService` mechanism.
 */
export class AsmStatePersistenceService {
    constructor(statePersistenceService, store, authStorageService) {
        this.statePersistenceService = statePersistenceService;
        this.store = store;
        this.authStorageService = authStorageService;
        this.subscription = new Subscription();
        /**
         * Identifier used for storage key.
         */
        this.key = 'asm';
    }
    /**
     * Initializes the synchronization between state and browser storage.
     */
    initSync() {
        this.subscription.add(this.statePersistenceService.syncWithStorage({
            key: this.key,
            state$: this.getAsmState(),
            onRead: (state) => this.onRead(state),
        }));
    }
    /**
     * Gets and transforms state from different sources into the form that should
     * be saved in storage.
     */
    getAsmState() {
        return combineLatest([
            this.store.pipe(
            // Since getAsmState() may be called while the module is lazy loded
            // The asm state slice may not exist yet in the first store emissions.
            filter((store) => !!store.asm), select(AsmSelectors.getAsmUi)),
            of(this.authStorageService.getEmulatedUserToken()),
            this.authStorageService.getTokenTarget(),
        ]).pipe(map(([ui, emulatedUserToken, tokenTarget]) => {
            let emulatedToken = emulatedUserToken;
            if (emulatedToken) {
                emulatedToken = Object.assign({}, emulatedUserToken);
                // To minimize risk of user account hijacking we don't persist emulated user refresh_token
                delete emulatedToken.refresh_token;
            }
            return {
                ui,
                emulatedUserToken: emulatedToken,
                tokenTarget,
            };
        }));
    }
    /**
     * Function called on each browser storage read.
     * Used to update state from browser -> state.
     */
    onRead(state) {
        if (state) {
            if (state.ui) {
                this.store.dispatch(new AsmActions.AsmUiUpdate(state.ui));
            }
            if (state.emulatedUserToken) {
                this.authStorageService.setEmulatedUserToken(state.emulatedUserToken);
            }
            if (state.tokenTarget) {
                this.authStorageService.setTokenTarget(state.tokenTarget);
            }
        }
    }
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
}
AsmStatePersistenceService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AsmStatePersistenceService, deps: [{ token: i1.StatePersistenceService }, { token: i2.Store }, { token: i3.AsmAuthStorageService }], target: i0.ɵɵFactoryTarget.Injectable });
AsmStatePersistenceService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AsmStatePersistenceService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AsmStatePersistenceService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.StatePersistenceService }, { type: i2.Store }, { type: i3.AsmAuthStorageService }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXNtLXN0YXRlLXBlcnNpc3RlbmNlLnNlcnZpY2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9mZWF0dXJlLWxpYnMvYXNtL2NvcmUvc2VydmljZXMvYXNtLXN0YXRlLXBlcnNpc3RlbmNlLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFVBQVUsRUFBYSxNQUFNLGVBQWUsQ0FBQztBQUN0RCxPQUFPLEVBQUUsTUFBTSxFQUFTLE1BQU0sYUFBYSxDQUFDO0FBRzVDLE9BQU8sRUFBRSxhQUFhLEVBQWMsRUFBRSxFQUFFLFlBQVksRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUNuRSxPQUFPLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRTdDLE9BQU8sRUFBRSxVQUFVLEVBQUUsWUFBWSxFQUFnQixNQUFNLFVBQVUsQ0FBQzs7Ozs7QUFXbEU7OztHQUdHO0FBSUgsTUFBTSxPQUFPLDBCQUEwQjtJQUdyQyxZQUNZLHVCQUFnRCxFQUNoRCxLQUEwQixFQUMxQixrQkFBeUM7UUFGekMsNEJBQXVCLEdBQXZCLHVCQUF1QixDQUF5QjtRQUNoRCxVQUFLLEdBQUwsS0FBSyxDQUFxQjtRQUMxQix1QkFBa0IsR0FBbEIsa0JBQWtCLENBQXVCO1FBTDNDLGlCQUFZLEdBQUcsSUFBSSxZQUFZLEVBQUUsQ0FBQztRQVE1Qzs7V0FFRztRQUNPLFFBQUcsR0FBRyxLQUFLLENBQUM7SUFMbkIsQ0FBQztJQU9KOztPQUVHO0lBQ0ksUUFBUTtRQUNiLElBQUksQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUNuQixJQUFJLENBQUMsdUJBQXVCLENBQUMsZUFBZSxDQUFDO1lBQzNDLEdBQUcsRUFBRSxJQUFJLENBQUMsR0FBRztZQUNiLE1BQU0sRUFBRSxJQUFJLENBQUMsV0FBVyxFQUFFO1lBQzFCLE1BQU0sRUFBRSxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUM7U0FDdEMsQ0FBQyxDQUNILENBQUM7SUFDSixDQUFDO0lBRUQ7OztPQUdHO0lBQ08sV0FBVztRQUNuQixPQUFPLGFBQWEsQ0FBQztZQUNuQixJQUFJLENBQUMsS0FBSyxDQUFDLElBQUk7WUFDYixtRUFBbUU7WUFDbkUsc0VBQXNFO1lBQ3RFLE1BQU0sQ0FBQyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsRUFDOUIsTUFBTSxDQUFDLFlBQVksQ0FBQyxRQUFRLENBQUMsQ0FDOUI7WUFDRCxFQUFFLENBQUMsSUFBSSxDQUFDLGtCQUFrQixDQUFDLG9CQUFvQixFQUFFLENBQUM7WUFDbEQsSUFBSSxDQUFDLGtCQUFrQixDQUFDLGNBQWMsRUFBRTtTQUN6QyxDQUFDLENBQUMsSUFBSSxDQUNMLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLGlCQUFpQixFQUFFLFdBQVcsQ0FBQyxFQUFFLEVBQUU7WUFDM0MsSUFBSSxhQUFhLEdBQUcsaUJBQWlCLENBQUM7WUFDdEMsSUFBSSxhQUFhLEVBQUU7Z0JBQ2pCLGFBQWEsR0FBRyxrQkFBSyxpQkFBaUIsQ0FBZSxDQUFDO2dCQUN0RCwwRkFBMEY7Z0JBQzFGLE9BQU8sYUFBYSxDQUFDLGFBQWEsQ0FBQzthQUNwQztZQUNELE9BQU87Z0JBQ0wsRUFBRTtnQkFDRixpQkFBaUIsRUFBRSxhQUFhO2dCQUNoQyxXQUFXO2FBQ1osQ0FBQztRQUNKLENBQUMsQ0FBQyxDQUNILENBQUM7SUFDSixDQUFDO0lBRUQ7OztPQUdHO0lBQ08sTUFBTSxDQUFDLEtBQWlDO1FBQ2hELElBQUksS0FBSyxFQUFFO1lBQ1QsSUFBSSxLQUFLLENBQUMsRUFBRSxFQUFFO2dCQUNaLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLElBQUksVUFBVSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQzthQUMzRDtZQUNELElBQUksS0FBSyxDQUFDLGlCQUFpQixFQUFFO2dCQUMzQixJQUFJLENBQUMsa0JBQWtCLENBQUMsb0JBQW9CLENBQUMsS0FBSyxDQUFDLGlCQUFpQixDQUFDLENBQUM7YUFDdkU7WUFDRCxJQUFJLEtBQUssQ0FBQyxXQUFXLEVBQUU7Z0JBQ3JCLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxjQUFjLENBQUMsS0FBSyxDQUFDLFdBQVcsQ0FBQyxDQUFDO2FBQzNEO1NBQ0Y7SUFDSCxDQUFDO0lBRUQsV0FBVztRQUNULElBQUksQ0FBQyxZQUFZLENBQUMsV0FBVyxFQUFFLENBQUM7SUFDbEMsQ0FBQzs7dUhBOUVVLDBCQUEwQjsySEFBMUIsMEJBQTBCLGNBRnpCLE1BQU07MkZBRVAsMEJBQTBCO2tCQUh0QyxVQUFVO21CQUFDO29CQUNWLFVBQVUsRUFBRSxNQUFNO2lCQUNuQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUsIE9uRGVzdHJveSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgc2VsZWN0LCBTdG9yZSB9IGZyb20gJ0BuZ3J4L3N0b3JlJztcbmltcG9ydCB7IEFzbUF1dGhTdG9yYWdlU2VydmljZSwgVG9rZW5UYXJnZXQgfSBmcm9tICdAc3BhcnRhY3VzL2FzbS9yb290JztcbmltcG9ydCB7IEF1dGhUb2tlbiwgU3RhdGVQZXJzaXN0ZW5jZVNlcnZpY2UgfSBmcm9tICdAc3BhcnRhY3VzL2NvcmUnO1xuaW1wb3J0IHsgY29tYmluZUxhdGVzdCwgT2JzZXJ2YWJsZSwgb2YsIFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgZmlsdGVyLCBtYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBBc21VaSB9IGZyb20gJy4uL21vZGVscy9hc20ubW9kZWxzJztcbmltcG9ydCB7IEFzbUFjdGlvbnMsIEFzbVNlbGVjdG9ycywgU3RhdGVXaXRoQXNtIH0gZnJvbSAnLi4vc3RvcmUnO1xuXG4vKipcbiAqIEFTTSBzdGF0ZSBzeW5jZWQgdG8gYnJvd3NlciBzdG9yYWdlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFN5bmNlZEFzbVN0YXRlIHtcbiAgdWk/OiBBc21VaTtcbiAgZW11bGF0ZWRVc2VyVG9rZW4/OiBBdXRoVG9rZW47XG4gIHRva2VuVGFyZ2V0PzogVG9rZW5UYXJnZXQ7XG59XG5cbi8qKlxuICogUmVzcG9uc2libGUgZm9yIHN0b3JpbmcgQVNNIHN0YXRlIGluIHRoZSBicm93c2VyIHN0b3JhZ2UuXG4gKiBVc2VzIGBTdGF0ZVBlcnNpc3RlbmNlU2VydmljZWAgbWVjaGFuaXNtLlxuICovXG5ASW5qZWN0YWJsZSh7XG4gIHByb3ZpZGVkSW46ICdyb290Jyxcbn0pXG5leHBvcnQgY2xhc3MgQXNtU3RhdGVQZXJzaXN0ZW5jZVNlcnZpY2UgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuICBwcm90ZWN0ZWQgc3Vic2NyaXB0aW9uID0gbmV3IFN1YnNjcmlwdGlvbigpO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByb3RlY3RlZCBzdGF0ZVBlcnNpc3RlbmNlU2VydmljZTogU3RhdGVQZXJzaXN0ZW5jZVNlcnZpY2UsXG4gICAgcHJvdGVjdGVkIHN0b3JlOiBTdG9yZTxTdGF0ZVdpdGhBc20+LFxuICAgIHByb3RlY3RlZCBhdXRoU3RvcmFnZVNlcnZpY2U6IEFzbUF1dGhTdG9yYWdlU2VydmljZVxuICApIHt9XG5cbiAgLyoqXG4gICAqIElkZW50aWZpZXIgdXNlZCBmb3Igc3RvcmFnZSBrZXkuXG4gICAqL1xuICBwcm90ZWN0ZWQga2V5ID0gJ2FzbSc7XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBzeW5jaHJvbml6YXRpb24gYmV0d2VlbiBzdGF0ZSBhbmQgYnJvd3NlciBzdG9yYWdlLlxuICAgKi9cbiAgcHVibGljIGluaXRTeW5jKCkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9uLmFkZChcbiAgICAgIHRoaXMuc3RhdGVQZXJzaXN0ZW5jZVNlcnZpY2Uuc3luY1dpdGhTdG9yYWdlKHtcbiAgICAgICAga2V5OiB0aGlzLmtleSxcbiAgICAgICAgc3RhdGUkOiB0aGlzLmdldEFzbVN0YXRlKCksXG4gICAgICAgIG9uUmVhZDogKHN0YXRlKSA9PiB0aGlzLm9uUmVhZChzdGF0ZSksXG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhbmQgdHJhbnNmb3JtcyBzdGF0ZSBmcm9tIGRpZmZlcmVudCBzb3VyY2VzIGludG8gdGhlIGZvcm0gdGhhdCBzaG91bGRcbiAgICogYmUgc2F2ZWQgaW4gc3RvcmFnZS5cbiAgICovXG4gIHByb3RlY3RlZCBnZXRBc21TdGF0ZSgpOiBPYnNlcnZhYmxlPFN5bmNlZEFzbVN0YXRlPiB7XG4gICAgcmV0dXJuIGNvbWJpbmVMYXRlc3QoW1xuICAgICAgdGhpcy5zdG9yZS5waXBlKFxuICAgICAgICAvLyBTaW5jZSBnZXRBc21TdGF0ZSgpIG1heSBiZSBjYWxsZWQgd2hpbGUgdGhlIG1vZHVsZSBpcyBsYXp5IGxvZGVkXG4gICAgICAgIC8vIFRoZSBhc20gc3RhdGUgc2xpY2UgbWF5IG5vdCBleGlzdCB5ZXQgaW4gdGhlIGZpcnN0IHN0b3JlIGVtaXNzaW9ucy5cbiAgICAgICAgZmlsdGVyKChzdG9yZSkgPT4gISFzdG9yZS5hc20pLFxuICAgICAgICBzZWxlY3QoQXNtU2VsZWN0b3JzLmdldEFzbVVpKVxuICAgICAgKSxcbiAgICAgIG9mKHRoaXMuYXV0aFN0b3JhZ2VTZXJ2aWNlLmdldEVtdWxhdGVkVXNlclRva2VuKCkpLFxuICAgICAgdGhpcy5hdXRoU3RvcmFnZVNlcnZpY2UuZ2V0VG9rZW5UYXJnZXQoKSxcbiAgICBdKS5waXBlKFxuICAgICAgbWFwKChbdWksIGVtdWxhdGVkVXNlclRva2VuLCB0b2tlblRhcmdldF0pID0+IHtcbiAgICAgICAgbGV0IGVtdWxhdGVkVG9rZW4gPSBlbXVsYXRlZFVzZXJUb2tlbjtcbiAgICAgICAgaWYgKGVtdWxhdGVkVG9rZW4pIHtcbiAgICAgICAgICBlbXVsYXRlZFRva2VuID0geyAuLi5lbXVsYXRlZFVzZXJUb2tlbiB9IGFzIEF1dGhUb2tlbjtcbiAgICAgICAgICAvLyBUbyBtaW5pbWl6ZSByaXNrIG9mIHVzZXIgYWNjb3VudCBoaWphY2tpbmcgd2UgZG9uJ3QgcGVyc2lzdCBlbXVsYXRlZCB1c2VyIHJlZnJlc2hfdG9rZW5cbiAgICAgICAgICBkZWxldGUgZW11bGF0ZWRUb2tlbi5yZWZyZXNoX3Rva2VuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdWksXG4gICAgICAgICAgZW11bGF0ZWRVc2VyVG9rZW46IGVtdWxhdGVkVG9rZW4sXG4gICAgICAgICAgdG9rZW5UYXJnZXQsXG4gICAgICAgIH07XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogRnVuY3Rpb24gY2FsbGVkIG9uIGVhY2ggYnJvd3NlciBzdG9yYWdlIHJlYWQuXG4gICAqIFVzZWQgdG8gdXBkYXRlIHN0YXRlIGZyb20gYnJvd3NlciAtPiBzdGF0ZS5cbiAgICovXG4gIHByb3RlY3RlZCBvblJlYWQoc3RhdGU6IFN5bmNlZEFzbVN0YXRlIHwgdW5kZWZpbmVkKSB7XG4gICAgaWYgKHN0YXRlKSB7XG4gICAgICBpZiAoc3RhdGUudWkpIHtcbiAgICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaChuZXcgQXNtQWN0aW9ucy5Bc21VaVVwZGF0ZShzdGF0ZS51aSkpO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLmVtdWxhdGVkVXNlclRva2VuKSB7XG4gICAgICAgIHRoaXMuYXV0aFN0b3JhZ2VTZXJ2aWNlLnNldEVtdWxhdGVkVXNlclRva2VuKHN0YXRlLmVtdWxhdGVkVXNlclRva2VuKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS50b2tlblRhcmdldCkge1xuICAgICAgICB0aGlzLmF1dGhTdG9yYWdlU2VydmljZS5zZXRUb2tlblRhcmdldChzdGF0ZS50b2tlblRhcmdldCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgfVxufVxuIl19